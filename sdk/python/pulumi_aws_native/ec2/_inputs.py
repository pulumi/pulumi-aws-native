# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'CapacityReservationFleetInstanceTypeSpecificationArgs',
    'CapacityReservationFleetInstanceTypeSpecificationArgsDict',
    'CapacityReservationFleetTagSpecificationArgs',
    'CapacityReservationFleetTagSpecificationArgsDict',
    'CapacityReservationFleetTagArgs',
    'CapacityReservationFleetTagArgsDict',
    'CapacityReservationTagSpecificationArgs',
    'CapacityReservationTagSpecificationArgsDict',
    'CapacityReservationTagArgs',
    'CapacityReservationTagArgsDict',
    'CpuOptionsPropertiesArgs',
    'CpuOptionsPropertiesArgsDict',
    'CreditSpecificationPropertiesArgs',
    'CreditSpecificationPropertiesArgsDict',
    'DestinationOptionsPropertiesArgs',
    'DestinationOptionsPropertiesArgsDict',
    'Ec2FleetAcceleratorCountRequestArgs',
    'Ec2FleetAcceleratorCountRequestArgsDict',
    'Ec2FleetAcceleratorTotalMemoryMiBRequestArgs',
    'Ec2FleetAcceleratorTotalMemoryMiBRequestArgsDict',
    'Ec2FleetBaselineEbsBandwidthMbpsRequestArgs',
    'Ec2FleetBaselineEbsBandwidthMbpsRequestArgsDict',
    'Ec2FleetBaselinePerformanceFactorsRequestArgs',
    'Ec2FleetBaselinePerformanceFactorsRequestArgsDict',
    'Ec2FleetBlockDeviceMappingArgs',
    'Ec2FleetBlockDeviceMappingArgsDict',
    'Ec2FleetCapacityRebalanceArgs',
    'Ec2FleetCapacityRebalanceArgsDict',
    'Ec2FleetCapacityReservationOptionsRequestArgs',
    'Ec2FleetCapacityReservationOptionsRequestArgsDict',
    'Ec2FleetCpuPerformanceFactorRequestArgs',
    'Ec2FleetCpuPerformanceFactorRequestArgsDict',
    'Ec2FleetEbsBlockDeviceArgs',
    'Ec2FleetEbsBlockDeviceArgsDict',
    'Ec2FleetFleetLaunchTemplateConfigRequestArgs',
    'Ec2FleetFleetLaunchTemplateConfigRequestArgsDict',
    'Ec2FleetFleetLaunchTemplateOverridesRequestArgs',
    'Ec2FleetFleetLaunchTemplateOverridesRequestArgsDict',
    'Ec2FleetFleetLaunchTemplateSpecificationRequestArgs',
    'Ec2FleetFleetLaunchTemplateSpecificationRequestArgsDict',
    'Ec2FleetInstanceRequirementsRequestArgs',
    'Ec2FleetInstanceRequirementsRequestArgsDict',
    'Ec2FleetMaintenanceStrategiesArgs',
    'Ec2FleetMaintenanceStrategiesArgsDict',
    'Ec2FleetMemoryGiBPerVCpuRequestArgs',
    'Ec2FleetMemoryGiBPerVCpuRequestArgsDict',
    'Ec2FleetMemoryMiBRequestArgs',
    'Ec2FleetMemoryMiBRequestArgsDict',
    'Ec2FleetNetworkBandwidthGbpsRequestArgs',
    'Ec2FleetNetworkBandwidthGbpsRequestArgsDict',
    'Ec2FleetNetworkInterfaceCountRequestArgs',
    'Ec2FleetNetworkInterfaceCountRequestArgsDict',
    'Ec2FleetOnDemandOptionsRequestArgs',
    'Ec2FleetOnDemandOptionsRequestArgsDict',
    'Ec2FleetPerformanceFactorReferenceRequestArgs',
    'Ec2FleetPerformanceFactorReferenceRequestArgsDict',
    'Ec2FleetPlacementArgs',
    'Ec2FleetPlacementArgsDict',
    'Ec2FleetSpotOptionsRequestArgs',
    'Ec2FleetSpotOptionsRequestArgsDict',
    'Ec2FleetTagSpecificationArgs',
    'Ec2FleetTagSpecificationArgsDict',
    'Ec2FleetTagArgs',
    'Ec2FleetTagArgsDict',
    'Ec2FleetTargetCapacitySpecificationRequestArgs',
    'Ec2FleetTargetCapacitySpecificationRequestArgsDict',
    'Ec2FleetTotalLocalStorageGbRequestArgs',
    'Ec2FleetTotalLocalStorageGbRequestArgsDict',
    'Ec2FleetVCpuCountRangeRequestArgs',
    'Ec2FleetVCpuCountRangeRequestArgsDict',
    'EnclaveOptionsPropertiesArgs',
    'EnclaveOptionsPropertiesArgsDict',
    'HibernationOptionsPropertiesArgs',
    'HibernationOptionsPropertiesArgsDict',
    'InstanceAssociationParameterArgs',
    'InstanceAssociationParameterArgsDict',
    'InstanceBlockDeviceMappingArgs',
    'InstanceBlockDeviceMappingArgsDict',
    'InstanceEbsArgs',
    'InstanceEbsArgsDict',
    'InstanceElasticGpuSpecificationArgs',
    'InstanceElasticGpuSpecificationArgsDict',
    'InstanceElasticInferenceAcceleratorArgs',
    'InstanceElasticInferenceAcceleratorArgsDict',
    'InstanceEnaSrdSpecificationArgs',
    'InstanceEnaSrdSpecificationArgsDict',
    'InstanceEnaSrdUdpSpecificationArgs',
    'InstanceEnaSrdUdpSpecificationArgsDict',
    'InstanceIpv6AddressArgs',
    'InstanceIpv6AddressArgsDict',
    'InstanceLaunchTemplateSpecificationArgs',
    'InstanceLaunchTemplateSpecificationArgsDict',
    'InstanceLicenseSpecificationArgs',
    'InstanceLicenseSpecificationArgsDict',
    'InstanceMetadataOptionsArgs',
    'InstanceMetadataOptionsArgsDict',
    'InstanceNetworkInterfaceArgs',
    'InstanceNetworkInterfaceArgsDict',
    'InstancePrivateDnsNameOptionsArgs',
    'InstancePrivateDnsNameOptionsArgsDict',
    'InstancePrivateIpAddressSpecificationArgs',
    'InstancePrivateIpAddressSpecificationArgsDict',
    'InstanceSsmAssociationArgs',
    'InstanceSsmAssociationArgsDict',
    'InstanceVolumeArgs',
    'InstanceVolumeArgsDict',
    'IpamOperatingRegionArgs',
    'IpamOperatingRegionArgsDict',
    'IpamOrganizationalUnitExclusionArgs',
    'IpamOrganizationalUnitExclusionArgsDict',
    'IpamPoolProvisionedCidrArgs',
    'IpamPoolProvisionedCidrArgsDict',
    'IpamPoolSourceResourceArgs',
    'IpamPoolSourceResourceArgsDict',
    'IpamPoolTagArgs',
    'IpamPoolTagArgsDict',
    'IpamResourceDiscoveryIpamOperatingRegionArgs',
    'IpamResourceDiscoveryIpamOperatingRegionArgsDict',
    'IpamResourceDiscoveryOrganizationalUnitExclusionArgs',
    'IpamResourceDiscoveryOrganizationalUnitExclusionArgsDict',
    'LaunchTemplateAcceleratorCountArgs',
    'LaunchTemplateAcceleratorCountArgsDict',
    'LaunchTemplateAcceleratorTotalMemoryMiBArgs',
    'LaunchTemplateAcceleratorTotalMemoryMiBArgsDict',
    'LaunchTemplateBaselineEbsBandwidthMbpsArgs',
    'LaunchTemplateBaselineEbsBandwidthMbpsArgsDict',
    'LaunchTemplateBaselinePerformanceFactorsArgs',
    'LaunchTemplateBaselinePerformanceFactorsArgsDict',
    'LaunchTemplateBlockDeviceMappingArgs',
    'LaunchTemplateBlockDeviceMappingArgsDict',
    'LaunchTemplateCapacityReservationSpecificationArgs',
    'LaunchTemplateCapacityReservationSpecificationArgsDict',
    'LaunchTemplateCapacityReservationTargetArgs',
    'LaunchTemplateCapacityReservationTargetArgsDict',
    'LaunchTemplateConnectionTrackingSpecificationArgs',
    'LaunchTemplateConnectionTrackingSpecificationArgsDict',
    'LaunchTemplateCpuOptionsArgs',
    'LaunchTemplateCpuOptionsArgsDict',
    'LaunchTemplateCpuArgs',
    'LaunchTemplateCpuArgsDict',
    'LaunchTemplateCreditSpecificationArgs',
    'LaunchTemplateCreditSpecificationArgsDict',
    'LaunchTemplateDataArgs',
    'LaunchTemplateDataArgsDict',
    'LaunchTemplateEbsArgs',
    'LaunchTemplateEbsArgsDict',
    'LaunchTemplateEnaSrdSpecificationArgs',
    'LaunchTemplateEnaSrdSpecificationArgsDict',
    'LaunchTemplateEnaSrdUdpSpecificationArgs',
    'LaunchTemplateEnaSrdUdpSpecificationArgsDict',
    'LaunchTemplateEnclaveOptionsArgs',
    'LaunchTemplateEnclaveOptionsArgsDict',
    'LaunchTemplateHibernationOptionsArgs',
    'LaunchTemplateHibernationOptionsArgsDict',
    'LaunchTemplateIamInstanceProfileArgs',
    'LaunchTemplateIamInstanceProfileArgsDict',
    'LaunchTemplateInstanceMarketOptionsArgs',
    'LaunchTemplateInstanceMarketOptionsArgsDict',
    'LaunchTemplateInstanceRequirementsArgs',
    'LaunchTemplateInstanceRequirementsArgsDict',
    'LaunchTemplateIpv4PrefixSpecificationArgs',
    'LaunchTemplateIpv4PrefixSpecificationArgsDict',
    'LaunchTemplateIpv6AddArgs',
    'LaunchTemplateIpv6AddArgsDict',
    'LaunchTemplateIpv6PrefixSpecificationArgs',
    'LaunchTemplateIpv6PrefixSpecificationArgsDict',
    'LaunchTemplateLicenseSpecificationArgs',
    'LaunchTemplateLicenseSpecificationArgsDict',
    'LaunchTemplateMaintenanceOptionsArgs',
    'LaunchTemplateMaintenanceOptionsArgsDict',
    'LaunchTemplateMemoryGiBPerVCpuArgs',
    'LaunchTemplateMemoryGiBPerVCpuArgsDict',
    'LaunchTemplateMemoryMiBArgs',
    'LaunchTemplateMemoryMiBArgsDict',
    'LaunchTemplateMetadataOptionsArgs',
    'LaunchTemplateMetadataOptionsArgsDict',
    'LaunchTemplateMonitoringArgs',
    'LaunchTemplateMonitoringArgsDict',
    'LaunchTemplateNetworkBandwidthGbpsArgs',
    'LaunchTemplateNetworkBandwidthGbpsArgsDict',
    'LaunchTemplateNetworkInterfaceCountArgs',
    'LaunchTemplateNetworkInterfaceCountArgsDict',
    'LaunchTemplateNetworkInterfaceArgs',
    'LaunchTemplateNetworkInterfaceArgsDict',
    'LaunchTemplateNetworkPerformanceOptionsArgs',
    'LaunchTemplateNetworkPerformanceOptionsArgsDict',
    'LaunchTemplatePlacementArgs',
    'LaunchTemplatePlacementArgsDict',
    'LaunchTemplatePrivateDnsNameOptionsArgs',
    'LaunchTemplatePrivateDnsNameOptionsArgsDict',
    'LaunchTemplatePrivateIpAddArgs',
    'LaunchTemplatePrivateIpAddArgsDict',
    'LaunchTemplateReferenceArgs',
    'LaunchTemplateReferenceArgsDict',
    'LaunchTemplateSpotOptionsArgs',
    'LaunchTemplateSpotOptionsArgsDict',
    'LaunchTemplateTagSpecificationArgs',
    'LaunchTemplateTagSpecificationArgsDict',
    'LaunchTemplateTagArgs',
    'LaunchTemplateTagArgsDict',
    'LaunchTemplateTotalLocalStorageGbArgs',
    'LaunchTemplateTotalLocalStorageGbArgsDict',
    'LaunchTemplateVCpuCountArgs',
    'LaunchTemplateVCpuCountArgsDict',
    'NetworkInsightsAccessScopeAccessScopePathRequestArgs',
    'NetworkInsightsAccessScopeAccessScopePathRequestArgsDict',
    'NetworkInsightsAccessScopePacketHeaderStatementRequestArgs',
    'NetworkInsightsAccessScopePacketHeaderStatementRequestArgsDict',
    'NetworkInsightsAccessScopePathStatementRequestArgs',
    'NetworkInsightsAccessScopePathStatementRequestArgsDict',
    'NetworkInsightsAccessScopeResourceStatementRequestArgs',
    'NetworkInsightsAccessScopeResourceStatementRequestArgsDict',
    'NetworkInsightsAccessScopeThroughResourcesStatementRequestArgs',
    'NetworkInsightsAccessScopeThroughResourcesStatementRequestArgsDict',
    'NetworkInsightsPathFilterPortRangeArgs',
    'NetworkInsightsPathFilterPortRangeArgsDict',
    'NetworkInsightsPathPathFilterArgs',
    'NetworkInsightsPathPathFilterArgsDict',
    'NetworkInterfaceAttachmentEnaSrdSpecificationEnaSrdUdpSpecificationPropertiesArgs',
    'NetworkInterfaceAttachmentEnaSrdSpecificationEnaSrdUdpSpecificationPropertiesArgsDict',
    'NetworkInterfaceAttachmentEnaSrdSpecificationArgs',
    'NetworkInterfaceAttachmentEnaSrdSpecificationArgsDict',
    'NetworkInterfaceConnectionTrackingSpecificationArgs',
    'NetworkInterfaceConnectionTrackingSpecificationArgsDict',
    'NetworkInterfaceInstanceIpv6AddressArgs',
    'NetworkInterfaceInstanceIpv6AddressArgsDict',
    'NetworkInterfaceIpv4PrefixSpecificationArgs',
    'NetworkInterfaceIpv4PrefixSpecificationArgsDict',
    'NetworkInterfaceIpv6PrefixSpecificationArgs',
    'NetworkInterfaceIpv6PrefixSpecificationArgsDict',
    'NetworkInterfacePrivateIpAddressSpecificationArgs',
    'NetworkInterfacePrivateIpAddressSpecificationArgsDict',
    'OptionsPropertiesArgs',
    'OptionsPropertiesArgsDict',
    'PrefixListEntryArgs',
    'PrefixListEntryArgsDict',
    'PrivateDnsNameOptionsOnLaunchPropertiesArgs',
    'PrivateDnsNameOptionsOnLaunchPropertiesArgsDict',
    'RouteServerPeerBgpOptionsArgs',
    'RouteServerPeerBgpOptionsArgsDict',
    'SecurityGroupEgressArgs',
    'SecurityGroupEgressArgsDict',
    'SecurityGroupIngressArgs',
    'SecurityGroupIngressArgsDict',
    'SpotFleetAcceleratorCountRequestArgs',
    'SpotFleetAcceleratorCountRequestArgsDict',
    'SpotFleetAcceleratorTotalMemoryMiBRequestArgs',
    'SpotFleetAcceleratorTotalMemoryMiBRequestArgsDict',
    'SpotFleetBaselineEbsBandwidthMbpsRequestArgs',
    'SpotFleetBaselineEbsBandwidthMbpsRequestArgsDict',
    'SpotFleetBaselinePerformanceFactorsRequestArgs',
    'SpotFleetBaselinePerformanceFactorsRequestArgsDict',
    'SpotFleetBlockDeviceMappingArgs',
    'SpotFleetBlockDeviceMappingArgsDict',
    'SpotFleetClassicLoadBalancersConfigArgs',
    'SpotFleetClassicLoadBalancersConfigArgsDict',
    'SpotFleetClassicLoadBalancerArgs',
    'SpotFleetClassicLoadBalancerArgsDict',
    'SpotFleetCpuPerformanceFactorRequestArgs',
    'SpotFleetCpuPerformanceFactorRequestArgsDict',
    'SpotFleetEbsBlockDeviceArgs',
    'SpotFleetEbsBlockDeviceArgsDict',
    'SpotFleetFleetLaunchTemplateSpecificationArgs',
    'SpotFleetFleetLaunchTemplateSpecificationArgsDict',
    'SpotFleetGroupIdentifierArgs',
    'SpotFleetGroupIdentifierArgsDict',
    'SpotFleetIamInstanceProfileSpecificationArgs',
    'SpotFleetIamInstanceProfileSpecificationArgsDict',
    'SpotFleetInstanceIpv6AddressArgs',
    'SpotFleetInstanceIpv6AddressArgsDict',
    'SpotFleetInstanceNetworkInterfaceSpecificationArgs',
    'SpotFleetInstanceNetworkInterfaceSpecificationArgsDict',
    'SpotFleetInstanceRequirementsRequestArgs',
    'SpotFleetInstanceRequirementsRequestArgsDict',
    'SpotFleetLaunchSpecificationArgs',
    'SpotFleetLaunchSpecificationArgsDict',
    'SpotFleetLaunchTemplateConfigArgs',
    'SpotFleetLaunchTemplateConfigArgsDict',
    'SpotFleetLaunchTemplateOverridesArgs',
    'SpotFleetLaunchTemplateOverridesArgsDict',
    'SpotFleetLoadBalancersConfigArgs',
    'SpotFleetLoadBalancersConfigArgsDict',
    'SpotFleetMemoryGiBPerVCpuRequestArgs',
    'SpotFleetMemoryGiBPerVCpuRequestArgsDict',
    'SpotFleetMemoryMiBRequestArgs',
    'SpotFleetMemoryMiBRequestArgsDict',
    'SpotFleetMonitoringArgs',
    'SpotFleetMonitoringArgsDict',
    'SpotFleetNetworkBandwidthGbpsRequestArgs',
    'SpotFleetNetworkBandwidthGbpsRequestArgsDict',
    'SpotFleetNetworkInterfaceCountRequestArgs',
    'SpotFleetNetworkInterfaceCountRequestArgsDict',
    'SpotFleetPerformanceFactorReferenceRequestArgs',
    'SpotFleetPerformanceFactorReferenceRequestArgsDict',
    'SpotFleetPrivateIpAddressSpecificationArgs',
    'SpotFleetPrivateIpAddressSpecificationArgsDict',
    'SpotFleetRequestConfigDataArgs',
    'SpotFleetRequestConfigDataArgsDict',
    'SpotFleetSpotCapacityRebalanceArgs',
    'SpotFleetSpotCapacityRebalanceArgsDict',
    'SpotFleetSpotMaintenanceStrategiesArgs',
    'SpotFleetSpotMaintenanceStrategiesArgsDict',
    'SpotFleetSpotPlacementArgs',
    'SpotFleetSpotPlacementArgsDict',
    'SpotFleetTagSpecificationArgs',
    'SpotFleetTagSpecificationArgsDict',
    'SpotFleetTagArgs',
    'SpotFleetTagArgsDict',
    'SpotFleetTargetGroupsConfigArgs',
    'SpotFleetTargetGroupsConfigArgsDict',
    'SpotFleetTargetGroupArgs',
    'SpotFleetTargetGroupArgsDict',
    'SpotFleetTotalLocalStorageGbRequestArgs',
    'SpotFleetTotalLocalStorageGbRequestArgsDict',
    'SpotFleetVCpuCountRangeRequestArgs',
    'SpotFleetVCpuCountRangeRequestArgsDict',
    'SseSpecificationPropertiesArgs',
    'SseSpecificationPropertiesArgsDict',
    'TagSpecificationArgs',
    'TagSpecificationArgsDict',
    'TrafficMirrorFilterRuleTrafficMirrorPortRangeArgs',
    'TrafficMirrorFilterRuleTrafficMirrorPortRangeArgsDict',
    'TransitGatewayConnectOptionsArgs',
    'TransitGatewayConnectOptionsArgsDict',
    'TransitGatewayConnectPeerConfigurationArgs',
    'TransitGatewayConnectPeerConfigurationArgsDict',
    'TransitGatewayConnectPeerTransitGatewayAttachmentBgpConfigurationArgs',
    'TransitGatewayConnectPeerTransitGatewayAttachmentBgpConfigurationArgsDict',
    'VerifiedAccessEndpointCidrOptionsArgs',
    'VerifiedAccessEndpointCidrOptionsArgsDict',
    'VerifiedAccessEndpointLoadBalancerOptionsArgs',
    'VerifiedAccessEndpointLoadBalancerOptionsArgsDict',
    'VerifiedAccessEndpointNetworkInterfaceOptionsArgs',
    'VerifiedAccessEndpointNetworkInterfaceOptionsArgsDict',
    'VerifiedAccessEndpointPortRangeArgs',
    'VerifiedAccessEndpointPortRangeArgsDict',
    'VerifiedAccessEndpointRdsOptionsArgs',
    'VerifiedAccessEndpointRdsOptionsArgsDict',
    'VerifiedAccessEndpointSseSpecificationArgs',
    'VerifiedAccessEndpointSseSpecificationArgsDict',
    'VerifiedAccessGroupSseSpecificationArgs',
    'VerifiedAccessGroupSseSpecificationArgsDict',
    'VerifiedAccessInstanceVerifiedAccessLogsCloudWatchLogsPropertiesArgs',
    'VerifiedAccessInstanceVerifiedAccessLogsCloudWatchLogsPropertiesArgsDict',
    'VerifiedAccessInstanceVerifiedAccessLogsKinesisDataFirehosePropertiesArgs',
    'VerifiedAccessInstanceVerifiedAccessLogsKinesisDataFirehosePropertiesArgsDict',
    'VerifiedAccessInstanceVerifiedAccessLogsS3PropertiesArgs',
    'VerifiedAccessInstanceVerifiedAccessLogsS3PropertiesArgsDict',
    'VerifiedAccessInstanceVerifiedAccessLogsArgs',
    'VerifiedAccessInstanceVerifiedAccessLogsArgsDict',
    'VerifiedAccessInstanceVerifiedAccessTrustProviderArgs',
    'VerifiedAccessInstanceVerifiedAccessTrustProviderArgsDict',
    'VerifiedAccessTrustProviderDeviceOptionsArgs',
    'VerifiedAccessTrustProviderDeviceOptionsArgsDict',
    'VerifiedAccessTrustProviderNativeApplicationOidcOptionsArgs',
    'VerifiedAccessTrustProviderNativeApplicationOidcOptionsArgsDict',
    'VerifiedAccessTrustProviderOidcOptionsArgs',
    'VerifiedAccessTrustProviderOidcOptionsArgsDict',
    'VpcEndpointDnsOptionsSpecificationArgs',
    'VpcEndpointDnsOptionsSpecificationArgsDict',
    'VpnConnectionCloudwatchLogOptionsSpecificationArgs',
    'VpnConnectionCloudwatchLogOptionsSpecificationArgsDict',
    'VpnConnectionIkeVersionsRequestListValueArgs',
    'VpnConnectionIkeVersionsRequestListValueArgsDict',
    'VpnConnectionPhase1EncryptionAlgorithmsRequestListValueArgs',
    'VpnConnectionPhase1EncryptionAlgorithmsRequestListValueArgsDict',
    'VpnConnectionPhase1IntegrityAlgorithmsRequestListValueArgs',
    'VpnConnectionPhase1IntegrityAlgorithmsRequestListValueArgsDict',
    'VpnConnectionPhase1dhGroupNumbersRequestListValueArgs',
    'VpnConnectionPhase1dhGroupNumbersRequestListValueArgsDict',
    'VpnConnectionPhase2EncryptionAlgorithmsRequestListValueArgs',
    'VpnConnectionPhase2EncryptionAlgorithmsRequestListValueArgsDict',
    'VpnConnectionPhase2IntegrityAlgorithmsRequestListValueArgs',
    'VpnConnectionPhase2IntegrityAlgorithmsRequestListValueArgsDict',
    'VpnConnectionPhase2dhGroupNumbersRequestListValueArgs',
    'VpnConnectionPhase2dhGroupNumbersRequestListValueArgsDict',
    'VpnConnectionVpnTunnelLogOptionsSpecificationArgs',
    'VpnConnectionVpnTunnelLogOptionsSpecificationArgsDict',
    'VpnConnectionVpnTunnelOptionsSpecificationArgs',
    'VpnConnectionVpnTunnelOptionsSpecificationArgsDict',
]

MYPY = False

if not MYPY:
    class CapacityReservationFleetInstanceTypeSpecificationArgsDict(TypedDict):
        availability_zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Availability Zone in which the Capacity Reservation Fleet reserves the capacity. A Capacity Reservation Fleet can't span Availability Zones. All instance type specifications that you specify for the Fleet must use the same Availability Zone.
        """
        availability_zone_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the Availability Zone in which the Capacity Reservation Fleet reserves the capacity. A Capacity Reservation Fleet can't span Availability Zones. All instance type specifications that you specify for the Fleet must use the same Availability Zone.
        """
        ebs_optimized: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the Capacity Reservation Fleet supports EBS-optimized instances types. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using EBS-optimized instance types.
        """
        instance_platform: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of operating system for which the Capacity Reservation Fleet reserves capacity.
        """
        instance_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The instance type for which the Capacity Reservation Fleet reserves capacity.
        """
        priority: NotRequired[pulumi.Input[_builtins.int]]
        """
        The priority to assign to the instance type. This value is used to determine which of the instance types specified for the Fleet should be prioritized for use. A lower value indicates a high priority. For more information, see [Instance type priority](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#instance-priority) in the *Amazon EC2 User Guide* .
        """
        weight: NotRequired[pulumi.Input[_builtins.float]]
        """
        The number of capacity units provided by the specified instance type. This value, together with the total target capacity that you specify for the Fleet determine the number of instances for which the Fleet reserves capacity. Both values are based on units that make sense for your workload. For more information, see [Total target capacity](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#target-capacity) in the Amazon EC2 User Guide.

        Valid Range: Minimum value of `0.001` . Maximum value of `99.999` .
        """
elif False:
    CapacityReservationFleetInstanceTypeSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapacityReservationFleetInstanceTypeSpecificationArgs:
    def __init__(__self__, *,
                 availability_zone: Optional[pulumi.Input[_builtins.str]] = None,
                 availability_zone_id: Optional[pulumi.Input[_builtins.str]] = None,
                 ebs_optimized: Optional[pulumi.Input[_builtins.bool]] = None,
                 instance_platform: Optional[pulumi.Input[_builtins.str]] = None,
                 instance_type: Optional[pulumi.Input[_builtins.str]] = None,
                 priority: Optional[pulumi.Input[_builtins.int]] = None,
                 weight: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] availability_zone: The Availability Zone in which the Capacity Reservation Fleet reserves the capacity. A Capacity Reservation Fleet can't span Availability Zones. All instance type specifications that you specify for the Fleet must use the same Availability Zone.
        :param pulumi.Input[_builtins.str] availability_zone_id: The ID of the Availability Zone in which the Capacity Reservation Fleet reserves the capacity. A Capacity Reservation Fleet can't span Availability Zones. All instance type specifications that you specify for the Fleet must use the same Availability Zone.
        :param pulumi.Input[_builtins.bool] ebs_optimized: Indicates whether the Capacity Reservation Fleet supports EBS-optimized instances types. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using EBS-optimized instance types.
        :param pulumi.Input[_builtins.str] instance_platform: The type of operating system for which the Capacity Reservation Fleet reserves capacity.
        :param pulumi.Input[_builtins.str] instance_type: The instance type for which the Capacity Reservation Fleet reserves capacity.
        :param pulumi.Input[_builtins.int] priority: The priority to assign to the instance type. This value is used to determine which of the instance types specified for the Fleet should be prioritized for use. A lower value indicates a high priority. For more information, see [Instance type priority](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#instance-priority) in the *Amazon EC2 User Guide* .
        :param pulumi.Input[_builtins.float] weight: The number of capacity units provided by the specified instance type. This value, together with the total target capacity that you specify for the Fleet determine the number of instances for which the Fleet reserves capacity. Both values are based on units that make sense for your workload. For more information, see [Total target capacity](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#target-capacity) in the Amazon EC2 User Guide.
               
               Valid Range: Minimum value of `0.001` . Maximum value of `99.999` .
        """
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if availability_zone_id is not None:
            pulumi.set(__self__, "availability_zone_id", availability_zone_id)
        if ebs_optimized is not None:
            pulumi.set(__self__, "ebs_optimized", ebs_optimized)
        if instance_platform is not None:
            pulumi.set(__self__, "instance_platform", instance_platform)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Availability Zone in which the Capacity Reservation Fleet reserves the capacity. A Capacity Reservation Fleet can't span Availability Zones. All instance type specifications that you specify for the Fleet must use the same Availability Zone.
        """
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "availability_zone", value)

    @_builtins.property
    @pulumi.getter(name="availabilityZoneId")
    def availability_zone_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the Availability Zone in which the Capacity Reservation Fleet reserves the capacity. A Capacity Reservation Fleet can't span Availability Zones. All instance type specifications that you specify for the Fleet must use the same Availability Zone.
        """
        return pulumi.get(self, "availability_zone_id")

    @availability_zone_id.setter
    def availability_zone_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "availability_zone_id", value)

    @_builtins.property
    @pulumi.getter(name="ebsOptimized")
    def ebs_optimized(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the Capacity Reservation Fleet supports EBS-optimized instances types. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using EBS-optimized instance types.
        """
        return pulumi.get(self, "ebs_optimized")

    @ebs_optimized.setter
    def ebs_optimized(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ebs_optimized", value)

    @_builtins.property
    @pulumi.getter(name="instancePlatform")
    def instance_platform(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of operating system for which the Capacity Reservation Fleet reserves capacity.
        """
        return pulumi.get(self, "instance_platform")

    @instance_platform.setter
    def instance_platform(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_platform", value)

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The instance type for which the Capacity Reservation Fleet reserves capacity.
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_type", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The priority to assign to the instance type. This value is used to determine which of the instance types specified for the Fleet should be prioritized for use. A lower value indicates a high priority. For more information, see [Instance type priority](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#instance-priority) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The number of capacity units provided by the specified instance type. This value, together with the total target capacity that you specify for the Fleet determine the number of instances for which the Fleet reserves capacity. Both values are based on units that make sense for your workload. For more information, see [Total target capacity](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#target-capacity) in the Amazon EC2 User Guide.

        Valid Range: Minimum value of `0.001` . Maximum value of `99.999` .
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class CapacityReservationFleetTagSpecificationArgsDict(TypedDict):
        resource_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of resource to tag on creation. Specify `capacity-reservation-fleet` .

        To tag a resource after it has been created, see [CreateTags](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html) .
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['CapacityReservationFleetTagArgsDict']]]]
        """
        The tags to apply to the resource.
        """
elif False:
    CapacityReservationFleetTagSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapacityReservationFleetTagSpecificationArgs:
    def __init__(__self__, *,
                 resource_type: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['CapacityReservationFleetTagArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] resource_type: The type of resource to tag on creation. Specify `capacity-reservation-fleet` .
               
               To tag a resource after it has been created, see [CreateTags](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html) .
        :param pulumi.Input[Sequence[pulumi.Input['CapacityReservationFleetTagArgs']]] tags: The tags to apply to the resource.
        """
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of resource to tag on creation. Specify `capacity-reservation-fleet` .

        To tag a resource after it has been created, see [CreateTags](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html) .
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_type", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CapacityReservationFleetTagArgs']]]]:
        """
        The tags to apply to the resource.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CapacityReservationFleetTagArgs']]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class CapacityReservationFleetTagArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The tag key.
        """
        value: pulumi.Input[_builtins.str]
        """
        The tag value.
        """
elif False:
    CapacityReservationFleetTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapacityReservationFleetTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The tag key.
        :param pulumi.Input[_builtins.str] value: The tag value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        The tag value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CapacityReservationTagSpecificationArgsDict(TypedDict):
        resource_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of resource to tag. Specify `capacity-reservation` .
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['CapacityReservationTagArgsDict']]]]
        """
        The tags to apply to the resource.
        """
elif False:
    CapacityReservationTagSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapacityReservationTagSpecificationArgs:
    def __init__(__self__, *,
                 resource_type: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['CapacityReservationTagArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] resource_type: The type of resource to tag. Specify `capacity-reservation` .
        :param pulumi.Input[Sequence[pulumi.Input['CapacityReservationTagArgs']]] tags: The tags to apply to the resource.
        """
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of resource to tag. Specify `capacity-reservation` .
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_type", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CapacityReservationTagArgs']]]]:
        """
        The tags to apply to the resource.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CapacityReservationTagArgs']]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class CapacityReservationTagArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The tag key.
        """
        value: pulumi.Input[_builtins.str]
        """
        The tag value.
        """
elif False:
    CapacityReservationTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapacityReservationTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The tag key.
        :param pulumi.Input[_builtins.str] value: The tag value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        The tag value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CpuOptionsPropertiesArgsDict(TypedDict):
        """
        The CPU options for the instance.
        """
        core_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of CPU cores for the instance.
        """
        threads_per_core: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of threads per CPU core.
        """
elif False:
    CpuOptionsPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CpuOptionsPropertiesArgs:
    def __init__(__self__, *,
                 core_count: Optional[pulumi.Input[_builtins.int]] = None,
                 threads_per_core: Optional[pulumi.Input[_builtins.int]] = None):
        """
        The CPU options for the instance.
        :param pulumi.Input[_builtins.int] core_count: The number of CPU cores for the instance.
        :param pulumi.Input[_builtins.int] threads_per_core: The number of threads per CPU core.
        """
        if core_count is not None:
            pulumi.set(__self__, "core_count", core_count)
        if threads_per_core is not None:
            pulumi.set(__self__, "threads_per_core", threads_per_core)

    @_builtins.property
    @pulumi.getter(name="coreCount")
    def core_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of CPU cores for the instance.
        """
        return pulumi.get(self, "core_count")

    @core_count.setter
    def core_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "core_count", value)

    @_builtins.property
    @pulumi.getter(name="threadsPerCore")
    def threads_per_core(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of threads per CPU core.
        """
        return pulumi.get(self, "threads_per_core")

    @threads_per_core.setter
    def threads_per_core(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "threads_per_core", value)


if not MYPY:
    class CreditSpecificationPropertiesArgsDict(TypedDict):
        """
        The credit option for CPU usage of the burstable performance instance. Valid values are standard and unlimited.
        """
        cpu_credits: NotRequired[pulumi.Input[_builtins.str]]
        """
        The credit option for CPU usage of the instance.

        Valid values: `standard` | `unlimited`

        T3 instances with `host` tenancy do not support the `unlimited` CPU credit option.
        """
elif False:
    CreditSpecificationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CreditSpecificationPropertiesArgs:
    def __init__(__self__, *,
                 cpu_credits: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The credit option for CPU usage of the burstable performance instance. Valid values are standard and unlimited.
        :param pulumi.Input[_builtins.str] cpu_credits: The credit option for CPU usage of the instance.
               
               Valid values: `standard` | `unlimited`
               
               T3 instances with `host` tenancy do not support the `unlimited` CPU credit option.
        """
        if cpu_credits is not None:
            pulumi.set(__self__, "cpu_credits", cpu_credits)

    @_builtins.property
    @pulumi.getter(name="cpuCredits")
    def cpu_credits(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The credit option for CPU usage of the instance.

        Valid values: `standard` | `unlimited`

        T3 instances with `host` tenancy do not support the `unlimited` CPU credit option.
        """
        return pulumi.get(self, "cpu_credits")

    @cpu_credits.setter
    def cpu_credits(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cpu_credits", value)


if not MYPY:
    class DestinationOptionsPropertiesArgsDict(TypedDict):
        """
        The destination options.
        """
        file_format: pulumi.Input['FlowLogDestinationOptionsPropertiesFileFormat']
        """
        The format for the flow log. The default is `plain-text` .
        """
        hive_compatible_partitions: pulumi.Input[_builtins.bool]
        """
        Indicates whether to use Hive-compatible prefixes for flow logs stored in Amazon S3. The default is `false` .
        """
        per_hour_partition: pulumi.Input[_builtins.bool]
        """
        Indicates whether to partition the flow log per hour. This reduces the cost and response time for queries. The default is `false` .
        """
elif False:
    DestinationOptionsPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DestinationOptionsPropertiesArgs:
    def __init__(__self__, *,
                 file_format: pulumi.Input['FlowLogDestinationOptionsPropertiesFileFormat'],
                 hive_compatible_partitions: pulumi.Input[_builtins.bool],
                 per_hour_partition: pulumi.Input[_builtins.bool]):
        """
        The destination options.
        :param pulumi.Input['FlowLogDestinationOptionsPropertiesFileFormat'] file_format: The format for the flow log. The default is `plain-text` .
        :param pulumi.Input[_builtins.bool] hive_compatible_partitions: Indicates whether to use Hive-compatible prefixes for flow logs stored in Amazon S3. The default is `false` .
        :param pulumi.Input[_builtins.bool] per_hour_partition: Indicates whether to partition the flow log per hour. This reduces the cost and response time for queries. The default is `false` .
        """
        pulumi.set(__self__, "file_format", file_format)
        pulumi.set(__self__, "hive_compatible_partitions", hive_compatible_partitions)
        pulumi.set(__self__, "per_hour_partition", per_hour_partition)

    @_builtins.property
    @pulumi.getter(name="fileFormat")
    def file_format(self) -> pulumi.Input['FlowLogDestinationOptionsPropertiesFileFormat']:
        """
        The format for the flow log. The default is `plain-text` .
        """
        return pulumi.get(self, "file_format")

    @file_format.setter
    def file_format(self, value: pulumi.Input['FlowLogDestinationOptionsPropertiesFileFormat']):
        pulumi.set(self, "file_format", value)

    @_builtins.property
    @pulumi.getter(name="hiveCompatiblePartitions")
    def hive_compatible_partitions(self) -> pulumi.Input[_builtins.bool]:
        """
        Indicates whether to use Hive-compatible prefixes for flow logs stored in Amazon S3. The default is `false` .
        """
        return pulumi.get(self, "hive_compatible_partitions")

    @hive_compatible_partitions.setter
    def hive_compatible_partitions(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "hive_compatible_partitions", value)

    @_builtins.property
    @pulumi.getter(name="perHourPartition")
    def per_hour_partition(self) -> pulumi.Input[_builtins.bool]:
        """
        Indicates whether to partition the flow log per hour. This reduces the cost and response time for queries. The default is `false` .
        """
        return pulumi.get(self, "per_hour_partition")

    @per_hour_partition.setter
    def per_hour_partition(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "per_hour_partition", value)


if not MYPY:
    class Ec2FleetAcceleratorCountRequestArgsDict(TypedDict):
        max: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum number of accelerators. To specify no maximum limit, omit this parameter. To exclude accelerator-enabled instance types, set `Max` to `0` .
        """
        min: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum number of accelerators. To specify no minimum limit, omit this parameter.
        """
elif False:
    Ec2FleetAcceleratorCountRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Ec2FleetAcceleratorCountRequestArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[_builtins.int]] = None,
                 min: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] max: The maximum number of accelerators. To specify no maximum limit, omit this parameter. To exclude accelerator-enabled instance types, set `Max` to `0` .
        :param pulumi.Input[_builtins.int] min: The minimum number of accelerators. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum number of accelerators. To specify no maximum limit, omit this parameter. To exclude accelerator-enabled instance types, set `Max` to `0` .
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum number of accelerators. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class Ec2FleetAcceleratorTotalMemoryMiBRequestArgsDict(TypedDict):
        max: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum amount of accelerator memory, in MiB. To specify no maximum limit, omit this parameter.
        """
        min: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum amount of accelerator memory, in MiB. To specify no minimum limit, omit this parameter.
        """
elif False:
    Ec2FleetAcceleratorTotalMemoryMiBRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Ec2FleetAcceleratorTotalMemoryMiBRequestArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[_builtins.int]] = None,
                 min: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] max: The maximum amount of accelerator memory, in MiB. To specify no maximum limit, omit this parameter.
        :param pulumi.Input[_builtins.int] min: The minimum amount of accelerator memory, in MiB. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum amount of accelerator memory, in MiB. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum amount of accelerator memory, in MiB. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class Ec2FleetBaselineEbsBandwidthMbpsRequestArgsDict(TypedDict):
        max: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum baseline bandwidth, in Mbps. To specify no maximum limit, omit this parameter.
        """
        min: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum baseline bandwidth, in Mbps. To specify no minimum limit, omit this parameter.
        """
elif False:
    Ec2FleetBaselineEbsBandwidthMbpsRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Ec2FleetBaselineEbsBandwidthMbpsRequestArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[_builtins.int]] = None,
                 min: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] max: The maximum baseline bandwidth, in Mbps. To specify no maximum limit, omit this parameter.
        :param pulumi.Input[_builtins.int] min: The minimum baseline bandwidth, in Mbps. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum baseline bandwidth, in Mbps. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum baseline bandwidth, in Mbps. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class Ec2FleetBaselinePerformanceFactorsRequestArgsDict(TypedDict):
        cpu: NotRequired[pulumi.Input['Ec2FleetCpuPerformanceFactorRequestArgsDict']]
        """
        The CPU performance to consider, using an instance family as the baseline reference.
        """
elif False:
    Ec2FleetBaselinePerformanceFactorsRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Ec2FleetBaselinePerformanceFactorsRequestArgs:
    def __init__(__self__, *,
                 cpu: Optional[pulumi.Input['Ec2FleetCpuPerformanceFactorRequestArgs']] = None):
        """
        :param pulumi.Input['Ec2FleetCpuPerformanceFactorRequestArgs'] cpu: The CPU performance to consider, using an instance family as the baseline reference.
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input['Ec2FleetCpuPerformanceFactorRequestArgs']]:
        """
        The CPU performance to consider, using an instance family as the baseline reference.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input['Ec2FleetCpuPerformanceFactorRequestArgs']]):
        pulumi.set(self, "cpu", value)


if not MYPY:
    class Ec2FleetBlockDeviceMappingArgsDict(TypedDict):
        device_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The device name. For available device names, see [Device names for volumes](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/device_naming.html) .
        """
        ebs: NotRequired[pulumi.Input['Ec2FleetEbsBlockDeviceArgsDict']]
        """
        Parameters used to automatically set up EBS volumes when the instance is launched.
        """
        no_device: NotRequired[pulumi.Input[_builtins.str]]
        """
        To omit the device from the block device mapping, specify an empty string. When this property is specified, the device is removed from the block device mapping regardless of the assigned value.
        """
        virtual_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The virtual device name ( `ephemeral` N). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for `ephemeral0` and `ephemeral1` . The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.

        NVMe instance store volumes are automatically enumerated and assigned a device name. Including them in your block device mapping has no effect.

        Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.
        """
elif False:
    Ec2FleetBlockDeviceMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Ec2FleetBlockDeviceMappingArgs:
    def __init__(__self__, *,
                 device_name: Optional[pulumi.Input[_builtins.str]] = None,
                 ebs: Optional[pulumi.Input['Ec2FleetEbsBlockDeviceArgs']] = None,
                 no_device: Optional[pulumi.Input[_builtins.str]] = None,
                 virtual_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] device_name: The device name. For available device names, see [Device names for volumes](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/device_naming.html) .
        :param pulumi.Input['Ec2FleetEbsBlockDeviceArgs'] ebs: Parameters used to automatically set up EBS volumes when the instance is launched.
        :param pulumi.Input[_builtins.str] no_device: To omit the device from the block device mapping, specify an empty string. When this property is specified, the device is removed from the block device mapping regardless of the assigned value.
        :param pulumi.Input[_builtins.str] virtual_name: The virtual device name ( `ephemeral` N). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for `ephemeral0` and `ephemeral1` . The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.
               
               NVMe instance store volumes are automatically enumerated and assigned a device name. Including them in your block device mapping has no effect.
               
               Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.
        """
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if ebs is not None:
            pulumi.set(__self__, "ebs", ebs)
        if no_device is not None:
            pulumi.set(__self__, "no_device", no_device)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The device name. For available device names, see [Device names for volumes](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/device_naming.html) .
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device_name", value)

    @_builtins.property
    @pulumi.getter
    def ebs(self) -> Optional[pulumi.Input['Ec2FleetEbsBlockDeviceArgs']]:
        """
        Parameters used to automatically set up EBS volumes when the instance is launched.
        """
        return pulumi.get(self, "ebs")

    @ebs.setter
    def ebs(self, value: Optional[pulumi.Input['Ec2FleetEbsBlockDeviceArgs']]):
        pulumi.set(self, "ebs", value)

    @_builtins.property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        To omit the device from the block device mapping, specify an empty string. When this property is specified, the device is removed from the block device mapping regardless of the assigned value.
        """
        return pulumi.get(self, "no_device")

    @no_device.setter
    def no_device(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "no_device", value)

    @_builtins.property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The virtual device name ( `ephemeral` N). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for `ephemeral0` and `ephemeral1` . The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.

        NVMe instance store volumes are automatically enumerated and assigned a device name. Including them in your block device mapping has no effect.

        Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.
        """
        return pulumi.get(self, "virtual_name")

    @virtual_name.setter
    def virtual_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "virtual_name", value)


if not MYPY:
    class Ec2FleetCapacityRebalanceArgsDict(TypedDict):
        replacement_strategy: NotRequired[pulumi.Input['Ec2FleetCapacityRebalanceReplacementStrategy']]
        """
        The replacement strategy to use. Only available for fleets of type `maintain` .

        `launch` - EC2 Fleet launches a replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet. EC2 Fleet does not terminate the instances that receive a rebalance notification. You can terminate the old instances, or you can leave them running. You are charged for all instances while they are running.

        `launch-before-terminate` - EC2 Fleet launches a replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet, and then, after a delay that you specify (in `TerminationDelay` ), terminates the instances that received a rebalance notification.
        """
        termination_delay: NotRequired[pulumi.Input[_builtins.int]]
        """
        The amount of time (in seconds) that Amazon EC2 waits before terminating the old Spot Instance after launching a new replacement Spot Instance.

        Required when `ReplacementStrategy` is set to `launch-before-terminate` .

        Not valid when `ReplacementStrategy` is set to `launch` .

        Valid values: Minimum value of `120` seconds. Maximum value of `7200` seconds.
        """
elif False:
    Ec2FleetCapacityRebalanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Ec2FleetCapacityRebalanceArgs:
    def __init__(__self__, *,
                 replacement_strategy: Optional[pulumi.Input['Ec2FleetCapacityRebalanceReplacementStrategy']] = None,
                 termination_delay: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['Ec2FleetCapacityRebalanceReplacementStrategy'] replacement_strategy: The replacement strategy to use. Only available for fleets of type `maintain` .
               
               `launch` - EC2 Fleet launches a replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet. EC2 Fleet does not terminate the instances that receive a rebalance notification. You can terminate the old instances, or you can leave them running. You are charged for all instances while they are running.
               
               `launch-before-terminate` - EC2 Fleet launches a replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet, and then, after a delay that you specify (in `TerminationDelay` ), terminates the instances that received a rebalance notification.
        :param pulumi.Input[_builtins.int] termination_delay: The amount of time (in seconds) that Amazon EC2 waits before terminating the old Spot Instance after launching a new replacement Spot Instance.
               
               Required when `ReplacementStrategy` is set to `launch-before-terminate` .
               
               Not valid when `ReplacementStrategy` is set to `launch` .
               
               Valid values: Minimum value of `120` seconds. Maximum value of `7200` seconds.
        """
        if replacement_strategy is not None:
            pulumi.set(__self__, "replacement_strategy", replacement_strategy)
        if termination_delay is not None:
            pulumi.set(__self__, "termination_delay", termination_delay)

    @_builtins.property
    @pulumi.getter(name="replacementStrategy")
    def replacement_strategy(self) -> Optional[pulumi.Input['Ec2FleetCapacityRebalanceReplacementStrategy']]:
        """
        The replacement strategy to use. Only available for fleets of type `maintain` .

        `launch` - EC2 Fleet launches a replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet. EC2 Fleet does not terminate the instances that receive a rebalance notification. You can terminate the old instances, or you can leave them running. You are charged for all instances while they are running.

        `launch-before-terminate` - EC2 Fleet launches a replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet, and then, after a delay that you specify (in `TerminationDelay` ), terminates the instances that received a rebalance notification.
        """
        return pulumi.get(self, "replacement_strategy")

    @replacement_strategy.setter
    def replacement_strategy(self, value: Optional[pulumi.Input['Ec2FleetCapacityRebalanceReplacementStrategy']]):
        pulumi.set(self, "replacement_strategy", value)

    @_builtins.property
    @pulumi.getter(name="terminationDelay")
    def termination_delay(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The amount of time (in seconds) that Amazon EC2 waits before terminating the old Spot Instance after launching a new replacement Spot Instance.

        Required when `ReplacementStrategy` is set to `launch-before-terminate` .

        Not valid when `ReplacementStrategy` is set to `launch` .

        Valid values: Minimum value of `120` seconds. Maximum value of `7200` seconds.
        """
        return pulumi.get(self, "termination_delay")

    @termination_delay.setter
    def termination_delay(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "termination_delay", value)


if not MYPY:
    class Ec2FleetCapacityReservationOptionsRequestArgsDict(TypedDict):
        usage_strategy: NotRequired[pulumi.Input['Ec2FleetCapacityReservationOptionsRequestUsageStrategy']]
        """
        Indicates whether to use unused Capacity Reservations for fulfilling On-Demand capacity.

        If you specify `use-capacity-reservations-first` , the fleet uses unused Capacity Reservations to fulfill On-Demand capacity up to the target On-Demand capacity. If multiple instance pools have unused Capacity Reservations, the On-Demand allocation strategy ( `lowest-price` or `prioritized` ) is applied. If the number of unused Capacity Reservations is less than the On-Demand target capacity, the remaining On-Demand target capacity is launched according to the On-Demand allocation strategy ( `lowest-price` or `prioritized` ).

        If you do not specify a value, the fleet fulfils the On-Demand capacity according to the chosen On-Demand allocation strategy.
        """
elif False:
    Ec2FleetCapacityReservationOptionsRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Ec2FleetCapacityReservationOptionsRequestArgs:
    def __init__(__self__, *,
                 usage_strategy: Optional[pulumi.Input['Ec2FleetCapacityReservationOptionsRequestUsageStrategy']] = None):
        """
        :param pulumi.Input['Ec2FleetCapacityReservationOptionsRequestUsageStrategy'] usage_strategy: Indicates whether to use unused Capacity Reservations for fulfilling On-Demand capacity.
               
               If you specify `use-capacity-reservations-first` , the fleet uses unused Capacity Reservations to fulfill On-Demand capacity up to the target On-Demand capacity. If multiple instance pools have unused Capacity Reservations, the On-Demand allocation strategy ( `lowest-price` or `prioritized` ) is applied. If the number of unused Capacity Reservations is less than the On-Demand target capacity, the remaining On-Demand target capacity is launched according to the On-Demand allocation strategy ( `lowest-price` or `prioritized` ).
               
               If you do not specify a value, the fleet fulfils the On-Demand capacity according to the chosen On-Demand allocation strategy.
        """
        if usage_strategy is not None:
            pulumi.set(__self__, "usage_strategy", usage_strategy)

    @_builtins.property
    @pulumi.getter(name="usageStrategy")
    def usage_strategy(self) -> Optional[pulumi.Input['Ec2FleetCapacityReservationOptionsRequestUsageStrategy']]:
        """
        Indicates whether to use unused Capacity Reservations for fulfilling On-Demand capacity.

        If you specify `use-capacity-reservations-first` , the fleet uses unused Capacity Reservations to fulfill On-Demand capacity up to the target On-Demand capacity. If multiple instance pools have unused Capacity Reservations, the On-Demand allocation strategy ( `lowest-price` or `prioritized` ) is applied. If the number of unused Capacity Reservations is less than the On-Demand target capacity, the remaining On-Demand target capacity is launched according to the On-Demand allocation strategy ( `lowest-price` or `prioritized` ).

        If you do not specify a value, the fleet fulfils the On-Demand capacity according to the chosen On-Demand allocation strategy.
        """
        return pulumi.get(self, "usage_strategy")

    @usage_strategy.setter
    def usage_strategy(self, value: Optional[pulumi.Input['Ec2FleetCapacityReservationOptionsRequestUsageStrategy']]):
        pulumi.set(self, "usage_strategy", value)


if not MYPY:
    class Ec2FleetCpuPerformanceFactorRequestArgsDict(TypedDict):
        references: NotRequired[pulumi.Input[Sequence[pulumi.Input['Ec2FleetPerformanceFactorReferenceRequestArgsDict']]]]
        """
        Specify an instance family to use as the baseline reference for CPU performance. All instance types that match your specified attributes will be compared against the CPU performance of the referenced instance family, regardless of CPU manufacturer or architecture differences.

        > Currently, only one instance family can be specified in the list.
        """
elif False:
    Ec2FleetCpuPerformanceFactorRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Ec2FleetCpuPerformanceFactorRequestArgs:
    def __init__(__self__, *,
                 references: Optional[pulumi.Input[Sequence[pulumi.Input['Ec2FleetPerformanceFactorReferenceRequestArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['Ec2FleetPerformanceFactorReferenceRequestArgs']]] references: Specify an instance family to use as the baseline reference for CPU performance. All instance types that match your specified attributes will be compared against the CPU performance of the referenced instance family, regardless of CPU manufacturer or architecture differences.
               
               > Currently, only one instance family can be specified in the list.
        """
        if references is not None:
            pulumi.set(__self__, "references", references)

    @_builtins.property
    @pulumi.getter
    def references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Ec2FleetPerformanceFactorReferenceRequestArgs']]]]:
        """
        Specify an instance family to use as the baseline reference for CPU performance. All instance types that match your specified attributes will be compared against the CPU performance of the referenced instance family, regardless of CPU manufacturer or architecture differences.

        > Currently, only one instance family can be specified in the list.
        """
        return pulumi.get(self, "references")

    @references.setter
    def references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Ec2FleetPerformanceFactorReferenceRequestArgs']]]]):
        pulumi.set(self, "references", value)


if not MYPY:
    class Ec2FleetEbsBlockDeviceArgsDict(TypedDict):
        delete_on_termination: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the EBS volume is deleted on instance termination. For more information, see [Preserving Amazon EBS volumes on instance termination](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination) in the *Amazon EC2 User Guide* .
        """
        encrypted: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the encryption state of an EBS volume is changed while being restored from a backing snapshot. The effect of setting the encryption state to `true` depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see [Amazon EBS encryption](https://docs.aws.amazon.com/ebs/latest/userguide/ebs-encryption.html#encryption-parameters) in the *Amazon EBS User Guide* .

        In no case can you remove encryption from an encrypted volume.

        Encrypted volumes can only be attached to instances that support Amazon EBS encryption. For more information, see [Supported instance types](https://docs.aws.amazon.com/ebs/latest/userguide/ebs-encryption-requirements.html#ebs-encryption_supported_instances) .

        - If you are creating a block device mapping for a *new (empty) volume* , you can include this parameter, and specify either `true` for an encrypted volume, or `false` for an unencrypted volume. If you omit this parameter, it defaults to `false` (unencrypted).
        - If you are creating a block device mapping from an *existing encrypted or unencrypted snapshot* , you must omit this parameter. If you include this parameter, the request will fail, regardless of the value that you specify.
        - If you are creating a block device mapping from an *existing unencrypted volume* , you can include this parameter, but you must specify `false` . If you specify `true` , the request will fail. In this case, we recommend that you omit the parameter.
        - If you are creating a block device mapping from an *existing encrypted volume* , you can include this parameter, and specify either `true` or `false` . However, if you specify `false` , the parameter is ignored and the block device mapping is always encrypted. In this case, we recommend that you omit the parameter.
        """
        iops: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of I/O operations per second (IOPS). For `gp3` , `io1` , and `io2` volumes, this represents the number of IOPS that are provisioned for the volume. For `gp2` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.

        The following are the supported values for each volume type:

        - `gp3` : 3,000 - 80,000 IOPS
        - `io1` : 100 - 64,000 IOPS
        - `io2` : 100 - 256,000 IOPS

        For `io2` volumes, you can achieve up to 256,000 IOPS on [instances built on the Nitro System](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances) . On other instances, you can achieve performance up to 32,000 IOPS.

        This parameter is required for `io1` and `io2` volumes. The default for `gp3` volumes is 3,000 IOPS.
        """
        kms_key_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identifier (key ID, key alias, key ARN, or alias ARN) of the customer managed KMS key to use for EBS encryption.

        This parameter is only supported on `BlockDeviceMapping` objects called by [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) , [RequestSpotFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotFleet.html) , and [RequestSpotInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotInstances.html) .
        """
        snapshot_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the snapshot.
        """
        volume_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size.

        The following are the supported sizes for each volume type:

        - `gp2` : 1 - 16,384 GiB
        - `gp3` : 1 - 65,536 GiB
        - `io1` : 4 - 16,384 GiB
        - `io2` : 4 - 65,536 GiB
        - `st1` and `sc1` : 125 - 16,384 GiB
        - `standard` : 1 - 1024 GiB
        """
        volume_type: NotRequired[pulumi.Input['Ec2FleetEbsBlockDeviceVolumeType']]
        """
        The volume type. For more information, see [Amazon EBS volume types](https://docs.aws.amazon.com/ebs/latest/userguide/ebs-volume-types.html) in the *Amazon EBS User Guide* .
        """
elif False:
    Ec2FleetEbsBlockDeviceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Ec2FleetEbsBlockDeviceArgs:
    def __init__(__self__, *,
                 delete_on_termination: Optional[pulumi.Input[_builtins.bool]] = None,
                 encrypted: Optional[pulumi.Input[_builtins.bool]] = None,
                 iops: Optional[pulumi.Input[_builtins.int]] = None,
                 kms_key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 snapshot_id: Optional[pulumi.Input[_builtins.str]] = None,
                 volume_size: Optional[pulumi.Input[_builtins.int]] = None,
                 volume_type: Optional[pulumi.Input['Ec2FleetEbsBlockDeviceVolumeType']] = None):
        """
        :param pulumi.Input[_builtins.bool] delete_on_termination: Indicates whether the EBS volume is deleted on instance termination. For more information, see [Preserving Amazon EBS volumes on instance termination](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination) in the *Amazon EC2 User Guide* .
        :param pulumi.Input[_builtins.bool] encrypted: Indicates whether the encryption state of an EBS volume is changed while being restored from a backing snapshot. The effect of setting the encryption state to `true` depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see [Amazon EBS encryption](https://docs.aws.amazon.com/ebs/latest/userguide/ebs-encryption.html#encryption-parameters) in the *Amazon EBS User Guide* .
               
               In no case can you remove encryption from an encrypted volume.
               
               Encrypted volumes can only be attached to instances that support Amazon EBS encryption. For more information, see [Supported instance types](https://docs.aws.amazon.com/ebs/latest/userguide/ebs-encryption-requirements.html#ebs-encryption_supported_instances) .
               
               - If you are creating a block device mapping for a *new (empty) volume* , you can include this parameter, and specify either `true` for an encrypted volume, or `false` for an unencrypted volume. If you omit this parameter, it defaults to `false` (unencrypted).
               - If you are creating a block device mapping from an *existing encrypted or unencrypted snapshot* , you must omit this parameter. If you include this parameter, the request will fail, regardless of the value that you specify.
               - If you are creating a block device mapping from an *existing unencrypted volume* , you can include this parameter, but you must specify `false` . If you specify `true` , the request will fail. In this case, we recommend that you omit the parameter.
               - If you are creating a block device mapping from an *existing encrypted volume* , you can include this parameter, and specify either `true` or `false` . However, if you specify `false` , the parameter is ignored and the block device mapping is always encrypted. In this case, we recommend that you omit the parameter.
        :param pulumi.Input[_builtins.int] iops: The number of I/O operations per second (IOPS). For `gp3` , `io1` , and `io2` volumes, this represents the number of IOPS that are provisioned for the volume. For `gp2` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.
               
               The following are the supported values for each volume type:
               
               - `gp3` : 3,000 - 80,000 IOPS
               - `io1` : 100 - 64,000 IOPS
               - `io2` : 100 - 256,000 IOPS
               
               For `io2` volumes, you can achieve up to 256,000 IOPS on [instances built on the Nitro System](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances) . On other instances, you can achieve performance up to 32,000 IOPS.
               
               This parameter is required for `io1` and `io2` volumes. The default for `gp3` volumes is 3,000 IOPS.
        :param pulumi.Input[_builtins.str] kms_key_id: Identifier (key ID, key alias, key ARN, or alias ARN) of the customer managed KMS key to use for EBS encryption.
               
               This parameter is only supported on `BlockDeviceMapping` objects called by [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) , [RequestSpotFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotFleet.html) , and [RequestSpotInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotInstances.html) .
        :param pulumi.Input[_builtins.str] snapshot_id: The ID of the snapshot.
        :param pulumi.Input[_builtins.int] volume_size: The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size.
               
               The following are the supported sizes for each volume type:
               
               - `gp2` : 1 - 16,384 GiB
               - `gp3` : 1 - 65,536 GiB
               - `io1` : 4 - 16,384 GiB
               - `io2` : 4 - 65,536 GiB
               - `st1` and `sc1` : 125 - 16,384 GiB
               - `standard` : 1 - 1024 GiB
        :param pulumi.Input['Ec2FleetEbsBlockDeviceVolumeType'] volume_type: The volume type. For more information, see [Amazon EBS volume types](https://docs.aws.amazon.com/ebs/latest/userguide/ebs-volume-types.html) in the *Amazon EBS User Guide* .
        """
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the EBS volume is deleted on instance termination. For more information, see [Preserving Amazon EBS volumes on instance termination](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "delete_on_termination")

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "delete_on_termination", value)

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the encryption state of an EBS volume is changed while being restored from a backing snapshot. The effect of setting the encryption state to `true` depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see [Amazon EBS encryption](https://docs.aws.amazon.com/ebs/latest/userguide/ebs-encryption.html#encryption-parameters) in the *Amazon EBS User Guide* .

        In no case can you remove encryption from an encrypted volume.

        Encrypted volumes can only be attached to instances that support Amazon EBS encryption. For more information, see [Supported instance types](https://docs.aws.amazon.com/ebs/latest/userguide/ebs-encryption-requirements.html#ebs-encryption_supported_instances) .

        - If you are creating a block device mapping for a *new (empty) volume* , you can include this parameter, and specify either `true` for an encrypted volume, or `false` for an unencrypted volume. If you omit this parameter, it defaults to `false` (unencrypted).
        - If you are creating a block device mapping from an *existing encrypted or unencrypted snapshot* , you must omit this parameter. If you include this parameter, the request will fail, regardless of the value that you specify.
        - If you are creating a block device mapping from an *existing unencrypted volume* , you can include this parameter, but you must specify `false` . If you specify `true` , the request will fail. In this case, we recommend that you omit the parameter.
        - If you are creating a block device mapping from an *existing encrypted volume* , you can include this parameter, and specify either `true` or `false` . However, if you specify `false` , the parameter is ignored and the block device mapping is always encrypted. In this case, we recommend that you omit the parameter.
        """
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "encrypted", value)

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of I/O operations per second (IOPS). For `gp3` , `io1` , and `io2` volumes, this represents the number of IOPS that are provisioned for the volume. For `gp2` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.

        The following are the supported values for each volume type:

        - `gp3` : 3,000 - 80,000 IOPS
        - `io1` : 100 - 64,000 IOPS
        - `io2` : 100 - 256,000 IOPS

        For `io2` volumes, you can achieve up to 256,000 IOPS on [instances built on the Nitro System](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances) . On other instances, you can achieve performance up to 32,000 IOPS.

        This parameter is required for `io1` and `io2` volumes. The default for `gp3` volumes is 3,000 IOPS.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "iops", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifier (key ID, key alias, key ARN, or alias ARN) of the customer managed KMS key to use for EBS encryption.

        This parameter is only supported on `BlockDeviceMapping` objects called by [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) , [RequestSpotFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotFleet.html) , and [RequestSpotInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotInstances.html) .
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_id", value)

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the snapshot.
        """
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "snapshot_id", value)

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size.

        The following are the supported sizes for each volume type:

        - `gp2` : 1 - 16,384 GiB
        - `gp3` : 1 - 65,536 GiB
        - `io1` : 4 - 16,384 GiB
        - `io2` : 4 - 65,536 GiB
        - `st1` and `sc1` : 125 - 16,384 GiB
        - `standard` : 1 - 1024 GiB
        """
        return pulumi.get(self, "volume_size")

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "volume_size", value)

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input['Ec2FleetEbsBlockDeviceVolumeType']]:
        """
        The volume type. For more information, see [Amazon EBS volume types](https://docs.aws.amazon.com/ebs/latest/userguide/ebs-volume-types.html) in the *Amazon EBS User Guide* .
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input['Ec2FleetEbsBlockDeviceVolumeType']]):
        pulumi.set(self, "volume_type", value)


if not MYPY:
    class Ec2FleetFleetLaunchTemplateConfigRequestArgsDict(TypedDict):
        launch_template_specification: NotRequired[pulumi.Input['Ec2FleetFleetLaunchTemplateSpecificationRequestArgsDict']]
        """
        The launch template to use. You must specify either the launch template ID or launch template name in the request.
        """
        overrides: NotRequired[pulumi.Input[Sequence[pulumi.Input['Ec2FleetFleetLaunchTemplateOverridesRequestArgsDict']]]]
        """
        Any parameters that you specify override the same parameters in the launch template.

        For fleets of type `request` and `maintain` , a maximum of 300 items is allowed across all launch templates.
        """
elif False:
    Ec2FleetFleetLaunchTemplateConfigRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Ec2FleetFleetLaunchTemplateConfigRequestArgs:
    def __init__(__self__, *,
                 launch_template_specification: Optional[pulumi.Input['Ec2FleetFleetLaunchTemplateSpecificationRequestArgs']] = None,
                 overrides: Optional[pulumi.Input[Sequence[pulumi.Input['Ec2FleetFleetLaunchTemplateOverridesRequestArgs']]]] = None):
        """
        :param pulumi.Input['Ec2FleetFleetLaunchTemplateSpecificationRequestArgs'] launch_template_specification: The launch template to use. You must specify either the launch template ID or launch template name in the request.
        :param pulumi.Input[Sequence[pulumi.Input['Ec2FleetFleetLaunchTemplateOverridesRequestArgs']]] overrides: Any parameters that you specify override the same parameters in the launch template.
               
               For fleets of type `request` and `maintain` , a maximum of 300 items is allowed across all launch templates.
        """
        if launch_template_specification is not None:
            pulumi.set(__self__, "launch_template_specification", launch_template_specification)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)

    @_builtins.property
    @pulumi.getter(name="launchTemplateSpecification")
    def launch_template_specification(self) -> Optional[pulumi.Input['Ec2FleetFleetLaunchTemplateSpecificationRequestArgs']]:
        """
        The launch template to use. You must specify either the launch template ID or launch template name in the request.
        """
        return pulumi.get(self, "launch_template_specification")

    @launch_template_specification.setter
    def launch_template_specification(self, value: Optional[pulumi.Input['Ec2FleetFleetLaunchTemplateSpecificationRequestArgs']]):
        pulumi.set(self, "launch_template_specification", value)

    @_builtins.property
    @pulumi.getter
    def overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Ec2FleetFleetLaunchTemplateOverridesRequestArgs']]]]:
        """
        Any parameters that you specify override the same parameters in the launch template.

        For fleets of type `request` and `maintain` , a maximum of 300 items is allowed across all launch templates.
        """
        return pulumi.get(self, "overrides")

    @overrides.setter
    def overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Ec2FleetFleetLaunchTemplateOverridesRequestArgs']]]]):
        pulumi.set(self, "overrides", value)


if not MYPY:
    class Ec2FleetFleetLaunchTemplateOverridesRequestArgsDict(TypedDict):
        availability_zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Availability Zone in which to launch the instances.
        """
        block_device_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['Ec2FleetBlockDeviceMappingArgsDict']]]]
        """
        The block device mappings, which define the EBS volumes and instance store volumes to attach to the instance at launch.

        Supported only for fleets of type `instant` .

        For more information, see [Block device mappings for volumes on Amazon EC2 instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/block-device-mapping-concepts.html) in the *Amazon EC2 User Guide* .
        """
        instance_requirements: NotRequired[pulumi.Input['Ec2FleetInstanceRequirementsRequestArgsDict']]
        """
        The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with those attributes.

        > If you specify `InstanceRequirements` , you can't specify `InstanceType` .
        """
        instance_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The instance type.

        `mac1.metal` is not supported as a launch template override.

        > If you specify `InstanceType` , you can't specify `InstanceRequirements` .
        """
        max_price: NotRequired[pulumi.Input[_builtins.str]]
        """
        The maximum price per unit hour that you are willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.

        > If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.
        > 
        > If you specify a maximum price, it must be more than USD $0.001. Specifying a value below USD $0.001 will result in an `InvalidParameterValue` error message.
        """
        placement: NotRequired[pulumi.Input['Ec2FleetPlacementArgsDict']]
        """
        The location where the instance launched, if applicable.
        """
        priority: NotRequired[pulumi.Input[_builtins.float]]
        """
        The priority for the launch template override. The highest priority is launched first.

        If the On-Demand `AllocationStrategy` is set to `prioritized` , EC2 Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity.

        If the Spot `AllocationStrategy` is set to `capacity-optimized-prioritized` , EC2 Fleet uses priority on a best-effort basis to determine which launch template override to use in fulfilling Spot capacity, but optimizes for capacity first.

        Valid values are whole numbers starting at `0` . The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority. You can set the same priority for different launch template overrides.
        """
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IDs of the subnets in which to launch the instances. Separate multiple subnet IDs using commas (for example, `subnet-1234abcdeexample1, subnet-0987cdef6example2` ). A request of type `instant` can have only one subnet ID.
        """
        weighted_capacity: NotRequired[pulumi.Input[_builtins.float]]
        """
        The number of units provided by the specified instance type. These are the same units that you chose to set the target capacity in terms of instances, or a performance characteristic such as vCPUs, memory, or I/O.

        If the target capacity divided by this value is not a whole number, Amazon EC2 rounds the number of instances to the next whole number. If this value is not specified, the default is 1.

        > When specifying weights, the price used in the `lowest-price` and `price-capacity-optimized` allocation strategies is per *unit* hour (where the instance price is divided by the specified weight). However, if all the specified weights are above the requested `TargetCapacity` , resulting in only 1 instance being launched, the price used is per *instance* hour.
        """
elif False:
    Ec2FleetFleetLaunchTemplateOverridesRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Ec2FleetFleetLaunchTemplateOverridesRequestArgs:
    def __init__(__self__, *,
                 availability_zone: Optional[pulumi.Input[_builtins.str]] = None,
                 block_device_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['Ec2FleetBlockDeviceMappingArgs']]]] = None,
                 instance_requirements: Optional[pulumi.Input['Ec2FleetInstanceRequirementsRequestArgs']] = None,
                 instance_type: Optional[pulumi.Input[_builtins.str]] = None,
                 max_price: Optional[pulumi.Input[_builtins.str]] = None,
                 placement: Optional[pulumi.Input['Ec2FleetPlacementArgs']] = None,
                 priority: Optional[pulumi.Input[_builtins.float]] = None,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None,
                 weighted_capacity: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] availability_zone: The Availability Zone in which to launch the instances.
        :param pulumi.Input[Sequence[pulumi.Input['Ec2FleetBlockDeviceMappingArgs']]] block_device_mappings: The block device mappings, which define the EBS volumes and instance store volumes to attach to the instance at launch.
               
               Supported only for fleets of type `instant` .
               
               For more information, see [Block device mappings for volumes on Amazon EC2 instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/block-device-mapping-concepts.html) in the *Amazon EC2 User Guide* .
        :param pulumi.Input['Ec2FleetInstanceRequirementsRequestArgs'] instance_requirements: The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with those attributes.
               
               > If you specify `InstanceRequirements` , you can't specify `InstanceType` .
        :param pulumi.Input[_builtins.str] instance_type: The instance type.
               
               `mac1.metal` is not supported as a launch template override.
               
               > If you specify `InstanceType` , you can't specify `InstanceRequirements` .
        :param pulumi.Input[_builtins.str] max_price: The maximum price per unit hour that you are willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.
               
               > If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.
               > 
               > If you specify a maximum price, it must be more than USD $0.001. Specifying a value below USD $0.001 will result in an `InvalidParameterValue` error message.
        :param pulumi.Input['Ec2FleetPlacementArgs'] placement: The location where the instance launched, if applicable.
        :param pulumi.Input[_builtins.float] priority: The priority for the launch template override. The highest priority is launched first.
               
               If the On-Demand `AllocationStrategy` is set to `prioritized` , EC2 Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity.
               
               If the Spot `AllocationStrategy` is set to `capacity-optimized-prioritized` , EC2 Fleet uses priority on a best-effort basis to determine which launch template override to use in fulfilling Spot capacity, but optimizes for capacity first.
               
               Valid values are whole numbers starting at `0` . The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority. You can set the same priority for different launch template overrides.
        :param pulumi.Input[_builtins.str] subnet_id: The IDs of the subnets in which to launch the instances. Separate multiple subnet IDs using commas (for example, `subnet-1234abcdeexample1, subnet-0987cdef6example2` ). A request of type `instant` can have only one subnet ID.
        :param pulumi.Input[_builtins.float] weighted_capacity: The number of units provided by the specified instance type. These are the same units that you chose to set the target capacity in terms of instances, or a performance characteristic such as vCPUs, memory, or I/O.
               
               If the target capacity divided by this value is not a whole number, Amazon EC2 rounds the number of instances to the next whole number. If this value is not specified, the default is 1.
               
               > When specifying weights, the price used in the `lowest-price` and `price-capacity-optimized` allocation strategies is per *unit* hour (where the instance price is divided by the specified weight). However, if all the specified weights are above the requested `TargetCapacity` , resulting in only 1 instance being launched, the price used is per *instance* hour.
        """
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if block_device_mappings is not None:
            pulumi.set(__self__, "block_device_mappings", block_device_mappings)
        if instance_requirements is not None:
            pulumi.set(__self__, "instance_requirements", instance_requirements)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if max_price is not None:
            pulumi.set(__self__, "max_price", max_price)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if weighted_capacity is not None:
            pulumi.set(__self__, "weighted_capacity", weighted_capacity)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Availability Zone in which to launch the instances.
        """
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "availability_zone", value)

    @_builtins.property
    @pulumi.getter(name="blockDeviceMappings")
    def block_device_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Ec2FleetBlockDeviceMappingArgs']]]]:
        """
        The block device mappings, which define the EBS volumes and instance store volumes to attach to the instance at launch.

        Supported only for fleets of type `instant` .

        For more information, see [Block device mappings for volumes on Amazon EC2 instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/block-device-mapping-concepts.html) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "block_device_mappings")

    @block_device_mappings.setter
    def block_device_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Ec2FleetBlockDeviceMappingArgs']]]]):
        pulumi.set(self, "block_device_mappings", value)

    @_builtins.property
    @pulumi.getter(name="instanceRequirements")
    def instance_requirements(self) -> Optional[pulumi.Input['Ec2FleetInstanceRequirementsRequestArgs']]:
        """
        The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with those attributes.

        > If you specify `InstanceRequirements` , you can't specify `InstanceType` .
        """
        return pulumi.get(self, "instance_requirements")

    @instance_requirements.setter
    def instance_requirements(self, value: Optional[pulumi.Input['Ec2FleetInstanceRequirementsRequestArgs']]):
        pulumi.set(self, "instance_requirements", value)

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The instance type.

        `mac1.metal` is not supported as a launch template override.

        > If you specify `InstanceType` , you can't specify `InstanceRequirements` .
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_type", value)

    @_builtins.property
    @pulumi.getter(name="maxPrice")
    def max_price(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The maximum price per unit hour that you are willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.

        > If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.
        > 
        > If you specify a maximum price, it must be more than USD $0.001. Specifying a value below USD $0.001 will result in an `InvalidParameterValue` error message.
        """
        return pulumi.get(self, "max_price")

    @max_price.setter
    def max_price(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_price", value)

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input['Ec2FleetPlacementArgs']]:
        """
        The location where the instance launched, if applicable.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input['Ec2FleetPlacementArgs']]):
        pulumi.set(self, "placement", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The priority for the launch template override. The highest priority is launched first.

        If the On-Demand `AllocationStrategy` is set to `prioritized` , EC2 Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity.

        If the Spot `AllocationStrategy` is set to `capacity-optimized-prioritized` , EC2 Fleet uses priority on a best-effort basis to determine which launch template override to use in fulfilling Spot capacity, but optimizes for capacity first.

        Valid values are whole numbers starting at `0` . The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority. You can set the same priority for different launch template overrides.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IDs of the subnets in which to launch the instances. Separate multiple subnet IDs using commas (for example, `subnet-1234abcdeexample1, subnet-0987cdef6example2` ). A request of type `instant` can have only one subnet ID.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)

    @_builtins.property
    @pulumi.getter(name="weightedCapacity")
    def weighted_capacity(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The number of units provided by the specified instance type. These are the same units that you chose to set the target capacity in terms of instances, or a performance characteristic such as vCPUs, memory, or I/O.

        If the target capacity divided by this value is not a whole number, Amazon EC2 rounds the number of instances to the next whole number. If this value is not specified, the default is 1.

        > When specifying weights, the price used in the `lowest-price` and `price-capacity-optimized` allocation strategies is per *unit* hour (where the instance price is divided by the specified weight). However, if all the specified weights are above the requested `TargetCapacity` , resulting in only 1 instance being launched, the price used is per *instance* hour.
        """
        return pulumi.get(self, "weighted_capacity")

    @weighted_capacity.setter
    def weighted_capacity(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "weighted_capacity", value)


if not MYPY:
    class Ec2FleetFleetLaunchTemplateSpecificationRequestArgsDict(TypedDict):
        version: pulumi.Input[_builtins.str]
        """
        The launch template version number, `$Latest` , or `$Default` . You must specify a value, otherwise the request fails.

        If the value is `$Latest` , Amazon EC2 uses the latest version of the launch template.

        If the value is `$Default` , Amazon EC2 uses the default version of the launch template.
        """
        launch_template_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the launch template.

        You must specify the `LaunchTemplateId` or the `LaunchTemplateName` , but not both.
        """
        launch_template_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the launch template.

        You must specify the `LaunchTemplateName` or the `LaunchTemplateId` , but not both.
        """
elif False:
    Ec2FleetFleetLaunchTemplateSpecificationRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Ec2FleetFleetLaunchTemplateSpecificationRequestArgs:
    def __init__(__self__, *,
                 version: pulumi.Input[_builtins.str],
                 launch_template_id: Optional[pulumi.Input[_builtins.str]] = None,
                 launch_template_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] version: The launch template version number, `$Latest` , or `$Default` . You must specify a value, otherwise the request fails.
               
               If the value is `$Latest` , Amazon EC2 uses the latest version of the launch template.
               
               If the value is `$Default` , Amazon EC2 uses the default version of the launch template.
        :param pulumi.Input[_builtins.str] launch_template_id: The ID of the launch template.
               
               You must specify the `LaunchTemplateId` or the `LaunchTemplateName` , but not both.
        :param pulumi.Input[_builtins.str] launch_template_name: The name of the launch template.
               
               You must specify the `LaunchTemplateName` or the `LaunchTemplateId` , but not both.
        """
        pulumi.set(__self__, "version", version)
        if launch_template_id is not None:
            pulumi.set(__self__, "launch_template_id", launch_template_id)
        if launch_template_name is not None:
            pulumi.set(__self__, "launch_template_name", launch_template_name)

    @_builtins.property
    @pulumi.getter
    def version(self) -> pulumi.Input[_builtins.str]:
        """
        The launch template version number, `$Latest` , or `$Default` . You must specify a value, otherwise the request fails.

        If the value is `$Latest` , Amazon EC2 uses the latest version of the launch template.

        If the value is `$Default` , Amazon EC2 uses the default version of the launch template.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "version", value)

    @_builtins.property
    @pulumi.getter(name="launchTemplateId")
    def launch_template_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the launch template.

        You must specify the `LaunchTemplateId` or the `LaunchTemplateName` , but not both.
        """
        return pulumi.get(self, "launch_template_id")

    @launch_template_id.setter
    def launch_template_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "launch_template_id", value)

    @_builtins.property
    @pulumi.getter(name="launchTemplateName")
    def launch_template_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the launch template.

        You must specify the `LaunchTemplateName` or the `LaunchTemplateId` , but not both.
        """
        return pulumi.get(self, "launch_template_name")

    @launch_template_name.setter
    def launch_template_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "launch_template_name", value)


if not MYPY:
    class Ec2FleetInstanceRequirementsRequestArgsDict(TypedDict):
        accelerator_count: NotRequired[pulumi.Input['Ec2FleetAcceleratorCountRequestArgsDict']]
        """
        The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.

        To exclude accelerator-enabled instance types, set `Max` to `0` .

        Default: No minimum or maximum limits
        """
        accelerator_manufacturers: NotRequired[pulumi.Input[Sequence[pulumi.Input['Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem']]]]
        """
        Indicates whether instance types must have accelerators by specific manufacturers.

        - For instance types with AWS devices, specify `amazon-web-services` .
        - For instance types with AMD devices, specify `amd` .
        - For instance types with Habana devices, specify `habana` .
        - For instance types with NVIDIA devices, specify `nvidia` .
        - For instance types with Xilinx devices, specify `xilinx` .

        Default: Any manufacturer
        """
        accelerator_names: NotRequired[pulumi.Input[Sequence[pulumi.Input['Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem']]]]
        """
        The accelerators that must be on the instance type.

        - For instance types with NVIDIA A10G GPUs, specify `a10g` .
        - For instance types with NVIDIA A100 GPUs, specify `a100` .
        - For instance types with NVIDIA H100 GPUs, specify `h100` .
        - For instance types with AWS Inferentia chips, specify `inferentia` .
        - For instance types with NVIDIA GRID K520 GPUs, specify `k520` .
        - For instance types with NVIDIA K80 GPUs, specify `k80` .
        - For instance types with NVIDIA M60 GPUs, specify `m60` .
        - For instance types with AMD Radeon Pro V520 GPUs, specify `radeon-pro-v520` .
        - For instance types with NVIDIA T4 GPUs, specify `t4` .
        - For instance types with NVIDIA T4G GPUs, specify `t4g` .
        - For instance types with Xilinx VU9P FPGAs, specify `vu9p` .
        - For instance types with NVIDIA V100 GPUs, specify `v100` .

        Default: Any accelerator
        """
        accelerator_total_memory_mi_b: NotRequired[pulumi.Input['Ec2FleetAcceleratorTotalMemoryMiBRequestArgsDict']]
        """
        The minimum and maximum amount of total accelerator memory, in MiB.

        Default: No minimum or maximum limits
        """
        accelerator_types: NotRequired[pulumi.Input[Sequence[pulumi.Input['Ec2FleetInstanceRequirementsRequestAcceleratorTypesItem']]]]
        """
        The accelerator types that must be on the instance type.

        - For instance types with FPGA accelerators, specify `fpga` .
        - For instance types with GPU accelerators, specify `gpu` .
        - For instance types with Inference accelerators, specify `inference` .

        Default: Any accelerator type
        """
        allowed_instance_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes.

        You can use strings with one or more wild cards, represented by an asterisk ( `*` ), to allow an instance type, size, or generation. The following are examples: `m5.8xlarge` , `c5*.*` , `m5a.*` , `r*` , `*3*` .

        For example, if you specify `c5*` ,Amazon EC2 will allow the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*` , Amazon EC2 will allow all the M5a instance types, but not the M5n instance types.

        > If you specify `AllowedInstanceTypes` , you can't specify `ExcludedInstanceTypes` . 

        Default: All instance types
        """
        bare_metal: NotRequired[pulumi.Input['Ec2FleetInstanceRequirementsRequestBareMetal']]
        """
        Indicates whether bare metal instance types must be included, excluded, or required.

        - To include bare metal instance types, specify `included` .
        - To require only bare metal instance types, specify `required` .
        - To exclude bare metal instance types, specify `excluded` .

        Default: `excluded`
        """
        baseline_ebs_bandwidth_mbps: NotRequired[pulumi.Input['Ec2FleetBaselineEbsBandwidthMbpsRequestArgsDict']]
        """
        The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see [Amazon EBSoptimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the *Amazon EC2 User Guide* .

        Default: No minimum or maximum limits
        """
        baseline_performance_factors: NotRequired[pulumi.Input['Ec2FleetBaselinePerformanceFactorsRequestArgsDict']]
        """
        The baseline performance to consider, using an instance family as a baseline reference. The instance family establishes the lowest acceptable level of performance. Amazon EC2 uses this baseline to guide instance type selection, but there is no guarantee that the selected instance types will always exceed the baseline for every application. Currently, this parameter only supports CPU performance as a baseline performance factor. For more information, see [Performance protection](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html#ec2fleet-abis-performance-protection) in the *Amazon EC2 User Guide* .
        """
        burstable_performance: NotRequired[pulumi.Input['Ec2FleetInstanceRequirementsRequestBurstablePerformance']]
        """
        Indicates whether burstable performance T instance types are included, excluded, or required. For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) .

        - To include burstable performance instance types, specify `included` .
        - To require only burstable performance instance types, specify `required` .
        - To exclude burstable performance instance types, specify `excluded` .

        Default: `excluded`
        """
        cpu_manufacturers: NotRequired[pulumi.Input[Sequence[pulumi.Input['Ec2FleetInstanceRequirementsRequestCpuManufacturersItem']]]]
        """
        The CPU manufacturers to include.

        - For instance types with Intel CPUs, specify `intel` .
        - For instance types with AMD CPUs, specify `amd` .
        - For instance types with AWS CPUs, specify `amazon-web-services` .
        - For instance types with Apple CPUs, specify `apple` .

        > Don't confuse the CPU manufacturer with the CPU architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template. 

        Default: Any manufacturer
        """
        excluded_instance_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The instance types to exclude.

        You can use strings with one or more wild cards, represented by an asterisk ( `*` ), to exclude an instance family, type, size, or generation. The following are examples: `m5.8xlarge` , `c5*.*` , `m5a.*` , `r*` , `*3*` .

        For example, if you specify `c5*` ,Amazon EC2 will exclude the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*` , Amazon EC2 will exclude all the M5a instance types, but not the M5n instance types.

        > If you specify `ExcludedInstanceTypes` , you can't specify `AllowedInstanceTypes` . 

        Default: No excluded instance types
        """
        instance_generations: NotRequired[pulumi.Input[Sequence[pulumi.Input['Ec2FleetInstanceRequirementsRequestInstanceGenerationsItem']]]]
        """
        Indicates whether current or previous generation instance types are included. The current generation instance types are recommended for use. Current generation instance types are typically the latest two to three generations in each instance family. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .

        For current generation instance types, specify `current` .

        For previous generation instance types, specify `previous` .

        Default: Current and previous generation instance types
        """
        local_storage: NotRequired[pulumi.Input['Ec2FleetInstanceRequirementsRequestLocalStorage']]
        """
        Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, [Amazon EC2 instance store](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html) in the *Amazon EC2 User Guide* .

        - To include instance types with instance store volumes, specify `included` .
        - To require only instance types with instance store volumes, specify `required` .
        - To exclude instance types with instance store volumes, specify `excluded` .

        Default: `included`
        """
        local_storage_types: NotRequired[pulumi.Input[Sequence[pulumi.Input['Ec2FleetInstanceRequirementsRequestLocalStorageTypesItem']]]]
        """
        The type of local storage that is required.

        - For instance types with hard disk drive (HDD) storage, specify `hdd` .
        - For instance types with solid state drive (SSD) storage, specify `ssd` .

        Default: `hdd` and `ssd`
        """
        max_spot_price_as_percentage_of_optimal_on_demand_price: NotRequired[pulumi.Input[_builtins.int]]
        """
        [Price protection] The price protection threshold for Spot Instances, as a percentage of an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.

        The parameter accepts an integer, which Amazon EC2 interprets as a percentage.

        If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is based on the per vCPU or per memory price instead of the per instance price.

        > Only one of `SpotMaxPricePercentageOverLowestPrice` or `MaxSpotPriceAsPercentageOfOptimalOnDemandPrice` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as `999999` .
        """
        memory_gi_b_per_v_cpu: NotRequired[pulumi.Input['Ec2FleetMemoryGiBPerVCpuRequestArgsDict']]
        """
        The minimum and maximum amount of memory per vCPU, in GiB.

        Default: No minimum or maximum limits
        """
        memory_mi_b: NotRequired[pulumi.Input['Ec2FleetMemoryMiBRequestArgsDict']]
        """
        The minimum and maximum amount of memory, in MiB.
        """
        network_bandwidth_gbps: NotRequired[pulumi.Input['Ec2FleetNetworkBandwidthGbpsRequestArgsDict']]
        """
        The minimum and maximum amount of baseline network bandwidth, in gigabits per second (Gbps). For more information, see [Amazon EC2 instance network bandwidth](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-network-bandwidth.html) in the *Amazon EC2 User Guide* .

        Default: No minimum or maximum limits
        """
        network_interface_count: NotRequired[pulumi.Input['Ec2FleetNetworkInterfaceCountRequestArgsDict']]
        """
        The minimum and maximum number of network interfaces.

        Default: No minimum or maximum limits
        """
        on_demand_max_price_percentage_over_lowest_price: NotRequired[pulumi.Input[_builtins.int]]
        """
        [Price protection] The price protection threshold for On-Demand Instances, as a percentage higher than an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.

        The parameter accepts an integer, which Amazon EC2 interprets as a percentage.

        To indicate no price protection threshold, specify a high value, such as `999999` .

        This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) .

        > If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price. 

        Default: `20`
        """
        require_hibernate_support: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether instance types must support hibernation for On-Demand Instances.

        This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) .

        Default: `false`
        """
        spot_max_price_percentage_over_lowest_price: NotRequired[pulumi.Input[_builtins.int]]
        """
        [Price protection] The price protection threshold for Spot Instances, as a percentage higher than an identified Spot price. The identified Spot price is the Spot price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified Spot price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose Spot price exceeds your specified threshold.

        The parameter accepts an integer, which Amazon EC2 interprets as a percentage.

        If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.

        This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) .

        > Only one of `SpotMaxPricePercentageOverLowestPrice` or `MaxSpotPriceAsPercentageOfOptimalOnDemandPrice` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as `999999` . 

        Default: `100`
        """
        total_local_storage_gb: NotRequired[pulumi.Input['Ec2FleetTotalLocalStorageGbRequestArgsDict']]
        """
        The minimum and maximum amount of total local storage, in GB.

        Default: No minimum or maximum limits
        """
        v_cpu_count: NotRequired[pulumi.Input['Ec2FleetVCpuCountRangeRequestArgsDict']]
        """
        The minimum and maximum number of vCPUs.
        """
elif False:
    Ec2FleetInstanceRequirementsRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Ec2FleetInstanceRequirementsRequestArgs:
    def __init__(__self__, *,
                 accelerator_count: Optional[pulumi.Input['Ec2FleetAcceleratorCountRequestArgs']] = None,
                 accelerator_manufacturers: Optional[pulumi.Input[Sequence[pulumi.Input['Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem']]]] = None,
                 accelerator_names: Optional[pulumi.Input[Sequence[pulumi.Input['Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem']]]] = None,
                 accelerator_total_memory_mi_b: Optional[pulumi.Input['Ec2FleetAcceleratorTotalMemoryMiBRequestArgs']] = None,
                 accelerator_types: Optional[pulumi.Input[Sequence[pulumi.Input['Ec2FleetInstanceRequirementsRequestAcceleratorTypesItem']]]] = None,
                 allowed_instance_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 bare_metal: Optional[pulumi.Input['Ec2FleetInstanceRequirementsRequestBareMetal']] = None,
                 baseline_ebs_bandwidth_mbps: Optional[pulumi.Input['Ec2FleetBaselineEbsBandwidthMbpsRequestArgs']] = None,
                 baseline_performance_factors: Optional[pulumi.Input['Ec2FleetBaselinePerformanceFactorsRequestArgs']] = None,
                 burstable_performance: Optional[pulumi.Input['Ec2FleetInstanceRequirementsRequestBurstablePerformance']] = None,
                 cpu_manufacturers: Optional[pulumi.Input[Sequence[pulumi.Input['Ec2FleetInstanceRequirementsRequestCpuManufacturersItem']]]] = None,
                 excluded_instance_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 instance_generations: Optional[pulumi.Input[Sequence[pulumi.Input['Ec2FleetInstanceRequirementsRequestInstanceGenerationsItem']]]] = None,
                 local_storage: Optional[pulumi.Input['Ec2FleetInstanceRequirementsRequestLocalStorage']] = None,
                 local_storage_types: Optional[pulumi.Input[Sequence[pulumi.Input['Ec2FleetInstanceRequirementsRequestLocalStorageTypesItem']]]] = None,
                 max_spot_price_as_percentage_of_optimal_on_demand_price: Optional[pulumi.Input[_builtins.int]] = None,
                 memory_gi_b_per_v_cpu: Optional[pulumi.Input['Ec2FleetMemoryGiBPerVCpuRequestArgs']] = None,
                 memory_mi_b: Optional[pulumi.Input['Ec2FleetMemoryMiBRequestArgs']] = None,
                 network_bandwidth_gbps: Optional[pulumi.Input['Ec2FleetNetworkBandwidthGbpsRequestArgs']] = None,
                 network_interface_count: Optional[pulumi.Input['Ec2FleetNetworkInterfaceCountRequestArgs']] = None,
                 on_demand_max_price_percentage_over_lowest_price: Optional[pulumi.Input[_builtins.int]] = None,
                 require_hibernate_support: Optional[pulumi.Input[_builtins.bool]] = None,
                 spot_max_price_percentage_over_lowest_price: Optional[pulumi.Input[_builtins.int]] = None,
                 total_local_storage_gb: Optional[pulumi.Input['Ec2FleetTotalLocalStorageGbRequestArgs']] = None,
                 v_cpu_count: Optional[pulumi.Input['Ec2FleetVCpuCountRangeRequestArgs']] = None):
        """
        :param pulumi.Input['Ec2FleetAcceleratorCountRequestArgs'] accelerator_count: The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.
               
               To exclude accelerator-enabled instance types, set `Max` to `0` .
               
               Default: No minimum or maximum limits
        :param pulumi.Input[Sequence[pulumi.Input['Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem']]] accelerator_manufacturers: Indicates whether instance types must have accelerators by specific manufacturers.
               
               - For instance types with AWS devices, specify `amazon-web-services` .
               - For instance types with AMD devices, specify `amd` .
               - For instance types with Habana devices, specify `habana` .
               - For instance types with NVIDIA devices, specify `nvidia` .
               - For instance types with Xilinx devices, specify `xilinx` .
               
               Default: Any manufacturer
        :param pulumi.Input[Sequence[pulumi.Input['Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem']]] accelerator_names: The accelerators that must be on the instance type.
               
               - For instance types with NVIDIA A10G GPUs, specify `a10g` .
               - For instance types with NVIDIA A100 GPUs, specify `a100` .
               - For instance types with NVIDIA H100 GPUs, specify `h100` .
               - For instance types with AWS Inferentia chips, specify `inferentia` .
               - For instance types with NVIDIA GRID K520 GPUs, specify `k520` .
               - For instance types with NVIDIA K80 GPUs, specify `k80` .
               - For instance types with NVIDIA M60 GPUs, specify `m60` .
               - For instance types with AMD Radeon Pro V520 GPUs, specify `radeon-pro-v520` .
               - For instance types with NVIDIA T4 GPUs, specify `t4` .
               - For instance types with NVIDIA T4G GPUs, specify `t4g` .
               - For instance types with Xilinx VU9P FPGAs, specify `vu9p` .
               - For instance types with NVIDIA V100 GPUs, specify `v100` .
               
               Default: Any accelerator
        :param pulumi.Input['Ec2FleetAcceleratorTotalMemoryMiBRequestArgs'] accelerator_total_memory_mi_b: The minimum and maximum amount of total accelerator memory, in MiB.
               
               Default: No minimum or maximum limits
        :param pulumi.Input[Sequence[pulumi.Input['Ec2FleetInstanceRequirementsRequestAcceleratorTypesItem']]] accelerator_types: The accelerator types that must be on the instance type.
               
               - For instance types with FPGA accelerators, specify `fpga` .
               - For instance types with GPU accelerators, specify `gpu` .
               - For instance types with Inference accelerators, specify `inference` .
               
               Default: Any accelerator type
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_instance_types: The instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes.
               
               You can use strings with one or more wild cards, represented by an asterisk ( `*` ), to allow an instance type, size, or generation. The following are examples: `m5.8xlarge` , `c5*.*` , `m5a.*` , `r*` , `*3*` .
               
               For example, if you specify `c5*` ,Amazon EC2 will allow the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*` , Amazon EC2 will allow all the M5a instance types, but not the M5n instance types.
               
               > If you specify `AllowedInstanceTypes` , you can't specify `ExcludedInstanceTypes` . 
               
               Default: All instance types
        :param pulumi.Input['Ec2FleetInstanceRequirementsRequestBareMetal'] bare_metal: Indicates whether bare metal instance types must be included, excluded, or required.
               
               - To include bare metal instance types, specify `included` .
               - To require only bare metal instance types, specify `required` .
               - To exclude bare metal instance types, specify `excluded` .
               
               Default: `excluded`
        :param pulumi.Input['Ec2FleetBaselineEbsBandwidthMbpsRequestArgs'] baseline_ebs_bandwidth_mbps: The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see [Amazon EBSoptimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the *Amazon EC2 User Guide* .
               
               Default: No minimum or maximum limits
        :param pulumi.Input['Ec2FleetBaselinePerformanceFactorsRequestArgs'] baseline_performance_factors: The baseline performance to consider, using an instance family as a baseline reference. The instance family establishes the lowest acceptable level of performance. Amazon EC2 uses this baseline to guide instance type selection, but there is no guarantee that the selected instance types will always exceed the baseline for every application. Currently, this parameter only supports CPU performance as a baseline performance factor. For more information, see [Performance protection](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html#ec2fleet-abis-performance-protection) in the *Amazon EC2 User Guide* .
        :param pulumi.Input['Ec2FleetInstanceRequirementsRequestBurstablePerformance'] burstable_performance: Indicates whether burstable performance T instance types are included, excluded, or required. For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) .
               
               - To include burstable performance instance types, specify `included` .
               - To require only burstable performance instance types, specify `required` .
               - To exclude burstable performance instance types, specify `excluded` .
               
               Default: `excluded`
        :param pulumi.Input[Sequence[pulumi.Input['Ec2FleetInstanceRequirementsRequestCpuManufacturersItem']]] cpu_manufacturers: The CPU manufacturers to include.
               
               - For instance types with Intel CPUs, specify `intel` .
               - For instance types with AMD CPUs, specify `amd` .
               - For instance types with AWS CPUs, specify `amazon-web-services` .
               - For instance types with Apple CPUs, specify `apple` .
               
               > Don't confuse the CPU manufacturer with the CPU architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template. 
               
               Default: Any manufacturer
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] excluded_instance_types: The instance types to exclude.
               
               You can use strings with one or more wild cards, represented by an asterisk ( `*` ), to exclude an instance family, type, size, or generation. The following are examples: `m5.8xlarge` , `c5*.*` , `m5a.*` , `r*` , `*3*` .
               
               For example, if you specify `c5*` ,Amazon EC2 will exclude the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*` , Amazon EC2 will exclude all the M5a instance types, but not the M5n instance types.
               
               > If you specify `ExcludedInstanceTypes` , you can't specify `AllowedInstanceTypes` . 
               
               Default: No excluded instance types
        :param pulumi.Input[Sequence[pulumi.Input['Ec2FleetInstanceRequirementsRequestInstanceGenerationsItem']]] instance_generations: Indicates whether current or previous generation instance types are included. The current generation instance types are recommended for use. Current generation instance types are typically the latest two to three generations in each instance family. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .
               
               For current generation instance types, specify `current` .
               
               For previous generation instance types, specify `previous` .
               
               Default: Current and previous generation instance types
        :param pulumi.Input['Ec2FleetInstanceRequirementsRequestLocalStorage'] local_storage: Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, [Amazon EC2 instance store](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html) in the *Amazon EC2 User Guide* .
               
               - To include instance types with instance store volumes, specify `included` .
               - To require only instance types with instance store volumes, specify `required` .
               - To exclude instance types with instance store volumes, specify `excluded` .
               
               Default: `included`
        :param pulumi.Input[Sequence[pulumi.Input['Ec2FleetInstanceRequirementsRequestLocalStorageTypesItem']]] local_storage_types: The type of local storage that is required.
               
               - For instance types with hard disk drive (HDD) storage, specify `hdd` .
               - For instance types with solid state drive (SSD) storage, specify `ssd` .
               
               Default: `hdd` and `ssd`
        :param pulumi.Input[_builtins.int] max_spot_price_as_percentage_of_optimal_on_demand_price: [Price protection] The price protection threshold for Spot Instances, as a percentage of an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.
               
               The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
               
               If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is based on the per vCPU or per memory price instead of the per instance price.
               
               > Only one of `SpotMaxPricePercentageOverLowestPrice` or `MaxSpotPriceAsPercentageOfOptimalOnDemandPrice` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as `999999` .
        :param pulumi.Input['Ec2FleetMemoryGiBPerVCpuRequestArgs'] memory_gi_b_per_v_cpu: The minimum and maximum amount of memory per vCPU, in GiB.
               
               Default: No minimum or maximum limits
        :param pulumi.Input['Ec2FleetMemoryMiBRequestArgs'] memory_mi_b: The minimum and maximum amount of memory, in MiB.
        :param pulumi.Input['Ec2FleetNetworkBandwidthGbpsRequestArgs'] network_bandwidth_gbps: The minimum and maximum amount of baseline network bandwidth, in gigabits per second (Gbps). For more information, see [Amazon EC2 instance network bandwidth](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-network-bandwidth.html) in the *Amazon EC2 User Guide* .
               
               Default: No minimum or maximum limits
        :param pulumi.Input['Ec2FleetNetworkInterfaceCountRequestArgs'] network_interface_count: The minimum and maximum number of network interfaces.
               
               Default: No minimum or maximum limits
        :param pulumi.Input[_builtins.int] on_demand_max_price_percentage_over_lowest_price: [Price protection] The price protection threshold for On-Demand Instances, as a percentage higher than an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.
               
               The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
               
               To indicate no price protection threshold, specify a high value, such as `999999` .
               
               This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) .
               
               > If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price. 
               
               Default: `20`
        :param pulumi.Input[_builtins.bool] require_hibernate_support: Indicates whether instance types must support hibernation for On-Demand Instances.
               
               This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) .
               
               Default: `false`
        :param pulumi.Input[_builtins.int] spot_max_price_percentage_over_lowest_price: [Price protection] The price protection threshold for Spot Instances, as a percentage higher than an identified Spot price. The identified Spot price is the Spot price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified Spot price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose Spot price exceeds your specified threshold.
               
               The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
               
               If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.
               
               This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) .
               
               > Only one of `SpotMaxPricePercentageOverLowestPrice` or `MaxSpotPriceAsPercentageOfOptimalOnDemandPrice` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as `999999` . 
               
               Default: `100`
        :param pulumi.Input['Ec2FleetTotalLocalStorageGbRequestArgs'] total_local_storage_gb: The minimum and maximum amount of total local storage, in GB.
               
               Default: No minimum or maximum limits
        :param pulumi.Input['Ec2FleetVCpuCountRangeRequestArgs'] v_cpu_count: The minimum and maximum number of vCPUs.
        """
        if accelerator_count is not None:
            pulumi.set(__self__, "accelerator_count", accelerator_count)
        if accelerator_manufacturers is not None:
            pulumi.set(__self__, "accelerator_manufacturers", accelerator_manufacturers)
        if accelerator_names is not None:
            pulumi.set(__self__, "accelerator_names", accelerator_names)
        if accelerator_total_memory_mi_b is not None:
            pulumi.set(__self__, "accelerator_total_memory_mi_b", accelerator_total_memory_mi_b)
        if accelerator_types is not None:
            pulumi.set(__self__, "accelerator_types", accelerator_types)
        if allowed_instance_types is not None:
            pulumi.set(__self__, "allowed_instance_types", allowed_instance_types)
        if bare_metal is not None:
            pulumi.set(__self__, "bare_metal", bare_metal)
        if baseline_ebs_bandwidth_mbps is not None:
            pulumi.set(__self__, "baseline_ebs_bandwidth_mbps", baseline_ebs_bandwidth_mbps)
        if baseline_performance_factors is not None:
            pulumi.set(__self__, "baseline_performance_factors", baseline_performance_factors)
        if burstable_performance is not None:
            pulumi.set(__self__, "burstable_performance", burstable_performance)
        if cpu_manufacturers is not None:
            pulumi.set(__self__, "cpu_manufacturers", cpu_manufacturers)
        if excluded_instance_types is not None:
            pulumi.set(__self__, "excluded_instance_types", excluded_instance_types)
        if instance_generations is not None:
            pulumi.set(__self__, "instance_generations", instance_generations)
        if local_storage is not None:
            pulumi.set(__self__, "local_storage", local_storage)
        if local_storage_types is not None:
            pulumi.set(__self__, "local_storage_types", local_storage_types)
        if max_spot_price_as_percentage_of_optimal_on_demand_price is not None:
            pulumi.set(__self__, "max_spot_price_as_percentage_of_optimal_on_demand_price", max_spot_price_as_percentage_of_optimal_on_demand_price)
        if memory_gi_b_per_v_cpu is not None:
            pulumi.set(__self__, "memory_gi_b_per_v_cpu", memory_gi_b_per_v_cpu)
        if memory_mi_b is not None:
            pulumi.set(__self__, "memory_mi_b", memory_mi_b)
        if network_bandwidth_gbps is not None:
            pulumi.set(__self__, "network_bandwidth_gbps", network_bandwidth_gbps)
        if network_interface_count is not None:
            pulumi.set(__self__, "network_interface_count", network_interface_count)
        if on_demand_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "on_demand_max_price_percentage_over_lowest_price", on_demand_max_price_percentage_over_lowest_price)
        if require_hibernate_support is not None:
            pulumi.set(__self__, "require_hibernate_support", require_hibernate_support)
        if spot_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "spot_max_price_percentage_over_lowest_price", spot_max_price_percentage_over_lowest_price)
        if total_local_storage_gb is not None:
            pulumi.set(__self__, "total_local_storage_gb", total_local_storage_gb)
        if v_cpu_count is not None:
            pulumi.set(__self__, "v_cpu_count", v_cpu_count)

    @_builtins.property
    @pulumi.getter(name="acceleratorCount")
    def accelerator_count(self) -> Optional[pulumi.Input['Ec2FleetAcceleratorCountRequestArgs']]:
        """
        The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.

        To exclude accelerator-enabled instance types, set `Max` to `0` .

        Default: No minimum or maximum limits
        """
        return pulumi.get(self, "accelerator_count")

    @accelerator_count.setter
    def accelerator_count(self, value: Optional[pulumi.Input['Ec2FleetAcceleratorCountRequestArgs']]):
        pulumi.set(self, "accelerator_count", value)

    @_builtins.property
    @pulumi.getter(name="acceleratorManufacturers")
    def accelerator_manufacturers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem']]]]:
        """
        Indicates whether instance types must have accelerators by specific manufacturers.

        - For instance types with AWS devices, specify `amazon-web-services` .
        - For instance types with AMD devices, specify `amd` .
        - For instance types with Habana devices, specify `habana` .
        - For instance types with NVIDIA devices, specify `nvidia` .
        - For instance types with Xilinx devices, specify `xilinx` .

        Default: Any manufacturer
        """
        return pulumi.get(self, "accelerator_manufacturers")

    @accelerator_manufacturers.setter
    def accelerator_manufacturers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem']]]]):
        pulumi.set(self, "accelerator_manufacturers", value)

    @_builtins.property
    @pulumi.getter(name="acceleratorNames")
    def accelerator_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem']]]]:
        """
        The accelerators that must be on the instance type.

        - For instance types with NVIDIA A10G GPUs, specify `a10g` .
        - For instance types with NVIDIA A100 GPUs, specify `a100` .
        - For instance types with NVIDIA H100 GPUs, specify `h100` .
        - For instance types with AWS Inferentia chips, specify `inferentia` .
        - For instance types with NVIDIA GRID K520 GPUs, specify `k520` .
        - For instance types with NVIDIA K80 GPUs, specify `k80` .
        - For instance types with NVIDIA M60 GPUs, specify `m60` .
        - For instance types with AMD Radeon Pro V520 GPUs, specify `radeon-pro-v520` .
        - For instance types with NVIDIA T4 GPUs, specify `t4` .
        - For instance types with NVIDIA T4G GPUs, specify `t4g` .
        - For instance types with Xilinx VU9P FPGAs, specify `vu9p` .
        - For instance types with NVIDIA V100 GPUs, specify `v100` .

        Default: Any accelerator
        """
        return pulumi.get(self, "accelerator_names")

    @accelerator_names.setter
    def accelerator_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem']]]]):
        pulumi.set(self, "accelerator_names", value)

    @_builtins.property
    @pulumi.getter(name="acceleratorTotalMemoryMiB")
    def accelerator_total_memory_mi_b(self) -> Optional[pulumi.Input['Ec2FleetAcceleratorTotalMemoryMiBRequestArgs']]:
        """
        The minimum and maximum amount of total accelerator memory, in MiB.

        Default: No minimum or maximum limits
        """
        return pulumi.get(self, "accelerator_total_memory_mi_b")

    @accelerator_total_memory_mi_b.setter
    def accelerator_total_memory_mi_b(self, value: Optional[pulumi.Input['Ec2FleetAcceleratorTotalMemoryMiBRequestArgs']]):
        pulumi.set(self, "accelerator_total_memory_mi_b", value)

    @_builtins.property
    @pulumi.getter(name="acceleratorTypes")
    def accelerator_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Ec2FleetInstanceRequirementsRequestAcceleratorTypesItem']]]]:
        """
        The accelerator types that must be on the instance type.

        - For instance types with FPGA accelerators, specify `fpga` .
        - For instance types with GPU accelerators, specify `gpu` .
        - For instance types with Inference accelerators, specify `inference` .

        Default: Any accelerator type
        """
        return pulumi.get(self, "accelerator_types")

    @accelerator_types.setter
    def accelerator_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Ec2FleetInstanceRequirementsRequestAcceleratorTypesItem']]]]):
        pulumi.set(self, "accelerator_types", value)

    @_builtins.property
    @pulumi.getter(name="allowedInstanceTypes")
    def allowed_instance_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes.

        You can use strings with one or more wild cards, represented by an asterisk ( `*` ), to allow an instance type, size, or generation. The following are examples: `m5.8xlarge` , `c5*.*` , `m5a.*` , `r*` , `*3*` .

        For example, if you specify `c5*` ,Amazon EC2 will allow the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*` , Amazon EC2 will allow all the M5a instance types, but not the M5n instance types.

        > If you specify `AllowedInstanceTypes` , you can't specify `ExcludedInstanceTypes` . 

        Default: All instance types
        """
        return pulumi.get(self, "allowed_instance_types")

    @allowed_instance_types.setter
    def allowed_instance_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_instance_types", value)

    @_builtins.property
    @pulumi.getter(name="bareMetal")
    def bare_metal(self) -> Optional[pulumi.Input['Ec2FleetInstanceRequirementsRequestBareMetal']]:
        """
        Indicates whether bare metal instance types must be included, excluded, or required.

        - To include bare metal instance types, specify `included` .
        - To require only bare metal instance types, specify `required` .
        - To exclude bare metal instance types, specify `excluded` .

        Default: `excluded`
        """
        return pulumi.get(self, "bare_metal")

    @bare_metal.setter
    def bare_metal(self, value: Optional[pulumi.Input['Ec2FleetInstanceRequirementsRequestBareMetal']]):
        pulumi.set(self, "bare_metal", value)

    @_builtins.property
    @pulumi.getter(name="baselineEbsBandwidthMbps")
    def baseline_ebs_bandwidth_mbps(self) -> Optional[pulumi.Input['Ec2FleetBaselineEbsBandwidthMbpsRequestArgs']]:
        """
        The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see [Amazon EBSoptimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the *Amazon EC2 User Guide* .

        Default: No minimum or maximum limits
        """
        return pulumi.get(self, "baseline_ebs_bandwidth_mbps")

    @baseline_ebs_bandwidth_mbps.setter
    def baseline_ebs_bandwidth_mbps(self, value: Optional[pulumi.Input['Ec2FleetBaselineEbsBandwidthMbpsRequestArgs']]):
        pulumi.set(self, "baseline_ebs_bandwidth_mbps", value)

    @_builtins.property
    @pulumi.getter(name="baselinePerformanceFactors")
    def baseline_performance_factors(self) -> Optional[pulumi.Input['Ec2FleetBaselinePerformanceFactorsRequestArgs']]:
        """
        The baseline performance to consider, using an instance family as a baseline reference. The instance family establishes the lowest acceptable level of performance. Amazon EC2 uses this baseline to guide instance type selection, but there is no guarantee that the selected instance types will always exceed the baseline for every application. Currently, this parameter only supports CPU performance as a baseline performance factor. For more information, see [Performance protection](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html#ec2fleet-abis-performance-protection) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "baseline_performance_factors")

    @baseline_performance_factors.setter
    def baseline_performance_factors(self, value: Optional[pulumi.Input['Ec2FleetBaselinePerformanceFactorsRequestArgs']]):
        pulumi.set(self, "baseline_performance_factors", value)

    @_builtins.property
    @pulumi.getter(name="burstablePerformance")
    def burstable_performance(self) -> Optional[pulumi.Input['Ec2FleetInstanceRequirementsRequestBurstablePerformance']]:
        """
        Indicates whether burstable performance T instance types are included, excluded, or required. For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) .

        - To include burstable performance instance types, specify `included` .
        - To require only burstable performance instance types, specify `required` .
        - To exclude burstable performance instance types, specify `excluded` .

        Default: `excluded`
        """
        return pulumi.get(self, "burstable_performance")

    @burstable_performance.setter
    def burstable_performance(self, value: Optional[pulumi.Input['Ec2FleetInstanceRequirementsRequestBurstablePerformance']]):
        pulumi.set(self, "burstable_performance", value)

    @_builtins.property
    @pulumi.getter(name="cpuManufacturers")
    def cpu_manufacturers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Ec2FleetInstanceRequirementsRequestCpuManufacturersItem']]]]:
        """
        The CPU manufacturers to include.

        - For instance types with Intel CPUs, specify `intel` .
        - For instance types with AMD CPUs, specify `amd` .
        - For instance types with AWS CPUs, specify `amazon-web-services` .
        - For instance types with Apple CPUs, specify `apple` .

        > Don't confuse the CPU manufacturer with the CPU architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template. 

        Default: Any manufacturer
        """
        return pulumi.get(self, "cpu_manufacturers")

    @cpu_manufacturers.setter
    def cpu_manufacturers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Ec2FleetInstanceRequirementsRequestCpuManufacturersItem']]]]):
        pulumi.set(self, "cpu_manufacturers", value)

    @_builtins.property
    @pulumi.getter(name="excludedInstanceTypes")
    def excluded_instance_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The instance types to exclude.

        You can use strings with one or more wild cards, represented by an asterisk ( `*` ), to exclude an instance family, type, size, or generation. The following are examples: `m5.8xlarge` , `c5*.*` , `m5a.*` , `r*` , `*3*` .

        For example, if you specify `c5*` ,Amazon EC2 will exclude the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*` , Amazon EC2 will exclude all the M5a instance types, but not the M5n instance types.

        > If you specify `ExcludedInstanceTypes` , you can't specify `AllowedInstanceTypes` . 

        Default: No excluded instance types
        """
        return pulumi.get(self, "excluded_instance_types")

    @excluded_instance_types.setter
    def excluded_instance_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_instance_types", value)

    @_builtins.property
    @pulumi.getter(name="instanceGenerations")
    def instance_generations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Ec2FleetInstanceRequirementsRequestInstanceGenerationsItem']]]]:
        """
        Indicates whether current or previous generation instance types are included. The current generation instance types are recommended for use. Current generation instance types are typically the latest two to three generations in each instance family. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .

        For current generation instance types, specify `current` .

        For previous generation instance types, specify `previous` .

        Default: Current and previous generation instance types
        """
        return pulumi.get(self, "instance_generations")

    @instance_generations.setter
    def instance_generations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Ec2FleetInstanceRequirementsRequestInstanceGenerationsItem']]]]):
        pulumi.set(self, "instance_generations", value)

    @_builtins.property
    @pulumi.getter(name="localStorage")
    def local_storage(self) -> Optional[pulumi.Input['Ec2FleetInstanceRequirementsRequestLocalStorage']]:
        """
        Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, [Amazon EC2 instance store](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html) in the *Amazon EC2 User Guide* .

        - To include instance types with instance store volumes, specify `included` .
        - To require only instance types with instance store volumes, specify `required` .
        - To exclude instance types with instance store volumes, specify `excluded` .

        Default: `included`
        """
        return pulumi.get(self, "local_storage")

    @local_storage.setter
    def local_storage(self, value: Optional[pulumi.Input['Ec2FleetInstanceRequirementsRequestLocalStorage']]):
        pulumi.set(self, "local_storage", value)

    @_builtins.property
    @pulumi.getter(name="localStorageTypes")
    def local_storage_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Ec2FleetInstanceRequirementsRequestLocalStorageTypesItem']]]]:
        """
        The type of local storage that is required.

        - For instance types with hard disk drive (HDD) storage, specify `hdd` .
        - For instance types with solid state drive (SSD) storage, specify `ssd` .

        Default: `hdd` and `ssd`
        """
        return pulumi.get(self, "local_storage_types")

    @local_storage_types.setter
    def local_storage_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Ec2FleetInstanceRequirementsRequestLocalStorageTypesItem']]]]):
        pulumi.set(self, "local_storage_types", value)

    @_builtins.property
    @pulumi.getter(name="maxSpotPriceAsPercentageOfOptimalOnDemandPrice")
    def max_spot_price_as_percentage_of_optimal_on_demand_price(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        [Price protection] The price protection threshold for Spot Instances, as a percentage of an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.

        The parameter accepts an integer, which Amazon EC2 interprets as a percentage.

        If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is based on the per vCPU or per memory price instead of the per instance price.

        > Only one of `SpotMaxPricePercentageOverLowestPrice` or `MaxSpotPriceAsPercentageOfOptimalOnDemandPrice` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as `999999` .
        """
        return pulumi.get(self, "max_spot_price_as_percentage_of_optimal_on_demand_price")

    @max_spot_price_as_percentage_of_optimal_on_demand_price.setter
    def max_spot_price_as_percentage_of_optimal_on_demand_price(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_spot_price_as_percentage_of_optimal_on_demand_price", value)

    @_builtins.property
    @pulumi.getter(name="memoryGiBPerVCpu")
    def memory_gi_b_per_v_cpu(self) -> Optional[pulumi.Input['Ec2FleetMemoryGiBPerVCpuRequestArgs']]:
        """
        The minimum and maximum amount of memory per vCPU, in GiB.

        Default: No minimum or maximum limits
        """
        return pulumi.get(self, "memory_gi_b_per_v_cpu")

    @memory_gi_b_per_v_cpu.setter
    def memory_gi_b_per_v_cpu(self, value: Optional[pulumi.Input['Ec2FleetMemoryGiBPerVCpuRequestArgs']]):
        pulumi.set(self, "memory_gi_b_per_v_cpu", value)

    @_builtins.property
    @pulumi.getter(name="memoryMiB")
    def memory_mi_b(self) -> Optional[pulumi.Input['Ec2FleetMemoryMiBRequestArgs']]:
        """
        The minimum and maximum amount of memory, in MiB.
        """
        return pulumi.get(self, "memory_mi_b")

    @memory_mi_b.setter
    def memory_mi_b(self, value: Optional[pulumi.Input['Ec2FleetMemoryMiBRequestArgs']]):
        pulumi.set(self, "memory_mi_b", value)

    @_builtins.property
    @pulumi.getter(name="networkBandwidthGbps")
    def network_bandwidth_gbps(self) -> Optional[pulumi.Input['Ec2FleetNetworkBandwidthGbpsRequestArgs']]:
        """
        The minimum and maximum amount of baseline network bandwidth, in gigabits per second (Gbps). For more information, see [Amazon EC2 instance network bandwidth](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-network-bandwidth.html) in the *Amazon EC2 User Guide* .

        Default: No minimum or maximum limits
        """
        return pulumi.get(self, "network_bandwidth_gbps")

    @network_bandwidth_gbps.setter
    def network_bandwidth_gbps(self, value: Optional[pulumi.Input['Ec2FleetNetworkBandwidthGbpsRequestArgs']]):
        pulumi.set(self, "network_bandwidth_gbps", value)

    @_builtins.property
    @pulumi.getter(name="networkInterfaceCount")
    def network_interface_count(self) -> Optional[pulumi.Input['Ec2FleetNetworkInterfaceCountRequestArgs']]:
        """
        The minimum and maximum number of network interfaces.

        Default: No minimum or maximum limits
        """
        return pulumi.get(self, "network_interface_count")

    @network_interface_count.setter
    def network_interface_count(self, value: Optional[pulumi.Input['Ec2FleetNetworkInterfaceCountRequestArgs']]):
        pulumi.set(self, "network_interface_count", value)

    @_builtins.property
    @pulumi.getter(name="onDemandMaxPricePercentageOverLowestPrice")
    def on_demand_max_price_percentage_over_lowest_price(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        [Price protection] The price protection threshold for On-Demand Instances, as a percentage higher than an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.

        The parameter accepts an integer, which Amazon EC2 interprets as a percentage.

        To indicate no price protection threshold, specify a high value, such as `999999` .

        This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) .

        > If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price. 

        Default: `20`
        """
        return pulumi.get(self, "on_demand_max_price_percentage_over_lowest_price")

    @on_demand_max_price_percentage_over_lowest_price.setter
    def on_demand_max_price_percentage_over_lowest_price(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "on_demand_max_price_percentage_over_lowest_price", value)

    @_builtins.property
    @pulumi.getter(name="requireHibernateSupport")
    def require_hibernate_support(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether instance types must support hibernation for On-Demand Instances.

        This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) .

        Default: `false`
        """
        return pulumi.get(self, "require_hibernate_support")

    @require_hibernate_support.setter
    def require_hibernate_support(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "require_hibernate_support", value)

    @_builtins.property
    @pulumi.getter(name="spotMaxPricePercentageOverLowestPrice")
    def spot_max_price_percentage_over_lowest_price(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        [Price protection] The price protection threshold for Spot Instances, as a percentage higher than an identified Spot price. The identified Spot price is the Spot price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified Spot price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose Spot price exceeds your specified threshold.

        The parameter accepts an integer, which Amazon EC2 interprets as a percentage.

        If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.

        This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) .

        > Only one of `SpotMaxPricePercentageOverLowestPrice` or `MaxSpotPriceAsPercentageOfOptimalOnDemandPrice` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as `999999` . 

        Default: `100`
        """
        return pulumi.get(self, "spot_max_price_percentage_over_lowest_price")

    @spot_max_price_percentage_over_lowest_price.setter
    def spot_max_price_percentage_over_lowest_price(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "spot_max_price_percentage_over_lowest_price", value)

    @_builtins.property
    @pulumi.getter(name="totalLocalStorageGb")
    def total_local_storage_gb(self) -> Optional[pulumi.Input['Ec2FleetTotalLocalStorageGbRequestArgs']]:
        """
        The minimum and maximum amount of total local storage, in GB.

        Default: No minimum or maximum limits
        """
        return pulumi.get(self, "total_local_storage_gb")

    @total_local_storage_gb.setter
    def total_local_storage_gb(self, value: Optional[pulumi.Input['Ec2FleetTotalLocalStorageGbRequestArgs']]):
        pulumi.set(self, "total_local_storage_gb", value)

    @_builtins.property
    @pulumi.getter(name="vCpuCount")
    def v_cpu_count(self) -> Optional[pulumi.Input['Ec2FleetVCpuCountRangeRequestArgs']]:
        """
        The minimum and maximum number of vCPUs.
        """
        return pulumi.get(self, "v_cpu_count")

    @v_cpu_count.setter
    def v_cpu_count(self, value: Optional[pulumi.Input['Ec2FleetVCpuCountRangeRequestArgs']]):
        pulumi.set(self, "v_cpu_count", value)


if not MYPY:
    class Ec2FleetMaintenanceStrategiesArgsDict(TypedDict):
        capacity_rebalance: NotRequired[pulumi.Input['Ec2FleetCapacityRebalanceArgsDict']]
        """
        The strategy to use when Amazon EC2 emits a signal that your Spot Instance is at an elevated risk of being interrupted.
        """
elif False:
    Ec2FleetMaintenanceStrategiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Ec2FleetMaintenanceStrategiesArgs:
    def __init__(__self__, *,
                 capacity_rebalance: Optional[pulumi.Input['Ec2FleetCapacityRebalanceArgs']] = None):
        """
        :param pulumi.Input['Ec2FleetCapacityRebalanceArgs'] capacity_rebalance: The strategy to use when Amazon EC2 emits a signal that your Spot Instance is at an elevated risk of being interrupted.
        """
        if capacity_rebalance is not None:
            pulumi.set(__self__, "capacity_rebalance", capacity_rebalance)

    @_builtins.property
    @pulumi.getter(name="capacityRebalance")
    def capacity_rebalance(self) -> Optional[pulumi.Input['Ec2FleetCapacityRebalanceArgs']]:
        """
        The strategy to use when Amazon EC2 emits a signal that your Spot Instance is at an elevated risk of being interrupted.
        """
        return pulumi.get(self, "capacity_rebalance")

    @capacity_rebalance.setter
    def capacity_rebalance(self, value: Optional[pulumi.Input['Ec2FleetCapacityRebalanceArgs']]):
        pulumi.set(self, "capacity_rebalance", value)


if not MYPY:
    class Ec2FleetMemoryGiBPerVCpuRequestArgsDict(TypedDict):
        max: NotRequired[pulumi.Input[_builtins.float]]
        """
        The maximum amount of memory per vCPU, in GiB. To specify no maximum limit, omit this parameter.
        """
        min: NotRequired[pulumi.Input[_builtins.float]]
        """
        The minimum amount of memory per vCPU, in GiB. To specify no minimum limit, omit this parameter.
        """
elif False:
    Ec2FleetMemoryGiBPerVCpuRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Ec2FleetMemoryGiBPerVCpuRequestArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[_builtins.float]] = None,
                 min: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] max: The maximum amount of memory per vCPU, in GiB. To specify no maximum limit, omit this parameter.
        :param pulumi.Input[_builtins.float] min: The minimum amount of memory per vCPU, in GiB. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The maximum amount of memory per vCPU, in GiB. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The minimum amount of memory per vCPU, in GiB. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class Ec2FleetMemoryMiBRequestArgsDict(TypedDict):
        max: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum amount of memory, in MiB. To specify no maximum limit, omit this parameter.
        """
        min: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum amount of memory, in MiB. To specify no minimum limit, specify `0` .
        """
elif False:
    Ec2FleetMemoryMiBRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Ec2FleetMemoryMiBRequestArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[_builtins.int]] = None,
                 min: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] max: The maximum amount of memory, in MiB. To specify no maximum limit, omit this parameter.
        :param pulumi.Input[_builtins.int] min: The minimum amount of memory, in MiB. To specify no minimum limit, specify `0` .
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum amount of memory, in MiB. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum amount of memory, in MiB. To specify no minimum limit, specify `0` .
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class Ec2FleetNetworkBandwidthGbpsRequestArgsDict(TypedDict):
        max: NotRequired[pulumi.Input[_builtins.float]]
        """
        The maximum amount of network bandwidth, in Gbps. To specify no maximum limit, omit this parameter.
        """
        min: NotRequired[pulumi.Input[_builtins.float]]
        """
        The minimum amount of network bandwidth, in Gbps. To specify no minimum limit, omit this parameter.
        """
elif False:
    Ec2FleetNetworkBandwidthGbpsRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Ec2FleetNetworkBandwidthGbpsRequestArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[_builtins.float]] = None,
                 min: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] max: The maximum amount of network bandwidth, in Gbps. To specify no maximum limit, omit this parameter.
        :param pulumi.Input[_builtins.float] min: The minimum amount of network bandwidth, in Gbps. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The maximum amount of network bandwidth, in Gbps. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The minimum amount of network bandwidth, in Gbps. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class Ec2FleetNetworkInterfaceCountRequestArgsDict(TypedDict):
        max: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum number of network interfaces. To specify no maximum limit, omit this parameter.
        """
        min: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum number of network interfaces. To specify no minimum limit, omit this parameter.
        """
elif False:
    Ec2FleetNetworkInterfaceCountRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Ec2FleetNetworkInterfaceCountRequestArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[_builtins.int]] = None,
                 min: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] max: The maximum number of network interfaces. To specify no maximum limit, omit this parameter.
        :param pulumi.Input[_builtins.int] min: The minimum number of network interfaces. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum number of network interfaces. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum number of network interfaces. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class Ec2FleetOnDemandOptionsRequestArgsDict(TypedDict):
        allocation_strategy: NotRequired[pulumi.Input[_builtins.str]]
        """
        The strategy that determines the order of the launch template overrides to use in fulfilling On-Demand capacity.

        `lowest-price` - EC2 Fleet uses price to determine the order, launching the lowest price first.

        `prioritized` - EC2 Fleet uses the priority that you assigned to each launch template override, launching the highest priority first.

        Default: `lowest-price`
        """
        capacity_reservation_options: NotRequired[pulumi.Input['Ec2FleetCapacityReservationOptionsRequestArgsDict']]
        """
        The strategy for using unused Capacity Reservations for fulfilling On-Demand capacity.

        Supported only for fleets of type `instant` .
        """
        max_total_price: NotRequired[pulumi.Input[_builtins.str]]
        """
        The maximum amount per hour for On-Demand Instances that you're willing to pay.

        > If your fleet includes T instances that are configured as `unlimited` , and if their average CPU usage exceeds the baseline utilization, you will incur a charge for surplus credits. The `MaxTotalPrice` does not account for surplus credits, and, if you use surplus credits, your final cost might be higher than what you specified for `MaxTotalPrice` . For more information, see [Surplus credits can incur charges](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-unlimited-mode-concepts.html#unlimited-mode-surplus-credits) in the *Amazon EC2 User Guide* .
        """
        min_target_capacity: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum target capacity for On-Demand Instances in the fleet. If this minimum capacity isn't reached, no instances are launched.

        Constraints: Maximum value of `1000` . Supported only for fleets of type `instant` .

        At least one of the following must be specified: `SingleAvailabilityZone` | `SingleInstanceType`
        """
        single_availability_zone: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates that the fleet launches all On-Demand Instances into a single Availability Zone.

        Supported only for fleets of type `instant` .
        """
        single_instance_type: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates that the fleet uses a single instance type to launch all On-Demand Instances in the fleet.

        Supported only for fleets of type `instant` .
        """
elif False:
    Ec2FleetOnDemandOptionsRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Ec2FleetOnDemandOptionsRequestArgs:
    def __init__(__self__, *,
                 allocation_strategy: Optional[pulumi.Input[_builtins.str]] = None,
                 capacity_reservation_options: Optional[pulumi.Input['Ec2FleetCapacityReservationOptionsRequestArgs']] = None,
                 max_total_price: Optional[pulumi.Input[_builtins.str]] = None,
                 min_target_capacity: Optional[pulumi.Input[_builtins.int]] = None,
                 single_availability_zone: Optional[pulumi.Input[_builtins.bool]] = None,
                 single_instance_type: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] allocation_strategy: The strategy that determines the order of the launch template overrides to use in fulfilling On-Demand capacity.
               
               `lowest-price` - EC2 Fleet uses price to determine the order, launching the lowest price first.
               
               `prioritized` - EC2 Fleet uses the priority that you assigned to each launch template override, launching the highest priority first.
               
               Default: `lowest-price`
        :param pulumi.Input['Ec2FleetCapacityReservationOptionsRequestArgs'] capacity_reservation_options: The strategy for using unused Capacity Reservations for fulfilling On-Demand capacity.
               
               Supported only for fleets of type `instant` .
        :param pulumi.Input[_builtins.str] max_total_price: The maximum amount per hour for On-Demand Instances that you're willing to pay.
               
               > If your fleet includes T instances that are configured as `unlimited` , and if their average CPU usage exceeds the baseline utilization, you will incur a charge for surplus credits. The `MaxTotalPrice` does not account for surplus credits, and, if you use surplus credits, your final cost might be higher than what you specified for `MaxTotalPrice` . For more information, see [Surplus credits can incur charges](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-unlimited-mode-concepts.html#unlimited-mode-surplus-credits) in the *Amazon EC2 User Guide* .
        :param pulumi.Input[_builtins.int] min_target_capacity: The minimum target capacity for On-Demand Instances in the fleet. If this minimum capacity isn't reached, no instances are launched.
               
               Constraints: Maximum value of `1000` . Supported only for fleets of type `instant` .
               
               At least one of the following must be specified: `SingleAvailabilityZone` | `SingleInstanceType`
        :param pulumi.Input[_builtins.bool] single_availability_zone: Indicates that the fleet launches all On-Demand Instances into a single Availability Zone.
               
               Supported only for fleets of type `instant` .
        :param pulumi.Input[_builtins.bool] single_instance_type: Indicates that the fleet uses a single instance type to launch all On-Demand Instances in the fleet.
               
               Supported only for fleets of type `instant` .
        """
        if allocation_strategy is not None:
            pulumi.set(__self__, "allocation_strategy", allocation_strategy)
        if capacity_reservation_options is not None:
            pulumi.set(__self__, "capacity_reservation_options", capacity_reservation_options)
        if max_total_price is not None:
            pulumi.set(__self__, "max_total_price", max_total_price)
        if min_target_capacity is not None:
            pulumi.set(__self__, "min_target_capacity", min_target_capacity)
        if single_availability_zone is not None:
            pulumi.set(__self__, "single_availability_zone", single_availability_zone)
        if single_instance_type is not None:
            pulumi.set(__self__, "single_instance_type", single_instance_type)

    @_builtins.property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The strategy that determines the order of the launch template overrides to use in fulfilling On-Demand capacity.

        `lowest-price` - EC2 Fleet uses price to determine the order, launching the lowest price first.

        `prioritized` - EC2 Fleet uses the priority that you assigned to each launch template override, launching the highest priority first.

        Default: `lowest-price`
        """
        return pulumi.get(self, "allocation_strategy")

    @allocation_strategy.setter
    def allocation_strategy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "allocation_strategy", value)

    @_builtins.property
    @pulumi.getter(name="capacityReservationOptions")
    def capacity_reservation_options(self) -> Optional[pulumi.Input['Ec2FleetCapacityReservationOptionsRequestArgs']]:
        """
        The strategy for using unused Capacity Reservations for fulfilling On-Demand capacity.

        Supported only for fleets of type `instant` .
        """
        return pulumi.get(self, "capacity_reservation_options")

    @capacity_reservation_options.setter
    def capacity_reservation_options(self, value: Optional[pulumi.Input['Ec2FleetCapacityReservationOptionsRequestArgs']]):
        pulumi.set(self, "capacity_reservation_options", value)

    @_builtins.property
    @pulumi.getter(name="maxTotalPrice")
    def max_total_price(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The maximum amount per hour for On-Demand Instances that you're willing to pay.

        > If your fleet includes T instances that are configured as `unlimited` , and if their average CPU usage exceeds the baseline utilization, you will incur a charge for surplus credits. The `MaxTotalPrice` does not account for surplus credits, and, if you use surplus credits, your final cost might be higher than what you specified for `MaxTotalPrice` . For more information, see [Surplus credits can incur charges](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-unlimited-mode-concepts.html#unlimited-mode-surplus-credits) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "max_total_price")

    @max_total_price.setter
    def max_total_price(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_total_price", value)

    @_builtins.property
    @pulumi.getter(name="minTargetCapacity")
    def min_target_capacity(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum target capacity for On-Demand Instances in the fleet. If this minimum capacity isn't reached, no instances are launched.

        Constraints: Maximum value of `1000` . Supported only for fleets of type `instant` .

        At least one of the following must be specified: `SingleAvailabilityZone` | `SingleInstanceType`
        """
        return pulumi.get(self, "min_target_capacity")

    @min_target_capacity.setter
    def min_target_capacity(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_target_capacity", value)

    @_builtins.property
    @pulumi.getter(name="singleAvailabilityZone")
    def single_availability_zone(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates that the fleet launches all On-Demand Instances into a single Availability Zone.

        Supported only for fleets of type `instant` .
        """
        return pulumi.get(self, "single_availability_zone")

    @single_availability_zone.setter
    def single_availability_zone(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "single_availability_zone", value)

    @_builtins.property
    @pulumi.getter(name="singleInstanceType")
    def single_instance_type(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates that the fleet uses a single instance type to launch all On-Demand Instances in the fleet.

        Supported only for fleets of type `instant` .
        """
        return pulumi.get(self, "single_instance_type")

    @single_instance_type.setter
    def single_instance_type(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "single_instance_type", value)


if not MYPY:
    class Ec2FleetPerformanceFactorReferenceRequestArgsDict(TypedDict):
        instance_family: NotRequired[pulumi.Input[_builtins.str]]
        """
        The instance family to use as a baseline reference.

        > Ensure that you specify the correct value for the instance family. The instance family is everything before the period ( `.` ) in the instance type name. For example, in the instance type `c6i.large` , the instance family is `c6i` , not `c6` . For more information, see [Amazon EC2 instance type naming conventions](https://docs.aws.amazon.com/ec2/latest/instancetypes/instance-type-names.html) in *Amazon EC2 Instance Types* . 

        The following instance families are *not supported* for performance protection:

        - `c1`
        - `g3` | `g3s`
        - `hpc7g`
        - `m1` | `m2`
        - `mac1` | `mac2` | `mac2-m1ultra` | `mac2-m2` | `mac2-m2pro`
        - `p3dn` | `p4d` | `p5`
        - `t1`
        - `u-12tb1` | `u-18tb1` | `u-24tb1` | `u-3tb1` | `u-6tb1` | `u-9tb1` | `u7i-12tb` | `u7in-16tb` | `u7in-24tb` | `u7in-32tb`

        If you enable performance protection by specifying a supported instance family, the returned instance types will exclude the above unsupported instance families.

        If you specify an unsupported instance family as a value for baseline performance, the API returns an empty response response for [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) and an exception for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet.html) , [RequestSpotFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotFleet.html) , [ModifyFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyFleet.html) , and [ModifySpotFleetRequest](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifySpotFleetRequest.html) .
        """
elif False:
    Ec2FleetPerformanceFactorReferenceRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Ec2FleetPerformanceFactorReferenceRequestArgs:
    def __init__(__self__, *,
                 instance_family: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] instance_family: The instance family to use as a baseline reference.
               
               > Ensure that you specify the correct value for the instance family. The instance family is everything before the period ( `.` ) in the instance type name. For example, in the instance type `c6i.large` , the instance family is `c6i` , not `c6` . For more information, see [Amazon EC2 instance type naming conventions](https://docs.aws.amazon.com/ec2/latest/instancetypes/instance-type-names.html) in *Amazon EC2 Instance Types* . 
               
               The following instance families are *not supported* for performance protection:
               
               - `c1`
               - `g3` | `g3s`
               - `hpc7g`
               - `m1` | `m2`
               - `mac1` | `mac2` | `mac2-m1ultra` | `mac2-m2` | `mac2-m2pro`
               - `p3dn` | `p4d` | `p5`
               - `t1`
               - `u-12tb1` | `u-18tb1` | `u-24tb1` | `u-3tb1` | `u-6tb1` | `u-9tb1` | `u7i-12tb` | `u7in-16tb` | `u7in-24tb` | `u7in-32tb`
               
               If you enable performance protection by specifying a supported instance family, the returned instance types will exclude the above unsupported instance families.
               
               If you specify an unsupported instance family as a value for baseline performance, the API returns an empty response response for [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) and an exception for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet.html) , [RequestSpotFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotFleet.html) , [ModifyFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyFleet.html) , and [ModifySpotFleetRequest](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifySpotFleetRequest.html) .
        """
        if instance_family is not None:
            pulumi.set(__self__, "instance_family", instance_family)

    @_builtins.property
    @pulumi.getter(name="instanceFamily")
    def instance_family(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The instance family to use as a baseline reference.

        > Ensure that you specify the correct value for the instance family. The instance family is everything before the period ( `.` ) in the instance type name. For example, in the instance type `c6i.large` , the instance family is `c6i` , not `c6` . For more information, see [Amazon EC2 instance type naming conventions](https://docs.aws.amazon.com/ec2/latest/instancetypes/instance-type-names.html) in *Amazon EC2 Instance Types* . 

        The following instance families are *not supported* for performance protection:

        - `c1`
        - `g3` | `g3s`
        - `hpc7g`
        - `m1` | `m2`
        - `mac1` | `mac2` | `mac2-m1ultra` | `mac2-m2` | `mac2-m2pro`
        - `p3dn` | `p4d` | `p5`
        - `t1`
        - `u-12tb1` | `u-18tb1` | `u-24tb1` | `u-3tb1` | `u-6tb1` | `u-9tb1` | `u7i-12tb` | `u7in-16tb` | `u7in-24tb` | `u7in-32tb`

        If you enable performance protection by specifying a supported instance family, the returned instance types will exclude the above unsupported instance families.

        If you specify an unsupported instance family as a value for baseline performance, the API returns an empty response response for [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) and an exception for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet.html) , [RequestSpotFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotFleet.html) , [ModifyFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyFleet.html) , and [ModifySpotFleetRequest](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifySpotFleetRequest.html) .
        """
        return pulumi.get(self, "instance_family")

    @instance_family.setter
    def instance_family(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_family", value)


if not MYPY:
    class Ec2FleetPlacementArgsDict(TypedDict):
        affinity: NotRequired[pulumi.Input[_builtins.str]]
        """
        The affinity setting for the instance on the Dedicated Host.

        This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) or [ImportInstance](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html) .
        """
        availability_zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Availability Zone of the instance.

        On input, you can specify `AvailabilityZone` or `AvailabilityZoneId` , but not both. If you specify neither one, Amazon EC2 automatically selects an Availability Zone for you.

        This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) .
        """
        group_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the placement group that the instance is in.

        On input, you can specify `GroupId` or `GroupName` , but not both.
        """
        host_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the Dedicated Host on which the instance resides.

        This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) or [ImportInstance](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html) .
        """
        host_resource_group_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ARN of the host resource group in which to launch the instances.

        On input, if you specify this parameter, either omit the *Tenancy* parameter or set it to `host` .

        This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) .
        """
        partition_number: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of the partition that the instance is in. Valid only if the placement group strategy is set to `partition` .

        This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) .
        """
        spread_domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        Reserved for future use.
        """
        tenancy: NotRequired[pulumi.Input[_builtins.str]]
        """
        The tenancy of the instance. An instance with a tenancy of `dedicated` runs on single-tenant hardware.

        This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) . The `host` tenancy is not supported for [ImportInstance](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html) or for T3 instances that are configured for the `unlimited` CPU credit option.
        """
elif False:
    Ec2FleetPlacementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Ec2FleetPlacementArgs:
    def __init__(__self__, *,
                 affinity: Optional[pulumi.Input[_builtins.str]] = None,
                 availability_zone: Optional[pulumi.Input[_builtins.str]] = None,
                 group_name: Optional[pulumi.Input[_builtins.str]] = None,
                 host_id: Optional[pulumi.Input[_builtins.str]] = None,
                 host_resource_group_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 partition_number: Optional[pulumi.Input[_builtins.int]] = None,
                 spread_domain: Optional[pulumi.Input[_builtins.str]] = None,
                 tenancy: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] affinity: The affinity setting for the instance on the Dedicated Host.
               
               This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) or [ImportInstance](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html) .
        :param pulumi.Input[_builtins.str] availability_zone: The Availability Zone of the instance.
               
               On input, you can specify `AvailabilityZone` or `AvailabilityZoneId` , but not both. If you specify neither one, Amazon EC2 automatically selects an Availability Zone for you.
               
               This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) .
        :param pulumi.Input[_builtins.str] group_name: The name of the placement group that the instance is in.
               
               On input, you can specify `GroupId` or `GroupName` , but not both.
        :param pulumi.Input[_builtins.str] host_id: The ID of the Dedicated Host on which the instance resides.
               
               This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) or [ImportInstance](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html) .
        :param pulumi.Input[_builtins.str] host_resource_group_arn: The ARN of the host resource group in which to launch the instances.
               
               On input, if you specify this parameter, either omit the *Tenancy* parameter or set it to `host` .
               
               This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) .
        :param pulumi.Input[_builtins.int] partition_number: The number of the partition that the instance is in. Valid only if the placement group strategy is set to `partition` .
               
               This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) .
        :param pulumi.Input[_builtins.str] spread_domain: Reserved for future use.
        :param pulumi.Input[_builtins.str] tenancy: The tenancy of the instance. An instance with a tenancy of `dedicated` runs on single-tenant hardware.
               
               This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) . The `host` tenancy is not supported for [ImportInstance](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html) or for T3 instances that are configured for the `unlimited` CPU credit option.
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if host_id is not None:
            pulumi.set(__self__, "host_id", host_id)
        if host_resource_group_arn is not None:
            pulumi.set(__self__, "host_resource_group_arn", host_resource_group_arn)
        if partition_number is not None:
            pulumi.set(__self__, "partition_number", partition_number)
        if spread_domain is not None:
            pulumi.set(__self__, "spread_domain", spread_domain)
        if tenancy is not None:
            pulumi.set(__self__, "tenancy", tenancy)

    @_builtins.property
    @pulumi.getter
    def affinity(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The affinity setting for the instance on the Dedicated Host.

        This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) or [ImportInstance](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html) .
        """
        return pulumi.get(self, "affinity")

    @affinity.setter
    def affinity(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "affinity", value)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Availability Zone of the instance.

        On input, you can specify `AvailabilityZone` or `AvailabilityZoneId` , but not both. If you specify neither one, Amazon EC2 automatically selects an Availability Zone for you.

        This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) .
        """
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "availability_zone", value)

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the placement group that the instance is in.

        On input, you can specify `GroupId` or `GroupName` , but not both.
        """
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_name", value)

    @_builtins.property
    @pulumi.getter(name="hostId")
    def host_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the Dedicated Host on which the instance resides.

        This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) or [ImportInstance](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html) .
        """
        return pulumi.get(self, "host_id")

    @host_id.setter
    def host_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host_id", value)

    @_builtins.property
    @pulumi.getter(name="hostResourceGroupArn")
    def host_resource_group_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ARN of the host resource group in which to launch the instances.

        On input, if you specify this parameter, either omit the *Tenancy* parameter or set it to `host` .

        This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) .
        """
        return pulumi.get(self, "host_resource_group_arn")

    @host_resource_group_arn.setter
    def host_resource_group_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host_resource_group_arn", value)

    @_builtins.property
    @pulumi.getter(name="partitionNumber")
    def partition_number(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of the partition that the instance is in. Valid only if the placement group strategy is set to `partition` .

        This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) .
        """
        return pulumi.get(self, "partition_number")

    @partition_number.setter
    def partition_number(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "partition_number", value)

    @_builtins.property
    @pulumi.getter(name="spreadDomain")
    def spread_domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Reserved for future use.
        """
        return pulumi.get(self, "spread_domain")

    @spread_domain.setter
    def spread_domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "spread_domain", value)

    @_builtins.property
    @pulumi.getter
    def tenancy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The tenancy of the instance. An instance with a tenancy of `dedicated` runs on single-tenant hardware.

        This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) . The `host` tenancy is not supported for [ImportInstance](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html) or for T3 instances that are configured for the `unlimited` CPU credit option.
        """
        return pulumi.get(self, "tenancy")

    @tenancy.setter
    def tenancy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tenancy", value)


if not MYPY:
    class Ec2FleetSpotOptionsRequestArgsDict(TypedDict):
        allocation_strategy: NotRequired[pulumi.Input['Ec2FleetSpotOptionsRequestAllocationStrategy']]
        """
        Indicates how to allocate the target Spot Instance capacity across the Spot Instance pools specified by the EC2 Fleet.

        If the allocation strategy is `lowestPrice` , EC2 Fleet launches instances from the Spot Instance pools with the lowest price. This is the default allocation strategy.

        If the allocation strategy is `diversified` , EC2 Fleet launches instances from all the Spot Instance pools that you specify.

        If the allocation strategy is `capacityOptimized` , EC2 Fleet launches instances from Spot Instance pools that are optimally chosen based on the available Spot Instance capacity.

        *Allowed Values* : `lowestPrice` | `diversified` | `capacityOptimized` | `capacityOptimizedPrioritized`
        """
        instance_interruption_behavior: NotRequired[pulumi.Input['Ec2FleetSpotOptionsRequestInstanceInterruptionBehavior']]
        """
        The behavior when a Spot Instance is interrupted.

        Default: `terminate`
        """
        instance_pools_to_use_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of Spot pools across which to allocate your target Spot capacity. Supported only when Spot `AllocationStrategy` is set to `lowest-price` . EC2 Fleet selects the cheapest Spot pools and evenly allocates your target Spot capacity across the number of Spot pools that you specify.

        Note that EC2 Fleet attempts to draw Spot Instances from the number of pools that you specify on a best effort basis. If a pool runs out of Spot capacity before fulfilling your target capacity, EC2 Fleet will continue to fulfill your request by drawing from the next cheapest pool. To ensure that your target capacity is met, you might receive Spot Instances from more than the number of pools that you specified. Similarly, if most of the pools have no Spot capacity, you might receive your full target capacity from fewer than the number of pools that you specified.
        """
        maintenance_strategies: NotRequired[pulumi.Input['Ec2FleetMaintenanceStrategiesArgsDict']]
        """
        The strategies for managing your Spot Instances that are at an elevated risk of being interrupted.
        """
        max_total_price: NotRequired[pulumi.Input[_builtins.str]]
        """
        The maximum amount per hour for Spot Instances that you're willing to pay. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.

        > If you specify a maximum price, your Spot Instances will be interrupted more frequently than if you do not specify this parameter. > If your fleet includes T instances that are configured as `unlimited` , and if their average CPU usage exceeds the baseline utilization, you will incur a charge for surplus credits. The `MaxTotalPrice` does not account for surplus credits, and, if you use surplus credits, your final cost might be higher than what you specified for `MaxTotalPrice` . For more information, see [Surplus credits can incur charges](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-unlimited-mode-concepts.html#unlimited-mode-surplus-credits) in the *Amazon EC2 User Guide* .
        """
        min_target_capacity: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum target capacity for Spot Instances in the fleet. If this minimum capacity isn't reached, no instances are launched.

        Constraints: Maximum value of `1000` . Supported only for fleets of type `instant` .

        At least one of the following must be specified: `SingleAvailabilityZone` | `SingleInstanceType`
        """
        single_availability_zone: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates that the fleet launches all Spot Instances into a single Availability Zone.

        Supported only for fleets of type `instant` .
        """
        single_instance_type: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates that the fleet uses a single instance type to launch all Spot Instances in the fleet.

        Supported only for fleets of type `instant` .
        """
elif False:
    Ec2FleetSpotOptionsRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Ec2FleetSpotOptionsRequestArgs:
    def __init__(__self__, *,
                 allocation_strategy: Optional[pulumi.Input['Ec2FleetSpotOptionsRequestAllocationStrategy']] = None,
                 instance_interruption_behavior: Optional[pulumi.Input['Ec2FleetSpotOptionsRequestInstanceInterruptionBehavior']] = None,
                 instance_pools_to_use_count: Optional[pulumi.Input[_builtins.int]] = None,
                 maintenance_strategies: Optional[pulumi.Input['Ec2FleetMaintenanceStrategiesArgs']] = None,
                 max_total_price: Optional[pulumi.Input[_builtins.str]] = None,
                 min_target_capacity: Optional[pulumi.Input[_builtins.int]] = None,
                 single_availability_zone: Optional[pulumi.Input[_builtins.bool]] = None,
                 single_instance_type: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input['Ec2FleetSpotOptionsRequestAllocationStrategy'] allocation_strategy: Indicates how to allocate the target Spot Instance capacity across the Spot Instance pools specified by the EC2 Fleet.
               
               If the allocation strategy is `lowestPrice` , EC2 Fleet launches instances from the Spot Instance pools with the lowest price. This is the default allocation strategy.
               
               If the allocation strategy is `diversified` , EC2 Fleet launches instances from all the Spot Instance pools that you specify.
               
               If the allocation strategy is `capacityOptimized` , EC2 Fleet launches instances from Spot Instance pools that are optimally chosen based on the available Spot Instance capacity.
               
               *Allowed Values* : `lowestPrice` | `diversified` | `capacityOptimized` | `capacityOptimizedPrioritized`
        :param pulumi.Input['Ec2FleetSpotOptionsRequestInstanceInterruptionBehavior'] instance_interruption_behavior: The behavior when a Spot Instance is interrupted.
               
               Default: `terminate`
        :param pulumi.Input[_builtins.int] instance_pools_to_use_count: The number of Spot pools across which to allocate your target Spot capacity. Supported only when Spot `AllocationStrategy` is set to `lowest-price` . EC2 Fleet selects the cheapest Spot pools and evenly allocates your target Spot capacity across the number of Spot pools that you specify.
               
               Note that EC2 Fleet attempts to draw Spot Instances from the number of pools that you specify on a best effort basis. If a pool runs out of Spot capacity before fulfilling your target capacity, EC2 Fleet will continue to fulfill your request by drawing from the next cheapest pool. To ensure that your target capacity is met, you might receive Spot Instances from more than the number of pools that you specified. Similarly, if most of the pools have no Spot capacity, you might receive your full target capacity from fewer than the number of pools that you specified.
        :param pulumi.Input['Ec2FleetMaintenanceStrategiesArgs'] maintenance_strategies: The strategies for managing your Spot Instances that are at an elevated risk of being interrupted.
        :param pulumi.Input[_builtins.str] max_total_price: The maximum amount per hour for Spot Instances that you're willing to pay. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.
               
               > If you specify a maximum price, your Spot Instances will be interrupted more frequently than if you do not specify this parameter. > If your fleet includes T instances that are configured as `unlimited` , and if their average CPU usage exceeds the baseline utilization, you will incur a charge for surplus credits. The `MaxTotalPrice` does not account for surplus credits, and, if you use surplus credits, your final cost might be higher than what you specified for `MaxTotalPrice` . For more information, see [Surplus credits can incur charges](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-unlimited-mode-concepts.html#unlimited-mode-surplus-credits) in the *Amazon EC2 User Guide* .
        :param pulumi.Input[_builtins.int] min_target_capacity: The minimum target capacity for Spot Instances in the fleet. If this minimum capacity isn't reached, no instances are launched.
               
               Constraints: Maximum value of `1000` . Supported only for fleets of type `instant` .
               
               At least one of the following must be specified: `SingleAvailabilityZone` | `SingleInstanceType`
        :param pulumi.Input[_builtins.bool] single_availability_zone: Indicates that the fleet launches all Spot Instances into a single Availability Zone.
               
               Supported only for fleets of type `instant` .
        :param pulumi.Input[_builtins.bool] single_instance_type: Indicates that the fleet uses a single instance type to launch all Spot Instances in the fleet.
               
               Supported only for fleets of type `instant` .
        """
        if allocation_strategy is not None:
            pulumi.set(__self__, "allocation_strategy", allocation_strategy)
        if instance_interruption_behavior is not None:
            pulumi.set(__self__, "instance_interruption_behavior", instance_interruption_behavior)
        if instance_pools_to_use_count is not None:
            pulumi.set(__self__, "instance_pools_to_use_count", instance_pools_to_use_count)
        if maintenance_strategies is not None:
            pulumi.set(__self__, "maintenance_strategies", maintenance_strategies)
        if max_total_price is not None:
            pulumi.set(__self__, "max_total_price", max_total_price)
        if min_target_capacity is not None:
            pulumi.set(__self__, "min_target_capacity", min_target_capacity)
        if single_availability_zone is not None:
            pulumi.set(__self__, "single_availability_zone", single_availability_zone)
        if single_instance_type is not None:
            pulumi.set(__self__, "single_instance_type", single_instance_type)

    @_builtins.property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> Optional[pulumi.Input['Ec2FleetSpotOptionsRequestAllocationStrategy']]:
        """
        Indicates how to allocate the target Spot Instance capacity across the Spot Instance pools specified by the EC2 Fleet.

        If the allocation strategy is `lowestPrice` , EC2 Fleet launches instances from the Spot Instance pools with the lowest price. This is the default allocation strategy.

        If the allocation strategy is `diversified` , EC2 Fleet launches instances from all the Spot Instance pools that you specify.

        If the allocation strategy is `capacityOptimized` , EC2 Fleet launches instances from Spot Instance pools that are optimally chosen based on the available Spot Instance capacity.

        *Allowed Values* : `lowestPrice` | `diversified` | `capacityOptimized` | `capacityOptimizedPrioritized`
        """
        return pulumi.get(self, "allocation_strategy")

    @allocation_strategy.setter
    def allocation_strategy(self, value: Optional[pulumi.Input['Ec2FleetSpotOptionsRequestAllocationStrategy']]):
        pulumi.set(self, "allocation_strategy", value)

    @_builtins.property
    @pulumi.getter(name="instanceInterruptionBehavior")
    def instance_interruption_behavior(self) -> Optional[pulumi.Input['Ec2FleetSpotOptionsRequestInstanceInterruptionBehavior']]:
        """
        The behavior when a Spot Instance is interrupted.

        Default: `terminate`
        """
        return pulumi.get(self, "instance_interruption_behavior")

    @instance_interruption_behavior.setter
    def instance_interruption_behavior(self, value: Optional[pulumi.Input['Ec2FleetSpotOptionsRequestInstanceInterruptionBehavior']]):
        pulumi.set(self, "instance_interruption_behavior", value)

    @_builtins.property
    @pulumi.getter(name="instancePoolsToUseCount")
    def instance_pools_to_use_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of Spot pools across which to allocate your target Spot capacity. Supported only when Spot `AllocationStrategy` is set to `lowest-price` . EC2 Fleet selects the cheapest Spot pools and evenly allocates your target Spot capacity across the number of Spot pools that you specify.

        Note that EC2 Fleet attempts to draw Spot Instances from the number of pools that you specify on a best effort basis. If a pool runs out of Spot capacity before fulfilling your target capacity, EC2 Fleet will continue to fulfill your request by drawing from the next cheapest pool. To ensure that your target capacity is met, you might receive Spot Instances from more than the number of pools that you specified. Similarly, if most of the pools have no Spot capacity, you might receive your full target capacity from fewer than the number of pools that you specified.
        """
        return pulumi.get(self, "instance_pools_to_use_count")

    @instance_pools_to_use_count.setter
    def instance_pools_to_use_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "instance_pools_to_use_count", value)

    @_builtins.property
    @pulumi.getter(name="maintenanceStrategies")
    def maintenance_strategies(self) -> Optional[pulumi.Input['Ec2FleetMaintenanceStrategiesArgs']]:
        """
        The strategies for managing your Spot Instances that are at an elevated risk of being interrupted.
        """
        return pulumi.get(self, "maintenance_strategies")

    @maintenance_strategies.setter
    def maintenance_strategies(self, value: Optional[pulumi.Input['Ec2FleetMaintenanceStrategiesArgs']]):
        pulumi.set(self, "maintenance_strategies", value)

    @_builtins.property
    @pulumi.getter(name="maxTotalPrice")
    def max_total_price(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The maximum amount per hour for Spot Instances that you're willing to pay. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.

        > If you specify a maximum price, your Spot Instances will be interrupted more frequently than if you do not specify this parameter. > If your fleet includes T instances that are configured as `unlimited` , and if their average CPU usage exceeds the baseline utilization, you will incur a charge for surplus credits. The `MaxTotalPrice` does not account for surplus credits, and, if you use surplus credits, your final cost might be higher than what you specified for `MaxTotalPrice` . For more information, see [Surplus credits can incur charges](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-unlimited-mode-concepts.html#unlimited-mode-surplus-credits) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "max_total_price")

    @max_total_price.setter
    def max_total_price(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_total_price", value)

    @_builtins.property
    @pulumi.getter(name="minTargetCapacity")
    def min_target_capacity(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum target capacity for Spot Instances in the fleet. If this minimum capacity isn't reached, no instances are launched.

        Constraints: Maximum value of `1000` . Supported only for fleets of type `instant` .

        At least one of the following must be specified: `SingleAvailabilityZone` | `SingleInstanceType`
        """
        return pulumi.get(self, "min_target_capacity")

    @min_target_capacity.setter
    def min_target_capacity(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_target_capacity", value)

    @_builtins.property
    @pulumi.getter(name="singleAvailabilityZone")
    def single_availability_zone(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates that the fleet launches all Spot Instances into a single Availability Zone.

        Supported only for fleets of type `instant` .
        """
        return pulumi.get(self, "single_availability_zone")

    @single_availability_zone.setter
    def single_availability_zone(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "single_availability_zone", value)

    @_builtins.property
    @pulumi.getter(name="singleInstanceType")
    def single_instance_type(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates that the fleet uses a single instance type to launch all Spot Instances in the fleet.

        Supported only for fleets of type `instant` .
        """
        return pulumi.get(self, "single_instance_type")

    @single_instance_type.setter
    def single_instance_type(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "single_instance_type", value)


if not MYPY:
    class Ec2FleetTagSpecificationArgsDict(TypedDict):
        resource_type: NotRequired[pulumi.Input['Ec2FleetTagSpecificationResourceType']]
        """
        The type of resource to tag.
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['Ec2FleetTagArgsDict']]]]
        """
        The tags to apply to the resource.
        """
elif False:
    Ec2FleetTagSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Ec2FleetTagSpecificationArgs:
    def __init__(__self__, *,
                 resource_type: Optional[pulumi.Input['Ec2FleetTagSpecificationResourceType']] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['Ec2FleetTagArgs']]]] = None):
        """
        :param pulumi.Input['Ec2FleetTagSpecificationResourceType'] resource_type: The type of resource to tag.
        :param pulumi.Input[Sequence[pulumi.Input['Ec2FleetTagArgs']]] tags: The tags to apply to the resource.
        """
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[pulumi.Input['Ec2FleetTagSpecificationResourceType']]:
        """
        The type of resource to tag.
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: Optional[pulumi.Input['Ec2FleetTagSpecificationResourceType']]):
        pulumi.set(self, "resource_type", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Ec2FleetTagArgs']]]]:
        """
        The tags to apply to the resource.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Ec2FleetTagArgs']]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class Ec2FleetTagArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The tag key.
        """
        value: pulumi.Input[_builtins.str]
        """
        The tag value.
        """
elif False:
    Ec2FleetTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Ec2FleetTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The tag key.
        :param pulumi.Input[_builtins.str] value: The tag value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        The tag value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class Ec2FleetTargetCapacitySpecificationRequestArgsDict(TypedDict):
        total_target_capacity: pulumi.Input[_builtins.int]
        """
        The number of units to request, filled using the default target capacity type.
        """
        default_target_capacity_type: NotRequired[pulumi.Input['Ec2FleetTargetCapacitySpecificationRequestDefaultTargetCapacityType']]
        """
        The default target capacity type.
        """
        on_demand_target_capacity: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of On-Demand units to request.
        """
        spot_target_capacity: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of Spot units to request.
        """
        target_capacity_unit_type: NotRequired[pulumi.Input['Ec2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType']]
        """
        The unit for the target capacity. You can specify this parameter only when using attributed-based instance type selection.

        Default: `units` (the number of instances)
        """
elif False:
    Ec2FleetTargetCapacitySpecificationRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Ec2FleetTargetCapacitySpecificationRequestArgs:
    def __init__(__self__, *,
                 total_target_capacity: pulumi.Input[_builtins.int],
                 default_target_capacity_type: Optional[pulumi.Input['Ec2FleetTargetCapacitySpecificationRequestDefaultTargetCapacityType']] = None,
                 on_demand_target_capacity: Optional[pulumi.Input[_builtins.int]] = None,
                 spot_target_capacity: Optional[pulumi.Input[_builtins.int]] = None,
                 target_capacity_unit_type: Optional[pulumi.Input['Ec2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType']] = None):
        """
        :param pulumi.Input[_builtins.int] total_target_capacity: The number of units to request, filled using the default target capacity type.
        :param pulumi.Input['Ec2FleetTargetCapacitySpecificationRequestDefaultTargetCapacityType'] default_target_capacity_type: The default target capacity type.
        :param pulumi.Input[_builtins.int] on_demand_target_capacity: The number of On-Demand units to request.
        :param pulumi.Input[_builtins.int] spot_target_capacity: The number of Spot units to request.
        :param pulumi.Input['Ec2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType'] target_capacity_unit_type: The unit for the target capacity. You can specify this parameter only when using attributed-based instance type selection.
               
               Default: `units` (the number of instances)
        """
        pulumi.set(__self__, "total_target_capacity", total_target_capacity)
        if default_target_capacity_type is not None:
            pulumi.set(__self__, "default_target_capacity_type", default_target_capacity_type)
        if on_demand_target_capacity is not None:
            pulumi.set(__self__, "on_demand_target_capacity", on_demand_target_capacity)
        if spot_target_capacity is not None:
            pulumi.set(__self__, "spot_target_capacity", spot_target_capacity)
        if target_capacity_unit_type is not None:
            pulumi.set(__self__, "target_capacity_unit_type", target_capacity_unit_type)

    @_builtins.property
    @pulumi.getter(name="totalTargetCapacity")
    def total_target_capacity(self) -> pulumi.Input[_builtins.int]:
        """
        The number of units to request, filled using the default target capacity type.
        """
        return pulumi.get(self, "total_target_capacity")

    @total_target_capacity.setter
    def total_target_capacity(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "total_target_capacity", value)

    @_builtins.property
    @pulumi.getter(name="defaultTargetCapacityType")
    def default_target_capacity_type(self) -> Optional[pulumi.Input['Ec2FleetTargetCapacitySpecificationRequestDefaultTargetCapacityType']]:
        """
        The default target capacity type.
        """
        return pulumi.get(self, "default_target_capacity_type")

    @default_target_capacity_type.setter
    def default_target_capacity_type(self, value: Optional[pulumi.Input['Ec2FleetTargetCapacitySpecificationRequestDefaultTargetCapacityType']]):
        pulumi.set(self, "default_target_capacity_type", value)

    @_builtins.property
    @pulumi.getter(name="onDemandTargetCapacity")
    def on_demand_target_capacity(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of On-Demand units to request.
        """
        return pulumi.get(self, "on_demand_target_capacity")

    @on_demand_target_capacity.setter
    def on_demand_target_capacity(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "on_demand_target_capacity", value)

    @_builtins.property
    @pulumi.getter(name="spotTargetCapacity")
    def spot_target_capacity(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of Spot units to request.
        """
        return pulumi.get(self, "spot_target_capacity")

    @spot_target_capacity.setter
    def spot_target_capacity(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "spot_target_capacity", value)

    @_builtins.property
    @pulumi.getter(name="targetCapacityUnitType")
    def target_capacity_unit_type(self) -> Optional[pulumi.Input['Ec2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType']]:
        """
        The unit for the target capacity. You can specify this parameter only when using attributed-based instance type selection.

        Default: `units` (the number of instances)
        """
        return pulumi.get(self, "target_capacity_unit_type")

    @target_capacity_unit_type.setter
    def target_capacity_unit_type(self, value: Optional[pulumi.Input['Ec2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType']]):
        pulumi.set(self, "target_capacity_unit_type", value)


if not MYPY:
    class Ec2FleetTotalLocalStorageGbRequestArgsDict(TypedDict):
        max: NotRequired[pulumi.Input[_builtins.float]]
        """
        The maximum amount of total local storage, in GB. To specify no maximum limit, omit this parameter.
        """
        min: NotRequired[pulumi.Input[_builtins.float]]
        """
        The minimum amount of total local storage, in GB. To specify no minimum limit, omit this parameter.
        """
elif False:
    Ec2FleetTotalLocalStorageGbRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Ec2FleetTotalLocalStorageGbRequestArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[_builtins.float]] = None,
                 min: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] max: The maximum amount of total local storage, in GB. To specify no maximum limit, omit this parameter.
        :param pulumi.Input[_builtins.float] min: The minimum amount of total local storage, in GB. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The maximum amount of total local storage, in GB. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The minimum amount of total local storage, in GB. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class Ec2FleetVCpuCountRangeRequestArgsDict(TypedDict):
        max: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
        """
        min: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum number of vCPUs. To specify no minimum limit, specify `0` .
        """
elif False:
    Ec2FleetVCpuCountRangeRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Ec2FleetVCpuCountRangeRequestArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[_builtins.int]] = None,
                 min: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] max: The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
        :param pulumi.Input[_builtins.int] min: The minimum number of vCPUs. To specify no minimum limit, specify `0` .
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum number of vCPUs. To specify no minimum limit, specify `0` .
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class EnclaveOptionsPropertiesArgsDict(TypedDict):
        """
        Indicates whether the instance is enabled for AWS Nitro Enclaves.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If this parameter is set to true, the instance is enabled for AWS Nitro Enclaves; otherwise, it is not enabled for AWS Nitro Enclaves.
        """
elif False:
    EnclaveOptionsPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EnclaveOptionsPropertiesArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        Indicates whether the instance is enabled for AWS Nitro Enclaves.
        :param pulumi.Input[_builtins.bool] enabled: If this parameter is set to true, the instance is enabled for AWS Nitro Enclaves; otherwise, it is not enabled for AWS Nitro Enclaves.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If this parameter is set to true, the instance is enabled for AWS Nitro Enclaves; otherwise, it is not enabled for AWS Nitro Enclaves.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class HibernationOptionsPropertiesArgsDict(TypedDict):
        """
        Indicates whether an instance is enabled for hibernation.
        """
        configured: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If you set this parameter to true, your instance is enabled for hibernation.
        """
elif False:
    HibernationOptionsPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HibernationOptionsPropertiesArgs:
    def __init__(__self__, *,
                 configured: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        Indicates whether an instance is enabled for hibernation.
        :param pulumi.Input[_builtins.bool] configured: If you set this parameter to true, your instance is enabled for hibernation.
        """
        if configured is not None:
            pulumi.set(__self__, "configured", configured)

    @_builtins.property
    @pulumi.getter
    def configured(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If you set this parameter to true, your instance is enabled for hibernation.
        """
        return pulumi.get(self, "configured")

    @configured.setter
    def configured(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "configured", value)


if not MYPY:
    class InstanceAssociationParameterArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The name of an input parameter that is in the associated SSM document.
        """
        value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The value of an input parameter.
        """
elif False:
    InstanceAssociationParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceAssociationParameterArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[_builtins.str] key: The name of an input parameter that is in the associated SSM document.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] value: The value of an input parameter.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The name of an input parameter that is in the associated SSM document.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The value of an input parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class InstanceBlockDeviceMappingArgsDict(TypedDict):
        device_name: pulumi.Input[_builtins.str]
        """
        The device name (for example, /dev/sdh or xvdh).
        """
        ebs: NotRequired[pulumi.Input['InstanceEbsArgsDict']]
        """
        Parameters used to automatically set up EBS volumes when the instance is launched.
        """
        no_device: NotRequired[Any]
        """
        To omit the device from the block device mapping, specify an empty string.

        > After the instance is running, modifying this parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
        """
        virtual_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The virtual device name ( `ephemeral` N). The name must be in the form `ephemeral` *X* where *X* is a number starting from zero (0). For example, an instance type with 2 available instance store volumes can specify mappings for `ephemeral0` and `ephemeral1` . The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.

        NVMe instance store volumes are automatically enumerated and assigned a device name. Including them in your block device mapping has no effect.

        *Constraints* : For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.

        > After the instance is running, modifying this parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
        """
elif False:
    InstanceBlockDeviceMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceBlockDeviceMappingArgs:
    def __init__(__self__, *,
                 device_name: pulumi.Input[_builtins.str],
                 ebs: Optional[pulumi.Input['InstanceEbsArgs']] = None,
                 no_device: Optional[Any] = None,
                 virtual_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] device_name: The device name (for example, /dev/sdh or xvdh).
        :param pulumi.Input['InstanceEbsArgs'] ebs: Parameters used to automatically set up EBS volumes when the instance is launched.
        :param Any no_device: To omit the device from the block device mapping, specify an empty string.
               
               > After the instance is running, modifying this parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
        :param pulumi.Input[_builtins.str] virtual_name: The virtual device name ( `ephemeral` N). The name must be in the form `ephemeral` *X* where *X* is a number starting from zero (0). For example, an instance type with 2 available instance store volumes can specify mappings for `ephemeral0` and `ephemeral1` . The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.
               
               NVMe instance store volumes are automatically enumerated and assigned a device name. Including them in your block device mapping has no effect.
               
               *Constraints* : For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.
               
               > After the instance is running, modifying this parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
        """
        pulumi.set(__self__, "device_name", device_name)
        if ebs is not None:
            pulumi.set(__self__, "ebs", ebs)
        if no_device is not None:
            pulumi.set(__self__, "no_device", no_device)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> pulumi.Input[_builtins.str]:
        """
        The device name (for example, /dev/sdh or xvdh).
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "device_name", value)

    @_builtins.property
    @pulumi.getter
    def ebs(self) -> Optional[pulumi.Input['InstanceEbsArgs']]:
        """
        Parameters used to automatically set up EBS volumes when the instance is launched.
        """
        return pulumi.get(self, "ebs")

    @ebs.setter
    def ebs(self, value: Optional[pulumi.Input['InstanceEbsArgs']]):
        pulumi.set(self, "ebs", value)

    @_builtins.property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[Any]:
        """
        To omit the device from the block device mapping, specify an empty string.

        > After the instance is running, modifying this parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
        """
        return pulumi.get(self, "no_device")

    @no_device.setter
    def no_device(self, value: Optional[Any]):
        pulumi.set(self, "no_device", value)

    @_builtins.property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The virtual device name ( `ephemeral` N). The name must be in the form `ephemeral` *X* where *X* is a number starting from zero (0). For example, an instance type with 2 available instance store volumes can specify mappings for `ephemeral0` and `ephemeral1` . The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.

        NVMe instance store volumes are automatically enumerated and assigned a device name. Including them in your block device mapping has no effect.

        *Constraints* : For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.

        > After the instance is running, modifying this parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
        """
        return pulumi.get(self, "virtual_name")

    @virtual_name.setter
    def virtual_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "virtual_name", value)


if not MYPY:
    class InstanceEbsArgsDict(TypedDict):
        delete_on_termination: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the EBS volume is deleted on instance termination.
        """
        encrypted: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the volume should be encrypted.
        """
        iops: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of I/O operations per second (IOPS). For gp3, io1, and io2 volumes, this represents the number of IOPS that are provisioned for the volume. For gp2 volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.
        """
        kms_key_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The identifier of the AWS Key Management Service (AWS KMS) customer managed CMK to use for Amazon EBS encryption. If KmsKeyId is specified, the encrypted state must be true. If the encrypted state is true but you do not specify KmsKeyId, your AWS managed CMK for EBS is used.
        """
        snapshot_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the snapshot.
        """
        volume_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size.
        """
        volume_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The volume type.
        """
elif False:
    InstanceEbsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceEbsArgs:
    def __init__(__self__, *,
                 delete_on_termination: Optional[pulumi.Input[_builtins.bool]] = None,
                 encrypted: Optional[pulumi.Input[_builtins.bool]] = None,
                 iops: Optional[pulumi.Input[_builtins.int]] = None,
                 kms_key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 snapshot_id: Optional[pulumi.Input[_builtins.str]] = None,
                 volume_size: Optional[pulumi.Input[_builtins.int]] = None,
                 volume_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] delete_on_termination: Indicates whether the EBS volume is deleted on instance termination.
        :param pulumi.Input[_builtins.bool] encrypted: Indicates whether the volume should be encrypted.
        :param pulumi.Input[_builtins.int] iops: The number of I/O operations per second (IOPS). For gp3, io1, and io2 volumes, this represents the number of IOPS that are provisioned for the volume. For gp2 volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.
        :param pulumi.Input[_builtins.str] kms_key_id: The identifier of the AWS Key Management Service (AWS KMS) customer managed CMK to use for Amazon EBS encryption. If KmsKeyId is specified, the encrypted state must be true. If the encrypted state is true but you do not specify KmsKeyId, your AWS managed CMK for EBS is used.
        :param pulumi.Input[_builtins.str] snapshot_id: The ID of the snapshot.
        :param pulumi.Input[_builtins.int] volume_size: The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size.
        :param pulumi.Input[_builtins.str] volume_type: The volume type.
        """
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the EBS volume is deleted on instance termination.
        """
        return pulumi.get(self, "delete_on_termination")

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "delete_on_termination", value)

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the volume should be encrypted.
        """
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "encrypted", value)

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of I/O operations per second (IOPS). For gp3, io1, and io2 volumes, this represents the number of IOPS that are provisioned for the volume. For gp2 volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "iops", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The identifier of the AWS Key Management Service (AWS KMS) customer managed CMK to use for Amazon EBS encryption. If KmsKeyId is specified, the encrypted state must be true. If the encrypted state is true but you do not specify KmsKeyId, your AWS managed CMK for EBS is used.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_id", value)

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the snapshot.
        """
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "snapshot_id", value)

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size.
        """
        return pulumi.get(self, "volume_size")

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "volume_size", value)

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The volume type.
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "volume_type", value)


if not MYPY:
    class InstanceElasticGpuSpecificationArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        The type of Elastic Graphics accelerator. Amazon Elastic Graphics is no longer available.
        """
elif False:
    InstanceElasticGpuSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceElasticGpuSpecificationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] type: The type of Elastic Graphics accelerator. Amazon Elastic Graphics is no longer available.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of Elastic Graphics accelerator. Amazon Elastic Graphics is no longer available.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class InstanceElasticInferenceAcceleratorArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        The type of elastic inference accelerator. Amazon Elastic Inference is no longer available.
        """
        count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of elastic inference accelerators to attach to the instance. Amazon Elastic Inference is no longer available.
        """
elif False:
    InstanceElasticInferenceAcceleratorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceElasticInferenceAcceleratorArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 count: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] type: The type of elastic inference accelerator. Amazon Elastic Inference is no longer available.
        :param pulumi.Input[_builtins.int] count: The number of elastic inference accelerators to attach to the instance. Amazon Elastic Inference is no longer available.
        """
        pulumi.set(__self__, "type", type)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of elastic inference accelerator. Amazon Elastic Inference is no longer available.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of elastic inference accelerators to attach to the instance. Amazon Elastic Inference is no longer available.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "count", value)


if not MYPY:
    class InstanceEnaSrdSpecificationArgsDict(TypedDict):
        """
        Specifies the ENA Express settings for the network interface that's attached to the instance.
        """
        ena_srd_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether ENA Express is enabled for the network interface when you launch an instance.
        """
        ena_srd_udp_specification: NotRequired[pulumi.Input['InstanceEnaSrdUdpSpecificationArgsDict']]
        """
        Configures ENA Express for UDP network traffic.
        """
elif False:
    InstanceEnaSrdSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceEnaSrdSpecificationArgs:
    def __init__(__self__, *,
                 ena_srd_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 ena_srd_udp_specification: Optional[pulumi.Input['InstanceEnaSrdUdpSpecificationArgs']] = None):
        """
        Specifies the ENA Express settings for the network interface that's attached to the instance.
        :param pulumi.Input[_builtins.bool] ena_srd_enabled: Specifies whether ENA Express is enabled for the network interface when you launch an instance.
        :param pulumi.Input['InstanceEnaSrdUdpSpecificationArgs'] ena_srd_udp_specification: Configures ENA Express for UDP network traffic.
        """
        if ena_srd_enabled is not None:
            pulumi.set(__self__, "ena_srd_enabled", ena_srd_enabled)
        if ena_srd_udp_specification is not None:
            pulumi.set(__self__, "ena_srd_udp_specification", ena_srd_udp_specification)

    @_builtins.property
    @pulumi.getter(name="enaSrdEnabled")
    def ena_srd_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether ENA Express is enabled for the network interface when you launch an instance.
        """
        return pulumi.get(self, "ena_srd_enabled")

    @ena_srd_enabled.setter
    def ena_srd_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ena_srd_enabled", value)

    @_builtins.property
    @pulumi.getter(name="enaSrdUdpSpecification")
    def ena_srd_udp_specification(self) -> Optional[pulumi.Input['InstanceEnaSrdUdpSpecificationArgs']]:
        """
        Configures ENA Express for UDP network traffic.
        """
        return pulumi.get(self, "ena_srd_udp_specification")

    @ena_srd_udp_specification.setter
    def ena_srd_udp_specification(self, value: Optional[pulumi.Input['InstanceEnaSrdUdpSpecificationArgs']]):
        pulumi.set(self, "ena_srd_udp_specification", value)


if not MYPY:
    class InstanceEnaSrdUdpSpecificationArgsDict(TypedDict):
        """
        Contains ENA Express settings for UDP network traffic for the network interface that's attached to the instance.
        """
        ena_srd_udp_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether UDP traffic uses ENA Express for your instance.
        """
elif False:
    InstanceEnaSrdUdpSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceEnaSrdUdpSpecificationArgs:
    def __init__(__self__, *,
                 ena_srd_udp_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        Contains ENA Express settings for UDP network traffic for the network interface that's attached to the instance.
        :param pulumi.Input[_builtins.bool] ena_srd_udp_enabled: Indicates whether UDP traffic uses ENA Express for your instance.
        """
        if ena_srd_udp_enabled is not None:
            pulumi.set(__self__, "ena_srd_udp_enabled", ena_srd_udp_enabled)

    @_builtins.property
    @pulumi.getter(name="enaSrdUdpEnabled")
    def ena_srd_udp_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether UDP traffic uses ENA Express for your instance.
        """
        return pulumi.get(self, "ena_srd_udp_enabled")

    @ena_srd_udp_enabled.setter
    def ena_srd_udp_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ena_srd_udp_enabled", value)


if not MYPY:
    class InstanceIpv6AddressArgsDict(TypedDict):
        ipv6_address: pulumi.Input[_builtins.str]
        """
        The IPv6 address.
        """
elif False:
    InstanceIpv6AddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceIpv6AddressArgs:
    def __init__(__self__, *,
                 ipv6_address: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ipv6_address: The IPv6 address.
        """
        pulumi.set(__self__, "ipv6_address", ipv6_address)

    @_builtins.property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> pulumi.Input[_builtins.str]:
        """
        The IPv6 address.
        """
        return pulumi.get(self, "ipv6_address")

    @ipv6_address.setter
    def ipv6_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ipv6_address", value)


if not MYPY:
    class InstanceLaunchTemplateSpecificationArgsDict(TypedDict):
        launch_template_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the launch template. You must specify the LaunchTemplateName or the LaunchTemplateId, but not both.
        """
        launch_template_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the launch template. You must specify the LaunchTemplateName or the LaunchTemplateId, but not both.
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The version number of the launch template.
        """
elif False:
    InstanceLaunchTemplateSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceLaunchTemplateSpecificationArgs:
    def __init__(__self__, *,
                 launch_template_id: Optional[pulumi.Input[_builtins.str]] = None,
                 launch_template_name: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] launch_template_id: The ID of the launch template. You must specify the LaunchTemplateName or the LaunchTemplateId, but not both.
        :param pulumi.Input[_builtins.str] launch_template_name: The name of the launch template. You must specify the LaunchTemplateName or the LaunchTemplateId, but not both.
        :param pulumi.Input[_builtins.str] version: The version number of the launch template.
        """
        if launch_template_id is not None:
            pulumi.set(__self__, "launch_template_id", launch_template_id)
        if launch_template_name is not None:
            pulumi.set(__self__, "launch_template_name", launch_template_name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="launchTemplateId")
    def launch_template_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the launch template. You must specify the LaunchTemplateName or the LaunchTemplateId, but not both.
        """
        return pulumi.get(self, "launch_template_id")

    @launch_template_id.setter
    def launch_template_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "launch_template_id", value)

    @_builtins.property
    @pulumi.getter(name="launchTemplateName")
    def launch_template_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the launch template. You must specify the LaunchTemplateName or the LaunchTemplateId, but not both.
        """
        return pulumi.get(self, "launch_template_name")

    @launch_template_name.setter
    def launch_template_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "launch_template_name", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The version number of the launch template.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class InstanceLicenseSpecificationArgsDict(TypedDict):
        license_configuration_arn: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name (ARN) of the license configuration.
        """
elif False:
    InstanceLicenseSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceLicenseSpecificationArgs:
    def __init__(__self__, *,
                 license_configuration_arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] license_configuration_arn: The Amazon Resource Name (ARN) of the license configuration.
        """
        pulumi.set(__self__, "license_configuration_arn", license_configuration_arn)

    @_builtins.property
    @pulumi.getter(name="licenseConfigurationArn")
    def license_configuration_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the license configuration.
        """
        return pulumi.get(self, "license_configuration_arn")

    @license_configuration_arn.setter
    def license_configuration_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "license_configuration_arn", value)


if not MYPY:
    class InstanceMetadataOptionsArgsDict(TypedDict):
        http_endpoint: NotRequired[pulumi.Input['InstanceMetadataOptionsHttpEndpoint']]
        """
        Enables or disables the HTTP metadata endpoint on your instances. If you specify a value of disabled, you cannot access your instance metadata.
        """
        http_protocol_ipv6: NotRequired[pulumi.Input['InstanceMetadataOptionsHttpProtocolIpv6']]
        """
        Enables or disables the IPv6 endpoint for the instance metadata service. To use this option, the instance must be a Nitro-based instance launched in a subnet that supports IPv6.
        """
        http_put_response_hop_limit: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of network hops that the metadata token can travel. Maximum is 64.
        """
        http_tokens: NotRequired[pulumi.Input['InstanceMetadataOptionsHttpTokens']]
        """
        Indicates whether IMDSv2 is required.
        """
        instance_metadata_tags: NotRequired[pulumi.Input['InstanceMetadataOptionsInstanceMetadataTags']]
        """
        Indicates whether tags from the instance are propagated to the EBS volumes.
        """
elif False:
    InstanceMetadataOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceMetadataOptionsArgs:
    def __init__(__self__, *,
                 http_endpoint: Optional[pulumi.Input['InstanceMetadataOptionsHttpEndpoint']] = None,
                 http_protocol_ipv6: Optional[pulumi.Input['InstanceMetadataOptionsHttpProtocolIpv6']] = None,
                 http_put_response_hop_limit: Optional[pulumi.Input[_builtins.int]] = None,
                 http_tokens: Optional[pulumi.Input['InstanceMetadataOptionsHttpTokens']] = None,
                 instance_metadata_tags: Optional[pulumi.Input['InstanceMetadataOptionsInstanceMetadataTags']] = None):
        """
        :param pulumi.Input['InstanceMetadataOptionsHttpEndpoint'] http_endpoint: Enables or disables the HTTP metadata endpoint on your instances. If you specify a value of disabled, you cannot access your instance metadata.
        :param pulumi.Input['InstanceMetadataOptionsHttpProtocolIpv6'] http_protocol_ipv6: Enables or disables the IPv6 endpoint for the instance metadata service. To use this option, the instance must be a Nitro-based instance launched in a subnet that supports IPv6.
        :param pulumi.Input[_builtins.int] http_put_response_hop_limit: The number of network hops that the metadata token can travel. Maximum is 64.
        :param pulumi.Input['InstanceMetadataOptionsHttpTokens'] http_tokens: Indicates whether IMDSv2 is required.
        :param pulumi.Input['InstanceMetadataOptionsInstanceMetadataTags'] instance_metadata_tags: Indicates whether tags from the instance are propagated to the EBS volumes.
        """
        if http_endpoint is not None:
            pulumi.set(__self__, "http_endpoint", http_endpoint)
        if http_protocol_ipv6 is not None:
            pulumi.set(__self__, "http_protocol_ipv6", http_protocol_ipv6)
        if http_put_response_hop_limit is not None:
            pulumi.set(__self__, "http_put_response_hop_limit", http_put_response_hop_limit)
        if http_tokens is not None:
            pulumi.set(__self__, "http_tokens", http_tokens)
        if instance_metadata_tags is not None:
            pulumi.set(__self__, "instance_metadata_tags", instance_metadata_tags)

    @_builtins.property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> Optional[pulumi.Input['InstanceMetadataOptionsHttpEndpoint']]:
        """
        Enables or disables the HTTP metadata endpoint on your instances. If you specify a value of disabled, you cannot access your instance metadata.
        """
        return pulumi.get(self, "http_endpoint")

    @http_endpoint.setter
    def http_endpoint(self, value: Optional[pulumi.Input['InstanceMetadataOptionsHttpEndpoint']]):
        pulumi.set(self, "http_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="httpProtocolIpv6")
    def http_protocol_ipv6(self) -> Optional[pulumi.Input['InstanceMetadataOptionsHttpProtocolIpv6']]:
        """
        Enables or disables the IPv6 endpoint for the instance metadata service. To use this option, the instance must be a Nitro-based instance launched in a subnet that supports IPv6.
        """
        return pulumi.get(self, "http_protocol_ipv6")

    @http_protocol_ipv6.setter
    def http_protocol_ipv6(self, value: Optional[pulumi.Input['InstanceMetadataOptionsHttpProtocolIpv6']]):
        pulumi.set(self, "http_protocol_ipv6", value)

    @_builtins.property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of network hops that the metadata token can travel. Maximum is 64.
        """
        return pulumi.get(self, "http_put_response_hop_limit")

    @http_put_response_hop_limit.setter
    def http_put_response_hop_limit(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "http_put_response_hop_limit", value)

    @_builtins.property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> Optional[pulumi.Input['InstanceMetadataOptionsHttpTokens']]:
        """
        Indicates whether IMDSv2 is required.
        """
        return pulumi.get(self, "http_tokens")

    @http_tokens.setter
    def http_tokens(self, value: Optional[pulumi.Input['InstanceMetadataOptionsHttpTokens']]):
        pulumi.set(self, "http_tokens", value)

    @_builtins.property
    @pulumi.getter(name="instanceMetadataTags")
    def instance_metadata_tags(self) -> Optional[pulumi.Input['InstanceMetadataOptionsInstanceMetadataTags']]:
        """
        Indicates whether tags from the instance are propagated to the EBS volumes.
        """
        return pulumi.get(self, "instance_metadata_tags")

    @instance_metadata_tags.setter
    def instance_metadata_tags(self, value: Optional[pulumi.Input['InstanceMetadataOptionsInstanceMetadataTags']]):
        pulumi.set(self, "instance_metadata_tags", value)


if not MYPY:
    class InstanceNetworkInterfaceArgsDict(TypedDict):
        device_index: pulumi.Input[_builtins.str]
        """
        The position of the network interface in the attachment order. A primary network interface has a device index of 0.
        """
        associate_carrier_ip_address: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Not currently supported by AWS CloudFormation.
        """
        associate_public_ip_address: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether to assign a public IPv4 address to an instance you launch in a VPC.
        """
        delete_on_termination: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set to true, the interface is deleted when the instance is terminated.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the network interface.
        """
        ena_srd_specification: NotRequired[pulumi.Input['InstanceEnaSrdSpecificationArgsDict']]
        """
        Configures ENA Express for UDP network traffic.
        """
        group_set: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The IDs of the security groups for the network interface.
        """
        ipv6_address_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        A number of IPv6 addresses to assign to the network interface.
        """
        ipv6_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['InstanceIpv6AddressArgsDict']]]]
        """
        The IPv6 addresses associated with the network interface.
        """
        network_interface_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the network interface.
        """
        private_ip_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The private IPv4 address of the network interface.
        """
        private_ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['InstancePrivateIpAddressSpecificationArgsDict']]]]
        """
        One or more private IPv4 addresses to assign to the network interface.
        """
        secondary_private_ip_address_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of secondary private IPv4 addresses.
        """
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the subnet.
        """
elif False:
    InstanceNetworkInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceNetworkInterfaceArgs:
    def __init__(__self__, *,
                 device_index: pulumi.Input[_builtins.str],
                 associate_carrier_ip_address: Optional[pulumi.Input[_builtins.bool]] = None,
                 associate_public_ip_address: Optional[pulumi.Input[_builtins.bool]] = None,
                 delete_on_termination: Optional[pulumi.Input[_builtins.bool]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 ena_srd_specification: Optional[pulumi.Input['InstanceEnaSrdSpecificationArgs']] = None,
                 group_set: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 ipv6_address_count: Optional[pulumi.Input[_builtins.int]] = None,
                 ipv6_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceIpv6AddressArgs']]]] = None,
                 network_interface_id: Optional[pulumi.Input[_builtins.str]] = None,
                 private_ip_address: Optional[pulumi.Input[_builtins.str]] = None,
                 private_ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['InstancePrivateIpAddressSpecificationArgs']]]] = None,
                 secondary_private_ip_address_count: Optional[pulumi.Input[_builtins.int]] = None,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] device_index: The position of the network interface in the attachment order. A primary network interface has a device index of 0.
        :param pulumi.Input[_builtins.bool] associate_carrier_ip_address: Not currently supported by AWS CloudFormation.
        :param pulumi.Input[_builtins.bool] associate_public_ip_address: Indicates whether to assign a public IPv4 address to an instance you launch in a VPC.
        :param pulumi.Input[_builtins.bool] delete_on_termination: If set to true, the interface is deleted when the instance is terminated.
        :param pulumi.Input[_builtins.str] description: The description of the network interface.
        :param pulumi.Input['InstanceEnaSrdSpecificationArgs'] ena_srd_specification: Configures ENA Express for UDP network traffic.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] group_set: The IDs of the security groups for the network interface.
        :param pulumi.Input[_builtins.int] ipv6_address_count: A number of IPv6 addresses to assign to the network interface.
        :param pulumi.Input[Sequence[pulumi.Input['InstanceIpv6AddressArgs']]] ipv6_addresses: The IPv6 addresses associated with the network interface.
        :param pulumi.Input[_builtins.str] network_interface_id: The ID of the network interface.
        :param pulumi.Input[_builtins.str] private_ip_address: The private IPv4 address of the network interface.
        :param pulumi.Input[Sequence[pulumi.Input['InstancePrivateIpAddressSpecificationArgs']]] private_ip_addresses: One or more private IPv4 addresses to assign to the network interface.
        :param pulumi.Input[_builtins.int] secondary_private_ip_address_count: The number of secondary private IPv4 addresses.
        :param pulumi.Input[_builtins.str] subnet_id: The ID of the subnet.
        """
        pulumi.set(__self__, "device_index", device_index)
        if associate_carrier_ip_address is not None:
            pulumi.set(__self__, "associate_carrier_ip_address", associate_carrier_ip_address)
        if associate_public_ip_address is not None:
            pulumi.set(__self__, "associate_public_ip_address", associate_public_ip_address)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ena_srd_specification is not None:
            pulumi.set(__self__, "ena_srd_specification", ena_srd_specification)
        if group_set is not None:
            pulumi.set(__self__, "group_set", group_set)
        if ipv6_address_count is not None:
            pulumi.set(__self__, "ipv6_address_count", ipv6_address_count)
        if ipv6_addresses is not None:
            pulumi.set(__self__, "ipv6_addresses", ipv6_addresses)
        if network_interface_id is not None:
            pulumi.set(__self__, "network_interface_id", network_interface_id)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)
        if private_ip_addresses is not None:
            pulumi.set(__self__, "private_ip_addresses", private_ip_addresses)
        if secondary_private_ip_address_count is not None:
            pulumi.set(__self__, "secondary_private_ip_address_count", secondary_private_ip_address_count)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> pulumi.Input[_builtins.str]:
        """
        The position of the network interface in the attachment order. A primary network interface has a device index of 0.
        """
        return pulumi.get(self, "device_index")

    @device_index.setter
    def device_index(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "device_index", value)

    @_builtins.property
    @pulumi.getter(name="associateCarrierIpAddress")
    def associate_carrier_ip_address(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Not currently supported by AWS CloudFormation.
        """
        return pulumi.get(self, "associate_carrier_ip_address")

    @associate_carrier_ip_address.setter
    def associate_carrier_ip_address(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "associate_carrier_ip_address", value)

    @_builtins.property
    @pulumi.getter(name="associatePublicIpAddress")
    def associate_public_ip_address(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether to assign a public IPv4 address to an instance you launch in a VPC.
        """
        return pulumi.get(self, "associate_public_ip_address")

    @associate_public_ip_address.setter
    def associate_public_ip_address(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "associate_public_ip_address", value)

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set to true, the interface is deleted when the instance is terminated.
        """
        return pulumi.get(self, "delete_on_termination")

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "delete_on_termination", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the network interface.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="enaSrdSpecification")
    def ena_srd_specification(self) -> Optional[pulumi.Input['InstanceEnaSrdSpecificationArgs']]:
        """
        Configures ENA Express for UDP network traffic.
        """
        return pulumi.get(self, "ena_srd_specification")

    @ena_srd_specification.setter
    def ena_srd_specification(self, value: Optional[pulumi.Input['InstanceEnaSrdSpecificationArgs']]):
        pulumi.set(self, "ena_srd_specification", value)

    @_builtins.property
    @pulumi.getter(name="groupSet")
    def group_set(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The IDs of the security groups for the network interface.
        """
        return pulumi.get(self, "group_set")

    @group_set.setter
    def group_set(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "group_set", value)

    @_builtins.property
    @pulumi.getter(name="ipv6AddressCount")
    def ipv6_address_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        A number of IPv6 addresses to assign to the network interface.
        """
        return pulumi.get(self, "ipv6_address_count")

    @ipv6_address_count.setter
    def ipv6_address_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ipv6_address_count", value)

    @_builtins.property
    @pulumi.getter(name="ipv6Addresses")
    def ipv6_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstanceIpv6AddressArgs']]]]:
        """
        The IPv6 addresses associated with the network interface.
        """
        return pulumi.get(self, "ipv6_addresses")

    @ipv6_addresses.setter
    def ipv6_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceIpv6AddressArgs']]]]):
        pulumi.set(self, "ipv6_addresses", value)

    @_builtins.property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the network interface.
        """
        return pulumi.get(self, "network_interface_id")

    @network_interface_id.setter
    def network_interface_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "network_interface_id", value)

    @_builtins.property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The private IPv4 address of the network interface.
        """
        return pulumi.get(self, "private_ip_address")

    @private_ip_address.setter
    def private_ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_ip_address", value)

    @_builtins.property
    @pulumi.getter(name="privateIpAddresses")
    def private_ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstancePrivateIpAddressSpecificationArgs']]]]:
        """
        One or more private IPv4 addresses to assign to the network interface.
        """
        return pulumi.get(self, "private_ip_addresses")

    @private_ip_addresses.setter
    def private_ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstancePrivateIpAddressSpecificationArgs']]]]):
        pulumi.set(self, "private_ip_addresses", value)

    @_builtins.property
    @pulumi.getter(name="secondaryPrivateIpAddressCount")
    def secondary_private_ip_address_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of secondary private IPv4 addresses.
        """
        return pulumi.get(self, "secondary_private_ip_address_count")

    @secondary_private_ip_address_count.setter
    def secondary_private_ip_address_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "secondary_private_ip_address_count", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the subnet.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class InstancePrivateDnsNameOptionsArgsDict(TypedDict):
        enable_resource_name_dns_a_record: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether to respond to DNS queries for instance hostnames with DNS A records. For more information, see Amazon EC2 instance hostname types in the Amazon Elastic Compute Cloud User Guide.
        """
        enable_resource_name_dns_aaaa_record: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records. For more information, see Amazon EC2 instance hostname types in the Amazon Elastic Compute Cloud User Guide.
        """
        hostname_type: NotRequired[pulumi.Input['InstancePrivateDnsNameOptionsHostnameType']]
        """
        The type of hostnames to assign to instances in the subnet at launch. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. For more information, see Amazon EC2 instance hostname types in the Amazon Elastic Compute Cloud User Guide.
        """
elif False:
    InstancePrivateDnsNameOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstancePrivateDnsNameOptionsArgs:
    def __init__(__self__, *,
                 enable_resource_name_dns_a_record: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_resource_name_dns_aaaa_record: Optional[pulumi.Input[_builtins.bool]] = None,
                 hostname_type: Optional[pulumi.Input['InstancePrivateDnsNameOptionsHostnameType']] = None):
        """
        :param pulumi.Input[_builtins.bool] enable_resource_name_dns_a_record: Indicates whether to respond to DNS queries for instance hostnames with DNS A records. For more information, see Amazon EC2 instance hostname types in the Amazon Elastic Compute Cloud User Guide.
        :param pulumi.Input[_builtins.bool] enable_resource_name_dns_aaaa_record: Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records. For more information, see Amazon EC2 instance hostname types in the Amazon Elastic Compute Cloud User Guide.
        :param pulumi.Input['InstancePrivateDnsNameOptionsHostnameType'] hostname_type: The type of hostnames to assign to instances in the subnet at launch. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. For more information, see Amazon EC2 instance hostname types in the Amazon Elastic Compute Cloud User Guide.
        """
        if enable_resource_name_dns_a_record is not None:
            pulumi.set(__self__, "enable_resource_name_dns_a_record", enable_resource_name_dns_a_record)
        if enable_resource_name_dns_aaaa_record is not None:
            pulumi.set(__self__, "enable_resource_name_dns_aaaa_record", enable_resource_name_dns_aaaa_record)
        if hostname_type is not None:
            pulumi.set(__self__, "hostname_type", hostname_type)

    @_builtins.property
    @pulumi.getter(name="enableResourceNameDnsARecord")
    def enable_resource_name_dns_a_record(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether to respond to DNS queries for instance hostnames with DNS A records. For more information, see Amazon EC2 instance hostname types in the Amazon Elastic Compute Cloud User Guide.
        """
        return pulumi.get(self, "enable_resource_name_dns_a_record")

    @enable_resource_name_dns_a_record.setter
    def enable_resource_name_dns_a_record(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_resource_name_dns_a_record", value)

    @_builtins.property
    @pulumi.getter(name="enableResourceNameDnsAaaaRecord")
    def enable_resource_name_dns_aaaa_record(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records. For more information, see Amazon EC2 instance hostname types in the Amazon Elastic Compute Cloud User Guide.
        """
        return pulumi.get(self, "enable_resource_name_dns_aaaa_record")

    @enable_resource_name_dns_aaaa_record.setter
    def enable_resource_name_dns_aaaa_record(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_resource_name_dns_aaaa_record", value)

    @_builtins.property
    @pulumi.getter(name="hostnameType")
    def hostname_type(self) -> Optional[pulumi.Input['InstancePrivateDnsNameOptionsHostnameType']]:
        """
        The type of hostnames to assign to instances in the subnet at launch. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. For more information, see Amazon EC2 instance hostname types in the Amazon Elastic Compute Cloud User Guide.
        """
        return pulumi.get(self, "hostname_type")

    @hostname_type.setter
    def hostname_type(self, value: Optional[pulumi.Input['InstancePrivateDnsNameOptionsHostnameType']]):
        pulumi.set(self, "hostname_type", value)


if not MYPY:
    class InstancePrivateIpAddressSpecificationArgsDict(TypedDict):
        primary: pulumi.Input[_builtins.bool]
        """
        Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.
        """
        private_ip_address: pulumi.Input[_builtins.str]
        """
        The private IPv4 addresses.
        """
elif False:
    InstancePrivateIpAddressSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstancePrivateIpAddressSpecificationArgs:
    def __init__(__self__, *,
                 primary: pulumi.Input[_builtins.bool],
                 private_ip_address: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.bool] primary: Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.
        :param pulumi.Input[_builtins.str] private_ip_address: The private IPv4 addresses.
        """
        pulumi.set(__self__, "primary", primary)
        pulumi.set(__self__, "private_ip_address", private_ip_address)

    @_builtins.property
    @pulumi.getter
    def primary(self) -> pulumi.Input[_builtins.bool]:
        """
        Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.
        """
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "primary", value)

    @_builtins.property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> pulumi.Input[_builtins.str]:
        """
        The private IPv4 addresses.
        """
        return pulumi.get(self, "private_ip_address")

    @private_ip_address.setter
    def private_ip_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "private_ip_address", value)


if not MYPY:
    class InstanceSsmAssociationArgsDict(TypedDict):
        document_name: pulumi.Input[_builtins.str]
        """
        The name of an SSM document to associate with the instance.
        """
        association_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['InstanceAssociationParameterArgsDict']]]]
        """
        The input parameter values to use with the associated SSM document.
        """
elif False:
    InstanceSsmAssociationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceSsmAssociationArgs:
    def __init__(__self__, *,
                 document_name: pulumi.Input[_builtins.str],
                 association_parameters: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceAssociationParameterArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] document_name: The name of an SSM document to associate with the instance.
        :param pulumi.Input[Sequence[pulumi.Input['InstanceAssociationParameterArgs']]] association_parameters: The input parameter values to use with the associated SSM document.
        """
        pulumi.set(__self__, "document_name", document_name)
        if association_parameters is not None:
            pulumi.set(__self__, "association_parameters", association_parameters)

    @_builtins.property
    @pulumi.getter(name="documentName")
    def document_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of an SSM document to associate with the instance.
        """
        return pulumi.get(self, "document_name")

    @document_name.setter
    def document_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "document_name", value)

    @_builtins.property
    @pulumi.getter(name="associationParameters")
    def association_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstanceAssociationParameterArgs']]]]:
        """
        The input parameter values to use with the associated SSM document.
        """
        return pulumi.get(self, "association_parameters")

    @association_parameters.setter
    def association_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceAssociationParameterArgs']]]]):
        pulumi.set(self, "association_parameters", value)


if not MYPY:
    class InstanceVolumeArgsDict(TypedDict):
        device: pulumi.Input[_builtins.str]
        """
        The device name (for example, /dev/sdh or xvdh).
        """
        volume_id: pulumi.Input[_builtins.str]
        """
        The ID of the EBS volume. The volume and instance must be within the same Availability Zone.
        """
elif False:
    InstanceVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceVolumeArgs:
    def __init__(__self__, *,
                 device: pulumi.Input[_builtins.str],
                 volume_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] device: The device name (for example, /dev/sdh or xvdh).
        :param pulumi.Input[_builtins.str] volume_id: The ID of the EBS volume. The volume and instance must be within the same Availability Zone.
        """
        pulumi.set(__self__, "device", device)
        pulumi.set(__self__, "volume_id", volume_id)

    @_builtins.property
    @pulumi.getter
    def device(self) -> pulumi.Input[_builtins.str]:
        """
        The device name (for example, /dev/sdh or xvdh).
        """
        return pulumi.get(self, "device")

    @device.setter
    def device(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "device", value)

    @_builtins.property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the EBS volume. The volume and instance must be within the same Availability Zone.
        """
        return pulumi.get(self, "volume_id")

    @volume_id.setter
    def volume_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "volume_id", value)


if not MYPY:
    class IpamOperatingRegionArgsDict(TypedDict):
        """
        The regions IPAM is enabled for. Allows pools to be created in these regions, as well as enabling monitoring
        """
        region_name: pulumi.Input[_builtins.str]
        """
        The name of the region.
        """
elif False:
    IpamOperatingRegionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpamOperatingRegionArgs:
    def __init__(__self__, *,
                 region_name: pulumi.Input[_builtins.str]):
        """
        The regions IPAM is enabled for. Allows pools to be created in these regions, as well as enabling monitoring
        :param pulumi.Input[_builtins.str] region_name: The name of the region.
        """
        pulumi.set(__self__, "region_name", region_name)

    @_builtins.property
    @pulumi.getter(name="regionName")
    def region_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the region.
        """
        return pulumi.get(self, "region_name")

    @region_name.setter
    def region_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region_name", value)


if not MYPY:
    class IpamOrganizationalUnitExclusionArgsDict(TypedDict):
        """
        If your IPAM is integrated with AWS Organizations and you add an organizational unit (OU) exclusion, IPAM will not manage the IP addresses in accounts in that OU exclusion.
        """
        organizations_entity_path: pulumi.Input[_builtins.str]
        """
        An AWS Organizations entity path. Build the path for the OU(s) using AWS Organizations IDs separated by a '/'. Include all child OUs by ending the path with '/*'.
        """
elif False:
    IpamOrganizationalUnitExclusionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpamOrganizationalUnitExclusionArgs:
    def __init__(__self__, *,
                 organizations_entity_path: pulumi.Input[_builtins.str]):
        """
        If your IPAM is integrated with AWS Organizations and you add an organizational unit (OU) exclusion, IPAM will not manage the IP addresses in accounts in that OU exclusion.
        :param pulumi.Input[_builtins.str] organizations_entity_path: An AWS Organizations entity path. Build the path for the OU(s) using AWS Organizations IDs separated by a '/'. Include all child OUs by ending the path with '/*'.
        """
        pulumi.set(__self__, "organizations_entity_path", organizations_entity_path)

    @_builtins.property
    @pulumi.getter(name="organizationsEntityPath")
    def organizations_entity_path(self) -> pulumi.Input[_builtins.str]:
        """
        An AWS Organizations entity path. Build the path for the OU(s) using AWS Organizations IDs separated by a '/'. Include all child OUs by ending the path with '/*'.
        """
        return pulumi.get(self, "organizations_entity_path")

    @organizations_entity_path.setter
    def organizations_entity_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "organizations_entity_path", value)


if not MYPY:
    class IpamPoolProvisionedCidrArgsDict(TypedDict):
        """
        An address space to be inserted into this pool. All allocations must be made from this address space.
        """
        cidr: pulumi.Input[_builtins.str]
        """
        The CIDR provisioned to the IPAM pool. A CIDR is a representation of an IP address and its associated network mask (or netmask) and refers to a range of IP addresses. An IPv4 CIDR example is `10.24.34.0/23` . An IPv6 CIDR example is `2001:DB8::/32` .
        """
elif False:
    IpamPoolProvisionedCidrArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpamPoolProvisionedCidrArgs:
    def __init__(__self__, *,
                 cidr: pulumi.Input[_builtins.str]):
        """
        An address space to be inserted into this pool. All allocations must be made from this address space.
        :param pulumi.Input[_builtins.str] cidr: The CIDR provisioned to the IPAM pool. A CIDR is a representation of an IP address and its associated network mask (or netmask) and refers to a range of IP addresses. An IPv4 CIDR example is `10.24.34.0/23` . An IPv6 CIDR example is `2001:DB8::/32` .
        """
        pulumi.set(__self__, "cidr", cidr)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> pulumi.Input[_builtins.str]:
        """
        The CIDR provisioned to the IPAM pool. A CIDR is a representation of an IP address and its associated network mask (or netmask) and refers to a range of IP addresses. An IPv4 CIDR example is `10.24.34.0/23` . An IPv6 CIDR example is `2001:DB8::/32` .
        """
        return pulumi.get(self, "cidr")

    @cidr.setter
    def cidr(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cidr", value)


if not MYPY:
    class IpamPoolSourceResourceArgsDict(TypedDict):
        """
        The resource associated with this pool's space. Depending on the ResourceType, setting a SourceResource changes which space can be provisioned in this pool and which types of resources can receive allocations
        """
        resource_id: pulumi.Input[_builtins.str]
        """
        The source resource ID.
        """
        resource_owner: pulumi.Input[_builtins.str]
        """
        The source resource owner.
        """
        resource_region: pulumi.Input[_builtins.str]
        """
        The source resource Region.
        """
        resource_type: pulumi.Input[_builtins.str]
        """
        The source resource type.
        """
elif False:
    IpamPoolSourceResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpamPoolSourceResourceArgs:
    def __init__(__self__, *,
                 resource_id: pulumi.Input[_builtins.str],
                 resource_owner: pulumi.Input[_builtins.str],
                 resource_region: pulumi.Input[_builtins.str],
                 resource_type: pulumi.Input[_builtins.str]):
        """
        The resource associated with this pool's space. Depending on the ResourceType, setting a SourceResource changes which space can be provisioned in this pool and which types of resources can receive allocations
        :param pulumi.Input[_builtins.str] resource_id: The source resource ID.
        :param pulumi.Input[_builtins.str] resource_owner: The source resource owner.
        :param pulumi.Input[_builtins.str] resource_region: The source resource Region.
        :param pulumi.Input[_builtins.str] resource_type: The source resource type.
        """
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_owner", resource_owner)
        pulumi.set(__self__, "resource_region", resource_region)
        pulumi.set(__self__, "resource_type", resource_type)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> pulumi.Input[_builtins.str]:
        """
        The source resource ID.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_id", value)

    @_builtins.property
    @pulumi.getter(name="resourceOwner")
    def resource_owner(self) -> pulumi.Input[_builtins.str]:
        """
        The source resource owner.
        """
        return pulumi.get(self, "resource_owner")

    @resource_owner.setter
    def resource_owner(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_owner", value)

    @_builtins.property
    @pulumi.getter(name="resourceRegion")
    def resource_region(self) -> pulumi.Input[_builtins.str]:
        """
        The source resource Region.
        """
        return pulumi.get(self, "resource_region")

    @resource_region.setter
    def resource_region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_region", value)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> pulumi.Input[_builtins.str]:
        """
        The source resource type.
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_type", value)


if not MYPY:
    class IpamPoolTagArgsDict(TypedDict):
        """
        A key-value pair to associate with a resource.
        """
        key: pulumi.Input[_builtins.str]
        """
        The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        value: pulumi.Input[_builtins.str]
        """
        The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
elif False:
    IpamPoolTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpamPoolTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        A key-value pair to associate with a resource.
        :param pulumi.Input[_builtins.str] key: The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        :param pulumi.Input[_builtins.str] value: The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class IpamResourceDiscoveryIpamOperatingRegionArgsDict(TypedDict):
        """
        The regions IPAM Resource Discovery is enabled for. Allows for monitoring.
        """
        region_name: pulumi.Input[_builtins.str]
        """
        The name of the region.
        """
elif False:
    IpamResourceDiscoveryIpamOperatingRegionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpamResourceDiscoveryIpamOperatingRegionArgs:
    def __init__(__self__, *,
                 region_name: pulumi.Input[_builtins.str]):
        """
        The regions IPAM Resource Discovery is enabled for. Allows for monitoring.
        :param pulumi.Input[_builtins.str] region_name: The name of the region.
        """
        pulumi.set(__self__, "region_name", region_name)

    @_builtins.property
    @pulumi.getter(name="regionName")
    def region_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the region.
        """
        return pulumi.get(self, "region_name")

    @region_name.setter
    def region_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region_name", value)


if not MYPY:
    class IpamResourceDiscoveryOrganizationalUnitExclusionArgsDict(TypedDict):
        """
        If your IPAM is integrated with AWS Organizations and you add an organizational unit (OU) exclusion, IPAM will not manage the IP addresses in accounts in that OU exclusion.
        """
        organizations_entity_path: pulumi.Input[_builtins.str]
        """
        An AWS Organizations entity path. Build the path for the OU(s) using AWS Organizations IDs separated by a '/'. Include all child OUs by ending the path with '/*'.
        """
elif False:
    IpamResourceDiscoveryOrganizationalUnitExclusionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpamResourceDiscoveryOrganizationalUnitExclusionArgs:
    def __init__(__self__, *,
                 organizations_entity_path: pulumi.Input[_builtins.str]):
        """
        If your IPAM is integrated with AWS Organizations and you add an organizational unit (OU) exclusion, IPAM will not manage the IP addresses in accounts in that OU exclusion.
        :param pulumi.Input[_builtins.str] organizations_entity_path: An AWS Organizations entity path. Build the path for the OU(s) using AWS Organizations IDs separated by a '/'. Include all child OUs by ending the path with '/*'.
        """
        pulumi.set(__self__, "organizations_entity_path", organizations_entity_path)

    @_builtins.property
    @pulumi.getter(name="organizationsEntityPath")
    def organizations_entity_path(self) -> pulumi.Input[_builtins.str]:
        """
        An AWS Organizations entity path. Build the path for the OU(s) using AWS Organizations IDs separated by a '/'. Include all child OUs by ending the path with '/*'.
        """
        return pulumi.get(self, "organizations_entity_path")

    @organizations_entity_path.setter
    def organizations_entity_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "organizations_entity_path", value)


if not MYPY:
    class LaunchTemplateAcceleratorCountArgsDict(TypedDict):
        """
        The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.
        """
        max: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum number of accelerators. To specify no maximum limit, omit this parameter. To exclude accelerator-enabled instance types, set ``Max`` to ``0``.
        """
        min: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum number of accelerators. To specify no minimum limit, omit this parameter.
        """
elif False:
    LaunchTemplateAcceleratorCountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateAcceleratorCountArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[_builtins.int]] = None,
                 min: Optional[pulumi.Input[_builtins.int]] = None):
        """
        The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.
        :param pulumi.Input[_builtins.int] max: The maximum number of accelerators. To specify no maximum limit, omit this parameter. To exclude accelerator-enabled instance types, set ``Max`` to ``0``.
        :param pulumi.Input[_builtins.int] min: The minimum number of accelerators. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum number of accelerators. To specify no maximum limit, omit this parameter. To exclude accelerator-enabled instance types, set ``Max`` to ``0``.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum number of accelerators. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class LaunchTemplateAcceleratorTotalMemoryMiBArgsDict(TypedDict):
        """
        The minimum and maximum amount of total accelerator memory, in MiB.
        """
        max: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum amount of accelerator memory, in MiB. To specify no maximum limit, omit this parameter.
        """
        min: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum amount of accelerator memory, in MiB. To specify no minimum limit, omit this parameter.
        """
elif False:
    LaunchTemplateAcceleratorTotalMemoryMiBArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateAcceleratorTotalMemoryMiBArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[_builtins.int]] = None,
                 min: Optional[pulumi.Input[_builtins.int]] = None):
        """
        The minimum and maximum amount of total accelerator memory, in MiB.
        :param pulumi.Input[_builtins.int] max: The maximum amount of accelerator memory, in MiB. To specify no maximum limit, omit this parameter.
        :param pulumi.Input[_builtins.int] min: The minimum amount of accelerator memory, in MiB. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum amount of accelerator memory, in MiB. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum amount of accelerator memory, in MiB. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class LaunchTemplateBaselineEbsBandwidthMbpsArgsDict(TypedDict):
        """
        The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see [Amazon EBSoptimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the *Amazon EC2 User Guide*.
        """
        max: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum baseline bandwidth, in Mbps. To specify no maximum limit, omit this parameter.
        """
        min: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum baseline bandwidth, in Mbps. To specify no minimum limit, omit this parameter.
        """
elif False:
    LaunchTemplateBaselineEbsBandwidthMbpsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateBaselineEbsBandwidthMbpsArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[_builtins.int]] = None,
                 min: Optional[pulumi.Input[_builtins.int]] = None):
        """
        The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see [Amazon EBSoptimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the *Amazon EC2 User Guide*.
        :param pulumi.Input[_builtins.int] max: The maximum baseline bandwidth, in Mbps. To specify no maximum limit, omit this parameter.
        :param pulumi.Input[_builtins.int] min: The minimum baseline bandwidth, in Mbps. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum baseline bandwidth, in Mbps. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum baseline bandwidth, in Mbps. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class LaunchTemplateBaselinePerformanceFactorsArgsDict(TypedDict):
        """
        The baseline performance to consider, using an instance family as a baseline reference. The instance family establishes the lowest acceptable level of performance. Amazon EC2 uses this baseline to guide instance type selection, but there is no guarantee that the selected instance types will always exceed the baseline for every application.
         Currently, this parameter only supports CPU performance as a baseline performance factor. For example, specifying ``c6i`` would use the CPU performance of the ``c6i`` family as the baseline reference.
        """
        cpu: NotRequired[pulumi.Input['LaunchTemplateCpuArgsDict']]
        """
        The CPU performance to consider, using an instance family as the baseline reference.
        """
elif False:
    LaunchTemplateBaselinePerformanceFactorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateBaselinePerformanceFactorsArgs:
    def __init__(__self__, *,
                 cpu: Optional[pulumi.Input['LaunchTemplateCpuArgs']] = None):
        """
        The baseline performance to consider, using an instance family as a baseline reference. The instance family establishes the lowest acceptable level of performance. Amazon EC2 uses this baseline to guide instance type selection, but there is no guarantee that the selected instance types will always exceed the baseline for every application.
         Currently, this parameter only supports CPU performance as a baseline performance factor. For example, specifying ``c6i`` would use the CPU performance of the ``c6i`` family as the baseline reference.
        :param pulumi.Input['LaunchTemplateCpuArgs'] cpu: The CPU performance to consider, using an instance family as the baseline reference.
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input['LaunchTemplateCpuArgs']]:
        """
        The CPU performance to consider, using an instance family as the baseline reference.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input['LaunchTemplateCpuArgs']]):
        pulumi.set(self, "cpu", value)


if not MYPY:
    class LaunchTemplateBlockDeviceMappingArgsDict(TypedDict):
        """
        Specifies a block device mapping for a launch template. You must specify ``DeviceName`` plus exactly one of the following properties: ``Ebs``, ``NoDevice``, or ``VirtualName``.
         ``BlockDeviceMapping`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        """
        device_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The device name (for example, /dev/sdh or xvdh).
        """
        ebs: NotRequired[pulumi.Input['LaunchTemplateEbsArgsDict']]
        """
        Parameters used to automatically set up EBS volumes when the instance is launched.
        """
        no_device: NotRequired[pulumi.Input[_builtins.str]]
        """
        To omit the device from the block device mapping, specify an empty string.
        """
        virtual_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The virtual device name (ephemeralN). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for ephemeral0 and ephemeral1. The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.
        """
elif False:
    LaunchTemplateBlockDeviceMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateBlockDeviceMappingArgs:
    def __init__(__self__, *,
                 device_name: Optional[pulumi.Input[_builtins.str]] = None,
                 ebs: Optional[pulumi.Input['LaunchTemplateEbsArgs']] = None,
                 no_device: Optional[pulumi.Input[_builtins.str]] = None,
                 virtual_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Specifies a block device mapping for a launch template. You must specify ``DeviceName`` plus exactly one of the following properties: ``Ebs``, ``NoDevice``, or ``VirtualName``.
         ``BlockDeviceMapping`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        :param pulumi.Input[_builtins.str] device_name: The device name (for example, /dev/sdh or xvdh).
        :param pulumi.Input['LaunchTemplateEbsArgs'] ebs: Parameters used to automatically set up EBS volumes when the instance is launched.
        :param pulumi.Input[_builtins.str] no_device: To omit the device from the block device mapping, specify an empty string.
        :param pulumi.Input[_builtins.str] virtual_name: The virtual device name (ephemeralN). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for ephemeral0 and ephemeral1. The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.
        """
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if ebs is not None:
            pulumi.set(__self__, "ebs", ebs)
        if no_device is not None:
            pulumi.set(__self__, "no_device", no_device)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The device name (for example, /dev/sdh or xvdh).
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device_name", value)

    @_builtins.property
    @pulumi.getter
    def ebs(self) -> Optional[pulumi.Input['LaunchTemplateEbsArgs']]:
        """
        Parameters used to automatically set up EBS volumes when the instance is launched.
        """
        return pulumi.get(self, "ebs")

    @ebs.setter
    def ebs(self, value: Optional[pulumi.Input['LaunchTemplateEbsArgs']]):
        pulumi.set(self, "ebs", value)

    @_builtins.property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        To omit the device from the block device mapping, specify an empty string.
        """
        return pulumi.get(self, "no_device")

    @no_device.setter
    def no_device(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "no_device", value)

    @_builtins.property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The virtual device name (ephemeralN). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for ephemeral0 and ephemeral1. The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.
        """
        return pulumi.get(self, "virtual_name")

    @virtual_name.setter
    def virtual_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "virtual_name", value)


if not MYPY:
    class LaunchTemplateCapacityReservationSpecificationArgsDict(TypedDict):
        """
        Specifies an instance's Capacity Reservation targeting option. You can specify only one option at a time.
         ``CapacityReservationSpecification`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        """
        capacity_reservation_preference: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the instance's Capacity Reservation preferences. Possible preferences include:
          +  ``capacity-reservations-only`` - The instance will only run in a Capacity Reservation or Capacity Reservation group. If capacity isn't available, the instance will fail to launch.
          +  ``open`` - The instance can run in any ``open`` Capacity Reservation that has matching attributes (instance type, platform, Availability Zone, tenancy).
          +  ``none`` - The instance avoids running in a Capacity Reservation even if one is available. The instance runs in On-Demand capacity.
        """
        capacity_reservation_target: NotRequired[pulumi.Input['LaunchTemplateCapacityReservationTargetArgsDict']]
        """
        Information about the target Capacity Reservation or Capacity Reservation group.
        """
elif False:
    LaunchTemplateCapacityReservationSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateCapacityReservationSpecificationArgs:
    def __init__(__self__, *,
                 capacity_reservation_preference: Optional[pulumi.Input[_builtins.str]] = None,
                 capacity_reservation_target: Optional[pulumi.Input['LaunchTemplateCapacityReservationTargetArgs']] = None):
        """
        Specifies an instance's Capacity Reservation targeting option. You can specify only one option at a time.
         ``CapacityReservationSpecification`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        :param pulumi.Input[_builtins.str] capacity_reservation_preference: Indicates the instance's Capacity Reservation preferences. Possible preferences include:
                 +  ``capacity-reservations-only`` - The instance will only run in a Capacity Reservation or Capacity Reservation group. If capacity isn't available, the instance will fail to launch.
                 +  ``open`` - The instance can run in any ``open`` Capacity Reservation that has matching attributes (instance type, platform, Availability Zone, tenancy).
                 +  ``none`` - The instance avoids running in a Capacity Reservation even if one is available. The instance runs in On-Demand capacity.
        :param pulumi.Input['LaunchTemplateCapacityReservationTargetArgs'] capacity_reservation_target: Information about the target Capacity Reservation or Capacity Reservation group.
        """
        if capacity_reservation_preference is not None:
            pulumi.set(__self__, "capacity_reservation_preference", capacity_reservation_preference)
        if capacity_reservation_target is not None:
            pulumi.set(__self__, "capacity_reservation_target", capacity_reservation_target)

    @_builtins.property
    @pulumi.getter(name="capacityReservationPreference")
    def capacity_reservation_preference(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the instance's Capacity Reservation preferences. Possible preferences include:
          +  ``capacity-reservations-only`` - The instance will only run in a Capacity Reservation or Capacity Reservation group. If capacity isn't available, the instance will fail to launch.
          +  ``open`` - The instance can run in any ``open`` Capacity Reservation that has matching attributes (instance type, platform, Availability Zone, tenancy).
          +  ``none`` - The instance avoids running in a Capacity Reservation even if one is available. The instance runs in On-Demand capacity.
        """
        return pulumi.get(self, "capacity_reservation_preference")

    @capacity_reservation_preference.setter
    def capacity_reservation_preference(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "capacity_reservation_preference", value)

    @_builtins.property
    @pulumi.getter(name="capacityReservationTarget")
    def capacity_reservation_target(self) -> Optional[pulumi.Input['LaunchTemplateCapacityReservationTargetArgs']]:
        """
        Information about the target Capacity Reservation or Capacity Reservation group.
        """
        return pulumi.get(self, "capacity_reservation_target")

    @capacity_reservation_target.setter
    def capacity_reservation_target(self, value: Optional[pulumi.Input['LaunchTemplateCapacityReservationTargetArgs']]):
        pulumi.set(self, "capacity_reservation_target", value)


if not MYPY:
    class LaunchTemplateCapacityReservationTargetArgsDict(TypedDict):
        """
        Specifies a target Capacity Reservation.
         ``CapacityReservationTarget`` is a property of the [Amazon EC2 LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html) property type.
        """
        capacity_reservation_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the Capacity Reservation in which to run the instance.
        """
        capacity_reservation_resource_group_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ARN of the Capacity Reservation resource group in which to run the instance.
        """
elif False:
    LaunchTemplateCapacityReservationTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateCapacityReservationTargetArgs:
    def __init__(__self__, *,
                 capacity_reservation_id: Optional[pulumi.Input[_builtins.str]] = None,
                 capacity_reservation_resource_group_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Specifies a target Capacity Reservation.
         ``CapacityReservationTarget`` is a property of the [Amazon EC2 LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html) property type.
        :param pulumi.Input[_builtins.str] capacity_reservation_id: The ID of the Capacity Reservation in which to run the instance.
        :param pulumi.Input[_builtins.str] capacity_reservation_resource_group_arn: The ARN of the Capacity Reservation resource group in which to run the instance.
        """
        if capacity_reservation_id is not None:
            pulumi.set(__self__, "capacity_reservation_id", capacity_reservation_id)
        if capacity_reservation_resource_group_arn is not None:
            pulumi.set(__self__, "capacity_reservation_resource_group_arn", capacity_reservation_resource_group_arn)

    @_builtins.property
    @pulumi.getter(name="capacityReservationId")
    def capacity_reservation_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the Capacity Reservation in which to run the instance.
        """
        return pulumi.get(self, "capacity_reservation_id")

    @capacity_reservation_id.setter
    def capacity_reservation_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "capacity_reservation_id", value)

    @_builtins.property
    @pulumi.getter(name="capacityReservationResourceGroupArn")
    def capacity_reservation_resource_group_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ARN of the Capacity Reservation resource group in which to run the instance.
        """
        return pulumi.get(self, "capacity_reservation_resource_group_arn")

    @capacity_reservation_resource_group_arn.setter
    def capacity_reservation_resource_group_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "capacity_reservation_resource_group_arn", value)


if not MYPY:
    class LaunchTemplateConnectionTrackingSpecificationArgsDict(TypedDict):
        """
        A security group connection tracking specification that enables you to set the idle timeout for connection tracking on an Elastic network interface. For more information, see [Connection tracking timeouts](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-connection-tracking.html#connection-tracking-timeouts) in the *Amazon EC2 User Guide*.
        """
        tcp_established_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout (in seconds) for idle TCP connections in an established state. Min: 60 seconds. Max: 432000 seconds (5 days). Default: 432000 seconds. Recommended: Less than 432000 seconds.
        """
        udp_stream_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout (in seconds) for idle UDP flows classified as streams which have seen more than one request-response transaction. Min: 60 seconds. Max: 180 seconds (3 minutes). Default: 180 seconds.
        """
        udp_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout (in seconds) for idle UDP flows that have seen traffic only in a single direction or a single request-response transaction. Min: 30 seconds. Max: 60 seconds. Default: 30 seconds.
        """
elif False:
    LaunchTemplateConnectionTrackingSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateConnectionTrackingSpecificationArgs:
    def __init__(__self__, *,
                 tcp_established_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 udp_stream_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 udp_timeout: Optional[pulumi.Input[_builtins.int]] = None):
        """
        A security group connection tracking specification that enables you to set the idle timeout for connection tracking on an Elastic network interface. For more information, see [Connection tracking timeouts](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-connection-tracking.html#connection-tracking-timeouts) in the *Amazon EC2 User Guide*.
        :param pulumi.Input[_builtins.int] tcp_established_timeout: Timeout (in seconds) for idle TCP connections in an established state. Min: 60 seconds. Max: 432000 seconds (5 days). Default: 432000 seconds. Recommended: Less than 432000 seconds.
        :param pulumi.Input[_builtins.int] udp_stream_timeout: Timeout (in seconds) for idle UDP flows classified as streams which have seen more than one request-response transaction. Min: 60 seconds. Max: 180 seconds (3 minutes). Default: 180 seconds.
        :param pulumi.Input[_builtins.int] udp_timeout: Timeout (in seconds) for idle UDP flows that have seen traffic only in a single direction or a single request-response transaction. Min: 30 seconds. Max: 60 seconds. Default: 30 seconds.
        """
        if tcp_established_timeout is not None:
            pulumi.set(__self__, "tcp_established_timeout", tcp_established_timeout)
        if udp_stream_timeout is not None:
            pulumi.set(__self__, "udp_stream_timeout", udp_stream_timeout)
        if udp_timeout is not None:
            pulumi.set(__self__, "udp_timeout", udp_timeout)

    @_builtins.property
    @pulumi.getter(name="tcpEstablishedTimeout")
    def tcp_established_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout (in seconds) for idle TCP connections in an established state. Min: 60 seconds. Max: 432000 seconds (5 days). Default: 432000 seconds. Recommended: Less than 432000 seconds.
        """
        return pulumi.get(self, "tcp_established_timeout")

    @tcp_established_timeout.setter
    def tcp_established_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "tcp_established_timeout", value)

    @_builtins.property
    @pulumi.getter(name="udpStreamTimeout")
    def udp_stream_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout (in seconds) for idle UDP flows classified as streams which have seen more than one request-response transaction. Min: 60 seconds. Max: 180 seconds (3 minutes). Default: 180 seconds.
        """
        return pulumi.get(self, "udp_stream_timeout")

    @udp_stream_timeout.setter
    def udp_stream_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "udp_stream_timeout", value)

    @_builtins.property
    @pulumi.getter(name="udpTimeout")
    def udp_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout (in seconds) for idle UDP flows that have seen traffic only in a single direction or a single request-response transaction. Min: 30 seconds. Max: 60 seconds. Default: 30 seconds.
        """
        return pulumi.get(self, "udp_timeout")

    @udp_timeout.setter
    def udp_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "udp_timeout", value)


if not MYPY:
    class LaunchTemplateCpuOptionsArgsDict(TypedDict):
        """
        Specifies the CPU options for an instance. For more information, see [Optimize CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the *User Guide*.
         ``CpuOptions`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        """
        amd_sev_snp: NotRequired[pulumi.Input['LaunchTemplateCpuOptionsAmdSevSnp']]
        """
        Indicates whether to enable the instance for AMD SEV-SNP. AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only. For more information, see [AMD SEV-SNP for Amazon EC2 instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/sev-snp.html).
        """
        core_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of CPU cores for the instance.
        """
        threads_per_core: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of threads per CPU core. To disable multithreading for the instance, specify a value of ``1``. Otherwise, specify the default value of ``2``.
        """
elif False:
    LaunchTemplateCpuOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateCpuOptionsArgs:
    def __init__(__self__, *,
                 amd_sev_snp: Optional[pulumi.Input['LaunchTemplateCpuOptionsAmdSevSnp']] = None,
                 core_count: Optional[pulumi.Input[_builtins.int]] = None,
                 threads_per_core: Optional[pulumi.Input[_builtins.int]] = None):
        """
        Specifies the CPU options for an instance. For more information, see [Optimize CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the *User Guide*.
         ``CpuOptions`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        :param pulumi.Input['LaunchTemplateCpuOptionsAmdSevSnp'] amd_sev_snp: Indicates whether to enable the instance for AMD SEV-SNP. AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only. For more information, see [AMD SEV-SNP for Amazon EC2 instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/sev-snp.html).
        :param pulumi.Input[_builtins.int] core_count: The number of CPU cores for the instance.
        :param pulumi.Input[_builtins.int] threads_per_core: The number of threads per CPU core. To disable multithreading for the instance, specify a value of ``1``. Otherwise, specify the default value of ``2``.
        """
        if amd_sev_snp is not None:
            pulumi.set(__self__, "amd_sev_snp", amd_sev_snp)
        if core_count is not None:
            pulumi.set(__self__, "core_count", core_count)
        if threads_per_core is not None:
            pulumi.set(__self__, "threads_per_core", threads_per_core)

    @_builtins.property
    @pulumi.getter(name="amdSevSnp")
    def amd_sev_snp(self) -> Optional[pulumi.Input['LaunchTemplateCpuOptionsAmdSevSnp']]:
        """
        Indicates whether to enable the instance for AMD SEV-SNP. AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only. For more information, see [AMD SEV-SNP for Amazon EC2 instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/sev-snp.html).
        """
        return pulumi.get(self, "amd_sev_snp")

    @amd_sev_snp.setter
    def amd_sev_snp(self, value: Optional[pulumi.Input['LaunchTemplateCpuOptionsAmdSevSnp']]):
        pulumi.set(self, "amd_sev_snp", value)

    @_builtins.property
    @pulumi.getter(name="coreCount")
    def core_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of CPU cores for the instance.
        """
        return pulumi.get(self, "core_count")

    @core_count.setter
    def core_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "core_count", value)

    @_builtins.property
    @pulumi.getter(name="threadsPerCore")
    def threads_per_core(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of threads per CPU core. To disable multithreading for the instance, specify a value of ``1``. Otherwise, specify the default value of ``2``.
        """
        return pulumi.get(self, "threads_per_core")

    @threads_per_core.setter
    def threads_per_core(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "threads_per_core", value)


if not MYPY:
    class LaunchTemplateCpuArgsDict(TypedDict):
        """
        Specifies the CPU performance to consider when using an instance family as the baseline reference.
        """
        references: NotRequired[pulumi.Input[Sequence[pulumi.Input['LaunchTemplateReferenceArgsDict']]]]
        """
        The instance family to use as the baseline reference for CPU performance. All instance types that match your specified attributes are compared against the CPU performance of the referenced instance family, regardless of CPU manufacturer or architecture differences.
        """
elif False:
    LaunchTemplateCpuArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateCpuArgs:
    def __init__(__self__, *,
                 references: Optional[pulumi.Input[Sequence[pulumi.Input['LaunchTemplateReferenceArgs']]]] = None):
        """
        Specifies the CPU performance to consider when using an instance family as the baseline reference.
        :param pulumi.Input[Sequence[pulumi.Input['LaunchTemplateReferenceArgs']]] references: The instance family to use as the baseline reference for CPU performance. All instance types that match your specified attributes are compared against the CPU performance of the referenced instance family, regardless of CPU manufacturer or architecture differences.
        """
        if references is not None:
            pulumi.set(__self__, "references", references)

    @_builtins.property
    @pulumi.getter
    def references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LaunchTemplateReferenceArgs']]]]:
        """
        The instance family to use as the baseline reference for CPU performance. All instance types that match your specified attributes are compared against the CPU performance of the referenced instance family, regardless of CPU manufacturer or architecture differences.
        """
        return pulumi.get(self, "references")

    @references.setter
    def references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LaunchTemplateReferenceArgs']]]]):
        pulumi.set(self, "references", value)


if not MYPY:
    class LaunchTemplateCreditSpecificationArgsDict(TypedDict):
        """
        Specifies the credit option for CPU usage of a T2, T3, or T3a instance.
         ``CreditSpecification`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        """
        cpu_credits: NotRequired[pulumi.Input[_builtins.str]]
        """
        The credit option for CPU usage of a T instance.
         Valid values: ``standard`` | ``unlimited``
        """
elif False:
    LaunchTemplateCreditSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateCreditSpecificationArgs:
    def __init__(__self__, *,
                 cpu_credits: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Specifies the credit option for CPU usage of a T2, T3, or T3a instance.
         ``CreditSpecification`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        :param pulumi.Input[_builtins.str] cpu_credits: The credit option for CPU usage of a T instance.
                Valid values: ``standard`` | ``unlimited``
        """
        if cpu_credits is not None:
            pulumi.set(__self__, "cpu_credits", cpu_credits)

    @_builtins.property
    @pulumi.getter(name="cpuCredits")
    def cpu_credits(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The credit option for CPU usage of a T instance.
         Valid values: ``standard`` | ``unlimited``
        """
        return pulumi.get(self, "cpu_credits")

    @cpu_credits.setter
    def cpu_credits(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cpu_credits", value)


if not MYPY:
    class LaunchTemplateDataArgsDict(TypedDict):
        """
        The information to include in the launch template.
          You must specify at least one parameter for the launch template data.
        """
        block_device_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['LaunchTemplateBlockDeviceMappingArgsDict']]]]
        """
        The block device mapping.
        """
        capacity_reservation_specification: NotRequired[pulumi.Input['LaunchTemplateCapacityReservationSpecificationArgsDict']]
        """
        The Capacity Reservation targeting option. If you do not specify this parameter, the instance's Capacity Reservation preference defaults to ``open``, which enables it to run in any open Capacity Reservation that has matching attributes (instance type, platform, Availability Zone).
        """
        cpu_options: NotRequired[pulumi.Input['LaunchTemplateCpuOptionsArgsDict']]
        """
        The CPU options for the instance. For more information, see [CPU options for Amazon EC2 instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the *Amazon EC2 User Guide*.
        """
        credit_specification: NotRequired[pulumi.Input['LaunchTemplateCreditSpecificationArgsDict']]
        """
        The credit option for CPU usage of the instance. Valid only for T instances.
        """
        disable_api_stop: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether to enable the instance for stop protection. For more information, see [Enable stop protection for your EC2 instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-stop-protection.html) in the *Amazon EC2 User Guide*.
        """
        disable_api_termination: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether termination protection is enabled for the instance. The default is ``false``, which means that you can terminate the instance using the Amazon EC2 console, command line tools, or API. You can enable termination protection when you launch an instance, while the instance is running, or while the instance is stopped.
        """
        ebs_optimized: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the instance is optimized for Amazon EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.
        """
        enclave_options: NotRequired[pulumi.Input['LaunchTemplateEnclaveOptionsArgsDict']]
        """
        Indicates whether the instance is enabled for AWS Nitro Enclaves. For more information, see [What is Nitro Enclaves?](https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html) in the *Nitro Enclaves User Guide*.
         You can't enable AWS Nitro Enclaves and hibernation on the same instance.
        """
        hibernation_options: NotRequired[pulumi.Input['LaunchTemplateHibernationOptionsArgsDict']]
        """
        Indicates whether an instance is enabled for hibernation. This parameter is valid only if the instance meets the [hibernation prerequisites](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/hibernating-prerequisites.html). For more information, see [Hibernate your Amazon EC2 instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html) in the *Amazon EC2 User Guide*.
        """
        iam_instance_profile: NotRequired[pulumi.Input['LaunchTemplateIamInstanceProfileArgsDict']]
        """
        The name or Amazon Resource Name (ARN) of an IAM instance profile.
        """
        image_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the AMI. Alternatively, you can specify a Systems Manager parameter, which will resolve to an AMI ID on launch.
         Valid formats:
          +   ``ami-0ac394d6a3example`` 
          +   ``resolve:ssm:parameter-name`` 
          +   ``resolve:ssm:parameter-name:version-number`` 
          +   ``resolve:ssm:parameter-name:label`` 
          
         For more information, see [Use a Systems Manager parameter to find an AMI](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/finding-an-ami.html#using-systems-manager-parameter-to-find-AMI) in the *Amazon Elastic Compute Cloud User Guide*.
        """
        instance_initiated_shutdown_behavior: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
         Default: ``stop``
        """
        instance_market_options: NotRequired[pulumi.Input['LaunchTemplateInstanceMarketOptionsArgsDict']]
        """
        The market (purchasing) option for the instances.
        """
        instance_requirements: NotRequired[pulumi.Input['LaunchTemplateInstanceRequirementsArgsDict']]
        """
        The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with these attributes.
         You must specify ``VCpuCount`` and ``MemoryMiB``. All other attributes are optional. Any unspecified optional attribute is set to its default.
         When you specify multiple attributes, you get instance types that satisfy all of the specified attributes. If you specify multiple values for an attribute, you get instance types that satisfy any of the specified values.
         To limit the list of instance types from which Amazon EC2 can identify matching instance types, you can use one of the following parameters, but not both in the same request:
          +  ``AllowedInstanceTypes`` - The instance types to include in the list. All other instance types are ignored, even if they match your specified attributes.
          +  ``ExcludedInstanceTypes`` - The instance types to exclude from the list, even if they match your specified attributes.
          
          If you specify ``InstanceRequirements``, you can't specify ``InstanceType``.
         Attribute-based instance type selection is only supported when using Auto Scaling groups, EC2 Fleet, and Spot Fleet to launch instances. If you plan to use the launch template in the [launch instance wizard](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-instance-wizard.html), or with the [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) API or [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html)AWS CloudFormation resource, you can't specify ``InstanceRequirements``.
          For more information, see [Specify attributes for instance type selection for EC2 Fleet or Spot Fleet](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html) and [Spot placement score](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html) in the *Amazon EC2 User Guide*.
        """
        instance_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The instance type. For more information, see [Amazon EC2 instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide*.
         If you specify ``InstanceType``, you can't specify ``InstanceRequirements``.
        """
        kernel_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the kernel.
         We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [User Provided Kernels](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide*.
        """
        key_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the key pair. You can create a key pair using [CreateKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html) or [ImportKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html).
          If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.
        """
        license_specifications: NotRequired[pulumi.Input[Sequence[pulumi.Input['LaunchTemplateLicenseSpecificationArgsDict']]]]
        """
        The license configurations.
        """
        maintenance_options: NotRequired[pulumi.Input['LaunchTemplateMaintenanceOptionsArgsDict']]
        """
        The maintenance options of your instance.
        """
        metadata_options: NotRequired[pulumi.Input['LaunchTemplateMetadataOptionsArgsDict']]
        """
        The metadata options for the instance. For more information, see [Configure the Instance Metadata Service options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/configuring-instance-metadata-options.html) in the *Amazon EC2 User Guide*.
        """
        monitoring: NotRequired[pulumi.Input['LaunchTemplateMonitoringArgsDict']]
        """
        The monitoring for the instance.
        """
        network_interfaces: NotRequired[pulumi.Input[Sequence[pulumi.Input['LaunchTemplateNetworkInterfaceArgsDict']]]]
        """
        The network interfaces for the instance.
        """
        network_performance_options: NotRequired[pulumi.Input['LaunchTemplateNetworkPerformanceOptionsArgsDict']]
        """
        The settings for the network performance options for the instance. For more information, see [EC2 instance bandwidth weighting configuration](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/configure-bandwidth-weighting.html).
        """
        placement: NotRequired[pulumi.Input['LaunchTemplatePlacementArgsDict']]
        """
        The placement for the instance.
        """
        private_dns_name_options: NotRequired[pulumi.Input['LaunchTemplatePrivateDnsNameOptionsArgsDict']]
        """
        The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries should be handled. For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *User Guide*.
        """
        ram_disk_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the RAM disk.
          We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [User provided kernels](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide*.
        """
        security_group_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The IDs of the security groups. You can specify the IDs of existing security groups and references to resources created by the stack template.
         If you specify a network interface, you must specify any security groups as part of the network interface instead.
        """
        security_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The names of the security groups. For a nondefault VPC, you must use security group IDs instead.
         If you specify a network interface, you must specify any security groups as part of the network interface instead of using this parameter.
        """
        tag_specifications: NotRequired[pulumi.Input[Sequence[pulumi.Input['TagSpecificationArgsDict']]]]
        """
        The tags to apply to resources that are created during instance launch.
         To tag the launch template itself, use [TagSpecifications](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#cfn-ec2-launchtemplate-tagspecifications).
        """
        user_data: NotRequired[pulumi.Input[_builtins.str]]
        """
        The user data to make available to the instance. You must provide base64-encoded text. User data is limited to 16 KB. For more information, see [Run commands when you launch an EC2 instance with user data input](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html) in the *Amazon EC2 User Guide*.
         If you are creating the launch template for use with BATCH, the user data must be provided in the [MIME multi-part archive format](https://docs.aws.amazon.com/https://cloudinit.readthedocs.io/en/latest/topics/format.html#mime-multi-part-archive). For more information, see [Amazon EC2 user data in launch templates](https://docs.aws.amazon.com/batch/latest/userguide/launch-templates.html#lt-user-data) in the *User Guide*.
        """
elif False:
    LaunchTemplateDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateDataArgs:
    def __init__(__self__, *,
                 block_device_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['LaunchTemplateBlockDeviceMappingArgs']]]] = None,
                 capacity_reservation_specification: Optional[pulumi.Input['LaunchTemplateCapacityReservationSpecificationArgs']] = None,
                 cpu_options: Optional[pulumi.Input['LaunchTemplateCpuOptionsArgs']] = None,
                 credit_specification: Optional[pulumi.Input['LaunchTemplateCreditSpecificationArgs']] = None,
                 disable_api_stop: Optional[pulumi.Input[_builtins.bool]] = None,
                 disable_api_termination: Optional[pulumi.Input[_builtins.bool]] = None,
                 ebs_optimized: Optional[pulumi.Input[_builtins.bool]] = None,
                 enclave_options: Optional[pulumi.Input['LaunchTemplateEnclaveOptionsArgs']] = None,
                 hibernation_options: Optional[pulumi.Input['LaunchTemplateHibernationOptionsArgs']] = None,
                 iam_instance_profile: Optional[pulumi.Input['LaunchTemplateIamInstanceProfileArgs']] = None,
                 image_id: Optional[pulumi.Input[_builtins.str]] = None,
                 instance_initiated_shutdown_behavior: Optional[pulumi.Input[_builtins.str]] = None,
                 instance_market_options: Optional[pulumi.Input['LaunchTemplateInstanceMarketOptionsArgs']] = None,
                 instance_requirements: Optional[pulumi.Input['LaunchTemplateInstanceRequirementsArgs']] = None,
                 instance_type: Optional[pulumi.Input[_builtins.str]] = None,
                 kernel_id: Optional[pulumi.Input[_builtins.str]] = None,
                 key_name: Optional[pulumi.Input[_builtins.str]] = None,
                 license_specifications: Optional[pulumi.Input[Sequence[pulumi.Input['LaunchTemplateLicenseSpecificationArgs']]]] = None,
                 maintenance_options: Optional[pulumi.Input['LaunchTemplateMaintenanceOptionsArgs']] = None,
                 metadata_options: Optional[pulumi.Input['LaunchTemplateMetadataOptionsArgs']] = None,
                 monitoring: Optional[pulumi.Input['LaunchTemplateMonitoringArgs']] = None,
                 network_interfaces: Optional[pulumi.Input[Sequence[pulumi.Input['LaunchTemplateNetworkInterfaceArgs']]]] = None,
                 network_performance_options: Optional[pulumi.Input['LaunchTemplateNetworkPerformanceOptionsArgs']] = None,
                 placement: Optional[pulumi.Input['LaunchTemplatePlacementArgs']] = None,
                 private_dns_name_options: Optional[pulumi.Input['LaunchTemplatePrivateDnsNameOptionsArgs']] = None,
                 ram_disk_id: Optional[pulumi.Input[_builtins.str]] = None,
                 security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 tag_specifications: Optional[pulumi.Input[Sequence[pulumi.Input['TagSpecificationArgs']]]] = None,
                 user_data: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The information to include in the launch template.
          You must specify at least one parameter for the launch template data.
        :param pulumi.Input[Sequence[pulumi.Input['LaunchTemplateBlockDeviceMappingArgs']]] block_device_mappings: The block device mapping.
        :param pulumi.Input['LaunchTemplateCapacityReservationSpecificationArgs'] capacity_reservation_specification: The Capacity Reservation targeting option. If you do not specify this parameter, the instance's Capacity Reservation preference defaults to ``open``, which enables it to run in any open Capacity Reservation that has matching attributes (instance type, platform, Availability Zone).
        :param pulumi.Input['LaunchTemplateCpuOptionsArgs'] cpu_options: The CPU options for the instance. For more information, see [CPU options for Amazon EC2 instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the *Amazon EC2 User Guide*.
        :param pulumi.Input['LaunchTemplateCreditSpecificationArgs'] credit_specification: The credit option for CPU usage of the instance. Valid only for T instances.
        :param pulumi.Input[_builtins.bool] disable_api_stop: Indicates whether to enable the instance for stop protection. For more information, see [Enable stop protection for your EC2 instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-stop-protection.html) in the *Amazon EC2 User Guide*.
        :param pulumi.Input[_builtins.bool] disable_api_termination: Indicates whether termination protection is enabled for the instance. The default is ``false``, which means that you can terminate the instance using the Amazon EC2 console, command line tools, or API. You can enable termination protection when you launch an instance, while the instance is running, or while the instance is stopped.
        :param pulumi.Input[_builtins.bool] ebs_optimized: Indicates whether the instance is optimized for Amazon EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.
        :param pulumi.Input['LaunchTemplateEnclaveOptionsArgs'] enclave_options: Indicates whether the instance is enabled for AWS Nitro Enclaves. For more information, see [What is Nitro Enclaves?](https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html) in the *Nitro Enclaves User Guide*.
                You can't enable AWS Nitro Enclaves and hibernation on the same instance.
        :param pulumi.Input['LaunchTemplateHibernationOptionsArgs'] hibernation_options: Indicates whether an instance is enabled for hibernation. This parameter is valid only if the instance meets the [hibernation prerequisites](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/hibernating-prerequisites.html). For more information, see [Hibernate your Amazon EC2 instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html) in the *Amazon EC2 User Guide*.
        :param pulumi.Input['LaunchTemplateIamInstanceProfileArgs'] iam_instance_profile: The name or Amazon Resource Name (ARN) of an IAM instance profile.
        :param pulumi.Input[_builtins.str] image_id: The ID of the AMI. Alternatively, you can specify a Systems Manager parameter, which will resolve to an AMI ID on launch.
                Valid formats:
                 +   ``ami-0ac394d6a3example`` 
                 +   ``resolve:ssm:parameter-name`` 
                 +   ``resolve:ssm:parameter-name:version-number`` 
                 +   ``resolve:ssm:parameter-name:label`` 
                 
                For more information, see [Use a Systems Manager parameter to find an AMI](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/finding-an-ami.html#using-systems-manager-parameter-to-find-AMI) in the *Amazon Elastic Compute Cloud User Guide*.
        :param pulumi.Input[_builtins.str] instance_initiated_shutdown_behavior: Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
                Default: ``stop``
        :param pulumi.Input['LaunchTemplateInstanceMarketOptionsArgs'] instance_market_options: The market (purchasing) option for the instances.
        :param pulumi.Input['LaunchTemplateInstanceRequirementsArgs'] instance_requirements: The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with these attributes.
                You must specify ``VCpuCount`` and ``MemoryMiB``. All other attributes are optional. Any unspecified optional attribute is set to its default.
                When you specify multiple attributes, you get instance types that satisfy all of the specified attributes. If you specify multiple values for an attribute, you get instance types that satisfy any of the specified values.
                To limit the list of instance types from which Amazon EC2 can identify matching instance types, you can use one of the following parameters, but not both in the same request:
                 +  ``AllowedInstanceTypes`` - The instance types to include in the list. All other instance types are ignored, even if they match your specified attributes.
                 +  ``ExcludedInstanceTypes`` - The instance types to exclude from the list, even if they match your specified attributes.
                 
                 If you specify ``InstanceRequirements``, you can't specify ``InstanceType``.
                Attribute-based instance type selection is only supported when using Auto Scaling groups, EC2 Fleet, and Spot Fleet to launch instances. If you plan to use the launch template in the [launch instance wizard](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-instance-wizard.html), or with the [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) API or [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html)AWS CloudFormation resource, you can't specify ``InstanceRequirements``.
                 For more information, see [Specify attributes for instance type selection for EC2 Fleet or Spot Fleet](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html) and [Spot placement score](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html) in the *Amazon EC2 User Guide*.
        :param pulumi.Input[_builtins.str] instance_type: The instance type. For more information, see [Amazon EC2 instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide*.
                If you specify ``InstanceType``, you can't specify ``InstanceRequirements``.
        :param pulumi.Input[_builtins.str] kernel_id: The ID of the kernel.
                We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [User Provided Kernels](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide*.
        :param pulumi.Input[_builtins.str] key_name: The name of the key pair. You can create a key pair using [CreateKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html) or [ImportKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html).
                 If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.
        :param pulumi.Input[Sequence[pulumi.Input['LaunchTemplateLicenseSpecificationArgs']]] license_specifications: The license configurations.
        :param pulumi.Input['LaunchTemplateMaintenanceOptionsArgs'] maintenance_options: The maintenance options of your instance.
        :param pulumi.Input['LaunchTemplateMetadataOptionsArgs'] metadata_options: The metadata options for the instance. For more information, see [Configure the Instance Metadata Service options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/configuring-instance-metadata-options.html) in the *Amazon EC2 User Guide*.
        :param pulumi.Input['LaunchTemplateMonitoringArgs'] monitoring: The monitoring for the instance.
        :param pulumi.Input[Sequence[pulumi.Input['LaunchTemplateNetworkInterfaceArgs']]] network_interfaces: The network interfaces for the instance.
        :param pulumi.Input['LaunchTemplateNetworkPerformanceOptionsArgs'] network_performance_options: The settings for the network performance options for the instance. For more information, see [EC2 instance bandwidth weighting configuration](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/configure-bandwidth-weighting.html).
        :param pulumi.Input['LaunchTemplatePlacementArgs'] placement: The placement for the instance.
        :param pulumi.Input['LaunchTemplatePrivateDnsNameOptionsArgs'] private_dns_name_options: The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries should be handled. For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *User Guide*.
        :param pulumi.Input[_builtins.str] ram_disk_id: The ID of the RAM disk.
                 We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [User provided kernels](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide*.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] security_group_ids: The IDs of the security groups. You can specify the IDs of existing security groups and references to resources created by the stack template.
                If you specify a network interface, you must specify any security groups as part of the network interface instead.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] security_groups: The names of the security groups. For a nondefault VPC, you must use security group IDs instead.
                If you specify a network interface, you must specify any security groups as part of the network interface instead of using this parameter.
        :param pulumi.Input[Sequence[pulumi.Input['TagSpecificationArgs']]] tag_specifications: The tags to apply to resources that are created during instance launch.
                To tag the launch template itself, use [TagSpecifications](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#cfn-ec2-launchtemplate-tagspecifications).
        :param pulumi.Input[_builtins.str] user_data: The user data to make available to the instance. You must provide base64-encoded text. User data is limited to 16 KB. For more information, see [Run commands when you launch an EC2 instance with user data input](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html) in the *Amazon EC2 User Guide*.
                If you are creating the launch template for use with BATCH, the user data must be provided in the [MIME multi-part archive format](https://docs.aws.amazon.com/https://cloudinit.readthedocs.io/en/latest/topics/format.html#mime-multi-part-archive). For more information, see [Amazon EC2 user data in launch templates](https://docs.aws.amazon.com/batch/latest/userguide/launch-templates.html#lt-user-data) in the *User Guide*.
        """
        if block_device_mappings is not None:
            pulumi.set(__self__, "block_device_mappings", block_device_mappings)
        if capacity_reservation_specification is not None:
            pulumi.set(__self__, "capacity_reservation_specification", capacity_reservation_specification)
        if cpu_options is not None:
            pulumi.set(__self__, "cpu_options", cpu_options)
        if credit_specification is not None:
            pulumi.set(__self__, "credit_specification", credit_specification)
        if disable_api_stop is not None:
            pulumi.set(__self__, "disable_api_stop", disable_api_stop)
        if disable_api_termination is not None:
            pulumi.set(__self__, "disable_api_termination", disable_api_termination)
        if ebs_optimized is not None:
            pulumi.set(__self__, "ebs_optimized", ebs_optimized)
        if enclave_options is not None:
            pulumi.set(__self__, "enclave_options", enclave_options)
        if hibernation_options is not None:
            pulumi.set(__self__, "hibernation_options", hibernation_options)
        if iam_instance_profile is not None:
            pulumi.set(__self__, "iam_instance_profile", iam_instance_profile)
        if image_id is not None:
            pulumi.set(__self__, "image_id", image_id)
        if instance_initiated_shutdown_behavior is not None:
            pulumi.set(__self__, "instance_initiated_shutdown_behavior", instance_initiated_shutdown_behavior)
        if instance_market_options is not None:
            pulumi.set(__self__, "instance_market_options", instance_market_options)
        if instance_requirements is not None:
            pulumi.set(__self__, "instance_requirements", instance_requirements)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if kernel_id is not None:
            pulumi.set(__self__, "kernel_id", kernel_id)
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if license_specifications is not None:
            pulumi.set(__self__, "license_specifications", license_specifications)
        if maintenance_options is not None:
            pulumi.set(__self__, "maintenance_options", maintenance_options)
        if metadata_options is not None:
            pulumi.set(__self__, "metadata_options", metadata_options)
        if monitoring is not None:
            pulumi.set(__self__, "monitoring", monitoring)
        if network_interfaces is not None:
            pulumi.set(__self__, "network_interfaces", network_interfaces)
        if network_performance_options is not None:
            pulumi.set(__self__, "network_performance_options", network_performance_options)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if private_dns_name_options is not None:
            pulumi.set(__self__, "private_dns_name_options", private_dns_name_options)
        if ram_disk_id is not None:
            pulumi.set(__self__, "ram_disk_id", ram_disk_id)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if tag_specifications is not None:
            pulumi.set(__self__, "tag_specifications", tag_specifications)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)

    @_builtins.property
    @pulumi.getter(name="blockDeviceMappings")
    def block_device_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LaunchTemplateBlockDeviceMappingArgs']]]]:
        """
        The block device mapping.
        """
        return pulumi.get(self, "block_device_mappings")

    @block_device_mappings.setter
    def block_device_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LaunchTemplateBlockDeviceMappingArgs']]]]):
        pulumi.set(self, "block_device_mappings", value)

    @_builtins.property
    @pulumi.getter(name="capacityReservationSpecification")
    def capacity_reservation_specification(self) -> Optional[pulumi.Input['LaunchTemplateCapacityReservationSpecificationArgs']]:
        """
        The Capacity Reservation targeting option. If you do not specify this parameter, the instance's Capacity Reservation preference defaults to ``open``, which enables it to run in any open Capacity Reservation that has matching attributes (instance type, platform, Availability Zone).
        """
        return pulumi.get(self, "capacity_reservation_specification")

    @capacity_reservation_specification.setter
    def capacity_reservation_specification(self, value: Optional[pulumi.Input['LaunchTemplateCapacityReservationSpecificationArgs']]):
        pulumi.set(self, "capacity_reservation_specification", value)

    @_builtins.property
    @pulumi.getter(name="cpuOptions")
    def cpu_options(self) -> Optional[pulumi.Input['LaunchTemplateCpuOptionsArgs']]:
        """
        The CPU options for the instance. For more information, see [CPU options for Amazon EC2 instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the *Amazon EC2 User Guide*.
        """
        return pulumi.get(self, "cpu_options")

    @cpu_options.setter
    def cpu_options(self, value: Optional[pulumi.Input['LaunchTemplateCpuOptionsArgs']]):
        pulumi.set(self, "cpu_options", value)

    @_builtins.property
    @pulumi.getter(name="creditSpecification")
    def credit_specification(self) -> Optional[pulumi.Input['LaunchTemplateCreditSpecificationArgs']]:
        """
        The credit option for CPU usage of the instance. Valid only for T instances.
        """
        return pulumi.get(self, "credit_specification")

    @credit_specification.setter
    def credit_specification(self, value: Optional[pulumi.Input['LaunchTemplateCreditSpecificationArgs']]):
        pulumi.set(self, "credit_specification", value)

    @_builtins.property
    @pulumi.getter(name="disableApiStop")
    def disable_api_stop(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether to enable the instance for stop protection. For more information, see [Enable stop protection for your EC2 instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-stop-protection.html) in the *Amazon EC2 User Guide*.
        """
        return pulumi.get(self, "disable_api_stop")

    @disable_api_stop.setter
    def disable_api_stop(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_api_stop", value)

    @_builtins.property
    @pulumi.getter(name="disableApiTermination")
    def disable_api_termination(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether termination protection is enabled for the instance. The default is ``false``, which means that you can terminate the instance using the Amazon EC2 console, command line tools, or API. You can enable termination protection when you launch an instance, while the instance is running, or while the instance is stopped.
        """
        return pulumi.get(self, "disable_api_termination")

    @disable_api_termination.setter
    def disable_api_termination(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_api_termination", value)

    @_builtins.property
    @pulumi.getter(name="ebsOptimized")
    def ebs_optimized(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the instance is optimized for Amazon EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.
        """
        return pulumi.get(self, "ebs_optimized")

    @ebs_optimized.setter
    def ebs_optimized(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ebs_optimized", value)

    @_builtins.property
    @pulumi.getter(name="enclaveOptions")
    def enclave_options(self) -> Optional[pulumi.Input['LaunchTemplateEnclaveOptionsArgs']]:
        """
        Indicates whether the instance is enabled for AWS Nitro Enclaves. For more information, see [What is Nitro Enclaves?](https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html) in the *Nitro Enclaves User Guide*.
         You can't enable AWS Nitro Enclaves and hibernation on the same instance.
        """
        return pulumi.get(self, "enclave_options")

    @enclave_options.setter
    def enclave_options(self, value: Optional[pulumi.Input['LaunchTemplateEnclaveOptionsArgs']]):
        pulumi.set(self, "enclave_options", value)

    @_builtins.property
    @pulumi.getter(name="hibernationOptions")
    def hibernation_options(self) -> Optional[pulumi.Input['LaunchTemplateHibernationOptionsArgs']]:
        """
        Indicates whether an instance is enabled for hibernation. This parameter is valid only if the instance meets the [hibernation prerequisites](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/hibernating-prerequisites.html). For more information, see [Hibernate your Amazon EC2 instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html) in the *Amazon EC2 User Guide*.
        """
        return pulumi.get(self, "hibernation_options")

    @hibernation_options.setter
    def hibernation_options(self, value: Optional[pulumi.Input['LaunchTemplateHibernationOptionsArgs']]):
        pulumi.set(self, "hibernation_options", value)

    @_builtins.property
    @pulumi.getter(name="iamInstanceProfile")
    def iam_instance_profile(self) -> Optional[pulumi.Input['LaunchTemplateIamInstanceProfileArgs']]:
        """
        The name or Amazon Resource Name (ARN) of an IAM instance profile.
        """
        return pulumi.get(self, "iam_instance_profile")

    @iam_instance_profile.setter
    def iam_instance_profile(self, value: Optional[pulumi.Input['LaunchTemplateIamInstanceProfileArgs']]):
        pulumi.set(self, "iam_instance_profile", value)

    @_builtins.property
    @pulumi.getter(name="imageId")
    def image_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the AMI. Alternatively, you can specify a Systems Manager parameter, which will resolve to an AMI ID on launch.
         Valid formats:
          +   ``ami-0ac394d6a3example`` 
          +   ``resolve:ssm:parameter-name`` 
          +   ``resolve:ssm:parameter-name:version-number`` 
          +   ``resolve:ssm:parameter-name:label`` 
          
         For more information, see [Use a Systems Manager parameter to find an AMI](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/finding-an-ami.html#using-systems-manager-parameter-to-find-AMI) in the *Amazon Elastic Compute Cloud User Guide*.
        """
        return pulumi.get(self, "image_id")

    @image_id.setter
    def image_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image_id", value)

    @_builtins.property
    @pulumi.getter(name="instanceInitiatedShutdownBehavior")
    def instance_initiated_shutdown_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
         Default: ``stop``
        """
        return pulumi.get(self, "instance_initiated_shutdown_behavior")

    @instance_initiated_shutdown_behavior.setter
    def instance_initiated_shutdown_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_initiated_shutdown_behavior", value)

    @_builtins.property
    @pulumi.getter(name="instanceMarketOptions")
    def instance_market_options(self) -> Optional[pulumi.Input['LaunchTemplateInstanceMarketOptionsArgs']]:
        """
        The market (purchasing) option for the instances.
        """
        return pulumi.get(self, "instance_market_options")

    @instance_market_options.setter
    def instance_market_options(self, value: Optional[pulumi.Input['LaunchTemplateInstanceMarketOptionsArgs']]):
        pulumi.set(self, "instance_market_options", value)

    @_builtins.property
    @pulumi.getter(name="instanceRequirements")
    def instance_requirements(self) -> Optional[pulumi.Input['LaunchTemplateInstanceRequirementsArgs']]:
        """
        The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with these attributes.
         You must specify ``VCpuCount`` and ``MemoryMiB``. All other attributes are optional. Any unspecified optional attribute is set to its default.
         When you specify multiple attributes, you get instance types that satisfy all of the specified attributes. If you specify multiple values for an attribute, you get instance types that satisfy any of the specified values.
         To limit the list of instance types from which Amazon EC2 can identify matching instance types, you can use one of the following parameters, but not both in the same request:
          +  ``AllowedInstanceTypes`` - The instance types to include in the list. All other instance types are ignored, even if they match your specified attributes.
          +  ``ExcludedInstanceTypes`` - The instance types to exclude from the list, even if they match your specified attributes.
          
          If you specify ``InstanceRequirements``, you can't specify ``InstanceType``.
         Attribute-based instance type selection is only supported when using Auto Scaling groups, EC2 Fleet, and Spot Fleet to launch instances. If you plan to use the launch template in the [launch instance wizard](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-instance-wizard.html), or with the [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) API or [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html)AWS CloudFormation resource, you can't specify ``InstanceRequirements``.
          For more information, see [Specify attributes for instance type selection for EC2 Fleet or Spot Fleet](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html) and [Spot placement score](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html) in the *Amazon EC2 User Guide*.
        """
        return pulumi.get(self, "instance_requirements")

    @instance_requirements.setter
    def instance_requirements(self, value: Optional[pulumi.Input['LaunchTemplateInstanceRequirementsArgs']]):
        pulumi.set(self, "instance_requirements", value)

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The instance type. For more information, see [Amazon EC2 instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide*.
         If you specify ``InstanceType``, you can't specify ``InstanceRequirements``.
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_type", value)

    @_builtins.property
    @pulumi.getter(name="kernelId")
    def kernel_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the kernel.
         We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [User Provided Kernels](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide*.
        """
        return pulumi.get(self, "kernel_id")

    @kernel_id.setter
    def kernel_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kernel_id", value)

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the key pair. You can create a key pair using [CreateKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html) or [ImportKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html).
          If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.
        """
        return pulumi.get(self, "key_name")

    @key_name.setter
    def key_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_name", value)

    @_builtins.property
    @pulumi.getter(name="licenseSpecifications")
    def license_specifications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LaunchTemplateLicenseSpecificationArgs']]]]:
        """
        The license configurations.
        """
        return pulumi.get(self, "license_specifications")

    @license_specifications.setter
    def license_specifications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LaunchTemplateLicenseSpecificationArgs']]]]):
        pulumi.set(self, "license_specifications", value)

    @_builtins.property
    @pulumi.getter(name="maintenanceOptions")
    def maintenance_options(self) -> Optional[pulumi.Input['LaunchTemplateMaintenanceOptionsArgs']]:
        """
        The maintenance options of your instance.
        """
        return pulumi.get(self, "maintenance_options")

    @maintenance_options.setter
    def maintenance_options(self, value: Optional[pulumi.Input['LaunchTemplateMaintenanceOptionsArgs']]):
        pulumi.set(self, "maintenance_options", value)

    @_builtins.property
    @pulumi.getter(name="metadataOptions")
    def metadata_options(self) -> Optional[pulumi.Input['LaunchTemplateMetadataOptionsArgs']]:
        """
        The metadata options for the instance. For more information, see [Configure the Instance Metadata Service options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/configuring-instance-metadata-options.html) in the *Amazon EC2 User Guide*.
        """
        return pulumi.get(self, "metadata_options")

    @metadata_options.setter
    def metadata_options(self, value: Optional[pulumi.Input['LaunchTemplateMetadataOptionsArgs']]):
        pulumi.set(self, "metadata_options", value)

    @_builtins.property
    @pulumi.getter
    def monitoring(self) -> Optional[pulumi.Input['LaunchTemplateMonitoringArgs']]:
        """
        The monitoring for the instance.
        """
        return pulumi.get(self, "monitoring")

    @monitoring.setter
    def monitoring(self, value: Optional[pulumi.Input['LaunchTemplateMonitoringArgs']]):
        pulumi.set(self, "monitoring", value)

    @_builtins.property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LaunchTemplateNetworkInterfaceArgs']]]]:
        """
        The network interfaces for the instance.
        """
        return pulumi.get(self, "network_interfaces")

    @network_interfaces.setter
    def network_interfaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LaunchTemplateNetworkInterfaceArgs']]]]):
        pulumi.set(self, "network_interfaces", value)

    @_builtins.property
    @pulumi.getter(name="networkPerformanceOptions")
    def network_performance_options(self) -> Optional[pulumi.Input['LaunchTemplateNetworkPerformanceOptionsArgs']]:
        """
        The settings for the network performance options for the instance. For more information, see [EC2 instance bandwidth weighting configuration](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/configure-bandwidth-weighting.html).
        """
        return pulumi.get(self, "network_performance_options")

    @network_performance_options.setter
    def network_performance_options(self, value: Optional[pulumi.Input['LaunchTemplateNetworkPerformanceOptionsArgs']]):
        pulumi.set(self, "network_performance_options", value)

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input['LaunchTemplatePlacementArgs']]:
        """
        The placement for the instance.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input['LaunchTemplatePlacementArgs']]):
        pulumi.set(self, "placement", value)

    @_builtins.property
    @pulumi.getter(name="privateDnsNameOptions")
    def private_dns_name_options(self) -> Optional[pulumi.Input['LaunchTemplatePrivateDnsNameOptionsArgs']]:
        """
        The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries should be handled. For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *User Guide*.
        """
        return pulumi.get(self, "private_dns_name_options")

    @private_dns_name_options.setter
    def private_dns_name_options(self, value: Optional[pulumi.Input['LaunchTemplatePrivateDnsNameOptionsArgs']]):
        pulumi.set(self, "private_dns_name_options", value)

    @_builtins.property
    @pulumi.getter(name="ramDiskId")
    def ram_disk_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the RAM disk.
          We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [User provided kernels](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide*.
        """
        return pulumi.get(self, "ram_disk_id")

    @ram_disk_id.setter
    def ram_disk_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ram_disk_id", value)

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The IDs of the security groups. You can specify the IDs of existing security groups and references to resources created by the stack template.
         If you specify a network interface, you must specify any security groups as part of the network interface instead.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "security_group_ids", value)

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The names of the security groups. For a nondefault VPC, you must use security group IDs instead.
         If you specify a network interface, you must specify any security groups as part of the network interface instead of using this parameter.
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "security_groups", value)

    @_builtins.property
    @pulumi.getter(name="tagSpecifications")
    def tag_specifications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TagSpecificationArgs']]]]:
        """
        The tags to apply to resources that are created during instance launch.
         To tag the launch template itself, use [TagSpecifications](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#cfn-ec2-launchtemplate-tagspecifications).
        """
        return pulumi.get(self, "tag_specifications")

    @tag_specifications.setter
    def tag_specifications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TagSpecificationArgs']]]]):
        pulumi.set(self, "tag_specifications", value)

    @_builtins.property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The user data to make available to the instance. You must provide base64-encoded text. User data is limited to 16 KB. For more information, see [Run commands when you launch an EC2 instance with user data input](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html) in the *Amazon EC2 User Guide*.
         If you are creating the launch template for use with BATCH, the user data must be provided in the [MIME multi-part archive format](https://docs.aws.amazon.com/https://cloudinit.readthedocs.io/en/latest/topics/format.html#mime-multi-part-archive). For more information, see [Amazon EC2 user data in launch templates](https://docs.aws.amazon.com/batch/latest/userguide/launch-templates.html#lt-user-data) in the *User Guide*.
        """
        return pulumi.get(self, "user_data")

    @user_data.setter
    def user_data(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_data", value)


if not MYPY:
    class LaunchTemplateEbsArgsDict(TypedDict):
        """
        Parameters for a block device for an EBS volume in an Amazon EC2 launch template.
         ``Ebs`` is a property of [AWS::EC2::LaunchTemplate BlockDeviceMapping](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping.html).
        """
        delete_on_termination: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the EBS volume is deleted on instance termination.
        """
        encrypted: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the EBS volume is encrypted. Encrypted volumes can only be attached to instances that support Amazon EBS encryption. If you are creating a volume from a snapshot, you can't specify an encryption value.
        """
        iops: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of I/O operations per second (IOPS). For ``gp3``, ``io1``, and ``io2`` volumes, this represents the number of IOPS that are provisioned for the volume. For ``gp2`` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.
         The following are the supported values for each volume type:
          +  ``gp3``: 3,000 - 80,000 IOPS
          +  ``io1``: 100 - 64,000 IOPS
          +  ``io2``: 100 - 256,000 IOPS
          
         For ``io2`` volumes, you can achieve up to 256,000 IOPS on [instances built on the Nitro System](https://docs.aws.amazon.com/ec2/latest/instancetypes/ec2-nitro-instances.html). On other instances, you can achieve performance up to 32,000 IOPS.
         This parameter is supported for ``io1``, ``io2``, and ``gp3`` volumes only.
        """
        kms_key_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identifier (key ID, key alias, key ARN, or alias ARN) of the customer managed KMS key to use for EBS encryption.
        """
        snapshot_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the snapshot.
        """
        throughput: NotRequired[pulumi.Input[_builtins.int]]
        """
        The throughput to provision for a ``gp3`` volume, with a maximum of 2,000 MiB/s.
         Valid Range: Minimum value of 125. Maximum value of 2,000.
        """
        volume_initialization_rate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the Amazon EBS Provisioned Rate for Volume Initialization (volume initialization rate), in MiB/s, at which to download the snapshot blocks from Amazon S3 to the volume. This is also known as *volume initialization*. Specifying a volume initialization rate ensures that the volume is initialized at a predictable and consistent rate after creation.
         This parameter is supported only for volumes created from snapshots. Omit this parameter if:
          +  You want to create the volume using fast snapshot restore. You must specify a snapshot that is enabled for fast snapshot restore. In this case, the volume is fully initialized at creation.
          If you specify a snapshot that is enabled for fast snapshot restore and a volume initialization rate, the volume will be initialized at the specified rate instead of fast snapshot restore.
           +  You want to create a volume that is initialized at the default rate.
          
         For more information, see [Initialize Amazon EBS volumes](https://docs.aws.amazon.com/ebs/latest/userguide/initalize-volume.html) in the *Amazon EC2 User Guide*.
         Valid range: 100 - 300 MiB/s
        """
        volume_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. The following are the supported volumes sizes for each volume type:
          +  ``gp2``: 1 - 16,384 GiB
          +  ``gp3``: 1 - 65,536 GiB
          +  ``io1``: 4 - 16,384 GiB
          +  ``io2``: 4 - 65,536 GiB
          +  ``st1`` and ``sc1``: 125 - 16,384 GiB
          +  ``standard``: 1 - 1024 GiB
        """
        volume_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The volume type. For more information, see [Amazon EBS volume types](https://docs.aws.amazon.com/ebs/latest/userguide/ebs-volume-types.html) in the *Amazon EBS User Guide*.
        """
elif False:
    LaunchTemplateEbsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateEbsArgs:
    def __init__(__self__, *,
                 delete_on_termination: Optional[pulumi.Input[_builtins.bool]] = None,
                 encrypted: Optional[pulumi.Input[_builtins.bool]] = None,
                 iops: Optional[pulumi.Input[_builtins.int]] = None,
                 kms_key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 snapshot_id: Optional[pulumi.Input[_builtins.str]] = None,
                 throughput: Optional[pulumi.Input[_builtins.int]] = None,
                 volume_initialization_rate: Optional[pulumi.Input[_builtins.int]] = None,
                 volume_size: Optional[pulumi.Input[_builtins.int]] = None,
                 volume_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Parameters for a block device for an EBS volume in an Amazon EC2 launch template.
         ``Ebs`` is a property of [AWS::EC2::LaunchTemplate BlockDeviceMapping](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping.html).
        :param pulumi.Input[_builtins.bool] delete_on_termination: Indicates whether the EBS volume is deleted on instance termination.
        :param pulumi.Input[_builtins.bool] encrypted: Indicates whether the EBS volume is encrypted. Encrypted volumes can only be attached to instances that support Amazon EBS encryption. If you are creating a volume from a snapshot, you can't specify an encryption value.
        :param pulumi.Input[_builtins.int] iops: The number of I/O operations per second (IOPS). For ``gp3``, ``io1``, and ``io2`` volumes, this represents the number of IOPS that are provisioned for the volume. For ``gp2`` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.
                The following are the supported values for each volume type:
                 +  ``gp3``: 3,000 - 80,000 IOPS
                 +  ``io1``: 100 - 64,000 IOPS
                 +  ``io2``: 100 - 256,000 IOPS
                 
                For ``io2`` volumes, you can achieve up to 256,000 IOPS on [instances built on the Nitro System](https://docs.aws.amazon.com/ec2/latest/instancetypes/ec2-nitro-instances.html). On other instances, you can achieve performance up to 32,000 IOPS.
                This parameter is supported for ``io1``, ``io2``, and ``gp3`` volumes only.
        :param pulumi.Input[_builtins.str] kms_key_id: Identifier (key ID, key alias, key ARN, or alias ARN) of the customer managed KMS key to use for EBS encryption.
        :param pulumi.Input[_builtins.str] snapshot_id: The ID of the snapshot.
        :param pulumi.Input[_builtins.int] throughput: The throughput to provision for a ``gp3`` volume, with a maximum of 2,000 MiB/s.
                Valid Range: Minimum value of 125. Maximum value of 2,000.
        :param pulumi.Input[_builtins.int] volume_initialization_rate: Specifies the Amazon EBS Provisioned Rate for Volume Initialization (volume initialization rate), in MiB/s, at which to download the snapshot blocks from Amazon S3 to the volume. This is also known as *volume initialization*. Specifying a volume initialization rate ensures that the volume is initialized at a predictable and consistent rate after creation.
                This parameter is supported only for volumes created from snapshots. Omit this parameter if:
                 +  You want to create the volume using fast snapshot restore. You must specify a snapshot that is enabled for fast snapshot restore. In this case, the volume is fully initialized at creation.
                 If you specify a snapshot that is enabled for fast snapshot restore and a volume initialization rate, the volume will be initialized at the specified rate instead of fast snapshot restore.
                  +  You want to create a volume that is initialized at the default rate.
                 
                For more information, see [Initialize Amazon EBS volumes](https://docs.aws.amazon.com/ebs/latest/userguide/initalize-volume.html) in the *Amazon EC2 User Guide*.
                Valid range: 100 - 300 MiB/s
        :param pulumi.Input[_builtins.int] volume_size: The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. The following are the supported volumes sizes for each volume type:
                 +  ``gp2``: 1 - 16,384 GiB
                 +  ``gp3``: 1 - 65,536 GiB
                 +  ``io1``: 4 - 16,384 GiB
                 +  ``io2``: 4 - 65,536 GiB
                 +  ``st1`` and ``sc1``: 125 - 16,384 GiB
                 +  ``standard``: 1 - 1024 GiB
        :param pulumi.Input[_builtins.str] volume_type: The volume type. For more information, see [Amazon EBS volume types](https://docs.aws.amazon.com/ebs/latest/userguide/ebs-volume-types.html) in the *Amazon EBS User Guide*.
        """
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_initialization_rate is not None:
            pulumi.set(__self__, "volume_initialization_rate", volume_initialization_rate)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the EBS volume is deleted on instance termination.
        """
        return pulumi.get(self, "delete_on_termination")

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "delete_on_termination", value)

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the EBS volume is encrypted. Encrypted volumes can only be attached to instances that support Amazon EBS encryption. If you are creating a volume from a snapshot, you can't specify an encryption value.
        """
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "encrypted", value)

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of I/O operations per second (IOPS). For ``gp3``, ``io1``, and ``io2`` volumes, this represents the number of IOPS that are provisioned for the volume. For ``gp2`` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.
         The following are the supported values for each volume type:
          +  ``gp3``: 3,000 - 80,000 IOPS
          +  ``io1``: 100 - 64,000 IOPS
          +  ``io2``: 100 - 256,000 IOPS
          
         For ``io2`` volumes, you can achieve up to 256,000 IOPS on [instances built on the Nitro System](https://docs.aws.amazon.com/ec2/latest/instancetypes/ec2-nitro-instances.html). On other instances, you can achieve performance up to 32,000 IOPS.
         This parameter is supported for ``io1``, ``io2``, and ``gp3`` volumes only.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "iops", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifier (key ID, key alias, key ARN, or alias ARN) of the customer managed KMS key to use for EBS encryption.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_id", value)

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the snapshot.
        """
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "snapshot_id", value)

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The throughput to provision for a ``gp3`` volume, with a maximum of 2,000 MiB/s.
         Valid Range: Minimum value of 125. Maximum value of 2,000.
        """
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "throughput", value)

    @_builtins.property
    @pulumi.getter(name="volumeInitializationRate")
    def volume_initialization_rate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the Amazon EBS Provisioned Rate for Volume Initialization (volume initialization rate), in MiB/s, at which to download the snapshot blocks from Amazon S3 to the volume. This is also known as *volume initialization*. Specifying a volume initialization rate ensures that the volume is initialized at a predictable and consistent rate after creation.
         This parameter is supported only for volumes created from snapshots. Omit this parameter if:
          +  You want to create the volume using fast snapshot restore. You must specify a snapshot that is enabled for fast snapshot restore. In this case, the volume is fully initialized at creation.
          If you specify a snapshot that is enabled for fast snapshot restore and a volume initialization rate, the volume will be initialized at the specified rate instead of fast snapshot restore.
           +  You want to create a volume that is initialized at the default rate.
          
         For more information, see [Initialize Amazon EBS volumes](https://docs.aws.amazon.com/ebs/latest/userguide/initalize-volume.html) in the *Amazon EC2 User Guide*.
         Valid range: 100 - 300 MiB/s
        """
        return pulumi.get(self, "volume_initialization_rate")

    @volume_initialization_rate.setter
    def volume_initialization_rate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "volume_initialization_rate", value)

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. The following are the supported volumes sizes for each volume type:
          +  ``gp2``: 1 - 16,384 GiB
          +  ``gp3``: 1 - 65,536 GiB
          +  ``io1``: 4 - 16,384 GiB
          +  ``io2``: 4 - 65,536 GiB
          +  ``st1`` and ``sc1``: 125 - 16,384 GiB
          +  ``standard``: 1 - 1024 GiB
        """
        return pulumi.get(self, "volume_size")

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "volume_size", value)

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The volume type. For more information, see [Amazon EBS volume types](https://docs.aws.amazon.com/ebs/latest/userguide/ebs-volume-types.html) in the *Amazon EBS User Guide*.
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "volume_type", value)


if not MYPY:
    class LaunchTemplateEnaSrdSpecificationArgsDict(TypedDict):
        """
        ENA Express uses AWS Scalable Reliable Datagram (SRD) technology to increase the maximum bandwidth used per stream and minimize tail latency of network traffic between EC2 instances. With ENA Express, you can communicate between two EC2 instances in the same subnet within the same account, or in different accounts. Both sending and receiving instances must have ENA Express enabled.
         To improve the reliability of network packet delivery, ENA Express reorders network packets on the receiving end by default. However, some UDP-based applications are designed to handle network packets that are out of order to reduce the overhead for packet delivery at the network layer. When ENA Express is enabled, you can specify whether UDP network traffic uses it.
        """
        ena_srd_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether ENA Express is enabled for the network interface.
        """
        ena_srd_udp_specification: NotRequired[pulumi.Input['LaunchTemplateEnaSrdUdpSpecificationArgsDict']]
        """
        Configures ENA Express for UDP network traffic.
        """
elif False:
    LaunchTemplateEnaSrdSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateEnaSrdSpecificationArgs:
    def __init__(__self__, *,
                 ena_srd_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 ena_srd_udp_specification: Optional[pulumi.Input['LaunchTemplateEnaSrdUdpSpecificationArgs']] = None):
        """
        ENA Express uses AWS Scalable Reliable Datagram (SRD) technology to increase the maximum bandwidth used per stream and minimize tail latency of network traffic between EC2 instances. With ENA Express, you can communicate between two EC2 instances in the same subnet within the same account, or in different accounts. Both sending and receiving instances must have ENA Express enabled.
         To improve the reliability of network packet delivery, ENA Express reorders network packets on the receiving end by default. However, some UDP-based applications are designed to handle network packets that are out of order to reduce the overhead for packet delivery at the network layer. When ENA Express is enabled, you can specify whether UDP network traffic uses it.
        :param pulumi.Input[_builtins.bool] ena_srd_enabled: Indicates whether ENA Express is enabled for the network interface.
        :param pulumi.Input['LaunchTemplateEnaSrdUdpSpecificationArgs'] ena_srd_udp_specification: Configures ENA Express for UDP network traffic.
        """
        if ena_srd_enabled is not None:
            pulumi.set(__self__, "ena_srd_enabled", ena_srd_enabled)
        if ena_srd_udp_specification is not None:
            pulumi.set(__self__, "ena_srd_udp_specification", ena_srd_udp_specification)

    @_builtins.property
    @pulumi.getter(name="enaSrdEnabled")
    def ena_srd_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether ENA Express is enabled for the network interface.
        """
        return pulumi.get(self, "ena_srd_enabled")

    @ena_srd_enabled.setter
    def ena_srd_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ena_srd_enabled", value)

    @_builtins.property
    @pulumi.getter(name="enaSrdUdpSpecification")
    def ena_srd_udp_specification(self) -> Optional[pulumi.Input['LaunchTemplateEnaSrdUdpSpecificationArgs']]:
        """
        Configures ENA Express for UDP network traffic.
        """
        return pulumi.get(self, "ena_srd_udp_specification")

    @ena_srd_udp_specification.setter
    def ena_srd_udp_specification(self, value: Optional[pulumi.Input['LaunchTemplateEnaSrdUdpSpecificationArgs']]):
        pulumi.set(self, "ena_srd_udp_specification", value)


if not MYPY:
    class LaunchTemplateEnaSrdUdpSpecificationArgsDict(TypedDict):
        """
        ENA Express is compatible with both TCP and UDP transport protocols. When it's enabled, TCP traffic automatically uses it. However, some UDP-based applications are designed to handle network packets that are out of order, without a need for retransmission, such as live video broadcasting or other near-real-time applications. For UDP traffic, you can specify whether to use ENA Express, based on your application environment needs.
        """
        ena_srd_udp_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether UDP traffic to and from the instance uses ENA Express. To specify this setting, you must first enable ENA Express.
        """
elif False:
    LaunchTemplateEnaSrdUdpSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateEnaSrdUdpSpecificationArgs:
    def __init__(__self__, *,
                 ena_srd_udp_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        ENA Express is compatible with both TCP and UDP transport protocols. When it's enabled, TCP traffic automatically uses it. However, some UDP-based applications are designed to handle network packets that are out of order, without a need for retransmission, such as live video broadcasting or other near-real-time applications. For UDP traffic, you can specify whether to use ENA Express, based on your application environment needs.
        :param pulumi.Input[_builtins.bool] ena_srd_udp_enabled: Indicates whether UDP traffic to and from the instance uses ENA Express. To specify this setting, you must first enable ENA Express.
        """
        if ena_srd_udp_enabled is not None:
            pulumi.set(__self__, "ena_srd_udp_enabled", ena_srd_udp_enabled)

    @_builtins.property
    @pulumi.getter(name="enaSrdUdpEnabled")
    def ena_srd_udp_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether UDP traffic to and from the instance uses ENA Express. To specify this setting, you must first enable ENA Express.
        """
        return pulumi.get(self, "ena_srd_udp_enabled")

    @ena_srd_udp_enabled.setter
    def ena_srd_udp_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ena_srd_udp_enabled", value)


if not MYPY:
    class LaunchTemplateEnclaveOptionsArgsDict(TypedDict):
        """
        Indicates whether the instance is enabled for AWS Nitro Enclaves.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If this parameter is set to ``true``, the instance is enabled for AWS Nitro Enclaves; otherwise, it is not enabled for AWS Nitro Enclaves.
        """
elif False:
    LaunchTemplateEnclaveOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateEnclaveOptionsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        Indicates whether the instance is enabled for AWS Nitro Enclaves.
        :param pulumi.Input[_builtins.bool] enabled: If this parameter is set to ``true``, the instance is enabled for AWS Nitro Enclaves; otherwise, it is not enabled for AWS Nitro Enclaves.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If this parameter is set to ``true``, the instance is enabled for AWS Nitro Enclaves; otherwise, it is not enabled for AWS Nitro Enclaves.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class LaunchTemplateHibernationOptionsArgsDict(TypedDict):
        """
        Specifies whether your instance is configured for hibernation. This parameter is valid only if the instance meets the [hibernation prerequisites](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html#hibernating-prerequisites). For more information, see [Hibernate Your Instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html) in the *Amazon EC2 User Guide*.
         ``HibernationOptions`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        """
        configured: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If you set this parameter to ``true``, the instance is enabled for hibernation.
         Default: ``false``
        """
elif False:
    LaunchTemplateHibernationOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateHibernationOptionsArgs:
    def __init__(__self__, *,
                 configured: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        Specifies whether your instance is configured for hibernation. This parameter is valid only if the instance meets the [hibernation prerequisites](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html#hibernating-prerequisites). For more information, see [Hibernate Your Instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html) in the *Amazon EC2 User Guide*.
         ``HibernationOptions`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        :param pulumi.Input[_builtins.bool] configured: If you set this parameter to ``true``, the instance is enabled for hibernation.
                Default: ``false``
        """
        if configured is not None:
            pulumi.set(__self__, "configured", configured)

    @_builtins.property
    @pulumi.getter
    def configured(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If you set this parameter to ``true``, the instance is enabled for hibernation.
         Default: ``false``
        """
        return pulumi.get(self, "configured")

    @configured.setter
    def configured(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "configured", value)


if not MYPY:
    class LaunchTemplateIamInstanceProfileArgsDict(TypedDict):
        """
        Specifies an IAM instance profile, which is a container for an IAM role for your instance. You can use an IAM role to distribute your AWS credentials to your instances.
         If you are creating the launch template for use with an ASlong group, you can specify either the name or the ARN of the instance profile, but not both.
         ``IamInstanceProfile`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        """
        arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Amazon Resource Name (ARN) of the instance profile.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the instance profile.
        """
elif False:
    LaunchTemplateIamInstanceProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateIamInstanceProfileArgs:
    def __init__(__self__, *,
                 arn: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Specifies an IAM instance profile, which is a container for an IAM role for your instance. You can use an IAM role to distribute your AWS credentials to your instances.
         If you are creating the launch template for use with an ASlong group, you can specify either the name or the ARN of the instance profile, but not both.
         ``IamInstanceProfile`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        :param pulumi.Input[_builtins.str] arn: The Amazon Resource Name (ARN) of the instance profile.
        :param pulumi.Input[_builtins.str] name: The name of the instance profile.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Amazon Resource Name (ARN) of the instance profile.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "arn", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the instance profile.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class LaunchTemplateInstanceMarketOptionsArgsDict(TypedDict):
        """
        Specifies the market (purchasing) option for an instance.
         ``InstanceMarketOptions`` is a property of the [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        """
        market_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The market type.
        """
        spot_options: NotRequired[pulumi.Input['LaunchTemplateSpotOptionsArgsDict']]
        """
        The options for Spot Instances.
        """
elif False:
    LaunchTemplateInstanceMarketOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateInstanceMarketOptionsArgs:
    def __init__(__self__, *,
                 market_type: Optional[pulumi.Input[_builtins.str]] = None,
                 spot_options: Optional[pulumi.Input['LaunchTemplateSpotOptionsArgs']] = None):
        """
        Specifies the market (purchasing) option for an instance.
         ``InstanceMarketOptions`` is a property of the [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        :param pulumi.Input[_builtins.str] market_type: The market type.
        :param pulumi.Input['LaunchTemplateSpotOptionsArgs'] spot_options: The options for Spot Instances.
        """
        if market_type is not None:
            pulumi.set(__self__, "market_type", market_type)
        if spot_options is not None:
            pulumi.set(__self__, "spot_options", spot_options)

    @_builtins.property
    @pulumi.getter(name="marketType")
    def market_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The market type.
        """
        return pulumi.get(self, "market_type")

    @market_type.setter
    def market_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "market_type", value)

    @_builtins.property
    @pulumi.getter(name="spotOptions")
    def spot_options(self) -> Optional[pulumi.Input['LaunchTemplateSpotOptionsArgs']]:
        """
        The options for Spot Instances.
        """
        return pulumi.get(self, "spot_options")

    @spot_options.setter
    def spot_options(self, value: Optional[pulumi.Input['LaunchTemplateSpotOptionsArgs']]):
        pulumi.set(self, "spot_options", value)


if not MYPY:
    class LaunchTemplateInstanceRequirementsArgsDict(TypedDict):
        """
        The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with these attributes.
         You must specify ``VCpuCount`` and ``MemoryMiB``. All other attributes are optional. Any unspecified optional attribute is set to its default.
         When you specify multiple attributes, you get instance types that satisfy all of the specified attributes. If you specify multiple values for an attribute, you get instance types that satisfy any of the specified values.
         To limit the list of instance types from which Amazon EC2 can identify matching instance types, you can use one of the following parameters, but not both in the same request:
          +  ``AllowedInstanceTypes`` - The instance types to include in the list. All other instance types are ignored, even if they match your specified attributes.
          +  ``ExcludedInstanceTypes`` - The instance types to exclude from the list, even if they match your specified attributes.
          
          If you specify ``InstanceRequirements``, you can't specify ``InstanceType``.
         Attribute-based instance type selection is only supported when using Auto Scaling groups, EC2 Fleet, and Spot Fleet to launch instances. If you plan to use the launch template in the [launch instance wizard](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-instance-wizard.html), or with the [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) API or [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html)AWS CloudFormation resource, you can't specify ``InstanceRequirements``.
          For more information, see [Specify attributes for instance type selection for EC2 Fleet or Spot Fleet](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html) and [Spot placement score](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html) in the *Amazon EC2 User Guide*.
        """
        accelerator_count: NotRequired[pulumi.Input['LaunchTemplateAcceleratorCountArgsDict']]
        """
        The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.
         To exclude accelerator-enabled instance types, set ``Max`` to ``0``.
         Default: No minimum or maximum limits
        """
        accelerator_manufacturers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Indicates whether instance types must have accelerators by specific manufacturers.
          +  For instance types with AWS devices, specify ``amazon-web-services``.
          +  For instance types with AMD devices, specify ``amd``.
          +  For instance types with Habana devices, specify ``habana``.
          +  For instance types with NVIDIA devices, specify ``nvidia``.
          +  For instance types with Xilinx devices, specify ``xilinx``.
          
         Default: Any manufacturer
        """
        accelerator_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The accelerators that must be on the instance type.
          +  For instance types with NVIDIA A10G GPUs, specify ``a10g``.
          +  For instance types with NVIDIA A100 GPUs, specify ``a100``.
          +  For instance types with NVIDIA H100 GPUs, specify ``h100``.
          +  For instance types with AWS Inferentia chips, specify ``inferentia``.
          +  For instance types with NVIDIA GRID K520 GPUs, specify ``k520``.
          +  For instance types with NVIDIA K80 GPUs, specify ``k80``.
          +  For instance types with NVIDIA M60 GPUs, specify ``m60``.
          +  For instance types with AMD Radeon Pro V520 GPUs, specify ``radeon-pro-v520``.
          +  For instance types with NVIDIA T4 GPUs, specify ``t4``.
          +  For instance types with NVIDIA T4G GPUs, specify ``t4g``.
          +  For instance types with Xilinx VU9P FPGAs, specify ``vu9p``.
          +  For instance types with NVIDIA V100 GPUs, specify ``v100``.
          
         Default: Any accelerator
        """
        accelerator_total_memory_mi_b: NotRequired[pulumi.Input['LaunchTemplateAcceleratorTotalMemoryMiBArgsDict']]
        """
        The minimum and maximum amount of total accelerator memory, in MiB.
         Default: No minimum or maximum limits
        """
        accelerator_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The accelerator types that must be on the instance type.
          +  For instance types with FPGA accelerators, specify ``fpga``.
          +  For instance types with GPU accelerators, specify ``gpu``.
          +  For instance types with Inference accelerators, specify ``inference``.
          
         Default: Any accelerator type
        """
        allowed_instance_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes.
         You can use strings with one or more wild cards, represented by an asterisk (``*``), to allow an instance type, size, or generation. The following are examples: ``m5.8xlarge``, ``c5*.*``, ``m5a.*``, ``r*``, ``*3*``.
         For example, if you specify ``c5*``,Amazon EC2 will allow the entire C5 instance family, which includes all C5a and C5n instance types. If you specify ``m5a.*``, Amazon EC2 will allow all the M5a instance types, but not the M5n instance types.
          If you specify ``AllowedInstanceTypes``, you can't specify ``ExcludedInstanceTypes``.
          Default: All instance types
        """
        bare_metal: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates whether bare metal instance types must be included, excluded, or required.
          +  To include bare metal instance types, specify ``included``.
          +  To require only bare metal instance types, specify ``required``.
          +  To exclude bare metal instance types, specify ``excluded``.
          
         Default: ``excluded``
        """
        baseline_ebs_bandwidth_mbps: NotRequired[pulumi.Input['LaunchTemplateBaselineEbsBandwidthMbpsArgsDict']]
        """
        The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see [Amazon EBSoptimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the *Amazon EC2 User Guide*.
         Default: No minimum or maximum limits
        """
        baseline_performance_factors: NotRequired[pulumi.Input['LaunchTemplateBaselinePerformanceFactorsArgsDict']]
        """
        The baseline performance to consider, using an instance family as a baseline reference. The instance family establishes the lowest acceptable level of performance. Amazon EC2 uses this baseline to guide instance type selection, but there is no guarantee that the selected instance types will always exceed the baseline for every application. Currently, this parameter only supports CPU performance as a baseline performance factor. For more information, see [Performance protection](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html#ec2fleet-abis-performance-protection) in the *Amazon EC2 User Guide*.
        """
        burstable_performance: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates whether burstable performance T instance types are included, excluded, or required. For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html).
          +  To include burstable performance instance types, specify ``included``.
          +  To require only burstable performance instance types, specify ``required``.
          +  To exclude burstable performance instance types, specify ``excluded``.
          
         Default: ``excluded``
        """
        cpu_manufacturers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The CPU manufacturers to include.
          +  For instance types with Intel CPUs, specify ``intel``.
          +  For instance types with AMD CPUs, specify ``amd``.
          +  For instance types with AWS CPUs, specify ``amazon-web-services``.
          +  For instance types with Apple CPUs, specify ``apple``.
          
          Don't confuse the CPU manufacturer with the CPU architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.
          Default: Any manufacturer
        """
        excluded_instance_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The instance types to exclude.
         You can use strings with one or more wild cards, represented by an asterisk (``*``), to exclude an instance type, size, or generation. The following are examples: ``m5.8xlarge``, ``c5*.*``, ``m5a.*``, ``r*``, ``*3*``.
         For example, if you specify ``c5*``,Amazon EC2 will exclude the entire C5 instance family, which includes all C5a and C5n instance types. If you specify ``m5a.*``, Amazon EC2 will exclude all the M5a instance types, but not the M5n instance types.
          If you specify ``ExcludedInstanceTypes``, you can't specify ``AllowedInstanceTypes``.
          Default: No excluded instance types
        """
        instance_generations: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Indicates whether current or previous generation instance types are included. The current generation instance types are recommended for use. Current generation instance types are typically the latest two to three generations in each instance family. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide*.
         For current generation instance types, specify ``current``.
         For previous generation instance types, specify ``previous``.
         Default: Current and previous generation instance types
        """
        local_storage: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, [Amazon EC2 instance store](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html) in the *Amazon EC2 User Guide*.
          +  To include instance types with instance store volumes, specify ``included``.
          +  To require only instance types with instance store volumes, specify ``required``.
          +  To exclude instance types with instance store volumes, specify ``excluded``.
          
         Default: ``included``
        """
        local_storage_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The type of local storage that is required.
          +  For instance types with hard disk drive (HDD) storage, specify ``hdd``.
          +  For instance types with solid state drive (SSD) storage, specify ``ssd``.
          
         Default: ``hdd`` and ``ssd``
        """
        max_spot_price_as_percentage_of_optimal_on_demand_price: NotRequired[pulumi.Input[_builtins.int]]
        """
        [Price protection] The price protection threshold for Spot Instances, as a percentage of an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.
         The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
         If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib``, the price protection threshold is based on the per vCPU or per memory price instead of the per instance price.
          Only one of ``SpotMaxPricePercentageOverLowestPrice`` or ``MaxSpotPriceAsPercentageOfOptimalOnDemandPrice`` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as ``999999``.
        """
        memory_gi_b_per_v_cpu: NotRequired[pulumi.Input['LaunchTemplateMemoryGiBPerVCpuArgsDict']]
        """
        The minimum and maximum amount of memory per vCPU, in GiB.
         Default: No minimum or maximum limits
        """
        memory_mi_b: NotRequired[pulumi.Input['LaunchTemplateMemoryMiBArgsDict']]
        """
        The minimum and maximum amount of memory, in MiB.
        """
        network_bandwidth_gbps: NotRequired[pulumi.Input['LaunchTemplateNetworkBandwidthGbpsArgsDict']]
        """
        The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps).
         Default: No minimum or maximum limits
        """
        network_interface_count: NotRequired[pulumi.Input['LaunchTemplateNetworkInterfaceCountArgsDict']]
        """
        The minimum and maximum number of network interfaces.
         Default: No minimum or maximum limits
        """
        on_demand_max_price_percentage_over_lowest_price: NotRequired[pulumi.Input[_builtins.int]]
        """
        [Price protection] The price protection threshold for On-Demand Instances, as a percentage higher than an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.
         The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
         To turn off price protection, specify a high value, such as ``999999``.
         This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html).
          If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib``, the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.
          Default: ``20``
        """
        require_hibernate_support: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether instance types must support hibernation for On-Demand Instances.
         This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html).
         Default: ``false``
        """
        spot_max_price_percentage_over_lowest_price: NotRequired[pulumi.Input[_builtins.int]]
        """
        [Price protection] The price protection threshold for Spot Instances, as a percentage higher than an identified Spot price. The identified Spot price is the Spot price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified Spot price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose Spot price exceeds your specified threshold.
         The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
         If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib``, the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.
         This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html).
          Only one of ``SpotMaxPricePercentageOverLowestPrice`` or ``MaxSpotPriceAsPercentageOfOptimalOnDemandPrice`` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as ``999999``.
          Default: ``100``
        """
        total_local_storage_gb: NotRequired[pulumi.Input['LaunchTemplateTotalLocalStorageGbArgsDict']]
        """
        The minimum and maximum amount of total local storage, in GB.
         Default: No minimum or maximum limits
        """
        v_cpu_count: NotRequired[pulumi.Input['LaunchTemplateVCpuCountArgsDict']]
        """
        The minimum and maximum number of vCPUs.
        """
elif False:
    LaunchTemplateInstanceRequirementsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateInstanceRequirementsArgs:
    def __init__(__self__, *,
                 accelerator_count: Optional[pulumi.Input['LaunchTemplateAcceleratorCountArgs']] = None,
                 accelerator_manufacturers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 accelerator_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 accelerator_total_memory_mi_b: Optional[pulumi.Input['LaunchTemplateAcceleratorTotalMemoryMiBArgs']] = None,
                 accelerator_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allowed_instance_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 bare_metal: Optional[pulumi.Input[_builtins.str]] = None,
                 baseline_ebs_bandwidth_mbps: Optional[pulumi.Input['LaunchTemplateBaselineEbsBandwidthMbpsArgs']] = None,
                 baseline_performance_factors: Optional[pulumi.Input['LaunchTemplateBaselinePerformanceFactorsArgs']] = None,
                 burstable_performance: Optional[pulumi.Input[_builtins.str]] = None,
                 cpu_manufacturers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 excluded_instance_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 instance_generations: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 local_storage: Optional[pulumi.Input[_builtins.str]] = None,
                 local_storage_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 max_spot_price_as_percentage_of_optimal_on_demand_price: Optional[pulumi.Input[_builtins.int]] = None,
                 memory_gi_b_per_v_cpu: Optional[pulumi.Input['LaunchTemplateMemoryGiBPerVCpuArgs']] = None,
                 memory_mi_b: Optional[pulumi.Input['LaunchTemplateMemoryMiBArgs']] = None,
                 network_bandwidth_gbps: Optional[pulumi.Input['LaunchTemplateNetworkBandwidthGbpsArgs']] = None,
                 network_interface_count: Optional[pulumi.Input['LaunchTemplateNetworkInterfaceCountArgs']] = None,
                 on_demand_max_price_percentage_over_lowest_price: Optional[pulumi.Input[_builtins.int]] = None,
                 require_hibernate_support: Optional[pulumi.Input[_builtins.bool]] = None,
                 spot_max_price_percentage_over_lowest_price: Optional[pulumi.Input[_builtins.int]] = None,
                 total_local_storage_gb: Optional[pulumi.Input['LaunchTemplateTotalLocalStorageGbArgs']] = None,
                 v_cpu_count: Optional[pulumi.Input['LaunchTemplateVCpuCountArgs']] = None):
        """
        The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with these attributes.
         You must specify ``VCpuCount`` and ``MemoryMiB``. All other attributes are optional. Any unspecified optional attribute is set to its default.
         When you specify multiple attributes, you get instance types that satisfy all of the specified attributes. If you specify multiple values for an attribute, you get instance types that satisfy any of the specified values.
         To limit the list of instance types from which Amazon EC2 can identify matching instance types, you can use one of the following parameters, but not both in the same request:
          +  ``AllowedInstanceTypes`` - The instance types to include in the list. All other instance types are ignored, even if they match your specified attributes.
          +  ``ExcludedInstanceTypes`` - The instance types to exclude from the list, even if they match your specified attributes.
          
          If you specify ``InstanceRequirements``, you can't specify ``InstanceType``.
         Attribute-based instance type selection is only supported when using Auto Scaling groups, EC2 Fleet, and Spot Fleet to launch instances. If you plan to use the launch template in the [launch instance wizard](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-instance-wizard.html), or with the [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) API or [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html)AWS CloudFormation resource, you can't specify ``InstanceRequirements``.
          For more information, see [Specify attributes for instance type selection for EC2 Fleet or Spot Fleet](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html) and [Spot placement score](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html) in the *Amazon EC2 User Guide*.
        :param pulumi.Input['LaunchTemplateAcceleratorCountArgs'] accelerator_count: The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.
                To exclude accelerator-enabled instance types, set ``Max`` to ``0``.
                Default: No minimum or maximum limits
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] accelerator_manufacturers: Indicates whether instance types must have accelerators by specific manufacturers.
                 +  For instance types with AWS devices, specify ``amazon-web-services``.
                 +  For instance types with AMD devices, specify ``amd``.
                 +  For instance types with Habana devices, specify ``habana``.
                 +  For instance types with NVIDIA devices, specify ``nvidia``.
                 +  For instance types with Xilinx devices, specify ``xilinx``.
                 
                Default: Any manufacturer
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] accelerator_names: The accelerators that must be on the instance type.
                 +  For instance types with NVIDIA A10G GPUs, specify ``a10g``.
                 +  For instance types with NVIDIA A100 GPUs, specify ``a100``.
                 +  For instance types with NVIDIA H100 GPUs, specify ``h100``.
                 +  For instance types with AWS Inferentia chips, specify ``inferentia``.
                 +  For instance types with NVIDIA GRID K520 GPUs, specify ``k520``.
                 +  For instance types with NVIDIA K80 GPUs, specify ``k80``.
                 +  For instance types with NVIDIA M60 GPUs, specify ``m60``.
                 +  For instance types with AMD Radeon Pro V520 GPUs, specify ``radeon-pro-v520``.
                 +  For instance types with NVIDIA T4 GPUs, specify ``t4``.
                 +  For instance types with NVIDIA T4G GPUs, specify ``t4g``.
                 +  For instance types with Xilinx VU9P FPGAs, specify ``vu9p``.
                 +  For instance types with NVIDIA V100 GPUs, specify ``v100``.
                 
                Default: Any accelerator
        :param pulumi.Input['LaunchTemplateAcceleratorTotalMemoryMiBArgs'] accelerator_total_memory_mi_b: The minimum and maximum amount of total accelerator memory, in MiB.
                Default: No minimum or maximum limits
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] accelerator_types: The accelerator types that must be on the instance type.
                 +  For instance types with FPGA accelerators, specify ``fpga``.
                 +  For instance types with GPU accelerators, specify ``gpu``.
                 +  For instance types with Inference accelerators, specify ``inference``.
                 
                Default: Any accelerator type
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_instance_types: The instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes.
                You can use strings with one or more wild cards, represented by an asterisk (``*``), to allow an instance type, size, or generation. The following are examples: ``m5.8xlarge``, ``c5*.*``, ``m5a.*``, ``r*``, ``*3*``.
                For example, if you specify ``c5*``,Amazon EC2 will allow the entire C5 instance family, which includes all C5a and C5n instance types. If you specify ``m5a.*``, Amazon EC2 will allow all the M5a instance types, but not the M5n instance types.
                 If you specify ``AllowedInstanceTypes``, you can't specify ``ExcludedInstanceTypes``.
                 Default: All instance types
        :param pulumi.Input[_builtins.str] bare_metal: Indicates whether bare metal instance types must be included, excluded, or required.
                 +  To include bare metal instance types, specify ``included``.
                 +  To require only bare metal instance types, specify ``required``.
                 +  To exclude bare metal instance types, specify ``excluded``.
                 
                Default: ``excluded``
        :param pulumi.Input['LaunchTemplateBaselineEbsBandwidthMbpsArgs'] baseline_ebs_bandwidth_mbps: The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see [Amazon EBSoptimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the *Amazon EC2 User Guide*.
                Default: No minimum or maximum limits
        :param pulumi.Input['LaunchTemplateBaselinePerformanceFactorsArgs'] baseline_performance_factors: The baseline performance to consider, using an instance family as a baseline reference. The instance family establishes the lowest acceptable level of performance. Amazon EC2 uses this baseline to guide instance type selection, but there is no guarantee that the selected instance types will always exceed the baseline for every application. Currently, this parameter only supports CPU performance as a baseline performance factor. For more information, see [Performance protection](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html#ec2fleet-abis-performance-protection) in the *Amazon EC2 User Guide*.
        :param pulumi.Input[_builtins.str] burstable_performance: Indicates whether burstable performance T instance types are included, excluded, or required. For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html).
                 +  To include burstable performance instance types, specify ``included``.
                 +  To require only burstable performance instance types, specify ``required``.
                 +  To exclude burstable performance instance types, specify ``excluded``.
                 
                Default: ``excluded``
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] cpu_manufacturers: The CPU manufacturers to include.
                 +  For instance types with Intel CPUs, specify ``intel``.
                 +  For instance types with AMD CPUs, specify ``amd``.
                 +  For instance types with AWS CPUs, specify ``amazon-web-services``.
                 +  For instance types with Apple CPUs, specify ``apple``.
                 
                 Don't confuse the CPU manufacturer with the CPU architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.
                 Default: Any manufacturer
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] excluded_instance_types: The instance types to exclude.
                You can use strings with one or more wild cards, represented by an asterisk (``*``), to exclude an instance type, size, or generation. The following are examples: ``m5.8xlarge``, ``c5*.*``, ``m5a.*``, ``r*``, ``*3*``.
                For example, if you specify ``c5*``,Amazon EC2 will exclude the entire C5 instance family, which includes all C5a and C5n instance types. If you specify ``m5a.*``, Amazon EC2 will exclude all the M5a instance types, but not the M5n instance types.
                 If you specify ``ExcludedInstanceTypes``, you can't specify ``AllowedInstanceTypes``.
                 Default: No excluded instance types
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] instance_generations: Indicates whether current or previous generation instance types are included. The current generation instance types are recommended for use. Current generation instance types are typically the latest two to three generations in each instance family. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide*.
                For current generation instance types, specify ``current``.
                For previous generation instance types, specify ``previous``.
                Default: Current and previous generation instance types
        :param pulumi.Input[_builtins.str] local_storage: Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, [Amazon EC2 instance store](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html) in the *Amazon EC2 User Guide*.
                 +  To include instance types with instance store volumes, specify ``included``.
                 +  To require only instance types with instance store volumes, specify ``required``.
                 +  To exclude instance types with instance store volumes, specify ``excluded``.
                 
                Default: ``included``
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] local_storage_types: The type of local storage that is required.
                 +  For instance types with hard disk drive (HDD) storage, specify ``hdd``.
                 +  For instance types with solid state drive (SSD) storage, specify ``ssd``.
                 
                Default: ``hdd`` and ``ssd``
        :param pulumi.Input[_builtins.int] max_spot_price_as_percentage_of_optimal_on_demand_price: [Price protection] The price protection threshold for Spot Instances, as a percentage of an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.
                The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
                If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib``, the price protection threshold is based on the per vCPU or per memory price instead of the per instance price.
                 Only one of ``SpotMaxPricePercentageOverLowestPrice`` or ``MaxSpotPriceAsPercentageOfOptimalOnDemandPrice`` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as ``999999``.
        :param pulumi.Input['LaunchTemplateMemoryGiBPerVCpuArgs'] memory_gi_b_per_v_cpu: The minimum and maximum amount of memory per vCPU, in GiB.
                Default: No minimum or maximum limits
        :param pulumi.Input['LaunchTemplateMemoryMiBArgs'] memory_mi_b: The minimum and maximum amount of memory, in MiB.
        :param pulumi.Input['LaunchTemplateNetworkBandwidthGbpsArgs'] network_bandwidth_gbps: The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps).
                Default: No minimum or maximum limits
        :param pulumi.Input['LaunchTemplateNetworkInterfaceCountArgs'] network_interface_count: The minimum and maximum number of network interfaces.
                Default: No minimum or maximum limits
        :param pulumi.Input[_builtins.int] on_demand_max_price_percentage_over_lowest_price: [Price protection] The price protection threshold for On-Demand Instances, as a percentage higher than an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.
                The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
                To turn off price protection, specify a high value, such as ``999999``.
                This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html).
                 If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib``, the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.
                 Default: ``20``
        :param pulumi.Input[_builtins.bool] require_hibernate_support: Indicates whether instance types must support hibernation for On-Demand Instances.
                This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html).
                Default: ``false``
        :param pulumi.Input[_builtins.int] spot_max_price_percentage_over_lowest_price: [Price protection] The price protection threshold for Spot Instances, as a percentage higher than an identified Spot price. The identified Spot price is the Spot price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified Spot price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose Spot price exceeds your specified threshold.
                The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
                If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib``, the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.
                This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html).
                 Only one of ``SpotMaxPricePercentageOverLowestPrice`` or ``MaxSpotPriceAsPercentageOfOptimalOnDemandPrice`` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as ``999999``.
                 Default: ``100``
        :param pulumi.Input['LaunchTemplateTotalLocalStorageGbArgs'] total_local_storage_gb: The minimum and maximum amount of total local storage, in GB.
                Default: No minimum or maximum limits
        :param pulumi.Input['LaunchTemplateVCpuCountArgs'] v_cpu_count: The minimum and maximum number of vCPUs.
        """
        if accelerator_count is not None:
            pulumi.set(__self__, "accelerator_count", accelerator_count)
        if accelerator_manufacturers is not None:
            pulumi.set(__self__, "accelerator_manufacturers", accelerator_manufacturers)
        if accelerator_names is not None:
            pulumi.set(__self__, "accelerator_names", accelerator_names)
        if accelerator_total_memory_mi_b is not None:
            pulumi.set(__self__, "accelerator_total_memory_mi_b", accelerator_total_memory_mi_b)
        if accelerator_types is not None:
            pulumi.set(__self__, "accelerator_types", accelerator_types)
        if allowed_instance_types is not None:
            pulumi.set(__self__, "allowed_instance_types", allowed_instance_types)
        if bare_metal is not None:
            pulumi.set(__self__, "bare_metal", bare_metal)
        if baseline_ebs_bandwidth_mbps is not None:
            pulumi.set(__self__, "baseline_ebs_bandwidth_mbps", baseline_ebs_bandwidth_mbps)
        if baseline_performance_factors is not None:
            pulumi.set(__self__, "baseline_performance_factors", baseline_performance_factors)
        if burstable_performance is not None:
            pulumi.set(__self__, "burstable_performance", burstable_performance)
        if cpu_manufacturers is not None:
            pulumi.set(__self__, "cpu_manufacturers", cpu_manufacturers)
        if excluded_instance_types is not None:
            pulumi.set(__self__, "excluded_instance_types", excluded_instance_types)
        if instance_generations is not None:
            pulumi.set(__self__, "instance_generations", instance_generations)
        if local_storage is not None:
            pulumi.set(__self__, "local_storage", local_storage)
        if local_storage_types is not None:
            pulumi.set(__self__, "local_storage_types", local_storage_types)
        if max_spot_price_as_percentage_of_optimal_on_demand_price is not None:
            pulumi.set(__self__, "max_spot_price_as_percentage_of_optimal_on_demand_price", max_spot_price_as_percentage_of_optimal_on_demand_price)
        if memory_gi_b_per_v_cpu is not None:
            pulumi.set(__self__, "memory_gi_b_per_v_cpu", memory_gi_b_per_v_cpu)
        if memory_mi_b is not None:
            pulumi.set(__self__, "memory_mi_b", memory_mi_b)
        if network_bandwidth_gbps is not None:
            pulumi.set(__self__, "network_bandwidth_gbps", network_bandwidth_gbps)
        if network_interface_count is not None:
            pulumi.set(__self__, "network_interface_count", network_interface_count)
        if on_demand_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "on_demand_max_price_percentage_over_lowest_price", on_demand_max_price_percentage_over_lowest_price)
        if require_hibernate_support is not None:
            pulumi.set(__self__, "require_hibernate_support", require_hibernate_support)
        if spot_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "spot_max_price_percentage_over_lowest_price", spot_max_price_percentage_over_lowest_price)
        if total_local_storage_gb is not None:
            pulumi.set(__self__, "total_local_storage_gb", total_local_storage_gb)
        if v_cpu_count is not None:
            pulumi.set(__self__, "v_cpu_count", v_cpu_count)

    @_builtins.property
    @pulumi.getter(name="acceleratorCount")
    def accelerator_count(self) -> Optional[pulumi.Input['LaunchTemplateAcceleratorCountArgs']]:
        """
        The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.
         To exclude accelerator-enabled instance types, set ``Max`` to ``0``.
         Default: No minimum or maximum limits
        """
        return pulumi.get(self, "accelerator_count")

    @accelerator_count.setter
    def accelerator_count(self, value: Optional[pulumi.Input['LaunchTemplateAcceleratorCountArgs']]):
        pulumi.set(self, "accelerator_count", value)

    @_builtins.property
    @pulumi.getter(name="acceleratorManufacturers")
    def accelerator_manufacturers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Indicates whether instance types must have accelerators by specific manufacturers.
          +  For instance types with AWS devices, specify ``amazon-web-services``.
          +  For instance types with AMD devices, specify ``amd``.
          +  For instance types with Habana devices, specify ``habana``.
          +  For instance types with NVIDIA devices, specify ``nvidia``.
          +  For instance types with Xilinx devices, specify ``xilinx``.
          
         Default: Any manufacturer
        """
        return pulumi.get(self, "accelerator_manufacturers")

    @accelerator_manufacturers.setter
    def accelerator_manufacturers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "accelerator_manufacturers", value)

    @_builtins.property
    @pulumi.getter(name="acceleratorNames")
    def accelerator_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The accelerators that must be on the instance type.
          +  For instance types with NVIDIA A10G GPUs, specify ``a10g``.
          +  For instance types with NVIDIA A100 GPUs, specify ``a100``.
          +  For instance types with NVIDIA H100 GPUs, specify ``h100``.
          +  For instance types with AWS Inferentia chips, specify ``inferentia``.
          +  For instance types with NVIDIA GRID K520 GPUs, specify ``k520``.
          +  For instance types with NVIDIA K80 GPUs, specify ``k80``.
          +  For instance types with NVIDIA M60 GPUs, specify ``m60``.
          +  For instance types with AMD Radeon Pro V520 GPUs, specify ``radeon-pro-v520``.
          +  For instance types with NVIDIA T4 GPUs, specify ``t4``.
          +  For instance types with NVIDIA T4G GPUs, specify ``t4g``.
          +  For instance types with Xilinx VU9P FPGAs, specify ``vu9p``.
          +  For instance types with NVIDIA V100 GPUs, specify ``v100``.
          
         Default: Any accelerator
        """
        return pulumi.get(self, "accelerator_names")

    @accelerator_names.setter
    def accelerator_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "accelerator_names", value)

    @_builtins.property
    @pulumi.getter(name="acceleratorTotalMemoryMiB")
    def accelerator_total_memory_mi_b(self) -> Optional[pulumi.Input['LaunchTemplateAcceleratorTotalMemoryMiBArgs']]:
        """
        The minimum and maximum amount of total accelerator memory, in MiB.
         Default: No minimum or maximum limits
        """
        return pulumi.get(self, "accelerator_total_memory_mi_b")

    @accelerator_total_memory_mi_b.setter
    def accelerator_total_memory_mi_b(self, value: Optional[pulumi.Input['LaunchTemplateAcceleratorTotalMemoryMiBArgs']]):
        pulumi.set(self, "accelerator_total_memory_mi_b", value)

    @_builtins.property
    @pulumi.getter(name="acceleratorTypes")
    def accelerator_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The accelerator types that must be on the instance type.
          +  For instance types with FPGA accelerators, specify ``fpga``.
          +  For instance types with GPU accelerators, specify ``gpu``.
          +  For instance types with Inference accelerators, specify ``inference``.
          
         Default: Any accelerator type
        """
        return pulumi.get(self, "accelerator_types")

    @accelerator_types.setter
    def accelerator_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "accelerator_types", value)

    @_builtins.property
    @pulumi.getter(name="allowedInstanceTypes")
    def allowed_instance_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes.
         You can use strings with one or more wild cards, represented by an asterisk (``*``), to allow an instance type, size, or generation. The following are examples: ``m5.8xlarge``, ``c5*.*``, ``m5a.*``, ``r*``, ``*3*``.
         For example, if you specify ``c5*``,Amazon EC2 will allow the entire C5 instance family, which includes all C5a and C5n instance types. If you specify ``m5a.*``, Amazon EC2 will allow all the M5a instance types, but not the M5n instance types.
          If you specify ``AllowedInstanceTypes``, you can't specify ``ExcludedInstanceTypes``.
          Default: All instance types
        """
        return pulumi.get(self, "allowed_instance_types")

    @allowed_instance_types.setter
    def allowed_instance_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_instance_types", value)

    @_builtins.property
    @pulumi.getter(name="bareMetal")
    def bare_metal(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates whether bare metal instance types must be included, excluded, or required.
          +  To include bare metal instance types, specify ``included``.
          +  To require only bare metal instance types, specify ``required``.
          +  To exclude bare metal instance types, specify ``excluded``.
          
         Default: ``excluded``
        """
        return pulumi.get(self, "bare_metal")

    @bare_metal.setter
    def bare_metal(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bare_metal", value)

    @_builtins.property
    @pulumi.getter(name="baselineEbsBandwidthMbps")
    def baseline_ebs_bandwidth_mbps(self) -> Optional[pulumi.Input['LaunchTemplateBaselineEbsBandwidthMbpsArgs']]:
        """
        The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see [Amazon EBSoptimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the *Amazon EC2 User Guide*.
         Default: No minimum or maximum limits
        """
        return pulumi.get(self, "baseline_ebs_bandwidth_mbps")

    @baseline_ebs_bandwidth_mbps.setter
    def baseline_ebs_bandwidth_mbps(self, value: Optional[pulumi.Input['LaunchTemplateBaselineEbsBandwidthMbpsArgs']]):
        pulumi.set(self, "baseline_ebs_bandwidth_mbps", value)

    @_builtins.property
    @pulumi.getter(name="baselinePerformanceFactors")
    def baseline_performance_factors(self) -> Optional[pulumi.Input['LaunchTemplateBaselinePerformanceFactorsArgs']]:
        """
        The baseline performance to consider, using an instance family as a baseline reference. The instance family establishes the lowest acceptable level of performance. Amazon EC2 uses this baseline to guide instance type selection, but there is no guarantee that the selected instance types will always exceed the baseline for every application. Currently, this parameter only supports CPU performance as a baseline performance factor. For more information, see [Performance protection](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html#ec2fleet-abis-performance-protection) in the *Amazon EC2 User Guide*.
        """
        return pulumi.get(self, "baseline_performance_factors")

    @baseline_performance_factors.setter
    def baseline_performance_factors(self, value: Optional[pulumi.Input['LaunchTemplateBaselinePerformanceFactorsArgs']]):
        pulumi.set(self, "baseline_performance_factors", value)

    @_builtins.property
    @pulumi.getter(name="burstablePerformance")
    def burstable_performance(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates whether burstable performance T instance types are included, excluded, or required. For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html).
          +  To include burstable performance instance types, specify ``included``.
          +  To require only burstable performance instance types, specify ``required``.
          +  To exclude burstable performance instance types, specify ``excluded``.
          
         Default: ``excluded``
        """
        return pulumi.get(self, "burstable_performance")

    @burstable_performance.setter
    def burstable_performance(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "burstable_performance", value)

    @_builtins.property
    @pulumi.getter(name="cpuManufacturers")
    def cpu_manufacturers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The CPU manufacturers to include.
          +  For instance types with Intel CPUs, specify ``intel``.
          +  For instance types with AMD CPUs, specify ``amd``.
          +  For instance types with AWS CPUs, specify ``amazon-web-services``.
          +  For instance types with Apple CPUs, specify ``apple``.
          
          Don't confuse the CPU manufacturer with the CPU architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.
          Default: Any manufacturer
        """
        return pulumi.get(self, "cpu_manufacturers")

    @cpu_manufacturers.setter
    def cpu_manufacturers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "cpu_manufacturers", value)

    @_builtins.property
    @pulumi.getter(name="excludedInstanceTypes")
    def excluded_instance_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The instance types to exclude.
         You can use strings with one or more wild cards, represented by an asterisk (``*``), to exclude an instance type, size, or generation. The following are examples: ``m5.8xlarge``, ``c5*.*``, ``m5a.*``, ``r*``, ``*3*``.
         For example, if you specify ``c5*``,Amazon EC2 will exclude the entire C5 instance family, which includes all C5a and C5n instance types. If you specify ``m5a.*``, Amazon EC2 will exclude all the M5a instance types, but not the M5n instance types.
          If you specify ``ExcludedInstanceTypes``, you can't specify ``AllowedInstanceTypes``.
          Default: No excluded instance types
        """
        return pulumi.get(self, "excluded_instance_types")

    @excluded_instance_types.setter
    def excluded_instance_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_instance_types", value)

    @_builtins.property
    @pulumi.getter(name="instanceGenerations")
    def instance_generations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Indicates whether current or previous generation instance types are included. The current generation instance types are recommended for use. Current generation instance types are typically the latest two to three generations in each instance family. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide*.
         For current generation instance types, specify ``current``.
         For previous generation instance types, specify ``previous``.
         Default: Current and previous generation instance types
        """
        return pulumi.get(self, "instance_generations")

    @instance_generations.setter
    def instance_generations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "instance_generations", value)

    @_builtins.property
    @pulumi.getter(name="localStorage")
    def local_storage(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, [Amazon EC2 instance store](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html) in the *Amazon EC2 User Guide*.
          +  To include instance types with instance store volumes, specify ``included``.
          +  To require only instance types with instance store volumes, specify ``required``.
          +  To exclude instance types with instance store volumes, specify ``excluded``.
          
         Default: ``included``
        """
        return pulumi.get(self, "local_storage")

    @local_storage.setter
    def local_storage(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "local_storage", value)

    @_builtins.property
    @pulumi.getter(name="localStorageTypes")
    def local_storage_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The type of local storage that is required.
          +  For instance types with hard disk drive (HDD) storage, specify ``hdd``.
          +  For instance types with solid state drive (SSD) storage, specify ``ssd``.
          
         Default: ``hdd`` and ``ssd``
        """
        return pulumi.get(self, "local_storage_types")

    @local_storage_types.setter
    def local_storage_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "local_storage_types", value)

    @_builtins.property
    @pulumi.getter(name="maxSpotPriceAsPercentageOfOptimalOnDemandPrice")
    def max_spot_price_as_percentage_of_optimal_on_demand_price(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        [Price protection] The price protection threshold for Spot Instances, as a percentage of an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.
         The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
         If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib``, the price protection threshold is based on the per vCPU or per memory price instead of the per instance price.
          Only one of ``SpotMaxPricePercentageOverLowestPrice`` or ``MaxSpotPriceAsPercentageOfOptimalOnDemandPrice`` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as ``999999``.
        """
        return pulumi.get(self, "max_spot_price_as_percentage_of_optimal_on_demand_price")

    @max_spot_price_as_percentage_of_optimal_on_demand_price.setter
    def max_spot_price_as_percentage_of_optimal_on_demand_price(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_spot_price_as_percentage_of_optimal_on_demand_price", value)

    @_builtins.property
    @pulumi.getter(name="memoryGiBPerVCpu")
    def memory_gi_b_per_v_cpu(self) -> Optional[pulumi.Input['LaunchTemplateMemoryGiBPerVCpuArgs']]:
        """
        The minimum and maximum amount of memory per vCPU, in GiB.
         Default: No minimum or maximum limits
        """
        return pulumi.get(self, "memory_gi_b_per_v_cpu")

    @memory_gi_b_per_v_cpu.setter
    def memory_gi_b_per_v_cpu(self, value: Optional[pulumi.Input['LaunchTemplateMemoryGiBPerVCpuArgs']]):
        pulumi.set(self, "memory_gi_b_per_v_cpu", value)

    @_builtins.property
    @pulumi.getter(name="memoryMiB")
    def memory_mi_b(self) -> Optional[pulumi.Input['LaunchTemplateMemoryMiBArgs']]:
        """
        The minimum and maximum amount of memory, in MiB.
        """
        return pulumi.get(self, "memory_mi_b")

    @memory_mi_b.setter
    def memory_mi_b(self, value: Optional[pulumi.Input['LaunchTemplateMemoryMiBArgs']]):
        pulumi.set(self, "memory_mi_b", value)

    @_builtins.property
    @pulumi.getter(name="networkBandwidthGbps")
    def network_bandwidth_gbps(self) -> Optional[pulumi.Input['LaunchTemplateNetworkBandwidthGbpsArgs']]:
        """
        The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps).
         Default: No minimum or maximum limits
        """
        return pulumi.get(self, "network_bandwidth_gbps")

    @network_bandwidth_gbps.setter
    def network_bandwidth_gbps(self, value: Optional[pulumi.Input['LaunchTemplateNetworkBandwidthGbpsArgs']]):
        pulumi.set(self, "network_bandwidth_gbps", value)

    @_builtins.property
    @pulumi.getter(name="networkInterfaceCount")
    def network_interface_count(self) -> Optional[pulumi.Input['LaunchTemplateNetworkInterfaceCountArgs']]:
        """
        The minimum and maximum number of network interfaces.
         Default: No minimum or maximum limits
        """
        return pulumi.get(self, "network_interface_count")

    @network_interface_count.setter
    def network_interface_count(self, value: Optional[pulumi.Input['LaunchTemplateNetworkInterfaceCountArgs']]):
        pulumi.set(self, "network_interface_count", value)

    @_builtins.property
    @pulumi.getter(name="onDemandMaxPricePercentageOverLowestPrice")
    def on_demand_max_price_percentage_over_lowest_price(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        [Price protection] The price protection threshold for On-Demand Instances, as a percentage higher than an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.
         The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
         To turn off price protection, specify a high value, such as ``999999``.
         This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html).
          If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib``, the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.
          Default: ``20``
        """
        return pulumi.get(self, "on_demand_max_price_percentage_over_lowest_price")

    @on_demand_max_price_percentage_over_lowest_price.setter
    def on_demand_max_price_percentage_over_lowest_price(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "on_demand_max_price_percentage_over_lowest_price", value)

    @_builtins.property
    @pulumi.getter(name="requireHibernateSupport")
    def require_hibernate_support(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether instance types must support hibernation for On-Demand Instances.
         This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html).
         Default: ``false``
        """
        return pulumi.get(self, "require_hibernate_support")

    @require_hibernate_support.setter
    def require_hibernate_support(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "require_hibernate_support", value)

    @_builtins.property
    @pulumi.getter(name="spotMaxPricePercentageOverLowestPrice")
    def spot_max_price_percentage_over_lowest_price(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        [Price protection] The price protection threshold for Spot Instances, as a percentage higher than an identified Spot price. The identified Spot price is the Spot price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified Spot price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose Spot price exceeds your specified threshold.
         The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
         If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib``, the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.
         This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html).
          Only one of ``SpotMaxPricePercentageOverLowestPrice`` or ``MaxSpotPriceAsPercentageOfOptimalOnDemandPrice`` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as ``999999``.
          Default: ``100``
        """
        return pulumi.get(self, "spot_max_price_percentage_over_lowest_price")

    @spot_max_price_percentage_over_lowest_price.setter
    def spot_max_price_percentage_over_lowest_price(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "spot_max_price_percentage_over_lowest_price", value)

    @_builtins.property
    @pulumi.getter(name="totalLocalStorageGb")
    def total_local_storage_gb(self) -> Optional[pulumi.Input['LaunchTemplateTotalLocalStorageGbArgs']]:
        """
        The minimum and maximum amount of total local storage, in GB.
         Default: No minimum or maximum limits
        """
        return pulumi.get(self, "total_local_storage_gb")

    @total_local_storage_gb.setter
    def total_local_storage_gb(self, value: Optional[pulumi.Input['LaunchTemplateTotalLocalStorageGbArgs']]):
        pulumi.set(self, "total_local_storage_gb", value)

    @_builtins.property
    @pulumi.getter(name="vCpuCount")
    def v_cpu_count(self) -> Optional[pulumi.Input['LaunchTemplateVCpuCountArgs']]:
        """
        The minimum and maximum number of vCPUs.
        """
        return pulumi.get(self, "v_cpu_count")

    @v_cpu_count.setter
    def v_cpu_count(self, value: Optional[pulumi.Input['LaunchTemplateVCpuCountArgs']]):
        pulumi.set(self, "v_cpu_count", value)


if not MYPY:
    class LaunchTemplateIpv4PrefixSpecificationArgsDict(TypedDict):
        """
        Specifies an IPv4 prefix for a network interface.
         ``Ipv4PrefixSpecification`` is a property of [AWS::EC2::LaunchTemplate NetworkInterface](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html).
        """
        ipv4_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IPv4 prefix. For information, see [Assigning prefixes to network interfaces](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-prefix-eni.html) in the *Amazon EC2 User Guide*.
        """
elif False:
    LaunchTemplateIpv4PrefixSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateIpv4PrefixSpecificationArgs:
    def __init__(__self__, *,
                 ipv4_prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Specifies an IPv4 prefix for a network interface.
         ``Ipv4PrefixSpecification`` is a property of [AWS::EC2::LaunchTemplate NetworkInterface](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html).
        :param pulumi.Input[_builtins.str] ipv4_prefix: The IPv4 prefix. For information, see [Assigning prefixes to network interfaces](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-prefix-eni.html) in the *Amazon EC2 User Guide*.
        """
        if ipv4_prefix is not None:
            pulumi.set(__self__, "ipv4_prefix", ipv4_prefix)

    @_builtins.property
    @pulumi.getter(name="ipv4Prefix")
    def ipv4_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IPv4 prefix. For information, see [Assigning prefixes to network interfaces](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-prefix-eni.html) in the *Amazon EC2 User Guide*.
        """
        return pulumi.get(self, "ipv4_prefix")

    @ipv4_prefix.setter
    def ipv4_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipv4_prefix", value)


if not MYPY:
    class LaunchTemplateIpv6AddArgsDict(TypedDict):
        """
        Specifies an IPv6 address in an Amazon EC2 launch template.
         ``Ipv6Add`` is a property of [AWS::EC2::LaunchTemplate NetworkInterface](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html).
        """
        ipv6_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. You can't use this option if you're specifying a number of IPv6 addresses.
        """
elif False:
    LaunchTemplateIpv6AddArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateIpv6AddArgs:
    def __init__(__self__, *,
                 ipv6_address: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Specifies an IPv6 address in an Amazon EC2 launch template.
         ``Ipv6Add`` is a property of [AWS::EC2::LaunchTemplate NetworkInterface](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html).
        :param pulumi.Input[_builtins.str] ipv6_address: One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. You can't use this option if you're specifying a number of IPv6 addresses.
        """
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)

    @_builtins.property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. You can't use this option if you're specifying a number of IPv6 addresses.
        """
        return pulumi.get(self, "ipv6_address")

    @ipv6_address.setter
    def ipv6_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipv6_address", value)


if not MYPY:
    class LaunchTemplateIpv6PrefixSpecificationArgsDict(TypedDict):
        """
        Specifies an IPv6 prefix for a network interface.
         ``Ipv6PrefixSpecification`` is a property of [AWS::EC2::LaunchTemplate NetworkInterface](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html).
        """
        ipv6_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IPv6 prefix.
        """
elif False:
    LaunchTemplateIpv6PrefixSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateIpv6PrefixSpecificationArgs:
    def __init__(__self__, *,
                 ipv6_prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Specifies an IPv6 prefix for a network interface.
         ``Ipv6PrefixSpecification`` is a property of [AWS::EC2::LaunchTemplate NetworkInterface](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html).
        :param pulumi.Input[_builtins.str] ipv6_prefix: The IPv6 prefix.
        """
        if ipv6_prefix is not None:
            pulumi.set(__self__, "ipv6_prefix", ipv6_prefix)

    @_builtins.property
    @pulumi.getter(name="ipv6Prefix")
    def ipv6_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IPv6 prefix.
        """
        return pulumi.get(self, "ipv6_prefix")

    @ipv6_prefix.setter
    def ipv6_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipv6_prefix", value)


if not MYPY:
    class LaunchTemplateLicenseSpecificationArgsDict(TypedDict):
        """
        Specifies a license configuration for an instance.
         ``LicenseSpecification`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        """
        license_configuration_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Amazon Resource Name (ARN) of the license configuration.
        """
elif False:
    LaunchTemplateLicenseSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateLicenseSpecificationArgs:
    def __init__(__self__, *,
                 license_configuration_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Specifies a license configuration for an instance.
         ``LicenseSpecification`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        :param pulumi.Input[_builtins.str] license_configuration_arn: The Amazon Resource Name (ARN) of the license configuration.
        """
        if license_configuration_arn is not None:
            pulumi.set(__self__, "license_configuration_arn", license_configuration_arn)

    @_builtins.property
    @pulumi.getter(name="licenseConfigurationArn")
    def license_configuration_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Amazon Resource Name (ARN) of the license configuration.
        """
        return pulumi.get(self, "license_configuration_arn")

    @license_configuration_arn.setter
    def license_configuration_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "license_configuration_arn", value)


if not MYPY:
    class LaunchTemplateMaintenanceOptionsArgsDict(TypedDict):
        """
        The maintenance options of your instance.
        """
        auto_recovery: NotRequired[pulumi.Input[_builtins.str]]
        """
        Disables the automatic recovery behavior of your instance or sets it to default.
        """
elif False:
    LaunchTemplateMaintenanceOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateMaintenanceOptionsArgs:
    def __init__(__self__, *,
                 auto_recovery: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The maintenance options of your instance.
        :param pulumi.Input[_builtins.str] auto_recovery: Disables the automatic recovery behavior of your instance or sets it to default.
        """
        if auto_recovery is not None:
            pulumi.set(__self__, "auto_recovery", auto_recovery)

    @_builtins.property
    @pulumi.getter(name="autoRecovery")
    def auto_recovery(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Disables the automatic recovery behavior of your instance or sets it to default.
        """
        return pulumi.get(self, "auto_recovery")

    @auto_recovery.setter
    def auto_recovery(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "auto_recovery", value)


if not MYPY:
    class LaunchTemplateMemoryGiBPerVCpuArgsDict(TypedDict):
        """
        The minimum and maximum amount of memory per vCPU, in GiB.
        """
        max: NotRequired[pulumi.Input[_builtins.float]]
        """
        The maximum amount of memory per vCPU, in GiB. To specify no maximum limit, omit this parameter.
        """
        min: NotRequired[pulumi.Input[_builtins.float]]
        """
        The minimum amount of memory per vCPU, in GiB. To specify no minimum limit, omit this parameter.
        """
elif False:
    LaunchTemplateMemoryGiBPerVCpuArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateMemoryGiBPerVCpuArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[_builtins.float]] = None,
                 min: Optional[pulumi.Input[_builtins.float]] = None):
        """
        The minimum and maximum amount of memory per vCPU, in GiB.
        :param pulumi.Input[_builtins.float] max: The maximum amount of memory per vCPU, in GiB. To specify no maximum limit, omit this parameter.
        :param pulumi.Input[_builtins.float] min: The minimum amount of memory per vCPU, in GiB. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The maximum amount of memory per vCPU, in GiB. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The minimum amount of memory per vCPU, in GiB. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class LaunchTemplateMemoryMiBArgsDict(TypedDict):
        """
        The minimum and maximum amount of memory, in MiB.
        """
        max: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum amount of memory, in MiB. To specify no maximum limit, omit this parameter.
        """
        min: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum amount of memory, in MiB. To specify no minimum limit, specify ``0``.
        """
elif False:
    LaunchTemplateMemoryMiBArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateMemoryMiBArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[_builtins.int]] = None,
                 min: Optional[pulumi.Input[_builtins.int]] = None):
        """
        The minimum and maximum amount of memory, in MiB.
        :param pulumi.Input[_builtins.int] max: The maximum amount of memory, in MiB. To specify no maximum limit, omit this parameter.
        :param pulumi.Input[_builtins.int] min: The minimum amount of memory, in MiB. To specify no minimum limit, specify ``0``.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum amount of memory, in MiB. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum amount of memory, in MiB. To specify no minimum limit, specify ``0``.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class LaunchTemplateMetadataOptionsArgsDict(TypedDict):
        """
        The metadata options for the instance. For more information, see [Instance metadata and user data](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html) in the *Amazon EC2 User Guide*.
         ``MetadataOptions`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        """
        http_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        Enables or disables the HTTP metadata endpoint on your instances. If the parameter is not specified, the default state is ``enabled``.
          If you specify a value of ``disabled``, you will not be able to access your instance metadata.
        """
        http_protocol_ipv6: NotRequired[pulumi.Input[_builtins.str]]
        """
        Enables or disables the IPv6 endpoint for the instance metadata service.
         Default: ``disabled``
        """
        http_put_response_hop_limit: NotRequired[pulumi.Input[_builtins.int]]
        """
        The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel.
         Default: ``1``
         Possible values: Integers from 1 to 64
        """
        http_tokens: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates whether IMDSv2 is required.
          +  ``optional`` - IMDSv2 is optional. You can choose whether to send a session token in your instance metadata retrieval requests. If you retrieve IAM role credentials without a session token, you receive the IMDSv1 role credentials. If you retrieve IAM role credentials using a valid session token, you receive the IMDSv2 role credentials.
          +  ``required`` - IMDSv2 is required. You must send a session token in your instance metadata retrieval requests. With this option, retrieving the IAM role credentials always returns IMDSv2 credentials; IMDSv1 credentials are not available.
          
         Default: If the value of ``ImdsSupport`` for the Amazon Machine Image (AMI) for your instance is ``v2.0``, the default is ``required``.
        """
        instance_metadata_tags: NotRequired[pulumi.Input[_builtins.str]]
        """
        Set to ``enabled`` to allow access to instance tags from the instance metadata. Set to ``disabled`` to turn off access to instance tags from the instance metadata. For more information, see [View tags for your EC2 instances using instance metadata](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/work-with-tags-in-IMDS.html).
         Default: ``disabled``
        """
elif False:
    LaunchTemplateMetadataOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateMetadataOptionsArgs:
    def __init__(__self__, *,
                 http_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 http_protocol_ipv6: Optional[pulumi.Input[_builtins.str]] = None,
                 http_put_response_hop_limit: Optional[pulumi.Input[_builtins.int]] = None,
                 http_tokens: Optional[pulumi.Input[_builtins.str]] = None,
                 instance_metadata_tags: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The metadata options for the instance. For more information, see [Instance metadata and user data](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html) in the *Amazon EC2 User Guide*.
         ``MetadataOptions`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        :param pulumi.Input[_builtins.str] http_endpoint: Enables or disables the HTTP metadata endpoint on your instances. If the parameter is not specified, the default state is ``enabled``.
                 If you specify a value of ``disabled``, you will not be able to access your instance metadata.
        :param pulumi.Input[_builtins.str] http_protocol_ipv6: Enables or disables the IPv6 endpoint for the instance metadata service.
                Default: ``disabled``
        :param pulumi.Input[_builtins.int] http_put_response_hop_limit: The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel.
                Default: ``1``
                Possible values: Integers from 1 to 64
        :param pulumi.Input[_builtins.str] http_tokens: Indicates whether IMDSv2 is required.
                 +  ``optional`` - IMDSv2 is optional. You can choose whether to send a session token in your instance metadata retrieval requests. If you retrieve IAM role credentials without a session token, you receive the IMDSv1 role credentials. If you retrieve IAM role credentials using a valid session token, you receive the IMDSv2 role credentials.
                 +  ``required`` - IMDSv2 is required. You must send a session token in your instance metadata retrieval requests. With this option, retrieving the IAM role credentials always returns IMDSv2 credentials; IMDSv1 credentials are not available.
                 
                Default: If the value of ``ImdsSupport`` for the Amazon Machine Image (AMI) for your instance is ``v2.0``, the default is ``required``.
        :param pulumi.Input[_builtins.str] instance_metadata_tags: Set to ``enabled`` to allow access to instance tags from the instance metadata. Set to ``disabled`` to turn off access to instance tags from the instance metadata. For more information, see [View tags for your EC2 instances using instance metadata](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/work-with-tags-in-IMDS.html).
                Default: ``disabled``
        """
        if http_endpoint is not None:
            pulumi.set(__self__, "http_endpoint", http_endpoint)
        if http_protocol_ipv6 is not None:
            pulumi.set(__self__, "http_protocol_ipv6", http_protocol_ipv6)
        if http_put_response_hop_limit is not None:
            pulumi.set(__self__, "http_put_response_hop_limit", http_put_response_hop_limit)
        if http_tokens is not None:
            pulumi.set(__self__, "http_tokens", http_tokens)
        if instance_metadata_tags is not None:
            pulumi.set(__self__, "instance_metadata_tags", instance_metadata_tags)

    @_builtins.property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Enables or disables the HTTP metadata endpoint on your instances. If the parameter is not specified, the default state is ``enabled``.
          If you specify a value of ``disabled``, you will not be able to access your instance metadata.
        """
        return pulumi.get(self, "http_endpoint")

    @http_endpoint.setter
    def http_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "http_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="httpProtocolIpv6")
    def http_protocol_ipv6(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Enables or disables the IPv6 endpoint for the instance metadata service.
         Default: ``disabled``
        """
        return pulumi.get(self, "http_protocol_ipv6")

    @http_protocol_ipv6.setter
    def http_protocol_ipv6(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "http_protocol_ipv6", value)

    @_builtins.property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel.
         Default: ``1``
         Possible values: Integers from 1 to 64
        """
        return pulumi.get(self, "http_put_response_hop_limit")

    @http_put_response_hop_limit.setter
    def http_put_response_hop_limit(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "http_put_response_hop_limit", value)

    @_builtins.property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates whether IMDSv2 is required.
          +  ``optional`` - IMDSv2 is optional. You can choose whether to send a session token in your instance metadata retrieval requests. If you retrieve IAM role credentials without a session token, you receive the IMDSv1 role credentials. If you retrieve IAM role credentials using a valid session token, you receive the IMDSv2 role credentials.
          +  ``required`` - IMDSv2 is required. You must send a session token in your instance metadata retrieval requests. With this option, retrieving the IAM role credentials always returns IMDSv2 credentials; IMDSv1 credentials are not available.
          
         Default: If the value of ``ImdsSupport`` for the Amazon Machine Image (AMI) for your instance is ``v2.0``, the default is ``required``.
        """
        return pulumi.get(self, "http_tokens")

    @http_tokens.setter
    def http_tokens(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "http_tokens", value)

    @_builtins.property
    @pulumi.getter(name="instanceMetadataTags")
    def instance_metadata_tags(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Set to ``enabled`` to allow access to instance tags from the instance metadata. Set to ``disabled`` to turn off access to instance tags from the instance metadata. For more information, see [View tags for your EC2 instances using instance metadata](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/work-with-tags-in-IMDS.html).
         Default: ``disabled``
        """
        return pulumi.get(self, "instance_metadata_tags")

    @instance_metadata_tags.setter
    def instance_metadata_tags(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_metadata_tags", value)


if not MYPY:
    class LaunchTemplateMonitoringArgsDict(TypedDict):
        """
        Specifies whether detailed monitoring is enabled for an instance. For more information about detailed monitoring, see [Enable or turn off detailed monitoring for your instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-cloudwatch-new.html) in the *User Guide*.
         ``Monitoring`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specify ``true`` to enable detailed monitoring. Otherwise, basic monitoring is enabled.
        """
elif False:
    LaunchTemplateMonitoringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateMonitoringArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        Specifies whether detailed monitoring is enabled for an instance. For more information about detailed monitoring, see [Enable or turn off detailed monitoring for your instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-cloudwatch-new.html) in the *User Guide*.
         ``Monitoring`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        :param pulumi.Input[_builtins.bool] enabled: Specify ``true`` to enable detailed monitoring. Otherwise, basic monitoring is enabled.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specify ``true`` to enable detailed monitoring. Otherwise, basic monitoring is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class LaunchTemplateNetworkBandwidthGbpsArgsDict(TypedDict):
        """
        The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps).
          Setting the minimum bandwidth does not guarantee that your instance will achieve the minimum bandwidth. Amazon EC2 will identify instance types that support the specified minimum bandwidth, but the actual bandwidth of your instance might go below the specified minimum at times. For more information, see [Available instance bandwidth](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-network-bandwidth.html#available-instance-bandwidth) in the *Amazon EC2 User Guide*.
        """
        max: NotRequired[pulumi.Input[_builtins.float]]
        """
        The maximum amount of network bandwidth, in Gbps. To specify no maximum limit, omit this parameter.
        """
        min: NotRequired[pulumi.Input[_builtins.float]]
        """
        The minimum amount of network bandwidth, in Gbps. If this parameter is not specified, there is no minimum limit.
        """
elif False:
    LaunchTemplateNetworkBandwidthGbpsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateNetworkBandwidthGbpsArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[_builtins.float]] = None,
                 min: Optional[pulumi.Input[_builtins.float]] = None):
        """
        The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps).
          Setting the minimum bandwidth does not guarantee that your instance will achieve the minimum bandwidth. Amazon EC2 will identify instance types that support the specified minimum bandwidth, but the actual bandwidth of your instance might go below the specified minimum at times. For more information, see [Available instance bandwidth](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-network-bandwidth.html#available-instance-bandwidth) in the *Amazon EC2 User Guide*.
        :param pulumi.Input[_builtins.float] max: The maximum amount of network bandwidth, in Gbps. To specify no maximum limit, omit this parameter.
        :param pulumi.Input[_builtins.float] min: The minimum amount of network bandwidth, in Gbps. If this parameter is not specified, there is no minimum limit.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The maximum amount of network bandwidth, in Gbps. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The minimum amount of network bandwidth, in Gbps. If this parameter is not specified, there is no minimum limit.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class LaunchTemplateNetworkInterfaceCountArgsDict(TypedDict):
        """
        The minimum and maximum number of network interfaces.
        """
        max: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum number of network interfaces. To specify no maximum limit, omit this parameter.
        """
        min: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum number of network interfaces. To specify no minimum limit, omit this parameter.
        """
elif False:
    LaunchTemplateNetworkInterfaceCountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateNetworkInterfaceCountArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[_builtins.int]] = None,
                 min: Optional[pulumi.Input[_builtins.int]] = None):
        """
        The minimum and maximum number of network interfaces.
        :param pulumi.Input[_builtins.int] max: The maximum number of network interfaces. To specify no maximum limit, omit this parameter.
        :param pulumi.Input[_builtins.int] min: The minimum number of network interfaces. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum number of network interfaces. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum number of network interfaces. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class LaunchTemplateNetworkInterfaceArgsDict(TypedDict):
        """
        Specifies the parameters for a network interface.
         ``NetworkInterface`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        """
        associate_carrier_ip_address: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Associates a Carrier IP address with eth0 for a new network interface.
         Use this option when you launch an instance in a Wavelength Zone and want to associate a Carrier IP address with the network interface. For more information about Carrier IP addresses, see [Carrier IP addresses](https://docs.aws.amazon.com/wavelength/latest/developerguide/how-wavelengths-work.html#provider-owned-ip) in the *Developer Guide*.
        """
        associate_public_ip_address: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Associates a public IPv4 address with eth0 for a new network interface.
         AWS charges for all public IPv4 addresses, including public IPv4 addresses associated with running instances and Elastic IP addresses. For more information, see the *Public IPv4 Address* tab on the [Amazon VPC pricing page](https://docs.aws.amazon.com/vpc/pricing/).
        """
        connection_tracking_specification: NotRequired[pulumi.Input['LaunchTemplateConnectionTrackingSpecificationArgsDict']]
        """
        A connection tracking specification for the network interface.
        """
        delete_on_termination: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the network interface is deleted when the instance is terminated.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description for the network interface.
        """
        device_index: NotRequired[pulumi.Input[_builtins.int]]
        """
        The device index for the network interface attachment. The primary network interface has a device index of 0. If the network interface is of type ``interface``, you must specify a device index.
         If you create a launch template that includes secondary network interfaces but no primary network interface, and you specify it using the ``LaunchTemplate`` property of ``AWS::EC2::Instance``, then you must include a primary network interface using the ``NetworkInterfaces`` property of ``AWS::EC2::Instance``.
        """
        ena_queue_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of ENA queues to be created with the instance.
        """
        ena_srd_specification: NotRequired[pulumi.Input['LaunchTemplateEnaSrdSpecificationArgsDict']]
        """
        The ENA Express configuration for the network interface.
        """
        groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The IDs of one or more security groups.
        """
        interface_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of network interface. To create an Elastic Fabric Adapter (EFA), specify ``efa`` or ``efa``. For more information, see [Elastic Fabric Adapter for AI/ML and HPC workloads on Amazon EC2](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/efa.html) in the *Amazon EC2 User Guide*.
         If you are not creating an EFA, specify ``interface`` or omit this parameter.
         If you specify ``efa-only``, do not assign any IP addresses to the network interface. EFA-only network interfaces do not support IP addresses.
         Valid values: ``interface`` | ``efa`` | ``efa-only``
        """
        ipv4_prefix_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of IPv4 prefixes to be automatically assigned to the network interface. You cannot use this option if you use the ``Ipv4Prefix`` option.
        """
        ipv4_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input['LaunchTemplateIpv4PrefixSpecificationArgsDict']]]]
        """
        One or more IPv4 prefixes to be assigned to the network interface. You cannot use this option if you use the ``Ipv4PrefixCount`` option.
        """
        ipv6_address_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of IPv6 addresses to assign to a network interface. Amazon EC2 automatically selects the IPv6 addresses from the subnet range. You can't use this option if specifying specific IPv6 addresses.
        """
        ipv6_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['LaunchTemplateIpv6AddArgsDict']]]]
        """
        One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. You can't use this option if you're specifying a number of IPv6 addresses.
        """
        ipv6_prefix_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of IPv6 prefixes to be automatically assigned to the network interface. You cannot use this option if you use the ``Ipv6Prefix`` option.
        """
        ipv6_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input['LaunchTemplateIpv6PrefixSpecificationArgsDict']]]]
        """
        One or more IPv6 prefixes to be assigned to the network interface. You cannot use this option if you use the ``Ipv6PrefixCount`` option.
        """
        network_card_index: NotRequired[pulumi.Input[_builtins.int]]
        """
        The index of the network card. Some instance types support multiple network cards. The primary network interface must be assigned to network card index 0. The default is network card index 0.
        """
        network_interface_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the network interface.
        """
        primary_ipv6: NotRequired[pulumi.Input[_builtins.bool]]
        """
        The primary IPv6 address of the network interface. When you enable an IPv6 GUA address to be a primary IPv6, the first IPv6 GUA will be made the primary IPv6 address until the instance is terminated or the network interface is detached. For more information about primary IPv6 addresses, see [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html).
        """
        private_ip_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The primary private IPv4 address of the network interface.
        """
        private_ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['LaunchTemplatePrivateIpAddArgsDict']]]]
        """
        One or more private IPv4 addresses.
        """
        secondary_private_ip_address_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of secondary private IPv4 addresses to assign to a network interface.
        """
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the subnet for the network interface.
        """
elif False:
    LaunchTemplateNetworkInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateNetworkInterfaceArgs:
    def __init__(__self__, *,
                 associate_carrier_ip_address: Optional[pulumi.Input[_builtins.bool]] = None,
                 associate_public_ip_address: Optional[pulumi.Input[_builtins.bool]] = None,
                 connection_tracking_specification: Optional[pulumi.Input['LaunchTemplateConnectionTrackingSpecificationArgs']] = None,
                 delete_on_termination: Optional[pulumi.Input[_builtins.bool]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 device_index: Optional[pulumi.Input[_builtins.int]] = None,
                 ena_queue_count: Optional[pulumi.Input[_builtins.int]] = None,
                 ena_srd_specification: Optional[pulumi.Input['LaunchTemplateEnaSrdSpecificationArgs']] = None,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 interface_type: Optional[pulumi.Input[_builtins.str]] = None,
                 ipv4_prefix_count: Optional[pulumi.Input[_builtins.int]] = None,
                 ipv4_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input['LaunchTemplateIpv4PrefixSpecificationArgs']]]] = None,
                 ipv6_address_count: Optional[pulumi.Input[_builtins.int]] = None,
                 ipv6_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['LaunchTemplateIpv6AddArgs']]]] = None,
                 ipv6_prefix_count: Optional[pulumi.Input[_builtins.int]] = None,
                 ipv6_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input['LaunchTemplateIpv6PrefixSpecificationArgs']]]] = None,
                 network_card_index: Optional[pulumi.Input[_builtins.int]] = None,
                 network_interface_id: Optional[pulumi.Input[_builtins.str]] = None,
                 primary_ipv6: Optional[pulumi.Input[_builtins.bool]] = None,
                 private_ip_address: Optional[pulumi.Input[_builtins.str]] = None,
                 private_ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['LaunchTemplatePrivateIpAddArgs']]]] = None,
                 secondary_private_ip_address_count: Optional[pulumi.Input[_builtins.int]] = None,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Specifies the parameters for a network interface.
         ``NetworkInterface`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        :param pulumi.Input[_builtins.bool] associate_carrier_ip_address: Associates a Carrier IP address with eth0 for a new network interface.
                Use this option when you launch an instance in a Wavelength Zone and want to associate a Carrier IP address with the network interface. For more information about Carrier IP addresses, see [Carrier IP addresses](https://docs.aws.amazon.com/wavelength/latest/developerguide/how-wavelengths-work.html#provider-owned-ip) in the *Developer Guide*.
        :param pulumi.Input[_builtins.bool] associate_public_ip_address: Associates a public IPv4 address with eth0 for a new network interface.
                AWS charges for all public IPv4 addresses, including public IPv4 addresses associated with running instances and Elastic IP addresses. For more information, see the *Public IPv4 Address* tab on the [Amazon VPC pricing page](https://docs.aws.amazon.com/vpc/pricing/).
        :param pulumi.Input['LaunchTemplateConnectionTrackingSpecificationArgs'] connection_tracking_specification: A connection tracking specification for the network interface.
        :param pulumi.Input[_builtins.bool] delete_on_termination: Indicates whether the network interface is deleted when the instance is terminated.
        :param pulumi.Input[_builtins.str] description: A description for the network interface.
        :param pulumi.Input[_builtins.int] device_index: The device index for the network interface attachment. The primary network interface has a device index of 0. If the network interface is of type ``interface``, you must specify a device index.
                If you create a launch template that includes secondary network interfaces but no primary network interface, and you specify it using the ``LaunchTemplate`` property of ``AWS::EC2::Instance``, then you must include a primary network interface using the ``NetworkInterfaces`` property of ``AWS::EC2::Instance``.
        :param pulumi.Input[_builtins.int] ena_queue_count: The number of ENA queues to be created with the instance.
        :param pulumi.Input['LaunchTemplateEnaSrdSpecificationArgs'] ena_srd_specification: The ENA Express configuration for the network interface.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] groups: The IDs of one or more security groups.
        :param pulumi.Input[_builtins.str] interface_type: The type of network interface. To create an Elastic Fabric Adapter (EFA), specify ``efa`` or ``efa``. For more information, see [Elastic Fabric Adapter for AI/ML and HPC workloads on Amazon EC2](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/efa.html) in the *Amazon EC2 User Guide*.
                If you are not creating an EFA, specify ``interface`` or omit this parameter.
                If you specify ``efa-only``, do not assign any IP addresses to the network interface. EFA-only network interfaces do not support IP addresses.
                Valid values: ``interface`` | ``efa`` | ``efa-only``
        :param pulumi.Input[_builtins.int] ipv4_prefix_count: The number of IPv4 prefixes to be automatically assigned to the network interface. You cannot use this option if you use the ``Ipv4Prefix`` option.
        :param pulumi.Input[Sequence[pulumi.Input['LaunchTemplateIpv4PrefixSpecificationArgs']]] ipv4_prefixes: One or more IPv4 prefixes to be assigned to the network interface. You cannot use this option if you use the ``Ipv4PrefixCount`` option.
        :param pulumi.Input[_builtins.int] ipv6_address_count: The number of IPv6 addresses to assign to a network interface. Amazon EC2 automatically selects the IPv6 addresses from the subnet range. You can't use this option if specifying specific IPv6 addresses.
        :param pulumi.Input[Sequence[pulumi.Input['LaunchTemplateIpv6AddArgs']]] ipv6_addresses: One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. You can't use this option if you're specifying a number of IPv6 addresses.
        :param pulumi.Input[_builtins.int] ipv6_prefix_count: The number of IPv6 prefixes to be automatically assigned to the network interface. You cannot use this option if you use the ``Ipv6Prefix`` option.
        :param pulumi.Input[Sequence[pulumi.Input['LaunchTemplateIpv6PrefixSpecificationArgs']]] ipv6_prefixes: One or more IPv6 prefixes to be assigned to the network interface. You cannot use this option if you use the ``Ipv6PrefixCount`` option.
        :param pulumi.Input[_builtins.int] network_card_index: The index of the network card. Some instance types support multiple network cards. The primary network interface must be assigned to network card index 0. The default is network card index 0.
        :param pulumi.Input[_builtins.str] network_interface_id: The ID of the network interface.
        :param pulumi.Input[_builtins.bool] primary_ipv6: The primary IPv6 address of the network interface. When you enable an IPv6 GUA address to be a primary IPv6, the first IPv6 GUA will be made the primary IPv6 address until the instance is terminated or the network interface is detached. For more information about primary IPv6 addresses, see [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html).
        :param pulumi.Input[_builtins.str] private_ip_address: The primary private IPv4 address of the network interface.
        :param pulumi.Input[Sequence[pulumi.Input['LaunchTemplatePrivateIpAddArgs']]] private_ip_addresses: One or more private IPv4 addresses.
        :param pulumi.Input[_builtins.int] secondary_private_ip_address_count: The number of secondary private IPv4 addresses to assign to a network interface.
        :param pulumi.Input[_builtins.str] subnet_id: The ID of the subnet for the network interface.
        """
        if associate_carrier_ip_address is not None:
            pulumi.set(__self__, "associate_carrier_ip_address", associate_carrier_ip_address)
        if associate_public_ip_address is not None:
            pulumi.set(__self__, "associate_public_ip_address", associate_public_ip_address)
        if connection_tracking_specification is not None:
            pulumi.set(__self__, "connection_tracking_specification", connection_tracking_specification)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if device_index is not None:
            pulumi.set(__self__, "device_index", device_index)
        if ena_queue_count is not None:
            pulumi.set(__self__, "ena_queue_count", ena_queue_count)
        if ena_srd_specification is not None:
            pulumi.set(__self__, "ena_srd_specification", ena_srd_specification)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if interface_type is not None:
            pulumi.set(__self__, "interface_type", interface_type)
        if ipv4_prefix_count is not None:
            pulumi.set(__self__, "ipv4_prefix_count", ipv4_prefix_count)
        if ipv4_prefixes is not None:
            pulumi.set(__self__, "ipv4_prefixes", ipv4_prefixes)
        if ipv6_address_count is not None:
            pulumi.set(__self__, "ipv6_address_count", ipv6_address_count)
        if ipv6_addresses is not None:
            pulumi.set(__self__, "ipv6_addresses", ipv6_addresses)
        if ipv6_prefix_count is not None:
            pulumi.set(__self__, "ipv6_prefix_count", ipv6_prefix_count)
        if ipv6_prefixes is not None:
            pulumi.set(__self__, "ipv6_prefixes", ipv6_prefixes)
        if network_card_index is not None:
            pulumi.set(__self__, "network_card_index", network_card_index)
        if network_interface_id is not None:
            pulumi.set(__self__, "network_interface_id", network_interface_id)
        if primary_ipv6 is not None:
            pulumi.set(__self__, "primary_ipv6", primary_ipv6)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)
        if private_ip_addresses is not None:
            pulumi.set(__self__, "private_ip_addresses", private_ip_addresses)
        if secondary_private_ip_address_count is not None:
            pulumi.set(__self__, "secondary_private_ip_address_count", secondary_private_ip_address_count)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="associateCarrierIpAddress")
    def associate_carrier_ip_address(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Associates a Carrier IP address with eth0 for a new network interface.
         Use this option when you launch an instance in a Wavelength Zone and want to associate a Carrier IP address with the network interface. For more information about Carrier IP addresses, see [Carrier IP addresses](https://docs.aws.amazon.com/wavelength/latest/developerguide/how-wavelengths-work.html#provider-owned-ip) in the *Developer Guide*.
        """
        return pulumi.get(self, "associate_carrier_ip_address")

    @associate_carrier_ip_address.setter
    def associate_carrier_ip_address(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "associate_carrier_ip_address", value)

    @_builtins.property
    @pulumi.getter(name="associatePublicIpAddress")
    def associate_public_ip_address(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Associates a public IPv4 address with eth0 for a new network interface.
         AWS charges for all public IPv4 addresses, including public IPv4 addresses associated with running instances and Elastic IP addresses. For more information, see the *Public IPv4 Address* tab on the [Amazon VPC pricing page](https://docs.aws.amazon.com/vpc/pricing/).
        """
        return pulumi.get(self, "associate_public_ip_address")

    @associate_public_ip_address.setter
    def associate_public_ip_address(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "associate_public_ip_address", value)

    @_builtins.property
    @pulumi.getter(name="connectionTrackingSpecification")
    def connection_tracking_specification(self) -> Optional[pulumi.Input['LaunchTemplateConnectionTrackingSpecificationArgs']]:
        """
        A connection tracking specification for the network interface.
        """
        return pulumi.get(self, "connection_tracking_specification")

    @connection_tracking_specification.setter
    def connection_tracking_specification(self, value: Optional[pulumi.Input['LaunchTemplateConnectionTrackingSpecificationArgs']]):
        pulumi.set(self, "connection_tracking_specification", value)

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the network interface is deleted when the instance is terminated.
        """
        return pulumi.get(self, "delete_on_termination")

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "delete_on_termination", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description for the network interface.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The device index for the network interface attachment. The primary network interface has a device index of 0. If the network interface is of type ``interface``, you must specify a device index.
         If you create a launch template that includes secondary network interfaces but no primary network interface, and you specify it using the ``LaunchTemplate`` property of ``AWS::EC2::Instance``, then you must include a primary network interface using the ``NetworkInterfaces`` property of ``AWS::EC2::Instance``.
        """
        return pulumi.get(self, "device_index")

    @device_index.setter
    def device_index(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "device_index", value)

    @_builtins.property
    @pulumi.getter(name="enaQueueCount")
    def ena_queue_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of ENA queues to be created with the instance.
        """
        return pulumi.get(self, "ena_queue_count")

    @ena_queue_count.setter
    def ena_queue_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ena_queue_count", value)

    @_builtins.property
    @pulumi.getter(name="enaSrdSpecification")
    def ena_srd_specification(self) -> Optional[pulumi.Input['LaunchTemplateEnaSrdSpecificationArgs']]:
        """
        The ENA Express configuration for the network interface.
        """
        return pulumi.get(self, "ena_srd_specification")

    @ena_srd_specification.setter
    def ena_srd_specification(self, value: Optional[pulumi.Input['LaunchTemplateEnaSrdSpecificationArgs']]):
        pulumi.set(self, "ena_srd_specification", value)

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The IDs of one or more security groups.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "groups", value)

    @_builtins.property
    @pulumi.getter(name="interfaceType")
    def interface_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of network interface. To create an Elastic Fabric Adapter (EFA), specify ``efa`` or ``efa``. For more information, see [Elastic Fabric Adapter for AI/ML and HPC workloads on Amazon EC2](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/efa.html) in the *Amazon EC2 User Guide*.
         If you are not creating an EFA, specify ``interface`` or omit this parameter.
         If you specify ``efa-only``, do not assign any IP addresses to the network interface. EFA-only network interfaces do not support IP addresses.
         Valid values: ``interface`` | ``efa`` | ``efa-only``
        """
        return pulumi.get(self, "interface_type")

    @interface_type.setter
    def interface_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interface_type", value)

    @_builtins.property
    @pulumi.getter(name="ipv4PrefixCount")
    def ipv4_prefix_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of IPv4 prefixes to be automatically assigned to the network interface. You cannot use this option if you use the ``Ipv4Prefix`` option.
        """
        return pulumi.get(self, "ipv4_prefix_count")

    @ipv4_prefix_count.setter
    def ipv4_prefix_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ipv4_prefix_count", value)

    @_builtins.property
    @pulumi.getter(name="ipv4Prefixes")
    def ipv4_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LaunchTemplateIpv4PrefixSpecificationArgs']]]]:
        """
        One or more IPv4 prefixes to be assigned to the network interface. You cannot use this option if you use the ``Ipv4PrefixCount`` option.
        """
        return pulumi.get(self, "ipv4_prefixes")

    @ipv4_prefixes.setter
    def ipv4_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LaunchTemplateIpv4PrefixSpecificationArgs']]]]):
        pulumi.set(self, "ipv4_prefixes", value)

    @_builtins.property
    @pulumi.getter(name="ipv6AddressCount")
    def ipv6_address_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of IPv6 addresses to assign to a network interface. Amazon EC2 automatically selects the IPv6 addresses from the subnet range. You can't use this option if specifying specific IPv6 addresses.
        """
        return pulumi.get(self, "ipv6_address_count")

    @ipv6_address_count.setter
    def ipv6_address_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ipv6_address_count", value)

    @_builtins.property
    @pulumi.getter(name="ipv6Addresses")
    def ipv6_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LaunchTemplateIpv6AddArgs']]]]:
        """
        One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. You can't use this option if you're specifying a number of IPv6 addresses.
        """
        return pulumi.get(self, "ipv6_addresses")

    @ipv6_addresses.setter
    def ipv6_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LaunchTemplateIpv6AddArgs']]]]):
        pulumi.set(self, "ipv6_addresses", value)

    @_builtins.property
    @pulumi.getter(name="ipv6PrefixCount")
    def ipv6_prefix_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of IPv6 prefixes to be automatically assigned to the network interface. You cannot use this option if you use the ``Ipv6Prefix`` option.
        """
        return pulumi.get(self, "ipv6_prefix_count")

    @ipv6_prefix_count.setter
    def ipv6_prefix_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ipv6_prefix_count", value)

    @_builtins.property
    @pulumi.getter(name="ipv6Prefixes")
    def ipv6_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LaunchTemplateIpv6PrefixSpecificationArgs']]]]:
        """
        One or more IPv6 prefixes to be assigned to the network interface. You cannot use this option if you use the ``Ipv6PrefixCount`` option.
        """
        return pulumi.get(self, "ipv6_prefixes")

    @ipv6_prefixes.setter
    def ipv6_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LaunchTemplateIpv6PrefixSpecificationArgs']]]]):
        pulumi.set(self, "ipv6_prefixes", value)

    @_builtins.property
    @pulumi.getter(name="networkCardIndex")
    def network_card_index(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The index of the network card. Some instance types support multiple network cards. The primary network interface must be assigned to network card index 0. The default is network card index 0.
        """
        return pulumi.get(self, "network_card_index")

    @network_card_index.setter
    def network_card_index(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "network_card_index", value)

    @_builtins.property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the network interface.
        """
        return pulumi.get(self, "network_interface_id")

    @network_interface_id.setter
    def network_interface_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "network_interface_id", value)

    @_builtins.property
    @pulumi.getter(name="primaryIpv6")
    def primary_ipv6(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        The primary IPv6 address of the network interface. When you enable an IPv6 GUA address to be a primary IPv6, the first IPv6 GUA will be made the primary IPv6 address until the instance is terminated or the network interface is detached. For more information about primary IPv6 addresses, see [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html).
        """
        return pulumi.get(self, "primary_ipv6")

    @primary_ipv6.setter
    def primary_ipv6(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "primary_ipv6", value)

    @_builtins.property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The primary private IPv4 address of the network interface.
        """
        return pulumi.get(self, "private_ip_address")

    @private_ip_address.setter
    def private_ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_ip_address", value)

    @_builtins.property
    @pulumi.getter(name="privateIpAddresses")
    def private_ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LaunchTemplatePrivateIpAddArgs']]]]:
        """
        One or more private IPv4 addresses.
        """
        return pulumi.get(self, "private_ip_addresses")

    @private_ip_addresses.setter
    def private_ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LaunchTemplatePrivateIpAddArgs']]]]):
        pulumi.set(self, "private_ip_addresses", value)

    @_builtins.property
    @pulumi.getter(name="secondaryPrivateIpAddressCount")
    def secondary_private_ip_address_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of secondary private IPv4 addresses to assign to a network interface.
        """
        return pulumi.get(self, "secondary_private_ip_address_count")

    @secondary_private_ip_address_count.setter
    def secondary_private_ip_address_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "secondary_private_ip_address_count", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the subnet for the network interface.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class LaunchTemplateNetworkPerformanceOptionsArgsDict(TypedDict):
        """
        Contains settings for the network performance options for the instance.
        """
        bandwidth_weighting: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specify the bandwidth weighting option to boost the associated type of baseline bandwidth, as follows:
          + default This option uses the standard bandwidth configuration for your instance type. + vpc-1 This option boosts your networking baseline bandwidth and reduces your EBS baseline bandwidth. + ebs-1 This option boosts your EBS baseline bandwidth and reduces your networking baseline bandwidth.
        """
elif False:
    LaunchTemplateNetworkPerformanceOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateNetworkPerformanceOptionsArgs:
    def __init__(__self__, *,
                 bandwidth_weighting: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Contains settings for the network performance options for the instance.
        :param pulumi.Input[_builtins.str] bandwidth_weighting: Specify the bandwidth weighting option to boost the associated type of baseline bandwidth, as follows:
                 + default This option uses the standard bandwidth configuration for your instance type. + vpc-1 This option boosts your networking baseline bandwidth and reduces your EBS baseline bandwidth. + ebs-1 This option boosts your EBS baseline bandwidth and reduces your networking baseline bandwidth.
        """
        if bandwidth_weighting is not None:
            pulumi.set(__self__, "bandwidth_weighting", bandwidth_weighting)

    @_builtins.property
    @pulumi.getter(name="bandwidthWeighting")
    def bandwidth_weighting(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specify the bandwidth weighting option to boost the associated type of baseline bandwidth, as follows:
          + default This option uses the standard bandwidth configuration for your instance type. + vpc-1 This option boosts your networking baseline bandwidth and reduces your EBS baseline bandwidth. + ebs-1 This option boosts your EBS baseline bandwidth and reduces your networking baseline bandwidth.
        """
        return pulumi.get(self, "bandwidth_weighting")

    @bandwidth_weighting.setter
    def bandwidth_weighting(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bandwidth_weighting", value)


if not MYPY:
    class LaunchTemplatePlacementArgsDict(TypedDict):
        """
        Specifies the placement of an instance.
         ``Placement`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        """
        affinity: NotRequired[pulumi.Input[_builtins.str]]
        """
        The affinity setting for an instance on a Dedicated Host.
        """
        availability_zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Availability Zone for the instance.
         Either ``AvailabilityZone`` or ``AvailabilityZoneId`` can be specified, but not both
        """
        group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Group Id of a placement group. You must specify the Placement Group *Group Id* to launch an instance in a shared placement group.
        """
        group_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the placement group for the instance.
        """
        host_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the Dedicated Host for the instance.
        """
        host_resource_group_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ARN of the host resource group in which to launch the instances. If you specify a host resource group ARN, omit the *Tenancy* parameter or set it to ``host``.
        """
        partition_number: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of the partition the instance should launch in. Valid only if the placement group strategy is set to ``partition``.
        """
        spread_domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        Reserved for future use.
        """
        tenancy: NotRequired[pulumi.Input[_builtins.str]]
        """
        The tenancy of the instance. An instance with a tenancy of dedicated runs on single-tenant hardware.
        """
elif False:
    LaunchTemplatePlacementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplatePlacementArgs:
    def __init__(__self__, *,
                 affinity: Optional[pulumi.Input[_builtins.str]] = None,
                 availability_zone: Optional[pulumi.Input[_builtins.str]] = None,
                 group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 group_name: Optional[pulumi.Input[_builtins.str]] = None,
                 host_id: Optional[pulumi.Input[_builtins.str]] = None,
                 host_resource_group_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 partition_number: Optional[pulumi.Input[_builtins.int]] = None,
                 spread_domain: Optional[pulumi.Input[_builtins.str]] = None,
                 tenancy: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Specifies the placement of an instance.
         ``Placement`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        :param pulumi.Input[_builtins.str] affinity: The affinity setting for an instance on a Dedicated Host.
        :param pulumi.Input[_builtins.str] availability_zone: The Availability Zone for the instance.
                Either ``AvailabilityZone`` or ``AvailabilityZoneId`` can be specified, but not both
        :param pulumi.Input[_builtins.str] group_id: The Group Id of a placement group. You must specify the Placement Group *Group Id* to launch an instance in a shared placement group.
        :param pulumi.Input[_builtins.str] group_name: The name of the placement group for the instance.
        :param pulumi.Input[_builtins.str] host_id: The ID of the Dedicated Host for the instance.
        :param pulumi.Input[_builtins.str] host_resource_group_arn: The ARN of the host resource group in which to launch the instances. If you specify a host resource group ARN, omit the *Tenancy* parameter or set it to ``host``.
        :param pulumi.Input[_builtins.int] partition_number: The number of the partition the instance should launch in. Valid only if the placement group strategy is set to ``partition``.
        :param pulumi.Input[_builtins.str] spread_domain: Reserved for future use.
        :param pulumi.Input[_builtins.str] tenancy: The tenancy of the instance. An instance with a tenancy of dedicated runs on single-tenant hardware.
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if host_id is not None:
            pulumi.set(__self__, "host_id", host_id)
        if host_resource_group_arn is not None:
            pulumi.set(__self__, "host_resource_group_arn", host_resource_group_arn)
        if partition_number is not None:
            pulumi.set(__self__, "partition_number", partition_number)
        if spread_domain is not None:
            pulumi.set(__self__, "spread_domain", spread_domain)
        if tenancy is not None:
            pulumi.set(__self__, "tenancy", tenancy)

    @_builtins.property
    @pulumi.getter
    def affinity(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The affinity setting for an instance on a Dedicated Host.
        """
        return pulumi.get(self, "affinity")

    @affinity.setter
    def affinity(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "affinity", value)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Availability Zone for the instance.
         Either ``AvailabilityZone`` or ``AvailabilityZoneId`` can be specified, but not both
        """
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "availability_zone", value)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Group Id of a placement group. You must specify the Placement Group *Group Id* to launch an instance in a shared placement group.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_id", value)

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the placement group for the instance.
        """
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_name", value)

    @_builtins.property
    @pulumi.getter(name="hostId")
    def host_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the Dedicated Host for the instance.
        """
        return pulumi.get(self, "host_id")

    @host_id.setter
    def host_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host_id", value)

    @_builtins.property
    @pulumi.getter(name="hostResourceGroupArn")
    def host_resource_group_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ARN of the host resource group in which to launch the instances. If you specify a host resource group ARN, omit the *Tenancy* parameter or set it to ``host``.
        """
        return pulumi.get(self, "host_resource_group_arn")

    @host_resource_group_arn.setter
    def host_resource_group_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host_resource_group_arn", value)

    @_builtins.property
    @pulumi.getter(name="partitionNumber")
    def partition_number(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of the partition the instance should launch in. Valid only if the placement group strategy is set to ``partition``.
        """
        return pulumi.get(self, "partition_number")

    @partition_number.setter
    def partition_number(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "partition_number", value)

    @_builtins.property
    @pulumi.getter(name="spreadDomain")
    def spread_domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Reserved for future use.
        """
        return pulumi.get(self, "spread_domain")

    @spread_domain.setter
    def spread_domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "spread_domain", value)

    @_builtins.property
    @pulumi.getter
    def tenancy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The tenancy of the instance. An instance with a tenancy of dedicated runs on single-tenant hardware.
        """
        return pulumi.get(self, "tenancy")

    @tenancy.setter
    def tenancy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tenancy", value)


if not MYPY:
    class LaunchTemplatePrivateDnsNameOptionsArgsDict(TypedDict):
        """
        The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries should be handled. For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *User Guide*.
        """
        enable_resource_name_dns_a_record: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
        """
        enable_resource_name_dns_aaaa_record: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
        """
        hostname_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of hostname for EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *User Guide*.
        """
elif False:
    LaunchTemplatePrivateDnsNameOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplatePrivateDnsNameOptionsArgs:
    def __init__(__self__, *,
                 enable_resource_name_dns_a_record: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_resource_name_dns_aaaa_record: Optional[pulumi.Input[_builtins.bool]] = None,
                 hostname_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries should be handled. For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *User Guide*.
        :param pulumi.Input[_builtins.bool] enable_resource_name_dns_a_record: Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
        :param pulumi.Input[_builtins.bool] enable_resource_name_dns_aaaa_record: Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
        :param pulumi.Input[_builtins.str] hostname_type: The type of hostname for EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *User Guide*.
        """
        if enable_resource_name_dns_a_record is not None:
            pulumi.set(__self__, "enable_resource_name_dns_a_record", enable_resource_name_dns_a_record)
        if enable_resource_name_dns_aaaa_record is not None:
            pulumi.set(__self__, "enable_resource_name_dns_aaaa_record", enable_resource_name_dns_aaaa_record)
        if hostname_type is not None:
            pulumi.set(__self__, "hostname_type", hostname_type)

    @_builtins.property
    @pulumi.getter(name="enableResourceNameDnsARecord")
    def enable_resource_name_dns_a_record(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
        """
        return pulumi.get(self, "enable_resource_name_dns_a_record")

    @enable_resource_name_dns_a_record.setter
    def enable_resource_name_dns_a_record(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_resource_name_dns_a_record", value)

    @_builtins.property
    @pulumi.getter(name="enableResourceNameDnsAaaaRecord")
    def enable_resource_name_dns_aaaa_record(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
        """
        return pulumi.get(self, "enable_resource_name_dns_aaaa_record")

    @enable_resource_name_dns_aaaa_record.setter
    def enable_resource_name_dns_aaaa_record(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_resource_name_dns_aaaa_record", value)

    @_builtins.property
    @pulumi.getter(name="hostnameType")
    def hostname_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of hostname for EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *User Guide*.
        """
        return pulumi.get(self, "hostname_type")

    @hostname_type.setter
    def hostname_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hostname_type", value)


if not MYPY:
    class LaunchTemplatePrivateIpAddArgsDict(TypedDict):
        """
        Specifies a secondary private IPv4 address for a network interface.
         ``PrivateIpAdd`` is a property of [AWS::EC2::LaunchTemplate NetworkInterface](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html).
        """
        primary: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.
        """
        private_ip_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The private IPv4 address.
        """
elif False:
    LaunchTemplatePrivateIpAddArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplatePrivateIpAddArgs:
    def __init__(__self__, *,
                 primary: Optional[pulumi.Input[_builtins.bool]] = None,
                 private_ip_address: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Specifies a secondary private IPv4 address for a network interface.
         ``PrivateIpAdd`` is a property of [AWS::EC2::LaunchTemplate NetworkInterface](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html).
        :param pulumi.Input[_builtins.bool] primary: Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.
        :param pulumi.Input[_builtins.str] private_ip_address: The private IPv4 address.
        """
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)

    @_builtins.property
    @pulumi.getter
    def primary(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.
        """
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "primary", value)

    @_builtins.property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The private IPv4 address.
        """
        return pulumi.get(self, "private_ip_address")

    @private_ip_address.setter
    def private_ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_ip_address", value)


if not MYPY:
    class LaunchTemplateReferenceArgsDict(TypedDict):
        """
        Specifies an instance family to use as the baseline reference for CPU performance.
        """
        instance_family: NotRequired[pulumi.Input[_builtins.str]]
        """
        The instance family to use as a baseline reference.
          Ensure that you specify the correct value for the instance family. The instance family is everything before the period (``.``) in the instance type name. For example, in the instance type ``c6i.large``, the instance family is ``c6i``, not ``c6``. For more information, see [Amazon EC2 instance type naming conventions](https://docs.aws.amazon.com/ec2/latest/instancetypes/instance-type-names.html) in *Amazon EC2 Instance Types*.
          The following instance families are *not supported* for performance protection:
          +   ``c1`` 
          +  ``g3`` | ``g3s``
          +   ``hpc7g`` 
          +  ``m1`` | ``m2``
          +  ``mac1`` | ``mac2`` | ``mac2-m1ultra`` | ``mac2-m2`` | ``mac2-m2pro``
          +  ``p3dn`` | ``p4d`` | ``p5``
          +   ``t1`` 
          +  ``u-12tb1`` | ``u-18tb1`` | ``u-24tb1`` | ``u-3tb1`` | ``u-6tb1`` | ``u-9tb1`` | ``u7i-12tb`` | ``u7in-16tb`` | ``u7in-24tb`` | ``u7in-32tb``
          
         If you enable performance protection by specifying a supported instance family, the returned instance types will exclude the above unsupported instance families.
        """
elif False:
    LaunchTemplateReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateReferenceArgs:
    def __init__(__self__, *,
                 instance_family: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Specifies an instance family to use as the baseline reference for CPU performance.
        :param pulumi.Input[_builtins.str] instance_family: The instance family to use as a baseline reference.
                 Ensure that you specify the correct value for the instance family. The instance family is everything before the period (``.``) in the instance type name. For example, in the instance type ``c6i.large``, the instance family is ``c6i``, not ``c6``. For more information, see [Amazon EC2 instance type naming conventions](https://docs.aws.amazon.com/ec2/latest/instancetypes/instance-type-names.html) in *Amazon EC2 Instance Types*.
                 The following instance families are *not supported* for performance protection:
                 +   ``c1`` 
                 +  ``g3`` | ``g3s``
                 +   ``hpc7g`` 
                 +  ``m1`` | ``m2``
                 +  ``mac1`` | ``mac2`` | ``mac2-m1ultra`` | ``mac2-m2`` | ``mac2-m2pro``
                 +  ``p3dn`` | ``p4d`` | ``p5``
                 +   ``t1`` 
                 +  ``u-12tb1`` | ``u-18tb1`` | ``u-24tb1`` | ``u-3tb1`` | ``u-6tb1`` | ``u-9tb1`` | ``u7i-12tb`` | ``u7in-16tb`` | ``u7in-24tb`` | ``u7in-32tb``
                 
                If you enable performance protection by specifying a supported instance family, the returned instance types will exclude the above unsupported instance families.
        """
        if instance_family is not None:
            pulumi.set(__self__, "instance_family", instance_family)

    @_builtins.property
    @pulumi.getter(name="instanceFamily")
    def instance_family(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The instance family to use as a baseline reference.
          Ensure that you specify the correct value for the instance family. The instance family is everything before the period (``.``) in the instance type name. For example, in the instance type ``c6i.large``, the instance family is ``c6i``, not ``c6``. For more information, see [Amazon EC2 instance type naming conventions](https://docs.aws.amazon.com/ec2/latest/instancetypes/instance-type-names.html) in *Amazon EC2 Instance Types*.
          The following instance families are *not supported* for performance protection:
          +   ``c1`` 
          +  ``g3`` | ``g3s``
          +   ``hpc7g`` 
          +  ``m1`` | ``m2``
          +  ``mac1`` | ``mac2`` | ``mac2-m1ultra`` | ``mac2-m2`` | ``mac2-m2pro``
          +  ``p3dn`` | ``p4d`` | ``p5``
          +   ``t1`` 
          +  ``u-12tb1`` | ``u-18tb1`` | ``u-24tb1`` | ``u-3tb1`` | ``u-6tb1`` | ``u-9tb1`` | ``u7i-12tb`` | ``u7in-16tb`` | ``u7in-24tb`` | ``u7in-32tb``
          
         If you enable performance protection by specifying a supported instance family, the returned instance types will exclude the above unsupported instance families.
        """
        return pulumi.get(self, "instance_family")

    @instance_family.setter
    def instance_family(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_family", value)


if not MYPY:
    class LaunchTemplateSpotOptionsArgsDict(TypedDict):
        """
        Specifies options for Spot Instances.
         ``SpotOptions`` is a property of [AWS::EC2::LaunchTemplate InstanceMarketOptions](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancemarketoptions.html).
        """
        block_duration_minutes: NotRequired[pulumi.Input[_builtins.int]]
        """
        Deprecated.
        """
        instance_interruption_behavior: NotRequired[pulumi.Input[_builtins.str]]
        """
        The behavior when a Spot Instance is interrupted. The default is ``terminate``.
        """
        max_price: NotRequired[pulumi.Input[_builtins.str]]
        """
        The maximum hourly price you're willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price. If you do specify this parameter, it must be more than USD $0.001. Specifying a value below USD $0.001 will result in an ``InvalidParameterValue`` error message when the launch template is used to launch an instance.
          If you specify a maximum price, your Spot Instances will be interrupted more frequently than if you do not specify this parameter.
        """
        spot_instance_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Spot Instance request type.
         If you are using Spot Instances with an Auto Scaling group, use ``one-time`` requests, as the ASlong service handles requesting new Spot Instances whenever the group is below its desired capacity.
        """
        valid_until: NotRequired[pulumi.Input[_builtins.str]]
        """
        The end date of the request, in UTC format (*YYYY-MM-DD*T*HH:MM:SS*Z). Supported only for persistent requests.
          +  For a persistent request, the request remains active until the ``ValidUntil`` date and time is reached. Otherwise, the request remains active until you cancel it.
          +  For a one-time request, ``ValidUntil`` is not supported. The request remains active until all instances launch or you cancel the request.
          
         Default: 7 days from the current date
        """
elif False:
    LaunchTemplateSpotOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateSpotOptionsArgs:
    def __init__(__self__, *,
                 block_duration_minutes: Optional[pulumi.Input[_builtins.int]] = None,
                 instance_interruption_behavior: Optional[pulumi.Input[_builtins.str]] = None,
                 max_price: Optional[pulumi.Input[_builtins.str]] = None,
                 spot_instance_type: Optional[pulumi.Input[_builtins.str]] = None,
                 valid_until: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Specifies options for Spot Instances.
         ``SpotOptions`` is a property of [AWS::EC2::LaunchTemplate InstanceMarketOptions](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancemarketoptions.html).
        :param pulumi.Input[_builtins.int] block_duration_minutes: Deprecated.
        :param pulumi.Input[_builtins.str] instance_interruption_behavior: The behavior when a Spot Instance is interrupted. The default is ``terminate``.
        :param pulumi.Input[_builtins.str] max_price: The maximum hourly price you're willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price. If you do specify this parameter, it must be more than USD $0.001. Specifying a value below USD $0.001 will result in an ``InvalidParameterValue`` error message when the launch template is used to launch an instance.
                 If you specify a maximum price, your Spot Instances will be interrupted more frequently than if you do not specify this parameter.
        :param pulumi.Input[_builtins.str] spot_instance_type: The Spot Instance request type.
                If you are using Spot Instances with an Auto Scaling group, use ``one-time`` requests, as the ASlong service handles requesting new Spot Instances whenever the group is below its desired capacity.
        :param pulumi.Input[_builtins.str] valid_until: The end date of the request, in UTC format (*YYYY-MM-DD*T*HH:MM:SS*Z). Supported only for persistent requests.
                 +  For a persistent request, the request remains active until the ``ValidUntil`` date and time is reached. Otherwise, the request remains active until you cancel it.
                 +  For a one-time request, ``ValidUntil`` is not supported. The request remains active until all instances launch or you cancel the request.
                 
                Default: 7 days from the current date
        """
        if block_duration_minutes is not None:
            pulumi.set(__self__, "block_duration_minutes", block_duration_minutes)
        if instance_interruption_behavior is not None:
            pulumi.set(__self__, "instance_interruption_behavior", instance_interruption_behavior)
        if max_price is not None:
            pulumi.set(__self__, "max_price", max_price)
        if spot_instance_type is not None:
            pulumi.set(__self__, "spot_instance_type", spot_instance_type)
        if valid_until is not None:
            pulumi.set(__self__, "valid_until", valid_until)

    @_builtins.property
    @pulumi.getter(name="blockDurationMinutes")
    def block_duration_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Deprecated.
        """
        return pulumi.get(self, "block_duration_minutes")

    @block_duration_minutes.setter
    def block_duration_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "block_duration_minutes", value)

    @_builtins.property
    @pulumi.getter(name="instanceInterruptionBehavior")
    def instance_interruption_behavior(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The behavior when a Spot Instance is interrupted. The default is ``terminate``.
        """
        return pulumi.get(self, "instance_interruption_behavior")

    @instance_interruption_behavior.setter
    def instance_interruption_behavior(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_interruption_behavior", value)

    @_builtins.property
    @pulumi.getter(name="maxPrice")
    def max_price(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The maximum hourly price you're willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price. If you do specify this parameter, it must be more than USD $0.001. Specifying a value below USD $0.001 will result in an ``InvalidParameterValue`` error message when the launch template is used to launch an instance.
          If you specify a maximum price, your Spot Instances will be interrupted more frequently than if you do not specify this parameter.
        """
        return pulumi.get(self, "max_price")

    @max_price.setter
    def max_price(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_price", value)

    @_builtins.property
    @pulumi.getter(name="spotInstanceType")
    def spot_instance_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Spot Instance request type.
         If you are using Spot Instances with an Auto Scaling group, use ``one-time`` requests, as the ASlong service handles requesting new Spot Instances whenever the group is below its desired capacity.
        """
        return pulumi.get(self, "spot_instance_type")

    @spot_instance_type.setter
    def spot_instance_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "spot_instance_type", value)

    @_builtins.property
    @pulumi.getter(name="validUntil")
    def valid_until(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The end date of the request, in UTC format (*YYYY-MM-DD*T*HH:MM:SS*Z). Supported only for persistent requests.
          +  For a persistent request, the request remains active until the ``ValidUntil`` date and time is reached. Otherwise, the request remains active until you cancel it.
          +  For a one-time request, ``ValidUntil`` is not supported. The request remains active until all instances launch or you cancel the request.
          
         Default: 7 days from the current date
        """
        return pulumi.get(self, "valid_until")

    @valid_until.setter
    def valid_until(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "valid_until", value)


if not MYPY:
    class LaunchTemplateTagSpecificationArgsDict(TypedDict):
        """
        Specifies the tags to apply to the launch template during creation.
         To specify the tags for the resources that are created during instance launch, use [AWS::EC2::LaunchTemplate TagSpecification](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-tagspecification.html).
         ``LaunchTemplateTagSpecification`` is a property of [AWS::EC2::LaunchTemplate](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html).
        """
        resource_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of resource. To tag a launch template, ``ResourceType`` must be ``launch-template``.
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['LaunchTemplateTagArgsDict']]]]
        """
        The tags for the resource.
        """
elif False:
    LaunchTemplateTagSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateTagSpecificationArgs:
    def __init__(__self__, *,
                 resource_type: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['LaunchTemplateTagArgs']]]] = None):
        """
        Specifies the tags to apply to the launch template during creation.
         To specify the tags for the resources that are created during instance launch, use [AWS::EC2::LaunchTemplate TagSpecification](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-tagspecification.html).
         ``LaunchTemplateTagSpecification`` is a property of [AWS::EC2::LaunchTemplate](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html).
        :param pulumi.Input[_builtins.str] resource_type: The type of resource. To tag a launch template, ``ResourceType`` must be ``launch-template``.
        :param pulumi.Input[Sequence[pulumi.Input['LaunchTemplateTagArgs']]] tags: The tags for the resource.
        """
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of resource. To tag a launch template, ``ResourceType`` must be ``launch-template``.
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_type", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LaunchTemplateTagArgs']]]]:
        """
        The tags for the resource.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LaunchTemplateTagArgs']]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class LaunchTemplateTagArgsDict(TypedDict):
        """
        Specifies a tag. For more information, see [Resource tags](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html).
        """
        key: pulumi.Input[_builtins.str]
        """
        The tag key.
        """
        value: pulumi.Input[_builtins.str]
        """
        The tag value.
        """
elif False:
    LaunchTemplateTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        Specifies a tag. For more information, see [Resource tags](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html).
        :param pulumi.Input[_builtins.str] key: The tag key.
        :param pulumi.Input[_builtins.str] value: The tag value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        The tag value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class LaunchTemplateTotalLocalStorageGbArgsDict(TypedDict):
        """
        The minimum and maximum amount of total local storage, in GB.
        """
        max: NotRequired[pulumi.Input[_builtins.float]]
        """
        The maximum amount of total local storage, in GB. To specify no maximum limit, omit this parameter.
        """
        min: NotRequired[pulumi.Input[_builtins.float]]
        """
        The minimum amount of total local storage, in GB. To specify no minimum limit, omit this parameter.
        """
elif False:
    LaunchTemplateTotalLocalStorageGbArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateTotalLocalStorageGbArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[_builtins.float]] = None,
                 min: Optional[pulumi.Input[_builtins.float]] = None):
        """
        The minimum and maximum amount of total local storage, in GB.
        :param pulumi.Input[_builtins.float] max: The maximum amount of total local storage, in GB. To specify no maximum limit, omit this parameter.
        :param pulumi.Input[_builtins.float] min: The minimum amount of total local storage, in GB. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The maximum amount of total local storage, in GB. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The minimum amount of total local storage, in GB. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class LaunchTemplateVCpuCountArgsDict(TypedDict):
        """
        The minimum and maximum number of vCPUs.
        """
        max: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
        """
        min: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum number of vCPUs. To specify no minimum limit, specify ``0``.
        """
elif False:
    LaunchTemplateVCpuCountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchTemplateVCpuCountArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[_builtins.int]] = None,
                 min: Optional[pulumi.Input[_builtins.int]] = None):
        """
        The minimum and maximum number of vCPUs.
        :param pulumi.Input[_builtins.int] max: The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
        :param pulumi.Input[_builtins.int] min: The minimum number of vCPUs. To specify no minimum limit, specify ``0``.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum number of vCPUs. To specify no minimum limit, specify ``0``.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class NetworkInsightsAccessScopeAccessScopePathRequestArgsDict(TypedDict):
        destination: NotRequired[pulumi.Input['NetworkInsightsAccessScopePathStatementRequestArgsDict']]
        """
        The destination.
        """
        source: NotRequired[pulumi.Input['NetworkInsightsAccessScopePathStatementRequestArgsDict']]
        """
        The source.
        """
        through_resources: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkInsightsAccessScopeThroughResourcesStatementRequestArgsDict']]]]
        """
        The through resources.
        """
elif False:
    NetworkInsightsAccessScopeAccessScopePathRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkInsightsAccessScopeAccessScopePathRequestArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input['NetworkInsightsAccessScopePathStatementRequestArgs']] = None,
                 source: Optional[pulumi.Input['NetworkInsightsAccessScopePathStatementRequestArgs']] = None,
                 through_resources: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkInsightsAccessScopeThroughResourcesStatementRequestArgs']]]] = None):
        """
        :param pulumi.Input['NetworkInsightsAccessScopePathStatementRequestArgs'] destination: The destination.
        :param pulumi.Input['NetworkInsightsAccessScopePathStatementRequestArgs'] source: The source.
        :param pulumi.Input[Sequence[pulumi.Input['NetworkInsightsAccessScopeThroughResourcesStatementRequestArgs']]] through_resources: The through resources.
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if through_resources is not None:
            pulumi.set(__self__, "through_resources", through_resources)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input['NetworkInsightsAccessScopePathStatementRequestArgs']]:
        """
        The destination.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input['NetworkInsightsAccessScopePathStatementRequestArgs']]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input['NetworkInsightsAccessScopePathStatementRequestArgs']]:
        """
        The source.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input['NetworkInsightsAccessScopePathStatementRequestArgs']]):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter(name="throughResources")
    def through_resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkInsightsAccessScopeThroughResourcesStatementRequestArgs']]]]:
        """
        The through resources.
        """
        return pulumi.get(self, "through_resources")

    @through_resources.setter
    def through_resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkInsightsAccessScopeThroughResourcesStatementRequestArgs']]]]):
        pulumi.set(self, "through_resources", value)


if not MYPY:
    class NetworkInsightsAccessScopePacketHeaderStatementRequestArgsDict(TypedDict):
        destination_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The destination addresses.
        """
        destination_ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The destination ports.
        """
        destination_prefix_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The destination prefix lists.
        """
        protocols: NotRequired[pulumi.Input[Sequence[pulumi.Input['NetworkInsightsAccessScopeProtocol']]]]
        """
        The protocols.
        """
        source_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The source addresses.
        """
        source_ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The source ports.
        """
        source_prefix_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The source prefix lists.
        """
elif False:
    NetworkInsightsAccessScopePacketHeaderStatementRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkInsightsAccessScopePacketHeaderStatementRequestArgs:
    def __init__(__self__, *,
                 destination_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 destination_ports: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 destination_prefix_lists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkInsightsAccessScopeProtocol']]]] = None,
                 source_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 source_ports: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 source_prefix_lists: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] destination_addresses: The destination addresses.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] destination_ports: The destination ports.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] destination_prefix_lists: The destination prefix lists.
        :param pulumi.Input[Sequence[pulumi.Input['NetworkInsightsAccessScopeProtocol']]] protocols: The protocols.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] source_addresses: The source addresses.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] source_ports: The source ports.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] source_prefix_lists: The source prefix lists.
        """
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if destination_ports is not None:
            pulumi.set(__self__, "destination_ports", destination_ports)
        if destination_prefix_lists is not None:
            pulumi.set(__self__, "destination_prefix_lists", destination_prefix_lists)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_ports is not None:
            pulumi.set(__self__, "source_ports", source_ports)
        if source_prefix_lists is not None:
            pulumi.set(__self__, "source_prefix_lists", source_prefix_lists)

    @_builtins.property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The destination addresses.
        """
        return pulumi.get(self, "destination_addresses")

    @destination_addresses.setter
    def destination_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "destination_addresses", value)

    @_builtins.property
    @pulumi.getter(name="destinationPorts")
    def destination_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The destination ports.
        """
        return pulumi.get(self, "destination_ports")

    @destination_ports.setter
    def destination_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "destination_ports", value)

    @_builtins.property
    @pulumi.getter(name="destinationPrefixLists")
    def destination_prefix_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The destination prefix lists.
        """
        return pulumi.get(self, "destination_prefix_lists")

    @destination_prefix_lists.setter
    def destination_prefix_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "destination_prefix_lists", value)

    @_builtins.property
    @pulumi.getter
    def protocols(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['NetworkInsightsAccessScopeProtocol']]]]:
        """
        The protocols.
        """
        return pulumi.get(self, "protocols")

    @protocols.setter
    def protocols(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['NetworkInsightsAccessScopeProtocol']]]]):
        pulumi.set(self, "protocols", value)

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The source addresses.
        """
        return pulumi.get(self, "source_addresses")

    @source_addresses.setter
    def source_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "source_addresses", value)

    @_builtins.property
    @pulumi.getter(name="sourcePorts")
    def source_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The source ports.
        """
        return pulumi.get(self, "source_ports")

    @source_ports.setter
    def source_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "source_ports", value)

    @_builtins.property
    @pulumi.getter(name="sourcePrefixLists")
    def source_prefix_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The source prefix lists.
        """
        return pulumi.get(self, "source_prefix_lists")

    @source_prefix_lists.setter
    def source_prefix_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "source_prefix_lists", value)


if not MYPY:
    class NetworkInsightsAccessScopePathStatementRequestArgsDict(TypedDict):
        packet_header_statement: NotRequired[pulumi.Input['NetworkInsightsAccessScopePacketHeaderStatementRequestArgsDict']]
        """
        The packet header statement.
        """
        resource_statement: NotRequired[pulumi.Input['NetworkInsightsAccessScopeResourceStatementRequestArgsDict']]
        """
        The resource statement.
        """
elif False:
    NetworkInsightsAccessScopePathStatementRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkInsightsAccessScopePathStatementRequestArgs:
    def __init__(__self__, *,
                 packet_header_statement: Optional[pulumi.Input['NetworkInsightsAccessScopePacketHeaderStatementRequestArgs']] = None,
                 resource_statement: Optional[pulumi.Input['NetworkInsightsAccessScopeResourceStatementRequestArgs']] = None):
        """
        :param pulumi.Input['NetworkInsightsAccessScopePacketHeaderStatementRequestArgs'] packet_header_statement: The packet header statement.
        :param pulumi.Input['NetworkInsightsAccessScopeResourceStatementRequestArgs'] resource_statement: The resource statement.
        """
        if packet_header_statement is not None:
            pulumi.set(__self__, "packet_header_statement", packet_header_statement)
        if resource_statement is not None:
            pulumi.set(__self__, "resource_statement", resource_statement)

    @_builtins.property
    @pulumi.getter(name="packetHeaderStatement")
    def packet_header_statement(self) -> Optional[pulumi.Input['NetworkInsightsAccessScopePacketHeaderStatementRequestArgs']]:
        """
        The packet header statement.
        """
        return pulumi.get(self, "packet_header_statement")

    @packet_header_statement.setter
    def packet_header_statement(self, value: Optional[pulumi.Input['NetworkInsightsAccessScopePacketHeaderStatementRequestArgs']]):
        pulumi.set(self, "packet_header_statement", value)

    @_builtins.property
    @pulumi.getter(name="resourceStatement")
    def resource_statement(self) -> Optional[pulumi.Input['NetworkInsightsAccessScopeResourceStatementRequestArgs']]:
        """
        The resource statement.
        """
        return pulumi.get(self, "resource_statement")

    @resource_statement.setter
    def resource_statement(self, value: Optional[pulumi.Input['NetworkInsightsAccessScopeResourceStatementRequestArgs']]):
        pulumi.set(self, "resource_statement", value)


if not MYPY:
    class NetworkInsightsAccessScopeResourceStatementRequestArgsDict(TypedDict):
        resource_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The resource types.
        """
        resources: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The resources.
        """
elif False:
    NetworkInsightsAccessScopeResourceStatementRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkInsightsAccessScopeResourceStatementRequestArgs:
    def __init__(__self__, *,
                 resource_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 resources: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] resource_types: The resource types.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] resources: The resources.
        """
        if resource_types is not None:
            pulumi.set(__self__, "resource_types", resource_types)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter(name="resourceTypes")
    def resource_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The resource types.
        """
        return pulumi.get(self, "resource_types")

    @resource_types.setter
    def resource_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "resource_types", value)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The resources.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "resources", value)


if not MYPY:
    class NetworkInsightsAccessScopeThroughResourcesStatementRequestArgsDict(TypedDict):
        resource_statement: NotRequired[pulumi.Input['NetworkInsightsAccessScopeResourceStatementRequestArgsDict']]
        """
        The resource statement.
        """
elif False:
    NetworkInsightsAccessScopeThroughResourcesStatementRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkInsightsAccessScopeThroughResourcesStatementRequestArgs:
    def __init__(__self__, *,
                 resource_statement: Optional[pulumi.Input['NetworkInsightsAccessScopeResourceStatementRequestArgs']] = None):
        """
        :param pulumi.Input['NetworkInsightsAccessScopeResourceStatementRequestArgs'] resource_statement: The resource statement.
        """
        if resource_statement is not None:
            pulumi.set(__self__, "resource_statement", resource_statement)

    @_builtins.property
    @pulumi.getter(name="resourceStatement")
    def resource_statement(self) -> Optional[pulumi.Input['NetworkInsightsAccessScopeResourceStatementRequestArgs']]:
        """
        The resource statement.
        """
        return pulumi.get(self, "resource_statement")

    @resource_statement.setter
    def resource_statement(self, value: Optional[pulumi.Input['NetworkInsightsAccessScopeResourceStatementRequestArgs']]):
        pulumi.set(self, "resource_statement", value)


if not MYPY:
    class NetworkInsightsPathFilterPortRangeArgsDict(TypedDict):
        from_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The first port in the range.
        """
        to_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The last port in the range.
        """
elif False:
    NetworkInsightsPathFilterPortRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkInsightsPathFilterPortRangeArgs:
    def __init__(__self__, *,
                 from_port: Optional[pulumi.Input[_builtins.int]] = None,
                 to_port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] from_port: The first port in the range.
        :param pulumi.Input[_builtins.int] to_port: The last port in the range.
        """
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The first port in the range.
        """
        return pulumi.get(self, "from_port")

    @from_port.setter
    def from_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "from_port", value)

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The last port in the range.
        """
        return pulumi.get(self, "to_port")

    @to_port.setter
    def to_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "to_port", value)


if not MYPY:
    class NetworkInsightsPathPathFilterArgsDict(TypedDict):
        destination_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The destination IPv4 address.
        """
        destination_port_range: NotRequired[pulumi.Input['NetworkInsightsPathFilterPortRangeArgsDict']]
        """
        The destination port range.
        """
        source_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The source IPv4 address.
        """
        source_port_range: NotRequired[pulumi.Input['NetworkInsightsPathFilterPortRangeArgsDict']]
        """
        The source port range.
        """
elif False:
    NetworkInsightsPathPathFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkInsightsPathPathFilterArgs:
    def __init__(__self__, *,
                 destination_address: Optional[pulumi.Input[_builtins.str]] = None,
                 destination_port_range: Optional[pulumi.Input['NetworkInsightsPathFilterPortRangeArgs']] = None,
                 source_address: Optional[pulumi.Input[_builtins.str]] = None,
                 source_port_range: Optional[pulumi.Input['NetworkInsightsPathFilterPortRangeArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] destination_address: The destination IPv4 address.
        :param pulumi.Input['NetworkInsightsPathFilterPortRangeArgs'] destination_port_range: The destination port range.
        :param pulumi.Input[_builtins.str] source_address: The source IPv4 address.
        :param pulumi.Input['NetworkInsightsPathFilterPortRangeArgs'] source_port_range: The source port range.
        """
        if destination_address is not None:
            pulumi.set(__self__, "destination_address", destination_address)
        if destination_port_range is not None:
            pulumi.set(__self__, "destination_port_range", destination_port_range)
        if source_address is not None:
            pulumi.set(__self__, "source_address", source_address)
        if source_port_range is not None:
            pulumi.set(__self__, "source_port_range", source_port_range)

    @_builtins.property
    @pulumi.getter(name="destinationAddress")
    def destination_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The destination IPv4 address.
        """
        return pulumi.get(self, "destination_address")

    @destination_address.setter
    def destination_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination_address", value)

    @_builtins.property
    @pulumi.getter(name="destinationPortRange")
    def destination_port_range(self) -> Optional[pulumi.Input['NetworkInsightsPathFilterPortRangeArgs']]:
        """
        The destination port range.
        """
        return pulumi.get(self, "destination_port_range")

    @destination_port_range.setter
    def destination_port_range(self, value: Optional[pulumi.Input['NetworkInsightsPathFilterPortRangeArgs']]):
        pulumi.set(self, "destination_port_range", value)

    @_builtins.property
    @pulumi.getter(name="sourceAddress")
    def source_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The source IPv4 address.
        """
        return pulumi.get(self, "source_address")

    @source_address.setter
    def source_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_address", value)

    @_builtins.property
    @pulumi.getter(name="sourcePortRange")
    def source_port_range(self) -> Optional[pulumi.Input['NetworkInsightsPathFilterPortRangeArgs']]:
        """
        The source port range.
        """
        return pulumi.get(self, "source_port_range")

    @source_port_range.setter
    def source_port_range(self, value: Optional[pulumi.Input['NetworkInsightsPathFilterPortRangeArgs']]):
        pulumi.set(self, "source_port_range", value)


if not MYPY:
    class NetworkInterfaceAttachmentEnaSrdSpecificationEnaSrdUdpSpecificationPropertiesArgsDict(TypedDict):
        """
        Configures ENA Express for UDP network traffic.
        """
        ena_srd_udp_enabled: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    NetworkInterfaceAttachmentEnaSrdSpecificationEnaSrdUdpSpecificationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkInterfaceAttachmentEnaSrdSpecificationEnaSrdUdpSpecificationPropertiesArgs:
    def __init__(__self__, *,
                 ena_srd_udp_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        Configures ENA Express for UDP network traffic.
        """
        if ena_srd_udp_enabled is not None:
            pulumi.set(__self__, "ena_srd_udp_enabled", ena_srd_udp_enabled)

    @_builtins.property
    @pulumi.getter(name="enaSrdUdpEnabled")
    def ena_srd_udp_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "ena_srd_udp_enabled")

    @ena_srd_udp_enabled.setter
    def ena_srd_udp_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ena_srd_udp_enabled", value)


if not MYPY:
    class NetworkInterfaceAttachmentEnaSrdSpecificationArgsDict(TypedDict):
        ena_srd_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether ENA Express is enabled for the network interface.
        """
        ena_srd_udp_specification: NotRequired[pulumi.Input['NetworkInterfaceAttachmentEnaSrdSpecificationEnaSrdUdpSpecificationPropertiesArgsDict']]
        """
        Configures ENA Express for UDP network traffic.
        """
elif False:
    NetworkInterfaceAttachmentEnaSrdSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkInterfaceAttachmentEnaSrdSpecificationArgs:
    def __init__(__self__, *,
                 ena_srd_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 ena_srd_udp_specification: Optional[pulumi.Input['NetworkInterfaceAttachmentEnaSrdSpecificationEnaSrdUdpSpecificationPropertiesArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] ena_srd_enabled: Indicates whether ENA Express is enabled for the network interface.
        :param pulumi.Input['NetworkInterfaceAttachmentEnaSrdSpecificationEnaSrdUdpSpecificationPropertiesArgs'] ena_srd_udp_specification: Configures ENA Express for UDP network traffic.
        """
        if ena_srd_enabled is not None:
            pulumi.set(__self__, "ena_srd_enabled", ena_srd_enabled)
        if ena_srd_udp_specification is not None:
            pulumi.set(__self__, "ena_srd_udp_specification", ena_srd_udp_specification)

    @_builtins.property
    @pulumi.getter(name="enaSrdEnabled")
    def ena_srd_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether ENA Express is enabled for the network interface.
        """
        return pulumi.get(self, "ena_srd_enabled")

    @ena_srd_enabled.setter
    def ena_srd_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ena_srd_enabled", value)

    @_builtins.property
    @pulumi.getter(name="enaSrdUdpSpecification")
    def ena_srd_udp_specification(self) -> Optional[pulumi.Input['NetworkInterfaceAttachmentEnaSrdSpecificationEnaSrdUdpSpecificationPropertiesArgs']]:
        """
        Configures ENA Express for UDP network traffic.
        """
        return pulumi.get(self, "ena_srd_udp_specification")

    @ena_srd_udp_specification.setter
    def ena_srd_udp_specification(self, value: Optional[pulumi.Input['NetworkInterfaceAttachmentEnaSrdSpecificationEnaSrdUdpSpecificationPropertiesArgs']]):
        pulumi.set(self, "ena_srd_udp_specification", value)


if not MYPY:
    class NetworkInterfaceConnectionTrackingSpecificationArgsDict(TypedDict):
        tcp_established_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout (in seconds) for idle TCP connections in an established state. Min: 60 seconds. Max: 432000 seconds (5 days). Default: 432000 seconds. Recommended: Less than 432000 seconds.
        """
        udp_stream_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout (in seconds) for idle UDP flows classified as streams which have seen more than one request-response transaction. Min: 60 seconds. Max: 180 seconds (3 minutes). Default: 180 seconds.
        """
        udp_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout (in seconds) for idle UDP flows that have seen traffic only in a single direction or a single request-response transaction. Min: 30 seconds. Max: 60 seconds. Default: 30 seconds.
        """
elif False:
    NetworkInterfaceConnectionTrackingSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkInterfaceConnectionTrackingSpecificationArgs:
    def __init__(__self__, *,
                 tcp_established_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 udp_stream_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 udp_timeout: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] tcp_established_timeout: Timeout (in seconds) for idle TCP connections in an established state. Min: 60 seconds. Max: 432000 seconds (5 days). Default: 432000 seconds. Recommended: Less than 432000 seconds.
        :param pulumi.Input[_builtins.int] udp_stream_timeout: Timeout (in seconds) for idle UDP flows classified as streams which have seen more than one request-response transaction. Min: 60 seconds. Max: 180 seconds (3 minutes). Default: 180 seconds.
        :param pulumi.Input[_builtins.int] udp_timeout: Timeout (in seconds) for idle UDP flows that have seen traffic only in a single direction or a single request-response transaction. Min: 30 seconds. Max: 60 seconds. Default: 30 seconds.
        """
        if tcp_established_timeout is not None:
            pulumi.set(__self__, "tcp_established_timeout", tcp_established_timeout)
        if udp_stream_timeout is not None:
            pulumi.set(__self__, "udp_stream_timeout", udp_stream_timeout)
        if udp_timeout is not None:
            pulumi.set(__self__, "udp_timeout", udp_timeout)

    @_builtins.property
    @pulumi.getter(name="tcpEstablishedTimeout")
    def tcp_established_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout (in seconds) for idle TCP connections in an established state. Min: 60 seconds. Max: 432000 seconds (5 days). Default: 432000 seconds. Recommended: Less than 432000 seconds.
        """
        return pulumi.get(self, "tcp_established_timeout")

    @tcp_established_timeout.setter
    def tcp_established_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "tcp_established_timeout", value)

    @_builtins.property
    @pulumi.getter(name="udpStreamTimeout")
    def udp_stream_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout (in seconds) for idle UDP flows classified as streams which have seen more than one request-response transaction. Min: 60 seconds. Max: 180 seconds (3 minutes). Default: 180 seconds.
        """
        return pulumi.get(self, "udp_stream_timeout")

    @udp_stream_timeout.setter
    def udp_stream_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "udp_stream_timeout", value)

    @_builtins.property
    @pulumi.getter(name="udpTimeout")
    def udp_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout (in seconds) for idle UDP flows that have seen traffic only in a single direction or a single request-response transaction. Min: 30 seconds. Max: 60 seconds. Default: 30 seconds.
        """
        return pulumi.get(self, "udp_timeout")

    @udp_timeout.setter
    def udp_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "udp_timeout", value)


if not MYPY:
    class NetworkInterfaceInstanceIpv6AddressArgsDict(TypedDict):
        ipv6_address: pulumi.Input[_builtins.str]
        """
        An IPv6 address to associate with the network interface.
        """
elif False:
    NetworkInterfaceInstanceIpv6AddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkInterfaceInstanceIpv6AddressArgs:
    def __init__(__self__, *,
                 ipv6_address: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ipv6_address: An IPv6 address to associate with the network interface.
        """
        pulumi.set(__self__, "ipv6_address", ipv6_address)

    @_builtins.property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> pulumi.Input[_builtins.str]:
        """
        An IPv6 address to associate with the network interface.
        """
        return pulumi.get(self, "ipv6_address")

    @ipv6_address.setter
    def ipv6_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ipv6_address", value)


if not MYPY:
    class NetworkInterfaceIpv4PrefixSpecificationArgsDict(TypedDict):
        ipv4_prefix: pulumi.Input[_builtins.str]
        """
        The IPv4 prefix. For information, see [Assigning prefixes to network interfaces](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-prefix-eni.html) in the *Amazon EC2 User Guide* .
        """
elif False:
    NetworkInterfaceIpv4PrefixSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkInterfaceIpv4PrefixSpecificationArgs:
    def __init__(__self__, *,
                 ipv4_prefix: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ipv4_prefix: The IPv4 prefix. For information, see [Assigning prefixes to network interfaces](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-prefix-eni.html) in the *Amazon EC2 User Guide* .
        """
        pulumi.set(__self__, "ipv4_prefix", ipv4_prefix)

    @_builtins.property
    @pulumi.getter(name="ipv4Prefix")
    def ipv4_prefix(self) -> pulumi.Input[_builtins.str]:
        """
        The IPv4 prefix. For information, see [Assigning prefixes to network interfaces](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-prefix-eni.html) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "ipv4_prefix")

    @ipv4_prefix.setter
    def ipv4_prefix(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ipv4_prefix", value)


if not MYPY:
    class NetworkInterfaceIpv6PrefixSpecificationArgsDict(TypedDict):
        ipv6_prefix: pulumi.Input[_builtins.str]
        """
        The IPv6 prefix. For information, see [Assigning prefixes to Amazon EC2 network interfaces](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-prefix-eni.html) in the *Amazon Elastic Compute Cloud User Guide* .
        """
elif False:
    NetworkInterfaceIpv6PrefixSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkInterfaceIpv6PrefixSpecificationArgs:
    def __init__(__self__, *,
                 ipv6_prefix: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ipv6_prefix: The IPv6 prefix. For information, see [Assigning prefixes to Amazon EC2 network interfaces](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-prefix-eni.html) in the *Amazon Elastic Compute Cloud User Guide* .
        """
        pulumi.set(__self__, "ipv6_prefix", ipv6_prefix)

    @_builtins.property
    @pulumi.getter(name="ipv6Prefix")
    def ipv6_prefix(self) -> pulumi.Input[_builtins.str]:
        """
        The IPv6 prefix. For information, see [Assigning prefixes to Amazon EC2 network interfaces](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-prefix-eni.html) in the *Amazon Elastic Compute Cloud User Guide* .
        """
        return pulumi.get(self, "ipv6_prefix")

    @ipv6_prefix.setter
    def ipv6_prefix(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ipv6_prefix", value)


if not MYPY:
    class NetworkInterfacePrivateIpAddressSpecificationArgsDict(TypedDict):
        primary: pulumi.Input[_builtins.bool]
        """
        Sets the private IP address as the primary private address. You can set only one primary private IP address. If you don't specify a primary private IP address, Amazon EC2 automatically assigns a primary private IP address.
        """
        private_ip_address: pulumi.Input[_builtins.str]
        """
        The private IP address of the network interface.
        """
elif False:
    NetworkInterfacePrivateIpAddressSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkInterfacePrivateIpAddressSpecificationArgs:
    def __init__(__self__, *,
                 primary: pulumi.Input[_builtins.bool],
                 private_ip_address: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.bool] primary: Sets the private IP address as the primary private address. You can set only one primary private IP address. If you don't specify a primary private IP address, Amazon EC2 automatically assigns a primary private IP address.
        :param pulumi.Input[_builtins.str] private_ip_address: The private IP address of the network interface.
        """
        pulumi.set(__self__, "primary", primary)
        pulumi.set(__self__, "private_ip_address", private_ip_address)

    @_builtins.property
    @pulumi.getter
    def primary(self) -> pulumi.Input[_builtins.bool]:
        """
        Sets the private IP address as the primary private address. You can set only one primary private IP address. If you don't specify a primary private IP address, Amazon EC2 automatically assigns a primary private IP address.
        """
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "primary", value)

    @_builtins.property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> pulumi.Input[_builtins.str]:
        """
        The private IP address of the network interface.
        """
        return pulumi.get(self, "private_ip_address")

    @private_ip_address.setter
    def private_ip_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "private_ip_address", value)


if not MYPY:
    class OptionsPropertiesArgsDict(TypedDict):
        """
        The options for the transit gateway vpc attachment.
        """
        appliance_mode_support: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates whether to enable Ipv6 Support for Vpc Attachment. Valid Values: enable | disable
        """
        dns_support: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates whether to enable DNS Support for Vpc Attachment. Valid Values: enable | disable
        """
        ipv6_support: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates whether to enable Ipv6 Support for Vpc Attachment. Valid Values: enable | disable
        """
        security_group_referencing_support: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates whether to enable Security Group referencing support for Vpc Attachment. Valid values: enable | disable
        """
elif False:
    OptionsPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OptionsPropertiesArgs:
    def __init__(__self__, *,
                 appliance_mode_support: Optional[pulumi.Input[_builtins.str]] = None,
                 dns_support: Optional[pulumi.Input[_builtins.str]] = None,
                 ipv6_support: Optional[pulumi.Input[_builtins.str]] = None,
                 security_group_referencing_support: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The options for the transit gateway vpc attachment.
        :param pulumi.Input[_builtins.str] appliance_mode_support: Indicates whether to enable Ipv6 Support for Vpc Attachment. Valid Values: enable | disable
        :param pulumi.Input[_builtins.str] dns_support: Indicates whether to enable DNS Support for Vpc Attachment. Valid Values: enable | disable
        :param pulumi.Input[_builtins.str] ipv6_support: Indicates whether to enable Ipv6 Support for Vpc Attachment. Valid Values: enable | disable
        :param pulumi.Input[_builtins.str] security_group_referencing_support: Indicates whether to enable Security Group referencing support for Vpc Attachment. Valid values: enable | disable
        """
        if appliance_mode_support is not None:
            pulumi.set(__self__, "appliance_mode_support", appliance_mode_support)
        if dns_support is not None:
            pulumi.set(__self__, "dns_support", dns_support)
        if ipv6_support is not None:
            pulumi.set(__self__, "ipv6_support", ipv6_support)
        if security_group_referencing_support is not None:
            pulumi.set(__self__, "security_group_referencing_support", security_group_referencing_support)

    @_builtins.property
    @pulumi.getter(name="applianceModeSupport")
    def appliance_mode_support(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates whether to enable Ipv6 Support for Vpc Attachment. Valid Values: enable | disable
        """
        return pulumi.get(self, "appliance_mode_support")

    @appliance_mode_support.setter
    def appliance_mode_support(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "appliance_mode_support", value)

    @_builtins.property
    @pulumi.getter(name="dnsSupport")
    def dns_support(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates whether to enable DNS Support for Vpc Attachment. Valid Values: enable | disable
        """
        return pulumi.get(self, "dns_support")

    @dns_support.setter
    def dns_support(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dns_support", value)

    @_builtins.property
    @pulumi.getter(name="ipv6Support")
    def ipv6_support(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates whether to enable Ipv6 Support for Vpc Attachment. Valid Values: enable | disable
        """
        return pulumi.get(self, "ipv6_support")

    @ipv6_support.setter
    def ipv6_support(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipv6_support", value)

    @_builtins.property
    @pulumi.getter(name="securityGroupReferencingSupport")
    def security_group_referencing_support(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates whether to enable Security Group referencing support for Vpc Attachment. Valid values: enable | disable
        """
        return pulumi.get(self, "security_group_referencing_support")

    @security_group_referencing_support.setter
    def security_group_referencing_support(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "security_group_referencing_support", value)


if not MYPY:
    class PrefixListEntryArgsDict(TypedDict):
        cidr: pulumi.Input[_builtins.str]
        """
        The CIDR block.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description for the entry.

        Constraints: Up to 255 characters in length.
        """
elif False:
    PrefixListEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrefixListEntryArgs:
    def __init__(__self__, *,
                 cidr: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cidr: The CIDR block.
        :param pulumi.Input[_builtins.str] description: A description for the entry.
               
               Constraints: Up to 255 characters in length.
        """
        pulumi.set(__self__, "cidr", cidr)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> pulumi.Input[_builtins.str]:
        """
        The CIDR block.
        """
        return pulumi.get(self, "cidr")

    @cidr.setter
    def cidr(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cidr", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description for the entry.

        Constraints: Up to 255 characters in length.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class PrivateDnsNameOptionsOnLaunchPropertiesArgsDict(TypedDict):
        """
        The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries to the instances should be handled. For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *User Guide*.
         Available options:
          +  EnableResourceNameDnsAAAARecord (true | false)
          +  EnableResourceNameDnsARecord (true | false)
          +  HostnameType (ip-name | resource-name)
        """
        enable_resource_name_dns_a_record: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
        """
        enable_resource_name_dns_aaaa_record: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether to respond to DNS queries for instance hostname with DNS AAAA records.
        """
        hostname_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of hostname for EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID.
        """
elif False:
    PrivateDnsNameOptionsOnLaunchPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivateDnsNameOptionsOnLaunchPropertiesArgs:
    def __init__(__self__, *,
                 enable_resource_name_dns_a_record: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_resource_name_dns_aaaa_record: Optional[pulumi.Input[_builtins.bool]] = None,
                 hostname_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries to the instances should be handled. For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *User Guide*.
         Available options:
          +  EnableResourceNameDnsAAAARecord (true | false)
          +  EnableResourceNameDnsARecord (true | false)
          +  HostnameType (ip-name | resource-name)
        :param pulumi.Input[_builtins.bool] enable_resource_name_dns_a_record: Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
        :param pulumi.Input[_builtins.bool] enable_resource_name_dns_aaaa_record: Indicates whether to respond to DNS queries for instance hostname with DNS AAAA records.
        :param pulumi.Input[_builtins.str] hostname_type: The type of hostname for EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID.
        """
        if enable_resource_name_dns_a_record is not None:
            pulumi.set(__self__, "enable_resource_name_dns_a_record", enable_resource_name_dns_a_record)
        if enable_resource_name_dns_aaaa_record is not None:
            pulumi.set(__self__, "enable_resource_name_dns_aaaa_record", enable_resource_name_dns_aaaa_record)
        if hostname_type is not None:
            pulumi.set(__self__, "hostname_type", hostname_type)

    @_builtins.property
    @pulumi.getter(name="enableResourceNameDnsARecord")
    def enable_resource_name_dns_a_record(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
        """
        return pulumi.get(self, "enable_resource_name_dns_a_record")

    @enable_resource_name_dns_a_record.setter
    def enable_resource_name_dns_a_record(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_resource_name_dns_a_record", value)

    @_builtins.property
    @pulumi.getter(name="enableResourceNameDnsAaaaRecord")
    def enable_resource_name_dns_aaaa_record(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether to respond to DNS queries for instance hostname with DNS AAAA records.
        """
        return pulumi.get(self, "enable_resource_name_dns_aaaa_record")

    @enable_resource_name_dns_aaaa_record.setter
    def enable_resource_name_dns_aaaa_record(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_resource_name_dns_aaaa_record", value)

    @_builtins.property
    @pulumi.getter(name="hostnameType")
    def hostname_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of hostname for EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID.
        """
        return pulumi.get(self, "hostname_type")

    @hostname_type.setter
    def hostname_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hostname_type", value)


if not MYPY:
    class RouteServerPeerBgpOptionsArgsDict(TypedDict):
        """
        BGP Options
        """
        peer_asn: NotRequired[pulumi.Input[_builtins.int]]
        """
        BGP ASN of the Route Server Peer
        """
        peer_liveness_detection: NotRequired[pulumi.Input['RouteServerPeerBgpOptionsPeerLivenessDetection']]
        """
        BGP Liveness Detection
        """
elif False:
    RouteServerPeerBgpOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouteServerPeerBgpOptionsArgs:
    def __init__(__self__, *,
                 peer_asn: Optional[pulumi.Input[_builtins.int]] = None,
                 peer_liveness_detection: Optional[pulumi.Input['RouteServerPeerBgpOptionsPeerLivenessDetection']] = None):
        """
        BGP Options
        :param pulumi.Input[_builtins.int] peer_asn: BGP ASN of the Route Server Peer
        :param pulumi.Input['RouteServerPeerBgpOptionsPeerLivenessDetection'] peer_liveness_detection: BGP Liveness Detection
        """
        if peer_asn is not None:
            pulumi.set(__self__, "peer_asn", peer_asn)
        if peer_liveness_detection is not None:
            pulumi.set(__self__, "peer_liveness_detection", peer_liveness_detection)

    @_builtins.property
    @pulumi.getter(name="peerAsn")
    def peer_asn(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        BGP ASN of the Route Server Peer
        """
        return pulumi.get(self, "peer_asn")

    @peer_asn.setter
    def peer_asn(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "peer_asn", value)

    @_builtins.property
    @pulumi.getter(name="peerLivenessDetection")
    def peer_liveness_detection(self) -> Optional[pulumi.Input['RouteServerPeerBgpOptionsPeerLivenessDetection']]:
        """
        BGP Liveness Detection
        """
        return pulumi.get(self, "peer_liveness_detection")

    @peer_liveness_detection.setter
    def peer_liveness_detection(self, value: Optional[pulumi.Input['RouteServerPeerBgpOptionsPeerLivenessDetection']]):
        pulumi.set(self, "peer_liveness_detection", value)


if not MYPY:
    class SecurityGroupEgressArgsDict(TypedDict):
        ip_protocol: pulumi.Input[_builtins.str]
        """
        The IP protocol name ( `tcp` , `udp` , `icmp` , `icmpv6` ) or number (see [Protocol Numbers](https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml) ).

        Use `-1` to specify all protocols. When authorizing security group rules, specifying `-1` or a protocol number other than `tcp` , `udp` , `icmp` , or `icmpv6` allows traffic on all ports, regardless of any port range you specify. For `tcp` , `udp` , and `icmp` , you must specify a port range. For `icmpv6` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.
        """
        cidr_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IPv4 address range, in CIDR format.

        You must specify exactly one of the following: `CidrIp` , `CidrIpv6` , `DestinationPrefixListId` , or `DestinationSecurityGroupId` .

        For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
        """
        cidr_ipv6: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IPv6 address range, in CIDR format.

        You must specify exactly one of the following: `CidrIp` , `CidrIpv6` , `DestinationPrefixListId` , or `DestinationSecurityGroupId` .

        For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description for the security group rule.

        Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
        """
        destination_prefix_list_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The prefix list IDs for the destination AWS service. This is the AWS service that you want to access through a VPC endpoint from instances associated with the security group.

        You must specify exactly one of the following: `CidrIp` , `CidrIpv6` , `DestinationPrefixListId` , or `DestinationSecurityGroupId` .
        """
        destination_security_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the destination VPC security group.

        You must specify exactly one of the following: `CidrIp` , `CidrIpv6` , `DestinationPrefixListId` , or `DestinationSecurityGroupId` .
        """
        from_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        If the protocol is TCP or UDP, this is the start of the port range. If the protocol is ICMP or ICMPv6, this is the ICMP type or -1 (all ICMP types).
        """
        to_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        If the protocol is TCP or UDP, this is the end of the port range. If the protocol is ICMP or ICMPv6, this is the ICMP code or -1 (all ICMP codes). If the start port is -1 (all ICMP types), then the end port must be -1 (all ICMP codes).
        """
elif False:
    SecurityGroupEgressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityGroupEgressArgs:
    def __init__(__self__, *,
                 ip_protocol: pulumi.Input[_builtins.str],
                 cidr_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 cidr_ipv6: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 destination_prefix_list_id: Optional[pulumi.Input[_builtins.str]] = None,
                 destination_security_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 from_port: Optional[pulumi.Input[_builtins.int]] = None,
                 to_port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] ip_protocol: The IP protocol name ( `tcp` , `udp` , `icmp` , `icmpv6` ) or number (see [Protocol Numbers](https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml) ).
               
               Use `-1` to specify all protocols. When authorizing security group rules, specifying `-1` or a protocol number other than `tcp` , `udp` , `icmp` , or `icmpv6` allows traffic on all ports, regardless of any port range you specify. For `tcp` , `udp` , and `icmp` , you must specify a port range. For `icmpv6` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.
        :param pulumi.Input[_builtins.str] cidr_ip: The IPv4 address range, in CIDR format.
               
               You must specify exactly one of the following: `CidrIp` , `CidrIpv6` , `DestinationPrefixListId` , or `DestinationSecurityGroupId` .
               
               For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
        :param pulumi.Input[_builtins.str] cidr_ipv6: The IPv6 address range, in CIDR format.
               
               You must specify exactly one of the following: `CidrIp` , `CidrIpv6` , `DestinationPrefixListId` , or `DestinationSecurityGroupId` .
               
               For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
        :param pulumi.Input[_builtins.str] description: A description for the security group rule.
               
               Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
        :param pulumi.Input[_builtins.str] destination_prefix_list_id: The prefix list IDs for the destination AWS service. This is the AWS service that you want to access through a VPC endpoint from instances associated with the security group.
               
               You must specify exactly one of the following: `CidrIp` , `CidrIpv6` , `DestinationPrefixListId` , or `DestinationSecurityGroupId` .
        :param pulumi.Input[_builtins.str] destination_security_group_id: The ID of the destination VPC security group.
               
               You must specify exactly one of the following: `CidrIp` , `CidrIpv6` , `DestinationPrefixListId` , or `DestinationSecurityGroupId` .
        :param pulumi.Input[_builtins.int] from_port: If the protocol is TCP or UDP, this is the start of the port range. If the protocol is ICMP or ICMPv6, this is the ICMP type or -1 (all ICMP types).
        :param pulumi.Input[_builtins.int] to_port: If the protocol is TCP or UDP, this is the end of the port range. If the protocol is ICMP or ICMPv6, this is the ICMP code or -1 (all ICMP codes). If the start port is -1 (all ICMP types), then the end port must be -1 (all ICMP codes).
        """
        pulumi.set(__self__, "ip_protocol", ip_protocol)
        if cidr_ip is not None:
            pulumi.set(__self__, "cidr_ip", cidr_ip)
        if cidr_ipv6 is not None:
            pulumi.set(__self__, "cidr_ipv6", cidr_ipv6)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destination_prefix_list_id is not None:
            pulumi.set(__self__, "destination_prefix_list_id", destination_prefix_list_id)
        if destination_security_group_id is not None:
            pulumi.set(__self__, "destination_security_group_id", destination_security_group_id)
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)

    @_builtins.property
    @pulumi.getter(name="ipProtocol")
    def ip_protocol(self) -> pulumi.Input[_builtins.str]:
        """
        The IP protocol name ( `tcp` , `udp` , `icmp` , `icmpv6` ) or number (see [Protocol Numbers](https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml) ).

        Use `-1` to specify all protocols. When authorizing security group rules, specifying `-1` or a protocol number other than `tcp` , `udp` , `icmp` , or `icmpv6` allows traffic on all ports, regardless of any port range you specify. For `tcp` , `udp` , and `icmp` , you must specify a port range. For `icmpv6` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.
        """
        return pulumi.get(self, "ip_protocol")

    @ip_protocol.setter
    def ip_protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip_protocol", value)

    @_builtins.property
    @pulumi.getter(name="cidrIp")
    def cidr_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IPv4 address range, in CIDR format.

        You must specify exactly one of the following: `CidrIp` , `CidrIpv6` , `DestinationPrefixListId` , or `DestinationSecurityGroupId` .

        For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "cidr_ip")

    @cidr_ip.setter
    def cidr_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cidr_ip", value)

    @_builtins.property
    @pulumi.getter(name="cidrIpv6")
    def cidr_ipv6(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IPv6 address range, in CIDR format.

        You must specify exactly one of the following: `CidrIp` , `CidrIpv6` , `DestinationPrefixListId` , or `DestinationSecurityGroupId` .

        For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "cidr_ipv6")

    @cidr_ipv6.setter
    def cidr_ipv6(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cidr_ipv6", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description for the security group rule.

        Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="destinationPrefixListId")
    def destination_prefix_list_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The prefix list IDs for the destination AWS service. This is the AWS service that you want to access through a VPC endpoint from instances associated with the security group.

        You must specify exactly one of the following: `CidrIp` , `CidrIpv6` , `DestinationPrefixListId` , or `DestinationSecurityGroupId` .
        """
        return pulumi.get(self, "destination_prefix_list_id")

    @destination_prefix_list_id.setter
    def destination_prefix_list_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination_prefix_list_id", value)

    @_builtins.property
    @pulumi.getter(name="destinationSecurityGroupId")
    def destination_security_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the destination VPC security group.

        You must specify exactly one of the following: `CidrIp` , `CidrIpv6` , `DestinationPrefixListId` , or `DestinationSecurityGroupId` .
        """
        return pulumi.get(self, "destination_security_group_id")

    @destination_security_group_id.setter
    def destination_security_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination_security_group_id", value)

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        If the protocol is TCP or UDP, this is the start of the port range. If the protocol is ICMP or ICMPv6, this is the ICMP type or -1 (all ICMP types).
        """
        return pulumi.get(self, "from_port")

    @from_port.setter
    def from_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "from_port", value)

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        If the protocol is TCP or UDP, this is the end of the port range. If the protocol is ICMP or ICMPv6, this is the ICMP code or -1 (all ICMP codes). If the start port is -1 (all ICMP types), then the end port must be -1 (all ICMP codes).
        """
        return pulumi.get(self, "to_port")

    @to_port.setter
    def to_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "to_port", value)


if not MYPY:
    class SecurityGroupIngressArgsDict(TypedDict):
        ip_protocol: pulumi.Input[_builtins.str]
        """
        The IP protocol name ( `tcp` , `udp` , `icmp` , `icmpv6` ) or number (see [Protocol Numbers](https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml) ).

        Use `-1` to specify all protocols. When authorizing security group rules, specifying `-1` or a protocol number other than `tcp` , `udp` , `icmp` , or `icmpv6` allows traffic on all ports, regardless of any port range you specify. For `tcp` , `udp` , and `icmp` , you must specify a port range. For `icmpv6` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.
        """
        cidr_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IPv4 address range, in CIDR format.

        You must specify exactly one of the following: `CidrIp` , `CidrIpv6` , `SourcePrefixListId` , or `SourceSecurityGroupId` .

        For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
        """
        cidr_ipv6: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IPv6 address range, in CIDR format.

        You must specify exactly one of the following: `CidrIp` , `CidrIpv6` , `SourcePrefixListId` , or `SourceSecurityGroupId` .

        For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updates the description of an ingress (inbound) security group rule. You can replace an existing description, or add a description to a rule that did not have one previously.

        Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
        """
        from_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        If the protocol is TCP or UDP, this is the start of the port range. If the protocol is ICMP or ICMPv6, this is the ICMP type or -1 (all ICMP types).
        """
        source_prefix_list_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of a prefix list.
        """
        source_security_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the security group.
        """
        source_security_group_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        [Default VPC] The name of the source security group. You must specify either the security group ID or the security group name. You can't specify the group name in combination with an IP address range. Creates rules that grant full ICMP, UDP, and TCP access.

        For security groups in a nondefault VPC, you must specify the group ID.
        """
        source_security_group_owner_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        [nondefault VPC] The AWS account ID for the source security group, if the source security group is in a different account. You can't specify this property with an IP address range. Creates rules that grant full ICMP, UDP, and TCP access.

        If you specify `SourceSecurityGroupName` or `SourceSecurityGroupId` and that security group is owned by a different account than the account creating the stack, you must specify the `SourceSecurityGroupOwnerId` ; otherwise, this property is optional.
        """
        to_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        If the protocol is TCP or UDP, this is the end of the port range. If the protocol is ICMP or ICMPv6, this is the ICMP code or -1 (all ICMP codes). If the start port is -1 (all ICMP types), then the end port must be -1 (all ICMP codes).
        """
elif False:
    SecurityGroupIngressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityGroupIngressArgs:
    def __init__(__self__, *,
                 ip_protocol: pulumi.Input[_builtins.str],
                 cidr_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 cidr_ipv6: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 from_port: Optional[pulumi.Input[_builtins.int]] = None,
                 source_prefix_list_id: Optional[pulumi.Input[_builtins.str]] = None,
                 source_security_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 source_security_group_name: Optional[pulumi.Input[_builtins.str]] = None,
                 source_security_group_owner_id: Optional[pulumi.Input[_builtins.str]] = None,
                 to_port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] ip_protocol: The IP protocol name ( `tcp` , `udp` , `icmp` , `icmpv6` ) or number (see [Protocol Numbers](https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml) ).
               
               Use `-1` to specify all protocols. When authorizing security group rules, specifying `-1` or a protocol number other than `tcp` , `udp` , `icmp` , or `icmpv6` allows traffic on all ports, regardless of any port range you specify. For `tcp` , `udp` , and `icmp` , you must specify a port range. For `icmpv6` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.
        :param pulumi.Input[_builtins.str] cidr_ip: The IPv4 address range, in CIDR format.
               
               You must specify exactly one of the following: `CidrIp` , `CidrIpv6` , `SourcePrefixListId` , or `SourceSecurityGroupId` .
               
               For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
        :param pulumi.Input[_builtins.str] cidr_ipv6: The IPv6 address range, in CIDR format.
               
               You must specify exactly one of the following: `CidrIp` , `CidrIpv6` , `SourcePrefixListId` , or `SourceSecurityGroupId` .
               
               For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
        :param pulumi.Input[_builtins.str] description: Updates the description of an ingress (inbound) security group rule. You can replace an existing description, or add a description to a rule that did not have one previously.
               
               Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
        :param pulumi.Input[_builtins.int] from_port: If the protocol is TCP or UDP, this is the start of the port range. If the protocol is ICMP or ICMPv6, this is the ICMP type or -1 (all ICMP types).
        :param pulumi.Input[_builtins.str] source_prefix_list_id: The ID of a prefix list.
        :param pulumi.Input[_builtins.str] source_security_group_id: The ID of the security group.
        :param pulumi.Input[_builtins.str] source_security_group_name: [Default VPC] The name of the source security group. You must specify either the security group ID or the security group name. You can't specify the group name in combination with an IP address range. Creates rules that grant full ICMP, UDP, and TCP access.
               
               For security groups in a nondefault VPC, you must specify the group ID.
        :param pulumi.Input[_builtins.str] source_security_group_owner_id: [nondefault VPC] The AWS account ID for the source security group, if the source security group is in a different account. You can't specify this property with an IP address range. Creates rules that grant full ICMP, UDP, and TCP access.
               
               If you specify `SourceSecurityGroupName` or `SourceSecurityGroupId` and that security group is owned by a different account than the account creating the stack, you must specify the `SourceSecurityGroupOwnerId` ; otherwise, this property is optional.
        :param pulumi.Input[_builtins.int] to_port: If the protocol is TCP or UDP, this is the end of the port range. If the protocol is ICMP or ICMPv6, this is the ICMP code or -1 (all ICMP codes). If the start port is -1 (all ICMP types), then the end port must be -1 (all ICMP codes).
        """
        pulumi.set(__self__, "ip_protocol", ip_protocol)
        if cidr_ip is not None:
            pulumi.set(__self__, "cidr_ip", cidr_ip)
        if cidr_ipv6 is not None:
            pulumi.set(__self__, "cidr_ipv6", cidr_ipv6)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if source_prefix_list_id is not None:
            pulumi.set(__self__, "source_prefix_list_id", source_prefix_list_id)
        if source_security_group_id is not None:
            pulumi.set(__self__, "source_security_group_id", source_security_group_id)
        if source_security_group_name is not None:
            pulumi.set(__self__, "source_security_group_name", source_security_group_name)
        if source_security_group_owner_id is not None:
            pulumi.set(__self__, "source_security_group_owner_id", source_security_group_owner_id)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)

    @_builtins.property
    @pulumi.getter(name="ipProtocol")
    def ip_protocol(self) -> pulumi.Input[_builtins.str]:
        """
        The IP protocol name ( `tcp` , `udp` , `icmp` , `icmpv6` ) or number (see [Protocol Numbers](https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml) ).

        Use `-1` to specify all protocols. When authorizing security group rules, specifying `-1` or a protocol number other than `tcp` , `udp` , `icmp` , or `icmpv6` allows traffic on all ports, regardless of any port range you specify. For `tcp` , `udp` , and `icmp` , you must specify a port range. For `icmpv6` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.
        """
        return pulumi.get(self, "ip_protocol")

    @ip_protocol.setter
    def ip_protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip_protocol", value)

    @_builtins.property
    @pulumi.getter(name="cidrIp")
    def cidr_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IPv4 address range, in CIDR format.

        You must specify exactly one of the following: `CidrIp` , `CidrIpv6` , `SourcePrefixListId` , or `SourceSecurityGroupId` .

        For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "cidr_ip")

    @cidr_ip.setter
    def cidr_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cidr_ip", value)

    @_builtins.property
    @pulumi.getter(name="cidrIpv6")
    def cidr_ipv6(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IPv6 address range, in CIDR format.

        You must specify exactly one of the following: `CidrIp` , `CidrIpv6` , `SourcePrefixListId` , or `SourceSecurityGroupId` .

        For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "cidr_ipv6")

    @cidr_ipv6.setter
    def cidr_ipv6(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cidr_ipv6", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updates the description of an ingress (inbound) security group rule. You can replace an existing description, or add a description to a rule that did not have one previously.

        Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        If the protocol is TCP or UDP, this is the start of the port range. If the protocol is ICMP or ICMPv6, this is the ICMP type or -1 (all ICMP types).
        """
        return pulumi.get(self, "from_port")

    @from_port.setter
    def from_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "from_port", value)

    @_builtins.property
    @pulumi.getter(name="sourcePrefixListId")
    def source_prefix_list_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of a prefix list.
        """
        return pulumi.get(self, "source_prefix_list_id")

    @source_prefix_list_id.setter
    def source_prefix_list_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_prefix_list_id", value)

    @_builtins.property
    @pulumi.getter(name="sourceSecurityGroupId")
    def source_security_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the security group.
        """
        return pulumi.get(self, "source_security_group_id")

    @source_security_group_id.setter
    def source_security_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_security_group_id", value)

    @_builtins.property
    @pulumi.getter(name="sourceSecurityGroupName")
    def source_security_group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        [Default VPC] The name of the source security group. You must specify either the security group ID or the security group name. You can't specify the group name in combination with an IP address range. Creates rules that grant full ICMP, UDP, and TCP access.

        For security groups in a nondefault VPC, you must specify the group ID.
        """
        return pulumi.get(self, "source_security_group_name")

    @source_security_group_name.setter
    def source_security_group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_security_group_name", value)

    @_builtins.property
    @pulumi.getter(name="sourceSecurityGroupOwnerId")
    def source_security_group_owner_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        [nondefault VPC] The AWS account ID for the source security group, if the source security group is in a different account. You can't specify this property with an IP address range. Creates rules that grant full ICMP, UDP, and TCP access.

        If you specify `SourceSecurityGroupName` or `SourceSecurityGroupId` and that security group is owned by a different account than the account creating the stack, you must specify the `SourceSecurityGroupOwnerId` ; otherwise, this property is optional.
        """
        return pulumi.get(self, "source_security_group_owner_id")

    @source_security_group_owner_id.setter
    def source_security_group_owner_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_security_group_owner_id", value)

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        If the protocol is TCP or UDP, this is the end of the port range. If the protocol is ICMP or ICMPv6, this is the ICMP code or -1 (all ICMP codes). If the start port is -1 (all ICMP types), then the end port must be -1 (all ICMP codes).
        """
        return pulumi.get(self, "to_port")

    @to_port.setter
    def to_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "to_port", value)


if not MYPY:
    class SpotFleetAcceleratorCountRequestArgsDict(TypedDict):
        max: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum number of accelerators. To specify no maximum limit, omit this parameter. To exclude accelerator-enabled instance types, set `Max` to `0` .
        """
        min: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum number of accelerators. To specify no minimum limit, omit this parameter.
        """
elif False:
    SpotFleetAcceleratorCountRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpotFleetAcceleratorCountRequestArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[_builtins.int]] = None,
                 min: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] max: The maximum number of accelerators. To specify no maximum limit, omit this parameter. To exclude accelerator-enabled instance types, set `Max` to `0` .
        :param pulumi.Input[_builtins.int] min: The minimum number of accelerators. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum number of accelerators. To specify no maximum limit, omit this parameter. To exclude accelerator-enabled instance types, set `Max` to `0` .
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum number of accelerators. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class SpotFleetAcceleratorTotalMemoryMiBRequestArgsDict(TypedDict):
        max: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum amount of accelerator memory, in MiB. To specify no maximum limit, omit this parameter.
        """
        min: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum amount of accelerator memory, in MiB. To specify no minimum limit, omit this parameter.
        """
elif False:
    SpotFleetAcceleratorTotalMemoryMiBRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpotFleetAcceleratorTotalMemoryMiBRequestArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[_builtins.int]] = None,
                 min: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] max: The maximum amount of accelerator memory, in MiB. To specify no maximum limit, omit this parameter.
        :param pulumi.Input[_builtins.int] min: The minimum amount of accelerator memory, in MiB. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum amount of accelerator memory, in MiB. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum amount of accelerator memory, in MiB. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class SpotFleetBaselineEbsBandwidthMbpsRequestArgsDict(TypedDict):
        max: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum baseline bandwidth, in Mbps. To specify no maximum limit, omit this parameter.
        """
        min: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum baseline bandwidth, in Mbps. To specify no minimum limit, omit this parameter.
        """
elif False:
    SpotFleetBaselineEbsBandwidthMbpsRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpotFleetBaselineEbsBandwidthMbpsRequestArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[_builtins.int]] = None,
                 min: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] max: The maximum baseline bandwidth, in Mbps. To specify no maximum limit, omit this parameter.
        :param pulumi.Input[_builtins.int] min: The minimum baseline bandwidth, in Mbps. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum baseline bandwidth, in Mbps. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum baseline bandwidth, in Mbps. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class SpotFleetBaselinePerformanceFactorsRequestArgsDict(TypedDict):
        cpu: NotRequired[pulumi.Input['SpotFleetCpuPerformanceFactorRequestArgsDict']]
        """
        The CPU performance to consider, using an instance family as the baseline reference.
        """
elif False:
    SpotFleetBaselinePerformanceFactorsRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpotFleetBaselinePerformanceFactorsRequestArgs:
    def __init__(__self__, *,
                 cpu: Optional[pulumi.Input['SpotFleetCpuPerformanceFactorRequestArgs']] = None):
        """
        :param pulumi.Input['SpotFleetCpuPerformanceFactorRequestArgs'] cpu: The CPU performance to consider, using an instance family as the baseline reference.
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input['SpotFleetCpuPerformanceFactorRequestArgs']]:
        """
        The CPU performance to consider, using an instance family as the baseline reference.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input['SpotFleetCpuPerformanceFactorRequestArgs']]):
        pulumi.set(self, "cpu", value)


if not MYPY:
    class SpotFleetBlockDeviceMappingArgsDict(TypedDict):
        device_name: pulumi.Input[_builtins.str]
        """
        The device name. For available device names, see [Device names for volumes](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/device_naming.html) .
        """
        ebs: NotRequired[pulumi.Input['SpotFleetEbsBlockDeviceArgsDict']]
        """
        Parameters used to automatically set up EBS volumes when the instance is launched.
        """
        no_device: NotRequired[pulumi.Input[_builtins.str]]
        """
        To omit the device from the block device mapping, specify an empty string. When this property is specified, the device is removed from the block device mapping regardless of the assigned value.
        """
        virtual_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The virtual device name ( `ephemeral` N). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for `ephemeral0` and `ephemeral1` . The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.

        NVMe instance store volumes are automatically enumerated and assigned a device name. Including them in your block device mapping has no effect.

        Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.
        """
elif False:
    SpotFleetBlockDeviceMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpotFleetBlockDeviceMappingArgs:
    def __init__(__self__, *,
                 device_name: pulumi.Input[_builtins.str],
                 ebs: Optional[pulumi.Input['SpotFleetEbsBlockDeviceArgs']] = None,
                 no_device: Optional[pulumi.Input[_builtins.str]] = None,
                 virtual_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] device_name: The device name. For available device names, see [Device names for volumes](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/device_naming.html) .
        :param pulumi.Input['SpotFleetEbsBlockDeviceArgs'] ebs: Parameters used to automatically set up EBS volumes when the instance is launched.
        :param pulumi.Input[_builtins.str] no_device: To omit the device from the block device mapping, specify an empty string. When this property is specified, the device is removed from the block device mapping regardless of the assigned value.
        :param pulumi.Input[_builtins.str] virtual_name: The virtual device name ( `ephemeral` N). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for `ephemeral0` and `ephemeral1` . The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.
               
               NVMe instance store volumes are automatically enumerated and assigned a device name. Including them in your block device mapping has no effect.
               
               Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.
        """
        pulumi.set(__self__, "device_name", device_name)
        if ebs is not None:
            pulumi.set(__self__, "ebs", ebs)
        if no_device is not None:
            pulumi.set(__self__, "no_device", no_device)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> pulumi.Input[_builtins.str]:
        """
        The device name. For available device names, see [Device names for volumes](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/device_naming.html) .
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "device_name", value)

    @_builtins.property
    @pulumi.getter
    def ebs(self) -> Optional[pulumi.Input['SpotFleetEbsBlockDeviceArgs']]:
        """
        Parameters used to automatically set up EBS volumes when the instance is launched.
        """
        return pulumi.get(self, "ebs")

    @ebs.setter
    def ebs(self, value: Optional[pulumi.Input['SpotFleetEbsBlockDeviceArgs']]):
        pulumi.set(self, "ebs", value)

    @_builtins.property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        To omit the device from the block device mapping, specify an empty string. When this property is specified, the device is removed from the block device mapping regardless of the assigned value.
        """
        return pulumi.get(self, "no_device")

    @no_device.setter
    def no_device(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "no_device", value)

    @_builtins.property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The virtual device name ( `ephemeral` N). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for `ephemeral0` and `ephemeral1` . The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.

        NVMe instance store volumes are automatically enumerated and assigned a device name. Including them in your block device mapping has no effect.

        Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.
        """
        return pulumi.get(self, "virtual_name")

    @virtual_name.setter
    def virtual_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "virtual_name", value)


if not MYPY:
    class SpotFleetClassicLoadBalancersConfigArgsDict(TypedDict):
        classic_load_balancers: pulumi.Input[Sequence[pulumi.Input['SpotFleetClassicLoadBalancerArgsDict']]]
        """
        One or more Classic Load Balancers.
        """
elif False:
    SpotFleetClassicLoadBalancersConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpotFleetClassicLoadBalancersConfigArgs:
    def __init__(__self__, *,
                 classic_load_balancers: pulumi.Input[Sequence[pulumi.Input['SpotFleetClassicLoadBalancerArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SpotFleetClassicLoadBalancerArgs']]] classic_load_balancers: One or more Classic Load Balancers.
        """
        pulumi.set(__self__, "classic_load_balancers", classic_load_balancers)

    @_builtins.property
    @pulumi.getter(name="classicLoadBalancers")
    def classic_load_balancers(self) -> pulumi.Input[Sequence[pulumi.Input['SpotFleetClassicLoadBalancerArgs']]]:
        """
        One or more Classic Load Balancers.
        """
        return pulumi.get(self, "classic_load_balancers")

    @classic_load_balancers.setter
    def classic_load_balancers(self, value: pulumi.Input[Sequence[pulumi.Input['SpotFleetClassicLoadBalancerArgs']]]):
        pulumi.set(self, "classic_load_balancers", value)


if not MYPY:
    class SpotFleetClassicLoadBalancerArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of the load balancer.
        """
elif False:
    SpotFleetClassicLoadBalancerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpotFleetClassicLoadBalancerArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: The name of the load balancer.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the load balancer.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class SpotFleetCpuPerformanceFactorRequestArgsDict(TypedDict):
        references: NotRequired[pulumi.Input[Sequence[pulumi.Input['SpotFleetPerformanceFactorReferenceRequestArgsDict']]]]
        """
        Specify an instance family to use as the baseline reference for CPU performance. All instance types that match your specified attributes will be compared against the CPU performance of the referenced instance family, regardless of CPU manufacturer or architecture differences.

        > Currently, only one instance family can be specified in the list.
        """
elif False:
    SpotFleetCpuPerformanceFactorRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpotFleetCpuPerformanceFactorRequestArgs:
    def __init__(__self__, *,
                 references: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetPerformanceFactorReferenceRequestArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SpotFleetPerformanceFactorReferenceRequestArgs']]] references: Specify an instance family to use as the baseline reference for CPU performance. All instance types that match your specified attributes will be compared against the CPU performance of the referenced instance family, regardless of CPU manufacturer or architecture differences.
               
               > Currently, only one instance family can be specified in the list.
        """
        if references is not None:
            pulumi.set(__self__, "references", references)

    @_builtins.property
    @pulumi.getter
    def references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetPerformanceFactorReferenceRequestArgs']]]]:
        """
        Specify an instance family to use as the baseline reference for CPU performance. All instance types that match your specified attributes will be compared against the CPU performance of the referenced instance family, regardless of CPU manufacturer or architecture differences.

        > Currently, only one instance family can be specified in the list.
        """
        return pulumi.get(self, "references")

    @references.setter
    def references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetPerformanceFactorReferenceRequestArgs']]]]):
        pulumi.set(self, "references", value)


if not MYPY:
    class SpotFleetEbsBlockDeviceArgsDict(TypedDict):
        delete_on_termination: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the EBS volume is deleted on instance termination. For more information, see [Preserving Amazon EBS volumes on instance termination](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination) in the *Amazon EC2 User Guide* .
        """
        encrypted: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the encryption state of an EBS volume is changed while being restored from a backing snapshot. The effect of setting the encryption state to `true` depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see [Amazon EBS Encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-parameters) in the *Amazon EC2 User Guide* .

        In no case can you remove encryption from an encrypted volume.

        Encrypted volumes can only be attached to instances that support Amazon EBS encryption. For more information, see [Supported Instance Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances) .

        This parameter is not returned by [DescribeImageAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImageAttribute.html) .
        """
        iops: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of I/O operations per second (IOPS). For `gp3` , `io1` , and `io2` volumes, this represents the number of IOPS that are provisioned for the volume. For `gp2` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.

        The following are the supported values for each volume type:

        - `gp3` : 3,000 - 80,000 IOPS
        - `io1` : 100 - 64,000 IOPS
        - `io2` : 100 - 256,000 IOPS

        For `io2` volumes, you can achieve up to 256,000 IOPS on [instances built on the Nitro System](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances) . On other instances, you can achieve performance up to 32,000 IOPS.

        This parameter is required for `io1` and `io2` volumes. The default for `gp3` volumes is 3,000 IOPS.
        """
        snapshot_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the snapshot.
        """
        volume_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size.

        The following are the supported sizes for each volume type:

        - `gp2` : 1 - 16,384 GiB
        - `gp3` : 1 - 65,536 GiB
        - `io1` : 4 - 16,384 GiB
        - `io2` : 4 - 65,536 GiB
        - `st1` and `sc1` : 125 - 16,384 GiB
        - `standard` : 1 - 1024 GiB
        """
        volume_type: NotRequired[pulumi.Input['SpotFleetEbsBlockDeviceVolumeType']]
        """
        The volume type. For more information, see [Amazon EBS volume types](https://docs.aws.amazon.com/ebs/latest/userguide/ebs-volume-types.html) in the *Amazon EBS User Guide* .
        """
elif False:
    SpotFleetEbsBlockDeviceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpotFleetEbsBlockDeviceArgs:
    def __init__(__self__, *,
                 delete_on_termination: Optional[pulumi.Input[_builtins.bool]] = None,
                 encrypted: Optional[pulumi.Input[_builtins.bool]] = None,
                 iops: Optional[pulumi.Input[_builtins.int]] = None,
                 snapshot_id: Optional[pulumi.Input[_builtins.str]] = None,
                 volume_size: Optional[pulumi.Input[_builtins.int]] = None,
                 volume_type: Optional[pulumi.Input['SpotFleetEbsBlockDeviceVolumeType']] = None):
        """
        :param pulumi.Input[_builtins.bool] delete_on_termination: Indicates whether the EBS volume is deleted on instance termination. For more information, see [Preserving Amazon EBS volumes on instance termination](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination) in the *Amazon EC2 User Guide* .
        :param pulumi.Input[_builtins.bool] encrypted: Indicates whether the encryption state of an EBS volume is changed while being restored from a backing snapshot. The effect of setting the encryption state to `true` depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see [Amazon EBS Encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-parameters) in the *Amazon EC2 User Guide* .
               
               In no case can you remove encryption from an encrypted volume.
               
               Encrypted volumes can only be attached to instances that support Amazon EBS encryption. For more information, see [Supported Instance Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances) .
               
               This parameter is not returned by [DescribeImageAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImageAttribute.html) .
        :param pulumi.Input[_builtins.int] iops: The number of I/O operations per second (IOPS). For `gp3` , `io1` , and `io2` volumes, this represents the number of IOPS that are provisioned for the volume. For `gp2` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.
               
               The following are the supported values for each volume type:
               
               - `gp3` : 3,000 - 80,000 IOPS
               - `io1` : 100 - 64,000 IOPS
               - `io2` : 100 - 256,000 IOPS
               
               For `io2` volumes, you can achieve up to 256,000 IOPS on [instances built on the Nitro System](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances) . On other instances, you can achieve performance up to 32,000 IOPS.
               
               This parameter is required for `io1` and `io2` volumes. The default for `gp3` volumes is 3,000 IOPS.
        :param pulumi.Input[_builtins.str] snapshot_id: The ID of the snapshot.
        :param pulumi.Input[_builtins.int] volume_size: The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size.
               
               The following are the supported sizes for each volume type:
               
               - `gp2` : 1 - 16,384 GiB
               - `gp3` : 1 - 65,536 GiB
               - `io1` : 4 - 16,384 GiB
               - `io2` : 4 - 65,536 GiB
               - `st1` and `sc1` : 125 - 16,384 GiB
               - `standard` : 1 - 1024 GiB
        :param pulumi.Input['SpotFleetEbsBlockDeviceVolumeType'] volume_type: The volume type. For more information, see [Amazon EBS volume types](https://docs.aws.amazon.com/ebs/latest/userguide/ebs-volume-types.html) in the *Amazon EBS User Guide* .
        """
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the EBS volume is deleted on instance termination. For more information, see [Preserving Amazon EBS volumes on instance termination](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "delete_on_termination")

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "delete_on_termination", value)

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the encryption state of an EBS volume is changed while being restored from a backing snapshot. The effect of setting the encryption state to `true` depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see [Amazon EBS Encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-parameters) in the *Amazon EC2 User Guide* .

        In no case can you remove encryption from an encrypted volume.

        Encrypted volumes can only be attached to instances that support Amazon EBS encryption. For more information, see [Supported Instance Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances) .

        This parameter is not returned by [DescribeImageAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImageAttribute.html) .
        """
        return pulumi.get(self, "encrypted")

    @encrypted.setter
    def encrypted(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "encrypted", value)

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of I/O operations per second (IOPS). For `gp3` , `io1` , and `io2` volumes, this represents the number of IOPS that are provisioned for the volume. For `gp2` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.

        The following are the supported values for each volume type:

        - `gp3` : 3,000 - 80,000 IOPS
        - `io1` : 100 - 64,000 IOPS
        - `io2` : 100 - 256,000 IOPS

        For `io2` volumes, you can achieve up to 256,000 IOPS on [instances built on the Nitro System](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances) . On other instances, you can achieve performance up to 32,000 IOPS.

        This parameter is required for `io1` and `io2` volumes. The default for `gp3` volumes is 3,000 IOPS.
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "iops", value)

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the snapshot.
        """
        return pulumi.get(self, "snapshot_id")

    @snapshot_id.setter
    def snapshot_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "snapshot_id", value)

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size.

        The following are the supported sizes for each volume type:

        - `gp2` : 1 - 16,384 GiB
        - `gp3` : 1 - 65,536 GiB
        - `io1` : 4 - 16,384 GiB
        - `io2` : 4 - 65,536 GiB
        - `st1` and `sc1` : 125 - 16,384 GiB
        - `standard` : 1 - 1024 GiB
        """
        return pulumi.get(self, "volume_size")

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "volume_size", value)

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input['SpotFleetEbsBlockDeviceVolumeType']]:
        """
        The volume type. For more information, see [Amazon EBS volume types](https://docs.aws.amazon.com/ebs/latest/userguide/ebs-volume-types.html) in the *Amazon EBS User Guide* .
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input['SpotFleetEbsBlockDeviceVolumeType']]):
        pulumi.set(self, "volume_type", value)


if not MYPY:
    class SpotFleetFleetLaunchTemplateSpecificationArgsDict(TypedDict):
        version: pulumi.Input[_builtins.str]
        """
        The version number of the launch template.

        Specifying `$Latest` or `$Default` for the template version number is not supported. However, you can specify `LatestVersionNumber` or `DefaultVersionNumber` using the `Fn::GetAtt` intrinsic function. For more information, see [Fn::GetAtt](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#aws-resource-ec2-launchtemplate-return-values-fn--getatt) .
        """
        launch_template_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the launch template.

        You must specify the `LaunchTemplateId` or the `LaunchTemplateName` , but not both.
        """
        launch_template_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the launch template.

        You must specify the `LaunchTemplateName` or the `LaunchTemplateId` , but not both.
        """
elif False:
    SpotFleetFleetLaunchTemplateSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpotFleetFleetLaunchTemplateSpecificationArgs:
    def __init__(__self__, *,
                 version: pulumi.Input[_builtins.str],
                 launch_template_id: Optional[pulumi.Input[_builtins.str]] = None,
                 launch_template_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] version: The version number of the launch template.
               
               Specifying `$Latest` or `$Default` for the template version number is not supported. However, you can specify `LatestVersionNumber` or `DefaultVersionNumber` using the `Fn::GetAtt` intrinsic function. For more information, see [Fn::GetAtt](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#aws-resource-ec2-launchtemplate-return-values-fn--getatt) .
        :param pulumi.Input[_builtins.str] launch_template_id: The ID of the launch template.
               
               You must specify the `LaunchTemplateId` or the `LaunchTemplateName` , but not both.
        :param pulumi.Input[_builtins.str] launch_template_name: The name of the launch template.
               
               You must specify the `LaunchTemplateName` or the `LaunchTemplateId` , but not both.
        """
        pulumi.set(__self__, "version", version)
        if launch_template_id is not None:
            pulumi.set(__self__, "launch_template_id", launch_template_id)
        if launch_template_name is not None:
            pulumi.set(__self__, "launch_template_name", launch_template_name)

    @_builtins.property
    @pulumi.getter
    def version(self) -> pulumi.Input[_builtins.str]:
        """
        The version number of the launch template.

        Specifying `$Latest` or `$Default` for the template version number is not supported. However, you can specify `LatestVersionNumber` or `DefaultVersionNumber` using the `Fn::GetAtt` intrinsic function. For more information, see [Fn::GetAtt](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#aws-resource-ec2-launchtemplate-return-values-fn--getatt) .
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "version", value)

    @_builtins.property
    @pulumi.getter(name="launchTemplateId")
    def launch_template_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the launch template.

        You must specify the `LaunchTemplateId` or the `LaunchTemplateName` , but not both.
        """
        return pulumi.get(self, "launch_template_id")

    @launch_template_id.setter
    def launch_template_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "launch_template_id", value)

    @_builtins.property
    @pulumi.getter(name="launchTemplateName")
    def launch_template_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the launch template.

        You must specify the `LaunchTemplateName` or the `LaunchTemplateId` , but not both.
        """
        return pulumi.get(self, "launch_template_name")

    @launch_template_name.setter
    def launch_template_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "launch_template_name", value)


if not MYPY:
    class SpotFleetGroupIdentifierArgsDict(TypedDict):
        group_id: pulumi.Input[_builtins.str]
        """
        The ID of the security group.
        """
elif False:
    SpotFleetGroupIdentifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpotFleetGroupIdentifierArgs:
    def __init__(__self__, *,
                 group_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] group_id: The ID of the security group.
        """
        pulumi.set(__self__, "group_id", group_id)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the security group.
        """
        return pulumi.get(self, "group_id")

    @group_id.setter
    def group_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "group_id", value)


if not MYPY:
    class SpotFleetIamInstanceProfileSpecificationArgsDict(TypedDict):
        arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Amazon Resource Name (ARN) of the instance profile.
        """
elif False:
    SpotFleetIamInstanceProfileSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpotFleetIamInstanceProfileSpecificationArgs:
    def __init__(__self__, *,
                 arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] arn: The Amazon Resource Name (ARN) of the instance profile.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Amazon Resource Name (ARN) of the instance profile.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "arn", value)


if not MYPY:
    class SpotFleetInstanceIpv6AddressArgsDict(TypedDict):
        ipv6_address: pulumi.Input[_builtins.str]
        """
        The IPv6 address.
        """
elif False:
    SpotFleetInstanceIpv6AddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpotFleetInstanceIpv6AddressArgs:
    def __init__(__self__, *,
                 ipv6_address: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ipv6_address: The IPv6 address.
        """
        pulumi.set(__self__, "ipv6_address", ipv6_address)

    @_builtins.property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> pulumi.Input[_builtins.str]:
        """
        The IPv6 address.
        """
        return pulumi.get(self, "ipv6_address")

    @ipv6_address.setter
    def ipv6_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ipv6_address", value)


if not MYPY:
    class SpotFleetInstanceNetworkInterfaceSpecificationArgsDict(TypedDict):
        associate_public_ip_address: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether to assign a public IPv4 address to an instance you launch in a VPC. The public IP address can only be assigned to a network interface for eth0, and can only be assigned to a new network interface, not an existing one. You cannot specify more than one network interface in the request. If launching into a default subnet, the default value is `true` .

        AWS charges for all public IPv4 addresses, including public IPv4 addresses associated with running instances and Elastic IP addresses. For more information, see the *Public IPv4 Address* tab on the [Amazon VPC pricing page](https://docs.aws.amazon.com/vpc/pricing/) .
        """
        delete_on_termination: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the network interface is deleted when the instance is terminated.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the network interface. Applies only if creating a network interface when launching an instance.
        """
        device_index: NotRequired[pulumi.Input[_builtins.int]]
        """
        The position of the network interface in the attachment order. A primary network interface has a device index of 0.

        If you specify a network interface when launching an instance, you must specify the device index.
        """
        groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The IDs of the security groups for the network interface. Applies only if creating a network interface when launching an instance.
        """
        ipv6_address_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        A number of IPv6 addresses to assign to the network interface. Amazon EC2 chooses the IPv6 addresses from the range of the subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.
        """
        ipv6_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['SpotFleetInstanceIpv6AddressArgsDict']]]]
        """
        The IPv6 addresses to assign to the network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.
        """
        network_interface_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the network interface.

        If you are creating a Spot Fleet, omit this parameter because you cant specify a network interface ID in a launch specification.
        """
        private_ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['SpotFleetPrivateIpAddressSpecificationArgsDict']]]]
        """
        The private IPv4 addresses to assign to the network interface. Only one private IPv4 address can be designated as primary. You cannot specify this option if you're launching more than one instance in a [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) request.
        """
        secondary_private_ip_address_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of secondary private IPv4 addresses. You cant specify this parameter and also specify a secondary private IP address using the `PrivateIpAddress` parameter.
        """
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the subnet associated with the network interface.
        """
elif False:
    SpotFleetInstanceNetworkInterfaceSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpotFleetInstanceNetworkInterfaceSpecificationArgs:
    def __init__(__self__, *,
                 associate_public_ip_address: Optional[pulumi.Input[_builtins.bool]] = None,
                 delete_on_termination: Optional[pulumi.Input[_builtins.bool]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 device_index: Optional[pulumi.Input[_builtins.int]] = None,
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 ipv6_address_count: Optional[pulumi.Input[_builtins.int]] = None,
                 ipv6_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetInstanceIpv6AddressArgs']]]] = None,
                 network_interface_id: Optional[pulumi.Input[_builtins.str]] = None,
                 private_ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetPrivateIpAddressSpecificationArgs']]]] = None,
                 secondary_private_ip_address_count: Optional[pulumi.Input[_builtins.int]] = None,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] associate_public_ip_address: Indicates whether to assign a public IPv4 address to an instance you launch in a VPC. The public IP address can only be assigned to a network interface for eth0, and can only be assigned to a new network interface, not an existing one. You cannot specify more than one network interface in the request. If launching into a default subnet, the default value is `true` .
               
               AWS charges for all public IPv4 addresses, including public IPv4 addresses associated with running instances and Elastic IP addresses. For more information, see the *Public IPv4 Address* tab on the [Amazon VPC pricing page](https://docs.aws.amazon.com/vpc/pricing/) .
        :param pulumi.Input[_builtins.bool] delete_on_termination: Indicates whether the network interface is deleted when the instance is terminated.
        :param pulumi.Input[_builtins.str] description: The description of the network interface. Applies only if creating a network interface when launching an instance.
        :param pulumi.Input[_builtins.int] device_index: The position of the network interface in the attachment order. A primary network interface has a device index of 0.
               
               If you specify a network interface when launching an instance, you must specify the device index.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] groups: The IDs of the security groups for the network interface. Applies only if creating a network interface when launching an instance.
        :param pulumi.Input[_builtins.int] ipv6_address_count: A number of IPv6 addresses to assign to the network interface. Amazon EC2 chooses the IPv6 addresses from the range of the subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.
        :param pulumi.Input[Sequence[pulumi.Input['SpotFleetInstanceIpv6AddressArgs']]] ipv6_addresses: The IPv6 addresses to assign to the network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.
        :param pulumi.Input[_builtins.str] network_interface_id: The ID of the network interface.
               
               If you are creating a Spot Fleet, omit this parameter because you cant specify a network interface ID in a launch specification.
        :param pulumi.Input[Sequence[pulumi.Input['SpotFleetPrivateIpAddressSpecificationArgs']]] private_ip_addresses: The private IPv4 addresses to assign to the network interface. Only one private IPv4 address can be designated as primary. You cannot specify this option if you're launching more than one instance in a [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) request.
        :param pulumi.Input[_builtins.int] secondary_private_ip_address_count: The number of secondary private IPv4 addresses. You cant specify this parameter and also specify a secondary private IP address using the `PrivateIpAddress` parameter.
        :param pulumi.Input[_builtins.str] subnet_id: The ID of the subnet associated with the network interface.
        """
        if associate_public_ip_address is not None:
            pulumi.set(__self__, "associate_public_ip_address", associate_public_ip_address)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if device_index is not None:
            pulumi.set(__self__, "device_index", device_index)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if ipv6_address_count is not None:
            pulumi.set(__self__, "ipv6_address_count", ipv6_address_count)
        if ipv6_addresses is not None:
            pulumi.set(__self__, "ipv6_addresses", ipv6_addresses)
        if network_interface_id is not None:
            pulumi.set(__self__, "network_interface_id", network_interface_id)
        if private_ip_addresses is not None:
            pulumi.set(__self__, "private_ip_addresses", private_ip_addresses)
        if secondary_private_ip_address_count is not None:
            pulumi.set(__self__, "secondary_private_ip_address_count", secondary_private_ip_address_count)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="associatePublicIpAddress")
    def associate_public_ip_address(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether to assign a public IPv4 address to an instance you launch in a VPC. The public IP address can only be assigned to a network interface for eth0, and can only be assigned to a new network interface, not an existing one. You cannot specify more than one network interface in the request. If launching into a default subnet, the default value is `true` .

        AWS charges for all public IPv4 addresses, including public IPv4 addresses associated with running instances and Elastic IP addresses. For more information, see the *Public IPv4 Address* tab on the [Amazon VPC pricing page](https://docs.aws.amazon.com/vpc/pricing/) .
        """
        return pulumi.get(self, "associate_public_ip_address")

    @associate_public_ip_address.setter
    def associate_public_ip_address(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "associate_public_ip_address", value)

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the network interface is deleted when the instance is terminated.
        """
        return pulumi.get(self, "delete_on_termination")

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "delete_on_termination", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the network interface. Applies only if creating a network interface when launching an instance.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The position of the network interface in the attachment order. A primary network interface has a device index of 0.

        If you specify a network interface when launching an instance, you must specify the device index.
        """
        return pulumi.get(self, "device_index")

    @device_index.setter
    def device_index(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "device_index", value)

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The IDs of the security groups for the network interface. Applies only if creating a network interface when launching an instance.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "groups", value)

    @_builtins.property
    @pulumi.getter(name="ipv6AddressCount")
    def ipv6_address_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        A number of IPv6 addresses to assign to the network interface. Amazon EC2 chooses the IPv6 addresses from the range of the subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.
        """
        return pulumi.get(self, "ipv6_address_count")

    @ipv6_address_count.setter
    def ipv6_address_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ipv6_address_count", value)

    @_builtins.property
    @pulumi.getter(name="ipv6Addresses")
    def ipv6_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetInstanceIpv6AddressArgs']]]]:
        """
        The IPv6 addresses to assign to the network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.
        """
        return pulumi.get(self, "ipv6_addresses")

    @ipv6_addresses.setter
    def ipv6_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetInstanceIpv6AddressArgs']]]]):
        pulumi.set(self, "ipv6_addresses", value)

    @_builtins.property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the network interface.

        If you are creating a Spot Fleet, omit this parameter because you cant specify a network interface ID in a launch specification.
        """
        return pulumi.get(self, "network_interface_id")

    @network_interface_id.setter
    def network_interface_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "network_interface_id", value)

    @_builtins.property
    @pulumi.getter(name="privateIpAddresses")
    def private_ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetPrivateIpAddressSpecificationArgs']]]]:
        """
        The private IPv4 addresses to assign to the network interface. Only one private IPv4 address can be designated as primary. You cannot specify this option if you're launching more than one instance in a [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) request.
        """
        return pulumi.get(self, "private_ip_addresses")

    @private_ip_addresses.setter
    def private_ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetPrivateIpAddressSpecificationArgs']]]]):
        pulumi.set(self, "private_ip_addresses", value)

    @_builtins.property
    @pulumi.getter(name="secondaryPrivateIpAddressCount")
    def secondary_private_ip_address_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of secondary private IPv4 addresses. You cant specify this parameter and also specify a secondary private IP address using the `PrivateIpAddress` parameter.
        """
        return pulumi.get(self, "secondary_private_ip_address_count")

    @secondary_private_ip_address_count.setter
    def secondary_private_ip_address_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "secondary_private_ip_address_count", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the subnet associated with the network interface.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class SpotFleetInstanceRequirementsRequestArgsDict(TypedDict):
        accelerator_count: NotRequired[pulumi.Input['SpotFleetAcceleratorCountRequestArgsDict']]
        """
        The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.

        To exclude accelerator-enabled instance types, set `Max` to `0` .

        Default: No minimum or maximum limits
        """
        accelerator_manufacturers: NotRequired[pulumi.Input[Sequence[pulumi.Input['SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem']]]]
        """
        Indicates whether instance types must have accelerators by specific manufacturers.

        - For instance types with AWS devices, specify `amazon-web-services` .
        - For instance types with AMD devices, specify `amd` .
        - For instance types with Habana devices, specify `habana` .
        - For instance types with NVIDIA devices, specify `nvidia` .
        - For instance types with Xilinx devices, specify `xilinx` .

        Default: Any manufacturer
        """
        accelerator_names: NotRequired[pulumi.Input[Sequence[pulumi.Input['SpotFleetInstanceRequirementsRequestAcceleratorNamesItem']]]]
        """
        The accelerators that must be on the instance type.

        - For instance types with NVIDIA A10G GPUs, specify `a10g` .
        - For instance types with NVIDIA A100 GPUs, specify `a100` .
        - For instance types with NVIDIA H100 GPUs, specify `h100` .
        - For instance types with AWS Inferentia chips, specify `inferentia` .
        - For instance types with NVIDIA GRID K520 GPUs, specify `k520` .
        - For instance types with NVIDIA K80 GPUs, specify `k80` .
        - For instance types with NVIDIA M60 GPUs, specify `m60` .
        - For instance types with AMD Radeon Pro V520 GPUs, specify `radeon-pro-v520` .
        - For instance types with NVIDIA T4 GPUs, specify `t4` .
        - For instance types with NVIDIA T4G GPUs, specify `t4g` .
        - For instance types with Xilinx VU9P FPGAs, specify `vu9p` .
        - For instance types with NVIDIA V100 GPUs, specify `v100` .

        Default: Any accelerator
        """
        accelerator_total_memory_mi_b: NotRequired[pulumi.Input['SpotFleetAcceleratorTotalMemoryMiBRequestArgsDict']]
        """
        The minimum and maximum amount of total accelerator memory, in MiB.

        Default: No minimum or maximum limits
        """
        accelerator_types: NotRequired[pulumi.Input[Sequence[pulumi.Input['SpotFleetInstanceRequirementsRequestAcceleratorTypesItem']]]]
        """
        The accelerator types that must be on the instance type.

        - For instance types with FPGA accelerators, specify `fpga` .
        - For instance types with GPU accelerators, specify `gpu` .
        - For instance types with Inference accelerators, specify `inference` .

        Default: Any accelerator type
        """
        allowed_instance_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes.

        You can use strings with one or more wild cards, represented by an asterisk ( `*` ), to allow an instance type, size, or generation. The following are examples: `m5.8xlarge` , `c5*.*` , `m5a.*` , `r*` , `*3*` .

        For example, if you specify `c5*` ,Amazon EC2 will allow the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*` , Amazon EC2 will allow all the M5a instance types, but not the M5n instance types.

        > If you specify `AllowedInstanceTypes` , you can't specify `ExcludedInstanceTypes` . 

        Default: All instance types
        """
        bare_metal: NotRequired[pulumi.Input['SpotFleetInstanceRequirementsRequestBareMetal']]
        """
        Indicates whether bare metal instance types must be included, excluded, or required.

        - To include bare metal instance types, specify `included` .
        - To require only bare metal instance types, specify `required` .
        - To exclude bare metal instance types, specify `excluded` .

        Default: `excluded`
        """
        baseline_ebs_bandwidth_mbps: NotRequired[pulumi.Input['SpotFleetBaselineEbsBandwidthMbpsRequestArgsDict']]
        """
        The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see [Amazon EBSoptimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the *Amazon EC2 User Guide* .

        Default: No minimum or maximum limits
        """
        baseline_performance_factors: NotRequired[pulumi.Input['SpotFleetBaselinePerformanceFactorsRequestArgsDict']]
        """
        The baseline performance to consider, using an instance family as a baseline reference. The instance family establishes the lowest acceptable level of performance. Amazon EC2 uses this baseline to guide instance type selection, but there is no guarantee that the selected instance types will always exceed the baseline for every application. Currently, this parameter only supports CPU performance as a baseline performance factor. For more information, see [Performance protection](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html#ec2fleet-abis-performance-protection) in the *Amazon EC2 User Guide* .
        """
        burstable_performance: NotRequired[pulumi.Input['SpotFleetInstanceRequirementsRequestBurstablePerformance']]
        """
        Indicates whether burstable performance T instance types are included, excluded, or required. For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) .

        - To include burstable performance instance types, specify `included` .
        - To require only burstable performance instance types, specify `required` .
        - To exclude burstable performance instance types, specify `excluded` .

        Default: `excluded`
        """
        cpu_manufacturers: NotRequired[pulumi.Input[Sequence[pulumi.Input['SpotFleetInstanceRequirementsRequestCpuManufacturersItem']]]]
        """
        The CPU manufacturers to include.

        - For instance types with Intel CPUs, specify `intel` .
        - For instance types with AMD CPUs, specify `amd` .
        - For instance types with AWS CPUs, specify `amazon-web-services` .
        - For instance types with Apple CPUs, specify `apple` .

        > Don't confuse the CPU manufacturer with the CPU architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template. 

        Default: Any manufacturer
        """
        excluded_instance_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The instance types to exclude.

        You can use strings with one or more wild cards, represented by an asterisk ( `*` ), to exclude an instance family, type, size, or generation. The following are examples: `m5.8xlarge` , `c5*.*` , `m5a.*` , `r*` , `*3*` .

        For example, if you specify `c5*` ,Amazon EC2 will exclude the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*` , Amazon EC2 will exclude all the M5a instance types, but not the M5n instance types.

        > If you specify `ExcludedInstanceTypes` , you can't specify `AllowedInstanceTypes` . 

        Default: No excluded instance types
        """
        instance_generations: NotRequired[pulumi.Input[Sequence[pulumi.Input['SpotFleetInstanceRequirementsRequestInstanceGenerationsItem']]]]
        """
        Indicates whether current or previous generation instance types are included. The current generation instance types are recommended for use. Current generation instance types are typically the latest two to three generations in each instance family. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .

        For current generation instance types, specify `current` .

        For previous generation instance types, specify `previous` .

        Default: Current and previous generation instance types
        """
        local_storage: NotRequired[pulumi.Input['SpotFleetInstanceRequirementsRequestLocalStorage']]
        """
        Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, [Amazon EC2 instance store](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html) in the *Amazon EC2 User Guide* .

        - To include instance types with instance store volumes, specify `included` .
        - To require only instance types with instance store volumes, specify `required` .
        - To exclude instance types with instance store volumes, specify `excluded` .

        Default: `included`
        """
        local_storage_types: NotRequired[pulumi.Input[Sequence[pulumi.Input['SpotFleetInstanceRequirementsRequestLocalStorageTypesItem']]]]
        """
        The type of local storage that is required.

        - For instance types with hard disk drive (HDD) storage, specify `hdd` .
        - For instance types with solid state drive (SSD) storage, specify `ssd` .

        Default: `hdd` and `ssd`
        """
        max_spot_price_as_percentage_of_optimal_on_demand_price: NotRequired[pulumi.Input[_builtins.int]]
        """
        [Price protection] The price protection threshold for Spot Instances, as a percentage of an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.

        The parameter accepts an integer, which Amazon EC2 interprets as a percentage.

        If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is based on the per vCPU or per memory price instead of the per instance price.

        > Only one of `SpotMaxPricePercentageOverLowestPrice` or `MaxSpotPriceAsPercentageOfOptimalOnDemandPrice` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as `999999` .
        """
        memory_gi_b_per_v_cpu: NotRequired[pulumi.Input['SpotFleetMemoryGiBPerVCpuRequestArgsDict']]
        """
        The minimum and maximum amount of memory per vCPU, in GiB.

        Default: No minimum or maximum limits
        """
        memory_mi_b: NotRequired[pulumi.Input['SpotFleetMemoryMiBRequestArgsDict']]
        """
        The minimum and maximum amount of memory, in MiB.
        """
        network_bandwidth_gbps: NotRequired[pulumi.Input['SpotFleetNetworkBandwidthGbpsRequestArgsDict']]
        """
        The minimum and maximum amount of baseline network bandwidth, in gigabits per second (Gbps). For more information, see [Amazon EC2 instance network bandwidth](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-network-bandwidth.html) in the *Amazon EC2 User Guide* .

        Default: No minimum or maximum limits
        """
        network_interface_count: NotRequired[pulumi.Input['SpotFleetNetworkInterfaceCountRequestArgsDict']]
        """
        The minimum and maximum number of network interfaces.

        Default: No minimum or maximum limits
        """
        on_demand_max_price_percentage_over_lowest_price: NotRequired[pulumi.Input[_builtins.int]]
        """
        [Price protection] The price protection threshold for On-Demand Instances, as a percentage higher than an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.

        The parameter accepts an integer, which Amazon EC2 interprets as a percentage.

        To indicate no price protection threshold, specify a high value, such as `999999` .

        This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) .

        > If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price. 

        Default: `20`
        """
        require_hibernate_support: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether instance types must support hibernation for On-Demand Instances.

        This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) .

        Default: `false`
        """
        spot_max_price_percentage_over_lowest_price: NotRequired[pulumi.Input[_builtins.int]]
        """
        [Price protection] The price protection threshold for Spot Instances, as a percentage higher than an identified Spot price. The identified Spot price is the Spot price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified Spot price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose Spot price exceeds your specified threshold.

        The parameter accepts an integer, which Amazon EC2 interprets as a percentage.

        If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.

        This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) .

        > Only one of `SpotMaxPricePercentageOverLowestPrice` or `MaxSpotPriceAsPercentageOfOptimalOnDemandPrice` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as `999999` . 

        Default: `100`
        """
        total_local_storage_gb: NotRequired[pulumi.Input['SpotFleetTotalLocalStorageGbRequestArgsDict']]
        """
        The minimum and maximum amount of total local storage, in GB.

        Default: No minimum or maximum limits
        """
        v_cpu_count: NotRequired[pulumi.Input['SpotFleetVCpuCountRangeRequestArgsDict']]
        """
        The minimum and maximum number of vCPUs.
        """
elif False:
    SpotFleetInstanceRequirementsRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpotFleetInstanceRequirementsRequestArgs:
    def __init__(__self__, *,
                 accelerator_count: Optional[pulumi.Input['SpotFleetAcceleratorCountRequestArgs']] = None,
                 accelerator_manufacturers: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem']]]] = None,
                 accelerator_names: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetInstanceRequirementsRequestAcceleratorNamesItem']]]] = None,
                 accelerator_total_memory_mi_b: Optional[pulumi.Input['SpotFleetAcceleratorTotalMemoryMiBRequestArgs']] = None,
                 accelerator_types: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetInstanceRequirementsRequestAcceleratorTypesItem']]]] = None,
                 allowed_instance_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 bare_metal: Optional[pulumi.Input['SpotFleetInstanceRequirementsRequestBareMetal']] = None,
                 baseline_ebs_bandwidth_mbps: Optional[pulumi.Input['SpotFleetBaselineEbsBandwidthMbpsRequestArgs']] = None,
                 baseline_performance_factors: Optional[pulumi.Input['SpotFleetBaselinePerformanceFactorsRequestArgs']] = None,
                 burstable_performance: Optional[pulumi.Input['SpotFleetInstanceRequirementsRequestBurstablePerformance']] = None,
                 cpu_manufacturers: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetInstanceRequirementsRequestCpuManufacturersItem']]]] = None,
                 excluded_instance_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 instance_generations: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetInstanceRequirementsRequestInstanceGenerationsItem']]]] = None,
                 local_storage: Optional[pulumi.Input['SpotFleetInstanceRequirementsRequestLocalStorage']] = None,
                 local_storage_types: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetInstanceRequirementsRequestLocalStorageTypesItem']]]] = None,
                 max_spot_price_as_percentage_of_optimal_on_demand_price: Optional[pulumi.Input[_builtins.int]] = None,
                 memory_gi_b_per_v_cpu: Optional[pulumi.Input['SpotFleetMemoryGiBPerVCpuRequestArgs']] = None,
                 memory_mi_b: Optional[pulumi.Input['SpotFleetMemoryMiBRequestArgs']] = None,
                 network_bandwidth_gbps: Optional[pulumi.Input['SpotFleetNetworkBandwidthGbpsRequestArgs']] = None,
                 network_interface_count: Optional[pulumi.Input['SpotFleetNetworkInterfaceCountRequestArgs']] = None,
                 on_demand_max_price_percentage_over_lowest_price: Optional[pulumi.Input[_builtins.int]] = None,
                 require_hibernate_support: Optional[pulumi.Input[_builtins.bool]] = None,
                 spot_max_price_percentage_over_lowest_price: Optional[pulumi.Input[_builtins.int]] = None,
                 total_local_storage_gb: Optional[pulumi.Input['SpotFleetTotalLocalStorageGbRequestArgs']] = None,
                 v_cpu_count: Optional[pulumi.Input['SpotFleetVCpuCountRangeRequestArgs']] = None):
        """
        :param pulumi.Input['SpotFleetAcceleratorCountRequestArgs'] accelerator_count: The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.
               
               To exclude accelerator-enabled instance types, set `Max` to `0` .
               
               Default: No minimum or maximum limits
        :param pulumi.Input[Sequence[pulumi.Input['SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem']]] accelerator_manufacturers: Indicates whether instance types must have accelerators by specific manufacturers.
               
               - For instance types with AWS devices, specify `amazon-web-services` .
               - For instance types with AMD devices, specify `amd` .
               - For instance types with Habana devices, specify `habana` .
               - For instance types with NVIDIA devices, specify `nvidia` .
               - For instance types with Xilinx devices, specify `xilinx` .
               
               Default: Any manufacturer
        :param pulumi.Input[Sequence[pulumi.Input['SpotFleetInstanceRequirementsRequestAcceleratorNamesItem']]] accelerator_names: The accelerators that must be on the instance type.
               
               - For instance types with NVIDIA A10G GPUs, specify `a10g` .
               - For instance types with NVIDIA A100 GPUs, specify `a100` .
               - For instance types with NVIDIA H100 GPUs, specify `h100` .
               - For instance types with AWS Inferentia chips, specify `inferentia` .
               - For instance types with NVIDIA GRID K520 GPUs, specify `k520` .
               - For instance types with NVIDIA K80 GPUs, specify `k80` .
               - For instance types with NVIDIA M60 GPUs, specify `m60` .
               - For instance types with AMD Radeon Pro V520 GPUs, specify `radeon-pro-v520` .
               - For instance types with NVIDIA T4 GPUs, specify `t4` .
               - For instance types with NVIDIA T4G GPUs, specify `t4g` .
               - For instance types with Xilinx VU9P FPGAs, specify `vu9p` .
               - For instance types with NVIDIA V100 GPUs, specify `v100` .
               
               Default: Any accelerator
        :param pulumi.Input['SpotFleetAcceleratorTotalMemoryMiBRequestArgs'] accelerator_total_memory_mi_b: The minimum and maximum amount of total accelerator memory, in MiB.
               
               Default: No minimum or maximum limits
        :param pulumi.Input[Sequence[pulumi.Input['SpotFleetInstanceRequirementsRequestAcceleratorTypesItem']]] accelerator_types: The accelerator types that must be on the instance type.
               
               - For instance types with FPGA accelerators, specify `fpga` .
               - For instance types with GPU accelerators, specify `gpu` .
               - For instance types with Inference accelerators, specify `inference` .
               
               Default: Any accelerator type
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_instance_types: The instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes.
               
               You can use strings with one or more wild cards, represented by an asterisk ( `*` ), to allow an instance type, size, or generation. The following are examples: `m5.8xlarge` , `c5*.*` , `m5a.*` , `r*` , `*3*` .
               
               For example, if you specify `c5*` ,Amazon EC2 will allow the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*` , Amazon EC2 will allow all the M5a instance types, but not the M5n instance types.
               
               > If you specify `AllowedInstanceTypes` , you can't specify `ExcludedInstanceTypes` . 
               
               Default: All instance types
        :param pulumi.Input['SpotFleetInstanceRequirementsRequestBareMetal'] bare_metal: Indicates whether bare metal instance types must be included, excluded, or required.
               
               - To include bare metal instance types, specify `included` .
               - To require only bare metal instance types, specify `required` .
               - To exclude bare metal instance types, specify `excluded` .
               
               Default: `excluded`
        :param pulumi.Input['SpotFleetBaselineEbsBandwidthMbpsRequestArgs'] baseline_ebs_bandwidth_mbps: The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see [Amazon EBSoptimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the *Amazon EC2 User Guide* .
               
               Default: No minimum or maximum limits
        :param pulumi.Input['SpotFleetBaselinePerformanceFactorsRequestArgs'] baseline_performance_factors: The baseline performance to consider, using an instance family as a baseline reference. The instance family establishes the lowest acceptable level of performance. Amazon EC2 uses this baseline to guide instance type selection, but there is no guarantee that the selected instance types will always exceed the baseline for every application. Currently, this parameter only supports CPU performance as a baseline performance factor. For more information, see [Performance protection](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html#ec2fleet-abis-performance-protection) in the *Amazon EC2 User Guide* .
        :param pulumi.Input['SpotFleetInstanceRequirementsRequestBurstablePerformance'] burstable_performance: Indicates whether burstable performance T instance types are included, excluded, or required. For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) .
               
               - To include burstable performance instance types, specify `included` .
               - To require only burstable performance instance types, specify `required` .
               - To exclude burstable performance instance types, specify `excluded` .
               
               Default: `excluded`
        :param pulumi.Input[Sequence[pulumi.Input['SpotFleetInstanceRequirementsRequestCpuManufacturersItem']]] cpu_manufacturers: The CPU manufacturers to include.
               
               - For instance types with Intel CPUs, specify `intel` .
               - For instance types with AMD CPUs, specify `amd` .
               - For instance types with AWS CPUs, specify `amazon-web-services` .
               - For instance types with Apple CPUs, specify `apple` .
               
               > Don't confuse the CPU manufacturer with the CPU architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template. 
               
               Default: Any manufacturer
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] excluded_instance_types: The instance types to exclude.
               
               You can use strings with one or more wild cards, represented by an asterisk ( `*` ), to exclude an instance family, type, size, or generation. The following are examples: `m5.8xlarge` , `c5*.*` , `m5a.*` , `r*` , `*3*` .
               
               For example, if you specify `c5*` ,Amazon EC2 will exclude the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*` , Amazon EC2 will exclude all the M5a instance types, but not the M5n instance types.
               
               > If you specify `ExcludedInstanceTypes` , you can't specify `AllowedInstanceTypes` . 
               
               Default: No excluded instance types
        :param pulumi.Input[Sequence[pulumi.Input['SpotFleetInstanceRequirementsRequestInstanceGenerationsItem']]] instance_generations: Indicates whether current or previous generation instance types are included. The current generation instance types are recommended for use. Current generation instance types are typically the latest two to three generations in each instance family. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .
               
               For current generation instance types, specify `current` .
               
               For previous generation instance types, specify `previous` .
               
               Default: Current and previous generation instance types
        :param pulumi.Input['SpotFleetInstanceRequirementsRequestLocalStorage'] local_storage: Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, [Amazon EC2 instance store](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html) in the *Amazon EC2 User Guide* .
               
               - To include instance types with instance store volumes, specify `included` .
               - To require only instance types with instance store volumes, specify `required` .
               - To exclude instance types with instance store volumes, specify `excluded` .
               
               Default: `included`
        :param pulumi.Input[Sequence[pulumi.Input['SpotFleetInstanceRequirementsRequestLocalStorageTypesItem']]] local_storage_types: The type of local storage that is required.
               
               - For instance types with hard disk drive (HDD) storage, specify `hdd` .
               - For instance types with solid state drive (SSD) storage, specify `ssd` .
               
               Default: `hdd` and `ssd`
        :param pulumi.Input[_builtins.int] max_spot_price_as_percentage_of_optimal_on_demand_price: [Price protection] The price protection threshold for Spot Instances, as a percentage of an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.
               
               The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
               
               If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is based on the per vCPU or per memory price instead of the per instance price.
               
               > Only one of `SpotMaxPricePercentageOverLowestPrice` or `MaxSpotPriceAsPercentageOfOptimalOnDemandPrice` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as `999999` .
        :param pulumi.Input['SpotFleetMemoryGiBPerVCpuRequestArgs'] memory_gi_b_per_v_cpu: The minimum and maximum amount of memory per vCPU, in GiB.
               
               Default: No minimum or maximum limits
        :param pulumi.Input['SpotFleetMemoryMiBRequestArgs'] memory_mi_b: The minimum and maximum amount of memory, in MiB.
        :param pulumi.Input['SpotFleetNetworkBandwidthGbpsRequestArgs'] network_bandwidth_gbps: The minimum and maximum amount of baseline network bandwidth, in gigabits per second (Gbps). For more information, see [Amazon EC2 instance network bandwidth](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-network-bandwidth.html) in the *Amazon EC2 User Guide* .
               
               Default: No minimum or maximum limits
        :param pulumi.Input['SpotFleetNetworkInterfaceCountRequestArgs'] network_interface_count: The minimum and maximum number of network interfaces.
               
               Default: No minimum or maximum limits
        :param pulumi.Input[_builtins.int] on_demand_max_price_percentage_over_lowest_price: [Price protection] The price protection threshold for On-Demand Instances, as a percentage higher than an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.
               
               The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
               
               To indicate no price protection threshold, specify a high value, such as `999999` .
               
               This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) .
               
               > If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price. 
               
               Default: `20`
        :param pulumi.Input[_builtins.bool] require_hibernate_support: Indicates whether instance types must support hibernation for On-Demand Instances.
               
               This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) .
               
               Default: `false`
        :param pulumi.Input[_builtins.int] spot_max_price_percentage_over_lowest_price: [Price protection] The price protection threshold for Spot Instances, as a percentage higher than an identified Spot price. The identified Spot price is the Spot price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified Spot price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose Spot price exceeds your specified threshold.
               
               The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
               
               If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.
               
               This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) .
               
               > Only one of `SpotMaxPricePercentageOverLowestPrice` or `MaxSpotPriceAsPercentageOfOptimalOnDemandPrice` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as `999999` . 
               
               Default: `100`
        :param pulumi.Input['SpotFleetTotalLocalStorageGbRequestArgs'] total_local_storage_gb: The minimum and maximum amount of total local storage, in GB.
               
               Default: No minimum or maximum limits
        :param pulumi.Input['SpotFleetVCpuCountRangeRequestArgs'] v_cpu_count: The minimum and maximum number of vCPUs.
        """
        if accelerator_count is not None:
            pulumi.set(__self__, "accelerator_count", accelerator_count)
        if accelerator_manufacturers is not None:
            pulumi.set(__self__, "accelerator_manufacturers", accelerator_manufacturers)
        if accelerator_names is not None:
            pulumi.set(__self__, "accelerator_names", accelerator_names)
        if accelerator_total_memory_mi_b is not None:
            pulumi.set(__self__, "accelerator_total_memory_mi_b", accelerator_total_memory_mi_b)
        if accelerator_types is not None:
            pulumi.set(__self__, "accelerator_types", accelerator_types)
        if allowed_instance_types is not None:
            pulumi.set(__self__, "allowed_instance_types", allowed_instance_types)
        if bare_metal is not None:
            pulumi.set(__self__, "bare_metal", bare_metal)
        if baseline_ebs_bandwidth_mbps is not None:
            pulumi.set(__self__, "baseline_ebs_bandwidth_mbps", baseline_ebs_bandwidth_mbps)
        if baseline_performance_factors is not None:
            pulumi.set(__self__, "baseline_performance_factors", baseline_performance_factors)
        if burstable_performance is not None:
            pulumi.set(__self__, "burstable_performance", burstable_performance)
        if cpu_manufacturers is not None:
            pulumi.set(__self__, "cpu_manufacturers", cpu_manufacturers)
        if excluded_instance_types is not None:
            pulumi.set(__self__, "excluded_instance_types", excluded_instance_types)
        if instance_generations is not None:
            pulumi.set(__self__, "instance_generations", instance_generations)
        if local_storage is not None:
            pulumi.set(__self__, "local_storage", local_storage)
        if local_storage_types is not None:
            pulumi.set(__self__, "local_storage_types", local_storage_types)
        if max_spot_price_as_percentage_of_optimal_on_demand_price is not None:
            pulumi.set(__self__, "max_spot_price_as_percentage_of_optimal_on_demand_price", max_spot_price_as_percentage_of_optimal_on_demand_price)
        if memory_gi_b_per_v_cpu is not None:
            pulumi.set(__self__, "memory_gi_b_per_v_cpu", memory_gi_b_per_v_cpu)
        if memory_mi_b is not None:
            pulumi.set(__self__, "memory_mi_b", memory_mi_b)
        if network_bandwidth_gbps is not None:
            pulumi.set(__self__, "network_bandwidth_gbps", network_bandwidth_gbps)
        if network_interface_count is not None:
            pulumi.set(__self__, "network_interface_count", network_interface_count)
        if on_demand_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "on_demand_max_price_percentage_over_lowest_price", on_demand_max_price_percentage_over_lowest_price)
        if require_hibernate_support is not None:
            pulumi.set(__self__, "require_hibernate_support", require_hibernate_support)
        if spot_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "spot_max_price_percentage_over_lowest_price", spot_max_price_percentage_over_lowest_price)
        if total_local_storage_gb is not None:
            pulumi.set(__self__, "total_local_storage_gb", total_local_storage_gb)
        if v_cpu_count is not None:
            pulumi.set(__self__, "v_cpu_count", v_cpu_count)

    @_builtins.property
    @pulumi.getter(name="acceleratorCount")
    def accelerator_count(self) -> Optional[pulumi.Input['SpotFleetAcceleratorCountRequestArgs']]:
        """
        The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.

        To exclude accelerator-enabled instance types, set `Max` to `0` .

        Default: No minimum or maximum limits
        """
        return pulumi.get(self, "accelerator_count")

    @accelerator_count.setter
    def accelerator_count(self, value: Optional[pulumi.Input['SpotFleetAcceleratorCountRequestArgs']]):
        pulumi.set(self, "accelerator_count", value)

    @_builtins.property
    @pulumi.getter(name="acceleratorManufacturers")
    def accelerator_manufacturers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem']]]]:
        """
        Indicates whether instance types must have accelerators by specific manufacturers.

        - For instance types with AWS devices, specify `amazon-web-services` .
        - For instance types with AMD devices, specify `amd` .
        - For instance types with Habana devices, specify `habana` .
        - For instance types with NVIDIA devices, specify `nvidia` .
        - For instance types with Xilinx devices, specify `xilinx` .

        Default: Any manufacturer
        """
        return pulumi.get(self, "accelerator_manufacturers")

    @accelerator_manufacturers.setter
    def accelerator_manufacturers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem']]]]):
        pulumi.set(self, "accelerator_manufacturers", value)

    @_builtins.property
    @pulumi.getter(name="acceleratorNames")
    def accelerator_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetInstanceRequirementsRequestAcceleratorNamesItem']]]]:
        """
        The accelerators that must be on the instance type.

        - For instance types with NVIDIA A10G GPUs, specify `a10g` .
        - For instance types with NVIDIA A100 GPUs, specify `a100` .
        - For instance types with NVIDIA H100 GPUs, specify `h100` .
        - For instance types with AWS Inferentia chips, specify `inferentia` .
        - For instance types with NVIDIA GRID K520 GPUs, specify `k520` .
        - For instance types with NVIDIA K80 GPUs, specify `k80` .
        - For instance types with NVIDIA M60 GPUs, specify `m60` .
        - For instance types with AMD Radeon Pro V520 GPUs, specify `radeon-pro-v520` .
        - For instance types with NVIDIA T4 GPUs, specify `t4` .
        - For instance types with NVIDIA T4G GPUs, specify `t4g` .
        - For instance types with Xilinx VU9P FPGAs, specify `vu9p` .
        - For instance types with NVIDIA V100 GPUs, specify `v100` .

        Default: Any accelerator
        """
        return pulumi.get(self, "accelerator_names")

    @accelerator_names.setter
    def accelerator_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetInstanceRequirementsRequestAcceleratorNamesItem']]]]):
        pulumi.set(self, "accelerator_names", value)

    @_builtins.property
    @pulumi.getter(name="acceleratorTotalMemoryMiB")
    def accelerator_total_memory_mi_b(self) -> Optional[pulumi.Input['SpotFleetAcceleratorTotalMemoryMiBRequestArgs']]:
        """
        The minimum and maximum amount of total accelerator memory, in MiB.

        Default: No minimum or maximum limits
        """
        return pulumi.get(self, "accelerator_total_memory_mi_b")

    @accelerator_total_memory_mi_b.setter
    def accelerator_total_memory_mi_b(self, value: Optional[pulumi.Input['SpotFleetAcceleratorTotalMemoryMiBRequestArgs']]):
        pulumi.set(self, "accelerator_total_memory_mi_b", value)

    @_builtins.property
    @pulumi.getter(name="acceleratorTypes")
    def accelerator_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetInstanceRequirementsRequestAcceleratorTypesItem']]]]:
        """
        The accelerator types that must be on the instance type.

        - For instance types with FPGA accelerators, specify `fpga` .
        - For instance types with GPU accelerators, specify `gpu` .
        - For instance types with Inference accelerators, specify `inference` .

        Default: Any accelerator type
        """
        return pulumi.get(self, "accelerator_types")

    @accelerator_types.setter
    def accelerator_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetInstanceRequirementsRequestAcceleratorTypesItem']]]]):
        pulumi.set(self, "accelerator_types", value)

    @_builtins.property
    @pulumi.getter(name="allowedInstanceTypes")
    def allowed_instance_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes.

        You can use strings with one or more wild cards, represented by an asterisk ( `*` ), to allow an instance type, size, or generation. The following are examples: `m5.8xlarge` , `c5*.*` , `m5a.*` , `r*` , `*3*` .

        For example, if you specify `c5*` ,Amazon EC2 will allow the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*` , Amazon EC2 will allow all the M5a instance types, but not the M5n instance types.

        > If you specify `AllowedInstanceTypes` , you can't specify `ExcludedInstanceTypes` . 

        Default: All instance types
        """
        return pulumi.get(self, "allowed_instance_types")

    @allowed_instance_types.setter
    def allowed_instance_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_instance_types", value)

    @_builtins.property
    @pulumi.getter(name="bareMetal")
    def bare_metal(self) -> Optional[pulumi.Input['SpotFleetInstanceRequirementsRequestBareMetal']]:
        """
        Indicates whether bare metal instance types must be included, excluded, or required.

        - To include bare metal instance types, specify `included` .
        - To require only bare metal instance types, specify `required` .
        - To exclude bare metal instance types, specify `excluded` .

        Default: `excluded`
        """
        return pulumi.get(self, "bare_metal")

    @bare_metal.setter
    def bare_metal(self, value: Optional[pulumi.Input['SpotFleetInstanceRequirementsRequestBareMetal']]):
        pulumi.set(self, "bare_metal", value)

    @_builtins.property
    @pulumi.getter(name="baselineEbsBandwidthMbps")
    def baseline_ebs_bandwidth_mbps(self) -> Optional[pulumi.Input['SpotFleetBaselineEbsBandwidthMbpsRequestArgs']]:
        """
        The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see [Amazon EBSoptimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the *Amazon EC2 User Guide* .

        Default: No minimum or maximum limits
        """
        return pulumi.get(self, "baseline_ebs_bandwidth_mbps")

    @baseline_ebs_bandwidth_mbps.setter
    def baseline_ebs_bandwidth_mbps(self, value: Optional[pulumi.Input['SpotFleetBaselineEbsBandwidthMbpsRequestArgs']]):
        pulumi.set(self, "baseline_ebs_bandwidth_mbps", value)

    @_builtins.property
    @pulumi.getter(name="baselinePerformanceFactors")
    def baseline_performance_factors(self) -> Optional[pulumi.Input['SpotFleetBaselinePerformanceFactorsRequestArgs']]:
        """
        The baseline performance to consider, using an instance family as a baseline reference. The instance family establishes the lowest acceptable level of performance. Amazon EC2 uses this baseline to guide instance type selection, but there is no guarantee that the selected instance types will always exceed the baseline for every application. Currently, this parameter only supports CPU performance as a baseline performance factor. For more information, see [Performance protection](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html#ec2fleet-abis-performance-protection) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "baseline_performance_factors")

    @baseline_performance_factors.setter
    def baseline_performance_factors(self, value: Optional[pulumi.Input['SpotFleetBaselinePerformanceFactorsRequestArgs']]):
        pulumi.set(self, "baseline_performance_factors", value)

    @_builtins.property
    @pulumi.getter(name="burstablePerformance")
    def burstable_performance(self) -> Optional[pulumi.Input['SpotFleetInstanceRequirementsRequestBurstablePerformance']]:
        """
        Indicates whether burstable performance T instance types are included, excluded, or required. For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) .

        - To include burstable performance instance types, specify `included` .
        - To require only burstable performance instance types, specify `required` .
        - To exclude burstable performance instance types, specify `excluded` .

        Default: `excluded`
        """
        return pulumi.get(self, "burstable_performance")

    @burstable_performance.setter
    def burstable_performance(self, value: Optional[pulumi.Input['SpotFleetInstanceRequirementsRequestBurstablePerformance']]):
        pulumi.set(self, "burstable_performance", value)

    @_builtins.property
    @pulumi.getter(name="cpuManufacturers")
    def cpu_manufacturers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetInstanceRequirementsRequestCpuManufacturersItem']]]]:
        """
        The CPU manufacturers to include.

        - For instance types with Intel CPUs, specify `intel` .
        - For instance types with AMD CPUs, specify `amd` .
        - For instance types with AWS CPUs, specify `amazon-web-services` .
        - For instance types with Apple CPUs, specify `apple` .

        > Don't confuse the CPU manufacturer with the CPU architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template. 

        Default: Any manufacturer
        """
        return pulumi.get(self, "cpu_manufacturers")

    @cpu_manufacturers.setter
    def cpu_manufacturers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetInstanceRequirementsRequestCpuManufacturersItem']]]]):
        pulumi.set(self, "cpu_manufacturers", value)

    @_builtins.property
    @pulumi.getter(name="excludedInstanceTypes")
    def excluded_instance_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The instance types to exclude.

        You can use strings with one or more wild cards, represented by an asterisk ( `*` ), to exclude an instance family, type, size, or generation. The following are examples: `m5.8xlarge` , `c5*.*` , `m5a.*` , `r*` , `*3*` .

        For example, if you specify `c5*` ,Amazon EC2 will exclude the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*` , Amazon EC2 will exclude all the M5a instance types, but not the M5n instance types.

        > If you specify `ExcludedInstanceTypes` , you can't specify `AllowedInstanceTypes` . 

        Default: No excluded instance types
        """
        return pulumi.get(self, "excluded_instance_types")

    @excluded_instance_types.setter
    def excluded_instance_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_instance_types", value)

    @_builtins.property
    @pulumi.getter(name="instanceGenerations")
    def instance_generations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetInstanceRequirementsRequestInstanceGenerationsItem']]]]:
        """
        Indicates whether current or previous generation instance types are included. The current generation instance types are recommended for use. Current generation instance types are typically the latest two to three generations in each instance family. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .

        For current generation instance types, specify `current` .

        For previous generation instance types, specify `previous` .

        Default: Current and previous generation instance types
        """
        return pulumi.get(self, "instance_generations")

    @instance_generations.setter
    def instance_generations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetInstanceRequirementsRequestInstanceGenerationsItem']]]]):
        pulumi.set(self, "instance_generations", value)

    @_builtins.property
    @pulumi.getter(name="localStorage")
    def local_storage(self) -> Optional[pulumi.Input['SpotFleetInstanceRequirementsRequestLocalStorage']]:
        """
        Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, [Amazon EC2 instance store](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html) in the *Amazon EC2 User Guide* .

        - To include instance types with instance store volumes, specify `included` .
        - To require only instance types with instance store volumes, specify `required` .
        - To exclude instance types with instance store volumes, specify `excluded` .

        Default: `included`
        """
        return pulumi.get(self, "local_storage")

    @local_storage.setter
    def local_storage(self, value: Optional[pulumi.Input['SpotFleetInstanceRequirementsRequestLocalStorage']]):
        pulumi.set(self, "local_storage", value)

    @_builtins.property
    @pulumi.getter(name="localStorageTypes")
    def local_storage_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetInstanceRequirementsRequestLocalStorageTypesItem']]]]:
        """
        The type of local storage that is required.

        - For instance types with hard disk drive (HDD) storage, specify `hdd` .
        - For instance types with solid state drive (SSD) storage, specify `ssd` .

        Default: `hdd` and `ssd`
        """
        return pulumi.get(self, "local_storage_types")

    @local_storage_types.setter
    def local_storage_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetInstanceRequirementsRequestLocalStorageTypesItem']]]]):
        pulumi.set(self, "local_storage_types", value)

    @_builtins.property
    @pulumi.getter(name="maxSpotPriceAsPercentageOfOptimalOnDemandPrice")
    def max_spot_price_as_percentage_of_optimal_on_demand_price(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        [Price protection] The price protection threshold for Spot Instances, as a percentage of an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.

        The parameter accepts an integer, which Amazon EC2 interprets as a percentage.

        If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is based on the per vCPU or per memory price instead of the per instance price.

        > Only one of `SpotMaxPricePercentageOverLowestPrice` or `MaxSpotPriceAsPercentageOfOptimalOnDemandPrice` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as `999999` .
        """
        return pulumi.get(self, "max_spot_price_as_percentage_of_optimal_on_demand_price")

    @max_spot_price_as_percentage_of_optimal_on_demand_price.setter
    def max_spot_price_as_percentage_of_optimal_on_demand_price(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_spot_price_as_percentage_of_optimal_on_demand_price", value)

    @_builtins.property
    @pulumi.getter(name="memoryGiBPerVCpu")
    def memory_gi_b_per_v_cpu(self) -> Optional[pulumi.Input['SpotFleetMemoryGiBPerVCpuRequestArgs']]:
        """
        The minimum and maximum amount of memory per vCPU, in GiB.

        Default: No minimum or maximum limits
        """
        return pulumi.get(self, "memory_gi_b_per_v_cpu")

    @memory_gi_b_per_v_cpu.setter
    def memory_gi_b_per_v_cpu(self, value: Optional[pulumi.Input['SpotFleetMemoryGiBPerVCpuRequestArgs']]):
        pulumi.set(self, "memory_gi_b_per_v_cpu", value)

    @_builtins.property
    @pulumi.getter(name="memoryMiB")
    def memory_mi_b(self) -> Optional[pulumi.Input['SpotFleetMemoryMiBRequestArgs']]:
        """
        The minimum and maximum amount of memory, in MiB.
        """
        return pulumi.get(self, "memory_mi_b")

    @memory_mi_b.setter
    def memory_mi_b(self, value: Optional[pulumi.Input['SpotFleetMemoryMiBRequestArgs']]):
        pulumi.set(self, "memory_mi_b", value)

    @_builtins.property
    @pulumi.getter(name="networkBandwidthGbps")
    def network_bandwidth_gbps(self) -> Optional[pulumi.Input['SpotFleetNetworkBandwidthGbpsRequestArgs']]:
        """
        The minimum and maximum amount of baseline network bandwidth, in gigabits per second (Gbps). For more information, see [Amazon EC2 instance network bandwidth](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-network-bandwidth.html) in the *Amazon EC2 User Guide* .

        Default: No minimum or maximum limits
        """
        return pulumi.get(self, "network_bandwidth_gbps")

    @network_bandwidth_gbps.setter
    def network_bandwidth_gbps(self, value: Optional[pulumi.Input['SpotFleetNetworkBandwidthGbpsRequestArgs']]):
        pulumi.set(self, "network_bandwidth_gbps", value)

    @_builtins.property
    @pulumi.getter(name="networkInterfaceCount")
    def network_interface_count(self) -> Optional[pulumi.Input['SpotFleetNetworkInterfaceCountRequestArgs']]:
        """
        The minimum and maximum number of network interfaces.

        Default: No minimum or maximum limits
        """
        return pulumi.get(self, "network_interface_count")

    @network_interface_count.setter
    def network_interface_count(self, value: Optional[pulumi.Input['SpotFleetNetworkInterfaceCountRequestArgs']]):
        pulumi.set(self, "network_interface_count", value)

    @_builtins.property
    @pulumi.getter(name="onDemandMaxPricePercentageOverLowestPrice")
    def on_demand_max_price_percentage_over_lowest_price(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        [Price protection] The price protection threshold for On-Demand Instances, as a percentage higher than an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.

        The parameter accepts an integer, which Amazon EC2 interprets as a percentage.

        To indicate no price protection threshold, specify a high value, such as `999999` .

        This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) .

        > If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price. 

        Default: `20`
        """
        return pulumi.get(self, "on_demand_max_price_percentage_over_lowest_price")

    @on_demand_max_price_percentage_over_lowest_price.setter
    def on_demand_max_price_percentage_over_lowest_price(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "on_demand_max_price_percentage_over_lowest_price", value)

    @_builtins.property
    @pulumi.getter(name="requireHibernateSupport")
    def require_hibernate_support(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether instance types must support hibernation for On-Demand Instances.

        This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) .

        Default: `false`
        """
        return pulumi.get(self, "require_hibernate_support")

    @require_hibernate_support.setter
    def require_hibernate_support(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "require_hibernate_support", value)

    @_builtins.property
    @pulumi.getter(name="spotMaxPricePercentageOverLowestPrice")
    def spot_max_price_percentage_over_lowest_price(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        [Price protection] The price protection threshold for Spot Instances, as a percentage higher than an identified Spot price. The identified Spot price is the Spot price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified Spot price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose Spot price exceeds your specified threshold.

        The parameter accepts an integer, which Amazon EC2 interprets as a percentage.

        If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.

        This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) .

        > Only one of `SpotMaxPricePercentageOverLowestPrice` or `MaxSpotPriceAsPercentageOfOptimalOnDemandPrice` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as `999999` . 

        Default: `100`
        """
        return pulumi.get(self, "spot_max_price_percentage_over_lowest_price")

    @spot_max_price_percentage_over_lowest_price.setter
    def spot_max_price_percentage_over_lowest_price(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "spot_max_price_percentage_over_lowest_price", value)

    @_builtins.property
    @pulumi.getter(name="totalLocalStorageGb")
    def total_local_storage_gb(self) -> Optional[pulumi.Input['SpotFleetTotalLocalStorageGbRequestArgs']]:
        """
        The minimum and maximum amount of total local storage, in GB.

        Default: No minimum or maximum limits
        """
        return pulumi.get(self, "total_local_storage_gb")

    @total_local_storage_gb.setter
    def total_local_storage_gb(self, value: Optional[pulumi.Input['SpotFleetTotalLocalStorageGbRequestArgs']]):
        pulumi.set(self, "total_local_storage_gb", value)

    @_builtins.property
    @pulumi.getter(name="vCpuCount")
    def v_cpu_count(self) -> Optional[pulumi.Input['SpotFleetVCpuCountRangeRequestArgs']]:
        """
        The minimum and maximum number of vCPUs.
        """
        return pulumi.get(self, "v_cpu_count")

    @v_cpu_count.setter
    def v_cpu_count(self, value: Optional[pulumi.Input['SpotFleetVCpuCountRangeRequestArgs']]):
        pulumi.set(self, "v_cpu_count", value)


if not MYPY:
    class SpotFleetLaunchSpecificationArgsDict(TypedDict):
        image_id: pulumi.Input[_builtins.str]
        """
        The ID of the AMI.
        """
        block_device_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['SpotFleetBlockDeviceMappingArgsDict']]]]
        """
        One or more block devices that are mapped to the Spot Instances. You can't specify both a snapshot ID and an encryption value. This is because only blank volumes can be encrypted on creation. If a snapshot is the basis for a volume, it is not blank and its encryption status is used for the volume encryption status.
        """
        ebs_optimized: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the instances are optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.

        Default: `false`
        """
        iam_instance_profile: NotRequired[pulumi.Input['SpotFleetIamInstanceProfileSpecificationArgsDict']]
        """
        The IAM instance profile.
        """
        instance_requirements: NotRequired[pulumi.Input['SpotFleetInstanceRequirementsRequestArgsDict']]
        """
        The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with those attributes.

        > If you specify `InstanceRequirements` , you can't specify `InstanceType` .
        """
        instance_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The instance type.
        """
        kernel_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the kernel.
        """
        key_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the key pair.
        """
        monitoring: NotRequired[pulumi.Input['SpotFleetMonitoringArgsDict']]
        """
        Enable or disable monitoring for the instances.
        """
        network_interfaces: NotRequired[pulumi.Input[Sequence[pulumi.Input['SpotFleetInstanceNetworkInterfaceSpecificationArgsDict']]]]
        """
        The network interfaces.
        """
        placement: NotRequired[pulumi.Input['SpotFleetSpotPlacementArgsDict']]
        """
        The placement information.
        """
        ramdisk_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the RAM disk. Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, refer to the AWS Resource Center and search for the kernel ID.
        """
        security_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input['SpotFleetGroupIdentifierArgsDict']]]]
        """
        The security groups.

        If you specify a network interface, you must specify any security groups as part of the network interface instead of using this parameter.
        """
        spot_price: NotRequired[pulumi.Input[_builtins.str]]
        """
        The maximum price per unit hour that you are willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.

        > If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.
        """
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IDs of the subnets in which to launch the instances. To specify multiple subnets, separate them using commas; for example, "subnet-1234abcdeexample1, subnet-0987cdef6example2".

        If you specify a network interface, you must specify any subnets as part of the network interface instead of using this parameter.
        """
        tag_specifications: NotRequired[pulumi.Input[Sequence[pulumi.Input['SpotFleetTagSpecificationArgsDict']]]]
        """
        The tags to apply during creation.
        """
        user_data: NotRequired[pulumi.Input[_builtins.str]]
        """
        The base64-encoded user data that instances use when starting up. User data is limited to 16 KB.
        """
        weighted_capacity: NotRequired[pulumi.Input[_builtins.float]]
        """
        The number of units provided by the specified instance type. These are the same units that you chose to set the target capacity in terms of instances, or a performance characteristic such as vCPUs, memory, or I/O.

        If the target capacity divided by this value is not a whole number, Amazon EC2 rounds the number of instances to the next whole number. If this value is not specified, the default is 1.

        > When specifying weights, the price used in the `lowestPrice` and `priceCapacityOptimized` allocation strategies is per *unit* hour (where the instance price is divided by the specified weight). However, if all the specified weights are above the requested `TargetCapacity` , resulting in only 1 instance being launched, the price used is per *instance* hour.
        """
elif False:
    SpotFleetLaunchSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpotFleetLaunchSpecificationArgs:
    def __init__(__self__, *,
                 image_id: pulumi.Input[_builtins.str],
                 block_device_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetBlockDeviceMappingArgs']]]] = None,
                 ebs_optimized: Optional[pulumi.Input[_builtins.bool]] = None,
                 iam_instance_profile: Optional[pulumi.Input['SpotFleetIamInstanceProfileSpecificationArgs']] = None,
                 instance_requirements: Optional[pulumi.Input['SpotFleetInstanceRequirementsRequestArgs']] = None,
                 instance_type: Optional[pulumi.Input[_builtins.str]] = None,
                 kernel_id: Optional[pulumi.Input[_builtins.str]] = None,
                 key_name: Optional[pulumi.Input[_builtins.str]] = None,
                 monitoring: Optional[pulumi.Input['SpotFleetMonitoringArgs']] = None,
                 network_interfaces: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetInstanceNetworkInterfaceSpecificationArgs']]]] = None,
                 placement: Optional[pulumi.Input['SpotFleetSpotPlacementArgs']] = None,
                 ramdisk_id: Optional[pulumi.Input[_builtins.str]] = None,
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetGroupIdentifierArgs']]]] = None,
                 spot_price: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None,
                 tag_specifications: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetTagSpecificationArgs']]]] = None,
                 user_data: Optional[pulumi.Input[_builtins.str]] = None,
                 weighted_capacity: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] image_id: The ID of the AMI.
        :param pulumi.Input[Sequence[pulumi.Input['SpotFleetBlockDeviceMappingArgs']]] block_device_mappings: One or more block devices that are mapped to the Spot Instances. You can't specify both a snapshot ID and an encryption value. This is because only blank volumes can be encrypted on creation. If a snapshot is the basis for a volume, it is not blank and its encryption status is used for the volume encryption status.
        :param pulumi.Input[_builtins.bool] ebs_optimized: Indicates whether the instances are optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.
               
               Default: `false`
        :param pulumi.Input['SpotFleetIamInstanceProfileSpecificationArgs'] iam_instance_profile: The IAM instance profile.
        :param pulumi.Input['SpotFleetInstanceRequirementsRequestArgs'] instance_requirements: The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with those attributes.
               
               > If you specify `InstanceRequirements` , you can't specify `InstanceType` .
        :param pulumi.Input[_builtins.str] instance_type: The instance type.
        :param pulumi.Input[_builtins.str] kernel_id: The ID of the kernel.
        :param pulumi.Input[_builtins.str] key_name: The name of the key pair.
        :param pulumi.Input['SpotFleetMonitoringArgs'] monitoring: Enable or disable monitoring for the instances.
        :param pulumi.Input[Sequence[pulumi.Input['SpotFleetInstanceNetworkInterfaceSpecificationArgs']]] network_interfaces: The network interfaces.
        :param pulumi.Input['SpotFleetSpotPlacementArgs'] placement: The placement information.
        :param pulumi.Input[_builtins.str] ramdisk_id: The ID of the RAM disk. Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, refer to the AWS Resource Center and search for the kernel ID.
        :param pulumi.Input[Sequence[pulumi.Input['SpotFleetGroupIdentifierArgs']]] security_groups: The security groups.
               
               If you specify a network interface, you must specify any security groups as part of the network interface instead of using this parameter.
        :param pulumi.Input[_builtins.str] spot_price: The maximum price per unit hour that you are willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.
               
               > If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.
        :param pulumi.Input[_builtins.str] subnet_id: The IDs of the subnets in which to launch the instances. To specify multiple subnets, separate them using commas; for example, "subnet-1234abcdeexample1, subnet-0987cdef6example2".
               
               If you specify a network interface, you must specify any subnets as part of the network interface instead of using this parameter.
        :param pulumi.Input[Sequence[pulumi.Input['SpotFleetTagSpecificationArgs']]] tag_specifications: The tags to apply during creation.
        :param pulumi.Input[_builtins.str] user_data: The base64-encoded user data that instances use when starting up. User data is limited to 16 KB.
        :param pulumi.Input[_builtins.float] weighted_capacity: The number of units provided by the specified instance type. These are the same units that you chose to set the target capacity in terms of instances, or a performance characteristic such as vCPUs, memory, or I/O.
               
               If the target capacity divided by this value is not a whole number, Amazon EC2 rounds the number of instances to the next whole number. If this value is not specified, the default is 1.
               
               > When specifying weights, the price used in the `lowestPrice` and `priceCapacityOptimized` allocation strategies is per *unit* hour (where the instance price is divided by the specified weight). However, if all the specified weights are above the requested `TargetCapacity` , resulting in only 1 instance being launched, the price used is per *instance* hour.
        """
        pulumi.set(__self__, "image_id", image_id)
        if block_device_mappings is not None:
            pulumi.set(__self__, "block_device_mappings", block_device_mappings)
        if ebs_optimized is not None:
            pulumi.set(__self__, "ebs_optimized", ebs_optimized)
        if iam_instance_profile is not None:
            pulumi.set(__self__, "iam_instance_profile", iam_instance_profile)
        if instance_requirements is not None:
            pulumi.set(__self__, "instance_requirements", instance_requirements)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if kernel_id is not None:
            pulumi.set(__self__, "kernel_id", kernel_id)
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if monitoring is not None:
            pulumi.set(__self__, "monitoring", monitoring)
        if network_interfaces is not None:
            pulumi.set(__self__, "network_interfaces", network_interfaces)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if ramdisk_id is not None:
            pulumi.set(__self__, "ramdisk_id", ramdisk_id)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if spot_price is not None:
            pulumi.set(__self__, "spot_price", spot_price)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if tag_specifications is not None:
            pulumi.set(__self__, "tag_specifications", tag_specifications)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)
        if weighted_capacity is not None:
            pulumi.set(__self__, "weighted_capacity", weighted_capacity)

    @_builtins.property
    @pulumi.getter(name="imageId")
    def image_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the AMI.
        """
        return pulumi.get(self, "image_id")

    @image_id.setter
    def image_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "image_id", value)

    @_builtins.property
    @pulumi.getter(name="blockDeviceMappings")
    def block_device_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetBlockDeviceMappingArgs']]]]:
        """
        One or more block devices that are mapped to the Spot Instances. You can't specify both a snapshot ID and an encryption value. This is because only blank volumes can be encrypted on creation. If a snapshot is the basis for a volume, it is not blank and its encryption status is used for the volume encryption status.
        """
        return pulumi.get(self, "block_device_mappings")

    @block_device_mappings.setter
    def block_device_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetBlockDeviceMappingArgs']]]]):
        pulumi.set(self, "block_device_mappings", value)

    @_builtins.property
    @pulumi.getter(name="ebsOptimized")
    def ebs_optimized(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the instances are optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.

        Default: `false`
        """
        return pulumi.get(self, "ebs_optimized")

    @ebs_optimized.setter
    def ebs_optimized(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ebs_optimized", value)

    @_builtins.property
    @pulumi.getter(name="iamInstanceProfile")
    def iam_instance_profile(self) -> Optional[pulumi.Input['SpotFleetIamInstanceProfileSpecificationArgs']]:
        """
        The IAM instance profile.
        """
        return pulumi.get(self, "iam_instance_profile")

    @iam_instance_profile.setter
    def iam_instance_profile(self, value: Optional[pulumi.Input['SpotFleetIamInstanceProfileSpecificationArgs']]):
        pulumi.set(self, "iam_instance_profile", value)

    @_builtins.property
    @pulumi.getter(name="instanceRequirements")
    def instance_requirements(self) -> Optional[pulumi.Input['SpotFleetInstanceRequirementsRequestArgs']]:
        """
        The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with those attributes.

        > If you specify `InstanceRequirements` , you can't specify `InstanceType` .
        """
        return pulumi.get(self, "instance_requirements")

    @instance_requirements.setter
    def instance_requirements(self, value: Optional[pulumi.Input['SpotFleetInstanceRequirementsRequestArgs']]):
        pulumi.set(self, "instance_requirements", value)

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The instance type.
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_type", value)

    @_builtins.property
    @pulumi.getter(name="kernelId")
    def kernel_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the kernel.
        """
        return pulumi.get(self, "kernel_id")

    @kernel_id.setter
    def kernel_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kernel_id", value)

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the key pair.
        """
        return pulumi.get(self, "key_name")

    @key_name.setter
    def key_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_name", value)

    @_builtins.property
    @pulumi.getter
    def monitoring(self) -> Optional[pulumi.Input['SpotFleetMonitoringArgs']]:
        """
        Enable or disable monitoring for the instances.
        """
        return pulumi.get(self, "monitoring")

    @monitoring.setter
    def monitoring(self, value: Optional[pulumi.Input['SpotFleetMonitoringArgs']]):
        pulumi.set(self, "monitoring", value)

    @_builtins.property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetInstanceNetworkInterfaceSpecificationArgs']]]]:
        """
        The network interfaces.
        """
        return pulumi.get(self, "network_interfaces")

    @network_interfaces.setter
    def network_interfaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetInstanceNetworkInterfaceSpecificationArgs']]]]):
        pulumi.set(self, "network_interfaces", value)

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input['SpotFleetSpotPlacementArgs']]:
        """
        The placement information.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input['SpotFleetSpotPlacementArgs']]):
        pulumi.set(self, "placement", value)

    @_builtins.property
    @pulumi.getter(name="ramdiskId")
    def ramdisk_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the RAM disk. Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, refer to the AWS Resource Center and search for the kernel ID.
        """
        return pulumi.get(self, "ramdisk_id")

    @ramdisk_id.setter
    def ramdisk_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ramdisk_id", value)

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetGroupIdentifierArgs']]]]:
        """
        The security groups.

        If you specify a network interface, you must specify any security groups as part of the network interface instead of using this parameter.
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetGroupIdentifierArgs']]]]):
        pulumi.set(self, "security_groups", value)

    @_builtins.property
    @pulumi.getter(name="spotPrice")
    def spot_price(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The maximum price per unit hour that you are willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.

        > If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.
        """
        return pulumi.get(self, "spot_price")

    @spot_price.setter
    def spot_price(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "spot_price", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IDs of the subnets in which to launch the instances. To specify multiple subnets, separate them using commas; for example, "subnet-1234abcdeexample1, subnet-0987cdef6example2".

        If you specify a network interface, you must specify any subnets as part of the network interface instead of using this parameter.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)

    @_builtins.property
    @pulumi.getter(name="tagSpecifications")
    def tag_specifications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetTagSpecificationArgs']]]]:
        """
        The tags to apply during creation.
        """
        return pulumi.get(self, "tag_specifications")

    @tag_specifications.setter
    def tag_specifications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetTagSpecificationArgs']]]]):
        pulumi.set(self, "tag_specifications", value)

    @_builtins.property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The base64-encoded user data that instances use when starting up. User data is limited to 16 KB.
        """
        return pulumi.get(self, "user_data")

    @user_data.setter
    def user_data(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_data", value)

    @_builtins.property
    @pulumi.getter(name="weightedCapacity")
    def weighted_capacity(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The number of units provided by the specified instance type. These are the same units that you chose to set the target capacity in terms of instances, or a performance characteristic such as vCPUs, memory, or I/O.

        If the target capacity divided by this value is not a whole number, Amazon EC2 rounds the number of instances to the next whole number. If this value is not specified, the default is 1.

        > When specifying weights, the price used in the `lowestPrice` and `priceCapacityOptimized` allocation strategies is per *unit* hour (where the instance price is divided by the specified weight). However, if all the specified weights are above the requested `TargetCapacity` , resulting in only 1 instance being launched, the price used is per *instance* hour.
        """
        return pulumi.get(self, "weighted_capacity")

    @weighted_capacity.setter
    def weighted_capacity(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "weighted_capacity", value)


if not MYPY:
    class SpotFleetLaunchTemplateConfigArgsDict(TypedDict):
        launch_template_specification: NotRequired[pulumi.Input['SpotFleetFleetLaunchTemplateSpecificationArgsDict']]
        """
        The launch template to use. Make sure that the launch template does not contain the `NetworkInterfaceId` parameter because you can't specify a network interface ID in a Spot Fleet.
        """
        overrides: NotRequired[pulumi.Input[Sequence[pulumi.Input['SpotFleetLaunchTemplateOverridesArgsDict']]]]
        """
        Any parameters that you specify override the same parameters in the launch template.
        """
elif False:
    SpotFleetLaunchTemplateConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpotFleetLaunchTemplateConfigArgs:
    def __init__(__self__, *,
                 launch_template_specification: Optional[pulumi.Input['SpotFleetFleetLaunchTemplateSpecificationArgs']] = None,
                 overrides: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetLaunchTemplateOverridesArgs']]]] = None):
        """
        :param pulumi.Input['SpotFleetFleetLaunchTemplateSpecificationArgs'] launch_template_specification: The launch template to use. Make sure that the launch template does not contain the `NetworkInterfaceId` parameter because you can't specify a network interface ID in a Spot Fleet.
        :param pulumi.Input[Sequence[pulumi.Input['SpotFleetLaunchTemplateOverridesArgs']]] overrides: Any parameters that you specify override the same parameters in the launch template.
        """
        if launch_template_specification is not None:
            pulumi.set(__self__, "launch_template_specification", launch_template_specification)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)

    @_builtins.property
    @pulumi.getter(name="launchTemplateSpecification")
    def launch_template_specification(self) -> Optional[pulumi.Input['SpotFleetFleetLaunchTemplateSpecificationArgs']]:
        """
        The launch template to use. Make sure that the launch template does not contain the `NetworkInterfaceId` parameter because you can't specify a network interface ID in a Spot Fleet.
        """
        return pulumi.get(self, "launch_template_specification")

    @launch_template_specification.setter
    def launch_template_specification(self, value: Optional[pulumi.Input['SpotFleetFleetLaunchTemplateSpecificationArgs']]):
        pulumi.set(self, "launch_template_specification", value)

    @_builtins.property
    @pulumi.getter
    def overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetLaunchTemplateOverridesArgs']]]]:
        """
        Any parameters that you specify override the same parameters in the launch template.
        """
        return pulumi.get(self, "overrides")

    @overrides.setter
    def overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetLaunchTemplateOverridesArgs']]]]):
        pulumi.set(self, "overrides", value)


if not MYPY:
    class SpotFleetLaunchTemplateOverridesArgsDict(TypedDict):
        availability_zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Availability Zone in which to launch the instances.
        """
        instance_requirements: NotRequired[pulumi.Input['SpotFleetInstanceRequirementsRequestArgsDict']]
        """
        The instance requirements. When you specify instance requirements, Amazon EC2 will identify instance types with the provided requirements, and then use your On-Demand and Spot allocation strategies to launch instances from these instance types, in the same way as when you specify a list of instance types.

        > If you specify `InstanceRequirements` , you can't specify `InstanceType` .
        """
        instance_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The instance type.
        """
        priority: NotRequired[pulumi.Input[_builtins.float]]
        """
        The priority for the launch template override. The highest priority is launched first.

        If `OnDemandAllocationStrategy` is set to `prioritized` , Spot Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity.

        If the Spot `AllocationStrategy` is set to `capacityOptimizedPrioritized` , Spot Fleet uses priority on a best-effort basis to determine which launch template override to use in fulfilling Spot capacity, but optimizes for capacity first.

        Valid values are whole numbers starting at `0` . The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority. You can set the same priority for different launch template overrides.
        """
        spot_price: NotRequired[pulumi.Input[_builtins.str]]
        """
        The maximum price per unit hour that you are willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.

        > If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.
        """
        subnet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the subnet in which to launch the instances.
        """
        weighted_capacity: NotRequired[pulumi.Input[_builtins.float]]
        """
        The number of units provided by the specified instance type. These are the same units that you chose to set the target capacity in terms of instances, or a performance characteristic such as vCPUs, memory, or I/O.

        If the target capacity divided by this value is not a whole number, Amazon EC2 rounds the number of instances to the next whole number. If this value is not specified, the default is 1.

        > When specifying weights, the price used in the `lowestPrice` and `priceCapacityOptimized` allocation strategies is per *unit* hour (where the instance price is divided by the specified weight). However, if all the specified weights are above the requested `TargetCapacity` , resulting in only 1 instance being launched, the price used is per *instance* hour.
        """
elif False:
    SpotFleetLaunchTemplateOverridesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpotFleetLaunchTemplateOverridesArgs:
    def __init__(__self__, *,
                 availability_zone: Optional[pulumi.Input[_builtins.str]] = None,
                 instance_requirements: Optional[pulumi.Input['SpotFleetInstanceRequirementsRequestArgs']] = None,
                 instance_type: Optional[pulumi.Input[_builtins.str]] = None,
                 priority: Optional[pulumi.Input[_builtins.float]] = None,
                 spot_price: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet_id: Optional[pulumi.Input[_builtins.str]] = None,
                 weighted_capacity: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] availability_zone: The Availability Zone in which to launch the instances.
        :param pulumi.Input['SpotFleetInstanceRequirementsRequestArgs'] instance_requirements: The instance requirements. When you specify instance requirements, Amazon EC2 will identify instance types with the provided requirements, and then use your On-Demand and Spot allocation strategies to launch instances from these instance types, in the same way as when you specify a list of instance types.
               
               > If you specify `InstanceRequirements` , you can't specify `InstanceType` .
        :param pulumi.Input[_builtins.str] instance_type: The instance type.
        :param pulumi.Input[_builtins.float] priority: The priority for the launch template override. The highest priority is launched first.
               
               If `OnDemandAllocationStrategy` is set to `prioritized` , Spot Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity.
               
               If the Spot `AllocationStrategy` is set to `capacityOptimizedPrioritized` , Spot Fleet uses priority on a best-effort basis to determine which launch template override to use in fulfilling Spot capacity, but optimizes for capacity first.
               
               Valid values are whole numbers starting at `0` . The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority. You can set the same priority for different launch template overrides.
        :param pulumi.Input[_builtins.str] spot_price: The maximum price per unit hour that you are willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.
               
               > If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.
        :param pulumi.Input[_builtins.str] subnet_id: The ID of the subnet in which to launch the instances.
        :param pulumi.Input[_builtins.float] weighted_capacity: The number of units provided by the specified instance type. These are the same units that you chose to set the target capacity in terms of instances, or a performance characteristic such as vCPUs, memory, or I/O.
               
               If the target capacity divided by this value is not a whole number, Amazon EC2 rounds the number of instances to the next whole number. If this value is not specified, the default is 1.
               
               > When specifying weights, the price used in the `lowestPrice` and `priceCapacityOptimized` allocation strategies is per *unit* hour (where the instance price is divided by the specified weight). However, if all the specified weights are above the requested `TargetCapacity` , resulting in only 1 instance being launched, the price used is per *instance* hour.
        """
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if instance_requirements is not None:
            pulumi.set(__self__, "instance_requirements", instance_requirements)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if spot_price is not None:
            pulumi.set(__self__, "spot_price", spot_price)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if weighted_capacity is not None:
            pulumi.set(__self__, "weighted_capacity", weighted_capacity)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Availability Zone in which to launch the instances.
        """
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "availability_zone", value)

    @_builtins.property
    @pulumi.getter(name="instanceRequirements")
    def instance_requirements(self) -> Optional[pulumi.Input['SpotFleetInstanceRequirementsRequestArgs']]:
        """
        The instance requirements. When you specify instance requirements, Amazon EC2 will identify instance types with the provided requirements, and then use your On-Demand and Spot allocation strategies to launch instances from these instance types, in the same way as when you specify a list of instance types.

        > If you specify `InstanceRequirements` , you can't specify `InstanceType` .
        """
        return pulumi.get(self, "instance_requirements")

    @instance_requirements.setter
    def instance_requirements(self, value: Optional[pulumi.Input['SpotFleetInstanceRequirementsRequestArgs']]):
        pulumi.set(self, "instance_requirements", value)

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The instance type.
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_type", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The priority for the launch template override. The highest priority is launched first.

        If `OnDemandAllocationStrategy` is set to `prioritized` , Spot Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity.

        If the Spot `AllocationStrategy` is set to `capacityOptimizedPrioritized` , Spot Fleet uses priority on a best-effort basis to determine which launch template override to use in fulfilling Spot capacity, but optimizes for capacity first.

        Valid values are whole numbers starting at `0` . The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority. You can set the same priority for different launch template overrides.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter(name="spotPrice")
    def spot_price(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The maximum price per unit hour that you are willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.

        > If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.
        """
        return pulumi.get(self, "spot_price")

    @spot_price.setter
    def spot_price(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "spot_price", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the subnet in which to launch the instances.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet_id", value)

    @_builtins.property
    @pulumi.getter(name="weightedCapacity")
    def weighted_capacity(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The number of units provided by the specified instance type. These are the same units that you chose to set the target capacity in terms of instances, or a performance characteristic such as vCPUs, memory, or I/O.

        If the target capacity divided by this value is not a whole number, Amazon EC2 rounds the number of instances to the next whole number. If this value is not specified, the default is 1.

        > When specifying weights, the price used in the `lowestPrice` and `priceCapacityOptimized` allocation strategies is per *unit* hour (where the instance price is divided by the specified weight). However, if all the specified weights are above the requested `TargetCapacity` , resulting in only 1 instance being launched, the price used is per *instance* hour.
        """
        return pulumi.get(self, "weighted_capacity")

    @weighted_capacity.setter
    def weighted_capacity(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "weighted_capacity", value)


if not MYPY:
    class SpotFleetLoadBalancersConfigArgsDict(TypedDict):
        classic_load_balancers_config: NotRequired[pulumi.Input['SpotFleetClassicLoadBalancersConfigArgsDict']]
        """
        The Classic Load Balancers.
        """
        target_groups_config: NotRequired[pulumi.Input['SpotFleetTargetGroupsConfigArgsDict']]
        """
        The target groups.
        """
elif False:
    SpotFleetLoadBalancersConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpotFleetLoadBalancersConfigArgs:
    def __init__(__self__, *,
                 classic_load_balancers_config: Optional[pulumi.Input['SpotFleetClassicLoadBalancersConfigArgs']] = None,
                 target_groups_config: Optional[pulumi.Input['SpotFleetTargetGroupsConfigArgs']] = None):
        """
        :param pulumi.Input['SpotFleetClassicLoadBalancersConfigArgs'] classic_load_balancers_config: The Classic Load Balancers.
        :param pulumi.Input['SpotFleetTargetGroupsConfigArgs'] target_groups_config: The target groups.
        """
        if classic_load_balancers_config is not None:
            pulumi.set(__self__, "classic_load_balancers_config", classic_load_balancers_config)
        if target_groups_config is not None:
            pulumi.set(__self__, "target_groups_config", target_groups_config)

    @_builtins.property
    @pulumi.getter(name="classicLoadBalancersConfig")
    def classic_load_balancers_config(self) -> Optional[pulumi.Input['SpotFleetClassicLoadBalancersConfigArgs']]:
        """
        The Classic Load Balancers.
        """
        return pulumi.get(self, "classic_load_balancers_config")

    @classic_load_balancers_config.setter
    def classic_load_balancers_config(self, value: Optional[pulumi.Input['SpotFleetClassicLoadBalancersConfigArgs']]):
        pulumi.set(self, "classic_load_balancers_config", value)

    @_builtins.property
    @pulumi.getter(name="targetGroupsConfig")
    def target_groups_config(self) -> Optional[pulumi.Input['SpotFleetTargetGroupsConfigArgs']]:
        """
        The target groups.
        """
        return pulumi.get(self, "target_groups_config")

    @target_groups_config.setter
    def target_groups_config(self, value: Optional[pulumi.Input['SpotFleetTargetGroupsConfigArgs']]):
        pulumi.set(self, "target_groups_config", value)


if not MYPY:
    class SpotFleetMemoryGiBPerVCpuRequestArgsDict(TypedDict):
        max: NotRequired[pulumi.Input[_builtins.float]]
        """
        The maximum amount of memory per vCPU, in GiB. To specify no maximum limit, omit this parameter.
        """
        min: NotRequired[pulumi.Input[_builtins.float]]
        """
        The minimum amount of memory per vCPU, in GiB. To specify no minimum limit, omit this parameter.
        """
elif False:
    SpotFleetMemoryGiBPerVCpuRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpotFleetMemoryGiBPerVCpuRequestArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[_builtins.float]] = None,
                 min: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] max: The maximum amount of memory per vCPU, in GiB. To specify no maximum limit, omit this parameter.
        :param pulumi.Input[_builtins.float] min: The minimum amount of memory per vCPU, in GiB. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The maximum amount of memory per vCPU, in GiB. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The minimum amount of memory per vCPU, in GiB. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class SpotFleetMemoryMiBRequestArgsDict(TypedDict):
        max: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum amount of memory, in MiB. To specify no maximum limit, omit this parameter.
        """
        min: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum amount of memory, in MiB. To specify no minimum limit, specify `0` .
        """
elif False:
    SpotFleetMemoryMiBRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpotFleetMemoryMiBRequestArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[_builtins.int]] = None,
                 min: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] max: The maximum amount of memory, in MiB. To specify no maximum limit, omit this parameter.
        :param pulumi.Input[_builtins.int] min: The minimum amount of memory, in MiB. To specify no minimum limit, specify `0` .
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum amount of memory, in MiB. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum amount of memory, in MiB. To specify no minimum limit, specify `0` .
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class SpotFleetMonitoringArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables monitoring for the instance.

        Default: `false`
        """
elif False:
    SpotFleetMonitoringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpotFleetMonitoringArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enables monitoring for the instance.
               
               Default: `false`
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables monitoring for the instance.

        Default: `false`
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class SpotFleetNetworkBandwidthGbpsRequestArgsDict(TypedDict):
        max: NotRequired[pulumi.Input[_builtins.float]]
        """
        The maximum amount of network bandwidth, in Gbps. To specify no maximum limit, omit this parameter.
        """
        min: NotRequired[pulumi.Input[_builtins.float]]
        """
        The minimum amount of network bandwidth, in Gbps. To specify no minimum limit, omit this parameter.
        """
elif False:
    SpotFleetNetworkBandwidthGbpsRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpotFleetNetworkBandwidthGbpsRequestArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[_builtins.float]] = None,
                 min: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] max: The maximum amount of network bandwidth, in Gbps. To specify no maximum limit, omit this parameter.
        :param pulumi.Input[_builtins.float] min: The minimum amount of network bandwidth, in Gbps. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The maximum amount of network bandwidth, in Gbps. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The minimum amount of network bandwidth, in Gbps. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class SpotFleetNetworkInterfaceCountRequestArgsDict(TypedDict):
        max: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum number of network interfaces. To specify no maximum limit, omit this parameter.
        """
        min: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum number of network interfaces. To specify no minimum limit, omit this parameter.
        """
elif False:
    SpotFleetNetworkInterfaceCountRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpotFleetNetworkInterfaceCountRequestArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[_builtins.int]] = None,
                 min: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] max: The maximum number of network interfaces. To specify no maximum limit, omit this parameter.
        :param pulumi.Input[_builtins.int] min: The minimum number of network interfaces. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum number of network interfaces. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum number of network interfaces. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class SpotFleetPerformanceFactorReferenceRequestArgsDict(TypedDict):
        instance_family: NotRequired[pulumi.Input[_builtins.str]]
        """
        The instance family to use as a baseline reference.

        > Ensure that you specify the correct value for the instance family. The instance family is everything before the period ( `.` ) in the instance type name. For example, in the instance type `c6i.large` , the instance family is `c6i` , not `c6` . For more information, see [Amazon EC2 instance type naming conventions](https://docs.aws.amazon.com/ec2/latest/instancetypes/instance-type-names.html) in *Amazon EC2 Instance Types* . 

        The following instance families are *not supported* for performance protection:

        - `c1`
        - `g3` | `g3s`
        - `hpc7g`
        - `m1` | `m2`
        - `mac1` | `mac2` | `mac2-m1ultra` | `mac2-m2` | `mac2-m2pro`
        - `p3dn` | `p4d` | `p5`
        - `t1`
        - `u-12tb1` | `u-18tb1` | `u-24tb1` | `u-3tb1` | `u-6tb1` | `u-9tb1` | `u7i-12tb` | `u7in-16tb` | `u7in-24tb` | `u7in-32tb`

        If you enable performance protection by specifying a supported instance family, the returned instance types will exclude the above unsupported instance families.

        If you specify an unsupported instance family as a value for baseline performance, the API returns an empty response for [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) and an exception for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet.html) , [RequestSpotFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotFleet.html) , [ModifyFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyFleet.html) , and [ModifySpotFleetRequest](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifySpotFleetRequest.html) .
        """
elif False:
    SpotFleetPerformanceFactorReferenceRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpotFleetPerformanceFactorReferenceRequestArgs:
    def __init__(__self__, *,
                 instance_family: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] instance_family: The instance family to use as a baseline reference.
               
               > Ensure that you specify the correct value for the instance family. The instance family is everything before the period ( `.` ) in the instance type name. For example, in the instance type `c6i.large` , the instance family is `c6i` , not `c6` . For more information, see [Amazon EC2 instance type naming conventions](https://docs.aws.amazon.com/ec2/latest/instancetypes/instance-type-names.html) in *Amazon EC2 Instance Types* . 
               
               The following instance families are *not supported* for performance protection:
               
               - `c1`
               - `g3` | `g3s`
               - `hpc7g`
               - `m1` | `m2`
               - `mac1` | `mac2` | `mac2-m1ultra` | `mac2-m2` | `mac2-m2pro`
               - `p3dn` | `p4d` | `p5`
               - `t1`
               - `u-12tb1` | `u-18tb1` | `u-24tb1` | `u-3tb1` | `u-6tb1` | `u-9tb1` | `u7i-12tb` | `u7in-16tb` | `u7in-24tb` | `u7in-32tb`
               
               If you enable performance protection by specifying a supported instance family, the returned instance types will exclude the above unsupported instance families.
               
               If you specify an unsupported instance family as a value for baseline performance, the API returns an empty response for [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) and an exception for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet.html) , [RequestSpotFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotFleet.html) , [ModifyFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyFleet.html) , and [ModifySpotFleetRequest](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifySpotFleetRequest.html) .
        """
        if instance_family is not None:
            pulumi.set(__self__, "instance_family", instance_family)

    @_builtins.property
    @pulumi.getter(name="instanceFamily")
    def instance_family(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The instance family to use as a baseline reference.

        > Ensure that you specify the correct value for the instance family. The instance family is everything before the period ( `.` ) in the instance type name. For example, in the instance type `c6i.large` , the instance family is `c6i` , not `c6` . For more information, see [Amazon EC2 instance type naming conventions](https://docs.aws.amazon.com/ec2/latest/instancetypes/instance-type-names.html) in *Amazon EC2 Instance Types* . 

        The following instance families are *not supported* for performance protection:

        - `c1`
        - `g3` | `g3s`
        - `hpc7g`
        - `m1` | `m2`
        - `mac1` | `mac2` | `mac2-m1ultra` | `mac2-m2` | `mac2-m2pro`
        - `p3dn` | `p4d` | `p5`
        - `t1`
        - `u-12tb1` | `u-18tb1` | `u-24tb1` | `u-3tb1` | `u-6tb1` | `u-9tb1` | `u7i-12tb` | `u7in-16tb` | `u7in-24tb` | `u7in-32tb`

        If you enable performance protection by specifying a supported instance family, the returned instance types will exclude the above unsupported instance families.

        If you specify an unsupported instance family as a value for baseline performance, the API returns an empty response for [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) and an exception for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet.html) , [RequestSpotFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotFleet.html) , [ModifyFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyFleet.html) , and [ModifySpotFleetRequest](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifySpotFleetRequest.html) .
        """
        return pulumi.get(self, "instance_family")

    @instance_family.setter
    def instance_family(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_family", value)


if not MYPY:
    class SpotFleetPrivateIpAddressSpecificationArgsDict(TypedDict):
        private_ip_address: pulumi.Input[_builtins.str]
        """
        The private IPv4 address.
        """
        primary: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.
        """
elif False:
    SpotFleetPrivateIpAddressSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpotFleetPrivateIpAddressSpecificationArgs:
    def __init__(__self__, *,
                 private_ip_address: pulumi.Input[_builtins.str],
                 primary: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] private_ip_address: The private IPv4 address.
        :param pulumi.Input[_builtins.bool] primary: Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.
        """
        pulumi.set(__self__, "private_ip_address", private_ip_address)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)

    @_builtins.property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> pulumi.Input[_builtins.str]:
        """
        The private IPv4 address.
        """
        return pulumi.get(self, "private_ip_address")

    @private_ip_address.setter
    def private_ip_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "private_ip_address", value)

    @_builtins.property
    @pulumi.getter
    def primary(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.
        """
        return pulumi.get(self, "primary")

    @primary.setter
    def primary(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "primary", value)


if not MYPY:
    class SpotFleetRequestConfigDataArgsDict(TypedDict):
        iam_fleet_role: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role that grants the Spot Fleet the permission to request, launch, terminate, and tag instances on your behalf. For more information, see [Spot Fleet Prerequisites](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-requests.html#spot-fleet-prerequisites) in the *Amazon EC2 User Guide* . Spot Fleet can terminate Spot Instances on your behalf when you cancel its Spot Fleet request or when the Spot Fleet request expires, if you set `TerminateInstancesWithExpiration` .
        """
        target_capacity: pulumi.Input[_builtins.int]
        """
        The number of units to request for the Spot Fleet. You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is `maintain` , you can specify a target capacity of 0 and add capacity later.
        """
        allocation_strategy: NotRequired[pulumi.Input['SpotFleetRequestConfigDataAllocationStrategy']]
        """
        The strategy that determines how to allocate the target Spot Instance capacity across the Spot Instance pools specified by the Spot Fleet launch configuration. For more information, see [Allocation strategies for Spot Instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-allocation-strategy.html) in the *Amazon EC2 User Guide* .

        - **priceCapacityOptimized (recommended)** - Spot Fleet identifies the pools with the highest capacity availability for the number of instances that are launching. This means that we will request Spot Instances from the pools that we believe have the lowest chance of interruption in the near term. Spot Fleet then requests Spot Instances from the lowest priced of these pools.
        - **capacityOptimized** - Spot Fleet identifies the pools with the highest capacity availability for the number of instances that are launching. This means that we will request Spot Instances from the pools that we believe have the lowest chance of interruption in the near term. To give certain instance types a higher chance of launching first, use `capacityOptimizedPrioritized` . Set a priority for each instance type by using the `Priority` parameter for `LaunchTemplateOverrides` . You can assign the same priority to different `LaunchTemplateOverrides` . EC2 implements the priorities on a best-effort basis, but optimizes for capacity first. `capacityOptimizedPrioritized` is supported only if your Spot Fleet uses a launch template. Note that if the `OnDemandAllocationStrategy` is set to `prioritized` , the same priority is applied when fulfilling On-Demand capacity.
        - **diversified** - Spot Fleet requests instances from all of the Spot Instance pools that you specify.
        - **lowestPrice (not recommended)** - > We don't recommend the `lowestPrice` allocation strategy because it has the highest risk of interruption for your Spot Instances. 

        Spot Fleet requests instances from the lowest priced Spot Instance pool that has available capacity. If the lowest priced pool doesn't have available capacity, the Spot Instances come from the next lowest priced pool that has available capacity. If a pool runs out of capacity before fulfilling your desired capacity, Spot Fleet will continue to fulfill your request by drawing from the next lowest priced pool. To ensure that your desired capacity is met, you might receive Spot Instances from several pools. Because this strategy only considers instance price and not capacity availability, it might lead to high interruption rates.

        Default: `lowestPrice`
        """
        context: NotRequired[pulumi.Input[_builtins.str]]
        """
        Reserved.
        """
        excess_capacity_termination_policy: NotRequired[pulumi.Input['SpotFleetRequestConfigDataExcessCapacityTerminationPolicy']]
        """
        Indicates whether running Spot Instances should be terminated if you decrease the target capacity of the Spot Fleet request below the current size of the Spot Fleet.

        Supported only for fleets of type `maintain` .
        """
        instance_interruption_behavior: NotRequired[pulumi.Input['SpotFleetRequestConfigDataInstanceInterruptionBehavior']]
        """
        The behavior when a Spot Instance is interrupted. The default is `terminate` .
        """
        instance_pools_to_use_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of Spot pools across which to allocate your target Spot capacity. Valid only when Spot *AllocationStrategy* is set to `lowest-price` . Spot Fleet selects the cheapest Spot pools and evenly allocates your target Spot capacity across the number of Spot pools that you specify.

        Note that Spot Fleet attempts to draw Spot Instances from the number of pools that you specify on a best effort basis. If a pool runs out of Spot capacity before fulfilling your target capacity, Spot Fleet will continue to fulfill your request by drawing from the next cheapest pool. To ensure that your target capacity is met, you might receive Spot Instances from more than the number of pools that you specified. Similarly, if most of the pools have no Spot capacity, you might receive your full target capacity from fewer than the number of pools that you specified.
        """
        launch_specifications: NotRequired[pulumi.Input[Sequence[pulumi.Input['SpotFleetLaunchSpecificationArgsDict']]]]
        """
        The launch specifications for the Spot Fleet request. If you specify `LaunchSpecifications` , you can't specify `LaunchTemplateConfigs` .
        """
        launch_template_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['SpotFleetLaunchTemplateConfigArgsDict']]]]
        """
        The launch template and overrides. If you specify `LaunchTemplateConfigs` , you can't specify `LaunchSpecifications` .
        """
        load_balancers_config: NotRequired[pulumi.Input['SpotFleetLoadBalancersConfigArgsDict']]
        """
        One or more Classic Load Balancers and target groups to attach to the Spot Fleet request. Spot Fleet registers the running Spot Instances with the specified Classic Load Balancers and target groups.

        With Network Load Balancers, Spot Fleet cannot register instances that have the following instance types: C1, CC1, CC2, CG1, CG2, CR1, CS1, G1, G2, HI1, HS1, M1, M2, M3, and T1.
        """
        on_demand_allocation_strategy: NotRequired[pulumi.Input[_builtins.str]]
        """
        The order of the launch template overrides to use in fulfilling On-Demand capacity. If you specify `lowestPrice` , Spot Fleet uses price to determine the order, launching the lowest price first. If you specify `prioritized` , Spot Fleet uses the priority that you assign to each Spot Fleet launch template override, launching the highest priority first. If you do not specify a value, Spot Fleet defaults to `lowestPrice` .
        """
        on_demand_max_total_price: NotRequired[pulumi.Input[_builtins.str]]
        """
        The maximum amount per hour for On-Demand Instances that you're willing to pay. You can use the `onDemandMaxTotalPrice` parameter, the `spotMaxTotalPrice` parameter, or both parameters to ensure that your fleet cost does not exceed your budget. If you set a maximum price per hour for the On-Demand Instances and Spot Instances in your request, Spot Fleet will launch instances until it reaches the maximum amount you're willing to pay. When the maximum amount you're willing to pay is reached, the fleet stops launching instances even if it hasnt met the target capacity.

        > If your fleet includes T instances that are configured as `unlimited` , and if their average CPU usage exceeds the baseline utilization, you will incur a charge for surplus credits. The `onDemandMaxTotalPrice` does not account for surplus credits, and, if you use surplus credits, your final cost might be higher than what you specified for `onDemandMaxTotalPrice` . For more information, see [Surplus credits can incur charges](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-unlimited-mode-concepts.html#unlimited-mode-surplus-credits) in the *Amazon EC2 User Guide* .
        """
        on_demand_target_capacity: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of On-Demand units to request. You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is `maintain` , you can specify a target capacity of 0 and add capacity later.
        """
        replace_unhealthy_instances: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether Spot Fleet should replace unhealthy instances.
        """
        spot_maintenance_strategies: NotRequired[pulumi.Input['SpotFleetSpotMaintenanceStrategiesArgsDict']]
        """
        The strategies for managing your Spot Instances that are at an elevated risk of being interrupted.
        """
        spot_max_total_price: NotRequired[pulumi.Input[_builtins.str]]
        """
        The maximum amount per hour for Spot Instances that you're willing to pay. You can use the `spotMaxTotalPrice` parameter, the `onDemandMaxTotalPrice` parameter, or both parameters to ensure that your fleet cost does not exceed your budget. If you set a maximum price per hour for the On-Demand Instances and Spot Instances in your request, Spot Fleet will launch instances until it reaches the maximum amount you're willing to pay. When the maximum amount you're willing to pay is reached, the fleet stops launching instances even if it hasnt met the target capacity.

        > If your fleet includes T instances that are configured as `unlimited` , and if their average CPU usage exceeds the baseline utilization, you will incur a charge for surplus credits. The `spotMaxTotalPrice` does not account for surplus credits, and, if you use surplus credits, your final cost might be higher than what you specified for `spotMaxTotalPrice` . For more information, see [Surplus credits can incur charges](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-unlimited-mode-concepts.html#unlimited-mode-surplus-credits) in the *Amazon EC2 User Guide* .
        """
        spot_price: NotRequired[pulumi.Input[_builtins.str]]
        """
        The maximum price per unit hour that you are willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.

        > If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.
        """
        tag_specifications: NotRequired[pulumi.Input[Sequence[pulumi.Input['SpotFleetTagSpecificationArgsDict']]]]
        """
        The key-value pair for tagging the Spot Fleet request on creation. The value for `ResourceType` must be `spot-fleet-request` , otherwise the Spot Fleet request fails. To tag instances at launch, specify the tags in the [launch template](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#create-launch-template) (valid only if you use `LaunchTemplateConfigs` ) or in the `[SpotFleetTagSpecification](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SpotFleetTagSpecification.html)` (valid only if you use `LaunchSpecifications` ). For information about tagging after launch, see [Tag your resources](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#tag-resources) .
        """
        target_capacity_unit_type: NotRequired[pulumi.Input['SpotFleetRequestConfigDataTargetCapacityUnitType']]
        """
        The unit for the target capacity. You can specify this parameter only when using attribute-based instance type selection.

        Default: `units` (the number of instances)
        """
        terminate_instances_with_expiration: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether running Spot Instances are terminated when the Spot Fleet request expires.
        """
        type: NotRequired[pulumi.Input['SpotFleetRequestConfigDataType']]
        """
        The type of request. Indicates whether the Spot Fleet only requests the target capacity or also attempts to maintain it. When this value is `request` , the Spot Fleet only places the required requests. It does not attempt to replenish Spot Instances if capacity is diminished, nor does it submit requests in alternative Spot pools if capacity is not available. When this value is `maintain` , the Spot Fleet maintains the target capacity. The Spot Fleet places the required requests to meet capacity and automatically replenishes any interrupted instances. Default: `maintain` . `instant` is listed but is not used by Spot Fleet.
        """
        valid_from: NotRequired[pulumi.Input[_builtins.str]]
        """
        The start date and time of the request, in UTC format ( *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z). By default, Amazon EC2 starts fulfilling the request immediately.
        """
        valid_until: NotRequired[pulumi.Input[_builtins.str]]
        """
        The end date and time of the request, in UTC format ( *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z). After the end date and time, no new Spot Instance requests are placed or able to fulfill the request. If no value is specified, the Spot Fleet request remains until you cancel it.
        """
elif False:
    SpotFleetRequestConfigDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpotFleetRequestConfigDataArgs:
    def __init__(__self__, *,
                 iam_fleet_role: pulumi.Input[_builtins.str],
                 target_capacity: pulumi.Input[_builtins.int],
                 allocation_strategy: Optional[pulumi.Input['SpotFleetRequestConfigDataAllocationStrategy']] = None,
                 context: Optional[pulumi.Input[_builtins.str]] = None,
                 excess_capacity_termination_policy: Optional[pulumi.Input['SpotFleetRequestConfigDataExcessCapacityTerminationPolicy']] = None,
                 instance_interruption_behavior: Optional[pulumi.Input['SpotFleetRequestConfigDataInstanceInterruptionBehavior']] = None,
                 instance_pools_to_use_count: Optional[pulumi.Input[_builtins.int]] = None,
                 launch_specifications: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetLaunchSpecificationArgs']]]] = None,
                 launch_template_configs: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetLaunchTemplateConfigArgs']]]] = None,
                 load_balancers_config: Optional[pulumi.Input['SpotFleetLoadBalancersConfigArgs']] = None,
                 on_demand_allocation_strategy: Optional[pulumi.Input[_builtins.str]] = None,
                 on_demand_max_total_price: Optional[pulumi.Input[_builtins.str]] = None,
                 on_demand_target_capacity: Optional[pulumi.Input[_builtins.int]] = None,
                 replace_unhealthy_instances: Optional[pulumi.Input[_builtins.bool]] = None,
                 spot_maintenance_strategies: Optional[pulumi.Input['SpotFleetSpotMaintenanceStrategiesArgs']] = None,
                 spot_max_total_price: Optional[pulumi.Input[_builtins.str]] = None,
                 spot_price: Optional[pulumi.Input[_builtins.str]] = None,
                 tag_specifications: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetTagSpecificationArgs']]]] = None,
                 target_capacity_unit_type: Optional[pulumi.Input['SpotFleetRequestConfigDataTargetCapacityUnitType']] = None,
                 terminate_instances_with_expiration: Optional[pulumi.Input[_builtins.bool]] = None,
                 type: Optional[pulumi.Input['SpotFleetRequestConfigDataType']] = None,
                 valid_from: Optional[pulumi.Input[_builtins.str]] = None,
                 valid_until: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] iam_fleet_role: The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role that grants the Spot Fleet the permission to request, launch, terminate, and tag instances on your behalf. For more information, see [Spot Fleet Prerequisites](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-requests.html#spot-fleet-prerequisites) in the *Amazon EC2 User Guide* . Spot Fleet can terminate Spot Instances on your behalf when you cancel its Spot Fleet request or when the Spot Fleet request expires, if you set `TerminateInstancesWithExpiration` .
        :param pulumi.Input[_builtins.int] target_capacity: The number of units to request for the Spot Fleet. You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is `maintain` , you can specify a target capacity of 0 and add capacity later.
        :param pulumi.Input['SpotFleetRequestConfigDataAllocationStrategy'] allocation_strategy: The strategy that determines how to allocate the target Spot Instance capacity across the Spot Instance pools specified by the Spot Fleet launch configuration. For more information, see [Allocation strategies for Spot Instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-allocation-strategy.html) in the *Amazon EC2 User Guide* .
               
               - **priceCapacityOptimized (recommended)** - Spot Fleet identifies the pools with the highest capacity availability for the number of instances that are launching. This means that we will request Spot Instances from the pools that we believe have the lowest chance of interruption in the near term. Spot Fleet then requests Spot Instances from the lowest priced of these pools.
               - **capacityOptimized** - Spot Fleet identifies the pools with the highest capacity availability for the number of instances that are launching. This means that we will request Spot Instances from the pools that we believe have the lowest chance of interruption in the near term. To give certain instance types a higher chance of launching first, use `capacityOptimizedPrioritized` . Set a priority for each instance type by using the `Priority` parameter for `LaunchTemplateOverrides` . You can assign the same priority to different `LaunchTemplateOverrides` . EC2 implements the priorities on a best-effort basis, but optimizes for capacity first. `capacityOptimizedPrioritized` is supported only if your Spot Fleet uses a launch template. Note that if the `OnDemandAllocationStrategy` is set to `prioritized` , the same priority is applied when fulfilling On-Demand capacity.
               - **diversified** - Spot Fleet requests instances from all of the Spot Instance pools that you specify.
               - **lowestPrice (not recommended)** - > We don't recommend the `lowestPrice` allocation strategy because it has the highest risk of interruption for your Spot Instances. 
               
               Spot Fleet requests instances from the lowest priced Spot Instance pool that has available capacity. If the lowest priced pool doesn't have available capacity, the Spot Instances come from the next lowest priced pool that has available capacity. If a pool runs out of capacity before fulfilling your desired capacity, Spot Fleet will continue to fulfill your request by drawing from the next lowest priced pool. To ensure that your desired capacity is met, you might receive Spot Instances from several pools. Because this strategy only considers instance price and not capacity availability, it might lead to high interruption rates.
               
               Default: `lowestPrice`
        :param pulumi.Input[_builtins.str] context: Reserved.
        :param pulumi.Input['SpotFleetRequestConfigDataExcessCapacityTerminationPolicy'] excess_capacity_termination_policy: Indicates whether running Spot Instances should be terminated if you decrease the target capacity of the Spot Fleet request below the current size of the Spot Fleet.
               
               Supported only for fleets of type `maintain` .
        :param pulumi.Input['SpotFleetRequestConfigDataInstanceInterruptionBehavior'] instance_interruption_behavior: The behavior when a Spot Instance is interrupted. The default is `terminate` .
        :param pulumi.Input[_builtins.int] instance_pools_to_use_count: The number of Spot pools across which to allocate your target Spot capacity. Valid only when Spot *AllocationStrategy* is set to `lowest-price` . Spot Fleet selects the cheapest Spot pools and evenly allocates your target Spot capacity across the number of Spot pools that you specify.
               
               Note that Spot Fleet attempts to draw Spot Instances from the number of pools that you specify on a best effort basis. If a pool runs out of Spot capacity before fulfilling your target capacity, Spot Fleet will continue to fulfill your request by drawing from the next cheapest pool. To ensure that your target capacity is met, you might receive Spot Instances from more than the number of pools that you specified. Similarly, if most of the pools have no Spot capacity, you might receive your full target capacity from fewer than the number of pools that you specified.
        :param pulumi.Input[Sequence[pulumi.Input['SpotFleetLaunchSpecificationArgs']]] launch_specifications: The launch specifications for the Spot Fleet request. If you specify `LaunchSpecifications` , you can't specify `LaunchTemplateConfigs` .
        :param pulumi.Input[Sequence[pulumi.Input['SpotFleetLaunchTemplateConfigArgs']]] launch_template_configs: The launch template and overrides. If you specify `LaunchTemplateConfigs` , you can't specify `LaunchSpecifications` .
        :param pulumi.Input['SpotFleetLoadBalancersConfigArgs'] load_balancers_config: One or more Classic Load Balancers and target groups to attach to the Spot Fleet request. Spot Fleet registers the running Spot Instances with the specified Classic Load Balancers and target groups.
               
               With Network Load Balancers, Spot Fleet cannot register instances that have the following instance types: C1, CC1, CC2, CG1, CG2, CR1, CS1, G1, G2, HI1, HS1, M1, M2, M3, and T1.
        :param pulumi.Input[_builtins.str] on_demand_allocation_strategy: The order of the launch template overrides to use in fulfilling On-Demand capacity. If you specify `lowestPrice` , Spot Fleet uses price to determine the order, launching the lowest price first. If you specify `prioritized` , Spot Fleet uses the priority that you assign to each Spot Fleet launch template override, launching the highest priority first. If you do not specify a value, Spot Fleet defaults to `lowestPrice` .
        :param pulumi.Input[_builtins.str] on_demand_max_total_price: The maximum amount per hour for On-Demand Instances that you're willing to pay. You can use the `onDemandMaxTotalPrice` parameter, the `spotMaxTotalPrice` parameter, or both parameters to ensure that your fleet cost does not exceed your budget. If you set a maximum price per hour for the On-Demand Instances and Spot Instances in your request, Spot Fleet will launch instances until it reaches the maximum amount you're willing to pay. When the maximum amount you're willing to pay is reached, the fleet stops launching instances even if it hasnt met the target capacity.
               
               > If your fleet includes T instances that are configured as `unlimited` , and if their average CPU usage exceeds the baseline utilization, you will incur a charge for surplus credits. The `onDemandMaxTotalPrice` does not account for surplus credits, and, if you use surplus credits, your final cost might be higher than what you specified for `onDemandMaxTotalPrice` . For more information, see [Surplus credits can incur charges](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-unlimited-mode-concepts.html#unlimited-mode-surplus-credits) in the *Amazon EC2 User Guide* .
        :param pulumi.Input[_builtins.int] on_demand_target_capacity: The number of On-Demand units to request. You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is `maintain` , you can specify a target capacity of 0 and add capacity later.
        :param pulumi.Input[_builtins.bool] replace_unhealthy_instances: Indicates whether Spot Fleet should replace unhealthy instances.
        :param pulumi.Input['SpotFleetSpotMaintenanceStrategiesArgs'] spot_maintenance_strategies: The strategies for managing your Spot Instances that are at an elevated risk of being interrupted.
        :param pulumi.Input[_builtins.str] spot_max_total_price: The maximum amount per hour for Spot Instances that you're willing to pay. You can use the `spotMaxTotalPrice` parameter, the `onDemandMaxTotalPrice` parameter, or both parameters to ensure that your fleet cost does not exceed your budget. If you set a maximum price per hour for the On-Demand Instances and Spot Instances in your request, Spot Fleet will launch instances until it reaches the maximum amount you're willing to pay. When the maximum amount you're willing to pay is reached, the fleet stops launching instances even if it hasnt met the target capacity.
               
               > If your fleet includes T instances that are configured as `unlimited` , and if their average CPU usage exceeds the baseline utilization, you will incur a charge for surplus credits. The `spotMaxTotalPrice` does not account for surplus credits, and, if you use surplus credits, your final cost might be higher than what you specified for `spotMaxTotalPrice` . For more information, see [Surplus credits can incur charges](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-unlimited-mode-concepts.html#unlimited-mode-surplus-credits) in the *Amazon EC2 User Guide* .
        :param pulumi.Input[_builtins.str] spot_price: The maximum price per unit hour that you are willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.
               
               > If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.
        :param pulumi.Input[Sequence[pulumi.Input['SpotFleetTagSpecificationArgs']]] tag_specifications: The key-value pair for tagging the Spot Fleet request on creation. The value for `ResourceType` must be `spot-fleet-request` , otherwise the Spot Fleet request fails. To tag instances at launch, specify the tags in the [launch template](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#create-launch-template) (valid only if you use `LaunchTemplateConfigs` ) or in the `[SpotFleetTagSpecification](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SpotFleetTagSpecification.html)` (valid only if you use `LaunchSpecifications` ). For information about tagging after launch, see [Tag your resources](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#tag-resources) .
        :param pulumi.Input['SpotFleetRequestConfigDataTargetCapacityUnitType'] target_capacity_unit_type: The unit for the target capacity. You can specify this parameter only when using attribute-based instance type selection.
               
               Default: `units` (the number of instances)
        :param pulumi.Input[_builtins.bool] terminate_instances_with_expiration: Indicates whether running Spot Instances are terminated when the Spot Fleet request expires.
        :param pulumi.Input['SpotFleetRequestConfigDataType'] type: The type of request. Indicates whether the Spot Fleet only requests the target capacity or also attempts to maintain it. When this value is `request` , the Spot Fleet only places the required requests. It does not attempt to replenish Spot Instances if capacity is diminished, nor does it submit requests in alternative Spot pools if capacity is not available. When this value is `maintain` , the Spot Fleet maintains the target capacity. The Spot Fleet places the required requests to meet capacity and automatically replenishes any interrupted instances. Default: `maintain` . `instant` is listed but is not used by Spot Fleet.
        :param pulumi.Input[_builtins.str] valid_from: The start date and time of the request, in UTC format ( *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z). By default, Amazon EC2 starts fulfilling the request immediately.
        :param pulumi.Input[_builtins.str] valid_until: The end date and time of the request, in UTC format ( *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z). After the end date and time, no new Spot Instance requests are placed or able to fulfill the request. If no value is specified, the Spot Fleet request remains until you cancel it.
        """
        pulumi.set(__self__, "iam_fleet_role", iam_fleet_role)
        pulumi.set(__self__, "target_capacity", target_capacity)
        if allocation_strategy is not None:
            pulumi.set(__self__, "allocation_strategy", allocation_strategy)
        if context is not None:
            pulumi.set(__self__, "context", context)
        if excess_capacity_termination_policy is not None:
            pulumi.set(__self__, "excess_capacity_termination_policy", excess_capacity_termination_policy)
        if instance_interruption_behavior is not None:
            pulumi.set(__self__, "instance_interruption_behavior", instance_interruption_behavior)
        if instance_pools_to_use_count is not None:
            pulumi.set(__self__, "instance_pools_to_use_count", instance_pools_to_use_count)
        if launch_specifications is not None:
            pulumi.set(__self__, "launch_specifications", launch_specifications)
        if launch_template_configs is not None:
            pulumi.set(__self__, "launch_template_configs", launch_template_configs)
        if load_balancers_config is not None:
            pulumi.set(__self__, "load_balancers_config", load_balancers_config)
        if on_demand_allocation_strategy is not None:
            pulumi.set(__self__, "on_demand_allocation_strategy", on_demand_allocation_strategy)
        if on_demand_max_total_price is not None:
            pulumi.set(__self__, "on_demand_max_total_price", on_demand_max_total_price)
        if on_demand_target_capacity is not None:
            pulumi.set(__self__, "on_demand_target_capacity", on_demand_target_capacity)
        if replace_unhealthy_instances is not None:
            pulumi.set(__self__, "replace_unhealthy_instances", replace_unhealthy_instances)
        if spot_maintenance_strategies is not None:
            pulumi.set(__self__, "spot_maintenance_strategies", spot_maintenance_strategies)
        if spot_max_total_price is not None:
            pulumi.set(__self__, "spot_max_total_price", spot_max_total_price)
        if spot_price is not None:
            pulumi.set(__self__, "spot_price", spot_price)
        if tag_specifications is not None:
            pulumi.set(__self__, "tag_specifications", tag_specifications)
        if target_capacity_unit_type is not None:
            pulumi.set(__self__, "target_capacity_unit_type", target_capacity_unit_type)
        if terminate_instances_with_expiration is not None:
            pulumi.set(__self__, "terminate_instances_with_expiration", terminate_instances_with_expiration)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if valid_from is not None:
            pulumi.set(__self__, "valid_from", valid_from)
        if valid_until is not None:
            pulumi.set(__self__, "valid_until", valid_until)

    @_builtins.property
    @pulumi.getter(name="iamFleetRole")
    def iam_fleet_role(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role that grants the Spot Fleet the permission to request, launch, terminate, and tag instances on your behalf. For more information, see [Spot Fleet Prerequisites](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-requests.html#spot-fleet-prerequisites) in the *Amazon EC2 User Guide* . Spot Fleet can terminate Spot Instances on your behalf when you cancel its Spot Fleet request or when the Spot Fleet request expires, if you set `TerminateInstancesWithExpiration` .
        """
        return pulumi.get(self, "iam_fleet_role")

    @iam_fleet_role.setter
    def iam_fleet_role(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "iam_fleet_role", value)

    @_builtins.property
    @pulumi.getter(name="targetCapacity")
    def target_capacity(self) -> pulumi.Input[_builtins.int]:
        """
        The number of units to request for the Spot Fleet. You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is `maintain` , you can specify a target capacity of 0 and add capacity later.
        """
        return pulumi.get(self, "target_capacity")

    @target_capacity.setter
    def target_capacity(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "target_capacity", value)

    @_builtins.property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> Optional[pulumi.Input['SpotFleetRequestConfigDataAllocationStrategy']]:
        """
        The strategy that determines how to allocate the target Spot Instance capacity across the Spot Instance pools specified by the Spot Fleet launch configuration. For more information, see [Allocation strategies for Spot Instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-allocation-strategy.html) in the *Amazon EC2 User Guide* .

        - **priceCapacityOptimized (recommended)** - Spot Fleet identifies the pools with the highest capacity availability for the number of instances that are launching. This means that we will request Spot Instances from the pools that we believe have the lowest chance of interruption in the near term. Spot Fleet then requests Spot Instances from the lowest priced of these pools.
        - **capacityOptimized** - Spot Fleet identifies the pools with the highest capacity availability for the number of instances that are launching. This means that we will request Spot Instances from the pools that we believe have the lowest chance of interruption in the near term. To give certain instance types a higher chance of launching first, use `capacityOptimizedPrioritized` . Set a priority for each instance type by using the `Priority` parameter for `LaunchTemplateOverrides` . You can assign the same priority to different `LaunchTemplateOverrides` . EC2 implements the priorities on a best-effort basis, but optimizes for capacity first. `capacityOptimizedPrioritized` is supported only if your Spot Fleet uses a launch template. Note that if the `OnDemandAllocationStrategy` is set to `prioritized` , the same priority is applied when fulfilling On-Demand capacity.
        - **diversified** - Spot Fleet requests instances from all of the Spot Instance pools that you specify.
        - **lowestPrice (not recommended)** - > We don't recommend the `lowestPrice` allocation strategy because it has the highest risk of interruption for your Spot Instances. 

        Spot Fleet requests instances from the lowest priced Spot Instance pool that has available capacity. If the lowest priced pool doesn't have available capacity, the Spot Instances come from the next lowest priced pool that has available capacity. If a pool runs out of capacity before fulfilling your desired capacity, Spot Fleet will continue to fulfill your request by drawing from the next lowest priced pool. To ensure that your desired capacity is met, you might receive Spot Instances from several pools. Because this strategy only considers instance price and not capacity availability, it might lead to high interruption rates.

        Default: `lowestPrice`
        """
        return pulumi.get(self, "allocation_strategy")

    @allocation_strategy.setter
    def allocation_strategy(self, value: Optional[pulumi.Input['SpotFleetRequestConfigDataAllocationStrategy']]):
        pulumi.set(self, "allocation_strategy", value)

    @_builtins.property
    @pulumi.getter
    def context(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Reserved.
        """
        return pulumi.get(self, "context")

    @context.setter
    def context(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "context", value)

    @_builtins.property
    @pulumi.getter(name="excessCapacityTerminationPolicy")
    def excess_capacity_termination_policy(self) -> Optional[pulumi.Input['SpotFleetRequestConfigDataExcessCapacityTerminationPolicy']]:
        """
        Indicates whether running Spot Instances should be terminated if you decrease the target capacity of the Spot Fleet request below the current size of the Spot Fleet.

        Supported only for fleets of type `maintain` .
        """
        return pulumi.get(self, "excess_capacity_termination_policy")

    @excess_capacity_termination_policy.setter
    def excess_capacity_termination_policy(self, value: Optional[pulumi.Input['SpotFleetRequestConfigDataExcessCapacityTerminationPolicy']]):
        pulumi.set(self, "excess_capacity_termination_policy", value)

    @_builtins.property
    @pulumi.getter(name="instanceInterruptionBehavior")
    def instance_interruption_behavior(self) -> Optional[pulumi.Input['SpotFleetRequestConfigDataInstanceInterruptionBehavior']]:
        """
        The behavior when a Spot Instance is interrupted. The default is `terminate` .
        """
        return pulumi.get(self, "instance_interruption_behavior")

    @instance_interruption_behavior.setter
    def instance_interruption_behavior(self, value: Optional[pulumi.Input['SpotFleetRequestConfigDataInstanceInterruptionBehavior']]):
        pulumi.set(self, "instance_interruption_behavior", value)

    @_builtins.property
    @pulumi.getter(name="instancePoolsToUseCount")
    def instance_pools_to_use_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of Spot pools across which to allocate your target Spot capacity. Valid only when Spot *AllocationStrategy* is set to `lowest-price` . Spot Fleet selects the cheapest Spot pools and evenly allocates your target Spot capacity across the number of Spot pools that you specify.

        Note that Spot Fleet attempts to draw Spot Instances from the number of pools that you specify on a best effort basis. If a pool runs out of Spot capacity before fulfilling your target capacity, Spot Fleet will continue to fulfill your request by drawing from the next cheapest pool. To ensure that your target capacity is met, you might receive Spot Instances from more than the number of pools that you specified. Similarly, if most of the pools have no Spot capacity, you might receive your full target capacity from fewer than the number of pools that you specified.
        """
        return pulumi.get(self, "instance_pools_to_use_count")

    @instance_pools_to_use_count.setter
    def instance_pools_to_use_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "instance_pools_to_use_count", value)

    @_builtins.property
    @pulumi.getter(name="launchSpecifications")
    def launch_specifications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetLaunchSpecificationArgs']]]]:
        """
        The launch specifications for the Spot Fleet request. If you specify `LaunchSpecifications` , you can't specify `LaunchTemplateConfigs` .
        """
        return pulumi.get(self, "launch_specifications")

    @launch_specifications.setter
    def launch_specifications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetLaunchSpecificationArgs']]]]):
        pulumi.set(self, "launch_specifications", value)

    @_builtins.property
    @pulumi.getter(name="launchTemplateConfigs")
    def launch_template_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetLaunchTemplateConfigArgs']]]]:
        """
        The launch template and overrides. If you specify `LaunchTemplateConfigs` , you can't specify `LaunchSpecifications` .
        """
        return pulumi.get(self, "launch_template_configs")

    @launch_template_configs.setter
    def launch_template_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetLaunchTemplateConfigArgs']]]]):
        pulumi.set(self, "launch_template_configs", value)

    @_builtins.property
    @pulumi.getter(name="loadBalancersConfig")
    def load_balancers_config(self) -> Optional[pulumi.Input['SpotFleetLoadBalancersConfigArgs']]:
        """
        One or more Classic Load Balancers and target groups to attach to the Spot Fleet request. Spot Fleet registers the running Spot Instances with the specified Classic Load Balancers and target groups.

        With Network Load Balancers, Spot Fleet cannot register instances that have the following instance types: C1, CC1, CC2, CG1, CG2, CR1, CS1, G1, G2, HI1, HS1, M1, M2, M3, and T1.
        """
        return pulumi.get(self, "load_balancers_config")

    @load_balancers_config.setter
    def load_balancers_config(self, value: Optional[pulumi.Input['SpotFleetLoadBalancersConfigArgs']]):
        pulumi.set(self, "load_balancers_config", value)

    @_builtins.property
    @pulumi.getter(name="onDemandAllocationStrategy")
    def on_demand_allocation_strategy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The order of the launch template overrides to use in fulfilling On-Demand capacity. If you specify `lowestPrice` , Spot Fleet uses price to determine the order, launching the lowest price first. If you specify `prioritized` , Spot Fleet uses the priority that you assign to each Spot Fleet launch template override, launching the highest priority first. If you do not specify a value, Spot Fleet defaults to `lowestPrice` .
        """
        return pulumi.get(self, "on_demand_allocation_strategy")

    @on_demand_allocation_strategy.setter
    def on_demand_allocation_strategy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "on_demand_allocation_strategy", value)

    @_builtins.property
    @pulumi.getter(name="onDemandMaxTotalPrice")
    def on_demand_max_total_price(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The maximum amount per hour for On-Demand Instances that you're willing to pay. You can use the `onDemandMaxTotalPrice` parameter, the `spotMaxTotalPrice` parameter, or both parameters to ensure that your fleet cost does not exceed your budget. If you set a maximum price per hour for the On-Demand Instances and Spot Instances in your request, Spot Fleet will launch instances until it reaches the maximum amount you're willing to pay. When the maximum amount you're willing to pay is reached, the fleet stops launching instances even if it hasnt met the target capacity.

        > If your fleet includes T instances that are configured as `unlimited` , and if their average CPU usage exceeds the baseline utilization, you will incur a charge for surplus credits. The `onDemandMaxTotalPrice` does not account for surplus credits, and, if you use surplus credits, your final cost might be higher than what you specified for `onDemandMaxTotalPrice` . For more information, see [Surplus credits can incur charges](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-unlimited-mode-concepts.html#unlimited-mode-surplus-credits) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "on_demand_max_total_price")

    @on_demand_max_total_price.setter
    def on_demand_max_total_price(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "on_demand_max_total_price", value)

    @_builtins.property
    @pulumi.getter(name="onDemandTargetCapacity")
    def on_demand_target_capacity(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of On-Demand units to request. You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is `maintain` , you can specify a target capacity of 0 and add capacity later.
        """
        return pulumi.get(self, "on_demand_target_capacity")

    @on_demand_target_capacity.setter
    def on_demand_target_capacity(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "on_demand_target_capacity", value)

    @_builtins.property
    @pulumi.getter(name="replaceUnhealthyInstances")
    def replace_unhealthy_instances(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether Spot Fleet should replace unhealthy instances.
        """
        return pulumi.get(self, "replace_unhealthy_instances")

    @replace_unhealthy_instances.setter
    def replace_unhealthy_instances(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "replace_unhealthy_instances", value)

    @_builtins.property
    @pulumi.getter(name="spotMaintenanceStrategies")
    def spot_maintenance_strategies(self) -> Optional[pulumi.Input['SpotFleetSpotMaintenanceStrategiesArgs']]:
        """
        The strategies for managing your Spot Instances that are at an elevated risk of being interrupted.
        """
        return pulumi.get(self, "spot_maintenance_strategies")

    @spot_maintenance_strategies.setter
    def spot_maintenance_strategies(self, value: Optional[pulumi.Input['SpotFleetSpotMaintenanceStrategiesArgs']]):
        pulumi.set(self, "spot_maintenance_strategies", value)

    @_builtins.property
    @pulumi.getter(name="spotMaxTotalPrice")
    def spot_max_total_price(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The maximum amount per hour for Spot Instances that you're willing to pay. You can use the `spotMaxTotalPrice` parameter, the `onDemandMaxTotalPrice` parameter, or both parameters to ensure that your fleet cost does not exceed your budget. If you set a maximum price per hour for the On-Demand Instances and Spot Instances in your request, Spot Fleet will launch instances until it reaches the maximum amount you're willing to pay. When the maximum amount you're willing to pay is reached, the fleet stops launching instances even if it hasnt met the target capacity.

        > If your fleet includes T instances that are configured as `unlimited` , and if their average CPU usage exceeds the baseline utilization, you will incur a charge for surplus credits. The `spotMaxTotalPrice` does not account for surplus credits, and, if you use surplus credits, your final cost might be higher than what you specified for `spotMaxTotalPrice` . For more information, see [Surplus credits can incur charges](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-unlimited-mode-concepts.html#unlimited-mode-surplus-credits) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "spot_max_total_price")

    @spot_max_total_price.setter
    def spot_max_total_price(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "spot_max_total_price", value)

    @_builtins.property
    @pulumi.getter(name="spotPrice")
    def spot_price(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The maximum price per unit hour that you are willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.

        > If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.
        """
        return pulumi.get(self, "spot_price")

    @spot_price.setter
    def spot_price(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "spot_price", value)

    @_builtins.property
    @pulumi.getter(name="tagSpecifications")
    def tag_specifications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetTagSpecificationArgs']]]]:
        """
        The key-value pair for tagging the Spot Fleet request on creation. The value for `ResourceType` must be `spot-fleet-request` , otherwise the Spot Fleet request fails. To tag instances at launch, specify the tags in the [launch template](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#create-launch-template) (valid only if you use `LaunchTemplateConfigs` ) or in the `[SpotFleetTagSpecification](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SpotFleetTagSpecification.html)` (valid only if you use `LaunchSpecifications` ). For information about tagging after launch, see [Tag your resources](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#tag-resources) .
        """
        return pulumi.get(self, "tag_specifications")

    @tag_specifications.setter
    def tag_specifications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetTagSpecificationArgs']]]]):
        pulumi.set(self, "tag_specifications", value)

    @_builtins.property
    @pulumi.getter(name="targetCapacityUnitType")
    def target_capacity_unit_type(self) -> Optional[pulumi.Input['SpotFleetRequestConfigDataTargetCapacityUnitType']]:
        """
        The unit for the target capacity. You can specify this parameter only when using attribute-based instance type selection.

        Default: `units` (the number of instances)
        """
        return pulumi.get(self, "target_capacity_unit_type")

    @target_capacity_unit_type.setter
    def target_capacity_unit_type(self, value: Optional[pulumi.Input['SpotFleetRequestConfigDataTargetCapacityUnitType']]):
        pulumi.set(self, "target_capacity_unit_type", value)

    @_builtins.property
    @pulumi.getter(name="terminateInstancesWithExpiration")
    def terminate_instances_with_expiration(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether running Spot Instances are terminated when the Spot Fleet request expires.
        """
        return pulumi.get(self, "terminate_instances_with_expiration")

    @terminate_instances_with_expiration.setter
    def terminate_instances_with_expiration(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "terminate_instances_with_expiration", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['SpotFleetRequestConfigDataType']]:
        """
        The type of request. Indicates whether the Spot Fleet only requests the target capacity or also attempts to maintain it. When this value is `request` , the Spot Fleet only places the required requests. It does not attempt to replenish Spot Instances if capacity is diminished, nor does it submit requests in alternative Spot pools if capacity is not available. When this value is `maintain` , the Spot Fleet maintains the target capacity. The Spot Fleet places the required requests to meet capacity and automatically replenishes any interrupted instances. Default: `maintain` . `instant` is listed but is not used by Spot Fleet.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['SpotFleetRequestConfigDataType']]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="validFrom")
    def valid_from(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The start date and time of the request, in UTC format ( *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z). By default, Amazon EC2 starts fulfilling the request immediately.
        """
        return pulumi.get(self, "valid_from")

    @valid_from.setter
    def valid_from(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "valid_from", value)

    @_builtins.property
    @pulumi.getter(name="validUntil")
    def valid_until(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The end date and time of the request, in UTC format ( *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z). After the end date and time, no new Spot Instance requests are placed or able to fulfill the request. If no value is specified, the Spot Fleet request remains until you cancel it.
        """
        return pulumi.get(self, "valid_until")

    @valid_until.setter
    def valid_until(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "valid_until", value)


if not MYPY:
    class SpotFleetSpotCapacityRebalanceArgsDict(TypedDict):
        replacement_strategy: NotRequired[pulumi.Input['SpotFleetSpotCapacityRebalanceReplacementStrategy']]
        """
        The replacement strategy to use. Only available for fleets of type `maintain` .

        `launch` - Spot Fleet launches a new replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet. Spot Fleet does not terminate the instances that receive a rebalance notification. You can terminate the old instances, or you can leave them running. You are charged for all instances while they are running.

        `launch-before-terminate` - Spot Fleet launches a new replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet, and then, after a delay that you specify (in `TerminationDelay` ), terminates the instances that received a rebalance notification.
        """
        termination_delay: NotRequired[pulumi.Input[_builtins.int]]
        """
        The amount of time (in seconds) that Amazon EC2 waits before terminating the old Spot Instance after launching a new replacement Spot Instance.

        Required when `ReplacementStrategy` is set to `launch-before-terminate` .

        Not valid when `ReplacementStrategy` is set to `launch` .

        Valid values: Minimum value of `120` seconds. Maximum value of `7200` seconds.
        """
elif False:
    SpotFleetSpotCapacityRebalanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpotFleetSpotCapacityRebalanceArgs:
    def __init__(__self__, *,
                 replacement_strategy: Optional[pulumi.Input['SpotFleetSpotCapacityRebalanceReplacementStrategy']] = None,
                 termination_delay: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['SpotFleetSpotCapacityRebalanceReplacementStrategy'] replacement_strategy: The replacement strategy to use. Only available for fleets of type `maintain` .
               
               `launch` - Spot Fleet launches a new replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet. Spot Fleet does not terminate the instances that receive a rebalance notification. You can terminate the old instances, or you can leave them running. You are charged for all instances while they are running.
               
               `launch-before-terminate` - Spot Fleet launches a new replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet, and then, after a delay that you specify (in `TerminationDelay` ), terminates the instances that received a rebalance notification.
        :param pulumi.Input[_builtins.int] termination_delay: The amount of time (in seconds) that Amazon EC2 waits before terminating the old Spot Instance after launching a new replacement Spot Instance.
               
               Required when `ReplacementStrategy` is set to `launch-before-terminate` .
               
               Not valid when `ReplacementStrategy` is set to `launch` .
               
               Valid values: Minimum value of `120` seconds. Maximum value of `7200` seconds.
        """
        if replacement_strategy is not None:
            pulumi.set(__self__, "replacement_strategy", replacement_strategy)
        if termination_delay is not None:
            pulumi.set(__self__, "termination_delay", termination_delay)

    @_builtins.property
    @pulumi.getter(name="replacementStrategy")
    def replacement_strategy(self) -> Optional[pulumi.Input['SpotFleetSpotCapacityRebalanceReplacementStrategy']]:
        """
        The replacement strategy to use. Only available for fleets of type `maintain` .

        `launch` - Spot Fleet launches a new replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet. Spot Fleet does not terminate the instances that receive a rebalance notification. You can terminate the old instances, or you can leave them running. You are charged for all instances while they are running.

        `launch-before-terminate` - Spot Fleet launches a new replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet, and then, after a delay that you specify (in `TerminationDelay` ), terminates the instances that received a rebalance notification.
        """
        return pulumi.get(self, "replacement_strategy")

    @replacement_strategy.setter
    def replacement_strategy(self, value: Optional[pulumi.Input['SpotFleetSpotCapacityRebalanceReplacementStrategy']]):
        pulumi.set(self, "replacement_strategy", value)

    @_builtins.property
    @pulumi.getter(name="terminationDelay")
    def termination_delay(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The amount of time (in seconds) that Amazon EC2 waits before terminating the old Spot Instance after launching a new replacement Spot Instance.

        Required when `ReplacementStrategy` is set to `launch-before-terminate` .

        Not valid when `ReplacementStrategy` is set to `launch` .

        Valid values: Minimum value of `120` seconds. Maximum value of `7200` seconds.
        """
        return pulumi.get(self, "termination_delay")

    @termination_delay.setter
    def termination_delay(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "termination_delay", value)


if not MYPY:
    class SpotFleetSpotMaintenanceStrategiesArgsDict(TypedDict):
        capacity_rebalance: NotRequired[pulumi.Input['SpotFleetSpotCapacityRebalanceArgsDict']]
        """
        The Spot Instance replacement strategy to use when Amazon EC2 emits a signal that your Spot Instance is at an elevated risk of being interrupted. For more information, see [Capacity rebalancing](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-capacity-rebalance.html) in the *Amazon EC2 User Guide* .
        """
elif False:
    SpotFleetSpotMaintenanceStrategiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpotFleetSpotMaintenanceStrategiesArgs:
    def __init__(__self__, *,
                 capacity_rebalance: Optional[pulumi.Input['SpotFleetSpotCapacityRebalanceArgs']] = None):
        """
        :param pulumi.Input['SpotFleetSpotCapacityRebalanceArgs'] capacity_rebalance: The Spot Instance replacement strategy to use when Amazon EC2 emits a signal that your Spot Instance is at an elevated risk of being interrupted. For more information, see [Capacity rebalancing](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-capacity-rebalance.html) in the *Amazon EC2 User Guide* .
        """
        if capacity_rebalance is not None:
            pulumi.set(__self__, "capacity_rebalance", capacity_rebalance)

    @_builtins.property
    @pulumi.getter(name="capacityRebalance")
    def capacity_rebalance(self) -> Optional[pulumi.Input['SpotFleetSpotCapacityRebalanceArgs']]:
        """
        The Spot Instance replacement strategy to use when Amazon EC2 emits a signal that your Spot Instance is at an elevated risk of being interrupted. For more information, see [Capacity rebalancing](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-capacity-rebalance.html) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "capacity_rebalance")

    @capacity_rebalance.setter
    def capacity_rebalance(self, value: Optional[pulumi.Input['SpotFleetSpotCapacityRebalanceArgs']]):
        pulumi.set(self, "capacity_rebalance", value)


if not MYPY:
    class SpotFleetSpotPlacementArgsDict(TypedDict):
        availability_zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Availability Zone.

        To specify multiple Availability Zones, separate them using commas; for example, "us-west-2a, us-west-2b".
        """
        group_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the placement group.
        """
        tenancy: NotRequired[pulumi.Input['SpotFleetSpotPlacementTenancy']]
        """
        The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of `dedicated` runs on single-tenant hardware. The `host` tenancy is not supported for Spot Instances.
        """
elif False:
    SpotFleetSpotPlacementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpotFleetSpotPlacementArgs:
    def __init__(__self__, *,
                 availability_zone: Optional[pulumi.Input[_builtins.str]] = None,
                 group_name: Optional[pulumi.Input[_builtins.str]] = None,
                 tenancy: Optional[pulumi.Input['SpotFleetSpotPlacementTenancy']] = None):
        """
        :param pulumi.Input[_builtins.str] availability_zone: The Availability Zone.
               
               To specify multiple Availability Zones, separate them using commas; for example, "us-west-2a, us-west-2b".
        :param pulumi.Input[_builtins.str] group_name: The name of the placement group.
        :param pulumi.Input['SpotFleetSpotPlacementTenancy'] tenancy: The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of `dedicated` runs on single-tenant hardware. The `host` tenancy is not supported for Spot Instances.
        """
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if tenancy is not None:
            pulumi.set(__self__, "tenancy", tenancy)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Availability Zone.

        To specify multiple Availability Zones, separate them using commas; for example, "us-west-2a, us-west-2b".
        """
        return pulumi.get(self, "availability_zone")

    @availability_zone.setter
    def availability_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "availability_zone", value)

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the placement group.
        """
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_name", value)

    @_builtins.property
    @pulumi.getter
    def tenancy(self) -> Optional[pulumi.Input['SpotFleetSpotPlacementTenancy']]:
        """
        The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of `dedicated` runs on single-tenant hardware. The `host` tenancy is not supported for Spot Instances.
        """
        return pulumi.get(self, "tenancy")

    @tenancy.setter
    def tenancy(self, value: Optional[pulumi.Input['SpotFleetSpotPlacementTenancy']]):
        pulumi.set(self, "tenancy", value)


if not MYPY:
    class SpotFleetTagSpecificationArgsDict(TypedDict):
        resource_type: NotRequired[pulumi.Input['SpotFleetTagSpecificationResourceType']]
        """
        The type of resource. Currently, the only resource type that is supported is `instance` . To tag the Spot Fleet request on creation, use the `TagSpecifications` parameter in `[SpotFleetRequestConfigData](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SpotFleetRequestConfigData.html)` .
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['SpotFleetTagArgsDict']]]]
        """
        The tags.
        """
elif False:
    SpotFleetTagSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpotFleetTagSpecificationArgs:
    def __init__(__self__, *,
                 resource_type: Optional[pulumi.Input['SpotFleetTagSpecificationResourceType']] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetTagArgs']]]] = None):
        """
        :param pulumi.Input['SpotFleetTagSpecificationResourceType'] resource_type: The type of resource. Currently, the only resource type that is supported is `instance` . To tag the Spot Fleet request on creation, use the `TagSpecifications` parameter in `[SpotFleetRequestConfigData](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SpotFleetRequestConfigData.html)` .
        :param pulumi.Input[Sequence[pulumi.Input['SpotFleetTagArgs']]] tags: The tags.
        """
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[pulumi.Input['SpotFleetTagSpecificationResourceType']]:
        """
        The type of resource. Currently, the only resource type that is supported is `instance` . To tag the Spot Fleet request on creation, use the `TagSpecifications` parameter in `[SpotFleetRequestConfigData](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SpotFleetRequestConfigData.html)` .
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: Optional[pulumi.Input['SpotFleetTagSpecificationResourceType']]):
        pulumi.set(self, "resource_type", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetTagArgs']]]]:
        """
        The tags.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SpotFleetTagArgs']]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class SpotFleetTagArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The tag key.
        """
        value: pulumi.Input[_builtins.str]
        """
        The tag value.
        """
elif False:
    SpotFleetTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpotFleetTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The tag key.
        :param pulumi.Input[_builtins.str] value: The tag value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        The tag value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SpotFleetTargetGroupsConfigArgsDict(TypedDict):
        target_groups: pulumi.Input[Sequence[pulumi.Input['SpotFleetTargetGroupArgsDict']]]
        """
        One or more target groups.
        """
elif False:
    SpotFleetTargetGroupsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpotFleetTargetGroupsConfigArgs:
    def __init__(__self__, *,
                 target_groups: pulumi.Input[Sequence[pulumi.Input['SpotFleetTargetGroupArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SpotFleetTargetGroupArgs']]] target_groups: One or more target groups.
        """
        pulumi.set(__self__, "target_groups", target_groups)

    @_builtins.property
    @pulumi.getter(name="targetGroups")
    def target_groups(self) -> pulumi.Input[Sequence[pulumi.Input['SpotFleetTargetGroupArgs']]]:
        """
        One or more target groups.
        """
        return pulumi.get(self, "target_groups")

    @target_groups.setter
    def target_groups(self, value: pulumi.Input[Sequence[pulumi.Input['SpotFleetTargetGroupArgs']]]):
        pulumi.set(self, "target_groups", value)


if not MYPY:
    class SpotFleetTargetGroupArgsDict(TypedDict):
        arn: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name (ARN) of the target group.
        """
elif False:
    SpotFleetTargetGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpotFleetTargetGroupArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] arn: The Amazon Resource Name (ARN) of the target group.
        """
        pulumi.set(__self__, "arn", arn)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the target group.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arn", value)


if not MYPY:
    class SpotFleetTotalLocalStorageGbRequestArgsDict(TypedDict):
        max: NotRequired[pulumi.Input[_builtins.float]]
        """
        The maximum amount of total local storage, in GB. To specify no maximum limit, omit this parameter.
        """
        min: NotRequired[pulumi.Input[_builtins.float]]
        """
        The minimum amount of total local storage, in GB. To specify no minimum limit, omit this parameter.
        """
elif False:
    SpotFleetTotalLocalStorageGbRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpotFleetTotalLocalStorageGbRequestArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[_builtins.float]] = None,
                 min: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] max: The maximum amount of total local storage, in GB. To specify no maximum limit, omit this parameter.
        :param pulumi.Input[_builtins.float] min: The minimum amount of total local storage, in GB. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The maximum amount of total local storage, in GB. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The minimum amount of total local storage, in GB. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class SpotFleetVCpuCountRangeRequestArgsDict(TypedDict):
        max: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
        """
        min: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum number of vCPUs. To specify no minimum limit, specify `0` .
        """
elif False:
    SpotFleetVCpuCountRangeRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpotFleetVCpuCountRangeRequestArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[_builtins.int]] = None,
                 min: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] max: The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
        :param pulumi.Input[_builtins.int] min: The minimum number of vCPUs. To specify no minimum limit, specify `0` .
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum number of vCPUs. To specify no minimum limit, specify `0` .
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class SseSpecificationPropertiesArgsDict(TypedDict):
        """
        The configuration options for customer provided KMS encryption.
        """
        customer_managed_key_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to encrypt the policy with the provided key or disable encryption
        """
        kms_key_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        KMS Key Arn used to encrypt the group policy
        """
elif False:
    SseSpecificationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SseSpecificationPropertiesArgs:
    def __init__(__self__, *,
                 customer_managed_key_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 kms_key_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The configuration options for customer provided KMS encryption.
        :param pulumi.Input[_builtins.bool] customer_managed_key_enabled: Whether to encrypt the policy with the provided key or disable encryption
        :param pulumi.Input[_builtins.str] kms_key_arn: KMS Key Arn used to encrypt the group policy
        """
        if customer_managed_key_enabled is not None:
            pulumi.set(__self__, "customer_managed_key_enabled", customer_managed_key_enabled)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @_builtins.property
    @pulumi.getter(name="customerManagedKeyEnabled")
    def customer_managed_key_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to encrypt the policy with the provided key or disable encryption
        """
        return pulumi.get(self, "customer_managed_key_enabled")

    @customer_managed_key_enabled.setter
    def customer_managed_key_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "customer_managed_key_enabled", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        KMS Key Arn used to encrypt the group policy
        """
        return pulumi.get(self, "kms_key_arn")

    @kms_key_arn.setter
    def kms_key_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_arn", value)


if not MYPY:
    class TagSpecificationArgsDict(TypedDict):
        """
        Specifies the tags to apply to resources that are created during instance launch.
         ``TagSpecification`` is a property type of [TagSpecifications](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-tagspecifications). [TagSpecifications](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-tagspecifications) is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        """
        resource_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of resource to tag. You can specify tags for the following resource types only: ``instance`` | ``volume`` | ``network-interface`` | ``spot-instances-request``. If the instance does not include the resource type that you specify, the instance launch fails. For example, not all instance types include a volume.
         To tag a resource after it has been created, see [CreateTags](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html).
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['LaunchTemplateTagArgsDict']]]]
        """
        The tags to apply to the resource.
        """
elif False:
    TagSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TagSpecificationArgs:
    def __init__(__self__, *,
                 resource_type: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['LaunchTemplateTagArgs']]]] = None):
        """
        Specifies the tags to apply to resources that are created during instance launch.
         ``TagSpecification`` is a property type of [TagSpecifications](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-tagspecifications). [TagSpecifications](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-tagspecifications) is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        :param pulumi.Input[_builtins.str] resource_type: The type of resource to tag. You can specify tags for the following resource types only: ``instance`` | ``volume`` | ``network-interface`` | ``spot-instances-request``. If the instance does not include the resource type that you specify, the instance launch fails. For example, not all instance types include a volume.
                To tag a resource after it has been created, see [CreateTags](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html).
        :param pulumi.Input[Sequence[pulumi.Input['LaunchTemplateTagArgs']]] tags: The tags to apply to the resource.
        """
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of resource to tag. You can specify tags for the following resource types only: ``instance`` | ``volume`` | ``network-interface`` | ``spot-instances-request``. If the instance does not include the resource type that you specify, the instance launch fails. For example, not all instance types include a volume.
         To tag a resource after it has been created, see [CreateTags](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html).
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_type", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LaunchTemplateTagArgs']]]]:
        """
        The tags to apply to the resource.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LaunchTemplateTagArgs']]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class TrafficMirrorFilterRuleTrafficMirrorPortRangeArgsDict(TypedDict):
        from_port: pulumi.Input[_builtins.int]
        """
        The first port in the Traffic Mirror port range.
        """
        to_port: pulumi.Input[_builtins.int]
        """
        The last port in the Traffic Mirror port range.
        """
elif False:
    TrafficMirrorFilterRuleTrafficMirrorPortRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TrafficMirrorFilterRuleTrafficMirrorPortRangeArgs:
    def __init__(__self__, *,
                 from_port: pulumi.Input[_builtins.int],
                 to_port: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] from_port: The first port in the Traffic Mirror port range.
        :param pulumi.Input[_builtins.int] to_port: The last port in the Traffic Mirror port range.
        """
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "to_port", to_port)

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> pulumi.Input[_builtins.int]:
        """
        The first port in the Traffic Mirror port range.
        """
        return pulumi.get(self, "from_port")

    @from_port.setter
    def from_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "from_port", value)

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> pulumi.Input[_builtins.int]:
        """
        The last port in the Traffic Mirror port range.
        """
        return pulumi.get(self, "to_port")

    @to_port.setter
    def to_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "to_port", value)


if not MYPY:
    class TransitGatewayConnectOptionsArgsDict(TypedDict):
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The tunnel protocol.
        """
elif False:
    TransitGatewayConnectOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransitGatewayConnectOptionsArgs:
    def __init__(__self__, *,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] protocol: The tunnel protocol.
        """
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The tunnel protocol.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class TransitGatewayConnectPeerConfigurationArgsDict(TypedDict):
        inside_cidr_blocks: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The range of interior BGP peer IP addresses.
        """
        peer_address: pulumi.Input[_builtins.str]
        """
        The peer IP address (GRE outer IP address) on the appliance side of the Connect peer.
        """
        bgp_configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['TransitGatewayConnectPeerTransitGatewayAttachmentBgpConfigurationArgsDict']]]]
        """
        The BGP configuration details.
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The tunnel protocol.
        """
        transit_gateway_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Connect peer IP address on the transit gateway side of the tunnel.
        """
elif False:
    TransitGatewayConnectPeerConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransitGatewayConnectPeerConfigurationArgs:
    def __init__(__self__, *,
                 inside_cidr_blocks: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 peer_address: pulumi.Input[_builtins.str],
                 bgp_configurations: Optional[pulumi.Input[Sequence[pulumi.Input['TransitGatewayConnectPeerTransitGatewayAttachmentBgpConfigurationArgs']]]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 transit_gateway_address: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] inside_cidr_blocks: The range of interior BGP peer IP addresses.
        :param pulumi.Input[_builtins.str] peer_address: The peer IP address (GRE outer IP address) on the appliance side of the Connect peer.
        :param pulumi.Input[Sequence[pulumi.Input['TransitGatewayConnectPeerTransitGatewayAttachmentBgpConfigurationArgs']]] bgp_configurations: The BGP configuration details.
        :param pulumi.Input[_builtins.str] protocol: The tunnel protocol.
        :param pulumi.Input[_builtins.str] transit_gateway_address: The Connect peer IP address on the transit gateway side of the tunnel.
        """
        pulumi.set(__self__, "inside_cidr_blocks", inside_cidr_blocks)
        pulumi.set(__self__, "peer_address", peer_address)
        if bgp_configurations is not None:
            pulumi.set(__self__, "bgp_configurations", bgp_configurations)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if transit_gateway_address is not None:
            pulumi.set(__self__, "transit_gateway_address", transit_gateway_address)

    @_builtins.property
    @pulumi.getter(name="insideCidrBlocks")
    def inside_cidr_blocks(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The range of interior BGP peer IP addresses.
        """
        return pulumi.get(self, "inside_cidr_blocks")

    @inside_cidr_blocks.setter
    def inside_cidr_blocks(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "inside_cidr_blocks", value)

    @_builtins.property
    @pulumi.getter(name="peerAddress")
    def peer_address(self) -> pulumi.Input[_builtins.str]:
        """
        The peer IP address (GRE outer IP address) on the appliance side of the Connect peer.
        """
        return pulumi.get(self, "peer_address")

    @peer_address.setter
    def peer_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "peer_address", value)

    @_builtins.property
    @pulumi.getter(name="bgpConfigurations")
    def bgp_configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TransitGatewayConnectPeerTransitGatewayAttachmentBgpConfigurationArgs']]]]:
        """
        The BGP configuration details.
        """
        return pulumi.get(self, "bgp_configurations")

    @bgp_configurations.setter
    def bgp_configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TransitGatewayConnectPeerTransitGatewayAttachmentBgpConfigurationArgs']]]]):
        pulumi.set(self, "bgp_configurations", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The tunnel protocol.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="transitGatewayAddress")
    def transit_gateway_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Connect peer IP address on the transit gateway side of the tunnel.
        """
        return pulumi.get(self, "transit_gateway_address")

    @transit_gateway_address.setter
    def transit_gateway_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "transit_gateway_address", value)


if not MYPY:
    class TransitGatewayConnectPeerTransitGatewayAttachmentBgpConfigurationArgsDict(TypedDict):
        bgp_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The BGP status.
        """
        peer_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The interior BGP peer IP address for the appliance.
        """
        peer_asn: NotRequired[pulumi.Input[_builtins.float]]
        """
        The peer Autonomous System Number (ASN).
        """
        transit_gateway_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The interior BGP peer IP address for the transit gateway.
        """
        transit_gateway_asn: NotRequired[pulumi.Input[_builtins.float]]
        """
        The transit gateway Autonomous System Number (ASN).
        """
elif False:
    TransitGatewayConnectPeerTransitGatewayAttachmentBgpConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransitGatewayConnectPeerTransitGatewayAttachmentBgpConfigurationArgs:
    def __init__(__self__, *,
                 bgp_status: Optional[pulumi.Input[_builtins.str]] = None,
                 peer_address: Optional[pulumi.Input[_builtins.str]] = None,
                 peer_asn: Optional[pulumi.Input[_builtins.float]] = None,
                 transit_gateway_address: Optional[pulumi.Input[_builtins.str]] = None,
                 transit_gateway_asn: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] bgp_status: The BGP status.
        :param pulumi.Input[_builtins.str] peer_address: The interior BGP peer IP address for the appliance.
        :param pulumi.Input[_builtins.float] peer_asn: The peer Autonomous System Number (ASN).
        :param pulumi.Input[_builtins.str] transit_gateway_address: The interior BGP peer IP address for the transit gateway.
        :param pulumi.Input[_builtins.float] transit_gateway_asn: The transit gateway Autonomous System Number (ASN).
        """
        if bgp_status is not None:
            pulumi.set(__self__, "bgp_status", bgp_status)
        if peer_address is not None:
            pulumi.set(__self__, "peer_address", peer_address)
        if peer_asn is not None:
            pulumi.set(__self__, "peer_asn", peer_asn)
        if transit_gateway_address is not None:
            pulumi.set(__self__, "transit_gateway_address", transit_gateway_address)
        if transit_gateway_asn is not None:
            pulumi.set(__self__, "transit_gateway_asn", transit_gateway_asn)

    @_builtins.property
    @pulumi.getter(name="bgpStatus")
    def bgp_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The BGP status.
        """
        return pulumi.get(self, "bgp_status")

    @bgp_status.setter
    def bgp_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bgp_status", value)

    @_builtins.property
    @pulumi.getter(name="peerAddress")
    def peer_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The interior BGP peer IP address for the appliance.
        """
        return pulumi.get(self, "peer_address")

    @peer_address.setter
    def peer_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "peer_address", value)

    @_builtins.property
    @pulumi.getter(name="peerAsn")
    def peer_asn(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The peer Autonomous System Number (ASN).
        """
        return pulumi.get(self, "peer_asn")

    @peer_asn.setter
    def peer_asn(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "peer_asn", value)

    @_builtins.property
    @pulumi.getter(name="transitGatewayAddress")
    def transit_gateway_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The interior BGP peer IP address for the transit gateway.
        """
        return pulumi.get(self, "transit_gateway_address")

    @transit_gateway_address.setter
    def transit_gateway_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "transit_gateway_address", value)

    @_builtins.property
    @pulumi.getter(name="transitGatewayAsn")
    def transit_gateway_asn(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The transit gateway Autonomous System Number (ASN).
        """
        return pulumi.get(self, "transit_gateway_asn")

    @transit_gateway_asn.setter
    def transit_gateway_asn(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "transit_gateway_asn", value)


if not MYPY:
    class VerifiedAccessEndpointCidrOptionsArgsDict(TypedDict):
        """
        The options for cidr type endpoint.
        """
        cidr: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP address range, in CIDR notation.
        """
        port_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input['VerifiedAccessEndpointPortRangeArgsDict']]]]
        """
        The list of port range.
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP protocol.
        """
        subnet_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The IDs of the subnets.
        """
elif False:
    VerifiedAccessEndpointCidrOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VerifiedAccessEndpointCidrOptionsArgs:
    def __init__(__self__, *,
                 cidr: Optional[pulumi.Input[_builtins.str]] = None,
                 port_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['VerifiedAccessEndpointPortRangeArgs']]]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        The options for cidr type endpoint.
        :param pulumi.Input[_builtins.str] cidr: The IP address range, in CIDR notation.
        :param pulumi.Input[Sequence[pulumi.Input['VerifiedAccessEndpointPortRangeArgs']]] port_ranges: The list of port range.
        :param pulumi.Input[_builtins.str] protocol: The IP protocol.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] subnet_ids: The IDs of the subnets.
        """
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if subnet_ids is not None:
            pulumi.set(__self__, "subnet_ids", subnet_ids)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP address range, in CIDR notation.
        """
        return pulumi.get(self, "cidr")

    @cidr.setter
    def cidr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cidr", value)

    @_builtins.property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VerifiedAccessEndpointPortRangeArgs']]]]:
        """
        The list of port range.
        """
        return pulumi.get(self, "port_ranges")

    @port_ranges.setter
    def port_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VerifiedAccessEndpointPortRangeArgs']]]]):
        pulumi.set(self, "port_ranges", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP protocol.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The IDs of the subnets.
        """
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "subnet_ids", value)


if not MYPY:
    class VerifiedAccessEndpointLoadBalancerOptionsArgsDict(TypedDict):
        """
        The load balancer details if creating the AWS Verified Access endpoint as load-balancertype.
        """
        load_balancer_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ARN of the load balancer.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The IP port number.
        """
        port_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input['VerifiedAccessEndpointPortRangeArgsDict']]]]
        """
        The list of port range.
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP protocol.
        """
        subnet_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The IDs of the subnets.
        """
elif False:
    VerifiedAccessEndpointLoadBalancerOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VerifiedAccessEndpointLoadBalancerOptionsArgs:
    def __init__(__self__, *,
                 load_balancer_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['VerifiedAccessEndpointPortRangeArgs']]]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        The load balancer details if creating the AWS Verified Access endpoint as load-balancertype.
        :param pulumi.Input[_builtins.str] load_balancer_arn: The ARN of the load balancer.
        :param pulumi.Input[_builtins.int] port: The IP port number.
        :param pulumi.Input[Sequence[pulumi.Input['VerifiedAccessEndpointPortRangeArgs']]] port_ranges: The list of port range.
        :param pulumi.Input[_builtins.str] protocol: The IP protocol.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] subnet_ids: The IDs of the subnets.
        """
        if load_balancer_arn is not None:
            pulumi.set(__self__, "load_balancer_arn", load_balancer_arn)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if subnet_ids is not None:
            pulumi.set(__self__, "subnet_ids", subnet_ids)

    @_builtins.property
    @pulumi.getter(name="loadBalancerArn")
    def load_balancer_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ARN of the load balancer.
        """
        return pulumi.get(self, "load_balancer_arn")

    @load_balancer_arn.setter
    def load_balancer_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "load_balancer_arn", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The IP port number.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VerifiedAccessEndpointPortRangeArgs']]]]:
        """
        The list of port range.
        """
        return pulumi.get(self, "port_ranges")

    @port_ranges.setter
    def port_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VerifiedAccessEndpointPortRangeArgs']]]]):
        pulumi.set(self, "port_ranges", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP protocol.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The IDs of the subnets.
        """
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "subnet_ids", value)


if not MYPY:
    class VerifiedAccessEndpointNetworkInterfaceOptionsArgsDict(TypedDict):
        """
        The options for network-interface type endpoint.
        """
        network_interface_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the network interface.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The IP port number.
        """
        port_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input['VerifiedAccessEndpointPortRangeArgsDict']]]]
        """
        The list of port ranges.
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP protocol.
        """
elif False:
    VerifiedAccessEndpointNetworkInterfaceOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VerifiedAccessEndpointNetworkInterfaceOptionsArgs:
    def __init__(__self__, *,
                 network_interface_id: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 port_ranges: Optional[pulumi.Input[Sequence[pulumi.Input['VerifiedAccessEndpointPortRangeArgs']]]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The options for network-interface type endpoint.
        :param pulumi.Input[_builtins.str] network_interface_id: The ID of the network interface.
        :param pulumi.Input[_builtins.int] port: The IP port number.
        :param pulumi.Input[Sequence[pulumi.Input['VerifiedAccessEndpointPortRangeArgs']]] port_ranges: The list of port ranges.
        :param pulumi.Input[_builtins.str] protocol: The IP protocol.
        """
        if network_interface_id is not None:
            pulumi.set(__self__, "network_interface_id", network_interface_id)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the network interface.
        """
        return pulumi.get(self, "network_interface_id")

    @network_interface_id.setter
    def network_interface_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "network_interface_id", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The IP port number.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VerifiedAccessEndpointPortRangeArgs']]]]:
        """
        The list of port ranges.
        """
        return pulumi.get(self, "port_ranges")

    @port_ranges.setter
    def port_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VerifiedAccessEndpointPortRangeArgs']]]]):
        pulumi.set(self, "port_ranges", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP protocol.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class VerifiedAccessEndpointPortRangeArgsDict(TypedDict):
        """
        The IP port range.
        """
        from_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The first port in the range.
        """
        to_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The last port in the range.
        """
elif False:
    VerifiedAccessEndpointPortRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VerifiedAccessEndpointPortRangeArgs:
    def __init__(__self__, *,
                 from_port: Optional[pulumi.Input[_builtins.int]] = None,
                 to_port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        The IP port range.
        :param pulumi.Input[_builtins.int] from_port: The first port in the range.
        :param pulumi.Input[_builtins.int] to_port: The last port in the range.
        """
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The first port in the range.
        """
        return pulumi.get(self, "from_port")

    @from_port.setter
    def from_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "from_port", value)

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The last port in the range.
        """
        return pulumi.get(self, "to_port")

    @to_port.setter
    def to_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "to_port", value)


if not MYPY:
    class VerifiedAccessEndpointRdsOptionsArgsDict(TypedDict):
        """
        The options for rds type endpoint.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The IP port number.
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP protocol.
        """
        rds_db_cluster_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ARN of the RDS DB cluster.
        """
        rds_db_instance_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ARN of the RDS DB instance.
        """
        rds_db_proxy_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ARN of the RDS DB proxy.
        """
        rds_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The RDS endpoint.
        """
        subnet_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The IDs of the subnets.
        """
elif False:
    VerifiedAccessEndpointRdsOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VerifiedAccessEndpointRdsOptionsArgs:
    def __init__(__self__, *,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 rds_db_cluster_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 rds_db_instance_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 rds_db_proxy_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 rds_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 subnet_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        The options for rds type endpoint.
        :param pulumi.Input[_builtins.int] port: The IP port number.
        :param pulumi.Input[_builtins.str] protocol: The IP protocol.
        :param pulumi.Input[_builtins.str] rds_db_cluster_arn: The ARN of the RDS DB cluster.
        :param pulumi.Input[_builtins.str] rds_db_instance_arn: The ARN of the RDS DB instance.
        :param pulumi.Input[_builtins.str] rds_db_proxy_arn: The ARN of the RDS DB proxy.
        :param pulumi.Input[_builtins.str] rds_endpoint: The RDS endpoint.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] subnet_ids: The IDs of the subnets.
        """
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if rds_db_cluster_arn is not None:
            pulumi.set(__self__, "rds_db_cluster_arn", rds_db_cluster_arn)
        if rds_db_instance_arn is not None:
            pulumi.set(__self__, "rds_db_instance_arn", rds_db_instance_arn)
        if rds_db_proxy_arn is not None:
            pulumi.set(__self__, "rds_db_proxy_arn", rds_db_proxy_arn)
        if rds_endpoint is not None:
            pulumi.set(__self__, "rds_endpoint", rds_endpoint)
        if subnet_ids is not None:
            pulumi.set(__self__, "subnet_ids", subnet_ids)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The IP port number.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP protocol.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="rdsDbClusterArn")
    def rds_db_cluster_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ARN of the RDS DB cluster.
        """
        return pulumi.get(self, "rds_db_cluster_arn")

    @rds_db_cluster_arn.setter
    def rds_db_cluster_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rds_db_cluster_arn", value)

    @_builtins.property
    @pulumi.getter(name="rdsDbInstanceArn")
    def rds_db_instance_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ARN of the RDS DB instance.
        """
        return pulumi.get(self, "rds_db_instance_arn")

    @rds_db_instance_arn.setter
    def rds_db_instance_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rds_db_instance_arn", value)

    @_builtins.property
    @pulumi.getter(name="rdsDbProxyArn")
    def rds_db_proxy_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ARN of the RDS DB proxy.
        """
        return pulumi.get(self, "rds_db_proxy_arn")

    @rds_db_proxy_arn.setter
    def rds_db_proxy_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rds_db_proxy_arn", value)

    @_builtins.property
    @pulumi.getter(name="rdsEndpoint")
    def rds_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The RDS endpoint.
        """
        return pulumi.get(self, "rds_endpoint")

    @rds_endpoint.setter
    def rds_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rds_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The IDs of the subnets.
        """
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "subnet_ids", value)


if not MYPY:
    class VerifiedAccessEndpointSseSpecificationArgsDict(TypedDict):
        """
        The configuration options for customer provided KMS encryption.
        """
        customer_managed_key_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to encrypt the policy with the provided key or disable encryption
        """
        kms_key_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        KMS Key Arn used to encrypt the group policy
        """
elif False:
    VerifiedAccessEndpointSseSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VerifiedAccessEndpointSseSpecificationArgs:
    def __init__(__self__, *,
                 customer_managed_key_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 kms_key_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The configuration options for customer provided KMS encryption.
        :param pulumi.Input[_builtins.bool] customer_managed_key_enabled: Whether to encrypt the policy with the provided key or disable encryption
        :param pulumi.Input[_builtins.str] kms_key_arn: KMS Key Arn used to encrypt the group policy
        """
        if customer_managed_key_enabled is not None:
            pulumi.set(__self__, "customer_managed_key_enabled", customer_managed_key_enabled)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @_builtins.property
    @pulumi.getter(name="customerManagedKeyEnabled")
    def customer_managed_key_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to encrypt the policy with the provided key or disable encryption
        """
        return pulumi.get(self, "customer_managed_key_enabled")

    @customer_managed_key_enabled.setter
    def customer_managed_key_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "customer_managed_key_enabled", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        KMS Key Arn used to encrypt the group policy
        """
        return pulumi.get(self, "kms_key_arn")

    @kms_key_arn.setter
    def kms_key_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_arn", value)


if not MYPY:
    class VerifiedAccessGroupSseSpecificationArgsDict(TypedDict):
        """
        The configuration options for customer provided KMS encryption.
        """
        customer_managed_key_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to encrypt the policy with the provided key or disable encryption
        """
        kms_key_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        KMS Key Arn used to encrypt the group policy
        """
elif False:
    VerifiedAccessGroupSseSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VerifiedAccessGroupSseSpecificationArgs:
    def __init__(__self__, *,
                 customer_managed_key_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 kms_key_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The configuration options for customer provided KMS encryption.
        :param pulumi.Input[_builtins.bool] customer_managed_key_enabled: Whether to encrypt the policy with the provided key or disable encryption
        :param pulumi.Input[_builtins.str] kms_key_arn: KMS Key Arn used to encrypt the group policy
        """
        if customer_managed_key_enabled is not None:
            pulumi.set(__self__, "customer_managed_key_enabled", customer_managed_key_enabled)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @_builtins.property
    @pulumi.getter(name="customerManagedKeyEnabled")
    def customer_managed_key_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to encrypt the policy with the provided key or disable encryption
        """
        return pulumi.get(self, "customer_managed_key_enabled")

    @customer_managed_key_enabled.setter
    def customer_managed_key_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "customer_managed_key_enabled", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        KMS Key Arn used to encrypt the group policy
        """
        return pulumi.get(self, "kms_key_arn")

    @kms_key_arn.setter
    def kms_key_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_arn", value)


if not MYPY:
    class VerifiedAccessInstanceVerifiedAccessLogsCloudWatchLogsPropertiesArgsDict(TypedDict):
        """
        Sends Verified Access logs to CloudWatch Logs.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether logging is enabled.
        """
        log_group: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the CloudWatch Logs log group.
        """
elif False:
    VerifiedAccessInstanceVerifiedAccessLogsCloudWatchLogsPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VerifiedAccessInstanceVerifiedAccessLogsCloudWatchLogsPropertiesArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 log_group: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Sends Verified Access logs to CloudWatch Logs.
        :param pulumi.Input[_builtins.bool] enabled: Indicates whether logging is enabled.
        :param pulumi.Input[_builtins.str] log_group: The ID of the CloudWatch Logs log group.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if log_group is not None:
            pulumi.set(__self__, "log_group", log_group)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether logging is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="logGroup")
    def log_group(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the CloudWatch Logs log group.
        """
        return pulumi.get(self, "log_group")

    @log_group.setter
    def log_group(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_group", value)


if not MYPY:
    class VerifiedAccessInstanceVerifiedAccessLogsKinesisDataFirehosePropertiesArgsDict(TypedDict):
        """
        Sends Verified Access logs to Kinesis.
        """
        delivery_stream: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the delivery stream.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether logging is enabled.
        """
elif False:
    VerifiedAccessInstanceVerifiedAccessLogsKinesisDataFirehosePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VerifiedAccessInstanceVerifiedAccessLogsKinesisDataFirehosePropertiesArgs:
    def __init__(__self__, *,
                 delivery_stream: Optional[pulumi.Input[_builtins.str]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        Sends Verified Access logs to Kinesis.
        :param pulumi.Input[_builtins.str] delivery_stream: The ID of the delivery stream.
        :param pulumi.Input[_builtins.bool] enabled: Indicates whether logging is enabled.
        """
        if delivery_stream is not None:
            pulumi.set(__self__, "delivery_stream", delivery_stream)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="deliveryStream")
    def delivery_stream(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the delivery stream.
        """
        return pulumi.get(self, "delivery_stream")

    @delivery_stream.setter
    def delivery_stream(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delivery_stream", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether logging is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class VerifiedAccessInstanceVerifiedAccessLogsS3PropertiesArgsDict(TypedDict):
        """
        Sends Verified Access logs to Amazon S3.
        """
        bucket_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bucket name.
        """
        bucket_owner: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the AWS account that owns the Amazon S3 bucket.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether logging is enabled.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The bucket prefix.
        """
elif False:
    VerifiedAccessInstanceVerifiedAccessLogsS3PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VerifiedAccessInstanceVerifiedAccessLogsS3PropertiesArgs:
    def __init__(__self__, *,
                 bucket_name: Optional[pulumi.Input[_builtins.str]] = None,
                 bucket_owner: Optional[pulumi.Input[_builtins.str]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Sends Verified Access logs to Amazon S3.
        :param pulumi.Input[_builtins.str] bucket_name: The bucket name.
        :param pulumi.Input[_builtins.str] bucket_owner: The ID of the AWS account that owns the Amazon S3 bucket.
        :param pulumi.Input[_builtins.bool] enabled: Indicates whether logging is enabled.
        :param pulumi.Input[_builtins.str] prefix: The bucket prefix.
        """
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if bucket_owner is not None:
            pulumi.set(__self__, "bucket_owner", bucket_owner)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bucket name.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="bucketOwner")
    def bucket_owner(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the AWS account that owns the Amazon S3 bucket.
        """
        return pulumi.get(self, "bucket_owner")

    @bucket_owner.setter
    def bucket_owner(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_owner", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether logging is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The bucket prefix.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class VerifiedAccessInstanceVerifiedAccessLogsArgsDict(TypedDict):
        """
        The configuration options for AWS Verified Access instances.
        """
        cloud_watch_logs: NotRequired[pulumi.Input['VerifiedAccessInstanceVerifiedAccessLogsCloudWatchLogsPropertiesArgsDict']]
        """
        Sends Verified Access logs to CloudWatch Logs.
        """
        include_trust_context: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Include claims from trust providers in Verified Access logs.
        """
        kinesis_data_firehose: NotRequired[pulumi.Input['VerifiedAccessInstanceVerifiedAccessLogsKinesisDataFirehosePropertiesArgsDict']]
        """
        Sends Verified Access logs to Kinesis.
        """
        log_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Select log version for Verified Access logs.
        """
        s3: NotRequired[pulumi.Input['VerifiedAccessInstanceVerifiedAccessLogsS3PropertiesArgsDict']]
        """
        Sends Verified Access logs to Amazon S3.
        """
elif False:
    VerifiedAccessInstanceVerifiedAccessLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VerifiedAccessInstanceVerifiedAccessLogsArgs:
    def __init__(__self__, *,
                 cloud_watch_logs: Optional[pulumi.Input['VerifiedAccessInstanceVerifiedAccessLogsCloudWatchLogsPropertiesArgs']] = None,
                 include_trust_context: Optional[pulumi.Input[_builtins.bool]] = None,
                 kinesis_data_firehose: Optional[pulumi.Input['VerifiedAccessInstanceVerifiedAccessLogsKinesisDataFirehosePropertiesArgs']] = None,
                 log_version: Optional[pulumi.Input[_builtins.str]] = None,
                 s3: Optional[pulumi.Input['VerifiedAccessInstanceVerifiedAccessLogsS3PropertiesArgs']] = None):
        """
        The configuration options for AWS Verified Access instances.
        :param pulumi.Input['VerifiedAccessInstanceVerifiedAccessLogsCloudWatchLogsPropertiesArgs'] cloud_watch_logs: Sends Verified Access logs to CloudWatch Logs.
        :param pulumi.Input[_builtins.bool] include_trust_context: Include claims from trust providers in Verified Access logs.
        :param pulumi.Input['VerifiedAccessInstanceVerifiedAccessLogsKinesisDataFirehosePropertiesArgs'] kinesis_data_firehose: Sends Verified Access logs to Kinesis.
        :param pulumi.Input[_builtins.str] log_version: Select log version for Verified Access logs.
        :param pulumi.Input['VerifiedAccessInstanceVerifiedAccessLogsS3PropertiesArgs'] s3: Sends Verified Access logs to Amazon S3.
        """
        if cloud_watch_logs is not None:
            pulumi.set(__self__, "cloud_watch_logs", cloud_watch_logs)
        if include_trust_context is not None:
            pulumi.set(__self__, "include_trust_context", include_trust_context)
        if kinesis_data_firehose is not None:
            pulumi.set(__self__, "kinesis_data_firehose", kinesis_data_firehose)
        if log_version is not None:
            pulumi.set(__self__, "log_version", log_version)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @_builtins.property
    @pulumi.getter(name="cloudWatchLogs")
    def cloud_watch_logs(self) -> Optional[pulumi.Input['VerifiedAccessInstanceVerifiedAccessLogsCloudWatchLogsPropertiesArgs']]:
        """
        Sends Verified Access logs to CloudWatch Logs.
        """
        return pulumi.get(self, "cloud_watch_logs")

    @cloud_watch_logs.setter
    def cloud_watch_logs(self, value: Optional[pulumi.Input['VerifiedAccessInstanceVerifiedAccessLogsCloudWatchLogsPropertiesArgs']]):
        pulumi.set(self, "cloud_watch_logs", value)

    @_builtins.property
    @pulumi.getter(name="includeTrustContext")
    def include_trust_context(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Include claims from trust providers in Verified Access logs.
        """
        return pulumi.get(self, "include_trust_context")

    @include_trust_context.setter
    def include_trust_context(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "include_trust_context", value)

    @_builtins.property
    @pulumi.getter(name="kinesisDataFirehose")
    def kinesis_data_firehose(self) -> Optional[pulumi.Input['VerifiedAccessInstanceVerifiedAccessLogsKinesisDataFirehosePropertiesArgs']]:
        """
        Sends Verified Access logs to Kinesis.
        """
        return pulumi.get(self, "kinesis_data_firehose")

    @kinesis_data_firehose.setter
    def kinesis_data_firehose(self, value: Optional[pulumi.Input['VerifiedAccessInstanceVerifiedAccessLogsKinesisDataFirehosePropertiesArgs']]):
        pulumi.set(self, "kinesis_data_firehose", value)

    @_builtins.property
    @pulumi.getter(name="logVersion")
    def log_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Select log version for Verified Access logs.
        """
        return pulumi.get(self, "log_version")

    @log_version.setter
    def log_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_version", value)

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['VerifiedAccessInstanceVerifiedAccessLogsS3PropertiesArgs']]:
        """
        Sends Verified Access logs to Amazon S3.
        """
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['VerifiedAccessInstanceVerifiedAccessLogsS3PropertiesArgs']]):
        pulumi.set(self, "s3", value)


if not MYPY:
    class VerifiedAccessInstanceVerifiedAccessTrustProviderArgsDict(TypedDict):
        """
        A Verified Access Trust Provider.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of trust provider.
        """
        device_trust_provider_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of device-based trust provider.
        """
        trust_provider_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of trust provider (user- or device-based).
        """
        user_trust_provider_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of user-based trust provider.
        """
        verified_access_trust_provider_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the trust provider.
        """
elif False:
    VerifiedAccessInstanceVerifiedAccessTrustProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VerifiedAccessInstanceVerifiedAccessTrustProviderArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 device_trust_provider_type: Optional[pulumi.Input[_builtins.str]] = None,
                 trust_provider_type: Optional[pulumi.Input[_builtins.str]] = None,
                 user_trust_provider_type: Optional[pulumi.Input[_builtins.str]] = None,
                 verified_access_trust_provider_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        A Verified Access Trust Provider.
        :param pulumi.Input[_builtins.str] description: The description of trust provider.
        :param pulumi.Input[_builtins.str] device_trust_provider_type: The type of device-based trust provider.
        :param pulumi.Input[_builtins.str] trust_provider_type: The type of trust provider (user- or device-based).
        :param pulumi.Input[_builtins.str] user_trust_provider_type: The type of user-based trust provider.
        :param pulumi.Input[_builtins.str] verified_access_trust_provider_id: The ID of the trust provider.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if device_trust_provider_type is not None:
            pulumi.set(__self__, "device_trust_provider_type", device_trust_provider_type)
        if trust_provider_type is not None:
            pulumi.set(__self__, "trust_provider_type", trust_provider_type)
        if user_trust_provider_type is not None:
            pulumi.set(__self__, "user_trust_provider_type", user_trust_provider_type)
        if verified_access_trust_provider_id is not None:
            pulumi.set(__self__, "verified_access_trust_provider_id", verified_access_trust_provider_id)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of trust provider.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="deviceTrustProviderType")
    def device_trust_provider_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of device-based trust provider.
        """
        return pulumi.get(self, "device_trust_provider_type")

    @device_trust_provider_type.setter
    def device_trust_provider_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device_trust_provider_type", value)

    @_builtins.property
    @pulumi.getter(name="trustProviderType")
    def trust_provider_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of trust provider (user- or device-based).
        """
        return pulumi.get(self, "trust_provider_type")

    @trust_provider_type.setter
    def trust_provider_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "trust_provider_type", value)

    @_builtins.property
    @pulumi.getter(name="userTrustProviderType")
    def user_trust_provider_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of user-based trust provider.
        """
        return pulumi.get(self, "user_trust_provider_type")

    @user_trust_provider_type.setter
    def user_trust_provider_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_trust_provider_type", value)

    @_builtins.property
    @pulumi.getter(name="verifiedAccessTrustProviderId")
    def verified_access_trust_provider_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the trust provider.
        """
        return pulumi.get(self, "verified_access_trust_provider_id")

    @verified_access_trust_provider_id.setter
    def verified_access_trust_provider_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "verified_access_trust_provider_id", value)


if not MYPY:
    class VerifiedAccessTrustProviderDeviceOptionsArgsDict(TypedDict):
        """
        The options for device identity based trust providers.
        """
        public_signing_key_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        URL Verified Access will use to verify authenticity of the device tokens.
        """
        tenant_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the tenant application with the device-identity provider.
        """
elif False:
    VerifiedAccessTrustProviderDeviceOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VerifiedAccessTrustProviderDeviceOptionsArgs:
    def __init__(__self__, *,
                 public_signing_key_url: Optional[pulumi.Input[_builtins.str]] = None,
                 tenant_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The options for device identity based trust providers.
        :param pulumi.Input[_builtins.str] public_signing_key_url: URL Verified Access will use to verify authenticity of the device tokens.
        :param pulumi.Input[_builtins.str] tenant_id: The ID of the tenant application with the device-identity provider.
        """
        if public_signing_key_url is not None:
            pulumi.set(__self__, "public_signing_key_url", public_signing_key_url)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter(name="publicSigningKeyUrl")
    def public_signing_key_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URL Verified Access will use to verify authenticity of the device tokens.
        """
        return pulumi.get(self, "public_signing_key_url")

    @public_signing_key_url.setter
    def public_signing_key_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_signing_key_url", value)

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the tenant application with the device-identity provider.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class VerifiedAccessTrustProviderNativeApplicationOidcOptionsArgsDict(TypedDict):
        """
        The OpenID Connect details for an oidc -type, user-identity based trust provider for L4.
        """
        authorization_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The OIDC authorization endpoint.
        """
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client identifier.
        """
        client_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client secret.
        """
        issuer: NotRequired[pulumi.Input[_builtins.str]]
        """
        The OIDC issuer.
        """
        public_signing_key_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The public signing key for endpoint
        """
        scope: NotRequired[pulumi.Input[_builtins.str]]
        """
        OpenID Connect (OIDC) scopes are used by an application during authentication to authorize access to details of a user. Each scope returns a specific set of user attributes.
        """
        token_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The OIDC token endpoint.
        """
        user_info_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The OIDC user info endpoint.
        """
elif False:
    VerifiedAccessTrustProviderNativeApplicationOidcOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VerifiedAccessTrustProviderNativeApplicationOidcOptionsArgs:
    def __init__(__self__, *,
                 authorization_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 issuer: Optional[pulumi.Input[_builtins.str]] = None,
                 public_signing_key_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 scope: Optional[pulumi.Input[_builtins.str]] = None,
                 token_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 user_info_endpoint: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The OpenID Connect details for an oidc -type, user-identity based trust provider for L4.
        :param pulumi.Input[_builtins.str] authorization_endpoint: The OIDC authorization endpoint.
        :param pulumi.Input[_builtins.str] client_id: The client identifier.
        :param pulumi.Input[_builtins.str] client_secret: The client secret.
        :param pulumi.Input[_builtins.str] issuer: The OIDC issuer.
        :param pulumi.Input[_builtins.str] public_signing_key_endpoint: The public signing key for endpoint
        :param pulumi.Input[_builtins.str] scope: OpenID Connect (OIDC) scopes are used by an application during authentication to authorize access to details of a user. Each scope returns a specific set of user attributes.
        :param pulumi.Input[_builtins.str] token_endpoint: The OIDC token endpoint.
        :param pulumi.Input[_builtins.str] user_info_endpoint: The OIDC user info endpoint.
        """
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if public_signing_key_endpoint is not None:
            pulumi.set(__self__, "public_signing_key_endpoint", public_signing_key_endpoint)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if user_info_endpoint is not None:
            pulumi.set(__self__, "user_info_endpoint", user_info_endpoint)

    @_builtins.property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The OIDC authorization endpoint.
        """
        return pulumi.get(self, "authorization_endpoint")

    @authorization_endpoint.setter
    def authorization_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authorization_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client identifier.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client secret.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The OIDC issuer.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "issuer", value)

    @_builtins.property
    @pulumi.getter(name="publicSigningKeyEndpoint")
    def public_signing_key_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The public signing key for endpoint
        """
        return pulumi.get(self, "public_signing_key_endpoint")

    @public_signing_key_endpoint.setter
    def public_signing_key_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_signing_key_endpoint", value)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OpenID Connect (OIDC) scopes are used by an application during authentication to authorize access to details of a user. Each scope returns a specific set of user attributes.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scope", value)

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The OIDC token endpoint.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="userInfoEndpoint")
    def user_info_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The OIDC user info endpoint.
        """
        return pulumi.get(self, "user_info_endpoint")

    @user_info_endpoint.setter
    def user_info_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_info_endpoint", value)


if not MYPY:
    class VerifiedAccessTrustProviderOidcOptionsArgsDict(TypedDict):
        """
        The OpenID Connect details for an oidc -type, user-identity based trust provider.
        """
        authorization_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The OIDC authorization endpoint.
        """
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client identifier.
        """
        client_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client secret.
        """
        issuer: NotRequired[pulumi.Input[_builtins.str]]
        """
        The OIDC issuer.
        """
        scope: NotRequired[pulumi.Input[_builtins.str]]
        """
        OpenID Connect (OIDC) scopes are used by an application during authentication to authorize access to details of a user. Each scope returns a specific set of user attributes.
        """
        token_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The OIDC token endpoint.
        """
        user_info_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The OIDC user info endpoint.
        """
elif False:
    VerifiedAccessTrustProviderOidcOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VerifiedAccessTrustProviderOidcOptionsArgs:
    def __init__(__self__, *,
                 authorization_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 issuer: Optional[pulumi.Input[_builtins.str]] = None,
                 scope: Optional[pulumi.Input[_builtins.str]] = None,
                 token_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 user_info_endpoint: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The OpenID Connect details for an oidc -type, user-identity based trust provider.
        :param pulumi.Input[_builtins.str] authorization_endpoint: The OIDC authorization endpoint.
        :param pulumi.Input[_builtins.str] client_id: The client identifier.
        :param pulumi.Input[_builtins.str] client_secret: The client secret.
        :param pulumi.Input[_builtins.str] issuer: The OIDC issuer.
        :param pulumi.Input[_builtins.str] scope: OpenID Connect (OIDC) scopes are used by an application during authentication to authorize access to details of a user. Each scope returns a specific set of user attributes.
        :param pulumi.Input[_builtins.str] token_endpoint: The OIDC token endpoint.
        :param pulumi.Input[_builtins.str] user_info_endpoint: The OIDC user info endpoint.
        """
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if user_info_endpoint is not None:
            pulumi.set(__self__, "user_info_endpoint", user_info_endpoint)

    @_builtins.property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The OIDC authorization endpoint.
        """
        return pulumi.get(self, "authorization_endpoint")

    @authorization_endpoint.setter
    def authorization_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authorization_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client identifier.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client secret.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The OIDC issuer.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "issuer", value)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OpenID Connect (OIDC) scopes are used by an application during authentication to authorize access to details of a user. Each scope returns a specific set of user attributes.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scope", value)

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The OIDC token endpoint.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="userInfoEndpoint")
    def user_info_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The OIDC user info endpoint.
        """
        return pulumi.get(self, "user_info_endpoint")

    @user_info_endpoint.setter
    def user_info_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_info_endpoint", value)


if not MYPY:
    class VpcEndpointDnsOptionsSpecificationArgsDict(TypedDict):
        """
        Describes the DNS options for an endpoint.
        """
        dns_record_ip_type: NotRequired[pulumi.Input['VpcEndpointDnsOptionsSpecificationDnsRecordIpType']]
        """
        The DNS records created for the endpoint.
        """
        private_dns_only_for_inbound_resolver_endpoint: NotRequired[pulumi.Input['VpcEndpointDnsOptionsSpecificationPrivateDnsOnlyForInboundResolverEndpoint']]
        """
        Indicates whether to enable private DNS only for inbound endpoints. This option is available only for services that support both gateway and interface endpoints. It routes traffic that originates from the VPC to the gateway endpoint and traffic that originates from on-premises to the interface endpoint.
        """
elif False:
    VpcEndpointDnsOptionsSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcEndpointDnsOptionsSpecificationArgs:
    def __init__(__self__, *,
                 dns_record_ip_type: Optional[pulumi.Input['VpcEndpointDnsOptionsSpecificationDnsRecordIpType']] = None,
                 private_dns_only_for_inbound_resolver_endpoint: Optional[pulumi.Input['VpcEndpointDnsOptionsSpecificationPrivateDnsOnlyForInboundResolverEndpoint']] = None):
        """
        Describes the DNS options for an endpoint.
        :param pulumi.Input['VpcEndpointDnsOptionsSpecificationDnsRecordIpType'] dns_record_ip_type: The DNS records created for the endpoint.
        :param pulumi.Input['VpcEndpointDnsOptionsSpecificationPrivateDnsOnlyForInboundResolverEndpoint'] private_dns_only_for_inbound_resolver_endpoint: Indicates whether to enable private DNS only for inbound endpoints. This option is available only for services that support both gateway and interface endpoints. It routes traffic that originates from the VPC to the gateway endpoint and traffic that originates from on-premises to the interface endpoint.
        """
        if dns_record_ip_type is not None:
            pulumi.set(__self__, "dns_record_ip_type", dns_record_ip_type)
        if private_dns_only_for_inbound_resolver_endpoint is not None:
            pulumi.set(__self__, "private_dns_only_for_inbound_resolver_endpoint", private_dns_only_for_inbound_resolver_endpoint)

    @_builtins.property
    @pulumi.getter(name="dnsRecordIpType")
    def dns_record_ip_type(self) -> Optional[pulumi.Input['VpcEndpointDnsOptionsSpecificationDnsRecordIpType']]:
        """
        The DNS records created for the endpoint.
        """
        return pulumi.get(self, "dns_record_ip_type")

    @dns_record_ip_type.setter
    def dns_record_ip_type(self, value: Optional[pulumi.Input['VpcEndpointDnsOptionsSpecificationDnsRecordIpType']]):
        pulumi.set(self, "dns_record_ip_type", value)

    @_builtins.property
    @pulumi.getter(name="privateDnsOnlyForInboundResolverEndpoint")
    def private_dns_only_for_inbound_resolver_endpoint(self) -> Optional[pulumi.Input['VpcEndpointDnsOptionsSpecificationPrivateDnsOnlyForInboundResolverEndpoint']]:
        """
        Indicates whether to enable private DNS only for inbound endpoints. This option is available only for services that support both gateway and interface endpoints. It routes traffic that originates from the VPC to the gateway endpoint and traffic that originates from on-premises to the interface endpoint.
        """
        return pulumi.get(self, "private_dns_only_for_inbound_resolver_endpoint")

    @private_dns_only_for_inbound_resolver_endpoint.setter
    def private_dns_only_for_inbound_resolver_endpoint(self, value: Optional[pulumi.Input['VpcEndpointDnsOptionsSpecificationPrivateDnsOnlyForInboundResolverEndpoint']]):
        pulumi.set(self, "private_dns_only_for_inbound_resolver_endpoint", value)


if not MYPY:
    class VpnConnectionCloudwatchLogOptionsSpecificationArgsDict(TypedDict):
        """
        Options for sending VPN tunnel logs to CloudWatch.
        """
        log_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable or disable VPN tunnel logging feature. Default value is ``False``.
         Valid values: ``True`` | ``False``
        """
        log_group_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Amazon Resource Name (ARN) of the CloudWatch log group to send logs to.
        """
        log_output_format: NotRequired[pulumi.Input['VpnConnectionCloudwatchLogOptionsSpecificationLogOutputFormat']]
        """
        Set log format. Default format is ``json``.
         Valid values: ``json`` | ``text``
        """
elif False:
    VpnConnectionCloudwatchLogOptionsSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpnConnectionCloudwatchLogOptionsSpecificationArgs:
    def __init__(__self__, *,
                 log_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 log_group_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 log_output_format: Optional[pulumi.Input['VpnConnectionCloudwatchLogOptionsSpecificationLogOutputFormat']] = None):
        """
        Options for sending VPN tunnel logs to CloudWatch.
        :param pulumi.Input[_builtins.bool] log_enabled: Enable or disable VPN tunnel logging feature. Default value is ``False``.
                Valid values: ``True`` | ``False``
        :param pulumi.Input[_builtins.str] log_group_arn: The Amazon Resource Name (ARN) of the CloudWatch log group to send logs to.
        :param pulumi.Input['VpnConnectionCloudwatchLogOptionsSpecificationLogOutputFormat'] log_output_format: Set log format. Default format is ``json``.
                Valid values: ``json`` | ``text``
        """
        if log_enabled is not None:
            pulumi.set(__self__, "log_enabled", log_enabled)
        if log_group_arn is not None:
            pulumi.set(__self__, "log_group_arn", log_group_arn)
        if log_output_format is not None:
            pulumi.set(__self__, "log_output_format", log_output_format)

    @_builtins.property
    @pulumi.getter(name="logEnabled")
    def log_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable or disable VPN tunnel logging feature. Default value is ``False``.
         Valid values: ``True`` | ``False``
        """
        return pulumi.get(self, "log_enabled")

    @log_enabled.setter
    def log_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "log_enabled", value)

    @_builtins.property
    @pulumi.getter(name="logGroupArn")
    def log_group_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Amazon Resource Name (ARN) of the CloudWatch log group to send logs to.
        """
        return pulumi.get(self, "log_group_arn")

    @log_group_arn.setter
    def log_group_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_group_arn", value)

    @_builtins.property
    @pulumi.getter(name="logOutputFormat")
    def log_output_format(self) -> Optional[pulumi.Input['VpnConnectionCloudwatchLogOptionsSpecificationLogOutputFormat']]:
        """
        Set log format. Default format is ``json``.
         Valid values: ``json`` | ``text``
        """
        return pulumi.get(self, "log_output_format")

    @log_output_format.setter
    def log_output_format(self, value: Optional[pulumi.Input['VpnConnectionCloudwatchLogOptionsSpecificationLogOutputFormat']]):
        pulumi.set(self, "log_output_format", value)


if not MYPY:
    class VpnConnectionIkeVersionsRequestListValueArgsDict(TypedDict):
        """
        The IKE version that is permitted for the VPN tunnel.
        """
        value: NotRequired[pulumi.Input['VpnConnectionIkeVersionsRequestListValueValue']]
        """
        The IKE version.
        """
elif False:
    VpnConnectionIkeVersionsRequestListValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpnConnectionIkeVersionsRequestListValueArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input['VpnConnectionIkeVersionsRequestListValueValue']] = None):
        """
        The IKE version that is permitted for the VPN tunnel.
        :param pulumi.Input['VpnConnectionIkeVersionsRequestListValueValue'] value: The IKE version.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input['VpnConnectionIkeVersionsRequestListValueValue']]:
        """
        The IKE version.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input['VpnConnectionIkeVersionsRequestListValueValue']]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VpnConnectionPhase1EncryptionAlgorithmsRequestListValueArgsDict(TypedDict):
        """
        Specifies the encryption algorithm for the VPN tunnel for phase 1 IKE negotiations.
        """
        value: NotRequired[pulumi.Input['VpnConnectionPhase1EncryptionAlgorithmsRequestListValueValue']]
        """
        The value for the encryption algorithm.
        """
elif False:
    VpnConnectionPhase1EncryptionAlgorithmsRequestListValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpnConnectionPhase1EncryptionAlgorithmsRequestListValueArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input['VpnConnectionPhase1EncryptionAlgorithmsRequestListValueValue']] = None):
        """
        Specifies the encryption algorithm for the VPN tunnel for phase 1 IKE negotiations.
        :param pulumi.Input['VpnConnectionPhase1EncryptionAlgorithmsRequestListValueValue'] value: The value for the encryption algorithm.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input['VpnConnectionPhase1EncryptionAlgorithmsRequestListValueValue']]:
        """
        The value for the encryption algorithm.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input['VpnConnectionPhase1EncryptionAlgorithmsRequestListValueValue']]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VpnConnectionPhase1IntegrityAlgorithmsRequestListValueArgsDict(TypedDict):
        """
        Specifies the integrity algorithm for the VPN tunnel for phase 1 IKE negotiations.
        """
        value: NotRequired[pulumi.Input['VpnConnectionPhase1IntegrityAlgorithmsRequestListValueValue']]
        """
        The value for the integrity algorithm.
        """
elif False:
    VpnConnectionPhase1IntegrityAlgorithmsRequestListValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpnConnectionPhase1IntegrityAlgorithmsRequestListValueArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input['VpnConnectionPhase1IntegrityAlgorithmsRequestListValueValue']] = None):
        """
        Specifies the integrity algorithm for the VPN tunnel for phase 1 IKE negotiations.
        :param pulumi.Input['VpnConnectionPhase1IntegrityAlgorithmsRequestListValueValue'] value: The value for the integrity algorithm.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input['VpnConnectionPhase1IntegrityAlgorithmsRequestListValueValue']]:
        """
        The value for the integrity algorithm.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input['VpnConnectionPhase1IntegrityAlgorithmsRequestListValueValue']]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VpnConnectionPhase1dhGroupNumbersRequestListValueArgsDict(TypedDict):
        """
        Specifies a Diffie-Hellman group number for the VPN tunnel for phase 1 IKE negotiations.
        """
        value: NotRequired[pulumi.Input[_builtins.int]]
        """
        The Diffie-Hellmann group number.
        """
elif False:
    VpnConnectionPhase1dhGroupNumbersRequestListValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpnConnectionPhase1dhGroupNumbersRequestListValueArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[_builtins.int]] = None):
        """
        Specifies a Diffie-Hellman group number for the VPN tunnel for phase 1 IKE negotiations.
        :param pulumi.Input[_builtins.int] value: The Diffie-Hellmann group number.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The Diffie-Hellmann group number.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VpnConnectionPhase2EncryptionAlgorithmsRequestListValueArgsDict(TypedDict):
        """
        Specifies the encryption algorithm for the VPN tunnel for phase 2 IKE negotiations.
        """
        value: NotRequired[pulumi.Input['VpnConnectionPhase2EncryptionAlgorithmsRequestListValueValue']]
        """
        The encryption algorithm.
        """
elif False:
    VpnConnectionPhase2EncryptionAlgorithmsRequestListValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpnConnectionPhase2EncryptionAlgorithmsRequestListValueArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input['VpnConnectionPhase2EncryptionAlgorithmsRequestListValueValue']] = None):
        """
        Specifies the encryption algorithm for the VPN tunnel for phase 2 IKE negotiations.
        :param pulumi.Input['VpnConnectionPhase2EncryptionAlgorithmsRequestListValueValue'] value: The encryption algorithm.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input['VpnConnectionPhase2EncryptionAlgorithmsRequestListValueValue']]:
        """
        The encryption algorithm.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input['VpnConnectionPhase2EncryptionAlgorithmsRequestListValueValue']]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VpnConnectionPhase2IntegrityAlgorithmsRequestListValueArgsDict(TypedDict):
        """
        Specifies the integrity algorithm for the VPN tunnel for phase 2 IKE negotiations.
        """
        value: NotRequired[pulumi.Input['VpnConnectionPhase2IntegrityAlgorithmsRequestListValueValue']]
        """
        The integrity algorithm.
        """
elif False:
    VpnConnectionPhase2IntegrityAlgorithmsRequestListValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpnConnectionPhase2IntegrityAlgorithmsRequestListValueArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input['VpnConnectionPhase2IntegrityAlgorithmsRequestListValueValue']] = None):
        """
        Specifies the integrity algorithm for the VPN tunnel for phase 2 IKE negotiations.
        :param pulumi.Input['VpnConnectionPhase2IntegrityAlgorithmsRequestListValueValue'] value: The integrity algorithm.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input['VpnConnectionPhase2IntegrityAlgorithmsRequestListValueValue']]:
        """
        The integrity algorithm.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input['VpnConnectionPhase2IntegrityAlgorithmsRequestListValueValue']]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VpnConnectionPhase2dhGroupNumbersRequestListValueArgsDict(TypedDict):
        """
        Specifies a Diffie-Hellman group number for the VPN tunnel for phase 2 IKE negotiations.
        """
        value: NotRequired[pulumi.Input[_builtins.int]]
        """
        The Diffie-Hellmann group number.
        """
elif False:
    VpnConnectionPhase2dhGroupNumbersRequestListValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpnConnectionPhase2dhGroupNumbersRequestListValueArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[_builtins.int]] = None):
        """
        Specifies a Diffie-Hellman group number for the VPN tunnel for phase 2 IKE negotiations.
        :param pulumi.Input[_builtins.int] value: The Diffie-Hellmann group number.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The Diffie-Hellmann group number.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class VpnConnectionVpnTunnelLogOptionsSpecificationArgsDict(TypedDict):
        """
        Options for logging VPN tunnel activity.
        """
        cloudwatch_log_options: NotRequired[pulumi.Input['VpnConnectionCloudwatchLogOptionsSpecificationArgsDict']]
        """
        Options for sending VPN tunnel logs to CloudWatch.
        """
elif False:
    VpnConnectionVpnTunnelLogOptionsSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpnConnectionVpnTunnelLogOptionsSpecificationArgs:
    def __init__(__self__, *,
                 cloudwatch_log_options: Optional[pulumi.Input['VpnConnectionCloudwatchLogOptionsSpecificationArgs']] = None):
        """
        Options for logging VPN tunnel activity.
        :param pulumi.Input['VpnConnectionCloudwatchLogOptionsSpecificationArgs'] cloudwatch_log_options: Options for sending VPN tunnel logs to CloudWatch.
        """
        if cloudwatch_log_options is not None:
            pulumi.set(__self__, "cloudwatch_log_options", cloudwatch_log_options)

    @_builtins.property
    @pulumi.getter(name="cloudwatchLogOptions")
    def cloudwatch_log_options(self) -> Optional[pulumi.Input['VpnConnectionCloudwatchLogOptionsSpecificationArgs']]:
        """
        Options for sending VPN tunnel logs to CloudWatch.
        """
        return pulumi.get(self, "cloudwatch_log_options")

    @cloudwatch_log_options.setter
    def cloudwatch_log_options(self, value: Optional[pulumi.Input['VpnConnectionCloudwatchLogOptionsSpecificationArgs']]):
        pulumi.set(self, "cloudwatch_log_options", value)


if not MYPY:
    class VpnConnectionVpnTunnelOptionsSpecificationArgsDict(TypedDict):
        """
        The tunnel options for a single VPN tunnel.
        """
        dpd_timeout_action: NotRequired[pulumi.Input['VpnConnectionVpnTunnelOptionsSpecificationDpdTimeoutAction']]
        """
        The action to take after DPD timeout occurs. Specify ``restart`` to restart the IKE initiation. Specify ``clear`` to end the IKE session.
         Valid Values: ``clear`` | ``none`` | ``restart``
         Default: ``clear``
        """
        dpd_timeout_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of seconds after which a DPD timeout occurs.
         Constraints: A value greater than or equal to 30.
         Default: ``30``
        """
        enable_tunnel_lifecycle_control: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Turn on or off tunnel endpoint lifecycle control feature.
        """
        ike_versions: NotRequired[pulumi.Input[Sequence[pulumi.Input['VpnConnectionIkeVersionsRequestListValueArgsDict']]]]
        """
        The IKE versions that are permitted for the VPN tunnel.
         Valid values: ``ikev1`` | ``ikev2``
        """
        log_options: NotRequired[pulumi.Input['VpnConnectionVpnTunnelLogOptionsSpecificationArgsDict']]
        """
        Options for logging VPN tunnel activity.
        """
        phase1_encryption_algorithms: NotRequired[pulumi.Input[Sequence[pulumi.Input['VpnConnectionPhase1EncryptionAlgorithmsRequestListValueArgsDict']]]]
        """
        One or more encryption algorithms that are permitted for the VPN tunnel for phase 1 IKE negotiations.
         Valid values: ``AES128`` | ``AES256`` | ``AES128-GCM-16`` | ``AES256-GCM-16``
        """
        phase1_integrity_algorithms: NotRequired[pulumi.Input[Sequence[pulumi.Input['VpnConnectionPhase1IntegrityAlgorithmsRequestListValueArgsDict']]]]
        """
        One or more integrity algorithms that are permitted for the VPN tunnel for phase 1 IKE negotiations.
         Valid values: ``SHA1`` | ``SHA2-256`` | ``SHA2-384`` | ``SHA2-512``
        """
        phase1_lifetime_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The lifetime for phase 1 of the IKE negotiation, in seconds.
         Constraints: A value between 900 and 28,800.
         Default: ``28800``
        """
        phase1dh_group_numbers: NotRequired[pulumi.Input[Sequence[pulumi.Input['VpnConnectionPhase1dhGroupNumbersRequestListValueArgsDict']]]]
        """
        One or more Diffie-Hellman group numbers that are permitted for the VPN tunnel for phase 1 IKE negotiations.
         Valid values: ``2`` | ``14`` | ``15`` | ``16`` | ``17`` | ``18`` | ``19`` | ``20`` | ``21`` | ``22`` | ``23`` | ``24``
        """
        phase2_encryption_algorithms: NotRequired[pulumi.Input[Sequence[pulumi.Input['VpnConnectionPhase2EncryptionAlgorithmsRequestListValueArgsDict']]]]
        """
        One or more encryption algorithms that are permitted for the VPN tunnel for phase 2 IKE negotiations.
         Valid values: ``AES128`` | ``AES256`` | ``AES128-GCM-16`` | ``AES256-GCM-16``
        """
        phase2_integrity_algorithms: NotRequired[pulumi.Input[Sequence[pulumi.Input['VpnConnectionPhase2IntegrityAlgorithmsRequestListValueArgsDict']]]]
        """
        One or more integrity algorithms that are permitted for the VPN tunnel for phase 2 IKE negotiations.
         Valid values: ``SHA1`` | ``SHA2-256`` | ``SHA2-384`` | ``SHA2-512``
        """
        phase2_lifetime_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The lifetime for phase 2 of the IKE negotiation, in seconds.
         Constraints: A value between 900 and 3,600. The value must be less than the value for ``Phase1LifetimeSeconds``.
         Default: ``3600``
        """
        phase2dh_group_numbers: NotRequired[pulumi.Input[Sequence[pulumi.Input['VpnConnectionPhase2dhGroupNumbersRequestListValueArgsDict']]]]
        """
        One or more Diffie-Hellman group numbers that are permitted for the VPN tunnel for phase 2 IKE negotiations.
         Valid values: ``2`` | ``5`` | ``14`` | ``15`` | ``16`` | ``17`` | ``18`` | ``19`` | ``20`` | ``21`` | ``22`` | ``23`` | ``24``
        """
        pre_shared_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The pre-shared key (PSK) to establish initial authentication between the virtual private gateway and customer gateway.
         Constraints: Allowed characters are alphanumeric characters, periods (.), and underscores (_). Must be between 8 and 64 characters in length and cannot start with zero (0).
        """
        rekey_fuzz_percentage: NotRequired[pulumi.Input[_builtins.int]]
        """
        The percentage of the rekey window (determined by ``RekeyMarginTimeSeconds``) during which the rekey time is randomly selected.
         Constraints: A value between 0 and 100.
         Default: ``100``
        """
        rekey_margin_time_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The margin time, in seconds, before the phase 2 lifetime expires, during which the AWS side of the VPN connection performs an IKE rekey. The exact time of the rekey is randomly selected based on the value for ``RekeyFuzzPercentage``.
         Constraints: A value between 60 and half of ``Phase2LifetimeSeconds``.
         Default: ``270``
        """
        replay_window_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of packets in an IKE replay window.
         Constraints: A value between 64 and 2048.
         Default: ``1024``
        """
        startup_action: NotRequired[pulumi.Input['VpnConnectionVpnTunnelOptionsSpecificationStartupAction']]
        """
        The action to take when the establishing the tunnel for the VPN connection. By default, your customer gateway device must initiate the IKE negotiation and bring up the tunnel. Specify ``start`` for AWS to initiate the IKE negotiation.
         Valid Values: ``add`` | ``start``
         Default: ``add``
        """
        tunnel_inside_cidr: NotRequired[pulumi.Input[_builtins.str]]
        """
        The range of inside IP addresses for the tunnel. Any specified CIDR blocks must be unique across all VPN connections that use the same virtual private gateway. 
         Constraints: A size /30 CIDR block from the ``169.254.0.0/16`` range. The following CIDR blocks are reserved and cannot be used:
          +   ``169.254.0.0/30`` 
          +   ``169.254.1.0/30`` 
          +   ``169.254.2.0/30`` 
          +   ``169.254.3.0/30`` 
          +   ``169.254.4.0/30`` 
          +   ``169.254.5.0/30`` 
          +   ``169.254.169.252/30``
        """
        tunnel_inside_ipv6_cidr: NotRequired[pulumi.Input[_builtins.str]]
        """
        The range of inside IPv6 addresses for the tunnel. Any specified CIDR blocks must be unique across all VPN connections that use the same transit gateway.
         Constraints: A size /126 CIDR block from the local ``fd00::/8`` range.
        """
elif False:
    VpnConnectionVpnTunnelOptionsSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpnConnectionVpnTunnelOptionsSpecificationArgs:
    def __init__(__self__, *,
                 dpd_timeout_action: Optional[pulumi.Input['VpnConnectionVpnTunnelOptionsSpecificationDpdTimeoutAction']] = None,
                 dpd_timeout_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 enable_tunnel_lifecycle_control: Optional[pulumi.Input[_builtins.bool]] = None,
                 ike_versions: Optional[pulumi.Input[Sequence[pulumi.Input['VpnConnectionIkeVersionsRequestListValueArgs']]]] = None,
                 log_options: Optional[pulumi.Input['VpnConnectionVpnTunnelLogOptionsSpecificationArgs']] = None,
                 phase1_encryption_algorithms: Optional[pulumi.Input[Sequence[pulumi.Input['VpnConnectionPhase1EncryptionAlgorithmsRequestListValueArgs']]]] = None,
                 phase1_integrity_algorithms: Optional[pulumi.Input[Sequence[pulumi.Input['VpnConnectionPhase1IntegrityAlgorithmsRequestListValueArgs']]]] = None,
                 phase1_lifetime_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 phase1dh_group_numbers: Optional[pulumi.Input[Sequence[pulumi.Input['VpnConnectionPhase1dhGroupNumbersRequestListValueArgs']]]] = None,
                 phase2_encryption_algorithms: Optional[pulumi.Input[Sequence[pulumi.Input['VpnConnectionPhase2EncryptionAlgorithmsRequestListValueArgs']]]] = None,
                 phase2_integrity_algorithms: Optional[pulumi.Input[Sequence[pulumi.Input['VpnConnectionPhase2IntegrityAlgorithmsRequestListValueArgs']]]] = None,
                 phase2_lifetime_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 phase2dh_group_numbers: Optional[pulumi.Input[Sequence[pulumi.Input['VpnConnectionPhase2dhGroupNumbersRequestListValueArgs']]]] = None,
                 pre_shared_key: Optional[pulumi.Input[_builtins.str]] = None,
                 rekey_fuzz_percentage: Optional[pulumi.Input[_builtins.int]] = None,
                 rekey_margin_time_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 replay_window_size: Optional[pulumi.Input[_builtins.int]] = None,
                 startup_action: Optional[pulumi.Input['VpnConnectionVpnTunnelOptionsSpecificationStartupAction']] = None,
                 tunnel_inside_cidr: Optional[pulumi.Input[_builtins.str]] = None,
                 tunnel_inside_ipv6_cidr: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The tunnel options for a single VPN tunnel.
        :param pulumi.Input['VpnConnectionVpnTunnelOptionsSpecificationDpdTimeoutAction'] dpd_timeout_action: The action to take after DPD timeout occurs. Specify ``restart`` to restart the IKE initiation. Specify ``clear`` to end the IKE session.
                Valid Values: ``clear`` | ``none`` | ``restart``
                Default: ``clear``
        :param pulumi.Input[_builtins.int] dpd_timeout_seconds: The number of seconds after which a DPD timeout occurs.
                Constraints: A value greater than or equal to 30.
                Default: ``30``
        :param pulumi.Input[_builtins.bool] enable_tunnel_lifecycle_control: Turn on or off tunnel endpoint lifecycle control feature.
        :param pulumi.Input[Sequence[pulumi.Input['VpnConnectionIkeVersionsRequestListValueArgs']]] ike_versions: The IKE versions that are permitted for the VPN tunnel.
                Valid values: ``ikev1`` | ``ikev2``
        :param pulumi.Input['VpnConnectionVpnTunnelLogOptionsSpecificationArgs'] log_options: Options for logging VPN tunnel activity.
        :param pulumi.Input[Sequence[pulumi.Input['VpnConnectionPhase1EncryptionAlgorithmsRequestListValueArgs']]] phase1_encryption_algorithms: One or more encryption algorithms that are permitted for the VPN tunnel for phase 1 IKE negotiations.
                Valid values: ``AES128`` | ``AES256`` | ``AES128-GCM-16`` | ``AES256-GCM-16``
        :param pulumi.Input[Sequence[pulumi.Input['VpnConnectionPhase1IntegrityAlgorithmsRequestListValueArgs']]] phase1_integrity_algorithms: One or more integrity algorithms that are permitted for the VPN tunnel for phase 1 IKE negotiations.
                Valid values: ``SHA1`` | ``SHA2-256`` | ``SHA2-384`` | ``SHA2-512``
        :param pulumi.Input[_builtins.int] phase1_lifetime_seconds: The lifetime for phase 1 of the IKE negotiation, in seconds.
                Constraints: A value between 900 and 28,800.
                Default: ``28800``
        :param pulumi.Input[Sequence[pulumi.Input['VpnConnectionPhase1dhGroupNumbersRequestListValueArgs']]] phase1dh_group_numbers: One or more Diffie-Hellman group numbers that are permitted for the VPN tunnel for phase 1 IKE negotiations.
                Valid values: ``2`` | ``14`` | ``15`` | ``16`` | ``17`` | ``18`` | ``19`` | ``20`` | ``21`` | ``22`` | ``23`` | ``24``
        :param pulumi.Input[Sequence[pulumi.Input['VpnConnectionPhase2EncryptionAlgorithmsRequestListValueArgs']]] phase2_encryption_algorithms: One or more encryption algorithms that are permitted for the VPN tunnel for phase 2 IKE negotiations.
                Valid values: ``AES128`` | ``AES256`` | ``AES128-GCM-16`` | ``AES256-GCM-16``
        :param pulumi.Input[Sequence[pulumi.Input['VpnConnectionPhase2IntegrityAlgorithmsRequestListValueArgs']]] phase2_integrity_algorithms: One or more integrity algorithms that are permitted for the VPN tunnel for phase 2 IKE negotiations.
                Valid values: ``SHA1`` | ``SHA2-256`` | ``SHA2-384`` | ``SHA2-512``
        :param pulumi.Input[_builtins.int] phase2_lifetime_seconds: The lifetime for phase 2 of the IKE negotiation, in seconds.
                Constraints: A value between 900 and 3,600. The value must be less than the value for ``Phase1LifetimeSeconds``.
                Default: ``3600``
        :param pulumi.Input[Sequence[pulumi.Input['VpnConnectionPhase2dhGroupNumbersRequestListValueArgs']]] phase2dh_group_numbers: One or more Diffie-Hellman group numbers that are permitted for the VPN tunnel for phase 2 IKE negotiations.
                Valid values: ``2`` | ``5`` | ``14`` | ``15`` | ``16`` | ``17`` | ``18`` | ``19`` | ``20`` | ``21`` | ``22`` | ``23`` | ``24``
        :param pulumi.Input[_builtins.str] pre_shared_key: The pre-shared key (PSK) to establish initial authentication between the virtual private gateway and customer gateway.
                Constraints: Allowed characters are alphanumeric characters, periods (.), and underscores (_). Must be between 8 and 64 characters in length and cannot start with zero (0).
        :param pulumi.Input[_builtins.int] rekey_fuzz_percentage: The percentage of the rekey window (determined by ``RekeyMarginTimeSeconds``) during which the rekey time is randomly selected.
                Constraints: A value between 0 and 100.
                Default: ``100``
        :param pulumi.Input[_builtins.int] rekey_margin_time_seconds: The margin time, in seconds, before the phase 2 lifetime expires, during which the AWS side of the VPN connection performs an IKE rekey. The exact time of the rekey is randomly selected based on the value for ``RekeyFuzzPercentage``.
                Constraints: A value between 60 and half of ``Phase2LifetimeSeconds``.
                Default: ``270``
        :param pulumi.Input[_builtins.int] replay_window_size: The number of packets in an IKE replay window.
                Constraints: A value between 64 and 2048.
                Default: ``1024``
        :param pulumi.Input['VpnConnectionVpnTunnelOptionsSpecificationStartupAction'] startup_action: The action to take when the establishing the tunnel for the VPN connection. By default, your customer gateway device must initiate the IKE negotiation and bring up the tunnel. Specify ``start`` for AWS to initiate the IKE negotiation.
                Valid Values: ``add`` | ``start``
                Default: ``add``
        :param pulumi.Input[_builtins.str] tunnel_inside_cidr: The range of inside IP addresses for the tunnel. Any specified CIDR blocks must be unique across all VPN connections that use the same virtual private gateway. 
                Constraints: A size /30 CIDR block from the ``169.254.0.0/16`` range. The following CIDR blocks are reserved and cannot be used:
                 +   ``169.254.0.0/30`` 
                 +   ``169.254.1.0/30`` 
                 +   ``169.254.2.0/30`` 
                 +   ``169.254.3.0/30`` 
                 +   ``169.254.4.0/30`` 
                 +   ``169.254.5.0/30`` 
                 +   ``169.254.169.252/30``
        :param pulumi.Input[_builtins.str] tunnel_inside_ipv6_cidr: The range of inside IPv6 addresses for the tunnel. Any specified CIDR blocks must be unique across all VPN connections that use the same transit gateway.
                Constraints: A size /126 CIDR block from the local ``fd00::/8`` range.
        """
        if dpd_timeout_action is not None:
            pulumi.set(__self__, "dpd_timeout_action", dpd_timeout_action)
        if dpd_timeout_seconds is not None:
            pulumi.set(__self__, "dpd_timeout_seconds", dpd_timeout_seconds)
        if enable_tunnel_lifecycle_control is not None:
            pulumi.set(__self__, "enable_tunnel_lifecycle_control", enable_tunnel_lifecycle_control)
        if ike_versions is not None:
            pulumi.set(__self__, "ike_versions", ike_versions)
        if log_options is not None:
            pulumi.set(__self__, "log_options", log_options)
        if phase1_encryption_algorithms is not None:
            pulumi.set(__self__, "phase1_encryption_algorithms", phase1_encryption_algorithms)
        if phase1_integrity_algorithms is not None:
            pulumi.set(__self__, "phase1_integrity_algorithms", phase1_integrity_algorithms)
        if phase1_lifetime_seconds is not None:
            pulumi.set(__self__, "phase1_lifetime_seconds", phase1_lifetime_seconds)
        if phase1dh_group_numbers is not None:
            pulumi.set(__self__, "phase1dh_group_numbers", phase1dh_group_numbers)
        if phase2_encryption_algorithms is not None:
            pulumi.set(__self__, "phase2_encryption_algorithms", phase2_encryption_algorithms)
        if phase2_integrity_algorithms is not None:
            pulumi.set(__self__, "phase2_integrity_algorithms", phase2_integrity_algorithms)
        if phase2_lifetime_seconds is not None:
            pulumi.set(__self__, "phase2_lifetime_seconds", phase2_lifetime_seconds)
        if phase2dh_group_numbers is not None:
            pulumi.set(__self__, "phase2dh_group_numbers", phase2dh_group_numbers)
        if pre_shared_key is not None:
            pulumi.set(__self__, "pre_shared_key", pre_shared_key)
        if rekey_fuzz_percentage is not None:
            pulumi.set(__self__, "rekey_fuzz_percentage", rekey_fuzz_percentage)
        if rekey_margin_time_seconds is not None:
            pulumi.set(__self__, "rekey_margin_time_seconds", rekey_margin_time_seconds)
        if replay_window_size is not None:
            pulumi.set(__self__, "replay_window_size", replay_window_size)
        if startup_action is not None:
            pulumi.set(__self__, "startup_action", startup_action)
        if tunnel_inside_cidr is not None:
            pulumi.set(__self__, "tunnel_inside_cidr", tunnel_inside_cidr)
        if tunnel_inside_ipv6_cidr is not None:
            pulumi.set(__self__, "tunnel_inside_ipv6_cidr", tunnel_inside_ipv6_cidr)

    @_builtins.property
    @pulumi.getter(name="dpdTimeoutAction")
    def dpd_timeout_action(self) -> Optional[pulumi.Input['VpnConnectionVpnTunnelOptionsSpecificationDpdTimeoutAction']]:
        """
        The action to take after DPD timeout occurs. Specify ``restart`` to restart the IKE initiation. Specify ``clear`` to end the IKE session.
         Valid Values: ``clear`` | ``none`` | ``restart``
         Default: ``clear``
        """
        return pulumi.get(self, "dpd_timeout_action")

    @dpd_timeout_action.setter
    def dpd_timeout_action(self, value: Optional[pulumi.Input['VpnConnectionVpnTunnelOptionsSpecificationDpdTimeoutAction']]):
        pulumi.set(self, "dpd_timeout_action", value)

    @_builtins.property
    @pulumi.getter(name="dpdTimeoutSeconds")
    def dpd_timeout_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of seconds after which a DPD timeout occurs.
         Constraints: A value greater than or equal to 30.
         Default: ``30``
        """
        return pulumi.get(self, "dpd_timeout_seconds")

    @dpd_timeout_seconds.setter
    def dpd_timeout_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "dpd_timeout_seconds", value)

    @_builtins.property
    @pulumi.getter(name="enableTunnelLifecycleControl")
    def enable_tunnel_lifecycle_control(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Turn on or off tunnel endpoint lifecycle control feature.
        """
        return pulumi.get(self, "enable_tunnel_lifecycle_control")

    @enable_tunnel_lifecycle_control.setter
    def enable_tunnel_lifecycle_control(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_tunnel_lifecycle_control", value)

    @_builtins.property
    @pulumi.getter(name="ikeVersions")
    def ike_versions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VpnConnectionIkeVersionsRequestListValueArgs']]]]:
        """
        The IKE versions that are permitted for the VPN tunnel.
         Valid values: ``ikev1`` | ``ikev2``
        """
        return pulumi.get(self, "ike_versions")

    @ike_versions.setter
    def ike_versions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VpnConnectionIkeVersionsRequestListValueArgs']]]]):
        pulumi.set(self, "ike_versions", value)

    @_builtins.property
    @pulumi.getter(name="logOptions")
    def log_options(self) -> Optional[pulumi.Input['VpnConnectionVpnTunnelLogOptionsSpecificationArgs']]:
        """
        Options for logging VPN tunnel activity.
        """
        return pulumi.get(self, "log_options")

    @log_options.setter
    def log_options(self, value: Optional[pulumi.Input['VpnConnectionVpnTunnelLogOptionsSpecificationArgs']]):
        pulumi.set(self, "log_options", value)

    @_builtins.property
    @pulumi.getter(name="phase1EncryptionAlgorithms")
    def phase1_encryption_algorithms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VpnConnectionPhase1EncryptionAlgorithmsRequestListValueArgs']]]]:
        """
        One or more encryption algorithms that are permitted for the VPN tunnel for phase 1 IKE negotiations.
         Valid values: ``AES128`` | ``AES256`` | ``AES128-GCM-16`` | ``AES256-GCM-16``
        """
        return pulumi.get(self, "phase1_encryption_algorithms")

    @phase1_encryption_algorithms.setter
    def phase1_encryption_algorithms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VpnConnectionPhase1EncryptionAlgorithmsRequestListValueArgs']]]]):
        pulumi.set(self, "phase1_encryption_algorithms", value)

    @_builtins.property
    @pulumi.getter(name="phase1IntegrityAlgorithms")
    def phase1_integrity_algorithms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VpnConnectionPhase1IntegrityAlgorithmsRequestListValueArgs']]]]:
        """
        One or more integrity algorithms that are permitted for the VPN tunnel for phase 1 IKE negotiations.
         Valid values: ``SHA1`` | ``SHA2-256`` | ``SHA2-384`` | ``SHA2-512``
        """
        return pulumi.get(self, "phase1_integrity_algorithms")

    @phase1_integrity_algorithms.setter
    def phase1_integrity_algorithms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VpnConnectionPhase1IntegrityAlgorithmsRequestListValueArgs']]]]):
        pulumi.set(self, "phase1_integrity_algorithms", value)

    @_builtins.property
    @pulumi.getter(name="phase1LifetimeSeconds")
    def phase1_lifetime_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The lifetime for phase 1 of the IKE negotiation, in seconds.
         Constraints: A value between 900 and 28,800.
         Default: ``28800``
        """
        return pulumi.get(self, "phase1_lifetime_seconds")

    @phase1_lifetime_seconds.setter
    def phase1_lifetime_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "phase1_lifetime_seconds", value)

    @_builtins.property
    @pulumi.getter(name="phase1dhGroupNumbers")
    def phase1dh_group_numbers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VpnConnectionPhase1dhGroupNumbersRequestListValueArgs']]]]:
        """
        One or more Diffie-Hellman group numbers that are permitted for the VPN tunnel for phase 1 IKE negotiations.
         Valid values: ``2`` | ``14`` | ``15`` | ``16`` | ``17`` | ``18`` | ``19`` | ``20`` | ``21`` | ``22`` | ``23`` | ``24``
        """
        return pulumi.get(self, "phase1dh_group_numbers")

    @phase1dh_group_numbers.setter
    def phase1dh_group_numbers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VpnConnectionPhase1dhGroupNumbersRequestListValueArgs']]]]):
        pulumi.set(self, "phase1dh_group_numbers", value)

    @_builtins.property
    @pulumi.getter(name="phase2EncryptionAlgorithms")
    def phase2_encryption_algorithms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VpnConnectionPhase2EncryptionAlgorithmsRequestListValueArgs']]]]:
        """
        One or more encryption algorithms that are permitted for the VPN tunnel for phase 2 IKE negotiations.
         Valid values: ``AES128`` | ``AES256`` | ``AES128-GCM-16`` | ``AES256-GCM-16``
        """
        return pulumi.get(self, "phase2_encryption_algorithms")

    @phase2_encryption_algorithms.setter
    def phase2_encryption_algorithms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VpnConnectionPhase2EncryptionAlgorithmsRequestListValueArgs']]]]):
        pulumi.set(self, "phase2_encryption_algorithms", value)

    @_builtins.property
    @pulumi.getter(name="phase2IntegrityAlgorithms")
    def phase2_integrity_algorithms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VpnConnectionPhase2IntegrityAlgorithmsRequestListValueArgs']]]]:
        """
        One or more integrity algorithms that are permitted for the VPN tunnel for phase 2 IKE negotiations.
         Valid values: ``SHA1`` | ``SHA2-256`` | ``SHA2-384`` | ``SHA2-512``
        """
        return pulumi.get(self, "phase2_integrity_algorithms")

    @phase2_integrity_algorithms.setter
    def phase2_integrity_algorithms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VpnConnectionPhase2IntegrityAlgorithmsRequestListValueArgs']]]]):
        pulumi.set(self, "phase2_integrity_algorithms", value)

    @_builtins.property
    @pulumi.getter(name="phase2LifetimeSeconds")
    def phase2_lifetime_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The lifetime for phase 2 of the IKE negotiation, in seconds.
         Constraints: A value between 900 and 3,600. The value must be less than the value for ``Phase1LifetimeSeconds``.
         Default: ``3600``
        """
        return pulumi.get(self, "phase2_lifetime_seconds")

    @phase2_lifetime_seconds.setter
    def phase2_lifetime_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "phase2_lifetime_seconds", value)

    @_builtins.property
    @pulumi.getter(name="phase2dhGroupNumbers")
    def phase2dh_group_numbers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VpnConnectionPhase2dhGroupNumbersRequestListValueArgs']]]]:
        """
        One or more Diffie-Hellman group numbers that are permitted for the VPN tunnel for phase 2 IKE negotiations.
         Valid values: ``2`` | ``5`` | ``14`` | ``15`` | ``16`` | ``17`` | ``18`` | ``19`` | ``20`` | ``21`` | ``22`` | ``23`` | ``24``
        """
        return pulumi.get(self, "phase2dh_group_numbers")

    @phase2dh_group_numbers.setter
    def phase2dh_group_numbers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VpnConnectionPhase2dhGroupNumbersRequestListValueArgs']]]]):
        pulumi.set(self, "phase2dh_group_numbers", value)

    @_builtins.property
    @pulumi.getter(name="preSharedKey")
    def pre_shared_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The pre-shared key (PSK) to establish initial authentication between the virtual private gateway and customer gateway.
         Constraints: Allowed characters are alphanumeric characters, periods (.), and underscores (_). Must be between 8 and 64 characters in length and cannot start with zero (0).
        """
        return pulumi.get(self, "pre_shared_key")

    @pre_shared_key.setter
    def pre_shared_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pre_shared_key", value)

    @_builtins.property
    @pulumi.getter(name="rekeyFuzzPercentage")
    def rekey_fuzz_percentage(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The percentage of the rekey window (determined by ``RekeyMarginTimeSeconds``) during which the rekey time is randomly selected.
         Constraints: A value between 0 and 100.
         Default: ``100``
        """
        return pulumi.get(self, "rekey_fuzz_percentage")

    @rekey_fuzz_percentage.setter
    def rekey_fuzz_percentage(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "rekey_fuzz_percentage", value)

    @_builtins.property
    @pulumi.getter(name="rekeyMarginTimeSeconds")
    def rekey_margin_time_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The margin time, in seconds, before the phase 2 lifetime expires, during which the AWS side of the VPN connection performs an IKE rekey. The exact time of the rekey is randomly selected based on the value for ``RekeyFuzzPercentage``.
         Constraints: A value between 60 and half of ``Phase2LifetimeSeconds``.
         Default: ``270``
        """
        return pulumi.get(self, "rekey_margin_time_seconds")

    @rekey_margin_time_seconds.setter
    def rekey_margin_time_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "rekey_margin_time_seconds", value)

    @_builtins.property
    @pulumi.getter(name="replayWindowSize")
    def replay_window_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of packets in an IKE replay window.
         Constraints: A value between 64 and 2048.
         Default: ``1024``
        """
        return pulumi.get(self, "replay_window_size")

    @replay_window_size.setter
    def replay_window_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "replay_window_size", value)

    @_builtins.property
    @pulumi.getter(name="startupAction")
    def startup_action(self) -> Optional[pulumi.Input['VpnConnectionVpnTunnelOptionsSpecificationStartupAction']]:
        """
        The action to take when the establishing the tunnel for the VPN connection. By default, your customer gateway device must initiate the IKE negotiation and bring up the tunnel. Specify ``start`` for AWS to initiate the IKE negotiation.
         Valid Values: ``add`` | ``start``
         Default: ``add``
        """
        return pulumi.get(self, "startup_action")

    @startup_action.setter
    def startup_action(self, value: Optional[pulumi.Input['VpnConnectionVpnTunnelOptionsSpecificationStartupAction']]):
        pulumi.set(self, "startup_action", value)

    @_builtins.property
    @pulumi.getter(name="tunnelInsideCidr")
    def tunnel_inside_cidr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The range of inside IP addresses for the tunnel. Any specified CIDR blocks must be unique across all VPN connections that use the same virtual private gateway. 
         Constraints: A size /30 CIDR block from the ``169.254.0.0/16`` range. The following CIDR blocks are reserved and cannot be used:
          +   ``169.254.0.0/30`` 
          +   ``169.254.1.0/30`` 
          +   ``169.254.2.0/30`` 
          +   ``169.254.3.0/30`` 
          +   ``169.254.4.0/30`` 
          +   ``169.254.5.0/30`` 
          +   ``169.254.169.252/30``
        """
        return pulumi.get(self, "tunnel_inside_cidr")

    @tunnel_inside_cidr.setter
    def tunnel_inside_cidr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tunnel_inside_cidr", value)

    @_builtins.property
    @pulumi.getter(name="tunnelInsideIpv6Cidr")
    def tunnel_inside_ipv6_cidr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The range of inside IPv6 addresses for the tunnel. Any specified CIDR blocks must be unique across all VPN connections that use the same transit gateway.
         Constraints: A size /126 CIDR block from the local ``fd00::/8`` range.
        """
        return pulumi.get(self, "tunnel_inside_ipv6_cidr")

    @tunnel_inside_ipv6_cidr.setter
    def tunnel_inside_ipv6_cidr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tunnel_inside_ipv6_cidr", value)


