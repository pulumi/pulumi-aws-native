# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'CapacityReservationFleetInstanceTypeSpecification',
    'CapacityReservationFleetTag',
    'CapacityReservationFleetTagSpecification',
    'CapacityReservationTag',
    'CapacityReservationTagSpecification',
    'CpuOptionsProperties',
    'CreditSpecificationProperties',
    'DestinationOptionsProperties',
    'Ec2FleetAcceleratorCountRequest',
    'Ec2FleetAcceleratorTotalMemoryMiBRequest',
    'Ec2FleetBaselineEbsBandwidthMbpsRequest',
    'Ec2FleetCapacityRebalance',
    'Ec2FleetCapacityReservationOptionsRequest',
    'Ec2FleetFleetLaunchTemplateConfigRequest',
    'Ec2FleetFleetLaunchTemplateOverridesRequest',
    'Ec2FleetFleetLaunchTemplateSpecificationRequest',
    'Ec2FleetInstanceRequirementsRequest',
    'Ec2FleetMaintenanceStrategies',
    'Ec2FleetMemoryGiBPerVCpuRequest',
    'Ec2FleetMemoryMiBRequest',
    'Ec2FleetNetworkBandwidthGbpsRequest',
    'Ec2FleetNetworkInterfaceCountRequest',
    'Ec2FleetOnDemandOptionsRequest',
    'Ec2FleetPlacement',
    'Ec2FleetSpotOptionsRequest',
    'Ec2FleetTag',
    'Ec2FleetTagSpecification',
    'Ec2FleetTargetCapacitySpecificationRequest',
    'Ec2FleetTotalLocalStorageGbRequest',
    'Ec2FleetVCpuCountRangeRequest',
    'EnclaveOptionsProperties',
    'HibernationOptionsProperties',
    'InstanceAssociationParameter',
    'InstanceBlockDeviceMapping',
    'InstanceEbs',
    'InstanceElasticGpuSpecification',
    'InstanceElasticInferenceAccelerator',
    'InstanceIpv6Address',
    'InstanceLaunchTemplateSpecification',
    'InstanceLicenseSpecification',
    'InstanceNetworkInterface',
    'InstancePrivateDnsNameOptions',
    'InstancePrivateIpAddressSpecification',
    'InstanceSsmAssociation',
    'InstanceState',
    'InstanceVolume',
    'IpamOperatingRegion',
    'IpamPoolProvisionedCidr',
    'IpamPoolSourceResource',
    'IpamPoolTag',
    'IpamResourceDiscoveryIpamOperatingRegion',
    'LaunchTemplateAcceleratorCount',
    'LaunchTemplateAcceleratorTotalMemoryMiB',
    'LaunchTemplateBaselineEbsBandwidthMbps',
    'LaunchTemplateBlockDeviceMapping',
    'LaunchTemplateCapacityReservationSpecification',
    'LaunchTemplateCapacityReservationTarget',
    'LaunchTemplateConnectionTrackingSpecification',
    'LaunchTemplateCpuOptions',
    'LaunchTemplateCreditSpecification',
    'LaunchTemplateData',
    'LaunchTemplateEbs',
    'LaunchTemplateElasticGpuSpecification',
    'LaunchTemplateElasticInferenceAccelerator',
    'LaunchTemplateEnaSrdSpecification',
    'LaunchTemplateEnaSrdUdpSpecification',
    'LaunchTemplateEnclaveOptions',
    'LaunchTemplateHibernationOptions',
    'LaunchTemplateIamInstanceProfile',
    'LaunchTemplateInstanceMarketOptions',
    'LaunchTemplateInstanceRequirements',
    'LaunchTemplateIpv4PrefixSpecification',
    'LaunchTemplateIpv6Add',
    'LaunchTemplateIpv6PrefixSpecification',
    'LaunchTemplateLicenseSpecification',
    'LaunchTemplateMaintenanceOptions',
    'LaunchTemplateMemoryGiBPerVCpu',
    'LaunchTemplateMemoryMiB',
    'LaunchTemplateMetadataOptions',
    'LaunchTemplateMonitoring',
    'LaunchTemplateNetworkBandwidthGbps',
    'LaunchTemplateNetworkInterface',
    'LaunchTemplateNetworkInterfaceCount',
    'LaunchTemplatePlacement',
    'LaunchTemplatePrivateDnsNameOptions',
    'LaunchTemplatePrivateIpAdd',
    'LaunchTemplateSpotOptions',
    'LaunchTemplateTag',
    'LaunchTemplateTagSpecification',
    'LaunchTemplateTotalLocalStorageGb',
    'LaunchTemplateVCpuCount',
    'NetworkInsightsAccessScopeAccessScopePathRequest',
    'NetworkInsightsAccessScopePacketHeaderStatementRequest',
    'NetworkInsightsAccessScopePathStatementRequest',
    'NetworkInsightsAccessScopeResourceStatementRequest',
    'NetworkInsightsAccessScopeThroughResourcesStatementRequest',
    'NetworkInsightsAnalysisAdditionalDetail',
    'NetworkInsightsAnalysisAlternatePathHint',
    'NetworkInsightsAnalysisAnalysisAclRule',
    'NetworkInsightsAnalysisAnalysisComponent',
    'NetworkInsightsAnalysisAnalysisLoadBalancerListener',
    'NetworkInsightsAnalysisAnalysisLoadBalancerTarget',
    'NetworkInsightsAnalysisAnalysisPacketHeader',
    'NetworkInsightsAnalysisAnalysisRouteTableRoute',
    'NetworkInsightsAnalysisAnalysisSecurityGroupRule',
    'NetworkInsightsAnalysisExplanation',
    'NetworkInsightsAnalysisPathComponent',
    'NetworkInsightsAnalysisPortRange',
    'NetworkInsightsAnalysisTransitGatewayRouteTableRoute',
    'NetworkInsightsPathFilterPortRange',
    'NetworkInsightsPathPathFilter',
    'NetworkInterfaceAttachmentEnaSrdSpecification',
    'NetworkInterfaceAttachmentEnaSrdSpecificationEnaSrdUdpSpecificationProperties',
    'NetworkInterfaceConnectionTrackingSpecification',
    'NetworkInterfaceInstanceIpv6Address',
    'NetworkInterfaceIpv4PrefixSpecification',
    'NetworkInterfaceIpv6PrefixSpecification',
    'NetworkInterfacePrivateIpAddressSpecification',
    'OptionsProperties',
    'PrefixListEntry',
    'PrivateDnsNameOptionsOnLaunchProperties',
    'SecurityGroupEgress',
    'SecurityGroupIngress',
    'SpotFleetAcceleratorCountRequest',
    'SpotFleetAcceleratorTotalMemoryMiBRequest',
    'SpotFleetBaselineEbsBandwidthMbpsRequest',
    'SpotFleetBlockDeviceMapping',
    'SpotFleetClassicLoadBalancer',
    'SpotFleetClassicLoadBalancersConfig',
    'SpotFleetEbsBlockDevice',
    'SpotFleetFleetLaunchTemplateSpecification',
    'SpotFleetGroupIdentifier',
    'SpotFleetIamInstanceProfileSpecification',
    'SpotFleetInstanceIpv6Address',
    'SpotFleetInstanceNetworkInterfaceSpecification',
    'SpotFleetInstanceRequirementsRequest',
    'SpotFleetLaunchSpecification',
    'SpotFleetLaunchTemplateConfig',
    'SpotFleetLaunchTemplateOverrides',
    'SpotFleetLoadBalancersConfig',
    'SpotFleetMemoryGiBPerVCpuRequest',
    'SpotFleetMemoryMiBRequest',
    'SpotFleetMonitoring',
    'SpotFleetNetworkBandwidthGbpsRequest',
    'SpotFleetNetworkInterfaceCountRequest',
    'SpotFleetPrivateIpAddressSpecification',
    'SpotFleetRequestConfigData',
    'SpotFleetSpotCapacityRebalance',
    'SpotFleetSpotMaintenanceStrategies',
    'SpotFleetSpotPlacement',
    'SpotFleetTag',
    'SpotFleetTagSpecification',
    'SpotFleetTargetGroup',
    'SpotFleetTargetGroupsConfig',
    'SpotFleetTotalLocalStorageGbRequest',
    'SpotFleetVCpuCountRangeRequest',
    'SseSpecificationProperties',
    'TagSpecification',
    'TransitGatewayConnectOptions',
    'TransitGatewayPeeringAttachmentPeeringAttachmentStatus',
    'VerifiedAccessEndpointLoadBalancerOptions',
    'VerifiedAccessEndpointNetworkInterfaceOptions',
    'VerifiedAccessEndpointSseSpecification',
    'VerifiedAccessGroupSseSpecification',
    'VerifiedAccessInstanceVerifiedAccessLogs',
    'VerifiedAccessInstanceVerifiedAccessLogsCloudWatchLogsProperties',
    'VerifiedAccessInstanceVerifiedAccessLogsKinesisDataFirehoseProperties',
    'VerifiedAccessInstanceVerifiedAccessLogsS3Properties',
    'VerifiedAccessInstanceVerifiedAccessTrustProvider',
    'VerifiedAccessTrustProviderDeviceOptions',
    'VerifiedAccessTrustProviderOidcOptions',
    'VpnConnectionVpnTunnelOptionsSpecification',
]

@pulumi.output_type
class CapacityReservationFleetInstanceTypeSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "availabilityZoneId":
            suggest = "availability_zone_id"
        elif key == "ebsOptimized":
            suggest = "ebs_optimized"
        elif key == "instancePlatform":
            suggest = "instance_platform"
        elif key == "instanceType":
            suggest = "instance_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CapacityReservationFleetInstanceTypeSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CapacityReservationFleetInstanceTypeSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CapacityReservationFleetInstanceTypeSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone: Optional[str] = None,
                 availability_zone_id: Optional[str] = None,
                 ebs_optimized: Optional[bool] = None,
                 instance_platform: Optional[str] = None,
                 instance_type: Optional[str] = None,
                 priority: Optional[int] = None,
                 weight: Optional[float] = None):
        """
        :param str availability_zone: The Availability Zone in which the Capacity Reservation Fleet reserves the capacity. A Capacity Reservation Fleet can't span Availability Zones. All instance type specifications that you specify for the Fleet must use the same Availability Zone.
        :param str availability_zone_id: The ID of the Availability Zone in which the Capacity Reservation Fleet reserves the capacity. A Capacity Reservation Fleet can't span Availability Zones. All instance type specifications that you specify for the Fleet must use the same Availability Zone.
        :param bool ebs_optimized: Indicates whether the Capacity Reservation Fleet supports EBS-optimized instances types. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using EBS-optimized instance types.
        :param str instance_platform: The type of operating system for which the Capacity Reservation Fleet reserves capacity.
        :param str instance_type: The instance type for which the Capacity Reservation Fleet reserves capacity.
        :param int priority: The priority to assign to the instance type. This value is used to determine which of the instance types specified for the Fleet should be prioritized for use. A lower value indicates a high priority. For more information, see [Instance type priority](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#instance-priority) in the *Amazon EC2 User Guide* .
        :param float weight: The number of capacity units provided by the specified instance type. This value, together with the total target capacity that you specify for the Fleet determine the number of instances for which the Fleet reserves capacity. Both values are based on units that make sense for your workload. For more information, see [Total target capacity](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#target-capacity) in the Amazon EC2 User Guide.
               
               Valid Range: Minimum value of `0.001` . Maximum value of `99.999` .
        """
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if availability_zone_id is not None:
            pulumi.set(__self__, "availability_zone_id", availability_zone_id)
        if ebs_optimized is not None:
            pulumi.set(__self__, "ebs_optimized", ebs_optimized)
        if instance_platform is not None:
            pulumi.set(__self__, "instance_platform", instance_platform)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[str]:
        """
        The Availability Zone in which the Capacity Reservation Fleet reserves the capacity. A Capacity Reservation Fleet can't span Availability Zones. All instance type specifications that you specify for the Fleet must use the same Availability Zone.
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="availabilityZoneId")
    def availability_zone_id(self) -> Optional[str]:
        """
        The ID of the Availability Zone in which the Capacity Reservation Fleet reserves the capacity. A Capacity Reservation Fleet can't span Availability Zones. All instance type specifications that you specify for the Fleet must use the same Availability Zone.
        """
        return pulumi.get(self, "availability_zone_id")

    @property
    @pulumi.getter(name="ebsOptimized")
    def ebs_optimized(self) -> Optional[bool]:
        """
        Indicates whether the Capacity Reservation Fleet supports EBS-optimized instances types. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using EBS-optimized instance types.
        """
        return pulumi.get(self, "ebs_optimized")

    @property
    @pulumi.getter(name="instancePlatform")
    def instance_platform(self) -> Optional[str]:
        """
        The type of operating system for which the Capacity Reservation Fleet reserves capacity.
        """
        return pulumi.get(self, "instance_platform")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[str]:
        """
        The instance type for which the Capacity Reservation Fleet reserves capacity.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        The priority to assign to the instance type. This value is used to determine which of the instance types specified for the Fleet should be prioritized for use. A lower value indicates a high priority. For more information, see [Instance type priority](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#instance-priority) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def weight(self) -> Optional[float]:
        """
        The number of capacity units provided by the specified instance type. This value, together with the total target capacity that you specify for the Fleet determine the number of instances for which the Fleet reserves capacity. Both values are based on units that make sense for your workload. For more information, see [Total target capacity](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#target-capacity) in the Amazon EC2 User Guide.

        Valid Range: Minimum value of `0.001` . Maximum value of `99.999` .
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class CapacityReservationFleetTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The tag key.
        :param str value: The tag value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The tag value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CapacityReservationFleetTagSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CapacityReservationFleetTagSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CapacityReservationFleetTagSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CapacityReservationFleetTagSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_type: Optional[str] = None,
                 tags: Optional[Sequence['outputs.CapacityReservationFleetTag']] = None):
        """
        :param str resource_type: The type of resource to tag on creation. Specify `capacity-reservation-fleet` .
               
               To tag a resource after it has been created, see [CreateTags](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html) .
        :param Sequence['CapacityReservationFleetTag'] tags: The tags to apply to the resource.
        """
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[str]:
        """
        The type of resource to tag on creation. Specify `capacity-reservation-fleet` .

        To tag a resource after it has been created, see [CreateTags](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html) .
        """
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.CapacityReservationFleetTag']]:
        """
        The tags to apply to the resource.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class CapacityReservationTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The tag key.
        :param str value: The tag value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The tag value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CapacityReservationTagSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CapacityReservationTagSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CapacityReservationTagSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CapacityReservationTagSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_type: Optional[str] = None,
                 tags: Optional[Sequence['outputs.CapacityReservationTag']] = None):
        """
        :param str resource_type: The type of resource to tag. Specify `capacity-reservation` .
        :param Sequence['CapacityReservationTag'] tags: The tags to apply to the resource.
        """
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[str]:
        """
        The type of resource to tag. Specify `capacity-reservation` .
        """
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.CapacityReservationTag']]:
        """
        The tags to apply to the resource.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class CpuOptionsProperties(dict):
    """
    The CPU options for the instance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coreCount":
            suggest = "core_count"
        elif key == "threadsPerCore":
            suggest = "threads_per_core"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CpuOptionsProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CpuOptionsProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CpuOptionsProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 core_count: Optional[int] = None,
                 threads_per_core: Optional[int] = None):
        """
        The CPU options for the instance.
        :param int core_count: The number of CPU cores for the instance.
        :param int threads_per_core: The number of threads per CPU core.
        """
        if core_count is not None:
            pulumi.set(__self__, "core_count", core_count)
        if threads_per_core is not None:
            pulumi.set(__self__, "threads_per_core", threads_per_core)

    @property
    @pulumi.getter(name="coreCount")
    def core_count(self) -> Optional[int]:
        """
        The number of CPU cores for the instance.
        """
        return pulumi.get(self, "core_count")

    @property
    @pulumi.getter(name="threadsPerCore")
    def threads_per_core(self) -> Optional[int]:
        """
        The number of threads per CPU core.
        """
        return pulumi.get(self, "threads_per_core")


@pulumi.output_type
class CreditSpecificationProperties(dict):
    """
    The credit option for CPU usage of the burstable performance instance. Valid values are standard and unlimited.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuCredits":
            suggest = "cpu_credits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CreditSpecificationProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CreditSpecificationProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CreditSpecificationProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_credits: Optional[str] = None):
        """
        The credit option for CPU usage of the burstable performance instance. Valid values are standard and unlimited.
        :param str cpu_credits: The credit option for CPU usage of the instance.
               
               Valid values: `standard` | `unlimited`
               
               T3 instances with `host` tenancy do not support the `unlimited` CPU credit option.
        """
        if cpu_credits is not None:
            pulumi.set(__self__, "cpu_credits", cpu_credits)

    @property
    @pulumi.getter(name="cpuCredits")
    def cpu_credits(self) -> Optional[str]:
        """
        The credit option for CPU usage of the instance.

        Valid values: `standard` | `unlimited`

        T3 instances with `host` tenancy do not support the `unlimited` CPU credit option.
        """
        return pulumi.get(self, "cpu_credits")


@pulumi.output_type
class DestinationOptionsProperties(dict):
    """
    The destination options.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileFormat":
            suggest = "file_format"
        elif key == "hiveCompatiblePartitions":
            suggest = "hive_compatible_partitions"
        elif key == "perHourPartition":
            suggest = "per_hour_partition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationOptionsProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationOptionsProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationOptionsProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_format: 'FlowLogDestinationOptionsPropertiesFileFormat',
                 hive_compatible_partitions: bool,
                 per_hour_partition: bool):
        """
        The destination options.
        :param 'FlowLogDestinationOptionsPropertiesFileFormat' file_format: The format for the flow log. The default is `plain-text` .
        :param bool hive_compatible_partitions: Indicates whether to use Hive-compatible prefixes for flow logs stored in Amazon S3. The default is `false` .
        :param bool per_hour_partition: Indicates whether to partition the flow log per hour. This reduces the cost and response time for queries. The default is `false` .
        """
        pulumi.set(__self__, "file_format", file_format)
        pulumi.set(__self__, "hive_compatible_partitions", hive_compatible_partitions)
        pulumi.set(__self__, "per_hour_partition", per_hour_partition)

    @property
    @pulumi.getter(name="fileFormat")
    def file_format(self) -> 'FlowLogDestinationOptionsPropertiesFileFormat':
        """
        The format for the flow log. The default is `plain-text` .
        """
        return pulumi.get(self, "file_format")

    @property
    @pulumi.getter(name="hiveCompatiblePartitions")
    def hive_compatible_partitions(self) -> bool:
        """
        Indicates whether to use Hive-compatible prefixes for flow logs stored in Amazon S3. The default is `false` .
        """
        return pulumi.get(self, "hive_compatible_partitions")

    @property
    @pulumi.getter(name="perHourPartition")
    def per_hour_partition(self) -> bool:
        """
        Indicates whether to partition the flow log per hour. This reduces the cost and response time for queries. The default is `false` .
        """
        return pulumi.get(self, "per_hour_partition")


@pulumi.output_type
class Ec2FleetAcceleratorCountRequest(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        :param int max: The maximum number of accelerators. To specify no maximum limit, omit this parameter. To exclude accelerator-enabled instance types, set `Max` to `0` .
        :param int min: The minimum number of accelerators. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        The maximum number of accelerators. To specify no maximum limit, omit this parameter. To exclude accelerator-enabled instance types, set `Max` to `0` .
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        The minimum number of accelerators. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class Ec2FleetAcceleratorTotalMemoryMiBRequest(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        :param int max: The maximum amount of accelerator memory, in MiB. To specify no maximum limit, omit this parameter.
        :param int min: The minimum amount of accelerator memory, in MiB. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        The maximum amount of accelerator memory, in MiB. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        The minimum amount of accelerator memory, in MiB. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class Ec2FleetBaselineEbsBandwidthMbpsRequest(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        :param int max: The maximum baseline bandwidth, in Mbps. To specify no maximum limit, omit this parameter.
        :param int min: The minimum baseline bandwidth, in Mbps. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        The maximum baseline bandwidth, in Mbps. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        The minimum baseline bandwidth, in Mbps. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class Ec2FleetCapacityRebalance(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replacementStrategy":
            suggest = "replacement_strategy"
        elif key == "terminationDelay":
            suggest = "termination_delay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2FleetCapacityRebalance. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2FleetCapacityRebalance.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2FleetCapacityRebalance.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 replacement_strategy: Optional['Ec2FleetCapacityRebalanceReplacementStrategy'] = None,
                 termination_delay: Optional[int] = None):
        """
        :param 'Ec2FleetCapacityRebalanceReplacementStrategy' replacement_strategy: The replacement strategy to use. Only available for fleets of type `maintain` .
               
               `launch` - EC2 Fleet launches a replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet. EC2 Fleet does not terminate the instances that receive a rebalance notification. You can terminate the old instances, or you can leave them running. You are charged for all instances while they are running.
               
               `launch-before-terminate` - EC2 Fleet launches a replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet, and then, after a delay that you specify (in `TerminationDelay` ), terminates the instances that received a rebalance notification.
        :param int termination_delay: The amount of time (in seconds) that Amazon EC2 waits before terminating the old Spot Instance after launching a new replacement Spot Instance.
               
               Required when `ReplacementStrategy` is set to `launch-before-terminate` .
               
               Not valid when `ReplacementStrategy` is set to `launch` .
               
               Valid values: Minimum value of `120` seconds. Maximum value of `7200` seconds.
        """
        if replacement_strategy is not None:
            pulumi.set(__self__, "replacement_strategy", replacement_strategy)
        if termination_delay is not None:
            pulumi.set(__self__, "termination_delay", termination_delay)

    @property
    @pulumi.getter(name="replacementStrategy")
    def replacement_strategy(self) -> Optional['Ec2FleetCapacityRebalanceReplacementStrategy']:
        """
        The replacement strategy to use. Only available for fleets of type `maintain` .

        `launch` - EC2 Fleet launches a replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet. EC2 Fleet does not terminate the instances that receive a rebalance notification. You can terminate the old instances, or you can leave them running. You are charged for all instances while they are running.

        `launch-before-terminate` - EC2 Fleet launches a replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet, and then, after a delay that you specify (in `TerminationDelay` ), terminates the instances that received a rebalance notification.
        """
        return pulumi.get(self, "replacement_strategy")

    @property
    @pulumi.getter(name="terminationDelay")
    def termination_delay(self) -> Optional[int]:
        """
        The amount of time (in seconds) that Amazon EC2 waits before terminating the old Spot Instance after launching a new replacement Spot Instance.

        Required when `ReplacementStrategy` is set to `launch-before-terminate` .

        Not valid when `ReplacementStrategy` is set to `launch` .

        Valid values: Minimum value of `120` seconds. Maximum value of `7200` seconds.
        """
        return pulumi.get(self, "termination_delay")


@pulumi.output_type
class Ec2FleetCapacityReservationOptionsRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "usageStrategy":
            suggest = "usage_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2FleetCapacityReservationOptionsRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2FleetCapacityReservationOptionsRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2FleetCapacityReservationOptionsRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 usage_strategy: Optional['Ec2FleetCapacityReservationOptionsRequestUsageStrategy'] = None):
        """
        :param 'Ec2FleetCapacityReservationOptionsRequestUsageStrategy' usage_strategy: Indicates whether to use unused Capacity Reservations for fulfilling On-Demand capacity.
               
               If you specify `use-capacity-reservations-first` , the fleet uses unused Capacity Reservations to fulfill On-Demand capacity up to the target On-Demand capacity. If multiple instance pools have unused Capacity Reservations, the On-Demand allocation strategy ( `lowest-price` or `prioritized` ) is applied. If the number of unused Capacity Reservations is less than the On-Demand target capacity, the remaining On-Demand target capacity is launched according to the On-Demand allocation strategy ( `lowest-price` or `prioritized` ).
               
               If you do not specify a value, the fleet fulfils the On-Demand capacity according to the chosen On-Demand allocation strategy.
        """
        if usage_strategy is not None:
            pulumi.set(__self__, "usage_strategy", usage_strategy)

    @property
    @pulumi.getter(name="usageStrategy")
    def usage_strategy(self) -> Optional['Ec2FleetCapacityReservationOptionsRequestUsageStrategy']:
        """
        Indicates whether to use unused Capacity Reservations for fulfilling On-Demand capacity.

        If you specify `use-capacity-reservations-first` , the fleet uses unused Capacity Reservations to fulfill On-Demand capacity up to the target On-Demand capacity. If multiple instance pools have unused Capacity Reservations, the On-Demand allocation strategy ( `lowest-price` or `prioritized` ) is applied. If the number of unused Capacity Reservations is less than the On-Demand target capacity, the remaining On-Demand target capacity is launched according to the On-Demand allocation strategy ( `lowest-price` or `prioritized` ).

        If you do not specify a value, the fleet fulfils the On-Demand capacity according to the chosen On-Demand allocation strategy.
        """
        return pulumi.get(self, "usage_strategy")


@pulumi.output_type
class Ec2FleetFleetLaunchTemplateConfigRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTemplateSpecification":
            suggest = "launch_template_specification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2FleetFleetLaunchTemplateConfigRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2FleetFleetLaunchTemplateConfigRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2FleetFleetLaunchTemplateConfigRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 launch_template_specification: Optional['outputs.Ec2FleetFleetLaunchTemplateSpecificationRequest'] = None,
                 overrides: Optional[Sequence['outputs.Ec2FleetFleetLaunchTemplateOverridesRequest']] = None):
        """
        :param 'Ec2FleetFleetLaunchTemplateSpecificationRequest' launch_template_specification: The launch template to use. You must specify either the launch template ID or launch template name in the request.
        :param Sequence['Ec2FleetFleetLaunchTemplateOverridesRequest'] overrides: Any parameters that you specify override the same parameters in the launch template.
               
               For fleets of type `request` and `maintain` , a maximum of 300 items is allowed across all launch templates.
        """
        if launch_template_specification is not None:
            pulumi.set(__self__, "launch_template_specification", launch_template_specification)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)

    @property
    @pulumi.getter(name="launchTemplateSpecification")
    def launch_template_specification(self) -> Optional['outputs.Ec2FleetFleetLaunchTemplateSpecificationRequest']:
        """
        The launch template to use. You must specify either the launch template ID or launch template name in the request.
        """
        return pulumi.get(self, "launch_template_specification")

    @property
    @pulumi.getter
    def overrides(self) -> Optional[Sequence['outputs.Ec2FleetFleetLaunchTemplateOverridesRequest']]:
        """
        Any parameters that you specify override the same parameters in the launch template.

        For fleets of type `request` and `maintain` , a maximum of 300 items is allowed across all launch templates.
        """
        return pulumi.get(self, "overrides")


@pulumi.output_type
class Ec2FleetFleetLaunchTemplateOverridesRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "instanceRequirements":
            suggest = "instance_requirements"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "maxPrice":
            suggest = "max_price"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "weightedCapacity":
            suggest = "weighted_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2FleetFleetLaunchTemplateOverridesRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2FleetFleetLaunchTemplateOverridesRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2FleetFleetLaunchTemplateOverridesRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone: Optional[str] = None,
                 instance_requirements: Optional['outputs.Ec2FleetInstanceRequirementsRequest'] = None,
                 instance_type: Optional[str] = None,
                 max_price: Optional[str] = None,
                 placement: Optional['outputs.Ec2FleetPlacement'] = None,
                 priority: Optional[float] = None,
                 subnet_id: Optional[str] = None,
                 weighted_capacity: Optional[float] = None):
        """
        :param str availability_zone: The Availability Zone in which to launch the instances.
        :param 'Ec2FleetInstanceRequirementsRequest' instance_requirements: The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with those attributes.
               
               > If you specify `InstanceRequirements` , you can't specify `InstanceType` .
        :param str instance_type: The instance type.
               
               `mac1.metal` is not supported as a launch template override.
               
               > If you specify `InstanceType` , you can't specify `InstanceRequirements` .
        :param str max_price: The maximum price per unit hour that you are willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.
               
               > If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.
        :param 'Ec2FleetPlacement' placement: The location where the instance launched, if applicable.
        :param float priority: The priority for the launch template override. The highest priority is launched first.
               
               If the On-Demand `AllocationStrategy` is set to `prioritized` , EC2 Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity.
               
               If the Spot `AllocationStrategy` is set to `capacity-optimized-prioritized` , EC2 Fleet uses priority on a best-effort basis to determine which launch template override to use in fulfilling Spot capacity, but optimizes for capacity first.
               
               Valid values are whole numbers starting at `0` . The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority. You can set the same priority for different launch template overrides.
        :param str subnet_id: The IDs of the subnets in which to launch the instances. Separate multiple subnet IDs using commas (for example, `subnet-1234abcdeexample1, subnet-0987cdef6example2` ). A request of type `instant` can have only one subnet ID.
        :param float weighted_capacity: The number of units provided by the specified instance type. These are the same units that you chose to set the target capacity in terms of instances, or a performance characteristic such as vCPUs, memory, or I/O.
               
               If the target capacity divided by this value is not a whole number, Amazon EC2 rounds the number of instances to the next whole number. If this value is not specified, the default is 1.
               
               > When specifying weights, the price used in the `lowest-price` and `price-capacity-optimized` allocation strategies is per *unit* hour (where the instance price is divided by the specified weight). However, if all the specified weights are above the requested `TargetCapacity` , resulting in only 1 instance being launched, the price used is per *instance* hour.
        """
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if instance_requirements is not None:
            pulumi.set(__self__, "instance_requirements", instance_requirements)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if max_price is not None:
            pulumi.set(__self__, "max_price", max_price)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if weighted_capacity is not None:
            pulumi.set(__self__, "weighted_capacity", weighted_capacity)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[str]:
        """
        The Availability Zone in which to launch the instances.
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="instanceRequirements")
    def instance_requirements(self) -> Optional['outputs.Ec2FleetInstanceRequirementsRequest']:
        """
        The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with those attributes.

        > If you specify `InstanceRequirements` , you can't specify `InstanceType` .
        """
        return pulumi.get(self, "instance_requirements")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[str]:
        """
        The instance type.

        `mac1.metal` is not supported as a launch template override.

        > If you specify `InstanceType` , you can't specify `InstanceRequirements` .
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="maxPrice")
    def max_price(self) -> Optional[str]:
        """
        The maximum price per unit hour that you are willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.

        > If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.
        """
        return pulumi.get(self, "max_price")

    @property
    @pulumi.getter
    def placement(self) -> Optional['outputs.Ec2FleetPlacement']:
        """
        The location where the instance launched, if applicable.
        """
        return pulumi.get(self, "placement")

    @property
    @pulumi.getter
    def priority(self) -> Optional[float]:
        """
        The priority for the launch template override. The highest priority is launched first.

        If the On-Demand `AllocationStrategy` is set to `prioritized` , EC2 Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity.

        If the Spot `AllocationStrategy` is set to `capacity-optimized-prioritized` , EC2 Fleet uses priority on a best-effort basis to determine which launch template override to use in fulfilling Spot capacity, but optimizes for capacity first.

        Valid values are whole numbers starting at `0` . The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority. You can set the same priority for different launch template overrides.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The IDs of the subnets in which to launch the instances. Separate multiple subnet IDs using commas (for example, `subnet-1234abcdeexample1, subnet-0987cdef6example2` ). A request of type `instant` can have only one subnet ID.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="weightedCapacity")
    def weighted_capacity(self) -> Optional[float]:
        """
        The number of units provided by the specified instance type. These are the same units that you chose to set the target capacity in terms of instances, or a performance characteristic such as vCPUs, memory, or I/O.

        If the target capacity divided by this value is not a whole number, Amazon EC2 rounds the number of instances to the next whole number. If this value is not specified, the default is 1.

        > When specifying weights, the price used in the `lowest-price` and `price-capacity-optimized` allocation strategies is per *unit* hour (where the instance price is divided by the specified weight). However, if all the specified weights are above the requested `TargetCapacity` , resulting in only 1 instance being launched, the price used is per *instance* hour.
        """
        return pulumi.get(self, "weighted_capacity")


@pulumi.output_type
class Ec2FleetFleetLaunchTemplateSpecificationRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTemplateId":
            suggest = "launch_template_id"
        elif key == "launchTemplateName":
            suggest = "launch_template_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2FleetFleetLaunchTemplateSpecificationRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2FleetFleetLaunchTemplateSpecificationRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2FleetFleetLaunchTemplateSpecificationRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 version: str,
                 launch_template_id: Optional[str] = None,
                 launch_template_name: Optional[str] = None):
        """
        :param str version: The launch template version number, `$Latest` , or `$Default` . You must specify a value, otherwise the request fails.
               
               If the value is `$Latest` , Amazon EC2 uses the latest version of the launch template.
               
               If the value is `$Default` , Amazon EC2 uses the default version of the launch template.
        :param str launch_template_id: The ID of the launch template.
               
               You must specify the `LaunchTemplateId` or the `LaunchTemplateName` , but not both.
        :param str launch_template_name: The name of the launch template.
               
               You must specify the `LaunchTemplateName` or the `LaunchTemplateId` , but not both.
        """
        pulumi.set(__self__, "version", version)
        if launch_template_id is not None:
            pulumi.set(__self__, "launch_template_id", launch_template_id)
        if launch_template_name is not None:
            pulumi.set(__self__, "launch_template_name", launch_template_name)

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        The launch template version number, `$Latest` , or `$Default` . You must specify a value, otherwise the request fails.

        If the value is `$Latest` , Amazon EC2 uses the latest version of the launch template.

        If the value is `$Default` , Amazon EC2 uses the default version of the launch template.
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter(name="launchTemplateId")
    def launch_template_id(self) -> Optional[str]:
        """
        The ID of the launch template.

        You must specify the `LaunchTemplateId` or the `LaunchTemplateName` , but not both.
        """
        return pulumi.get(self, "launch_template_id")

    @property
    @pulumi.getter(name="launchTemplateName")
    def launch_template_name(self) -> Optional[str]:
        """
        The name of the launch template.

        You must specify the `LaunchTemplateName` or the `LaunchTemplateId` , but not both.
        """
        return pulumi.get(self, "launch_template_name")


@pulumi.output_type
class Ec2FleetInstanceRequirementsRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceleratorCount":
            suggest = "accelerator_count"
        elif key == "acceleratorManufacturers":
            suggest = "accelerator_manufacturers"
        elif key == "acceleratorNames":
            suggest = "accelerator_names"
        elif key == "acceleratorTotalMemoryMiB":
            suggest = "accelerator_total_memory_mi_b"
        elif key == "acceleratorTypes":
            suggest = "accelerator_types"
        elif key == "allowedInstanceTypes":
            suggest = "allowed_instance_types"
        elif key == "bareMetal":
            suggest = "bare_metal"
        elif key == "baselineEbsBandwidthMbps":
            suggest = "baseline_ebs_bandwidth_mbps"
        elif key == "burstablePerformance":
            suggest = "burstable_performance"
        elif key == "cpuManufacturers":
            suggest = "cpu_manufacturers"
        elif key == "excludedInstanceTypes":
            suggest = "excluded_instance_types"
        elif key == "instanceGenerations":
            suggest = "instance_generations"
        elif key == "localStorage":
            suggest = "local_storage"
        elif key == "localStorageTypes":
            suggest = "local_storage_types"
        elif key == "maxSpotPriceAsPercentageOfOptimalOnDemandPrice":
            suggest = "max_spot_price_as_percentage_of_optimal_on_demand_price"
        elif key == "memoryGiBPerVCpu":
            suggest = "memory_gi_b_per_v_cpu"
        elif key == "memoryMiB":
            suggest = "memory_mi_b"
        elif key == "networkBandwidthGbps":
            suggest = "network_bandwidth_gbps"
        elif key == "networkInterfaceCount":
            suggest = "network_interface_count"
        elif key == "onDemandMaxPricePercentageOverLowestPrice":
            suggest = "on_demand_max_price_percentage_over_lowest_price"
        elif key == "requireHibernateSupport":
            suggest = "require_hibernate_support"
        elif key == "spotMaxPricePercentageOverLowestPrice":
            suggest = "spot_max_price_percentage_over_lowest_price"
        elif key == "totalLocalStorageGb":
            suggest = "total_local_storage_gb"
        elif key == "vCpuCount":
            suggest = "v_cpu_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2FleetInstanceRequirementsRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2FleetInstanceRequirementsRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2FleetInstanceRequirementsRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accelerator_count: Optional['outputs.Ec2FleetAcceleratorCountRequest'] = None,
                 accelerator_manufacturers: Optional[Sequence['Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem']] = None,
                 accelerator_names: Optional[Sequence['Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem']] = None,
                 accelerator_total_memory_mi_b: Optional['outputs.Ec2FleetAcceleratorTotalMemoryMiBRequest'] = None,
                 accelerator_types: Optional[Sequence['Ec2FleetInstanceRequirementsRequestAcceleratorTypesItem']] = None,
                 allowed_instance_types: Optional[Sequence[str]] = None,
                 bare_metal: Optional['Ec2FleetInstanceRequirementsRequestBareMetal'] = None,
                 baseline_ebs_bandwidth_mbps: Optional['outputs.Ec2FleetBaselineEbsBandwidthMbpsRequest'] = None,
                 burstable_performance: Optional['Ec2FleetInstanceRequirementsRequestBurstablePerformance'] = None,
                 cpu_manufacturers: Optional[Sequence['Ec2FleetInstanceRequirementsRequestCpuManufacturersItem']] = None,
                 excluded_instance_types: Optional[Sequence[str]] = None,
                 instance_generations: Optional[Sequence['Ec2FleetInstanceRequirementsRequestInstanceGenerationsItem']] = None,
                 local_storage: Optional['Ec2FleetInstanceRequirementsRequestLocalStorage'] = None,
                 local_storage_types: Optional[Sequence['Ec2FleetInstanceRequirementsRequestLocalStorageTypesItem']] = None,
                 max_spot_price_as_percentage_of_optimal_on_demand_price: Optional[int] = None,
                 memory_gi_b_per_v_cpu: Optional['outputs.Ec2FleetMemoryGiBPerVCpuRequest'] = None,
                 memory_mi_b: Optional['outputs.Ec2FleetMemoryMiBRequest'] = None,
                 network_bandwidth_gbps: Optional['outputs.Ec2FleetNetworkBandwidthGbpsRequest'] = None,
                 network_interface_count: Optional['outputs.Ec2FleetNetworkInterfaceCountRequest'] = None,
                 on_demand_max_price_percentage_over_lowest_price: Optional[int] = None,
                 require_hibernate_support: Optional[bool] = None,
                 spot_max_price_percentage_over_lowest_price: Optional[int] = None,
                 total_local_storage_gb: Optional['outputs.Ec2FleetTotalLocalStorageGbRequest'] = None,
                 v_cpu_count: Optional['outputs.Ec2FleetVCpuCountRangeRequest'] = None):
        """
        :param 'Ec2FleetAcceleratorCountRequest' accelerator_count: The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.
               
               To exclude accelerator-enabled instance types, set `Max` to `0` .
               
               Default: No minimum or maximum limits
        :param Sequence['Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem'] accelerator_manufacturers: Indicates whether instance types must have accelerators by specific manufacturers.
               
               - For instance types with AWS devices, specify `amazon-web-services` .
               - For instance types with AMD devices, specify `amd` .
               - For instance types with Habana devices, specify `habana` .
               - For instance types with NVIDIA devices, specify `nvidia` .
               - For instance types with Xilinx devices, specify `xilinx` .
               
               Default: Any manufacturer
        :param Sequence['Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem'] accelerator_names: The accelerators that must be on the instance type.
               
               - For instance types with NVIDIA A10G GPUs, specify `a10g` .
               - For instance types with NVIDIA A100 GPUs, specify `a100` .
               - For instance types with NVIDIA H100 GPUs, specify `h100` .
               - For instance types with AWS Inferentia chips, specify `inferentia` .
               - For instance types with NVIDIA GRID K520 GPUs, specify `k520` .
               - For instance types with NVIDIA K80 GPUs, specify `k80` .
               - For instance types with NVIDIA M60 GPUs, specify `m60` .
               - For instance types with AMD Radeon Pro V520 GPUs, specify `radeon-pro-v520` .
               - For instance types with NVIDIA T4 GPUs, specify `t4` .
               - For instance types with NVIDIA T4G GPUs, specify `t4g` .
               - For instance types with Xilinx VU9P FPGAs, specify `vu9p` .
               - For instance types with NVIDIA V100 GPUs, specify `v100` .
               
               Default: Any accelerator
        :param 'Ec2FleetAcceleratorTotalMemoryMiBRequest' accelerator_total_memory_mi_b: The minimum and maximum amount of total accelerator memory, in MiB.
               
               Default: No minimum or maximum limits
        :param Sequence['Ec2FleetInstanceRequirementsRequestAcceleratorTypesItem'] accelerator_types: The accelerator types that must be on the instance type.
               
               - To include instance types with GPU hardware, specify `gpu` .
               - To include instance types with FPGA hardware, specify `fpga` .
               - To include instance types with inference hardware, specify `inference` .
               
               Default: Any accelerator type
        :param Sequence[str] allowed_instance_types: The instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes.
               
               You can use strings with one or more wild cards, represented by an asterisk ( `*` ), to allow an instance type, size, or generation. The following are examples: `m5.8xlarge` , `c5*.*` , `m5a.*` , `r*` , `*3*` .
               
               For example, if you specify `c5*` ,Amazon EC2 will allow the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*` , Amazon EC2 will allow all the M5a instance types, but not the M5n instance types.
               
               > If you specify `AllowedInstanceTypes` , you can't specify `ExcludedInstanceTypes` . 
               
               Default: All instance types
        :param 'Ec2FleetInstanceRequirementsRequestBareMetal' bare_metal: Indicates whether bare metal instance types must be included, excluded, or required.
               
               - To include bare metal instance types, specify `included` .
               - To require only bare metal instance types, specify `required` .
               - To exclude bare metal instance types, specify `excluded` .
               
               Default: `excluded`
        :param 'Ec2FleetBaselineEbsBandwidthMbpsRequest' baseline_ebs_bandwidth_mbps: The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see [Amazon EBSoptimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the *Amazon EC2 User Guide* .
               
               Default: No minimum or maximum limits
        :param 'Ec2FleetInstanceRequirementsRequestBurstablePerformance' burstable_performance: Indicates whether burstable performance T instance types are included, excluded, or required. For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) .
               
               - To include burstable performance instance types, specify `included` .
               - To require only burstable performance instance types, specify `required` .
               - To exclude burstable performance instance types, specify `excluded` .
               
               Default: `excluded`
        :param Sequence['Ec2FleetInstanceRequirementsRequestCpuManufacturersItem'] cpu_manufacturers: The CPU manufacturers to include.
               
               - For instance types with Intel CPUs, specify `intel` .
               - For instance types with AMD CPUs, specify `amd` .
               - For instance types with AWS CPUs, specify `amazon-web-services` .
               
               > Don't confuse the CPU manufacturer with the CPU architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template. 
               
               Default: Any manufacturer
        :param Sequence[str] excluded_instance_types: The instance types to exclude.
               
               You can use strings with one or more wild cards, represented by an asterisk ( `*` ), to exclude an instance family, type, size, or generation. The following are examples: `m5.8xlarge` , `c5*.*` , `m5a.*` , `r*` , `*3*` .
               
               For example, if you specify `c5*` ,Amazon EC2 will exclude the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*` , Amazon EC2 will exclude all the M5a instance types, but not the M5n instance types.
               
               > If you specify `ExcludedInstanceTypes` , you can't specify `AllowedInstanceTypes` . 
               
               Default: No excluded instance types
        :param Sequence['Ec2FleetInstanceRequirementsRequestInstanceGenerationsItem'] instance_generations: Indicates whether current or previous generation instance types are included. The current generation instance types are recommended for use. Current generation instance types are typically the latest two to three generations in each instance family. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .
               
               For current generation instance types, specify `current` .
               
               For previous generation instance types, specify `previous` .
               
               Default: Current and previous generation instance types
        :param 'Ec2FleetInstanceRequirementsRequestLocalStorage' local_storage: Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, [Amazon EC2 instance store](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html) in the *Amazon EC2 User Guide* .
               
               - To include instance types with instance store volumes, specify `included` .
               - To require only instance types with instance store volumes, specify `required` .
               - To exclude instance types with instance store volumes, specify `excluded` .
               
               Default: `included`
        :param Sequence['Ec2FleetInstanceRequirementsRequestLocalStorageTypesItem'] local_storage_types: The type of local storage that is required.
               
               - For instance types with hard disk drive (HDD) storage, specify `hdd` .
               - For instance types with solid state drive (SSD) storage, specify `ssd` .
               
               Default: `hdd` and `ssd`
        :param int max_spot_price_as_percentage_of_optimal_on_demand_price: [Price protection] The price protection threshold for Spot Instances, as a percentage of an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.
               
               The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
               
               If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is based on the per vCPU or per memory price instead of the per instance price.
               
               > Only one of `SpotMaxPricePercentageOverLowestPrice` or `MaxSpotPriceAsPercentageOfOptimalOnDemandPrice` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as `999999` .
        :param 'Ec2FleetMemoryGiBPerVCpuRequest' memory_gi_b_per_v_cpu: The minimum and maximum amount of memory per vCPU, in GiB.
               
               Default: No minimum or maximum limits
        :param 'Ec2FleetMemoryMiBRequest' memory_mi_b: The minimum and maximum amount of memory, in MiB.
        :param 'Ec2FleetNetworkBandwidthGbpsRequest' network_bandwidth_gbps: The minimum and maximum amount of baseline network bandwidth, in gigabits per second (Gbps). For more information, see [Amazon EC2 instance network bandwidth](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-network-bandwidth.html) in the *Amazon EC2 User Guide* .
               
               Default: No minimum or maximum limits
        :param 'Ec2FleetNetworkInterfaceCountRequest' network_interface_count: The minimum and maximum number of network interfaces.
               
               Default: No minimum or maximum limits
        :param int on_demand_max_price_percentage_over_lowest_price: [Price protection] The price protection threshold for On-Demand Instances, as a percentage higher than an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.
               
               The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
               
               To indicate no price protection threshold, specify a high value, such as `999999` .
               
               This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) .
               
               > If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price. 
               
               Default: `20`
        :param bool require_hibernate_support: Indicates whether instance types must support hibernation for On-Demand Instances.
               
               This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) .
               
               Default: `false`
        :param int spot_max_price_percentage_over_lowest_price: [Price protection] The price protection threshold for Spot Instances, as a percentage higher than an identified Spot price. The identified Spot price is the Spot price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified Spot price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose Spot price exceeds your specified threshold.
               
               The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
               
               If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.
               
               This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) .
               
               > Only one of `SpotMaxPricePercentageOverLowestPrice` or `MaxSpotPriceAsPercentageOfOptimalOnDemandPrice` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as `999999` . 
               
               Default: `100`
        :param 'Ec2FleetTotalLocalStorageGbRequest' total_local_storage_gb: The minimum and maximum amount of total local storage, in GB.
               
               Default: No minimum or maximum limits
        :param 'Ec2FleetVCpuCountRangeRequest' v_cpu_count: The minimum and maximum number of vCPUs.
        """
        if accelerator_count is not None:
            pulumi.set(__self__, "accelerator_count", accelerator_count)
        if accelerator_manufacturers is not None:
            pulumi.set(__self__, "accelerator_manufacturers", accelerator_manufacturers)
        if accelerator_names is not None:
            pulumi.set(__self__, "accelerator_names", accelerator_names)
        if accelerator_total_memory_mi_b is not None:
            pulumi.set(__self__, "accelerator_total_memory_mi_b", accelerator_total_memory_mi_b)
        if accelerator_types is not None:
            pulumi.set(__self__, "accelerator_types", accelerator_types)
        if allowed_instance_types is not None:
            pulumi.set(__self__, "allowed_instance_types", allowed_instance_types)
        if bare_metal is not None:
            pulumi.set(__self__, "bare_metal", bare_metal)
        if baseline_ebs_bandwidth_mbps is not None:
            pulumi.set(__self__, "baseline_ebs_bandwidth_mbps", baseline_ebs_bandwidth_mbps)
        if burstable_performance is not None:
            pulumi.set(__self__, "burstable_performance", burstable_performance)
        if cpu_manufacturers is not None:
            pulumi.set(__self__, "cpu_manufacturers", cpu_manufacturers)
        if excluded_instance_types is not None:
            pulumi.set(__self__, "excluded_instance_types", excluded_instance_types)
        if instance_generations is not None:
            pulumi.set(__self__, "instance_generations", instance_generations)
        if local_storage is not None:
            pulumi.set(__self__, "local_storage", local_storage)
        if local_storage_types is not None:
            pulumi.set(__self__, "local_storage_types", local_storage_types)
        if max_spot_price_as_percentage_of_optimal_on_demand_price is not None:
            pulumi.set(__self__, "max_spot_price_as_percentage_of_optimal_on_demand_price", max_spot_price_as_percentage_of_optimal_on_demand_price)
        if memory_gi_b_per_v_cpu is not None:
            pulumi.set(__self__, "memory_gi_b_per_v_cpu", memory_gi_b_per_v_cpu)
        if memory_mi_b is not None:
            pulumi.set(__self__, "memory_mi_b", memory_mi_b)
        if network_bandwidth_gbps is not None:
            pulumi.set(__self__, "network_bandwidth_gbps", network_bandwidth_gbps)
        if network_interface_count is not None:
            pulumi.set(__self__, "network_interface_count", network_interface_count)
        if on_demand_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "on_demand_max_price_percentage_over_lowest_price", on_demand_max_price_percentage_over_lowest_price)
        if require_hibernate_support is not None:
            pulumi.set(__self__, "require_hibernate_support", require_hibernate_support)
        if spot_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "spot_max_price_percentage_over_lowest_price", spot_max_price_percentage_over_lowest_price)
        if total_local_storage_gb is not None:
            pulumi.set(__self__, "total_local_storage_gb", total_local_storage_gb)
        if v_cpu_count is not None:
            pulumi.set(__self__, "v_cpu_count", v_cpu_count)

    @property
    @pulumi.getter(name="acceleratorCount")
    def accelerator_count(self) -> Optional['outputs.Ec2FleetAcceleratorCountRequest']:
        """
        The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.

        To exclude accelerator-enabled instance types, set `Max` to `0` .

        Default: No minimum or maximum limits
        """
        return pulumi.get(self, "accelerator_count")

    @property
    @pulumi.getter(name="acceleratorManufacturers")
    def accelerator_manufacturers(self) -> Optional[Sequence['Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem']]:
        """
        Indicates whether instance types must have accelerators by specific manufacturers.

        - For instance types with AWS devices, specify `amazon-web-services` .
        - For instance types with AMD devices, specify `amd` .
        - For instance types with Habana devices, specify `habana` .
        - For instance types with NVIDIA devices, specify `nvidia` .
        - For instance types with Xilinx devices, specify `xilinx` .

        Default: Any manufacturer
        """
        return pulumi.get(self, "accelerator_manufacturers")

    @property
    @pulumi.getter(name="acceleratorNames")
    def accelerator_names(self) -> Optional[Sequence['Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem']]:
        """
        The accelerators that must be on the instance type.

        - For instance types with NVIDIA A10G GPUs, specify `a10g` .
        - For instance types with NVIDIA A100 GPUs, specify `a100` .
        - For instance types with NVIDIA H100 GPUs, specify `h100` .
        - For instance types with AWS Inferentia chips, specify `inferentia` .
        - For instance types with NVIDIA GRID K520 GPUs, specify `k520` .
        - For instance types with NVIDIA K80 GPUs, specify `k80` .
        - For instance types with NVIDIA M60 GPUs, specify `m60` .
        - For instance types with AMD Radeon Pro V520 GPUs, specify `radeon-pro-v520` .
        - For instance types with NVIDIA T4 GPUs, specify `t4` .
        - For instance types with NVIDIA T4G GPUs, specify `t4g` .
        - For instance types with Xilinx VU9P FPGAs, specify `vu9p` .
        - For instance types with NVIDIA V100 GPUs, specify `v100` .

        Default: Any accelerator
        """
        return pulumi.get(self, "accelerator_names")

    @property
    @pulumi.getter(name="acceleratorTotalMemoryMiB")
    def accelerator_total_memory_mi_b(self) -> Optional['outputs.Ec2FleetAcceleratorTotalMemoryMiBRequest']:
        """
        The minimum and maximum amount of total accelerator memory, in MiB.

        Default: No minimum or maximum limits
        """
        return pulumi.get(self, "accelerator_total_memory_mi_b")

    @property
    @pulumi.getter(name="acceleratorTypes")
    def accelerator_types(self) -> Optional[Sequence['Ec2FleetInstanceRequirementsRequestAcceleratorTypesItem']]:
        """
        The accelerator types that must be on the instance type.

        - To include instance types with GPU hardware, specify `gpu` .
        - To include instance types with FPGA hardware, specify `fpga` .
        - To include instance types with inference hardware, specify `inference` .

        Default: Any accelerator type
        """
        return pulumi.get(self, "accelerator_types")

    @property
    @pulumi.getter(name="allowedInstanceTypes")
    def allowed_instance_types(self) -> Optional[Sequence[str]]:
        """
        The instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes.

        You can use strings with one or more wild cards, represented by an asterisk ( `*` ), to allow an instance type, size, or generation. The following are examples: `m5.8xlarge` , `c5*.*` , `m5a.*` , `r*` , `*3*` .

        For example, if you specify `c5*` ,Amazon EC2 will allow the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*` , Amazon EC2 will allow all the M5a instance types, but not the M5n instance types.

        > If you specify `AllowedInstanceTypes` , you can't specify `ExcludedInstanceTypes` . 

        Default: All instance types
        """
        return pulumi.get(self, "allowed_instance_types")

    @property
    @pulumi.getter(name="bareMetal")
    def bare_metal(self) -> Optional['Ec2FleetInstanceRequirementsRequestBareMetal']:
        """
        Indicates whether bare metal instance types must be included, excluded, or required.

        - To include bare metal instance types, specify `included` .
        - To require only bare metal instance types, specify `required` .
        - To exclude bare metal instance types, specify `excluded` .

        Default: `excluded`
        """
        return pulumi.get(self, "bare_metal")

    @property
    @pulumi.getter(name="baselineEbsBandwidthMbps")
    def baseline_ebs_bandwidth_mbps(self) -> Optional['outputs.Ec2FleetBaselineEbsBandwidthMbpsRequest']:
        """
        The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see [Amazon EBSoptimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the *Amazon EC2 User Guide* .

        Default: No minimum or maximum limits
        """
        return pulumi.get(self, "baseline_ebs_bandwidth_mbps")

    @property
    @pulumi.getter(name="burstablePerformance")
    def burstable_performance(self) -> Optional['Ec2FleetInstanceRequirementsRequestBurstablePerformance']:
        """
        Indicates whether burstable performance T instance types are included, excluded, or required. For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) .

        - To include burstable performance instance types, specify `included` .
        - To require only burstable performance instance types, specify `required` .
        - To exclude burstable performance instance types, specify `excluded` .

        Default: `excluded`
        """
        return pulumi.get(self, "burstable_performance")

    @property
    @pulumi.getter(name="cpuManufacturers")
    def cpu_manufacturers(self) -> Optional[Sequence['Ec2FleetInstanceRequirementsRequestCpuManufacturersItem']]:
        """
        The CPU manufacturers to include.

        - For instance types with Intel CPUs, specify `intel` .
        - For instance types with AMD CPUs, specify `amd` .
        - For instance types with AWS CPUs, specify `amazon-web-services` .

        > Don't confuse the CPU manufacturer with the CPU architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template. 

        Default: Any manufacturer
        """
        return pulumi.get(self, "cpu_manufacturers")

    @property
    @pulumi.getter(name="excludedInstanceTypes")
    def excluded_instance_types(self) -> Optional[Sequence[str]]:
        """
        The instance types to exclude.

        You can use strings with one or more wild cards, represented by an asterisk ( `*` ), to exclude an instance family, type, size, or generation. The following are examples: `m5.8xlarge` , `c5*.*` , `m5a.*` , `r*` , `*3*` .

        For example, if you specify `c5*` ,Amazon EC2 will exclude the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*` , Amazon EC2 will exclude all the M5a instance types, but not the M5n instance types.

        > If you specify `ExcludedInstanceTypes` , you can't specify `AllowedInstanceTypes` . 

        Default: No excluded instance types
        """
        return pulumi.get(self, "excluded_instance_types")

    @property
    @pulumi.getter(name="instanceGenerations")
    def instance_generations(self) -> Optional[Sequence['Ec2FleetInstanceRequirementsRequestInstanceGenerationsItem']]:
        """
        Indicates whether current or previous generation instance types are included. The current generation instance types are recommended for use. Current generation instance types are typically the latest two to three generations in each instance family. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .

        For current generation instance types, specify `current` .

        For previous generation instance types, specify `previous` .

        Default: Current and previous generation instance types
        """
        return pulumi.get(self, "instance_generations")

    @property
    @pulumi.getter(name="localStorage")
    def local_storage(self) -> Optional['Ec2FleetInstanceRequirementsRequestLocalStorage']:
        """
        Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, [Amazon EC2 instance store](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html) in the *Amazon EC2 User Guide* .

        - To include instance types with instance store volumes, specify `included` .
        - To require only instance types with instance store volumes, specify `required` .
        - To exclude instance types with instance store volumes, specify `excluded` .

        Default: `included`
        """
        return pulumi.get(self, "local_storage")

    @property
    @pulumi.getter(name="localStorageTypes")
    def local_storage_types(self) -> Optional[Sequence['Ec2FleetInstanceRequirementsRequestLocalStorageTypesItem']]:
        """
        The type of local storage that is required.

        - For instance types with hard disk drive (HDD) storage, specify `hdd` .
        - For instance types with solid state drive (SSD) storage, specify `ssd` .

        Default: `hdd` and `ssd`
        """
        return pulumi.get(self, "local_storage_types")

    @property
    @pulumi.getter(name="maxSpotPriceAsPercentageOfOptimalOnDemandPrice")
    def max_spot_price_as_percentage_of_optimal_on_demand_price(self) -> Optional[int]:
        """
        [Price protection] The price protection threshold for Spot Instances, as a percentage of an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.

        The parameter accepts an integer, which Amazon EC2 interprets as a percentage.

        If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is based on the per vCPU or per memory price instead of the per instance price.

        > Only one of `SpotMaxPricePercentageOverLowestPrice` or `MaxSpotPriceAsPercentageOfOptimalOnDemandPrice` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as `999999` .
        """
        return pulumi.get(self, "max_spot_price_as_percentage_of_optimal_on_demand_price")

    @property
    @pulumi.getter(name="memoryGiBPerVCpu")
    def memory_gi_b_per_v_cpu(self) -> Optional['outputs.Ec2FleetMemoryGiBPerVCpuRequest']:
        """
        The minimum and maximum amount of memory per vCPU, in GiB.

        Default: No minimum or maximum limits
        """
        return pulumi.get(self, "memory_gi_b_per_v_cpu")

    @property
    @pulumi.getter(name="memoryMiB")
    def memory_mi_b(self) -> Optional['outputs.Ec2FleetMemoryMiBRequest']:
        """
        The minimum and maximum amount of memory, in MiB.
        """
        return pulumi.get(self, "memory_mi_b")

    @property
    @pulumi.getter(name="networkBandwidthGbps")
    def network_bandwidth_gbps(self) -> Optional['outputs.Ec2FleetNetworkBandwidthGbpsRequest']:
        """
        The minimum and maximum amount of baseline network bandwidth, in gigabits per second (Gbps). For more information, see [Amazon EC2 instance network bandwidth](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-network-bandwidth.html) in the *Amazon EC2 User Guide* .

        Default: No minimum or maximum limits
        """
        return pulumi.get(self, "network_bandwidth_gbps")

    @property
    @pulumi.getter(name="networkInterfaceCount")
    def network_interface_count(self) -> Optional['outputs.Ec2FleetNetworkInterfaceCountRequest']:
        """
        The minimum and maximum number of network interfaces.

        Default: No minimum or maximum limits
        """
        return pulumi.get(self, "network_interface_count")

    @property
    @pulumi.getter(name="onDemandMaxPricePercentageOverLowestPrice")
    def on_demand_max_price_percentage_over_lowest_price(self) -> Optional[int]:
        """
        [Price protection] The price protection threshold for On-Demand Instances, as a percentage higher than an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.

        The parameter accepts an integer, which Amazon EC2 interprets as a percentage.

        To indicate no price protection threshold, specify a high value, such as `999999` .

        This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) .

        > If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price. 

        Default: `20`
        """
        return pulumi.get(self, "on_demand_max_price_percentage_over_lowest_price")

    @property
    @pulumi.getter(name="requireHibernateSupport")
    def require_hibernate_support(self) -> Optional[bool]:
        """
        Indicates whether instance types must support hibernation for On-Demand Instances.

        This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) .

        Default: `false`
        """
        return pulumi.get(self, "require_hibernate_support")

    @property
    @pulumi.getter(name="spotMaxPricePercentageOverLowestPrice")
    def spot_max_price_percentage_over_lowest_price(self) -> Optional[int]:
        """
        [Price protection] The price protection threshold for Spot Instances, as a percentage higher than an identified Spot price. The identified Spot price is the Spot price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified Spot price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose Spot price exceeds your specified threshold.

        The parameter accepts an integer, which Amazon EC2 interprets as a percentage.

        If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.

        This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) .

        > Only one of `SpotMaxPricePercentageOverLowestPrice` or `MaxSpotPriceAsPercentageOfOptimalOnDemandPrice` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as `999999` . 

        Default: `100`
        """
        return pulumi.get(self, "spot_max_price_percentage_over_lowest_price")

    @property
    @pulumi.getter(name="totalLocalStorageGb")
    def total_local_storage_gb(self) -> Optional['outputs.Ec2FleetTotalLocalStorageGbRequest']:
        """
        The minimum and maximum amount of total local storage, in GB.

        Default: No minimum or maximum limits
        """
        return pulumi.get(self, "total_local_storage_gb")

    @property
    @pulumi.getter(name="vCpuCount")
    def v_cpu_count(self) -> Optional['outputs.Ec2FleetVCpuCountRangeRequest']:
        """
        The minimum and maximum number of vCPUs.
        """
        return pulumi.get(self, "v_cpu_count")


@pulumi.output_type
class Ec2FleetMaintenanceStrategies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityRebalance":
            suggest = "capacity_rebalance"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2FleetMaintenanceStrategies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2FleetMaintenanceStrategies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2FleetMaintenanceStrategies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_rebalance: Optional['outputs.Ec2FleetCapacityRebalance'] = None):
        """
        :param 'Ec2FleetCapacityRebalance' capacity_rebalance: The strategy to use when Amazon EC2 emits a signal that your Spot Instance is at an elevated risk of being interrupted.
        """
        if capacity_rebalance is not None:
            pulumi.set(__self__, "capacity_rebalance", capacity_rebalance)

    @property
    @pulumi.getter(name="capacityRebalance")
    def capacity_rebalance(self) -> Optional['outputs.Ec2FleetCapacityRebalance']:
        """
        The strategy to use when Amazon EC2 emits a signal that your Spot Instance is at an elevated risk of being interrupted.
        """
        return pulumi.get(self, "capacity_rebalance")


@pulumi.output_type
class Ec2FleetMemoryGiBPerVCpuRequest(dict):
    def __init__(__self__, *,
                 max: Optional[float] = None,
                 min: Optional[float] = None):
        """
        :param float max: The maximum amount of memory per vCPU, in GiB. To specify no maximum limit, omit this parameter.
        :param float min: The minimum amount of memory per vCPU, in GiB. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        """
        The maximum amount of memory per vCPU, in GiB. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        """
        The minimum amount of memory per vCPU, in GiB. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class Ec2FleetMemoryMiBRequest(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        :param int max: The maximum amount of memory, in MiB. To specify no maximum limit, omit this parameter.
        :param int min: The minimum amount of memory, in MiB. To specify no minimum limit, specify `0` .
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        The maximum amount of memory, in MiB. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        The minimum amount of memory, in MiB. To specify no minimum limit, specify `0` .
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class Ec2FleetNetworkBandwidthGbpsRequest(dict):
    def __init__(__self__, *,
                 max: Optional[float] = None,
                 min: Optional[float] = None):
        """
        :param float max: The maximum amount of network bandwidth, in Gbps. To specify no maximum limit, omit this parameter.
        :param float min: The minimum amount of network bandwidth, in Gbps. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        """
        The maximum amount of network bandwidth, in Gbps. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        """
        The minimum amount of network bandwidth, in Gbps. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class Ec2FleetNetworkInterfaceCountRequest(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        :param int max: The maximum number of network interfaces. To specify no maximum limit, omit this parameter.
        :param int min: The minimum number of network interfaces. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        The maximum number of network interfaces. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        The minimum number of network interfaces. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class Ec2FleetOnDemandOptionsRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocationStrategy":
            suggest = "allocation_strategy"
        elif key == "capacityReservationOptions":
            suggest = "capacity_reservation_options"
        elif key == "maxTotalPrice":
            suggest = "max_total_price"
        elif key == "minTargetCapacity":
            suggest = "min_target_capacity"
        elif key == "singleAvailabilityZone":
            suggest = "single_availability_zone"
        elif key == "singleInstanceType":
            suggest = "single_instance_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2FleetOnDemandOptionsRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2FleetOnDemandOptionsRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2FleetOnDemandOptionsRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocation_strategy: Optional[str] = None,
                 capacity_reservation_options: Optional['outputs.Ec2FleetCapacityReservationOptionsRequest'] = None,
                 max_total_price: Optional[str] = None,
                 min_target_capacity: Optional[int] = None,
                 single_availability_zone: Optional[bool] = None,
                 single_instance_type: Optional[bool] = None):
        """
        :param str allocation_strategy: The strategy that determines the order of the launch template overrides to use in fulfilling On-Demand capacity.
               
               `lowest-price` - EC2 Fleet uses price to determine the order, launching the lowest price first.
               
               `prioritized` - EC2 Fleet uses the priority that you assigned to each launch template override, launching the highest priority first.
               
               Default: `lowest-price`
        :param 'Ec2FleetCapacityReservationOptionsRequest' capacity_reservation_options: The strategy for using unused Capacity Reservations for fulfilling On-Demand capacity.
               
               Supported only for fleets of type `instant` .
        :param str max_total_price: The maximum amount per hour for On-Demand Instances that you're willing to pay.
               
               > If your fleet includes T instances that are configured as `unlimited` , and if their average CPU usage exceeds the baseline utilization, you will incur a charge for surplus credits. The `MaxTotalPrice` does not account for surplus credits, and, if you use surplus credits, your final cost might be higher than what you specified for `MaxTotalPrice` . For more information, see [Surplus credits can incur charges](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-unlimited-mode-concepts.html#unlimited-mode-surplus-credits) in the *Amazon EC2 User Guide* .
        :param int min_target_capacity: The minimum target capacity for On-Demand Instances in the fleet. If this minimum capacity isn't reached, no instances are launched.
               
               Constraints: Maximum value of `1000` . Supported only for fleets of type `instant` .
               
               At least one of the following must be specified: `SingleAvailabilityZone` | `SingleInstanceType`
        :param bool single_availability_zone: Indicates that the fleet launches all On-Demand Instances into a single Availability Zone.
               
               Supported only for fleets of type `instant` .
        :param bool single_instance_type: Indicates that the fleet uses a single instance type to launch all On-Demand Instances in the fleet.
               
               Supported only for fleets of type `instant` .
        """
        if allocation_strategy is not None:
            pulumi.set(__self__, "allocation_strategy", allocation_strategy)
        if capacity_reservation_options is not None:
            pulumi.set(__self__, "capacity_reservation_options", capacity_reservation_options)
        if max_total_price is not None:
            pulumi.set(__self__, "max_total_price", max_total_price)
        if min_target_capacity is not None:
            pulumi.set(__self__, "min_target_capacity", min_target_capacity)
        if single_availability_zone is not None:
            pulumi.set(__self__, "single_availability_zone", single_availability_zone)
        if single_instance_type is not None:
            pulumi.set(__self__, "single_instance_type", single_instance_type)

    @property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> Optional[str]:
        """
        The strategy that determines the order of the launch template overrides to use in fulfilling On-Demand capacity.

        `lowest-price` - EC2 Fleet uses price to determine the order, launching the lowest price first.

        `prioritized` - EC2 Fleet uses the priority that you assigned to each launch template override, launching the highest priority first.

        Default: `lowest-price`
        """
        return pulumi.get(self, "allocation_strategy")

    @property
    @pulumi.getter(name="capacityReservationOptions")
    def capacity_reservation_options(self) -> Optional['outputs.Ec2FleetCapacityReservationOptionsRequest']:
        """
        The strategy for using unused Capacity Reservations for fulfilling On-Demand capacity.

        Supported only for fleets of type `instant` .
        """
        return pulumi.get(self, "capacity_reservation_options")

    @property
    @pulumi.getter(name="maxTotalPrice")
    def max_total_price(self) -> Optional[str]:
        """
        The maximum amount per hour for On-Demand Instances that you're willing to pay.

        > If your fleet includes T instances that are configured as `unlimited` , and if their average CPU usage exceeds the baseline utilization, you will incur a charge for surplus credits. The `MaxTotalPrice` does not account for surplus credits, and, if you use surplus credits, your final cost might be higher than what you specified for `MaxTotalPrice` . For more information, see [Surplus credits can incur charges](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-unlimited-mode-concepts.html#unlimited-mode-surplus-credits) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "max_total_price")

    @property
    @pulumi.getter(name="minTargetCapacity")
    def min_target_capacity(self) -> Optional[int]:
        """
        The minimum target capacity for On-Demand Instances in the fleet. If this minimum capacity isn't reached, no instances are launched.

        Constraints: Maximum value of `1000` . Supported only for fleets of type `instant` .

        At least one of the following must be specified: `SingleAvailabilityZone` | `SingleInstanceType`
        """
        return pulumi.get(self, "min_target_capacity")

    @property
    @pulumi.getter(name="singleAvailabilityZone")
    def single_availability_zone(self) -> Optional[bool]:
        """
        Indicates that the fleet launches all On-Demand Instances into a single Availability Zone.

        Supported only for fleets of type `instant` .
        """
        return pulumi.get(self, "single_availability_zone")

    @property
    @pulumi.getter(name="singleInstanceType")
    def single_instance_type(self) -> Optional[bool]:
        """
        Indicates that the fleet uses a single instance type to launch all On-Demand Instances in the fleet.

        Supported only for fleets of type `instant` .
        """
        return pulumi.get(self, "single_instance_type")


@pulumi.output_type
class Ec2FleetPlacement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "groupName":
            suggest = "group_name"
        elif key == "hostId":
            suggest = "host_id"
        elif key == "hostResourceGroupArn":
            suggest = "host_resource_group_arn"
        elif key == "partitionNumber":
            suggest = "partition_number"
        elif key == "spreadDomain":
            suggest = "spread_domain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2FleetPlacement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2FleetPlacement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2FleetPlacement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 affinity: Optional[str] = None,
                 availability_zone: Optional[str] = None,
                 group_name: Optional[str] = None,
                 host_id: Optional[str] = None,
                 host_resource_group_arn: Optional[str] = None,
                 partition_number: Optional[int] = None,
                 spread_domain: Optional[str] = None,
                 tenancy: Optional[str] = None):
        """
        :param str affinity: The affinity setting for the instance on the Dedicated Host.
               
               This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) or [ImportInstance](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html) .
        :param str availability_zone: The Availability Zone of the instance.
               
               If not specified, an Availability Zone will be automatically chosen for you based on the load balancing criteria for the Region.
               
               This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) .
        :param str group_name: The name of the placement group that the instance is in. If you specify `GroupName` , you can't specify `GroupId` .
        :param str host_id: The ID of the Dedicated Host on which the instance resides.
               
               This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) or [ImportInstance](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html) .
        :param str host_resource_group_arn: The ARN of the host resource group in which to launch the instances.
               
               If you specify this parameter, either omit the *Tenancy* parameter or set it to `host` .
               
               This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) .
        :param int partition_number: The number of the partition that the instance is in. Valid only if the placement group strategy is set to `partition` .
               
               This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) .
        :param str spread_domain: Reserved for future use.
        :param str tenancy: The tenancy of the instance. An instance with a tenancy of `dedicated` runs on single-tenant hardware.
               
               This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) . The `host` tenancy is not supported for [ImportInstance](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html) or for T3 instances that are configured for the `unlimited` CPU credit option.
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if host_id is not None:
            pulumi.set(__self__, "host_id", host_id)
        if host_resource_group_arn is not None:
            pulumi.set(__self__, "host_resource_group_arn", host_resource_group_arn)
        if partition_number is not None:
            pulumi.set(__self__, "partition_number", partition_number)
        if spread_domain is not None:
            pulumi.set(__self__, "spread_domain", spread_domain)
        if tenancy is not None:
            pulumi.set(__self__, "tenancy", tenancy)

    @property
    @pulumi.getter
    def affinity(self) -> Optional[str]:
        """
        The affinity setting for the instance on the Dedicated Host.

        This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) or [ImportInstance](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html) .
        """
        return pulumi.get(self, "affinity")

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[str]:
        """
        The Availability Zone of the instance.

        If not specified, an Availability Zone will be automatically chosen for you based on the load balancing criteria for the Region.

        This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) .
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[str]:
        """
        The name of the placement group that the instance is in. If you specify `GroupName` , you can't specify `GroupId` .
        """
        return pulumi.get(self, "group_name")

    @property
    @pulumi.getter(name="hostId")
    def host_id(self) -> Optional[str]:
        """
        The ID of the Dedicated Host on which the instance resides.

        This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) or [ImportInstance](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html) .
        """
        return pulumi.get(self, "host_id")

    @property
    @pulumi.getter(name="hostResourceGroupArn")
    def host_resource_group_arn(self) -> Optional[str]:
        """
        The ARN of the host resource group in which to launch the instances.

        If you specify this parameter, either omit the *Tenancy* parameter or set it to `host` .

        This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) .
        """
        return pulumi.get(self, "host_resource_group_arn")

    @property
    @pulumi.getter(name="partitionNumber")
    def partition_number(self) -> Optional[int]:
        """
        The number of the partition that the instance is in. Valid only if the placement group strategy is set to `partition` .

        This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) .
        """
        return pulumi.get(self, "partition_number")

    @property
    @pulumi.getter(name="spreadDomain")
    def spread_domain(self) -> Optional[str]:
        """
        Reserved for future use.
        """
        return pulumi.get(self, "spread_domain")

    @property
    @pulumi.getter
    def tenancy(self) -> Optional[str]:
        """
        The tenancy of the instance. An instance with a tenancy of `dedicated` runs on single-tenant hardware.

        This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) . The `host` tenancy is not supported for [ImportInstance](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html) or for T3 instances that are configured for the `unlimited` CPU credit option.
        """
        return pulumi.get(self, "tenancy")


@pulumi.output_type
class Ec2FleetSpotOptionsRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocationStrategy":
            suggest = "allocation_strategy"
        elif key == "instanceInterruptionBehavior":
            suggest = "instance_interruption_behavior"
        elif key == "instancePoolsToUseCount":
            suggest = "instance_pools_to_use_count"
        elif key == "maintenanceStrategies":
            suggest = "maintenance_strategies"
        elif key == "maxTotalPrice":
            suggest = "max_total_price"
        elif key == "minTargetCapacity":
            suggest = "min_target_capacity"
        elif key == "singleAvailabilityZone":
            suggest = "single_availability_zone"
        elif key == "singleInstanceType":
            suggest = "single_instance_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2FleetSpotOptionsRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2FleetSpotOptionsRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2FleetSpotOptionsRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocation_strategy: Optional['Ec2FleetSpotOptionsRequestAllocationStrategy'] = None,
                 instance_interruption_behavior: Optional['Ec2FleetSpotOptionsRequestInstanceInterruptionBehavior'] = None,
                 instance_pools_to_use_count: Optional[int] = None,
                 maintenance_strategies: Optional['outputs.Ec2FleetMaintenanceStrategies'] = None,
                 max_total_price: Optional[str] = None,
                 min_target_capacity: Optional[int] = None,
                 single_availability_zone: Optional[bool] = None,
                 single_instance_type: Optional[bool] = None):
        """
        :param 'Ec2FleetSpotOptionsRequestAllocationStrategy' allocation_strategy: Indicates how to allocate the target Spot Instance capacity across the Spot Instance pools specified by the EC2 Fleet.
               
               If the allocation strategy is `lowestPrice` , EC2 Fleet launches instances from the Spot Instance pools with the lowest price. This is the default allocation strategy.
               
               If the allocation strategy is `diversified` , EC2 Fleet launches instances from all the Spot Instance pools that you specify.
               
               If the allocation strategy is `capacityOptimized` , EC2 Fleet launches instances from Spot Instance pools that are optimally chosen based on the available Spot Instance capacity.
               
               *Allowed Values* : `lowestPrice` | `diversified` | `capacityOptimized` | `capacityOptimizedPrioritized`
        :param 'Ec2FleetSpotOptionsRequestInstanceInterruptionBehavior' instance_interruption_behavior: The behavior when a Spot Instance is interrupted.
               
               Default: `terminate`
        :param int instance_pools_to_use_count: The number of Spot pools across which to allocate your target Spot capacity. Supported only when Spot `AllocationStrategy` is set to `lowest-price` . EC2 Fleet selects the cheapest Spot pools and evenly allocates your target Spot capacity across the number of Spot pools that you specify.
               
               Note that EC2 Fleet attempts to draw Spot Instances from the number of pools that you specify on a best effort basis. If a pool runs out of Spot capacity before fulfilling your target capacity, EC2 Fleet will continue to fulfill your request by drawing from the next cheapest pool. To ensure that your target capacity is met, you might receive Spot Instances from more than the number of pools that you specified. Similarly, if most of the pools have no Spot capacity, you might receive your full target capacity from fewer than the number of pools that you specified.
        :param 'Ec2FleetMaintenanceStrategies' maintenance_strategies: The strategies for managing your Spot Instances that are at an elevated risk of being interrupted.
        :param str max_total_price: The maximum amount per hour for Spot Instances that you're willing to pay. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.
               
               > If you specify a maximum price, your Spot Instances will be interrupted more frequently than if you do not specify this parameter. > If your fleet includes T instances that are configured as `unlimited` , and if their average CPU usage exceeds the baseline utilization, you will incur a charge for surplus credits. The `MaxTotalPrice` does not account for surplus credits, and, if you use surplus credits, your final cost might be higher than what you specified for `MaxTotalPrice` . For more information, see [Surplus credits can incur charges](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-unlimited-mode-concepts.html#unlimited-mode-surplus-credits) in the *Amazon EC2 User Guide* .
        :param int min_target_capacity: The minimum target capacity for Spot Instances in the fleet. If this minimum capacity isn't reached, no instances are launched.
               
               Constraints: Maximum value of `1000` . Supported only for fleets of type `instant` .
               
               At least one of the following must be specified: `SingleAvailabilityZone` | `SingleInstanceType`
        :param bool single_availability_zone: Indicates that the fleet launches all Spot Instances into a single Availability Zone.
               
               Supported only for fleets of type `instant` .
        :param bool single_instance_type: Indicates that the fleet uses a single instance type to launch all Spot Instances in the fleet.
               
               Supported only for fleets of type `instant` .
        """
        if allocation_strategy is not None:
            pulumi.set(__self__, "allocation_strategy", allocation_strategy)
        if instance_interruption_behavior is not None:
            pulumi.set(__self__, "instance_interruption_behavior", instance_interruption_behavior)
        if instance_pools_to_use_count is not None:
            pulumi.set(__self__, "instance_pools_to_use_count", instance_pools_to_use_count)
        if maintenance_strategies is not None:
            pulumi.set(__self__, "maintenance_strategies", maintenance_strategies)
        if max_total_price is not None:
            pulumi.set(__self__, "max_total_price", max_total_price)
        if min_target_capacity is not None:
            pulumi.set(__self__, "min_target_capacity", min_target_capacity)
        if single_availability_zone is not None:
            pulumi.set(__self__, "single_availability_zone", single_availability_zone)
        if single_instance_type is not None:
            pulumi.set(__self__, "single_instance_type", single_instance_type)

    @property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> Optional['Ec2FleetSpotOptionsRequestAllocationStrategy']:
        """
        Indicates how to allocate the target Spot Instance capacity across the Spot Instance pools specified by the EC2 Fleet.

        If the allocation strategy is `lowestPrice` , EC2 Fleet launches instances from the Spot Instance pools with the lowest price. This is the default allocation strategy.

        If the allocation strategy is `diversified` , EC2 Fleet launches instances from all the Spot Instance pools that you specify.

        If the allocation strategy is `capacityOptimized` , EC2 Fleet launches instances from Spot Instance pools that are optimally chosen based on the available Spot Instance capacity.

        *Allowed Values* : `lowestPrice` | `diversified` | `capacityOptimized` | `capacityOptimizedPrioritized`
        """
        return pulumi.get(self, "allocation_strategy")

    @property
    @pulumi.getter(name="instanceInterruptionBehavior")
    def instance_interruption_behavior(self) -> Optional['Ec2FleetSpotOptionsRequestInstanceInterruptionBehavior']:
        """
        The behavior when a Spot Instance is interrupted.

        Default: `terminate`
        """
        return pulumi.get(self, "instance_interruption_behavior")

    @property
    @pulumi.getter(name="instancePoolsToUseCount")
    def instance_pools_to_use_count(self) -> Optional[int]:
        """
        The number of Spot pools across which to allocate your target Spot capacity. Supported only when Spot `AllocationStrategy` is set to `lowest-price` . EC2 Fleet selects the cheapest Spot pools and evenly allocates your target Spot capacity across the number of Spot pools that you specify.

        Note that EC2 Fleet attempts to draw Spot Instances from the number of pools that you specify on a best effort basis. If a pool runs out of Spot capacity before fulfilling your target capacity, EC2 Fleet will continue to fulfill your request by drawing from the next cheapest pool. To ensure that your target capacity is met, you might receive Spot Instances from more than the number of pools that you specified. Similarly, if most of the pools have no Spot capacity, you might receive your full target capacity from fewer than the number of pools that you specified.
        """
        return pulumi.get(self, "instance_pools_to_use_count")

    @property
    @pulumi.getter(name="maintenanceStrategies")
    def maintenance_strategies(self) -> Optional['outputs.Ec2FleetMaintenanceStrategies']:
        """
        The strategies for managing your Spot Instances that are at an elevated risk of being interrupted.
        """
        return pulumi.get(self, "maintenance_strategies")

    @property
    @pulumi.getter(name="maxTotalPrice")
    def max_total_price(self) -> Optional[str]:
        """
        The maximum amount per hour for Spot Instances that you're willing to pay. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.

        > If you specify a maximum price, your Spot Instances will be interrupted more frequently than if you do not specify this parameter. > If your fleet includes T instances that are configured as `unlimited` , and if their average CPU usage exceeds the baseline utilization, you will incur a charge for surplus credits. The `MaxTotalPrice` does not account for surplus credits, and, if you use surplus credits, your final cost might be higher than what you specified for `MaxTotalPrice` . For more information, see [Surplus credits can incur charges](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-unlimited-mode-concepts.html#unlimited-mode-surplus-credits) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "max_total_price")

    @property
    @pulumi.getter(name="minTargetCapacity")
    def min_target_capacity(self) -> Optional[int]:
        """
        The minimum target capacity for Spot Instances in the fleet. If this minimum capacity isn't reached, no instances are launched.

        Constraints: Maximum value of `1000` . Supported only for fleets of type `instant` .

        At least one of the following must be specified: `SingleAvailabilityZone` | `SingleInstanceType`
        """
        return pulumi.get(self, "min_target_capacity")

    @property
    @pulumi.getter(name="singleAvailabilityZone")
    def single_availability_zone(self) -> Optional[bool]:
        """
        Indicates that the fleet launches all Spot Instances into a single Availability Zone.

        Supported only for fleets of type `instant` .
        """
        return pulumi.get(self, "single_availability_zone")

    @property
    @pulumi.getter(name="singleInstanceType")
    def single_instance_type(self) -> Optional[bool]:
        """
        Indicates that the fleet uses a single instance type to launch all Spot Instances in the fleet.

        Supported only for fleets of type `instant` .
        """
        return pulumi.get(self, "single_instance_type")


@pulumi.output_type
class Ec2FleetTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The tag key.
        :param str value: The tag value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The tag value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class Ec2FleetTagSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2FleetTagSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2FleetTagSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2FleetTagSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_type: Optional['Ec2FleetTagSpecificationResourceType'] = None,
                 tags: Optional[Sequence['outputs.Ec2FleetTag']] = None):
        """
        :param 'Ec2FleetTagSpecificationResourceType' resource_type: The type of resource to tag.
        :param Sequence['Ec2FleetTag'] tags: The tags to apply to the resource.
        """
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional['Ec2FleetTagSpecificationResourceType']:
        """
        The type of resource to tag.
        """
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.Ec2FleetTag']]:
        """
        The tags to apply to the resource.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class Ec2FleetTargetCapacitySpecificationRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "totalTargetCapacity":
            suggest = "total_target_capacity"
        elif key == "defaultTargetCapacityType":
            suggest = "default_target_capacity_type"
        elif key == "onDemandTargetCapacity":
            suggest = "on_demand_target_capacity"
        elif key == "spotTargetCapacity":
            suggest = "spot_target_capacity"
        elif key == "targetCapacityUnitType":
            suggest = "target_capacity_unit_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2FleetTargetCapacitySpecificationRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2FleetTargetCapacitySpecificationRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2FleetTargetCapacitySpecificationRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 total_target_capacity: int,
                 default_target_capacity_type: Optional['Ec2FleetTargetCapacitySpecificationRequestDefaultTargetCapacityType'] = None,
                 on_demand_target_capacity: Optional[int] = None,
                 spot_target_capacity: Optional[int] = None,
                 target_capacity_unit_type: Optional['Ec2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType'] = None):
        """
        :param int total_target_capacity: The number of units to request, filled using the default target capacity type.
        :param 'Ec2FleetTargetCapacitySpecificationRequestDefaultTargetCapacityType' default_target_capacity_type: The default target capacity type.
        :param int on_demand_target_capacity: The number of On-Demand units to request.
        :param int spot_target_capacity: The number of Spot units to request.
        :param 'Ec2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType' target_capacity_unit_type: The unit for the target capacity. You can specify this parameter only when using attributed-based instance type selection.
               
               Default: `units` (the number of instances)
        """
        pulumi.set(__self__, "total_target_capacity", total_target_capacity)
        if default_target_capacity_type is not None:
            pulumi.set(__self__, "default_target_capacity_type", default_target_capacity_type)
        if on_demand_target_capacity is not None:
            pulumi.set(__self__, "on_demand_target_capacity", on_demand_target_capacity)
        if spot_target_capacity is not None:
            pulumi.set(__self__, "spot_target_capacity", spot_target_capacity)
        if target_capacity_unit_type is not None:
            pulumi.set(__self__, "target_capacity_unit_type", target_capacity_unit_type)

    @property
    @pulumi.getter(name="totalTargetCapacity")
    def total_target_capacity(self) -> int:
        """
        The number of units to request, filled using the default target capacity type.
        """
        return pulumi.get(self, "total_target_capacity")

    @property
    @pulumi.getter(name="defaultTargetCapacityType")
    def default_target_capacity_type(self) -> Optional['Ec2FleetTargetCapacitySpecificationRequestDefaultTargetCapacityType']:
        """
        The default target capacity type.
        """
        return pulumi.get(self, "default_target_capacity_type")

    @property
    @pulumi.getter(name="onDemandTargetCapacity")
    def on_demand_target_capacity(self) -> Optional[int]:
        """
        The number of On-Demand units to request.
        """
        return pulumi.get(self, "on_demand_target_capacity")

    @property
    @pulumi.getter(name="spotTargetCapacity")
    def spot_target_capacity(self) -> Optional[int]:
        """
        The number of Spot units to request.
        """
        return pulumi.get(self, "spot_target_capacity")

    @property
    @pulumi.getter(name="targetCapacityUnitType")
    def target_capacity_unit_type(self) -> Optional['Ec2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType']:
        """
        The unit for the target capacity. You can specify this parameter only when using attributed-based instance type selection.

        Default: `units` (the number of instances)
        """
        return pulumi.get(self, "target_capacity_unit_type")


@pulumi.output_type
class Ec2FleetTotalLocalStorageGbRequest(dict):
    def __init__(__self__, *,
                 max: Optional[float] = None,
                 min: Optional[float] = None):
        """
        :param float max: The maximum amount of total local storage, in GB. To specify no maximum limit, omit this parameter.
        :param float min: The minimum amount of total local storage, in GB. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        """
        The maximum amount of total local storage, in GB. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        """
        The minimum amount of total local storage, in GB. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class Ec2FleetVCpuCountRangeRequest(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        :param int max: The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
        :param int min: The minimum number of vCPUs. To specify no minimum limit, specify `0` .
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        The minimum number of vCPUs. To specify no minimum limit, specify `0` .
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class EnclaveOptionsProperties(dict):
    """
    Indicates whether the instance is enabled for AWS Nitro Enclaves.
    """
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        Indicates whether the instance is enabled for AWS Nitro Enclaves.
        :param bool enabled: If this parameter is set to true, the instance is enabled for AWS Nitro Enclaves; otherwise, it is not enabled for AWS Nitro Enclaves.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If this parameter is set to true, the instance is enabled for AWS Nitro Enclaves; otherwise, it is not enabled for AWS Nitro Enclaves.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class HibernationOptionsProperties(dict):
    """
    Indicates whether an instance is enabled for hibernation.
    """
    def __init__(__self__, *,
                 configured: Optional[bool] = None):
        """
        Indicates whether an instance is enabled for hibernation.
        :param bool configured: If you set this parameter to true, your instance is enabled for hibernation.
        """
        if configured is not None:
            pulumi.set(__self__, "configured", configured)

    @property
    @pulumi.getter
    def configured(self) -> Optional[bool]:
        """
        If you set this parameter to true, your instance is enabled for hibernation.
        """
        return pulumi.get(self, "configured")


@pulumi.output_type
class InstanceAssociationParameter(dict):
    def __init__(__self__, *,
                 key: str,
                 value: Sequence[str]):
        """
        :param str key: The name of an input parameter that is in the associated SSM document.
        :param Sequence[str] value: The value of an input parameter.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The name of an input parameter that is in the associated SSM document.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Sequence[str]:
        """
        The value of an input parameter.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class InstanceBlockDeviceMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "noDevice":
            suggest = "no_device"
        elif key == "virtualName":
            suggest = "virtual_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceBlockDeviceMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceBlockDeviceMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceBlockDeviceMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: str,
                 ebs: Optional['outputs.InstanceEbs'] = None,
                 no_device: Optional[Any] = None,
                 virtual_name: Optional[str] = None):
        """
        :param str device_name: The device name (for example, /dev/sdh or xvdh).
        :param 'InstanceEbs' ebs: Parameters used to automatically set up EBS volumes when the instance is launched.
        :param Any no_device: To omit the device from the block device mapping, specify an empty string.
               
               > After the instance is running, modifying this parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
        :param str virtual_name: The virtual device name ( `ephemeral` N). The name must be in the form `ephemeral` *X* where *X* is a number starting from zero (0). For example, an instance type with 2 available instance store volumes can specify mappings for `ephemeral0` and `ephemeral1` . The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.
               
               NVMe instance store volumes are automatically enumerated and assigned a device name. Including them in your block device mapping has no effect.
               
               *Constraints* : For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.
               
               > After the instance is running, modifying this parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
        """
        pulumi.set(__self__, "device_name", device_name)
        if ebs is not None:
            pulumi.set(__self__, "ebs", ebs)
        if no_device is not None:
            pulumi.set(__self__, "no_device", no_device)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        """
        The device name (for example, /dev/sdh or xvdh).
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter
    def ebs(self) -> Optional['outputs.InstanceEbs']:
        """
        Parameters used to automatically set up EBS volumes when the instance is launched.
        """
        return pulumi.get(self, "ebs")

    @property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[Any]:
        """
        To omit the device from the block device mapping, specify an empty string.

        > After the instance is running, modifying this parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
        """
        return pulumi.get(self, "no_device")

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[str]:
        """
        The virtual device name ( `ephemeral` N). The name must be in the form `ephemeral` *X* where *X* is a number starting from zero (0). For example, an instance type with 2 available instance store volumes can specify mappings for `ephemeral0` and `ephemeral1` . The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.

        NVMe instance store volumes are automatically enumerated and assigned a device name. Including them in your block device mapping has no effect.

        *Constraints* : For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.

        > After the instance is running, modifying this parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
        """
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class InstanceEbs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceEbs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceEbs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceEbs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_on_termination: Optional[bool] = None,
                 encrypted: Optional[bool] = None,
                 iops: Optional[int] = None,
                 kms_key_id: Optional[str] = None,
                 snapshot_id: Optional[str] = None,
                 volume_size: Optional[int] = None,
                 volume_type: Optional[str] = None):
        """
        :param bool delete_on_termination: Indicates whether the EBS volume is deleted on instance termination.
        :param bool encrypted: Indicates whether the volume should be encrypted.
        :param int iops: The number of I/O operations per second (IOPS). For gp3, io1, and io2 volumes, this represents the number of IOPS that are provisioned for the volume. For gp2 volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.
        :param str kms_key_id: The identifier of the AWS Key Management Service (AWS KMS) customer managed CMK to use for Amazon EBS encryption. If KmsKeyId is specified, the encrypted state must be true. If the encrypted state is true but you do not specify KmsKeyId, your AWS managed CMK for EBS is used.
        :param str snapshot_id: The ID of the snapshot.
        :param int volume_size: The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size.
        :param str volume_type: The volume type.
        """
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[bool]:
        """
        Indicates whether the EBS volume is deleted on instance termination.
        """
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[bool]:
        """
        Indicates whether the volume should be encrypted.
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        """
        The number of I/O operations per second (IOPS). For gp3, io1, and io2 volumes, this represents the number of IOPS that are provisioned for the volume. For gp2 volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.
        """
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        The identifier of the AWS Key Management Service (AWS KMS) customer managed CMK to use for Amazon EBS encryption. If KmsKeyId is specified, the encrypted state must be true. If the encrypted state is true but you do not specify KmsKeyId, your AWS managed CMK for EBS is used.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        """
        The ID of the snapshot.
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[int]:
        """
        The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size.
        """
        return pulumi.get(self, "volume_size")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[str]:
        """
        The volume type.
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class InstanceElasticGpuSpecification(dict):
    def __init__(__self__, *,
                 type: str):
        """
        :param str type: The type of Elastic Graphics accelerator.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of Elastic Graphics accelerator.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class InstanceElasticInferenceAccelerator(dict):
    def __init__(__self__, *,
                 type: str,
                 count: Optional[int] = None):
        """
        :param str type: The type of elastic inference accelerator.
        :param int count: The number of elastic inference accelerators to attach to the instance.
        """
        pulumi.set(__self__, "type", type)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of elastic inference accelerator.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The number of elastic inference accelerators to attach to the instance.
        """
        return pulumi.get(self, "count")


@pulumi.output_type
class InstanceIpv6Address(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv6Address":
            suggest = "ipv6_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceIpv6Address. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceIpv6Address.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceIpv6Address.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv6_address: str):
        """
        :param str ipv6_address: The IPv6 address.
        """
        pulumi.set(__self__, "ipv6_address", ipv6_address)

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> str:
        """
        The IPv6 address.
        """
        return pulumi.get(self, "ipv6_address")


@pulumi.output_type
class InstanceLaunchTemplateSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTemplateId":
            suggest = "launch_template_id"
        elif key == "launchTemplateName":
            suggest = "launch_template_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceLaunchTemplateSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceLaunchTemplateSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceLaunchTemplateSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 launch_template_id: Optional[str] = None,
                 launch_template_name: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str launch_template_id: The ID of the launch template. You must specify the LaunchTemplateName or the LaunchTemplateId, but not both.
        :param str launch_template_name: The name of the launch template. You must specify the LaunchTemplateName or the LaunchTemplateId, but not both.
        :param str version: The version number of the launch template.
        """
        if launch_template_id is not None:
            pulumi.set(__self__, "launch_template_id", launch_template_id)
        if launch_template_name is not None:
            pulumi.set(__self__, "launch_template_name", launch_template_name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="launchTemplateId")
    def launch_template_id(self) -> Optional[str]:
        """
        The ID of the launch template. You must specify the LaunchTemplateName or the LaunchTemplateId, but not both.
        """
        return pulumi.get(self, "launch_template_id")

    @property
    @pulumi.getter(name="launchTemplateName")
    def launch_template_name(self) -> Optional[str]:
        """
        The name of the launch template. You must specify the LaunchTemplateName or the LaunchTemplateId, but not both.
        """
        return pulumi.get(self, "launch_template_name")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        The version number of the launch template.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class InstanceLicenseSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "licenseConfigurationArn":
            suggest = "license_configuration_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceLicenseSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceLicenseSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceLicenseSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 license_configuration_arn: str):
        """
        :param str license_configuration_arn: The Amazon Resource Name (ARN) of the license configuration.
        """
        pulumi.set(__self__, "license_configuration_arn", license_configuration_arn)

    @property
    @pulumi.getter(name="licenseConfigurationArn")
    def license_configuration_arn(self) -> str:
        """
        The Amazon Resource Name (ARN) of the license configuration.
        """
        return pulumi.get(self, "license_configuration_arn")


@pulumi.output_type
class InstanceNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceIndex":
            suggest = "device_index"
        elif key == "associateCarrierIpAddress":
            suggest = "associate_carrier_ip_address"
        elif key == "associatePublicIpAddress":
            suggest = "associate_public_ip_address"
        elif key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "groupSet":
            suggest = "group_set"
        elif key == "ipv6AddressCount":
            suggest = "ipv6_address_count"
        elif key == "ipv6Addresses":
            suggest = "ipv6_addresses"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "privateIpAddress":
            suggest = "private_ip_address"
        elif key == "privateIpAddresses":
            suggest = "private_ip_addresses"
        elif key == "secondaryPrivateIpAddressCount":
            suggest = "secondary_private_ip_address_count"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_index: str,
                 associate_carrier_ip_address: Optional[bool] = None,
                 associate_public_ip_address: Optional[bool] = None,
                 delete_on_termination: Optional[bool] = None,
                 description: Optional[str] = None,
                 group_set: Optional[Sequence[str]] = None,
                 ipv6_address_count: Optional[int] = None,
                 ipv6_addresses: Optional[Sequence['outputs.InstanceIpv6Address']] = None,
                 network_interface_id: Optional[str] = None,
                 private_ip_address: Optional[str] = None,
                 private_ip_addresses: Optional[Sequence['outputs.InstancePrivateIpAddressSpecification']] = None,
                 secondary_private_ip_address_count: Optional[int] = None,
                 subnet_id: Optional[str] = None):
        """
        :param str device_index: The position of the network interface in the attachment order. A primary network interface has a device index of 0.
        :param bool associate_carrier_ip_address: Not currently supported by AWS CloudFormation.
        :param bool associate_public_ip_address: Indicates whether to assign a public IPv4 address to an instance you launch in a VPC.
        :param bool delete_on_termination: If set to true, the interface is deleted when the instance is terminated.
        :param str description: The description of the network interface.
        :param Sequence[str] group_set: The IDs of the security groups for the network interface.
        :param int ipv6_address_count: A number of IPv6 addresses to assign to the network interface.
        :param Sequence['InstanceIpv6Address'] ipv6_addresses: The IPv6 addresses associated with the network interface.
        :param str network_interface_id: The ID of the network interface.
        :param str private_ip_address: The private IPv4 address of the network interface.
        :param Sequence['InstancePrivateIpAddressSpecification'] private_ip_addresses: One or more private IPv4 addresses to assign to the network interface.
        :param int secondary_private_ip_address_count: The number of secondary private IPv4 addresses.
        :param str subnet_id: The ID of the subnet.
        """
        pulumi.set(__self__, "device_index", device_index)
        if associate_carrier_ip_address is not None:
            pulumi.set(__self__, "associate_carrier_ip_address", associate_carrier_ip_address)
        if associate_public_ip_address is not None:
            pulumi.set(__self__, "associate_public_ip_address", associate_public_ip_address)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if group_set is not None:
            pulumi.set(__self__, "group_set", group_set)
        if ipv6_address_count is not None:
            pulumi.set(__self__, "ipv6_address_count", ipv6_address_count)
        if ipv6_addresses is not None:
            pulumi.set(__self__, "ipv6_addresses", ipv6_addresses)
        if network_interface_id is not None:
            pulumi.set(__self__, "network_interface_id", network_interface_id)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)
        if private_ip_addresses is not None:
            pulumi.set(__self__, "private_ip_addresses", private_ip_addresses)
        if secondary_private_ip_address_count is not None:
            pulumi.set(__self__, "secondary_private_ip_address_count", secondary_private_ip_address_count)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> str:
        """
        The position of the network interface in the attachment order. A primary network interface has a device index of 0.
        """
        return pulumi.get(self, "device_index")

    @property
    @pulumi.getter(name="associateCarrierIpAddress")
    def associate_carrier_ip_address(self) -> Optional[bool]:
        """
        Not currently supported by AWS CloudFormation.
        """
        return pulumi.get(self, "associate_carrier_ip_address")

    @property
    @pulumi.getter(name="associatePublicIpAddress")
    def associate_public_ip_address(self) -> Optional[bool]:
        """
        Indicates whether to assign a public IPv4 address to an instance you launch in a VPC.
        """
        return pulumi.get(self, "associate_public_ip_address")

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[bool]:
        """
        If set to true, the interface is deleted when the instance is terminated.
        """
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the network interface.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="groupSet")
    def group_set(self) -> Optional[Sequence[str]]:
        """
        The IDs of the security groups for the network interface.
        """
        return pulumi.get(self, "group_set")

    @property
    @pulumi.getter(name="ipv6AddressCount")
    def ipv6_address_count(self) -> Optional[int]:
        """
        A number of IPv6 addresses to assign to the network interface.
        """
        return pulumi.get(self, "ipv6_address_count")

    @property
    @pulumi.getter(name="ipv6Addresses")
    def ipv6_addresses(self) -> Optional[Sequence['outputs.InstanceIpv6Address']]:
        """
        The IPv6 addresses associated with the network interface.
        """
        return pulumi.get(self, "ipv6_addresses")

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[str]:
        """
        The ID of the network interface.
        """
        return pulumi.get(self, "network_interface_id")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[str]:
        """
        The private IPv4 address of the network interface.
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="privateIpAddresses")
    def private_ip_addresses(self) -> Optional[Sequence['outputs.InstancePrivateIpAddressSpecification']]:
        """
        One or more private IPv4 addresses to assign to the network interface.
        """
        return pulumi.get(self, "private_ip_addresses")

    @property
    @pulumi.getter(name="secondaryPrivateIpAddressCount")
    def secondary_private_ip_address_count(self) -> Optional[int]:
        """
        The number of secondary private IPv4 addresses.
        """
        return pulumi.get(self, "secondary_private_ip_address_count")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The ID of the subnet.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class InstancePrivateDnsNameOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableResourceNameDnsARecord":
            suggest = "enable_resource_name_dns_a_record"
        elif key == "enableResourceNameDnsAaaaRecord":
            suggest = "enable_resource_name_dns_aaaa_record"
        elif key == "hostnameType":
            suggest = "hostname_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstancePrivateDnsNameOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstancePrivateDnsNameOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstancePrivateDnsNameOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_resource_name_dns_a_record: Optional[bool] = None,
                 enable_resource_name_dns_aaaa_record: Optional[bool] = None,
                 hostname_type: Optional['InstancePrivateDnsNameOptionsHostnameType'] = None):
        """
        :param bool enable_resource_name_dns_a_record: Indicates whether to respond to DNS queries for instance hostnames with DNS A records. For more information, see Amazon EC2 instance hostname types in the Amazon Elastic Compute Cloud User Guide.
        :param bool enable_resource_name_dns_aaaa_record: Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records. For more information, see Amazon EC2 instance hostname types in the Amazon Elastic Compute Cloud User Guide.
        :param 'InstancePrivateDnsNameOptionsHostnameType' hostname_type: The type of hostnames to assign to instances in the subnet at launch. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. For more information, see Amazon EC2 instance hostname types in the Amazon Elastic Compute Cloud User Guide.
        """
        if enable_resource_name_dns_a_record is not None:
            pulumi.set(__self__, "enable_resource_name_dns_a_record", enable_resource_name_dns_a_record)
        if enable_resource_name_dns_aaaa_record is not None:
            pulumi.set(__self__, "enable_resource_name_dns_aaaa_record", enable_resource_name_dns_aaaa_record)
        if hostname_type is not None:
            pulumi.set(__self__, "hostname_type", hostname_type)

    @property
    @pulumi.getter(name="enableResourceNameDnsARecord")
    def enable_resource_name_dns_a_record(self) -> Optional[bool]:
        """
        Indicates whether to respond to DNS queries for instance hostnames with DNS A records. For more information, see Amazon EC2 instance hostname types in the Amazon Elastic Compute Cloud User Guide.
        """
        return pulumi.get(self, "enable_resource_name_dns_a_record")

    @property
    @pulumi.getter(name="enableResourceNameDnsAaaaRecord")
    def enable_resource_name_dns_aaaa_record(self) -> Optional[bool]:
        """
        Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records. For more information, see Amazon EC2 instance hostname types in the Amazon Elastic Compute Cloud User Guide.
        """
        return pulumi.get(self, "enable_resource_name_dns_aaaa_record")

    @property
    @pulumi.getter(name="hostnameType")
    def hostname_type(self) -> Optional['InstancePrivateDnsNameOptionsHostnameType']:
        """
        The type of hostnames to assign to instances in the subnet at launch. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. For more information, see Amazon EC2 instance hostname types in the Amazon Elastic Compute Cloud User Guide.
        """
        return pulumi.get(self, "hostname_type")


@pulumi.output_type
class InstancePrivateIpAddressSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIpAddress":
            suggest = "private_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstancePrivateIpAddressSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstancePrivateIpAddressSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstancePrivateIpAddressSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 primary: bool,
                 private_ip_address: str):
        """
        :param bool primary: Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.
        :param str private_ip_address: The private IPv4 addresses.
        """
        pulumi.set(__self__, "primary", primary)
        pulumi.set(__self__, "private_ip_address", private_ip_address)

    @property
    @pulumi.getter
    def primary(self) -> bool:
        """
        Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.
        """
        return pulumi.get(self, "primary")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> str:
        """
        The private IPv4 addresses.
        """
        return pulumi.get(self, "private_ip_address")


@pulumi.output_type
class InstanceSsmAssociation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "documentName":
            suggest = "document_name"
        elif key == "associationParameters":
            suggest = "association_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceSsmAssociation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceSsmAssociation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceSsmAssociation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 document_name: str,
                 association_parameters: Optional[Sequence['outputs.InstanceAssociationParameter']] = None):
        """
        :param str document_name: The name of an SSM document to associate with the instance.
        :param Sequence['InstanceAssociationParameter'] association_parameters: The input parameter values to use with the associated SSM document.
        """
        pulumi.set(__self__, "document_name", document_name)
        if association_parameters is not None:
            pulumi.set(__self__, "association_parameters", association_parameters)

    @property
    @pulumi.getter(name="documentName")
    def document_name(self) -> str:
        """
        The name of an SSM document to associate with the instance.
        """
        return pulumi.get(self, "document_name")

    @property
    @pulumi.getter(name="associationParameters")
    def association_parameters(self) -> Optional[Sequence['outputs.InstanceAssociationParameter']]:
        """
        The input parameter values to use with the associated SSM document.
        """
        return pulumi.get(self, "association_parameters")


@pulumi.output_type
class InstanceState(dict):
    """
    The current state of the instance
    """
    def __init__(__self__, *,
                 code: Optional[str] = None,
                 name: Optional[str] = None):
        """
        The current state of the instance
        :param str code: The state of the instance as a 16-bit unsigned integer.
        :param str name: The current state of the instance.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def code(self) -> Optional[str]:
        """
        The state of the instance as a 16-bit unsigned integer.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The current state of the instance.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class InstanceVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "volumeId":
            suggest = "volume_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device: str,
                 volume_id: str):
        """
        :param str device: The device name (for example, /dev/sdh or xvdh).
        :param str volume_id: The ID of the EBS volume. The volume and instance must be within the same Availability Zone.
        """
        pulumi.set(__self__, "device", device)
        pulumi.set(__self__, "volume_id", volume_id)

    @property
    @pulumi.getter
    def device(self) -> str:
        """
        The device name (for example, /dev/sdh or xvdh).
        """
        return pulumi.get(self, "device")

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> str:
        """
        The ID of the EBS volume. The volume and instance must be within the same Availability Zone.
        """
        return pulumi.get(self, "volume_id")


@pulumi.output_type
class IpamOperatingRegion(dict):
    """
    The regions IPAM is enabled for. Allows pools to be created in these regions, as well as enabling monitoring
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regionName":
            suggest = "region_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpamOperatingRegion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpamOperatingRegion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpamOperatingRegion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region_name: str):
        """
        The regions IPAM is enabled for. Allows pools to be created in these regions, as well as enabling monitoring
        :param str region_name: The name of the region.
        """
        pulumi.set(__self__, "region_name", region_name)

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> str:
        """
        The name of the region.
        """
        return pulumi.get(self, "region_name")


@pulumi.output_type
class IpamPoolProvisionedCidr(dict):
    """
    An address space to be inserted into this pool. All allocations must be made from this address space.
    """
    def __init__(__self__, *,
                 cidr: str):
        """
        An address space to be inserted into this pool. All allocations must be made from this address space.
        :param str cidr: The CIDR provisioned to the IPAM pool. A CIDR is a representation of an IP address and its associated network mask (or netmask) and refers to a range of IP addresses. An IPv4 CIDR example is `10.24.34.0/23` . An IPv6 CIDR example is `2001:DB8::/32` .
        """
        pulumi.set(__self__, "cidr", cidr)

    @property
    @pulumi.getter
    def cidr(self) -> str:
        """
        The CIDR provisioned to the IPAM pool. A CIDR is a representation of an IP address and its associated network mask (or netmask) and refers to a range of IP addresses. An IPv4 CIDR example is `10.24.34.0/23` . An IPv6 CIDR example is `2001:DB8::/32` .
        """
        return pulumi.get(self, "cidr")


@pulumi.output_type
class IpamPoolSourceResource(dict):
    """
    The resource associated with this pool's space. Depending on the ResourceType, setting a SourceResource changes which space can be provisioned in this pool and which types of resources can receive allocations
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceId":
            suggest = "resource_id"
        elif key == "resourceOwner":
            suggest = "resource_owner"
        elif key == "resourceRegion":
            suggest = "resource_region"
        elif key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpamPoolSourceResource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpamPoolSourceResource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpamPoolSourceResource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_id: str,
                 resource_owner: str,
                 resource_region: str,
                 resource_type: str):
        """
        The resource associated with this pool's space. Depending on the ResourceType, setting a SourceResource changes which space can be provisioned in this pool and which types of resources can receive allocations
        :param str resource_id: The source resource ID.
        :param str resource_owner: The source resource owner.
        :param str resource_region: The source resource Region.
        :param str resource_type: The source resource type.
        """
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_owner", resource_owner)
        pulumi.set(__self__, "resource_region", resource_region)
        pulumi.set(__self__, "resource_type", resource_type)

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> str:
        """
        The source resource ID.
        """
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter(name="resourceOwner")
    def resource_owner(self) -> str:
        """
        The source resource owner.
        """
        return pulumi.get(self, "resource_owner")

    @property
    @pulumi.getter(name="resourceRegion")
    def resource_region(self) -> str:
        """
        The source resource Region.
        """
        return pulumi.get(self, "resource_region")

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> str:
        """
        The source resource type.
        """
        return pulumi.get(self, "resource_type")


@pulumi.output_type
class IpamPoolTag(dict):
    """
    A key-value pair to associate with a resource.
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        A key-value pair to associate with a resource.
        :param str key: The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        :param str value: The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IpamResourceDiscoveryIpamOperatingRegion(dict):
    """
    The regions IPAM Resource Discovery is enabled for. Allows for monitoring.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regionName":
            suggest = "region_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpamResourceDiscoveryIpamOperatingRegion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpamResourceDiscoveryIpamOperatingRegion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpamResourceDiscoveryIpamOperatingRegion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region_name: str):
        """
        The regions IPAM Resource Discovery is enabled for. Allows for monitoring.
        :param str region_name: The name of the region.
        """
        pulumi.set(__self__, "region_name", region_name)

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> str:
        """
        The name of the region.
        """
        return pulumi.get(self, "region_name")


@pulumi.output_type
class LaunchTemplateAcceleratorCount(dict):
    """
    The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.
    """
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.
        :param int max: The maximum number of accelerators. To specify no maximum limit, omit this parameter. To exclude accelerator-enabled instance types, set ``Max`` to ``0``.
        :param int min: The minimum number of accelerators. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        The maximum number of accelerators. To specify no maximum limit, omit this parameter. To exclude accelerator-enabled instance types, set ``Max`` to ``0``.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        The minimum number of accelerators. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateAcceleratorTotalMemoryMiB(dict):
    """
    The minimum and maximum amount of total accelerator memory, in MiB.
    """
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        The minimum and maximum amount of total accelerator memory, in MiB.
        :param int max: The maximum amount of accelerator memory, in MiB. To specify no maximum limit, omit this parameter.
        :param int min: The minimum amount of accelerator memory, in MiB. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        The maximum amount of accelerator memory, in MiB. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        The minimum amount of accelerator memory, in MiB. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateBaselineEbsBandwidthMbps(dict):
    """
    The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see [Amazon EBSoptimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the *Amazon EC2 User Guide*.
    """
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see [Amazon EBSoptimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the *Amazon EC2 User Guide*.
        :param int max: The maximum baseline bandwidth, in Mbps. To specify no maximum limit, omit this parameter.
        :param int min: The minimum baseline bandwidth, in Mbps. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        The maximum baseline bandwidth, in Mbps. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        The minimum baseline bandwidth, in Mbps. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateBlockDeviceMapping(dict):
    """
    Specifies a block device mapping for a launch template. You must specify ``DeviceName`` plus exactly one of the following properties: ``Ebs``, ``NoDevice``, or ``VirtualName``.
      ``BlockDeviceMapping`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "noDevice":
            suggest = "no_device"
        elif key == "virtualName":
            suggest = "virtual_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateBlockDeviceMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateBlockDeviceMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateBlockDeviceMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: Optional[str] = None,
                 ebs: Optional['outputs.LaunchTemplateEbs'] = None,
                 no_device: Optional[str] = None,
                 virtual_name: Optional[str] = None):
        """
        Specifies a block device mapping for a launch template. You must specify ``DeviceName`` plus exactly one of the following properties: ``Ebs``, ``NoDevice``, or ``VirtualName``.
          ``BlockDeviceMapping`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        :param str device_name: The device name (for example, /dev/sdh or xvdh).
        :param 'LaunchTemplateEbs' ebs: Parameters used to automatically set up EBS volumes when the instance is launched.
        :param str no_device: To omit the device from the block device mapping, specify an empty string.
        :param str virtual_name: The virtual device name (ephemeralN). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for ephemeral0 and ephemeral1. The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.
        """
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if ebs is not None:
            pulumi.set(__self__, "ebs", ebs)
        if no_device is not None:
            pulumi.set(__self__, "no_device", no_device)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[str]:
        """
        The device name (for example, /dev/sdh or xvdh).
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter
    def ebs(self) -> Optional['outputs.LaunchTemplateEbs']:
        """
        Parameters used to automatically set up EBS volumes when the instance is launched.
        """
        return pulumi.get(self, "ebs")

    @property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[str]:
        """
        To omit the device from the block device mapping, specify an empty string.
        """
        return pulumi.get(self, "no_device")

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[str]:
        """
        The virtual device name (ephemeralN). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for ephemeral0 and ephemeral1. The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.
        """
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class LaunchTemplateCapacityReservationSpecification(dict):
    """
    Specifies an instance's Capacity Reservation targeting option. You can specify only one option at a time.
      ``CapacityReservationSpecification`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityReservationPreference":
            suggest = "capacity_reservation_preference"
        elif key == "capacityReservationTarget":
            suggest = "capacity_reservation_target"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateCapacityReservationSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateCapacityReservationSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateCapacityReservationSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_reservation_preference: Optional[str] = None,
                 capacity_reservation_target: Optional['outputs.LaunchTemplateCapacityReservationTarget'] = None):
        """
        Specifies an instance's Capacity Reservation targeting option. You can specify only one option at a time.
          ``CapacityReservationSpecification`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        :param str capacity_reservation_preference: Indicates the instance's Capacity Reservation preferences. Possible preferences include:
                 +   ``open`` - The instance can run in any ``open`` Capacity Reservation that has matching attributes (instance type, platform, Availability Zone).
                 +   ``none`` - The instance avoids running in a Capacity Reservation even if one is available. The instance runs in On-Demand capacity.
        :param 'LaunchTemplateCapacityReservationTarget' capacity_reservation_target: Information about the target Capacity Reservation or Capacity Reservation group.
        """
        if capacity_reservation_preference is not None:
            pulumi.set(__self__, "capacity_reservation_preference", capacity_reservation_preference)
        if capacity_reservation_target is not None:
            pulumi.set(__self__, "capacity_reservation_target", capacity_reservation_target)

    @property
    @pulumi.getter(name="capacityReservationPreference")
    def capacity_reservation_preference(self) -> Optional[str]:
        """
        Indicates the instance's Capacity Reservation preferences. Possible preferences include:
          +   ``open`` - The instance can run in any ``open`` Capacity Reservation that has matching attributes (instance type, platform, Availability Zone).
          +   ``none`` - The instance avoids running in a Capacity Reservation even if one is available. The instance runs in On-Demand capacity.
        """
        return pulumi.get(self, "capacity_reservation_preference")

    @property
    @pulumi.getter(name="capacityReservationTarget")
    def capacity_reservation_target(self) -> Optional['outputs.LaunchTemplateCapacityReservationTarget']:
        """
        Information about the target Capacity Reservation or Capacity Reservation group.
        """
        return pulumi.get(self, "capacity_reservation_target")


@pulumi.output_type
class LaunchTemplateCapacityReservationTarget(dict):
    """
    Specifies a target Capacity Reservation.
      ``CapacityReservationTarget`` is a property of the [Amazon EC2 LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html) property type.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityReservationId":
            suggest = "capacity_reservation_id"
        elif key == "capacityReservationResourceGroupArn":
            suggest = "capacity_reservation_resource_group_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateCapacityReservationTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateCapacityReservationTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateCapacityReservationTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_reservation_id: Optional[str] = None,
                 capacity_reservation_resource_group_arn: Optional[str] = None):
        """
        Specifies a target Capacity Reservation.
          ``CapacityReservationTarget`` is a property of the [Amazon EC2 LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html) property type.
        :param str capacity_reservation_id: The ID of the Capacity Reservation in which to run the instance.
        :param str capacity_reservation_resource_group_arn: The ARN of the Capacity Reservation resource group in which to run the instance.
        """
        if capacity_reservation_id is not None:
            pulumi.set(__self__, "capacity_reservation_id", capacity_reservation_id)
        if capacity_reservation_resource_group_arn is not None:
            pulumi.set(__self__, "capacity_reservation_resource_group_arn", capacity_reservation_resource_group_arn)

    @property
    @pulumi.getter(name="capacityReservationId")
    def capacity_reservation_id(self) -> Optional[str]:
        """
        The ID of the Capacity Reservation in which to run the instance.
        """
        return pulumi.get(self, "capacity_reservation_id")

    @property
    @pulumi.getter(name="capacityReservationResourceGroupArn")
    def capacity_reservation_resource_group_arn(self) -> Optional[str]:
        """
        The ARN of the Capacity Reservation resource group in which to run the instance.
        """
        return pulumi.get(self, "capacity_reservation_resource_group_arn")


@pulumi.output_type
class LaunchTemplateConnectionTrackingSpecification(dict):
    """
    A security group connection tracking specification that enables you to set the idle timeout for connection tracking on an Elastic network interface. For more information, see [Connection tracking timeouts](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-connection-tracking.html#connection-tracking-timeouts) in the *Amazon EC2 User Guide*.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tcpEstablishedTimeout":
            suggest = "tcp_established_timeout"
        elif key == "udpStreamTimeout":
            suggest = "udp_stream_timeout"
        elif key == "udpTimeout":
            suggest = "udp_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateConnectionTrackingSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateConnectionTrackingSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateConnectionTrackingSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tcp_established_timeout: Optional[int] = None,
                 udp_stream_timeout: Optional[int] = None,
                 udp_timeout: Optional[int] = None):
        """
        A security group connection tracking specification that enables you to set the idle timeout for connection tracking on an Elastic network interface. For more information, see [Connection tracking timeouts](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-connection-tracking.html#connection-tracking-timeouts) in the *Amazon EC2 User Guide*.
        :param int tcp_established_timeout: Timeout (in seconds) for idle TCP connections in an established state. Min: 60 seconds. Max: 432000 seconds (5 days). Default: 432000 seconds. Recommended: Less than 432000 seconds.
        :param int udp_stream_timeout: Timeout (in seconds) for idle UDP flows classified as streams which have seen more than one request-response transaction. Min: 60 seconds. Max: 180 seconds (3 minutes). Default: 180 seconds.
        :param int udp_timeout: Timeout (in seconds) for idle UDP flows that have seen traffic only in a single direction or a single request-response transaction. Min: 30 seconds. Max: 60 seconds. Default: 30 seconds.
        """
        if tcp_established_timeout is not None:
            pulumi.set(__self__, "tcp_established_timeout", tcp_established_timeout)
        if udp_stream_timeout is not None:
            pulumi.set(__self__, "udp_stream_timeout", udp_stream_timeout)
        if udp_timeout is not None:
            pulumi.set(__self__, "udp_timeout", udp_timeout)

    @property
    @pulumi.getter(name="tcpEstablishedTimeout")
    def tcp_established_timeout(self) -> Optional[int]:
        """
        Timeout (in seconds) for idle TCP connections in an established state. Min: 60 seconds. Max: 432000 seconds (5 days). Default: 432000 seconds. Recommended: Less than 432000 seconds.
        """
        return pulumi.get(self, "tcp_established_timeout")

    @property
    @pulumi.getter(name="udpStreamTimeout")
    def udp_stream_timeout(self) -> Optional[int]:
        """
        Timeout (in seconds) for idle UDP flows classified as streams which have seen more than one request-response transaction. Min: 60 seconds. Max: 180 seconds (3 minutes). Default: 180 seconds.
        """
        return pulumi.get(self, "udp_stream_timeout")

    @property
    @pulumi.getter(name="udpTimeout")
    def udp_timeout(self) -> Optional[int]:
        """
        Timeout (in seconds) for idle UDP flows that have seen traffic only in a single direction or a single request-response transaction. Min: 30 seconds. Max: 60 seconds. Default: 30 seconds.
        """
        return pulumi.get(self, "udp_timeout")


@pulumi.output_type
class LaunchTemplateCpuOptions(dict):
    """
    Specifies the CPU options for an instance. For more information, see [Optimize CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the *User Guide*.
      ``CpuOptions`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "amdSevSnp":
            suggest = "amd_sev_snp"
        elif key == "coreCount":
            suggest = "core_count"
        elif key == "threadsPerCore":
            suggest = "threads_per_core"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateCpuOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateCpuOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateCpuOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amd_sev_snp: Optional['LaunchTemplateCpuOptionsAmdSevSnp'] = None,
                 core_count: Optional[int] = None,
                 threads_per_core: Optional[int] = None):
        """
        Specifies the CPU options for an instance. For more information, see [Optimize CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the *User Guide*.
          ``CpuOptions`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        :param 'LaunchTemplateCpuOptionsAmdSevSnp' amd_sev_snp: Indicates whether to enable the instance for AMD SEV-SNP. AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only. For more information, see [AMD SEV-SNP](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/sev-snp.html).
        :param int core_count: The number of CPU cores for the instance.
        :param int threads_per_core: The number of threads per CPU core. To disable multithreading for the instance, specify a value of ``1``. Otherwise, specify the default value of ``2``.
        """
        if amd_sev_snp is not None:
            pulumi.set(__self__, "amd_sev_snp", amd_sev_snp)
        if core_count is not None:
            pulumi.set(__self__, "core_count", core_count)
        if threads_per_core is not None:
            pulumi.set(__self__, "threads_per_core", threads_per_core)

    @property
    @pulumi.getter(name="amdSevSnp")
    def amd_sev_snp(self) -> Optional['LaunchTemplateCpuOptionsAmdSevSnp']:
        """
        Indicates whether to enable the instance for AMD SEV-SNP. AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only. For more information, see [AMD SEV-SNP](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/sev-snp.html).
        """
        return pulumi.get(self, "amd_sev_snp")

    @property
    @pulumi.getter(name="coreCount")
    def core_count(self) -> Optional[int]:
        """
        The number of CPU cores for the instance.
        """
        return pulumi.get(self, "core_count")

    @property
    @pulumi.getter(name="threadsPerCore")
    def threads_per_core(self) -> Optional[int]:
        """
        The number of threads per CPU core. To disable multithreading for the instance, specify a value of ``1``. Otherwise, specify the default value of ``2``.
        """
        return pulumi.get(self, "threads_per_core")


@pulumi.output_type
class LaunchTemplateCreditSpecification(dict):
    """
    Specifies the credit option for CPU usage of a T2, T3, or T3a instance.
      ``CreditSpecification`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuCredits":
            suggest = "cpu_credits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateCreditSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateCreditSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateCreditSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_credits: Optional[str] = None):
        """
        Specifies the credit option for CPU usage of a T2, T3, or T3a instance.
          ``CreditSpecification`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        :param str cpu_credits: The credit option for CPU usage of a T instance.
                Valid values: ``standard`` | ``unlimited``
        """
        if cpu_credits is not None:
            pulumi.set(__self__, "cpu_credits", cpu_credits)

    @property
    @pulumi.getter(name="cpuCredits")
    def cpu_credits(self) -> Optional[str]:
        """
        The credit option for CPU usage of a T instance.
         Valid values: ``standard`` | ``unlimited``
        """
        return pulumi.get(self, "cpu_credits")


@pulumi.output_type
class LaunchTemplateData(dict):
    """
    The information to include in the launch template.
      You must specify at least one parameter for the launch template data.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockDeviceMappings":
            suggest = "block_device_mappings"
        elif key == "capacityReservationSpecification":
            suggest = "capacity_reservation_specification"
        elif key == "cpuOptions":
            suggest = "cpu_options"
        elif key == "creditSpecification":
            suggest = "credit_specification"
        elif key == "disableApiStop":
            suggest = "disable_api_stop"
        elif key == "disableApiTermination":
            suggest = "disable_api_termination"
        elif key == "ebsOptimized":
            suggest = "ebs_optimized"
        elif key == "elasticGpuSpecifications":
            suggest = "elastic_gpu_specifications"
        elif key == "elasticInferenceAccelerators":
            suggest = "elastic_inference_accelerators"
        elif key == "enclaveOptions":
            suggest = "enclave_options"
        elif key == "hibernationOptions":
            suggest = "hibernation_options"
        elif key == "iamInstanceProfile":
            suggest = "iam_instance_profile"
        elif key == "imageId":
            suggest = "image_id"
        elif key == "instanceInitiatedShutdownBehavior":
            suggest = "instance_initiated_shutdown_behavior"
        elif key == "instanceMarketOptions":
            suggest = "instance_market_options"
        elif key == "instanceRequirements":
            suggest = "instance_requirements"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "kernelId":
            suggest = "kernel_id"
        elif key == "keyName":
            suggest = "key_name"
        elif key == "licenseSpecifications":
            suggest = "license_specifications"
        elif key == "maintenanceOptions":
            suggest = "maintenance_options"
        elif key == "metadataOptions":
            suggest = "metadata_options"
        elif key == "networkInterfaces":
            suggest = "network_interfaces"
        elif key == "privateDnsNameOptions":
            suggest = "private_dns_name_options"
        elif key == "ramDiskId":
            suggest = "ram_disk_id"
        elif key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "securityGroups":
            suggest = "security_groups"
        elif key == "tagSpecifications":
            suggest = "tag_specifications"
        elif key == "userData":
            suggest = "user_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 block_device_mappings: Optional[Sequence['outputs.LaunchTemplateBlockDeviceMapping']] = None,
                 capacity_reservation_specification: Optional['outputs.LaunchTemplateCapacityReservationSpecification'] = None,
                 cpu_options: Optional['outputs.LaunchTemplateCpuOptions'] = None,
                 credit_specification: Optional['outputs.LaunchTemplateCreditSpecification'] = None,
                 disable_api_stop: Optional[bool] = None,
                 disable_api_termination: Optional[bool] = None,
                 ebs_optimized: Optional[bool] = None,
                 elastic_gpu_specifications: Optional[Sequence['outputs.LaunchTemplateElasticGpuSpecification']] = None,
                 elastic_inference_accelerators: Optional[Sequence['outputs.LaunchTemplateElasticInferenceAccelerator']] = None,
                 enclave_options: Optional['outputs.LaunchTemplateEnclaveOptions'] = None,
                 hibernation_options: Optional['outputs.LaunchTemplateHibernationOptions'] = None,
                 iam_instance_profile: Optional['outputs.LaunchTemplateIamInstanceProfile'] = None,
                 image_id: Optional[str] = None,
                 instance_initiated_shutdown_behavior: Optional[str] = None,
                 instance_market_options: Optional['outputs.LaunchTemplateInstanceMarketOptions'] = None,
                 instance_requirements: Optional['outputs.LaunchTemplateInstanceRequirements'] = None,
                 instance_type: Optional[str] = None,
                 kernel_id: Optional[str] = None,
                 key_name: Optional[str] = None,
                 license_specifications: Optional[Sequence['outputs.LaunchTemplateLicenseSpecification']] = None,
                 maintenance_options: Optional['outputs.LaunchTemplateMaintenanceOptions'] = None,
                 metadata_options: Optional['outputs.LaunchTemplateMetadataOptions'] = None,
                 monitoring: Optional['outputs.LaunchTemplateMonitoring'] = None,
                 network_interfaces: Optional[Sequence['outputs.LaunchTemplateNetworkInterface']] = None,
                 placement: Optional['outputs.LaunchTemplatePlacement'] = None,
                 private_dns_name_options: Optional['outputs.LaunchTemplatePrivateDnsNameOptions'] = None,
                 ram_disk_id: Optional[str] = None,
                 security_group_ids: Optional[Sequence[str]] = None,
                 security_groups: Optional[Sequence[str]] = None,
                 tag_specifications: Optional[Sequence['outputs.TagSpecification']] = None,
                 user_data: Optional[str] = None):
        """
        The information to include in the launch template.
          You must specify at least one parameter for the launch template data.
        :param Sequence['LaunchTemplateBlockDeviceMapping'] block_device_mappings: The block device mapping.
        :param 'LaunchTemplateCapacityReservationSpecification' capacity_reservation_specification: The Capacity Reservation targeting option. If you do not specify this parameter, the instance's Capacity Reservation preference defaults to ``open``, which enables it to run in any open Capacity Reservation that has matching attributes (instance type, platform, Availability Zone).
        :param 'LaunchTemplateCpuOptions' cpu_options: The CPU options for the instance. For more information, see [Optimize CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the *Amazon EC2 User Guide*.
        :param 'LaunchTemplateCreditSpecification' credit_specification: The credit option for CPU usage of the instance. Valid only for T instances.
        :param bool disable_api_stop: Indicates whether to enable the instance for stop protection. For more information, see [Enable stop protection for your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-stop-protection.html) in the *Amazon EC2 User Guide*.
        :param bool disable_api_termination: If you set this parameter to ``true``, you can't terminate the instance using the Amazon EC2 console, CLI, or API; otherwise, you can. To change this attribute after launch, use [ModifyInstanceAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceAttribute.html). Alternatively, if you set ``InstanceInitiatedShutdownBehavior`` to ``terminate``, you can terminate the instance by running the shutdown command from the instance.
        :param bool ebs_optimized: Indicates whether the instance is optimized for Amazon EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.
        :param Sequence['LaunchTemplateElasticGpuSpecification'] elastic_gpu_specifications: Deprecated.
                 Amazon Elastic Graphics reached end of life on January 8, 2024. For workloads that require graphics acceleration, we recommend that you use Amazon EC2 G4ad, G4dn, or G5 instances.
        :param Sequence['LaunchTemplateElasticInferenceAccelerator'] elastic_inference_accelerators: An elastic inference accelerator to associate with the instance. Elastic inference accelerators are a resource you can attach to your Amazon EC2 instances to accelerate your Deep Learning (DL) inference workloads.
                You cannot specify accelerators from different generations in the same request.
                 Starting April 15, 2023, AWS will not onboard new customers to Amazon Elastic Inference (EI), and will help current customers migrate their workloads to options that offer better price and performance. After April 15, 2023, new customers will not be able to launch instances with Amazon EI accelerators in Amazon SageMaker, Amazon ECS, or Amazon EC2. However, customers who have used Amazon EI at least once during the past 30-day period are considered current customers and will be able to continue using the service.
        :param 'LaunchTemplateEnclaveOptions' enclave_options: Indicates whether the instance is enabled for AWS Nitro Enclaves. For more information, see [What is Nitro Enclaves?](https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html) in the *Nitro Enclaves User Guide*.
                You can't enable AWS Nitro Enclaves and hibernation on the same instance.
        :param 'LaunchTemplateHibernationOptions' hibernation_options: Indicates whether an instance is enabled for hibernation. This parameter is valid only if the instance meets the [hibernation prerequisites](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/hibernating-prerequisites.html). For more information, see [Hibernate your Amazon EC2 instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html) in the *Amazon EC2 User Guide*.
        :param 'LaunchTemplateIamInstanceProfile' iam_instance_profile: The name or Amazon Resource Name (ARN) of an IAM instance profile.
        :param str image_id: The ID of the AMI. Alternatively, you can specify a Systems Manager parameter, which will resolve to an AMI ID on launch.
                Valid formats:
                 +   ``ami-0ac394d6a3example`` 
                 +   ``resolve:ssm:parameter-name`` 
                 +   ``resolve:ssm:parameter-name:version-number`` 
                 +   ``resolve:ssm:parameter-name:label`` 
                 
                For more information, see [Use a Systems Manager parameter to find an AMI](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/finding-an-ami.html#using-systems-manager-parameter-to-find-AMI) in the *Amazon Elastic Compute Cloud User Guide*.
        :param str instance_initiated_shutdown_behavior: Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
                Default: ``stop``
        :param 'LaunchTemplateInstanceMarketOptions' instance_market_options: The market (purchasing) option for the instances.
        :param 'LaunchTemplateInstanceRequirements' instance_requirements: The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with these attributes.
                You must specify ``VCpuCount`` and ``MemoryMiB``. All other attributes are optional. Any unspecified optional attribute is set to its default.
                When you specify multiple attributes, you get instance types that satisfy all of the specified attributes. If you specify multiple values for an attribute, you get instance types that satisfy any of the specified values.
                To limit the list of instance types from which Amazon EC2 can identify matching instance types, you can use one of the following parameters, but not both in the same request:
                 +   ``AllowedInstanceTypes`` - The instance types to include in the list. All other instance types are ignored, even if they match your specified attributes.
                 +   ``ExcludedInstanceTypes`` - The instance types to exclude from the list, even if they match your specified attributes.
                 
                 If you specify ``InstanceRequirements``, you can't specify ``InstanceType``.
                Attribute-based instance type selection is only supported when using Auto Scaling groups, EC2 Fleet, and Spot Fleet to launch instances. If you plan to use the launch template in the [launch instance wizard](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-instance-wizard.html), or with the [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) API or [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) AWS CloudFormation resource, you can't specify ``InstanceRequirements``.
                 For more information, see [Attribute-based instance type selection for EC2 Fleet](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html), [Attribute-based instance type selection for Spot Fleet](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-attribute-based-instance-type-selection.html), and [Spot placement score](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html) in the *Amazon EC2 User Guide*.
        :param str instance_type: The instance type. For more information, see [Amazon EC2 instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide*.
                If you specify ``InstanceType``, you can't specify ``InstanceRequirements``.
        :param str kernel_id: The ID of the kernel.
                We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [User Provided Kernels](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide*.
        :param str key_name: The name of the key pair. You can create a key pair using [CreateKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html) or [ImportKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html).
                 If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.
        :param Sequence['LaunchTemplateLicenseSpecification'] license_specifications: The license configurations.
        :param 'LaunchTemplateMaintenanceOptions' maintenance_options: The maintenance options of your instance.
        :param 'LaunchTemplateMetadataOptions' metadata_options: The metadata options for the instance. For more information, see [Instance metadata and user data](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html) in the *Amazon EC2 User Guide*.
        :param 'LaunchTemplateMonitoring' monitoring: The monitoring for the instance.
        :param Sequence['LaunchTemplateNetworkInterface'] network_interfaces: The network interfaces for the instance.
        :param 'LaunchTemplatePlacement' placement: The placement for the instance.
        :param 'LaunchTemplatePrivateDnsNameOptions' private_dns_name_options: The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries should be handled. For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *User Guide*.
        :param str ram_disk_id: The ID of the RAM disk.
                 We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [User provided kernels](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide*.
        :param Sequence[str] security_group_ids: The IDs of the security groups. You can specify the IDs of existing security groups and references to resources created by the stack template.
                If you specify a network interface, you must specify any security groups as part of the network interface instead.
        :param Sequence[str] security_groups: The names of the security groups. For a nondefault VPC, you must use security group IDs instead.
                If you specify a network interface, you must specify any security groups as part of the network interface instead of using this parameter.
        :param Sequence['TagSpecification'] tag_specifications: The tags to apply to the resources that are created during instance launch.
                To tag a resource after it has been created, see [CreateTags](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html).
                To tag the launch template itself, use [TagSpecifications](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#cfn-ec2-launchtemplate-tagspecifications).
        :param str user_data: The user data to make available to the instance. You must provide base64-encoded text. User data is limited to 16 KB. For more information, see [Run commands on your Amazon EC2 instance at launch](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html) in the *Amazon EC2 User Guide*.
                If you are creating the launch template for use with BATCH, the user data must be provided in the [MIME multi-part archive format](https://docs.aws.amazon.com/https://cloudinit.readthedocs.io/en/latest/topics/format.html#mime-multi-part-archive). For more information, see [Amazon EC2 user data in launch templates](https://docs.aws.amazon.com/batch/latest/userguide/launch-templates.html) in the *User Guide*.
        """
        if block_device_mappings is not None:
            pulumi.set(__self__, "block_device_mappings", block_device_mappings)
        if capacity_reservation_specification is not None:
            pulumi.set(__self__, "capacity_reservation_specification", capacity_reservation_specification)
        if cpu_options is not None:
            pulumi.set(__self__, "cpu_options", cpu_options)
        if credit_specification is not None:
            pulumi.set(__self__, "credit_specification", credit_specification)
        if disable_api_stop is not None:
            pulumi.set(__self__, "disable_api_stop", disable_api_stop)
        if disable_api_termination is not None:
            pulumi.set(__self__, "disable_api_termination", disable_api_termination)
        if ebs_optimized is not None:
            pulumi.set(__self__, "ebs_optimized", ebs_optimized)
        if elastic_gpu_specifications is not None:
            pulumi.set(__self__, "elastic_gpu_specifications", elastic_gpu_specifications)
        if elastic_inference_accelerators is not None:
            pulumi.set(__self__, "elastic_inference_accelerators", elastic_inference_accelerators)
        if enclave_options is not None:
            pulumi.set(__self__, "enclave_options", enclave_options)
        if hibernation_options is not None:
            pulumi.set(__self__, "hibernation_options", hibernation_options)
        if iam_instance_profile is not None:
            pulumi.set(__self__, "iam_instance_profile", iam_instance_profile)
        if image_id is not None:
            pulumi.set(__self__, "image_id", image_id)
        if instance_initiated_shutdown_behavior is not None:
            pulumi.set(__self__, "instance_initiated_shutdown_behavior", instance_initiated_shutdown_behavior)
        if instance_market_options is not None:
            pulumi.set(__self__, "instance_market_options", instance_market_options)
        if instance_requirements is not None:
            pulumi.set(__self__, "instance_requirements", instance_requirements)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if kernel_id is not None:
            pulumi.set(__self__, "kernel_id", kernel_id)
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if license_specifications is not None:
            pulumi.set(__self__, "license_specifications", license_specifications)
        if maintenance_options is not None:
            pulumi.set(__self__, "maintenance_options", maintenance_options)
        if metadata_options is not None:
            pulumi.set(__self__, "metadata_options", metadata_options)
        if monitoring is not None:
            pulumi.set(__self__, "monitoring", monitoring)
        if network_interfaces is not None:
            pulumi.set(__self__, "network_interfaces", network_interfaces)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if private_dns_name_options is not None:
            pulumi.set(__self__, "private_dns_name_options", private_dns_name_options)
        if ram_disk_id is not None:
            pulumi.set(__self__, "ram_disk_id", ram_disk_id)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if tag_specifications is not None:
            pulumi.set(__self__, "tag_specifications", tag_specifications)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)

    @property
    @pulumi.getter(name="blockDeviceMappings")
    def block_device_mappings(self) -> Optional[Sequence['outputs.LaunchTemplateBlockDeviceMapping']]:
        """
        The block device mapping.
        """
        return pulumi.get(self, "block_device_mappings")

    @property
    @pulumi.getter(name="capacityReservationSpecification")
    def capacity_reservation_specification(self) -> Optional['outputs.LaunchTemplateCapacityReservationSpecification']:
        """
        The Capacity Reservation targeting option. If you do not specify this parameter, the instance's Capacity Reservation preference defaults to ``open``, which enables it to run in any open Capacity Reservation that has matching attributes (instance type, platform, Availability Zone).
        """
        return pulumi.get(self, "capacity_reservation_specification")

    @property
    @pulumi.getter(name="cpuOptions")
    def cpu_options(self) -> Optional['outputs.LaunchTemplateCpuOptions']:
        """
        The CPU options for the instance. For more information, see [Optimize CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the *Amazon EC2 User Guide*.
        """
        return pulumi.get(self, "cpu_options")

    @property
    @pulumi.getter(name="creditSpecification")
    def credit_specification(self) -> Optional['outputs.LaunchTemplateCreditSpecification']:
        """
        The credit option for CPU usage of the instance. Valid only for T instances.
        """
        return pulumi.get(self, "credit_specification")

    @property
    @pulumi.getter(name="disableApiStop")
    def disable_api_stop(self) -> Optional[bool]:
        """
        Indicates whether to enable the instance for stop protection. For more information, see [Enable stop protection for your instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-stop-protection.html) in the *Amazon EC2 User Guide*.
        """
        return pulumi.get(self, "disable_api_stop")

    @property
    @pulumi.getter(name="disableApiTermination")
    def disable_api_termination(self) -> Optional[bool]:
        """
        If you set this parameter to ``true``, you can't terminate the instance using the Amazon EC2 console, CLI, or API; otherwise, you can. To change this attribute after launch, use [ModifyInstanceAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceAttribute.html). Alternatively, if you set ``InstanceInitiatedShutdownBehavior`` to ``terminate``, you can terminate the instance by running the shutdown command from the instance.
        """
        return pulumi.get(self, "disable_api_termination")

    @property
    @pulumi.getter(name="ebsOptimized")
    def ebs_optimized(self) -> Optional[bool]:
        """
        Indicates whether the instance is optimized for Amazon EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.
        """
        return pulumi.get(self, "ebs_optimized")

    @property
    @pulumi.getter(name="elasticGpuSpecifications")
    def elastic_gpu_specifications(self) -> Optional[Sequence['outputs.LaunchTemplateElasticGpuSpecification']]:
        """
        Deprecated.
          Amazon Elastic Graphics reached end of life on January 8, 2024. For workloads that require graphics acceleration, we recommend that you use Amazon EC2 G4ad, G4dn, or G5 instances.
        """
        return pulumi.get(self, "elastic_gpu_specifications")

    @property
    @pulumi.getter(name="elasticInferenceAccelerators")
    def elastic_inference_accelerators(self) -> Optional[Sequence['outputs.LaunchTemplateElasticInferenceAccelerator']]:
        """
        An elastic inference accelerator to associate with the instance. Elastic inference accelerators are a resource you can attach to your Amazon EC2 instances to accelerate your Deep Learning (DL) inference workloads.
         You cannot specify accelerators from different generations in the same request.
          Starting April 15, 2023, AWS will not onboard new customers to Amazon Elastic Inference (EI), and will help current customers migrate their workloads to options that offer better price and performance. After April 15, 2023, new customers will not be able to launch instances with Amazon EI accelerators in Amazon SageMaker, Amazon ECS, or Amazon EC2. However, customers who have used Amazon EI at least once during the past 30-day period are considered current customers and will be able to continue using the service.
        """
        return pulumi.get(self, "elastic_inference_accelerators")

    @property
    @pulumi.getter(name="enclaveOptions")
    def enclave_options(self) -> Optional['outputs.LaunchTemplateEnclaveOptions']:
        """
        Indicates whether the instance is enabled for AWS Nitro Enclaves. For more information, see [What is Nitro Enclaves?](https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html) in the *Nitro Enclaves User Guide*.
         You can't enable AWS Nitro Enclaves and hibernation on the same instance.
        """
        return pulumi.get(self, "enclave_options")

    @property
    @pulumi.getter(name="hibernationOptions")
    def hibernation_options(self) -> Optional['outputs.LaunchTemplateHibernationOptions']:
        """
        Indicates whether an instance is enabled for hibernation. This parameter is valid only if the instance meets the [hibernation prerequisites](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/hibernating-prerequisites.html). For more information, see [Hibernate your Amazon EC2 instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html) in the *Amazon EC2 User Guide*.
        """
        return pulumi.get(self, "hibernation_options")

    @property
    @pulumi.getter(name="iamInstanceProfile")
    def iam_instance_profile(self) -> Optional['outputs.LaunchTemplateIamInstanceProfile']:
        """
        The name or Amazon Resource Name (ARN) of an IAM instance profile.
        """
        return pulumi.get(self, "iam_instance_profile")

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> Optional[str]:
        """
        The ID of the AMI. Alternatively, you can specify a Systems Manager parameter, which will resolve to an AMI ID on launch.
         Valid formats:
          +   ``ami-0ac394d6a3example`` 
          +   ``resolve:ssm:parameter-name`` 
          +   ``resolve:ssm:parameter-name:version-number`` 
          +   ``resolve:ssm:parameter-name:label`` 
          
         For more information, see [Use a Systems Manager parameter to find an AMI](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/finding-an-ami.html#using-systems-manager-parameter-to-find-AMI) in the *Amazon Elastic Compute Cloud User Guide*.
        """
        return pulumi.get(self, "image_id")

    @property
    @pulumi.getter(name="instanceInitiatedShutdownBehavior")
    def instance_initiated_shutdown_behavior(self) -> Optional[str]:
        """
        Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
         Default: ``stop``
        """
        return pulumi.get(self, "instance_initiated_shutdown_behavior")

    @property
    @pulumi.getter(name="instanceMarketOptions")
    def instance_market_options(self) -> Optional['outputs.LaunchTemplateInstanceMarketOptions']:
        """
        The market (purchasing) option for the instances.
        """
        return pulumi.get(self, "instance_market_options")

    @property
    @pulumi.getter(name="instanceRequirements")
    def instance_requirements(self) -> Optional['outputs.LaunchTemplateInstanceRequirements']:
        """
        The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with these attributes.
         You must specify ``VCpuCount`` and ``MemoryMiB``. All other attributes are optional. Any unspecified optional attribute is set to its default.
         When you specify multiple attributes, you get instance types that satisfy all of the specified attributes. If you specify multiple values for an attribute, you get instance types that satisfy any of the specified values.
         To limit the list of instance types from which Amazon EC2 can identify matching instance types, you can use one of the following parameters, but not both in the same request:
          +   ``AllowedInstanceTypes`` - The instance types to include in the list. All other instance types are ignored, even if they match your specified attributes.
          +   ``ExcludedInstanceTypes`` - The instance types to exclude from the list, even if they match your specified attributes.
          
          If you specify ``InstanceRequirements``, you can't specify ``InstanceType``.
         Attribute-based instance type selection is only supported when using Auto Scaling groups, EC2 Fleet, and Spot Fleet to launch instances. If you plan to use the launch template in the [launch instance wizard](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-instance-wizard.html), or with the [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) API or [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) AWS CloudFormation resource, you can't specify ``InstanceRequirements``.
          For more information, see [Attribute-based instance type selection for EC2 Fleet](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html), [Attribute-based instance type selection for Spot Fleet](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-attribute-based-instance-type-selection.html), and [Spot placement score](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html) in the *Amazon EC2 User Guide*.
        """
        return pulumi.get(self, "instance_requirements")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[str]:
        """
        The instance type. For more information, see [Amazon EC2 instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide*.
         If you specify ``InstanceType``, you can't specify ``InstanceRequirements``.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="kernelId")
    def kernel_id(self) -> Optional[str]:
        """
        The ID of the kernel.
         We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [User Provided Kernels](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide*.
        """
        return pulumi.get(self, "kernel_id")

    @property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[str]:
        """
        The name of the key pair. You can create a key pair using [CreateKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html) or [ImportKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html).
          If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.
        """
        return pulumi.get(self, "key_name")

    @property
    @pulumi.getter(name="licenseSpecifications")
    def license_specifications(self) -> Optional[Sequence['outputs.LaunchTemplateLicenseSpecification']]:
        """
        The license configurations.
        """
        return pulumi.get(self, "license_specifications")

    @property
    @pulumi.getter(name="maintenanceOptions")
    def maintenance_options(self) -> Optional['outputs.LaunchTemplateMaintenanceOptions']:
        """
        The maintenance options of your instance.
        """
        return pulumi.get(self, "maintenance_options")

    @property
    @pulumi.getter(name="metadataOptions")
    def metadata_options(self) -> Optional['outputs.LaunchTemplateMetadataOptions']:
        """
        The metadata options for the instance. For more information, see [Instance metadata and user data](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html) in the *Amazon EC2 User Guide*.
        """
        return pulumi.get(self, "metadata_options")

    @property
    @pulumi.getter
    def monitoring(self) -> Optional['outputs.LaunchTemplateMonitoring']:
        """
        The monitoring for the instance.
        """
        return pulumi.get(self, "monitoring")

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Optional[Sequence['outputs.LaunchTemplateNetworkInterface']]:
        """
        The network interfaces for the instance.
        """
        return pulumi.get(self, "network_interfaces")

    @property
    @pulumi.getter
    def placement(self) -> Optional['outputs.LaunchTemplatePlacement']:
        """
        The placement for the instance.
        """
        return pulumi.get(self, "placement")

    @property
    @pulumi.getter(name="privateDnsNameOptions")
    def private_dns_name_options(self) -> Optional['outputs.LaunchTemplatePrivateDnsNameOptions']:
        """
        The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries should be handled. For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *User Guide*.
        """
        return pulumi.get(self, "private_dns_name_options")

    @property
    @pulumi.getter(name="ramDiskId")
    def ram_disk_id(self) -> Optional[str]:
        """
        The ID of the RAM disk.
          We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [User provided kernels](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide*.
        """
        return pulumi.get(self, "ram_disk_id")

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[str]]:
        """
        The IDs of the security groups. You can specify the IDs of existing security groups and references to resources created by the stack template.
         If you specify a network interface, you must specify any security groups as part of the network interface instead.
        """
        return pulumi.get(self, "security_group_ids")

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[str]]:
        """
        The names of the security groups. For a nondefault VPC, you must use security group IDs instead.
         If you specify a network interface, you must specify any security groups as part of the network interface instead of using this parameter.
        """
        return pulumi.get(self, "security_groups")

    @property
    @pulumi.getter(name="tagSpecifications")
    def tag_specifications(self) -> Optional[Sequence['outputs.TagSpecification']]:
        """
        The tags to apply to the resources that are created during instance launch.
         To tag a resource after it has been created, see [CreateTags](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html).
         To tag the launch template itself, use [TagSpecifications](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#cfn-ec2-launchtemplate-tagspecifications).
        """
        return pulumi.get(self, "tag_specifications")

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[str]:
        """
        The user data to make available to the instance. You must provide base64-encoded text. User data is limited to 16 KB. For more information, see [Run commands on your Amazon EC2 instance at launch](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html) in the *Amazon EC2 User Guide*.
         If you are creating the launch template for use with BATCH, the user data must be provided in the [MIME multi-part archive format](https://docs.aws.amazon.com/https://cloudinit.readthedocs.io/en/latest/topics/format.html#mime-multi-part-archive). For more information, see [Amazon EC2 user data in launch templates](https://docs.aws.amazon.com/batch/latest/userguide/launch-templates.html) in the *User Guide*.
        """
        return pulumi.get(self, "user_data")


@pulumi.output_type
class LaunchTemplateEbs(dict):
    """
    Parameters for a block device for an EBS volume in an Amazon EC2 launch template.
      ``Ebs`` is a property of [AWS::EC2::LaunchTemplate BlockDeviceMapping](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping.html).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateEbs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateEbs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateEbs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_on_termination: Optional[bool] = None,
                 encrypted: Optional[bool] = None,
                 iops: Optional[int] = None,
                 kms_key_id: Optional[str] = None,
                 snapshot_id: Optional[str] = None,
                 throughput: Optional[int] = None,
                 volume_size: Optional[int] = None,
                 volume_type: Optional[str] = None):
        """
        Parameters for a block device for an EBS volume in an Amazon EC2 launch template.
          ``Ebs`` is a property of [AWS::EC2::LaunchTemplate BlockDeviceMapping](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping.html).
        :param bool delete_on_termination: Indicates whether the EBS volume is deleted on instance termination.
        :param bool encrypted: Indicates whether the EBS volume is encrypted. Encrypted volumes can only be attached to instances that support Amazon EBS encryption. If you are creating a volume from a snapshot, you can't specify an encryption value.
        :param int iops: The number of I/O operations per second (IOPS). For ``gp3``, ``io1``, and ``io2`` volumes, this represents the number of IOPS that are provisioned for the volume. For ``gp2`` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.
                The following are the supported values for each volume type:
                 +   ``gp3``: 3,000 - 16,000 IOPS
                 +   ``io1``: 100 - 64,000 IOPS
                 +   ``io2``: 100 - 256,000 IOPS
                 
                For ``io2`` volumes, you can achieve up to 256,000 IOPS on [instances built on the Nitro System](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances). On other instances, you can achieve performance up to 32,000 IOPS.
                This parameter is supported for ``io1``, ``io2``, and ``gp3`` volumes only.
        :param str kms_key_id: The ARN of the symmetric KMSlong (KMS) CMK used for encryption.
        :param str snapshot_id: The ID of the snapshot.
        :param int throughput: The throughput to provision for a ``gp3`` volume, with a maximum of 1,000 MiB/s.
                Valid Range: Minimum value of 125. Maximum value of 1000.
        :param int volume_size: The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. The following are the supported volumes sizes for each volume type:
                 +   ``gp2`` and ``gp3``: 1 - 16,384 GiB
                 +   ``io1``: 4 - 16,384 GiB
                 +   ``io2``: 4 - 65,536 GiB
                 +   ``st1`` and ``sc1``: 125 - 16,384 GiB
                 +   ``standard``: 1 - 1024 GiB
        :param str volume_type: The volume type. For more information, see [Amazon EBS volume types](https://docs.aws.amazon.com/ebs/latest/userguide/ebs-volume-types.html) in the *Amazon EBS User Guide*.
        """
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[bool]:
        """
        Indicates whether the EBS volume is deleted on instance termination.
        """
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[bool]:
        """
        Indicates whether the EBS volume is encrypted. Encrypted volumes can only be attached to instances that support Amazon EBS encryption. If you are creating a volume from a snapshot, you can't specify an encryption value.
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        """
        The number of I/O operations per second (IOPS). For ``gp3``, ``io1``, and ``io2`` volumes, this represents the number of IOPS that are provisioned for the volume. For ``gp2`` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.
         The following are the supported values for each volume type:
          +   ``gp3``: 3,000 - 16,000 IOPS
          +   ``io1``: 100 - 64,000 IOPS
          +   ``io2``: 100 - 256,000 IOPS
          
         For ``io2`` volumes, you can achieve up to 256,000 IOPS on [instances built on the Nitro System](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances). On other instances, you can achieve performance up to 32,000 IOPS.
         This parameter is supported for ``io1``, ``io2``, and ``gp3`` volumes only.
        """
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        The ARN of the symmetric KMSlong (KMS) CMK used for encryption.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        """
        The ID of the snapshot.
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter
    def throughput(self) -> Optional[int]:
        """
        The throughput to provision for a ``gp3`` volume, with a maximum of 1,000 MiB/s.
         Valid Range: Minimum value of 125. Maximum value of 1000.
        """
        return pulumi.get(self, "throughput")

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[int]:
        """
        The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. The following are the supported volumes sizes for each volume type:
          +   ``gp2`` and ``gp3``: 1 - 16,384 GiB
          +   ``io1``: 4 - 16,384 GiB
          +   ``io2``: 4 - 65,536 GiB
          +   ``st1`` and ``sc1``: 125 - 16,384 GiB
          +   ``standard``: 1 - 1024 GiB
        """
        return pulumi.get(self, "volume_size")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[str]:
        """
        The volume type. For more information, see [Amazon EBS volume types](https://docs.aws.amazon.com/ebs/latest/userguide/ebs-volume-types.html) in the *Amazon EBS User Guide*.
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class LaunchTemplateElasticGpuSpecification(dict):
    """
    Amazon Elastic Graphics reached end of life on January 8, 2024. For workloads that require graphics acceleration, we recommend that you use Amazon EC2 G4ad, G4dn, or G5 instances.
      Specifies a specification for an Elastic GPU for an Amazon EC2 launch template.
      ``ElasticGpuSpecification`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
    """
    def __init__(__self__, *,
                 type: Optional[str] = None):
        """
        Amazon Elastic Graphics reached end of life on January 8, 2024. For workloads that require graphics acceleration, we recommend that you use Amazon EC2 G4ad, G4dn, or G5 instances.
          Specifies a specification for an Elastic GPU for an Amazon EC2 launch template.
          ``ElasticGpuSpecification`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        :param str type: The type of Elastic Graphics accelerator.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of Elastic Graphics accelerator.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class LaunchTemplateElasticInferenceAccelerator(dict):
    """
    Specifies an elastic inference accelerator.
      ``LaunchTemplateElasticInferenceAccelerator`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
    """
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 type: Optional[str] = None):
        """
        Specifies an elastic inference accelerator.
          ``LaunchTemplateElasticInferenceAccelerator`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        :param int count: The number of elastic inference accelerators to attach to the instance. 
                Default: 1
        :param str type: The type of elastic inference accelerator. The possible values are eia1.medium, eia1.large, and eia1.xlarge.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The number of elastic inference accelerators to attach to the instance. 
         Default: 1
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of elastic inference accelerator. The possible values are eia1.medium, eia1.large, and eia1.xlarge.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class LaunchTemplateEnaSrdSpecification(dict):
    """
    ENA Express uses AWS Scalable Reliable Datagram (SRD) technology to increase the maximum bandwidth used per stream and minimize tail latency of network traffic between EC2 instances. With ENA Express, you can communicate between two EC2 instances in the same subnet within the same account, or in different accounts. Both sending and receiving instances must have ENA Express enabled.
     To improve the reliability of network packet delivery, ENA Express reorders network packets on the receiving end by default. However, some UDP-based applications are designed to handle network packets that are out of order to reduce the overhead for packet delivery at the network layer. When ENA Express is enabled, you can specify whether UDP network traffic uses it.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enaSrdEnabled":
            suggest = "ena_srd_enabled"
        elif key == "enaSrdUdpSpecification":
            suggest = "ena_srd_udp_specification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateEnaSrdSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateEnaSrdSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateEnaSrdSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ena_srd_enabled: Optional[bool] = None,
                 ena_srd_udp_specification: Optional['outputs.LaunchTemplateEnaSrdUdpSpecification'] = None):
        """
        ENA Express uses AWS Scalable Reliable Datagram (SRD) technology to increase the maximum bandwidth used per stream and minimize tail latency of network traffic between EC2 instances. With ENA Express, you can communicate between two EC2 instances in the same subnet within the same account, or in different accounts. Both sending and receiving instances must have ENA Express enabled.
         To improve the reliability of network packet delivery, ENA Express reorders network packets on the receiving end by default. However, some UDP-based applications are designed to handle network packets that are out of order to reduce the overhead for packet delivery at the network layer. When ENA Express is enabled, you can specify whether UDP network traffic uses it.
        :param bool ena_srd_enabled: Indicates whether ENA Express is enabled for the network interface.
        :param 'LaunchTemplateEnaSrdUdpSpecification' ena_srd_udp_specification: Configures ENA Express for UDP network traffic.
        """
        if ena_srd_enabled is not None:
            pulumi.set(__self__, "ena_srd_enabled", ena_srd_enabled)
        if ena_srd_udp_specification is not None:
            pulumi.set(__self__, "ena_srd_udp_specification", ena_srd_udp_specification)

    @property
    @pulumi.getter(name="enaSrdEnabled")
    def ena_srd_enabled(self) -> Optional[bool]:
        """
        Indicates whether ENA Express is enabled for the network interface.
        """
        return pulumi.get(self, "ena_srd_enabled")

    @property
    @pulumi.getter(name="enaSrdUdpSpecification")
    def ena_srd_udp_specification(self) -> Optional['outputs.LaunchTemplateEnaSrdUdpSpecification']:
        """
        Configures ENA Express for UDP network traffic.
        """
        return pulumi.get(self, "ena_srd_udp_specification")


@pulumi.output_type
class LaunchTemplateEnaSrdUdpSpecification(dict):
    """
    ENA Express is compatible with both TCP and UDP transport protocols. When it's enabled, TCP traffic automatically uses it. However, some UDP-based applications are designed to handle network packets that are out of order, without a need for retransmission, such as live video broadcasting or other near-real-time applications. For UDP traffic, you can specify whether to use ENA Express, based on your application environment needs.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enaSrdUdpEnabled":
            suggest = "ena_srd_udp_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateEnaSrdUdpSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateEnaSrdUdpSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateEnaSrdUdpSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ena_srd_udp_enabled: Optional[bool] = None):
        """
        ENA Express is compatible with both TCP and UDP transport protocols. When it's enabled, TCP traffic automatically uses it. However, some UDP-based applications are designed to handle network packets that are out of order, without a need for retransmission, such as live video broadcasting or other near-real-time applications. For UDP traffic, you can specify whether to use ENA Express, based on your application environment needs.
        :param bool ena_srd_udp_enabled: Indicates whether UDP traffic to and from the instance uses ENA Express. To specify this setting, you must first enable ENA Express.
        """
        if ena_srd_udp_enabled is not None:
            pulumi.set(__self__, "ena_srd_udp_enabled", ena_srd_udp_enabled)

    @property
    @pulumi.getter(name="enaSrdUdpEnabled")
    def ena_srd_udp_enabled(self) -> Optional[bool]:
        """
        Indicates whether UDP traffic to and from the instance uses ENA Express. To specify this setting, you must first enable ENA Express.
        """
        return pulumi.get(self, "ena_srd_udp_enabled")


@pulumi.output_type
class LaunchTemplateEnclaveOptions(dict):
    """
    Indicates whether the instance is enabled for AWS Nitro Enclaves.
    """
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        Indicates whether the instance is enabled for AWS Nitro Enclaves.
        :param bool enabled: If this parameter is set to ``true``, the instance is enabled for AWS Nitro Enclaves; otherwise, it is not enabled for AWS Nitro Enclaves.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If this parameter is set to ``true``, the instance is enabled for AWS Nitro Enclaves; otherwise, it is not enabled for AWS Nitro Enclaves.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class LaunchTemplateHibernationOptions(dict):
    """
    Specifies whether your instance is configured for hibernation. This parameter is valid only if the instance meets the [hibernation prerequisites](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html#hibernating-prerequisites). For more information, see [Hibernate Your Instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html) in the *Amazon EC2 User Guide*.
      ``HibernationOptions`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
    """
    def __init__(__self__, *,
                 configured: Optional[bool] = None):
        """
        Specifies whether your instance is configured for hibernation. This parameter is valid only if the instance meets the [hibernation prerequisites](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html#hibernating-prerequisites). For more information, see [Hibernate Your Instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html) in the *Amazon EC2 User Guide*.
          ``HibernationOptions`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        :param bool configured: If you set this parameter to ``true``, the instance is enabled for hibernation.
                Default: ``false``
        """
        if configured is not None:
            pulumi.set(__self__, "configured", configured)

    @property
    @pulumi.getter
    def configured(self) -> Optional[bool]:
        """
        If you set this parameter to ``true``, the instance is enabled for hibernation.
         Default: ``false``
        """
        return pulumi.get(self, "configured")


@pulumi.output_type
class LaunchTemplateIamInstanceProfile(dict):
    """
    Specifies an IAM instance profile, which is a container for an IAM role for your instance. You can use an IAM role to distribute your AWS credentials to your instances.
     If you are creating the launch template for use with an ASlong group, you can specify either the name or the ARN of the instance profile, but not both.
      ``IamInstanceProfile`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
    """
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 name: Optional[str] = None):
        """
        Specifies an IAM instance profile, which is a container for an IAM role for your instance. You can use an IAM role to distribute your AWS credentials to your instances.
         If you are creating the launch template for use with an ASlong group, you can specify either the name or the ARN of the instance profile, but not both.
          ``IamInstanceProfile`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        :param str arn: The Amazon Resource Name (ARN) of the instance profile.
        :param str name: The name of the instance profile.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the instance profile.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the instance profile.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LaunchTemplateInstanceMarketOptions(dict):
    """
    Specifies the market (purchasing) option for an instance.
      ``InstanceMarketOptions`` is a property of the [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "marketType":
            suggest = "market_type"
        elif key == "spotOptions":
            suggest = "spot_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateInstanceMarketOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateInstanceMarketOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateInstanceMarketOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 market_type: Optional[str] = None,
                 spot_options: Optional['outputs.LaunchTemplateSpotOptions'] = None):
        """
        Specifies the market (purchasing) option for an instance.
          ``InstanceMarketOptions`` is a property of the [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        :param str market_type: The market type.
        :param 'LaunchTemplateSpotOptions' spot_options: The options for Spot Instances.
        """
        if market_type is not None:
            pulumi.set(__self__, "market_type", market_type)
        if spot_options is not None:
            pulumi.set(__self__, "spot_options", spot_options)

    @property
    @pulumi.getter(name="marketType")
    def market_type(self) -> Optional[str]:
        """
        The market type.
        """
        return pulumi.get(self, "market_type")

    @property
    @pulumi.getter(name="spotOptions")
    def spot_options(self) -> Optional['outputs.LaunchTemplateSpotOptions']:
        """
        The options for Spot Instances.
        """
        return pulumi.get(self, "spot_options")


@pulumi.output_type
class LaunchTemplateInstanceRequirements(dict):
    """
    The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with these attributes.
     You must specify ``VCpuCount`` and ``MemoryMiB``. All other attributes are optional. Any unspecified optional attribute is set to its default.
     When you specify multiple attributes, you get instance types that satisfy all of the specified attributes. If you specify multiple values for an attribute, you get instance types that satisfy any of the specified values.
     To limit the list of instance types from which Amazon EC2 can identify matching instance types, you can use one of the following parameters, but not both in the same request:
      +   ``AllowedInstanceTypes`` - The instance types to include in the list. All other instance types are ignored, even if they match your specified attributes.
      +   ``ExcludedInstanceTypes`` - The instance types to exclude from the list, even if they match your specified attributes.
      
      If you specify ``InstanceRequirements``, you can't specify ``InstanceType``.
     Attribute-based instance type selection is only supported when using Auto Scaling groups, EC2 Fleet, and Spot Fleet to launch instances. If you plan to use the launch template in the [launch instance wizard](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-instance-wizard.html), or with the [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) API or [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) AWS CloudFormation resource, you can't specify ``InstanceRequirements``.
      For more information, see [Attribute-based instance type selection for EC2 Fleet](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html), [Attribute-based instance type selection for Spot Fleet](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-attribute-based-instance-type-selection.html), and [Spot placement score](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html) in the *Amazon EC2 User Guide*.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceleratorCount":
            suggest = "accelerator_count"
        elif key == "acceleratorManufacturers":
            suggest = "accelerator_manufacturers"
        elif key == "acceleratorNames":
            suggest = "accelerator_names"
        elif key == "acceleratorTotalMemoryMiB":
            suggest = "accelerator_total_memory_mi_b"
        elif key == "acceleratorTypes":
            suggest = "accelerator_types"
        elif key == "allowedInstanceTypes":
            suggest = "allowed_instance_types"
        elif key == "bareMetal":
            suggest = "bare_metal"
        elif key == "baselineEbsBandwidthMbps":
            suggest = "baseline_ebs_bandwidth_mbps"
        elif key == "burstablePerformance":
            suggest = "burstable_performance"
        elif key == "cpuManufacturers":
            suggest = "cpu_manufacturers"
        elif key == "excludedInstanceTypes":
            suggest = "excluded_instance_types"
        elif key == "instanceGenerations":
            suggest = "instance_generations"
        elif key == "localStorage":
            suggest = "local_storage"
        elif key == "localStorageTypes":
            suggest = "local_storage_types"
        elif key == "maxSpotPriceAsPercentageOfOptimalOnDemandPrice":
            suggest = "max_spot_price_as_percentage_of_optimal_on_demand_price"
        elif key == "memoryGiBPerVCpu":
            suggest = "memory_gi_b_per_v_cpu"
        elif key == "memoryMiB":
            suggest = "memory_mi_b"
        elif key == "networkBandwidthGbps":
            suggest = "network_bandwidth_gbps"
        elif key == "networkInterfaceCount":
            suggest = "network_interface_count"
        elif key == "onDemandMaxPricePercentageOverLowestPrice":
            suggest = "on_demand_max_price_percentage_over_lowest_price"
        elif key == "requireHibernateSupport":
            suggest = "require_hibernate_support"
        elif key == "spotMaxPricePercentageOverLowestPrice":
            suggest = "spot_max_price_percentage_over_lowest_price"
        elif key == "totalLocalStorageGb":
            suggest = "total_local_storage_gb"
        elif key == "vCpuCount":
            suggest = "v_cpu_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateInstanceRequirements. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateInstanceRequirements.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateInstanceRequirements.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accelerator_count: Optional['outputs.LaunchTemplateAcceleratorCount'] = None,
                 accelerator_manufacturers: Optional[Sequence[str]] = None,
                 accelerator_names: Optional[Sequence[str]] = None,
                 accelerator_total_memory_mi_b: Optional['outputs.LaunchTemplateAcceleratorTotalMemoryMiB'] = None,
                 accelerator_types: Optional[Sequence[str]] = None,
                 allowed_instance_types: Optional[Sequence[str]] = None,
                 bare_metal: Optional[str] = None,
                 baseline_ebs_bandwidth_mbps: Optional['outputs.LaunchTemplateBaselineEbsBandwidthMbps'] = None,
                 burstable_performance: Optional[str] = None,
                 cpu_manufacturers: Optional[Sequence[str]] = None,
                 excluded_instance_types: Optional[Sequence[str]] = None,
                 instance_generations: Optional[Sequence[str]] = None,
                 local_storage: Optional[str] = None,
                 local_storage_types: Optional[Sequence[str]] = None,
                 max_spot_price_as_percentage_of_optimal_on_demand_price: Optional[int] = None,
                 memory_gi_b_per_v_cpu: Optional['outputs.LaunchTemplateMemoryGiBPerVCpu'] = None,
                 memory_mi_b: Optional['outputs.LaunchTemplateMemoryMiB'] = None,
                 network_bandwidth_gbps: Optional['outputs.LaunchTemplateNetworkBandwidthGbps'] = None,
                 network_interface_count: Optional['outputs.LaunchTemplateNetworkInterfaceCount'] = None,
                 on_demand_max_price_percentage_over_lowest_price: Optional[int] = None,
                 require_hibernate_support: Optional[bool] = None,
                 spot_max_price_percentage_over_lowest_price: Optional[int] = None,
                 total_local_storage_gb: Optional['outputs.LaunchTemplateTotalLocalStorageGb'] = None,
                 v_cpu_count: Optional['outputs.LaunchTemplateVCpuCount'] = None):
        """
        The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with these attributes.
         You must specify ``VCpuCount`` and ``MemoryMiB``. All other attributes are optional. Any unspecified optional attribute is set to its default.
         When you specify multiple attributes, you get instance types that satisfy all of the specified attributes. If you specify multiple values for an attribute, you get instance types that satisfy any of the specified values.
         To limit the list of instance types from which Amazon EC2 can identify matching instance types, you can use one of the following parameters, but not both in the same request:
          +   ``AllowedInstanceTypes`` - The instance types to include in the list. All other instance types are ignored, even if they match your specified attributes.
          +   ``ExcludedInstanceTypes`` - The instance types to exclude from the list, even if they match your specified attributes.
          
          If you specify ``InstanceRequirements``, you can't specify ``InstanceType``.
         Attribute-based instance type selection is only supported when using Auto Scaling groups, EC2 Fleet, and Spot Fleet to launch instances. If you plan to use the launch template in the [launch instance wizard](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-instance-wizard.html), or with the [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) API or [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html) AWS CloudFormation resource, you can't specify ``InstanceRequirements``.
          For more information, see [Attribute-based instance type selection for EC2 Fleet](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html), [Attribute-based instance type selection for Spot Fleet](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-attribute-based-instance-type-selection.html), and [Spot placement score](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html) in the *Amazon EC2 User Guide*.
        :param 'LaunchTemplateAcceleratorCount' accelerator_count: The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.
                To exclude accelerator-enabled instance types, set ``Max`` to ``0``.
                Default: No minimum or maximum limits
        :param Sequence[str] accelerator_manufacturers: Indicates whether instance types must have accelerators by specific manufacturers.
                 +  For instance types with AWS devices, specify ``amazon-web-services``.
                 +  For instance types with AMD devices, specify ``amd``.
                 +  For instance types with Habana devices, specify ``habana``.
                 +  For instance types with NVIDIA devices, specify ``nvidia``.
                 +  For instance types with Xilinx devices, specify ``xilinx``.
                 
                Default: Any manufacturer
        :param Sequence[str] accelerator_names: The accelerators that must be on the instance type.
                 +  For instance types with NVIDIA A10G GPUs, specify ``a10g``.
                 +  For instance types with NVIDIA A100 GPUs, specify ``a100``.
                 +  For instance types with NVIDIA H100 GPUs, specify ``h100``.
                 +  For instance types with AWS Inferentia chips, specify ``inferentia``.
                 +  For instance types with NVIDIA GRID K520 GPUs, specify ``k520``.
                 +  For instance types with NVIDIA K80 GPUs, specify ``k80``.
                 +  For instance types with NVIDIA M60 GPUs, specify ``m60``.
                 +  For instance types with AMD Radeon Pro V520 GPUs, specify ``radeon-pro-v520``.
                 +  For instance types with NVIDIA T4 GPUs, specify ``t4``.
                 +  For instance types with NVIDIA T4G GPUs, specify ``t4g``.
                 +  For instance types with Xilinx VU9P FPGAs, specify ``vu9p``.
                 +  For instance types with NVIDIA V100 GPUs, specify ``v100``.
                 
                Default: Any accelerator
        :param 'LaunchTemplateAcceleratorTotalMemoryMiB' accelerator_total_memory_mi_b: The minimum and maximum amount of total accelerator memory, in MiB.
                Default: No minimum or maximum limits
        :param Sequence[str] accelerator_types: The accelerator types that must be on the instance type.
                 +  For instance types with GPU accelerators, specify ``gpu``.
                 +  For instance types with FPGA accelerators, specify ``fpga``.
                 +  For instance types with inference accelerators, specify ``inference``.
                 
                Default: Any accelerator type
        :param Sequence[str] allowed_instance_types: The instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes.
                You can use strings with one or more wild cards, represented by an asterisk (``*``), to allow an instance type, size, or generation. The following are examples: ``m5.8xlarge``, ``c5*.*``, ``m5a.*``, ``r*``, ``*3*``.
                For example, if you specify ``c5*``,Amazon EC2 will allow the entire C5 instance family, which includes all C5a and C5n instance types. If you specify ``m5a.*``, Amazon EC2 will allow all the M5a instance types, but not the M5n instance types.
                 If you specify ``AllowedInstanceTypes``, you can't specify ``ExcludedInstanceTypes``.
                 Default: All instance types
        :param str bare_metal: Indicates whether bare metal instance types must be included, excluded, or required.
                 +  To include bare metal instance types, specify ``included``.
                 +  To require only bare metal instance types, specify ``required``.
                 +  To exclude bare metal instance types, specify ``excluded``.
                 
                Default: ``excluded``
        :param 'LaunchTemplateBaselineEbsBandwidthMbps' baseline_ebs_bandwidth_mbps: The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see [Amazon EBSoptimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the *Amazon EC2 User Guide*.
                Default: No minimum or maximum limits
        :param str burstable_performance: Indicates whether burstable performance T instance types are included, excluded, or required. For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html).
                 +  To include burstable performance instance types, specify ``included``.
                 +  To require only burstable performance instance types, specify ``required``.
                 +  To exclude burstable performance instance types, specify ``excluded``.
                 
                Default: ``excluded``
        :param Sequence[str] cpu_manufacturers: The CPU manufacturers to include.
                 +  For instance types with Intel CPUs, specify ``intel``.
                 +  For instance types with AMD CPUs, specify ``amd``.
                 +  For instance types with AWS CPUs, specify ``amazon-web-services``.
                 
                 Don't confuse the CPU manufacturer with the CPU architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.
                 Default: Any manufacturer
        :param Sequence[str] excluded_instance_types: The instance types to exclude.
                You can use strings with one or more wild cards, represented by an asterisk (``*``), to exclude an instance type, size, or generation. The following are examples: ``m5.8xlarge``, ``c5*.*``, ``m5a.*``, ``r*``, ``*3*``.
                For example, if you specify ``c5*``,Amazon EC2 will exclude the entire C5 instance family, which includes all C5a and C5n instance types. If you specify ``m5a.*``, Amazon EC2 will exclude all the M5a instance types, but not the M5n instance types.
                 If you specify ``ExcludedInstanceTypes``, you can't specify ``AllowedInstanceTypes``.
                 Default: No excluded instance types
        :param Sequence[str] instance_generations: Indicates whether current or previous generation instance types are included. The current generation instance types are recommended for use. Current generation instance types are typically the latest two to three generations in each instance family. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide*.
                For current generation instance types, specify ``current``.
                For previous generation instance types, specify ``previous``.
                Default: Current and previous generation instance types
        :param str local_storage: Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, [Amazon EC2 instance store](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html) in the *Amazon EC2 User Guide*.
                 +  To include instance types with instance store volumes, specify ``included``.
                 +  To require only instance types with instance store volumes, specify ``required``.
                 +  To exclude instance types with instance store volumes, specify ``excluded``.
                 
                Default: ``included``
        :param Sequence[str] local_storage_types: The type of local storage that is required.
                 +  For instance types with hard disk drive (HDD) storage, specify ``hdd``.
                 +  For instance types with solid state drive (SSD) storage, specify ``ssd``.
                 
                Default: ``hdd`` and ``ssd``
        :param int max_spot_price_as_percentage_of_optimal_on_demand_price: [Price protection] The price protection threshold for Spot Instances, as a percentage of an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.
                The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
                If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib``, the price protection threshold is based on the per vCPU or per memory price instead of the per instance price.
                 Only one of ``SpotMaxPricePercentageOverLowestPrice`` or ``MaxSpotPriceAsPercentageOfOptimalOnDemandPrice`` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as ``999999``.
        :param 'LaunchTemplateMemoryGiBPerVCpu' memory_gi_b_per_v_cpu: The minimum and maximum amount of memory per vCPU, in GiB.
                Default: No minimum or maximum limits
        :param 'LaunchTemplateMemoryMiB' memory_mi_b: The minimum and maximum amount of memory, in MiB.
        :param 'LaunchTemplateNetworkBandwidthGbps' network_bandwidth_gbps: The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps).
                Default: No minimum or maximum limits
        :param 'LaunchTemplateNetworkInterfaceCount' network_interface_count: The minimum and maximum number of network interfaces.
                Default: No minimum or maximum limits
        :param int on_demand_max_price_percentage_over_lowest_price: [Price protection] The price protection threshold for On-Demand Instances, as a percentage higher than an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.
                The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
                To turn off price protection, specify a high value, such as ``999999``.
                This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html).
                 If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib``, the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.
                 Default: ``20``
        :param bool require_hibernate_support: Indicates whether instance types must support hibernation for On-Demand Instances.
                This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html).
                Default: ``false``
        :param int spot_max_price_percentage_over_lowest_price: [Price protection] The price protection threshold for Spot Instances, as a percentage higher than an identified Spot price. The identified Spot price is the Spot price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified Spot price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose Spot price exceeds your specified threshold.
                The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
                If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib``, the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.
                This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html).
                 Only one of ``SpotMaxPricePercentageOverLowestPrice`` or ``MaxSpotPriceAsPercentageOfOptimalOnDemandPrice`` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as ``999999``.
                 Default: ``100``
        :param 'LaunchTemplateTotalLocalStorageGb' total_local_storage_gb: The minimum and maximum amount of total local storage, in GB.
                Default: No minimum or maximum limits
        :param 'LaunchTemplateVCpuCount' v_cpu_count: The minimum and maximum number of vCPUs.
        """
        if accelerator_count is not None:
            pulumi.set(__self__, "accelerator_count", accelerator_count)
        if accelerator_manufacturers is not None:
            pulumi.set(__self__, "accelerator_manufacturers", accelerator_manufacturers)
        if accelerator_names is not None:
            pulumi.set(__self__, "accelerator_names", accelerator_names)
        if accelerator_total_memory_mi_b is not None:
            pulumi.set(__self__, "accelerator_total_memory_mi_b", accelerator_total_memory_mi_b)
        if accelerator_types is not None:
            pulumi.set(__self__, "accelerator_types", accelerator_types)
        if allowed_instance_types is not None:
            pulumi.set(__self__, "allowed_instance_types", allowed_instance_types)
        if bare_metal is not None:
            pulumi.set(__self__, "bare_metal", bare_metal)
        if baseline_ebs_bandwidth_mbps is not None:
            pulumi.set(__self__, "baseline_ebs_bandwidth_mbps", baseline_ebs_bandwidth_mbps)
        if burstable_performance is not None:
            pulumi.set(__self__, "burstable_performance", burstable_performance)
        if cpu_manufacturers is not None:
            pulumi.set(__self__, "cpu_manufacturers", cpu_manufacturers)
        if excluded_instance_types is not None:
            pulumi.set(__self__, "excluded_instance_types", excluded_instance_types)
        if instance_generations is not None:
            pulumi.set(__self__, "instance_generations", instance_generations)
        if local_storage is not None:
            pulumi.set(__self__, "local_storage", local_storage)
        if local_storage_types is not None:
            pulumi.set(__self__, "local_storage_types", local_storage_types)
        if max_spot_price_as_percentage_of_optimal_on_demand_price is not None:
            pulumi.set(__self__, "max_spot_price_as_percentage_of_optimal_on_demand_price", max_spot_price_as_percentage_of_optimal_on_demand_price)
        if memory_gi_b_per_v_cpu is not None:
            pulumi.set(__self__, "memory_gi_b_per_v_cpu", memory_gi_b_per_v_cpu)
        if memory_mi_b is not None:
            pulumi.set(__self__, "memory_mi_b", memory_mi_b)
        if network_bandwidth_gbps is not None:
            pulumi.set(__self__, "network_bandwidth_gbps", network_bandwidth_gbps)
        if network_interface_count is not None:
            pulumi.set(__self__, "network_interface_count", network_interface_count)
        if on_demand_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "on_demand_max_price_percentage_over_lowest_price", on_demand_max_price_percentage_over_lowest_price)
        if require_hibernate_support is not None:
            pulumi.set(__self__, "require_hibernate_support", require_hibernate_support)
        if spot_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "spot_max_price_percentage_over_lowest_price", spot_max_price_percentage_over_lowest_price)
        if total_local_storage_gb is not None:
            pulumi.set(__self__, "total_local_storage_gb", total_local_storage_gb)
        if v_cpu_count is not None:
            pulumi.set(__self__, "v_cpu_count", v_cpu_count)

    @property
    @pulumi.getter(name="acceleratorCount")
    def accelerator_count(self) -> Optional['outputs.LaunchTemplateAcceleratorCount']:
        """
        The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.
         To exclude accelerator-enabled instance types, set ``Max`` to ``0``.
         Default: No minimum or maximum limits
        """
        return pulumi.get(self, "accelerator_count")

    @property
    @pulumi.getter(name="acceleratorManufacturers")
    def accelerator_manufacturers(self) -> Optional[Sequence[str]]:
        """
        Indicates whether instance types must have accelerators by specific manufacturers.
          +  For instance types with AWS devices, specify ``amazon-web-services``.
          +  For instance types with AMD devices, specify ``amd``.
          +  For instance types with Habana devices, specify ``habana``.
          +  For instance types with NVIDIA devices, specify ``nvidia``.
          +  For instance types with Xilinx devices, specify ``xilinx``.
          
         Default: Any manufacturer
        """
        return pulumi.get(self, "accelerator_manufacturers")

    @property
    @pulumi.getter(name="acceleratorNames")
    def accelerator_names(self) -> Optional[Sequence[str]]:
        """
        The accelerators that must be on the instance type.
          +  For instance types with NVIDIA A10G GPUs, specify ``a10g``.
          +  For instance types with NVIDIA A100 GPUs, specify ``a100``.
          +  For instance types with NVIDIA H100 GPUs, specify ``h100``.
          +  For instance types with AWS Inferentia chips, specify ``inferentia``.
          +  For instance types with NVIDIA GRID K520 GPUs, specify ``k520``.
          +  For instance types with NVIDIA K80 GPUs, specify ``k80``.
          +  For instance types with NVIDIA M60 GPUs, specify ``m60``.
          +  For instance types with AMD Radeon Pro V520 GPUs, specify ``radeon-pro-v520``.
          +  For instance types with NVIDIA T4 GPUs, specify ``t4``.
          +  For instance types with NVIDIA T4G GPUs, specify ``t4g``.
          +  For instance types with Xilinx VU9P FPGAs, specify ``vu9p``.
          +  For instance types with NVIDIA V100 GPUs, specify ``v100``.
          
         Default: Any accelerator
        """
        return pulumi.get(self, "accelerator_names")

    @property
    @pulumi.getter(name="acceleratorTotalMemoryMiB")
    def accelerator_total_memory_mi_b(self) -> Optional['outputs.LaunchTemplateAcceleratorTotalMemoryMiB']:
        """
        The minimum and maximum amount of total accelerator memory, in MiB.
         Default: No minimum or maximum limits
        """
        return pulumi.get(self, "accelerator_total_memory_mi_b")

    @property
    @pulumi.getter(name="acceleratorTypes")
    def accelerator_types(self) -> Optional[Sequence[str]]:
        """
        The accelerator types that must be on the instance type.
          +  For instance types with GPU accelerators, specify ``gpu``.
          +  For instance types with FPGA accelerators, specify ``fpga``.
          +  For instance types with inference accelerators, specify ``inference``.
          
         Default: Any accelerator type
        """
        return pulumi.get(self, "accelerator_types")

    @property
    @pulumi.getter(name="allowedInstanceTypes")
    def allowed_instance_types(self) -> Optional[Sequence[str]]:
        """
        The instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes.
         You can use strings with one or more wild cards, represented by an asterisk (``*``), to allow an instance type, size, or generation. The following are examples: ``m5.8xlarge``, ``c5*.*``, ``m5a.*``, ``r*``, ``*3*``.
         For example, if you specify ``c5*``,Amazon EC2 will allow the entire C5 instance family, which includes all C5a and C5n instance types. If you specify ``m5a.*``, Amazon EC2 will allow all the M5a instance types, but not the M5n instance types.
          If you specify ``AllowedInstanceTypes``, you can't specify ``ExcludedInstanceTypes``.
          Default: All instance types
        """
        return pulumi.get(self, "allowed_instance_types")

    @property
    @pulumi.getter(name="bareMetal")
    def bare_metal(self) -> Optional[str]:
        """
        Indicates whether bare metal instance types must be included, excluded, or required.
          +  To include bare metal instance types, specify ``included``.
          +  To require only bare metal instance types, specify ``required``.
          +  To exclude bare metal instance types, specify ``excluded``.
          
         Default: ``excluded``
        """
        return pulumi.get(self, "bare_metal")

    @property
    @pulumi.getter(name="baselineEbsBandwidthMbps")
    def baseline_ebs_bandwidth_mbps(self) -> Optional['outputs.LaunchTemplateBaselineEbsBandwidthMbps']:
        """
        The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see [Amazon EBSoptimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the *Amazon EC2 User Guide*.
         Default: No minimum or maximum limits
        """
        return pulumi.get(self, "baseline_ebs_bandwidth_mbps")

    @property
    @pulumi.getter(name="burstablePerformance")
    def burstable_performance(self) -> Optional[str]:
        """
        Indicates whether burstable performance T instance types are included, excluded, or required. For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html).
          +  To include burstable performance instance types, specify ``included``.
          +  To require only burstable performance instance types, specify ``required``.
          +  To exclude burstable performance instance types, specify ``excluded``.
          
         Default: ``excluded``
        """
        return pulumi.get(self, "burstable_performance")

    @property
    @pulumi.getter(name="cpuManufacturers")
    def cpu_manufacturers(self) -> Optional[Sequence[str]]:
        """
        The CPU manufacturers to include.
          +  For instance types with Intel CPUs, specify ``intel``.
          +  For instance types with AMD CPUs, specify ``amd``.
          +  For instance types with AWS CPUs, specify ``amazon-web-services``.
          
          Don't confuse the CPU manufacturer with the CPU architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.
          Default: Any manufacturer
        """
        return pulumi.get(self, "cpu_manufacturers")

    @property
    @pulumi.getter(name="excludedInstanceTypes")
    def excluded_instance_types(self) -> Optional[Sequence[str]]:
        """
        The instance types to exclude.
         You can use strings with one or more wild cards, represented by an asterisk (``*``), to exclude an instance type, size, or generation. The following are examples: ``m5.8xlarge``, ``c5*.*``, ``m5a.*``, ``r*``, ``*3*``.
         For example, if you specify ``c5*``,Amazon EC2 will exclude the entire C5 instance family, which includes all C5a and C5n instance types. If you specify ``m5a.*``, Amazon EC2 will exclude all the M5a instance types, but not the M5n instance types.
          If you specify ``ExcludedInstanceTypes``, you can't specify ``AllowedInstanceTypes``.
          Default: No excluded instance types
        """
        return pulumi.get(self, "excluded_instance_types")

    @property
    @pulumi.getter(name="instanceGenerations")
    def instance_generations(self) -> Optional[Sequence[str]]:
        """
        Indicates whether current or previous generation instance types are included. The current generation instance types are recommended for use. Current generation instance types are typically the latest two to three generations in each instance family. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide*.
         For current generation instance types, specify ``current``.
         For previous generation instance types, specify ``previous``.
         Default: Current and previous generation instance types
        """
        return pulumi.get(self, "instance_generations")

    @property
    @pulumi.getter(name="localStorage")
    def local_storage(self) -> Optional[str]:
        """
        Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, [Amazon EC2 instance store](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html) in the *Amazon EC2 User Guide*.
          +  To include instance types with instance store volumes, specify ``included``.
          +  To require only instance types with instance store volumes, specify ``required``.
          +  To exclude instance types with instance store volumes, specify ``excluded``.
          
         Default: ``included``
        """
        return pulumi.get(self, "local_storage")

    @property
    @pulumi.getter(name="localStorageTypes")
    def local_storage_types(self) -> Optional[Sequence[str]]:
        """
        The type of local storage that is required.
          +  For instance types with hard disk drive (HDD) storage, specify ``hdd``.
          +  For instance types with solid state drive (SSD) storage, specify ``ssd``.
          
         Default: ``hdd`` and ``ssd``
        """
        return pulumi.get(self, "local_storage_types")

    @property
    @pulumi.getter(name="maxSpotPriceAsPercentageOfOptimalOnDemandPrice")
    def max_spot_price_as_percentage_of_optimal_on_demand_price(self) -> Optional[int]:
        """
        [Price protection] The price protection threshold for Spot Instances, as a percentage of an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.
         The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
         If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib``, the price protection threshold is based on the per vCPU or per memory price instead of the per instance price.
          Only one of ``SpotMaxPricePercentageOverLowestPrice`` or ``MaxSpotPriceAsPercentageOfOptimalOnDemandPrice`` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as ``999999``.
        """
        return pulumi.get(self, "max_spot_price_as_percentage_of_optimal_on_demand_price")

    @property
    @pulumi.getter(name="memoryGiBPerVCpu")
    def memory_gi_b_per_v_cpu(self) -> Optional['outputs.LaunchTemplateMemoryGiBPerVCpu']:
        """
        The minimum and maximum amount of memory per vCPU, in GiB.
         Default: No minimum or maximum limits
        """
        return pulumi.get(self, "memory_gi_b_per_v_cpu")

    @property
    @pulumi.getter(name="memoryMiB")
    def memory_mi_b(self) -> Optional['outputs.LaunchTemplateMemoryMiB']:
        """
        The minimum and maximum amount of memory, in MiB.
        """
        return pulumi.get(self, "memory_mi_b")

    @property
    @pulumi.getter(name="networkBandwidthGbps")
    def network_bandwidth_gbps(self) -> Optional['outputs.LaunchTemplateNetworkBandwidthGbps']:
        """
        The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps).
         Default: No minimum or maximum limits
        """
        return pulumi.get(self, "network_bandwidth_gbps")

    @property
    @pulumi.getter(name="networkInterfaceCount")
    def network_interface_count(self) -> Optional['outputs.LaunchTemplateNetworkInterfaceCount']:
        """
        The minimum and maximum number of network interfaces.
         Default: No minimum or maximum limits
        """
        return pulumi.get(self, "network_interface_count")

    @property
    @pulumi.getter(name="onDemandMaxPricePercentageOverLowestPrice")
    def on_demand_max_price_percentage_over_lowest_price(self) -> Optional[int]:
        """
        [Price protection] The price protection threshold for On-Demand Instances, as a percentage higher than an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.
         The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
         To turn off price protection, specify a high value, such as ``999999``.
         This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html).
          If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib``, the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.
          Default: ``20``
        """
        return pulumi.get(self, "on_demand_max_price_percentage_over_lowest_price")

    @property
    @pulumi.getter(name="requireHibernateSupport")
    def require_hibernate_support(self) -> Optional[bool]:
        """
        Indicates whether instance types must support hibernation for On-Demand Instances.
         This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html).
         Default: ``false``
        """
        return pulumi.get(self, "require_hibernate_support")

    @property
    @pulumi.getter(name="spotMaxPricePercentageOverLowestPrice")
    def spot_max_price_percentage_over_lowest_price(self) -> Optional[int]:
        """
        [Price protection] The price protection threshold for Spot Instances, as a percentage higher than an identified Spot price. The identified Spot price is the Spot price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified Spot price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose Spot price exceeds your specified threshold.
         The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
         If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib``, the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.
         This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html).
          Only one of ``SpotMaxPricePercentageOverLowestPrice`` or ``MaxSpotPriceAsPercentageOfOptimalOnDemandPrice`` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as ``999999``.
          Default: ``100``
        """
        return pulumi.get(self, "spot_max_price_percentage_over_lowest_price")

    @property
    @pulumi.getter(name="totalLocalStorageGb")
    def total_local_storage_gb(self) -> Optional['outputs.LaunchTemplateTotalLocalStorageGb']:
        """
        The minimum and maximum amount of total local storage, in GB.
         Default: No minimum or maximum limits
        """
        return pulumi.get(self, "total_local_storage_gb")

    @property
    @pulumi.getter(name="vCpuCount")
    def v_cpu_count(self) -> Optional['outputs.LaunchTemplateVCpuCount']:
        """
        The minimum and maximum number of vCPUs.
        """
        return pulumi.get(self, "v_cpu_count")


@pulumi.output_type
class LaunchTemplateIpv4PrefixSpecification(dict):
    """
    Specifies an IPv4 prefix for a network interface.
      ``Ipv4PrefixSpecification`` is a property of [AWS::EC2::LaunchTemplate NetworkInterface](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv4Prefix":
            suggest = "ipv4_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateIpv4PrefixSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateIpv4PrefixSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateIpv4PrefixSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv4_prefix: Optional[str] = None):
        """
        Specifies an IPv4 prefix for a network interface.
          ``Ipv4PrefixSpecification`` is a property of [AWS::EC2::LaunchTemplate NetworkInterface](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html).
        :param str ipv4_prefix: The IPv4 prefix. For information, see [Assigning prefixes to network interfaces](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-prefix-eni.html) in the *Amazon EC2 User Guide*.
        """
        if ipv4_prefix is not None:
            pulumi.set(__self__, "ipv4_prefix", ipv4_prefix)

    @property
    @pulumi.getter(name="ipv4Prefix")
    def ipv4_prefix(self) -> Optional[str]:
        """
        The IPv4 prefix. For information, see [Assigning prefixes to network interfaces](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-prefix-eni.html) in the *Amazon EC2 User Guide*.
        """
        return pulumi.get(self, "ipv4_prefix")


@pulumi.output_type
class LaunchTemplateIpv6Add(dict):
    """
    Specifies an IPv6 address in an Amazon EC2 launch template.
      ``Ipv6Add`` is a property of [AWS::EC2::LaunchTemplate NetworkInterface](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv6Address":
            suggest = "ipv6_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateIpv6Add. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateIpv6Add.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateIpv6Add.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv6_address: Optional[str] = None):
        """
        Specifies an IPv6 address in an Amazon EC2 launch template.
          ``Ipv6Add`` is a property of [AWS::EC2::LaunchTemplate NetworkInterface](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html).
        :param str ipv6_address: One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. You can't use this option if you're specifying a number of IPv6 addresses.
        """
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[str]:
        """
        One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. You can't use this option if you're specifying a number of IPv6 addresses.
        """
        return pulumi.get(self, "ipv6_address")


@pulumi.output_type
class LaunchTemplateIpv6PrefixSpecification(dict):
    """
    Specifies an IPv6 prefix for a network interface.
      ``Ipv6PrefixSpecification`` is a property of [AWS::EC2::LaunchTemplate NetworkInterface](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv6Prefix":
            suggest = "ipv6_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateIpv6PrefixSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateIpv6PrefixSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateIpv6PrefixSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv6_prefix: Optional[str] = None):
        """
        Specifies an IPv6 prefix for a network interface.
          ``Ipv6PrefixSpecification`` is a property of [AWS::EC2::LaunchTemplate NetworkInterface](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html).
        :param str ipv6_prefix: The IPv6 prefix.
        """
        if ipv6_prefix is not None:
            pulumi.set(__self__, "ipv6_prefix", ipv6_prefix)

    @property
    @pulumi.getter(name="ipv6Prefix")
    def ipv6_prefix(self) -> Optional[str]:
        """
        The IPv6 prefix.
        """
        return pulumi.get(self, "ipv6_prefix")


@pulumi.output_type
class LaunchTemplateLicenseSpecification(dict):
    """
    Specifies a license configuration for an instance.
      ``LicenseSpecification`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "licenseConfigurationArn":
            suggest = "license_configuration_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateLicenseSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateLicenseSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateLicenseSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 license_configuration_arn: Optional[str] = None):
        """
        Specifies a license configuration for an instance.
          ``LicenseSpecification`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        :param str license_configuration_arn: The Amazon Resource Name (ARN) of the license configuration.
        """
        if license_configuration_arn is not None:
            pulumi.set(__self__, "license_configuration_arn", license_configuration_arn)

    @property
    @pulumi.getter(name="licenseConfigurationArn")
    def license_configuration_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the license configuration.
        """
        return pulumi.get(self, "license_configuration_arn")


@pulumi.output_type
class LaunchTemplateMaintenanceOptions(dict):
    """
    The maintenance options of your instance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoRecovery":
            suggest = "auto_recovery"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateMaintenanceOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateMaintenanceOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateMaintenanceOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_recovery: Optional[str] = None):
        """
        The maintenance options of your instance.
        :param str auto_recovery: Disables the automatic recovery behavior of your instance or sets it to default.
        """
        if auto_recovery is not None:
            pulumi.set(__self__, "auto_recovery", auto_recovery)

    @property
    @pulumi.getter(name="autoRecovery")
    def auto_recovery(self) -> Optional[str]:
        """
        Disables the automatic recovery behavior of your instance or sets it to default.
        """
        return pulumi.get(self, "auto_recovery")


@pulumi.output_type
class LaunchTemplateMemoryGiBPerVCpu(dict):
    """
    The minimum and maximum amount of memory per vCPU, in GiB.
    """
    def __init__(__self__, *,
                 max: Optional[float] = None,
                 min: Optional[float] = None):
        """
        The minimum and maximum amount of memory per vCPU, in GiB.
        :param float max: The maximum amount of memory per vCPU, in GiB. To specify no maximum limit, omit this parameter.
        :param float min: The minimum amount of memory per vCPU, in GiB. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        """
        The maximum amount of memory per vCPU, in GiB. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        """
        The minimum amount of memory per vCPU, in GiB. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateMemoryMiB(dict):
    """
    The minimum and maximum amount of memory, in MiB.
    """
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        The minimum and maximum amount of memory, in MiB.
        :param int max: The maximum amount of memory, in MiB. To specify no maximum limit, omit this parameter.
        :param int min: The minimum amount of memory, in MiB. To specify no minimum limit, specify ``0``.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        The maximum amount of memory, in MiB. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        The minimum amount of memory, in MiB. To specify no minimum limit, specify ``0``.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateMetadataOptions(dict):
    """
    The metadata options for the instance. For more information, see [Instance metadata and user data](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html) in the *Amazon EC2 User Guide*.
      ``MetadataOptions`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpEndpoint":
            suggest = "http_endpoint"
        elif key == "httpProtocolIpv6":
            suggest = "http_protocol_ipv6"
        elif key == "httpPutResponseHopLimit":
            suggest = "http_put_response_hop_limit"
        elif key == "httpTokens":
            suggest = "http_tokens"
        elif key == "instanceMetadataTags":
            suggest = "instance_metadata_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateMetadataOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateMetadataOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateMetadataOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_endpoint: Optional[str] = None,
                 http_protocol_ipv6: Optional[str] = None,
                 http_put_response_hop_limit: Optional[int] = None,
                 http_tokens: Optional[str] = None,
                 instance_metadata_tags: Optional[str] = None):
        """
        The metadata options for the instance. For more information, see [Instance metadata and user data](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html) in the *Amazon EC2 User Guide*.
          ``MetadataOptions`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        :param str http_endpoint: Enables or disables the HTTP metadata endpoint on your instances. If the parameter is not specified, the default state is ``enabled``.
                 If you specify a value of ``disabled``, you will not be able to access your instance metadata.
        :param str http_protocol_ipv6: Enables or disables the IPv6 endpoint for the instance metadata service.
                Default: ``disabled``
        :param int http_put_response_hop_limit: The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel.
                Default: ``1`` 
                Possible values: Integers from 1 to 64
        :param str http_tokens: Indicates whether IMDSv2 is required.
                 +   ``optional`` - IMDSv2 is optional. You can choose whether to send a session token in your instance metadata retrieval requests. If you retrieve IAM role credentials without a session token, you receive the IMDSv1 role credentials. If you retrieve IAM role credentials using a valid session token, you receive the IMDSv2 role credentials.
                 +   ``required`` - IMDSv2 is required. You must send a session token in your instance metadata retrieval requests. With this option, retrieving the IAM role credentials always returns IMDSv2 credentials; IMDSv1 credentials are not available.
                 
                Default: If the value of ``ImdsSupport`` for the Amazon Machine Image (AMI) for your instance is ``v2.0``, the default is ``required``.
        :param str instance_metadata_tags: Set to ``enabled`` to allow access to instance tags from the instance metadata. Set to ``disabled`` to turn off access to instance tags from the instance metadata. For more information, see [Work with instance tags using the instance metadata](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#work-with-tags-in-IMDS).
                Default: ``disabled``
        """
        if http_endpoint is not None:
            pulumi.set(__self__, "http_endpoint", http_endpoint)
        if http_protocol_ipv6 is not None:
            pulumi.set(__self__, "http_protocol_ipv6", http_protocol_ipv6)
        if http_put_response_hop_limit is not None:
            pulumi.set(__self__, "http_put_response_hop_limit", http_put_response_hop_limit)
        if http_tokens is not None:
            pulumi.set(__self__, "http_tokens", http_tokens)
        if instance_metadata_tags is not None:
            pulumi.set(__self__, "instance_metadata_tags", instance_metadata_tags)

    @property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> Optional[str]:
        """
        Enables or disables the HTTP metadata endpoint on your instances. If the parameter is not specified, the default state is ``enabled``.
          If you specify a value of ``disabled``, you will not be able to access your instance metadata.
        """
        return pulumi.get(self, "http_endpoint")

    @property
    @pulumi.getter(name="httpProtocolIpv6")
    def http_protocol_ipv6(self) -> Optional[str]:
        """
        Enables or disables the IPv6 endpoint for the instance metadata service.
         Default: ``disabled``
        """
        return pulumi.get(self, "http_protocol_ipv6")

    @property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> Optional[int]:
        """
        The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel.
         Default: ``1`` 
         Possible values: Integers from 1 to 64
        """
        return pulumi.get(self, "http_put_response_hop_limit")

    @property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> Optional[str]:
        """
        Indicates whether IMDSv2 is required.
          +   ``optional`` - IMDSv2 is optional. You can choose whether to send a session token in your instance metadata retrieval requests. If you retrieve IAM role credentials without a session token, you receive the IMDSv1 role credentials. If you retrieve IAM role credentials using a valid session token, you receive the IMDSv2 role credentials.
          +   ``required`` - IMDSv2 is required. You must send a session token in your instance metadata retrieval requests. With this option, retrieving the IAM role credentials always returns IMDSv2 credentials; IMDSv1 credentials are not available.
          
         Default: If the value of ``ImdsSupport`` for the Amazon Machine Image (AMI) for your instance is ``v2.0``, the default is ``required``.
        """
        return pulumi.get(self, "http_tokens")

    @property
    @pulumi.getter(name="instanceMetadataTags")
    def instance_metadata_tags(self) -> Optional[str]:
        """
        Set to ``enabled`` to allow access to instance tags from the instance metadata. Set to ``disabled`` to turn off access to instance tags from the instance metadata. For more information, see [Work with instance tags using the instance metadata](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#work-with-tags-in-IMDS).
         Default: ``disabled``
        """
        return pulumi.get(self, "instance_metadata_tags")


@pulumi.output_type
class LaunchTemplateMonitoring(dict):
    """
    Specifies whether detailed monitoring is enabled for an instance. For more information about detailed monitoring, see [Enable or turn off detailed monitoring for your instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-cloudwatch-new.html) in the *User Guide*.
      ``Monitoring`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
    """
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        Specifies whether detailed monitoring is enabled for an instance. For more information about detailed monitoring, see [Enable or turn off detailed monitoring for your instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-cloudwatch-new.html) in the *User Guide*.
          ``Monitoring`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        :param bool enabled: Specify ``true`` to enable detailed monitoring. Otherwise, basic monitoring is enabled.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Specify ``true`` to enable detailed monitoring. Otherwise, basic monitoring is enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class LaunchTemplateNetworkBandwidthGbps(dict):
    """
    The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps).
      Setting the minimum bandwidth does not guarantee that your instance will achieve the minimum bandwidth. Amazon EC2 will identify instance types that support the specified minimum bandwidth, but the actual bandwidth of your instance might go below the specified minimum at times. For more information, see [Available instance bandwidth](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-network-bandwidth.html#available-instance-bandwidth) in the *Amazon EC2 User Guide*.
    """
    def __init__(__self__, *,
                 max: Optional[float] = None,
                 min: Optional[float] = None):
        """
        The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps).
          Setting the minimum bandwidth does not guarantee that your instance will achieve the minimum bandwidth. Amazon EC2 will identify instance types that support the specified minimum bandwidth, but the actual bandwidth of your instance might go below the specified minimum at times. For more information, see [Available instance bandwidth](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-network-bandwidth.html#available-instance-bandwidth) in the *Amazon EC2 User Guide*.
        :param float max: The maximum amount of network bandwidth, in Gbps. To specify no maximum limit, omit this parameter.
        :param float min: The minimum amount of network bandwidth, in Gbps. If this parameter is not specified, there is no minimum limit.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        """
        The maximum amount of network bandwidth, in Gbps. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        """
        The minimum amount of network bandwidth, in Gbps. If this parameter is not specified, there is no minimum limit.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateNetworkInterface(dict):
    """
    Specifies the parameters for a network interface.
      ``NetworkInterface`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "associateCarrierIpAddress":
            suggest = "associate_carrier_ip_address"
        elif key == "associatePublicIpAddress":
            suggest = "associate_public_ip_address"
        elif key == "connectionTrackingSpecification":
            suggest = "connection_tracking_specification"
        elif key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "deviceIndex":
            suggest = "device_index"
        elif key == "enaSrdSpecification":
            suggest = "ena_srd_specification"
        elif key == "interfaceType":
            suggest = "interface_type"
        elif key == "ipv4PrefixCount":
            suggest = "ipv4_prefix_count"
        elif key == "ipv4Prefixes":
            suggest = "ipv4_prefixes"
        elif key == "ipv6AddressCount":
            suggest = "ipv6_address_count"
        elif key == "ipv6Addresses":
            suggest = "ipv6_addresses"
        elif key == "ipv6PrefixCount":
            suggest = "ipv6_prefix_count"
        elif key == "ipv6Prefixes":
            suggest = "ipv6_prefixes"
        elif key == "networkCardIndex":
            suggest = "network_card_index"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "primaryIpv6":
            suggest = "primary_ipv6"
        elif key == "privateIpAddress":
            suggest = "private_ip_address"
        elif key == "privateIpAddresses":
            suggest = "private_ip_addresses"
        elif key == "secondaryPrivateIpAddressCount":
            suggest = "secondary_private_ip_address_count"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 associate_carrier_ip_address: Optional[bool] = None,
                 associate_public_ip_address: Optional[bool] = None,
                 connection_tracking_specification: Optional['outputs.LaunchTemplateConnectionTrackingSpecification'] = None,
                 delete_on_termination: Optional[bool] = None,
                 description: Optional[str] = None,
                 device_index: Optional[int] = None,
                 ena_srd_specification: Optional['outputs.LaunchTemplateEnaSrdSpecification'] = None,
                 groups: Optional[Sequence[str]] = None,
                 interface_type: Optional[str] = None,
                 ipv4_prefix_count: Optional[int] = None,
                 ipv4_prefixes: Optional[Sequence['outputs.LaunchTemplateIpv4PrefixSpecification']] = None,
                 ipv6_address_count: Optional[int] = None,
                 ipv6_addresses: Optional[Sequence['outputs.LaunchTemplateIpv6Add']] = None,
                 ipv6_prefix_count: Optional[int] = None,
                 ipv6_prefixes: Optional[Sequence['outputs.LaunchTemplateIpv6PrefixSpecification']] = None,
                 network_card_index: Optional[int] = None,
                 network_interface_id: Optional[str] = None,
                 primary_ipv6: Optional[bool] = None,
                 private_ip_address: Optional[str] = None,
                 private_ip_addresses: Optional[Sequence['outputs.LaunchTemplatePrivateIpAdd']] = None,
                 secondary_private_ip_address_count: Optional[int] = None,
                 subnet_id: Optional[str] = None):
        """
        Specifies the parameters for a network interface.
          ``NetworkInterface`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        :param bool associate_carrier_ip_address: Associates a Carrier IP address with eth0 for a new network interface.
                Use this option when you launch an instance in a Wavelength Zone and want to associate a Carrier IP address with the network interface. For more information about Carrier IP addresses, see [Carrier IP addresses](https://docs.aws.amazon.com/wavelength/latest/developerguide/how-wavelengths-work.html#provider-owned-ip) in the *Developer Guide*.
        :param bool associate_public_ip_address: Associates a public IPv4 address with eth0 for a new network interface.
                 AWS charges for all public IPv4 addresses, including public IPv4 addresses associated with running instances and Elastic IP addresses. For more information, see the *Public IPv4 Address* tab on the [Amazon VPC pricing page](https://docs.aws.amazon.com/vpc/pricing/).
        :param 'LaunchTemplateConnectionTrackingSpecification' connection_tracking_specification: A connection tracking specification for the network interface.
        :param bool delete_on_termination: Indicates whether the network interface is deleted when the instance is terminated.
        :param str description: A description for the network interface.
        :param int device_index: The device index for the network interface attachment. Each network interface requires a device index. If you create a launch template that includes secondary network interfaces but not a primary network interface, then you must add a primary network interface as a launch parameter when you launch an instance from the template.
        :param 'LaunchTemplateEnaSrdSpecification' ena_srd_specification: The ENA Express configuration for the network interface.
        :param Sequence[str] groups: The IDs of one or more security groups.
        :param str interface_type: The type of network interface. To create an Elastic Fabric Adapter (EFA), specify ``efa``. For more information, see [Elastic Fabric Adapter](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/efa.html) in the *Amazon EC2 User Guide*.
                If you are not creating an EFA, specify ``interface`` or omit this parameter.
                Valid values: ``interface`` | ``efa``
        :param int ipv4_prefix_count: The number of IPv4 prefixes to be automatically assigned to the network interface. You cannot use this option if you use the ``Ipv4Prefix`` option.
        :param Sequence['LaunchTemplateIpv4PrefixSpecification'] ipv4_prefixes: One or more IPv4 prefixes to be assigned to the network interface. You cannot use this option if you use the ``Ipv4PrefixCount`` option.
        :param int ipv6_address_count: The number of IPv6 addresses to assign to a network interface. Amazon EC2 automatically selects the IPv6 addresses from the subnet range. You can't use this option if specifying specific IPv6 addresses.
        :param Sequence['LaunchTemplateIpv6Add'] ipv6_addresses: One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. You can't use this option if you're specifying a number of IPv6 addresses.
        :param int ipv6_prefix_count: The number of IPv6 prefixes to be automatically assigned to the network interface. You cannot use this option if you use the ``Ipv6Prefix`` option.
        :param Sequence['LaunchTemplateIpv6PrefixSpecification'] ipv6_prefixes: One or more IPv6 prefixes to be assigned to the network interface. You cannot use this option if you use the ``Ipv6PrefixCount`` option.
        :param int network_card_index: The index of the network card. Some instance types support multiple network cards. The primary network interface must be assigned to network card index 0. The default is network card index 0.
        :param str network_interface_id: The ID of the network interface.
        :param bool primary_ipv6: The primary IPv6 address of the network interface. When you enable an IPv6 GUA address to be a primary IPv6, the first IPv6 GUA will be made the primary IPv6 address until the instance is terminated or the network interface is detached. For more information about primary IPv6 addresses, see [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html).
        :param str private_ip_address: The primary private IPv4 address of the network interface.
        :param Sequence['LaunchTemplatePrivateIpAdd'] private_ip_addresses: One or more private IPv4 addresses.
        :param int secondary_private_ip_address_count: The number of secondary private IPv4 addresses to assign to a network interface.
        :param str subnet_id: The ID of the subnet for the network interface.
        """
        if associate_carrier_ip_address is not None:
            pulumi.set(__self__, "associate_carrier_ip_address", associate_carrier_ip_address)
        if associate_public_ip_address is not None:
            pulumi.set(__self__, "associate_public_ip_address", associate_public_ip_address)
        if connection_tracking_specification is not None:
            pulumi.set(__self__, "connection_tracking_specification", connection_tracking_specification)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if device_index is not None:
            pulumi.set(__self__, "device_index", device_index)
        if ena_srd_specification is not None:
            pulumi.set(__self__, "ena_srd_specification", ena_srd_specification)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if interface_type is not None:
            pulumi.set(__self__, "interface_type", interface_type)
        if ipv4_prefix_count is not None:
            pulumi.set(__self__, "ipv4_prefix_count", ipv4_prefix_count)
        if ipv4_prefixes is not None:
            pulumi.set(__self__, "ipv4_prefixes", ipv4_prefixes)
        if ipv6_address_count is not None:
            pulumi.set(__self__, "ipv6_address_count", ipv6_address_count)
        if ipv6_addresses is not None:
            pulumi.set(__self__, "ipv6_addresses", ipv6_addresses)
        if ipv6_prefix_count is not None:
            pulumi.set(__self__, "ipv6_prefix_count", ipv6_prefix_count)
        if ipv6_prefixes is not None:
            pulumi.set(__self__, "ipv6_prefixes", ipv6_prefixes)
        if network_card_index is not None:
            pulumi.set(__self__, "network_card_index", network_card_index)
        if network_interface_id is not None:
            pulumi.set(__self__, "network_interface_id", network_interface_id)
        if primary_ipv6 is not None:
            pulumi.set(__self__, "primary_ipv6", primary_ipv6)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)
        if private_ip_addresses is not None:
            pulumi.set(__self__, "private_ip_addresses", private_ip_addresses)
        if secondary_private_ip_address_count is not None:
            pulumi.set(__self__, "secondary_private_ip_address_count", secondary_private_ip_address_count)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="associateCarrierIpAddress")
    def associate_carrier_ip_address(self) -> Optional[bool]:
        """
        Associates a Carrier IP address with eth0 for a new network interface.
         Use this option when you launch an instance in a Wavelength Zone and want to associate a Carrier IP address with the network interface. For more information about Carrier IP addresses, see [Carrier IP addresses](https://docs.aws.amazon.com/wavelength/latest/developerguide/how-wavelengths-work.html#provider-owned-ip) in the *Developer Guide*.
        """
        return pulumi.get(self, "associate_carrier_ip_address")

    @property
    @pulumi.getter(name="associatePublicIpAddress")
    def associate_public_ip_address(self) -> Optional[bool]:
        """
        Associates a public IPv4 address with eth0 for a new network interface.
          AWS charges for all public IPv4 addresses, including public IPv4 addresses associated with running instances and Elastic IP addresses. For more information, see the *Public IPv4 Address* tab on the [Amazon VPC pricing page](https://docs.aws.amazon.com/vpc/pricing/).
        """
        return pulumi.get(self, "associate_public_ip_address")

    @property
    @pulumi.getter(name="connectionTrackingSpecification")
    def connection_tracking_specification(self) -> Optional['outputs.LaunchTemplateConnectionTrackingSpecification']:
        """
        A connection tracking specification for the network interface.
        """
        return pulumi.get(self, "connection_tracking_specification")

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[bool]:
        """
        Indicates whether the network interface is deleted when the instance is terminated.
        """
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A description for the network interface.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> Optional[int]:
        """
        The device index for the network interface attachment. Each network interface requires a device index. If you create a launch template that includes secondary network interfaces but not a primary network interface, then you must add a primary network interface as a launch parameter when you launch an instance from the template.
        """
        return pulumi.get(self, "device_index")

    @property
    @pulumi.getter(name="enaSrdSpecification")
    def ena_srd_specification(self) -> Optional['outputs.LaunchTemplateEnaSrdSpecification']:
        """
        The ENA Express configuration for the network interface.
        """
        return pulumi.get(self, "ena_srd_specification")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[str]]:
        """
        The IDs of one or more security groups.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter(name="interfaceType")
    def interface_type(self) -> Optional[str]:
        """
        The type of network interface. To create an Elastic Fabric Adapter (EFA), specify ``efa``. For more information, see [Elastic Fabric Adapter](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/efa.html) in the *Amazon EC2 User Guide*.
         If you are not creating an EFA, specify ``interface`` or omit this parameter.
         Valid values: ``interface`` | ``efa``
        """
        return pulumi.get(self, "interface_type")

    @property
    @pulumi.getter(name="ipv4PrefixCount")
    def ipv4_prefix_count(self) -> Optional[int]:
        """
        The number of IPv4 prefixes to be automatically assigned to the network interface. You cannot use this option if you use the ``Ipv4Prefix`` option.
        """
        return pulumi.get(self, "ipv4_prefix_count")

    @property
    @pulumi.getter(name="ipv4Prefixes")
    def ipv4_prefixes(self) -> Optional[Sequence['outputs.LaunchTemplateIpv4PrefixSpecification']]:
        """
        One or more IPv4 prefixes to be assigned to the network interface. You cannot use this option if you use the ``Ipv4PrefixCount`` option.
        """
        return pulumi.get(self, "ipv4_prefixes")

    @property
    @pulumi.getter(name="ipv6AddressCount")
    def ipv6_address_count(self) -> Optional[int]:
        """
        The number of IPv6 addresses to assign to a network interface. Amazon EC2 automatically selects the IPv6 addresses from the subnet range. You can't use this option if specifying specific IPv6 addresses.
        """
        return pulumi.get(self, "ipv6_address_count")

    @property
    @pulumi.getter(name="ipv6Addresses")
    def ipv6_addresses(self) -> Optional[Sequence['outputs.LaunchTemplateIpv6Add']]:
        """
        One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. You can't use this option if you're specifying a number of IPv6 addresses.
        """
        return pulumi.get(self, "ipv6_addresses")

    @property
    @pulumi.getter(name="ipv6PrefixCount")
    def ipv6_prefix_count(self) -> Optional[int]:
        """
        The number of IPv6 prefixes to be automatically assigned to the network interface. You cannot use this option if you use the ``Ipv6Prefix`` option.
        """
        return pulumi.get(self, "ipv6_prefix_count")

    @property
    @pulumi.getter(name="ipv6Prefixes")
    def ipv6_prefixes(self) -> Optional[Sequence['outputs.LaunchTemplateIpv6PrefixSpecification']]:
        """
        One or more IPv6 prefixes to be assigned to the network interface. You cannot use this option if you use the ``Ipv6PrefixCount`` option.
        """
        return pulumi.get(self, "ipv6_prefixes")

    @property
    @pulumi.getter(name="networkCardIndex")
    def network_card_index(self) -> Optional[int]:
        """
        The index of the network card. Some instance types support multiple network cards. The primary network interface must be assigned to network card index 0. The default is network card index 0.
        """
        return pulumi.get(self, "network_card_index")

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[str]:
        """
        The ID of the network interface.
        """
        return pulumi.get(self, "network_interface_id")

    @property
    @pulumi.getter(name="primaryIpv6")
    def primary_ipv6(self) -> Optional[bool]:
        """
        The primary IPv6 address of the network interface. When you enable an IPv6 GUA address to be a primary IPv6, the first IPv6 GUA will be made the primary IPv6 address until the instance is terminated or the network interface is detached. For more information about primary IPv6 addresses, see [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html).
        """
        return pulumi.get(self, "primary_ipv6")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[str]:
        """
        The primary private IPv4 address of the network interface.
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="privateIpAddresses")
    def private_ip_addresses(self) -> Optional[Sequence['outputs.LaunchTemplatePrivateIpAdd']]:
        """
        One or more private IPv4 addresses.
        """
        return pulumi.get(self, "private_ip_addresses")

    @property
    @pulumi.getter(name="secondaryPrivateIpAddressCount")
    def secondary_private_ip_address_count(self) -> Optional[int]:
        """
        The number of secondary private IPv4 addresses to assign to a network interface.
        """
        return pulumi.get(self, "secondary_private_ip_address_count")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The ID of the subnet for the network interface.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class LaunchTemplateNetworkInterfaceCount(dict):
    """
    The minimum and maximum number of network interfaces.
    """
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        The minimum and maximum number of network interfaces.
        :param int max: The maximum number of network interfaces. To specify no maximum limit, omit this parameter.
        :param int min: The minimum number of network interfaces. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        The maximum number of network interfaces. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        The minimum number of network interfaces. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplatePlacement(dict):
    """
    Specifies the placement of an instance.
      ``Placement`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "groupId":
            suggest = "group_id"
        elif key == "groupName":
            suggest = "group_name"
        elif key == "hostId":
            suggest = "host_id"
        elif key == "hostResourceGroupArn":
            suggest = "host_resource_group_arn"
        elif key == "partitionNumber":
            suggest = "partition_number"
        elif key == "spreadDomain":
            suggest = "spread_domain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplatePlacement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplatePlacement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplatePlacement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 affinity: Optional[str] = None,
                 availability_zone: Optional[str] = None,
                 group_id: Optional[str] = None,
                 group_name: Optional[str] = None,
                 host_id: Optional[str] = None,
                 host_resource_group_arn: Optional[str] = None,
                 partition_number: Optional[int] = None,
                 spread_domain: Optional[str] = None,
                 tenancy: Optional[str] = None):
        """
        Specifies the placement of an instance.
          ``Placement`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        :param str affinity: The affinity setting for an instance on a Dedicated Host.
        :param str availability_zone: The Availability Zone for the instance.
        :param str group_id: The Group Id of a placement group. You must specify the Placement Group *Group Id* to launch an instance in a shared placement group.
        :param str group_name: The name of the placement group for the instance.
        :param str host_id: The ID of the Dedicated Host for the instance.
        :param str host_resource_group_arn: The ARN of the host resource group in which to launch the instances. If you specify a host resource group ARN, omit the *Tenancy* parameter or set it to ``host``.
        :param int partition_number: The number of the partition the instance should launch in. Valid only if the placement group strategy is set to ``partition``.
        :param str spread_domain: Reserved for future use.
        :param str tenancy: The tenancy of the instance. An instance with a tenancy of dedicated runs on single-tenant hardware.
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if host_id is not None:
            pulumi.set(__self__, "host_id", host_id)
        if host_resource_group_arn is not None:
            pulumi.set(__self__, "host_resource_group_arn", host_resource_group_arn)
        if partition_number is not None:
            pulumi.set(__self__, "partition_number", partition_number)
        if spread_domain is not None:
            pulumi.set(__self__, "spread_domain", spread_domain)
        if tenancy is not None:
            pulumi.set(__self__, "tenancy", tenancy)

    @property
    @pulumi.getter
    def affinity(self) -> Optional[str]:
        """
        The affinity setting for an instance on a Dedicated Host.
        """
        return pulumi.get(self, "affinity")

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[str]:
        """
        The Availability Zone for the instance.
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[str]:
        """
        The Group Id of a placement group. You must specify the Placement Group *Group Id* to launch an instance in a shared placement group.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[str]:
        """
        The name of the placement group for the instance.
        """
        return pulumi.get(self, "group_name")

    @property
    @pulumi.getter(name="hostId")
    def host_id(self) -> Optional[str]:
        """
        The ID of the Dedicated Host for the instance.
        """
        return pulumi.get(self, "host_id")

    @property
    @pulumi.getter(name="hostResourceGroupArn")
    def host_resource_group_arn(self) -> Optional[str]:
        """
        The ARN of the host resource group in which to launch the instances. If you specify a host resource group ARN, omit the *Tenancy* parameter or set it to ``host``.
        """
        return pulumi.get(self, "host_resource_group_arn")

    @property
    @pulumi.getter(name="partitionNumber")
    def partition_number(self) -> Optional[int]:
        """
        The number of the partition the instance should launch in. Valid only if the placement group strategy is set to ``partition``.
        """
        return pulumi.get(self, "partition_number")

    @property
    @pulumi.getter(name="spreadDomain")
    def spread_domain(self) -> Optional[str]:
        """
        Reserved for future use.
        """
        return pulumi.get(self, "spread_domain")

    @property
    @pulumi.getter
    def tenancy(self) -> Optional[str]:
        """
        The tenancy of the instance. An instance with a tenancy of dedicated runs on single-tenant hardware.
        """
        return pulumi.get(self, "tenancy")


@pulumi.output_type
class LaunchTemplatePrivateDnsNameOptions(dict):
    """
    The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries should be handled. For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *User Guide*.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableResourceNameDnsARecord":
            suggest = "enable_resource_name_dns_a_record"
        elif key == "enableResourceNameDnsAaaaRecord":
            suggest = "enable_resource_name_dns_aaaa_record"
        elif key == "hostnameType":
            suggest = "hostname_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplatePrivateDnsNameOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplatePrivateDnsNameOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplatePrivateDnsNameOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_resource_name_dns_a_record: Optional[bool] = None,
                 enable_resource_name_dns_aaaa_record: Optional[bool] = None,
                 hostname_type: Optional[str] = None):
        """
        The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries should be handled. For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *User Guide*.
        :param bool enable_resource_name_dns_a_record: Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
        :param bool enable_resource_name_dns_aaaa_record: Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
        :param str hostname_type: The type of hostname for EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *User Guide*.
        """
        if enable_resource_name_dns_a_record is not None:
            pulumi.set(__self__, "enable_resource_name_dns_a_record", enable_resource_name_dns_a_record)
        if enable_resource_name_dns_aaaa_record is not None:
            pulumi.set(__self__, "enable_resource_name_dns_aaaa_record", enable_resource_name_dns_aaaa_record)
        if hostname_type is not None:
            pulumi.set(__self__, "hostname_type", hostname_type)

    @property
    @pulumi.getter(name="enableResourceNameDnsARecord")
    def enable_resource_name_dns_a_record(self) -> Optional[bool]:
        """
        Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
        """
        return pulumi.get(self, "enable_resource_name_dns_a_record")

    @property
    @pulumi.getter(name="enableResourceNameDnsAaaaRecord")
    def enable_resource_name_dns_aaaa_record(self) -> Optional[bool]:
        """
        Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
        """
        return pulumi.get(self, "enable_resource_name_dns_aaaa_record")

    @property
    @pulumi.getter(name="hostnameType")
    def hostname_type(self) -> Optional[str]:
        """
        The type of hostname for EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *User Guide*.
        """
        return pulumi.get(self, "hostname_type")


@pulumi.output_type
class LaunchTemplatePrivateIpAdd(dict):
    """
    Specifies a secondary private IPv4 address for a network interface.
      ``PrivateIpAdd`` is a property of [AWS::EC2::LaunchTemplate NetworkInterface](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIpAddress":
            suggest = "private_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplatePrivateIpAdd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplatePrivateIpAdd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplatePrivateIpAdd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 primary: Optional[bool] = None,
                 private_ip_address: Optional[str] = None):
        """
        Specifies a secondary private IPv4 address for a network interface.
          ``PrivateIpAdd`` is a property of [AWS::EC2::LaunchTemplate NetworkInterface](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html).
        :param bool primary: Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.
        :param str private_ip_address: The private IPv4 address.
        """
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)

    @property
    @pulumi.getter
    def primary(self) -> Optional[bool]:
        """
        Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.
        """
        return pulumi.get(self, "primary")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[str]:
        """
        The private IPv4 address.
        """
        return pulumi.get(self, "private_ip_address")


@pulumi.output_type
class LaunchTemplateSpotOptions(dict):
    """
    Specifies options for Spot Instances.
      ``SpotOptions`` is a property of [AWS::EC2::LaunchTemplate InstanceMarketOptions](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancemarketoptions.html).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockDurationMinutes":
            suggest = "block_duration_minutes"
        elif key == "instanceInterruptionBehavior":
            suggest = "instance_interruption_behavior"
        elif key == "maxPrice":
            suggest = "max_price"
        elif key == "spotInstanceType":
            suggest = "spot_instance_type"
        elif key == "validUntil":
            suggest = "valid_until"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateSpotOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateSpotOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateSpotOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 block_duration_minutes: Optional[int] = None,
                 instance_interruption_behavior: Optional[str] = None,
                 max_price: Optional[str] = None,
                 spot_instance_type: Optional[str] = None,
                 valid_until: Optional[str] = None):
        """
        Specifies options for Spot Instances.
          ``SpotOptions`` is a property of [AWS::EC2::LaunchTemplate InstanceMarketOptions](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancemarketoptions.html).
        :param int block_duration_minutes: Deprecated.
        :param str instance_interruption_behavior: The behavior when a Spot Instance is interrupted. The default is ``terminate``.
        :param str max_price: The maximum hourly price you're willing to pay for the Spot Instances. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.
                 If you specify a maximum price, your Spot Instances will be interrupted more frequently than if you do not specify this parameter.
        :param str spot_instance_type: The Spot Instance request type.
                If you are using Spot Instances with an Auto Scaling group, use ``one-time`` requests, as the ASlong service handles requesting new Spot Instances whenever the group is below its desired capacity.
        :param str valid_until: The end date of the request, in UTC format (*YYYY-MM-DD*T*HH:MM:SS*Z). Supported only for persistent requests.
                 +  For a persistent request, the request remains active until the ``ValidUntil`` date and time is reached. Otherwise, the request remains active until you cancel it.
                 +  For a one-time request, ``ValidUntil`` is not supported. The request remains active until all instances launch or you cancel the request.
                 
                Default: 7 days from the current date
        """
        if block_duration_minutes is not None:
            pulumi.set(__self__, "block_duration_minutes", block_duration_minutes)
        if instance_interruption_behavior is not None:
            pulumi.set(__self__, "instance_interruption_behavior", instance_interruption_behavior)
        if max_price is not None:
            pulumi.set(__self__, "max_price", max_price)
        if spot_instance_type is not None:
            pulumi.set(__self__, "spot_instance_type", spot_instance_type)
        if valid_until is not None:
            pulumi.set(__self__, "valid_until", valid_until)

    @property
    @pulumi.getter(name="blockDurationMinutes")
    def block_duration_minutes(self) -> Optional[int]:
        """
        Deprecated.
        """
        return pulumi.get(self, "block_duration_minutes")

    @property
    @pulumi.getter(name="instanceInterruptionBehavior")
    def instance_interruption_behavior(self) -> Optional[str]:
        """
        The behavior when a Spot Instance is interrupted. The default is ``terminate``.
        """
        return pulumi.get(self, "instance_interruption_behavior")

    @property
    @pulumi.getter(name="maxPrice")
    def max_price(self) -> Optional[str]:
        """
        The maximum hourly price you're willing to pay for the Spot Instances. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.
          If you specify a maximum price, your Spot Instances will be interrupted more frequently than if you do not specify this parameter.
        """
        return pulumi.get(self, "max_price")

    @property
    @pulumi.getter(name="spotInstanceType")
    def spot_instance_type(self) -> Optional[str]:
        """
        The Spot Instance request type.
         If you are using Spot Instances with an Auto Scaling group, use ``one-time`` requests, as the ASlong service handles requesting new Spot Instances whenever the group is below its desired capacity.
        """
        return pulumi.get(self, "spot_instance_type")

    @property
    @pulumi.getter(name="validUntil")
    def valid_until(self) -> Optional[str]:
        """
        The end date of the request, in UTC format (*YYYY-MM-DD*T*HH:MM:SS*Z). Supported only for persistent requests.
          +  For a persistent request, the request remains active until the ``ValidUntil`` date and time is reached. Otherwise, the request remains active until you cancel it.
          +  For a one-time request, ``ValidUntil`` is not supported. The request remains active until all instances launch or you cancel the request.
          
         Default: 7 days from the current date
        """
        return pulumi.get(self, "valid_until")


@pulumi.output_type
class LaunchTemplateTag(dict):
    """
    Specifies a tag. For more information, see [Resource tags](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html).
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        Specifies a tag. For more information, see [Resource tags](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html).
        :param str key: The tag key.
        :param str value: The tag value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The tag value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class LaunchTemplateTagSpecification(dict):
    """
    Specifies the tags to apply to the launch template during creation.
      ``LaunchTemplateTagSpecification`` is a property of [AWS::EC2::LaunchTemplate](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateTagSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateTagSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateTagSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_type: Optional[str] = None,
                 tags: Optional[Sequence['outputs.LaunchTemplateTag']] = None):
        """
        Specifies the tags to apply to the launch template during creation.
          ``LaunchTemplateTagSpecification`` is a property of [AWS::EC2::LaunchTemplate](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html).
        :param str resource_type: The type of resource. To tag a launch template, ``ResourceType`` must be ``launch-template``.
        :param Sequence['LaunchTemplateTag'] tags: The tags for the resource.
        """
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[str]:
        """
        The type of resource. To tag a launch template, ``ResourceType`` must be ``launch-template``.
        """
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.LaunchTemplateTag']]:
        """
        The tags for the resource.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class LaunchTemplateTotalLocalStorageGb(dict):
    """
    The minimum and maximum amount of total local storage, in GB.
    """
    def __init__(__self__, *,
                 max: Optional[float] = None,
                 min: Optional[float] = None):
        """
        The minimum and maximum amount of total local storage, in GB.
        :param float max: The maximum amount of total local storage, in GB. To specify no maximum limit, omit this parameter.
        :param float min: The minimum amount of total local storage, in GB. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        """
        The maximum amount of total local storage, in GB. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        """
        The minimum amount of total local storage, in GB. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateVCpuCount(dict):
    """
    The minimum and maximum number of vCPUs.
    """
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        The minimum and maximum number of vCPUs.
        :param int max: The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
        :param int min: The minimum number of vCPUs. To specify no minimum limit, specify ``0``.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        The minimum number of vCPUs. To specify no minimum limit, specify ``0``.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class NetworkInsightsAccessScopeAccessScopePathRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "throughResources":
            suggest = "through_resources"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAccessScopeAccessScopePathRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAccessScopeAccessScopePathRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAccessScopeAccessScopePathRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: Optional['outputs.NetworkInsightsAccessScopePathStatementRequest'] = None,
                 source: Optional['outputs.NetworkInsightsAccessScopePathStatementRequest'] = None,
                 through_resources: Optional[Sequence['outputs.NetworkInsightsAccessScopeThroughResourcesStatementRequest']] = None):
        """
        :param 'NetworkInsightsAccessScopePathStatementRequest' destination: The destination.
        :param 'NetworkInsightsAccessScopePathStatementRequest' source: The source.
        :param Sequence['NetworkInsightsAccessScopeThroughResourcesStatementRequest'] through_resources: The through resources.
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if through_resources is not None:
            pulumi.set(__self__, "through_resources", through_resources)

    @property
    @pulumi.getter
    def destination(self) -> Optional['outputs.NetworkInsightsAccessScopePathStatementRequest']:
        """
        The destination.
        """
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter
    def source(self) -> Optional['outputs.NetworkInsightsAccessScopePathStatementRequest']:
        """
        The source.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="throughResources")
    def through_resources(self) -> Optional[Sequence['outputs.NetworkInsightsAccessScopeThroughResourcesStatementRequest']]:
        """
        The through resources.
        """
        return pulumi.get(self, "through_resources")


@pulumi.output_type
class NetworkInsightsAccessScopePacketHeaderStatementRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddresses":
            suggest = "destination_addresses"
        elif key == "destinationPorts":
            suggest = "destination_ports"
        elif key == "destinationPrefixLists":
            suggest = "destination_prefix_lists"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourcePorts":
            suggest = "source_ports"
        elif key == "sourcePrefixLists":
            suggest = "source_prefix_lists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAccessScopePacketHeaderStatementRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAccessScopePacketHeaderStatementRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAccessScopePacketHeaderStatementRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_addresses: Optional[Sequence[str]] = None,
                 destination_ports: Optional[Sequence[str]] = None,
                 destination_prefix_lists: Optional[Sequence[str]] = None,
                 protocols: Optional[Sequence['NetworkInsightsAccessScopeProtocol']] = None,
                 source_addresses: Optional[Sequence[str]] = None,
                 source_ports: Optional[Sequence[str]] = None,
                 source_prefix_lists: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] destination_addresses: The destination addresses.
        :param Sequence[str] destination_ports: The destination ports.
        :param Sequence[str] destination_prefix_lists: The destination prefix lists.
        :param Sequence['NetworkInsightsAccessScopeProtocol'] protocols: The protocols.
        :param Sequence[str] source_addresses: The source addresses.
        :param Sequence[str] source_ports: The source ports.
        :param Sequence[str] source_prefix_lists: The source prefix lists.
        """
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if destination_ports is not None:
            pulumi.set(__self__, "destination_ports", destination_ports)
        if destination_prefix_lists is not None:
            pulumi.set(__self__, "destination_prefix_lists", destination_prefix_lists)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_ports is not None:
            pulumi.set(__self__, "source_ports", source_ports)
        if source_prefix_lists is not None:
            pulumi.set(__self__, "source_prefix_lists", source_prefix_lists)

    @property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[str]]:
        """
        The destination addresses.
        """
        return pulumi.get(self, "destination_addresses")

    @property
    @pulumi.getter(name="destinationPorts")
    def destination_ports(self) -> Optional[Sequence[str]]:
        """
        The destination ports.
        """
        return pulumi.get(self, "destination_ports")

    @property
    @pulumi.getter(name="destinationPrefixLists")
    def destination_prefix_lists(self) -> Optional[Sequence[str]]:
        """
        The destination prefix lists.
        """
        return pulumi.get(self, "destination_prefix_lists")

    @property
    @pulumi.getter
    def protocols(self) -> Optional[Sequence['NetworkInsightsAccessScopeProtocol']]:
        """
        The protocols.
        """
        return pulumi.get(self, "protocols")

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[str]]:
        """
        The source addresses.
        """
        return pulumi.get(self, "source_addresses")

    @property
    @pulumi.getter(name="sourcePorts")
    def source_ports(self) -> Optional[Sequence[str]]:
        """
        The source ports.
        """
        return pulumi.get(self, "source_ports")

    @property
    @pulumi.getter(name="sourcePrefixLists")
    def source_prefix_lists(self) -> Optional[Sequence[str]]:
        """
        The source prefix lists.
        """
        return pulumi.get(self, "source_prefix_lists")


@pulumi.output_type
class NetworkInsightsAccessScopePathStatementRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "packetHeaderStatement":
            suggest = "packet_header_statement"
        elif key == "resourceStatement":
            suggest = "resource_statement"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAccessScopePathStatementRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAccessScopePathStatementRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAccessScopePathStatementRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 packet_header_statement: Optional['outputs.NetworkInsightsAccessScopePacketHeaderStatementRequest'] = None,
                 resource_statement: Optional['outputs.NetworkInsightsAccessScopeResourceStatementRequest'] = None):
        """
        :param 'NetworkInsightsAccessScopePacketHeaderStatementRequest' packet_header_statement: The packet header statement.
        :param 'NetworkInsightsAccessScopeResourceStatementRequest' resource_statement: The resource statement.
        """
        if packet_header_statement is not None:
            pulumi.set(__self__, "packet_header_statement", packet_header_statement)
        if resource_statement is not None:
            pulumi.set(__self__, "resource_statement", resource_statement)

    @property
    @pulumi.getter(name="packetHeaderStatement")
    def packet_header_statement(self) -> Optional['outputs.NetworkInsightsAccessScopePacketHeaderStatementRequest']:
        """
        The packet header statement.
        """
        return pulumi.get(self, "packet_header_statement")

    @property
    @pulumi.getter(name="resourceStatement")
    def resource_statement(self) -> Optional['outputs.NetworkInsightsAccessScopeResourceStatementRequest']:
        """
        The resource statement.
        """
        return pulumi.get(self, "resource_statement")


@pulumi.output_type
class NetworkInsightsAccessScopeResourceStatementRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceTypes":
            suggest = "resource_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAccessScopeResourceStatementRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAccessScopeResourceStatementRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAccessScopeResourceStatementRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_types: Optional[Sequence[str]] = None,
                 resources: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] resource_types: The resource types.
        :param Sequence[str] resources: The resources.
        """
        if resource_types is not None:
            pulumi.set(__self__, "resource_types", resource_types)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter(name="resourceTypes")
    def resource_types(self) -> Optional[Sequence[str]]:
        """
        The resource types.
        """
        return pulumi.get(self, "resource_types")

    @property
    @pulumi.getter
    def resources(self) -> Optional[Sequence[str]]:
        """
        The resources.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class NetworkInsightsAccessScopeThroughResourcesStatementRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceStatement":
            suggest = "resource_statement"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAccessScopeThroughResourcesStatementRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAccessScopeThroughResourcesStatementRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAccessScopeThroughResourcesStatementRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_statement: Optional['outputs.NetworkInsightsAccessScopeResourceStatementRequest'] = None):
        """
        :param 'NetworkInsightsAccessScopeResourceStatementRequest' resource_statement: The resource statement.
        """
        if resource_statement is not None:
            pulumi.set(__self__, "resource_statement", resource_statement)

    @property
    @pulumi.getter(name="resourceStatement")
    def resource_statement(self) -> Optional['outputs.NetworkInsightsAccessScopeResourceStatementRequest']:
        """
        The resource statement.
        """
        return pulumi.get(self, "resource_statement")


@pulumi.output_type
class NetworkInsightsAnalysisAdditionalDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalDetailType":
            suggest = "additional_detail_type"
        elif key == "loadBalancers":
            suggest = "load_balancers"
        elif key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisAdditionalDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisAdditionalDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisAdditionalDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_detail_type: Optional[str] = None,
                 component: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 load_balancers: Optional[Sequence['outputs.NetworkInsightsAnalysisAnalysisComponent']] = None,
                 service_name: Optional[str] = None):
        """
        :param str additional_detail_type: The additional detail code.
        :param 'NetworkInsightsAnalysisAnalysisComponent' component: The path component.
        :param Sequence['NetworkInsightsAnalysisAnalysisComponent'] load_balancers: The load balancers.
        :param str service_name: The name of the VPC endpoint service.
        """
        if additional_detail_type is not None:
            pulumi.set(__self__, "additional_detail_type", additional_detail_type)
        if component is not None:
            pulumi.set(__self__, "component", component)
        if load_balancers is not None:
            pulumi.set(__self__, "load_balancers", load_balancers)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter(name="additionalDetailType")
    def additional_detail_type(self) -> Optional[str]:
        """
        The additional detail code.
        """
        return pulumi.get(self, "additional_detail_type")

    @property
    @pulumi.getter
    def component(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The path component.
        """
        return pulumi.get(self, "component")

    @property
    @pulumi.getter(name="loadBalancers")
    def load_balancers(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisAnalysisComponent']]:
        """
        The load balancers.
        """
        return pulumi.get(self, "load_balancers")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        """
        The name of the VPC endpoint service.
        """
        return pulumi.get(self, "service_name")


@pulumi.output_type
class NetworkInsightsAnalysisAlternatePathHint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "componentArn":
            suggest = "component_arn"
        elif key == "componentId":
            suggest = "component_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisAlternatePathHint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisAlternatePathHint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisAlternatePathHint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component_arn: Optional[str] = None,
                 component_id: Optional[str] = None):
        """
        :param str component_arn: The Amazon Resource Name (ARN) of the component.
        :param str component_id: The ID of the component.
        """
        if component_arn is not None:
            pulumi.set(__self__, "component_arn", component_arn)
        if component_id is not None:
            pulumi.set(__self__, "component_id", component_id)

    @property
    @pulumi.getter(name="componentArn")
    def component_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the component.
        """
        return pulumi.get(self, "component_arn")

    @property
    @pulumi.getter(name="componentId")
    def component_id(self) -> Optional[str]:
        """
        The ID of the component.
        """
        return pulumi.get(self, "component_id")


@pulumi.output_type
class NetworkInsightsAnalysisAnalysisAclRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portRange":
            suggest = "port_range"
        elif key == "ruleAction":
            suggest = "rule_action"
        elif key == "ruleNumber":
            suggest = "rule_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisAnalysisAclRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisAnalysisAclRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisAnalysisAclRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr: Optional[str] = None,
                 egress: Optional[bool] = None,
                 port_range: Optional['outputs.NetworkInsightsAnalysisPortRange'] = None,
                 protocol: Optional[str] = None,
                 rule_action: Optional[str] = None,
                 rule_number: Optional[int] = None):
        """
        :param str cidr: The IPv4 address range, in CIDR notation.
        :param bool egress: Indicates whether the rule is an outbound rule.
        :param 'NetworkInsightsAnalysisPortRange' port_range: The range of ports.
        :param str protocol: The protocol.
        :param str rule_action: Indicates whether to allow or deny traffic that matches the rule.
        :param int rule_number: The rule number.
        """
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if egress is not None:
            pulumi.set(__self__, "egress", egress)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if rule_action is not None:
            pulumi.set(__self__, "rule_action", rule_action)
        if rule_number is not None:
            pulumi.set(__self__, "rule_number", rule_number)

    @property
    @pulumi.getter
    def cidr(self) -> Optional[str]:
        """
        The IPv4 address range, in CIDR notation.
        """
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def egress(self) -> Optional[bool]:
        """
        Indicates whether the rule is an outbound rule.
        """
        return pulumi.get(self, "egress")

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional['outputs.NetworkInsightsAnalysisPortRange']:
        """
        The range of ports.
        """
        return pulumi.get(self, "port_range")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The protocol.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="ruleAction")
    def rule_action(self) -> Optional[str]:
        """
        Indicates whether to allow or deny traffic that matches the rule.
        """
        return pulumi.get(self, "rule_action")

    @property
    @pulumi.getter(name="ruleNumber")
    def rule_number(self) -> Optional[int]:
        """
        The rule number.
        """
        return pulumi.get(self, "rule_number")


@pulumi.output_type
class NetworkInsightsAnalysisAnalysisComponent(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None):
        """
        :param str arn: The Amazon Resource Name (ARN) of the component.
        :param str id: The ID of the component.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the component.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the component.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class NetworkInsightsAnalysisAnalysisLoadBalancerListener(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instancePort":
            suggest = "instance_port"
        elif key == "loadBalancerPort":
            suggest = "load_balancer_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisAnalysisLoadBalancerListener. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisAnalysisLoadBalancerListener.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisAnalysisLoadBalancerListener.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_port: Optional[int] = None,
                 load_balancer_port: Optional[int] = None):
        """
        :param int instance_port: [Classic Load Balancers] The back-end port for the listener.
        :param int load_balancer_port: The port on which the load balancer is listening.
        """
        if instance_port is not None:
            pulumi.set(__self__, "instance_port", instance_port)
        if load_balancer_port is not None:
            pulumi.set(__self__, "load_balancer_port", load_balancer_port)

    @property
    @pulumi.getter(name="instancePort")
    def instance_port(self) -> Optional[int]:
        """
        [Classic Load Balancers] The back-end port for the listener.
        """
        return pulumi.get(self, "instance_port")

    @property
    @pulumi.getter(name="loadBalancerPort")
    def load_balancer_port(self) -> Optional[int]:
        """
        The port on which the load balancer is listening.
        """
        return pulumi.get(self, "load_balancer_port")


@pulumi.output_type
class NetworkInsightsAnalysisAnalysisLoadBalancerTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisAnalysisLoadBalancerTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisAnalysisLoadBalancerTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisAnalysisLoadBalancerTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[str] = None,
                 availability_zone: Optional[str] = None,
                 instance: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 port: Optional[int] = None):
        """
        :param str address: The IP address.
        :param str availability_zone: The Availability Zone.
        :param 'NetworkInsightsAnalysisAnalysisComponent' instance: Information about the instance.
        :param int port: The port on which the target is listening.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if instance is not None:
            pulumi.set(__self__, "instance", instance)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        The IP address.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[str]:
        """
        The Availability Zone.
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter
    def instance(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        Information about the instance.
        """
        return pulumi.get(self, "instance")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port on which the target is listening.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class NetworkInsightsAnalysisAnalysisPacketHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddresses":
            suggest = "destination_addresses"
        elif key == "destinationPortRanges":
            suggest = "destination_port_ranges"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourcePortRanges":
            suggest = "source_port_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisAnalysisPacketHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisAnalysisPacketHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisAnalysisPacketHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_addresses: Optional[Sequence[str]] = None,
                 destination_port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisPortRange']] = None,
                 protocol: Optional[str] = None,
                 source_addresses: Optional[Sequence[str]] = None,
                 source_port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisPortRange']] = None):
        """
        :param Sequence[str] destination_addresses: The destination addresses.
        :param Sequence['NetworkInsightsAnalysisPortRange'] destination_port_ranges: The destination port ranges.
        :param str protocol: The protocol.
        :param Sequence[str] source_addresses: The source addresses.
        :param Sequence['NetworkInsightsAnalysisPortRange'] source_port_ranges: The source port ranges.
        """
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if destination_port_ranges is not None:
            pulumi.set(__self__, "destination_port_ranges", destination_port_ranges)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_port_ranges is not None:
            pulumi.set(__self__, "source_port_ranges", source_port_ranges)

    @property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[str]]:
        """
        The destination addresses.
        """
        return pulumi.get(self, "destination_addresses")

    @property
    @pulumi.getter(name="destinationPortRanges")
    def destination_port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisPortRange']]:
        """
        The destination port ranges.
        """
        return pulumi.get(self, "destination_port_ranges")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The protocol.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[str]]:
        """
        The source addresses.
        """
        return pulumi.get(self, "source_addresses")

    @property
    @pulumi.getter(name="sourcePortRanges")
    def source_port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisPortRange']]:
        """
        The source port ranges.
        """
        return pulumi.get(self, "source_port_ranges")


@pulumi.output_type
class NetworkInsightsAnalysisAnalysisRouteTableRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationCidr":
            suggest = "destination_cidr"
        elif key == "destinationPrefixListId":
            suggest = "destination_prefix_list_id"
        elif key == "egressOnlyInternetGatewayId":
            suggest = "egress_only_internet_gateway_id"
        elif key == "gatewayId":
            suggest = "gateway_id"
        elif key == "instanceId":
            suggest = "instance_id"
        elif key == "natGatewayId":
            suggest = "nat_gateway_id"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "transitGatewayId":
            suggest = "transit_gateway_id"
        elif key == "vpcPeeringConnectionId":
            suggest = "vpc_peering_connection_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisAnalysisRouteTableRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisAnalysisRouteTableRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisAnalysisRouteTableRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_cidr: Optional[str] = None,
                 destination_prefix_list_id: Optional[str] = None,
                 egress_only_internet_gateway_id: Optional[str] = None,
                 gateway_id: Optional[str] = None,
                 instance_id: Optional[str] = None,
                 nat_gateway_id: Optional[str] = None,
                 network_interface_id: Optional[str] = None,
                 origin: Optional[str] = None,
                 state: Optional[str] = None,
                 transit_gateway_id: Optional[str] = None,
                 vpc_peering_connection_id: Optional[str] = None):
        """
        :param str destination_cidr: The destination IPv4 address, in CIDR notation.
        :param str destination_prefix_list_id: The prefix of the AWS service.
        :param str egress_only_internet_gateway_id: The ID of an egress-only internet gateway.
        :param str gateway_id: The ID of the gateway, such as an internet gateway or virtual private gateway.
        :param str instance_id: The ID of the instance, such as a NAT instance.
        :param str nat_gateway_id: The ID of a NAT gateway.
        :param str network_interface_id: The ID of a network interface.
        :param str origin: Describes how the route was created. The following are the possible values:
               
               - CreateRouteTable - The route was automatically created when the route table was created.
               - CreateRoute - The route was manually added to the route table.
               - EnableVgwRoutePropagation - The route was propagated by route propagation.
        :param str state: The state. The following are the possible values:
               
               - active
               - blackhole
        :param str transit_gateway_id: The ID of a transit gateway.
        :param str vpc_peering_connection_id: The ID of a VPC peering connection.
        """
        if destination_cidr is not None:
            pulumi.set(__self__, "destination_cidr", destination_cidr)
        if destination_prefix_list_id is not None:
            pulumi.set(__self__, "destination_prefix_list_id", destination_prefix_list_id)
        if egress_only_internet_gateway_id is not None:
            pulumi.set(__self__, "egress_only_internet_gateway_id", egress_only_internet_gateway_id)
        if gateway_id is not None:
            pulumi.set(__self__, "gateway_id", gateway_id)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if nat_gateway_id is not None:
            pulumi.set(__self__, "nat_gateway_id", nat_gateway_id)
        if network_interface_id is not None:
            pulumi.set(__self__, "network_interface_id", network_interface_id)
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if transit_gateway_id is not None:
            pulumi.set(__self__, "transit_gateway_id", transit_gateway_id)
        if vpc_peering_connection_id is not None:
            pulumi.set(__self__, "vpc_peering_connection_id", vpc_peering_connection_id)

    @property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> Optional[str]:
        """
        The destination IPv4 address, in CIDR notation.
        """
        return pulumi.get(self, "destination_cidr")

    @property
    @pulumi.getter(name="destinationPrefixListId")
    def destination_prefix_list_id(self) -> Optional[str]:
        """
        The prefix of the AWS service.
        """
        return pulumi.get(self, "destination_prefix_list_id")

    @property
    @pulumi.getter(name="egressOnlyInternetGatewayId")
    def egress_only_internet_gateway_id(self) -> Optional[str]:
        """
        The ID of an egress-only internet gateway.
        """
        return pulumi.get(self, "egress_only_internet_gateway_id")

    @property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> Optional[str]:
        """
        The ID of the gateway, such as an internet gateway or virtual private gateway.
        """
        return pulumi.get(self, "gateway_id")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[str]:
        """
        The ID of the instance, such as a NAT instance.
        """
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter(name="natGatewayId")
    def nat_gateway_id(self) -> Optional[str]:
        """
        The ID of a NAT gateway.
        """
        return pulumi.get(self, "nat_gateway_id")

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[str]:
        """
        The ID of a network interface.
        """
        return pulumi.get(self, "network_interface_id")

    @property
    @pulumi.getter
    def origin(self) -> Optional[str]:
        """
        Describes how the route was created. The following are the possible values:

        - CreateRouteTable - The route was automatically created when the route table was created.
        - CreateRoute - The route was manually added to the route table.
        - EnableVgwRoutePropagation - The route was propagated by route propagation.
        """
        return pulumi.get(self, "origin")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        The state. The following are the possible values:

        - active
        - blackhole
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="transitGatewayId")
    def transit_gateway_id(self) -> Optional[str]:
        """
        The ID of a transit gateway.
        """
        return pulumi.get(self, "transit_gateway_id")

    @property
    @pulumi.getter(name="vpcPeeringConnectionId")
    def vpc_peering_connection_id(self) -> Optional[str]:
        """
        The ID of a VPC peering connection.
        """
        return pulumi.get(self, "vpc_peering_connection_id")


@pulumi.output_type
class NetworkInsightsAnalysisAnalysisSecurityGroupRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portRange":
            suggest = "port_range"
        elif key == "prefixListId":
            suggest = "prefix_list_id"
        elif key == "securityGroupId":
            suggest = "security_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisAnalysisSecurityGroupRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisAnalysisSecurityGroupRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisAnalysisSecurityGroupRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr: Optional[str] = None,
                 direction: Optional[str] = None,
                 port_range: Optional['outputs.NetworkInsightsAnalysisPortRange'] = None,
                 prefix_list_id: Optional[str] = None,
                 protocol: Optional[str] = None,
                 security_group_id: Optional[str] = None):
        """
        :param str cidr: The IPv4 address range, in CIDR notation.
        :param str direction: The direction. The following are the possible values:
               
               - egress
               - ingress
        :param 'NetworkInsightsAnalysisPortRange' port_range: The port range.
        :param str prefix_list_id: The prefix list ID.
        :param str protocol: The protocol name.
        :param str security_group_id: The security group ID.
        """
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if prefix_list_id is not None:
            pulumi.set(__self__, "prefix_list_id", prefix_list_id)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if security_group_id is not None:
            pulumi.set(__self__, "security_group_id", security_group_id)

    @property
    @pulumi.getter
    def cidr(self) -> Optional[str]:
        """
        The IPv4 address range, in CIDR notation.
        """
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The direction. The following are the possible values:

        - egress
        - ingress
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional['outputs.NetworkInsightsAnalysisPortRange']:
        """
        The port range.
        """
        return pulumi.get(self, "port_range")

    @property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> Optional[str]:
        """
        The prefix list ID.
        """
        return pulumi.get(self, "prefix_list_id")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The protocol name.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> Optional[str]:
        """
        The security group ID.
        """
        return pulumi.get(self, "security_group_id")


@pulumi.output_type
class NetworkInsightsAnalysisExplanation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aclRule":
            suggest = "acl_rule"
        elif key == "attachedTo":
            suggest = "attached_to"
        elif key == "availabilityZones":
            suggest = "availability_zones"
        elif key == "classicLoadBalancerListener":
            suggest = "classic_load_balancer_listener"
        elif key == "componentAccount":
            suggest = "component_account"
        elif key == "componentRegion":
            suggest = "component_region"
        elif key == "customerGateway":
            suggest = "customer_gateway"
        elif key == "destinationVpc":
            suggest = "destination_vpc"
        elif key == "elasticLoadBalancerListener":
            suggest = "elastic_load_balancer_listener"
        elif key == "explanationCode":
            suggest = "explanation_code"
        elif key == "ingressRouteTable":
            suggest = "ingress_route_table"
        elif key == "internetGateway":
            suggest = "internet_gateway"
        elif key == "loadBalancerArn":
            suggest = "load_balancer_arn"
        elif key == "loadBalancerListenerPort":
            suggest = "load_balancer_listener_port"
        elif key == "loadBalancerTarget":
            suggest = "load_balancer_target"
        elif key == "loadBalancerTargetGroup":
            suggest = "load_balancer_target_group"
        elif key == "loadBalancerTargetGroups":
            suggest = "load_balancer_target_groups"
        elif key == "loadBalancerTargetPort":
            suggest = "load_balancer_target_port"
        elif key == "missingComponent":
            suggest = "missing_component"
        elif key == "natGateway":
            suggest = "nat_gateway"
        elif key == "networkInterface":
            suggest = "network_interface"
        elif key == "packetField":
            suggest = "packet_field"
        elif key == "portRanges":
            suggest = "port_ranges"
        elif key == "prefixList":
            suggest = "prefix_list"
        elif key == "routeTable":
            suggest = "route_table"
        elif key == "routeTableRoute":
            suggest = "route_table_route"
        elif key == "securityGroup":
            suggest = "security_group"
        elif key == "securityGroupRule":
            suggest = "security_group_rule"
        elif key == "securityGroups":
            suggest = "security_groups"
        elif key == "sourceVpc":
            suggest = "source_vpc"
        elif key == "subnetRouteTable":
            suggest = "subnet_route_table"
        elif key == "transitGateway":
            suggest = "transit_gateway"
        elif key == "transitGatewayAttachment":
            suggest = "transit_gateway_attachment"
        elif key == "transitGatewayRouteTable":
            suggest = "transit_gateway_route_table"
        elif key == "transitGatewayRouteTableRoute":
            suggest = "transit_gateway_route_table_route"
        elif key == "vpcEndpoint":
            suggest = "vpc_endpoint"
        elif key == "vpcPeeringConnection":
            suggest = "vpc_peering_connection"
        elif key == "vpnConnection":
            suggest = "vpn_connection"
        elif key == "vpnGateway":
            suggest = "vpn_gateway"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisExplanation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisExplanation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisExplanation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acl: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 acl_rule: Optional['outputs.NetworkInsightsAnalysisAnalysisAclRule'] = None,
                 address: Optional[str] = None,
                 addresses: Optional[Sequence[str]] = None,
                 attached_to: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 availability_zones: Optional[Sequence[str]] = None,
                 cidrs: Optional[Sequence[str]] = None,
                 classic_load_balancer_listener: Optional['outputs.NetworkInsightsAnalysisAnalysisLoadBalancerListener'] = None,
                 component: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 component_account: Optional[str] = None,
                 component_region: Optional[str] = None,
                 customer_gateway: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 destination: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 destination_vpc: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 direction: Optional[str] = None,
                 elastic_load_balancer_listener: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 explanation_code: Optional[str] = None,
                 ingress_route_table: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 internet_gateway: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 load_balancer_arn: Optional[str] = None,
                 load_balancer_listener_port: Optional[int] = None,
                 load_balancer_target: Optional['outputs.NetworkInsightsAnalysisAnalysisLoadBalancerTarget'] = None,
                 load_balancer_target_group: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 load_balancer_target_groups: Optional[Sequence['outputs.NetworkInsightsAnalysisAnalysisComponent']] = None,
                 load_balancer_target_port: Optional[int] = None,
                 missing_component: Optional[str] = None,
                 nat_gateway: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 network_interface: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 packet_field: Optional[str] = None,
                 port: Optional[int] = None,
                 port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisPortRange']] = None,
                 prefix_list: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 protocols: Optional[Sequence[str]] = None,
                 route_table: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 route_table_route: Optional['outputs.NetworkInsightsAnalysisAnalysisRouteTableRoute'] = None,
                 security_group: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 security_group_rule: Optional['outputs.NetworkInsightsAnalysisAnalysisSecurityGroupRule'] = None,
                 security_groups: Optional[Sequence['outputs.NetworkInsightsAnalysisAnalysisComponent']] = None,
                 source_vpc: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 state: Optional[str] = None,
                 subnet: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 subnet_route_table: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 transit_gateway: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 transit_gateway_attachment: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 transit_gateway_route_table: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 transit_gateway_route_table_route: Optional['outputs.NetworkInsightsAnalysisTransitGatewayRouteTableRoute'] = None,
                 vpc: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 vpc_endpoint: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 vpc_peering_connection: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 vpn_connection: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 vpn_gateway: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None):
        """
        :param 'NetworkInsightsAnalysisAnalysisComponent' acl: The network ACL.
        :param 'NetworkInsightsAnalysisAnalysisAclRule' acl_rule: The network ACL rule.
        :param str address: The IPv4 address, in CIDR notation.
        :param Sequence[str] addresses: The IPv4 addresses, in CIDR notation.
        :param 'NetworkInsightsAnalysisAnalysisComponent' attached_to: The resource to which the component is attached.
        :param Sequence[str] availability_zones: The Availability Zones.
        :param Sequence[str] cidrs: The CIDR ranges.
        :param 'NetworkInsightsAnalysisAnalysisLoadBalancerListener' classic_load_balancer_listener: The listener for a Classic Load Balancer.
        :param 'NetworkInsightsAnalysisAnalysisComponent' component: The component.
        :param str component_account: The AWS account for the component.
        :param str component_region: The Region for the component.
        :param 'NetworkInsightsAnalysisAnalysisComponent' customer_gateway: The customer gateway.
        :param 'NetworkInsightsAnalysisAnalysisComponent' destination: The destination.
        :param 'NetworkInsightsAnalysisAnalysisComponent' destination_vpc: The destination VPC.
        :param str direction: The direction. The following are the possible values:
               
               - egress
               - ingress
        :param 'NetworkInsightsAnalysisAnalysisComponent' elastic_load_balancer_listener: The load balancer listener.
        :param str explanation_code: The explanation code.
        :param 'NetworkInsightsAnalysisAnalysisComponent' ingress_route_table: The route table.
        :param 'NetworkInsightsAnalysisAnalysisComponent' internet_gateway: The internet gateway.
        :param str load_balancer_arn: The Amazon Resource Name (ARN) of the load balancer.
        :param int load_balancer_listener_port: The listener port of the load balancer.
        :param 'NetworkInsightsAnalysisAnalysisLoadBalancerTarget' load_balancer_target: The target.
        :param 'NetworkInsightsAnalysisAnalysisComponent' load_balancer_target_group: The target group.
        :param Sequence['NetworkInsightsAnalysisAnalysisComponent'] load_balancer_target_groups: The target groups.
        :param int load_balancer_target_port: The target port.
        :param str missing_component: The missing component.
        :param 'NetworkInsightsAnalysisAnalysisComponent' nat_gateway: The NAT gateway.
        :param 'NetworkInsightsAnalysisAnalysisComponent' network_interface: The network interface.
        :param str packet_field: The packet field.
        :param int port: The port.
        :param Sequence['NetworkInsightsAnalysisPortRange'] port_ranges: The port ranges.
        :param 'NetworkInsightsAnalysisAnalysisComponent' prefix_list: The prefix list.
        :param Sequence[str] protocols: The protocols.
        :param 'NetworkInsightsAnalysisAnalysisComponent' route_table: The route table.
        :param 'NetworkInsightsAnalysisAnalysisRouteTableRoute' route_table_route: The route table route.
        :param 'NetworkInsightsAnalysisAnalysisComponent' security_group: The security group.
        :param 'NetworkInsightsAnalysisAnalysisSecurityGroupRule' security_group_rule: The security group rule.
        :param Sequence['NetworkInsightsAnalysisAnalysisComponent'] security_groups: The security groups.
        :param 'NetworkInsightsAnalysisAnalysisComponent' source_vpc: The source VPC.
        :param str state: The state.
        :param 'NetworkInsightsAnalysisAnalysisComponent' subnet: The subnet.
        :param 'NetworkInsightsAnalysisAnalysisComponent' subnet_route_table: The route table for the subnet.
        :param 'NetworkInsightsAnalysisAnalysisComponent' transit_gateway: The transit gateway.
        :param 'NetworkInsightsAnalysisAnalysisComponent' transit_gateway_attachment: The transit gateway attachment.
        :param 'NetworkInsightsAnalysisAnalysisComponent' transit_gateway_route_table: The transit gateway route table.
        :param 'NetworkInsightsAnalysisTransitGatewayRouteTableRoute' transit_gateway_route_table_route: The transit gateway route table route.
        :param 'NetworkInsightsAnalysisAnalysisComponent' vpc: The component VPC.
        :param 'NetworkInsightsAnalysisAnalysisComponent' vpc_endpoint: The VPC endpoint.
        :param 'NetworkInsightsAnalysisAnalysisComponent' vpc_peering_connection: The VPC peering connection.
        :param 'NetworkInsightsAnalysisAnalysisComponent' vpn_connection: The VPN connection.
        :param 'NetworkInsightsAnalysisAnalysisComponent' vpn_gateway: The VPN gateway.
        """
        if acl is not None:
            pulumi.set(__self__, "acl", acl)
        if acl_rule is not None:
            pulumi.set(__self__, "acl_rule", acl_rule)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)
        if attached_to is not None:
            pulumi.set(__self__, "attached_to", attached_to)
        if availability_zones is not None:
            pulumi.set(__self__, "availability_zones", availability_zones)
        if cidrs is not None:
            pulumi.set(__self__, "cidrs", cidrs)
        if classic_load_balancer_listener is not None:
            pulumi.set(__self__, "classic_load_balancer_listener", classic_load_balancer_listener)
        if component is not None:
            pulumi.set(__self__, "component", component)
        if component_account is not None:
            pulumi.set(__self__, "component_account", component_account)
        if component_region is not None:
            pulumi.set(__self__, "component_region", component_region)
        if customer_gateway is not None:
            pulumi.set(__self__, "customer_gateway", customer_gateway)
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if destination_vpc is not None:
            pulumi.set(__self__, "destination_vpc", destination_vpc)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if elastic_load_balancer_listener is not None:
            pulumi.set(__self__, "elastic_load_balancer_listener", elastic_load_balancer_listener)
        if explanation_code is not None:
            pulumi.set(__self__, "explanation_code", explanation_code)
        if ingress_route_table is not None:
            pulumi.set(__self__, "ingress_route_table", ingress_route_table)
        if internet_gateway is not None:
            pulumi.set(__self__, "internet_gateway", internet_gateway)
        if load_balancer_arn is not None:
            pulumi.set(__self__, "load_balancer_arn", load_balancer_arn)
        if load_balancer_listener_port is not None:
            pulumi.set(__self__, "load_balancer_listener_port", load_balancer_listener_port)
        if load_balancer_target is not None:
            pulumi.set(__self__, "load_balancer_target", load_balancer_target)
        if load_balancer_target_group is not None:
            pulumi.set(__self__, "load_balancer_target_group", load_balancer_target_group)
        if load_balancer_target_groups is not None:
            pulumi.set(__self__, "load_balancer_target_groups", load_balancer_target_groups)
        if load_balancer_target_port is not None:
            pulumi.set(__self__, "load_balancer_target_port", load_balancer_target_port)
        if missing_component is not None:
            pulumi.set(__self__, "missing_component", missing_component)
        if nat_gateway is not None:
            pulumi.set(__self__, "nat_gateway", nat_gateway)
        if network_interface is not None:
            pulumi.set(__self__, "network_interface", network_interface)
        if packet_field is not None:
            pulumi.set(__self__, "packet_field", packet_field)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if prefix_list is not None:
            pulumi.set(__self__, "prefix_list", prefix_list)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if route_table is not None:
            pulumi.set(__self__, "route_table", route_table)
        if route_table_route is not None:
            pulumi.set(__self__, "route_table_route", route_table_route)
        if security_group is not None:
            pulumi.set(__self__, "security_group", security_group)
        if security_group_rule is not None:
            pulumi.set(__self__, "security_group_rule", security_group_rule)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if source_vpc is not None:
            pulumi.set(__self__, "source_vpc", source_vpc)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)
        if subnet_route_table is not None:
            pulumi.set(__self__, "subnet_route_table", subnet_route_table)
        if transit_gateway is not None:
            pulumi.set(__self__, "transit_gateway", transit_gateway)
        if transit_gateway_attachment is not None:
            pulumi.set(__self__, "transit_gateway_attachment", transit_gateway_attachment)
        if transit_gateway_route_table is not None:
            pulumi.set(__self__, "transit_gateway_route_table", transit_gateway_route_table)
        if transit_gateway_route_table_route is not None:
            pulumi.set(__self__, "transit_gateway_route_table_route", transit_gateway_route_table_route)
        if vpc is not None:
            pulumi.set(__self__, "vpc", vpc)
        if vpc_endpoint is not None:
            pulumi.set(__self__, "vpc_endpoint", vpc_endpoint)
        if vpc_peering_connection is not None:
            pulumi.set(__self__, "vpc_peering_connection", vpc_peering_connection)
        if vpn_connection is not None:
            pulumi.set(__self__, "vpn_connection", vpn_connection)
        if vpn_gateway is not None:
            pulumi.set(__self__, "vpn_gateway", vpn_gateway)

    @property
    @pulumi.getter
    def acl(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The network ACL.
        """
        return pulumi.get(self, "acl")

    @property
    @pulumi.getter(name="aclRule")
    def acl_rule(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisAclRule']:
        """
        The network ACL rule.
        """
        return pulumi.get(self, "acl_rule")

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        The IPv4 address, in CIDR notation.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def addresses(self) -> Optional[Sequence[str]]:
        """
        The IPv4 addresses, in CIDR notation.
        """
        return pulumi.get(self, "addresses")

    @property
    @pulumi.getter(name="attachedTo")
    def attached_to(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The resource to which the component is attached.
        """
        return pulumi.get(self, "attached_to")

    @property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Optional[Sequence[str]]:
        """
        The Availability Zones.
        """
        return pulumi.get(self, "availability_zones")

    @property
    @pulumi.getter
    def cidrs(self) -> Optional[Sequence[str]]:
        """
        The CIDR ranges.
        """
        return pulumi.get(self, "cidrs")

    @property
    @pulumi.getter(name="classicLoadBalancerListener")
    def classic_load_balancer_listener(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisLoadBalancerListener']:
        """
        The listener for a Classic Load Balancer.
        """
        return pulumi.get(self, "classic_load_balancer_listener")

    @property
    @pulumi.getter
    def component(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The component.
        """
        return pulumi.get(self, "component")

    @property
    @pulumi.getter(name="componentAccount")
    def component_account(self) -> Optional[str]:
        """
        The AWS account for the component.
        """
        return pulumi.get(self, "component_account")

    @property
    @pulumi.getter(name="componentRegion")
    def component_region(self) -> Optional[str]:
        """
        The Region for the component.
        """
        return pulumi.get(self, "component_region")

    @property
    @pulumi.getter(name="customerGateway")
    def customer_gateway(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The customer gateway.
        """
        return pulumi.get(self, "customer_gateway")

    @property
    @pulumi.getter
    def destination(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The destination.
        """
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter(name="destinationVpc")
    def destination_vpc(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The destination VPC.
        """
        return pulumi.get(self, "destination_vpc")

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The direction. The following are the possible values:

        - egress
        - ingress
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter(name="elasticLoadBalancerListener")
    def elastic_load_balancer_listener(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The load balancer listener.
        """
        return pulumi.get(self, "elastic_load_balancer_listener")

    @property
    @pulumi.getter(name="explanationCode")
    def explanation_code(self) -> Optional[str]:
        """
        The explanation code.
        """
        return pulumi.get(self, "explanation_code")

    @property
    @pulumi.getter(name="ingressRouteTable")
    def ingress_route_table(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The route table.
        """
        return pulumi.get(self, "ingress_route_table")

    @property
    @pulumi.getter(name="internetGateway")
    def internet_gateway(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The internet gateway.
        """
        return pulumi.get(self, "internet_gateway")

    @property
    @pulumi.getter(name="loadBalancerArn")
    def load_balancer_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the load balancer.
        """
        return pulumi.get(self, "load_balancer_arn")

    @property
    @pulumi.getter(name="loadBalancerListenerPort")
    def load_balancer_listener_port(self) -> Optional[int]:
        """
        The listener port of the load balancer.
        """
        return pulumi.get(self, "load_balancer_listener_port")

    @property
    @pulumi.getter(name="loadBalancerTarget")
    def load_balancer_target(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisLoadBalancerTarget']:
        """
        The target.
        """
        return pulumi.get(self, "load_balancer_target")

    @property
    @pulumi.getter(name="loadBalancerTargetGroup")
    def load_balancer_target_group(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The target group.
        """
        return pulumi.get(self, "load_balancer_target_group")

    @property
    @pulumi.getter(name="loadBalancerTargetGroups")
    def load_balancer_target_groups(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisAnalysisComponent']]:
        """
        The target groups.
        """
        return pulumi.get(self, "load_balancer_target_groups")

    @property
    @pulumi.getter(name="loadBalancerTargetPort")
    def load_balancer_target_port(self) -> Optional[int]:
        """
        The target port.
        """
        return pulumi.get(self, "load_balancer_target_port")

    @property
    @pulumi.getter(name="missingComponent")
    def missing_component(self) -> Optional[str]:
        """
        The missing component.
        """
        return pulumi.get(self, "missing_component")

    @property
    @pulumi.getter(name="natGateway")
    def nat_gateway(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The NAT gateway.
        """
        return pulumi.get(self, "nat_gateway")

    @property
    @pulumi.getter(name="networkInterface")
    def network_interface(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The network interface.
        """
        return pulumi.get(self, "network_interface")

    @property
    @pulumi.getter(name="packetField")
    def packet_field(self) -> Optional[str]:
        """
        The packet field.
        """
        return pulumi.get(self, "packet_field")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisPortRange']]:
        """
        The port ranges.
        """
        return pulumi.get(self, "port_ranges")

    @property
    @pulumi.getter(name="prefixList")
    def prefix_list(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The prefix list.
        """
        return pulumi.get(self, "prefix_list")

    @property
    @pulumi.getter
    def protocols(self) -> Optional[Sequence[str]]:
        """
        The protocols.
        """
        return pulumi.get(self, "protocols")

    @property
    @pulumi.getter(name="routeTable")
    def route_table(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The route table.
        """
        return pulumi.get(self, "route_table")

    @property
    @pulumi.getter(name="routeTableRoute")
    def route_table_route(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisRouteTableRoute']:
        """
        The route table route.
        """
        return pulumi.get(self, "route_table_route")

    @property
    @pulumi.getter(name="securityGroup")
    def security_group(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The security group.
        """
        return pulumi.get(self, "security_group")

    @property
    @pulumi.getter(name="securityGroupRule")
    def security_group_rule(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisSecurityGroupRule']:
        """
        The security group rule.
        """
        return pulumi.get(self, "security_group_rule")

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisAnalysisComponent']]:
        """
        The security groups.
        """
        return pulumi.get(self, "security_groups")

    @property
    @pulumi.getter(name="sourceVpc")
    def source_vpc(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The source VPC.
        """
        return pulumi.get(self, "source_vpc")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        The state.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def subnet(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The subnet.
        """
        return pulumi.get(self, "subnet")

    @property
    @pulumi.getter(name="subnetRouteTable")
    def subnet_route_table(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The route table for the subnet.
        """
        return pulumi.get(self, "subnet_route_table")

    @property
    @pulumi.getter(name="transitGateway")
    def transit_gateway(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The transit gateway.
        """
        return pulumi.get(self, "transit_gateway")

    @property
    @pulumi.getter(name="transitGatewayAttachment")
    def transit_gateway_attachment(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The transit gateway attachment.
        """
        return pulumi.get(self, "transit_gateway_attachment")

    @property
    @pulumi.getter(name="transitGatewayRouteTable")
    def transit_gateway_route_table(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The transit gateway route table.
        """
        return pulumi.get(self, "transit_gateway_route_table")

    @property
    @pulumi.getter(name="transitGatewayRouteTableRoute")
    def transit_gateway_route_table_route(self) -> Optional['outputs.NetworkInsightsAnalysisTransitGatewayRouteTableRoute']:
        """
        The transit gateway route table route.
        """
        return pulumi.get(self, "transit_gateway_route_table_route")

    @property
    @pulumi.getter
    def vpc(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The component VPC.
        """
        return pulumi.get(self, "vpc")

    @property
    @pulumi.getter(name="vpcEndpoint")
    def vpc_endpoint(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The VPC endpoint.
        """
        return pulumi.get(self, "vpc_endpoint")

    @property
    @pulumi.getter(name="vpcPeeringConnection")
    def vpc_peering_connection(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The VPC peering connection.
        """
        return pulumi.get(self, "vpc_peering_connection")

    @property
    @pulumi.getter(name="vpnConnection")
    def vpn_connection(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The VPN connection.
        """
        return pulumi.get(self, "vpn_connection")

    @property
    @pulumi.getter(name="vpnGateway")
    def vpn_gateway(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The VPN gateway.
        """
        return pulumi.get(self, "vpn_gateway")


@pulumi.output_type
class NetworkInsightsAnalysisPathComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aclRule":
            suggest = "acl_rule"
        elif key == "additionalDetails":
            suggest = "additional_details"
        elif key == "destinationVpc":
            suggest = "destination_vpc"
        elif key == "elasticLoadBalancerListener":
            suggest = "elastic_load_balancer_listener"
        elif key == "inboundHeader":
            suggest = "inbound_header"
        elif key == "outboundHeader":
            suggest = "outbound_header"
        elif key == "routeTableRoute":
            suggest = "route_table_route"
        elif key == "securityGroupRule":
            suggest = "security_group_rule"
        elif key == "sequenceNumber":
            suggest = "sequence_number"
        elif key == "serviceName":
            suggest = "service_name"
        elif key == "sourceVpc":
            suggest = "source_vpc"
        elif key == "transitGateway":
            suggest = "transit_gateway"
        elif key == "transitGatewayRouteTableRoute":
            suggest = "transit_gateway_route_table_route"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisPathComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisPathComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisPathComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acl_rule: Optional['outputs.NetworkInsightsAnalysisAnalysisAclRule'] = None,
                 additional_details: Optional[Sequence['outputs.NetworkInsightsAnalysisAdditionalDetail']] = None,
                 component: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 destination_vpc: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 elastic_load_balancer_listener: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 explanations: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanation']] = None,
                 inbound_header: Optional['outputs.NetworkInsightsAnalysisAnalysisPacketHeader'] = None,
                 outbound_header: Optional['outputs.NetworkInsightsAnalysisAnalysisPacketHeader'] = None,
                 route_table_route: Optional['outputs.NetworkInsightsAnalysisAnalysisRouteTableRoute'] = None,
                 security_group_rule: Optional['outputs.NetworkInsightsAnalysisAnalysisSecurityGroupRule'] = None,
                 sequence_number: Optional[int] = None,
                 service_name: Optional[str] = None,
                 source_vpc: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 subnet: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 transit_gateway: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 transit_gateway_route_table_route: Optional['outputs.NetworkInsightsAnalysisTransitGatewayRouteTableRoute'] = None,
                 vpc: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None):
        """
        :param 'NetworkInsightsAnalysisAnalysisAclRule' acl_rule: The network ACL rule.
        :param Sequence['NetworkInsightsAnalysisAdditionalDetail'] additional_details: The additional details.
        :param 'NetworkInsightsAnalysisAnalysisComponent' component: The component.
        :param 'NetworkInsightsAnalysisAnalysisComponent' destination_vpc: The destination VPC.
        :param 'NetworkInsightsAnalysisAnalysisComponent' elastic_load_balancer_listener: The load balancer listener.
        :param Sequence['NetworkInsightsAnalysisExplanation'] explanations: The explanation codes.
        :param 'NetworkInsightsAnalysisAnalysisPacketHeader' inbound_header: The inbound header.
        :param 'NetworkInsightsAnalysisAnalysisPacketHeader' outbound_header: The outbound header.
        :param 'NetworkInsightsAnalysisAnalysisRouteTableRoute' route_table_route: The route table route.
        :param 'NetworkInsightsAnalysisAnalysisSecurityGroupRule' security_group_rule: The security group rule.
        :param int sequence_number: The sequence number.
        :param str service_name: The name of the VPC endpoint service.
        :param 'NetworkInsightsAnalysisAnalysisComponent' source_vpc: The source VPC.
        :param 'NetworkInsightsAnalysisAnalysisComponent' subnet: The subnet.
        :param 'NetworkInsightsAnalysisAnalysisComponent' transit_gateway: The transit gateway.
        :param 'NetworkInsightsAnalysisTransitGatewayRouteTableRoute' transit_gateway_route_table_route: The route in a transit gateway route table.
        :param 'NetworkInsightsAnalysisAnalysisComponent' vpc: The component VPC.
        """
        if acl_rule is not None:
            pulumi.set(__self__, "acl_rule", acl_rule)
        if additional_details is not None:
            pulumi.set(__self__, "additional_details", additional_details)
        if component is not None:
            pulumi.set(__self__, "component", component)
        if destination_vpc is not None:
            pulumi.set(__self__, "destination_vpc", destination_vpc)
        if elastic_load_balancer_listener is not None:
            pulumi.set(__self__, "elastic_load_balancer_listener", elastic_load_balancer_listener)
        if explanations is not None:
            pulumi.set(__self__, "explanations", explanations)
        if inbound_header is not None:
            pulumi.set(__self__, "inbound_header", inbound_header)
        if outbound_header is not None:
            pulumi.set(__self__, "outbound_header", outbound_header)
        if route_table_route is not None:
            pulumi.set(__self__, "route_table_route", route_table_route)
        if security_group_rule is not None:
            pulumi.set(__self__, "security_group_rule", security_group_rule)
        if sequence_number is not None:
            pulumi.set(__self__, "sequence_number", sequence_number)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)
        if source_vpc is not None:
            pulumi.set(__self__, "source_vpc", source_vpc)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)
        if transit_gateway is not None:
            pulumi.set(__self__, "transit_gateway", transit_gateway)
        if transit_gateway_route_table_route is not None:
            pulumi.set(__self__, "transit_gateway_route_table_route", transit_gateway_route_table_route)
        if vpc is not None:
            pulumi.set(__self__, "vpc", vpc)

    @property
    @pulumi.getter(name="aclRule")
    def acl_rule(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisAclRule']:
        """
        The network ACL rule.
        """
        return pulumi.get(self, "acl_rule")

    @property
    @pulumi.getter(name="additionalDetails")
    def additional_details(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisAdditionalDetail']]:
        """
        The additional details.
        """
        return pulumi.get(self, "additional_details")

    @property
    @pulumi.getter
    def component(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The component.
        """
        return pulumi.get(self, "component")

    @property
    @pulumi.getter(name="destinationVpc")
    def destination_vpc(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The destination VPC.
        """
        return pulumi.get(self, "destination_vpc")

    @property
    @pulumi.getter(name="elasticLoadBalancerListener")
    def elastic_load_balancer_listener(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The load balancer listener.
        """
        return pulumi.get(self, "elastic_load_balancer_listener")

    @property
    @pulumi.getter
    def explanations(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanation']]:
        """
        The explanation codes.
        """
        return pulumi.get(self, "explanations")

    @property
    @pulumi.getter(name="inboundHeader")
    def inbound_header(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisPacketHeader']:
        """
        The inbound header.
        """
        return pulumi.get(self, "inbound_header")

    @property
    @pulumi.getter(name="outboundHeader")
    def outbound_header(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisPacketHeader']:
        """
        The outbound header.
        """
        return pulumi.get(self, "outbound_header")

    @property
    @pulumi.getter(name="routeTableRoute")
    def route_table_route(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisRouteTableRoute']:
        """
        The route table route.
        """
        return pulumi.get(self, "route_table_route")

    @property
    @pulumi.getter(name="securityGroupRule")
    def security_group_rule(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisSecurityGroupRule']:
        """
        The security group rule.
        """
        return pulumi.get(self, "security_group_rule")

    @property
    @pulumi.getter(name="sequenceNumber")
    def sequence_number(self) -> Optional[int]:
        """
        The sequence number.
        """
        return pulumi.get(self, "sequence_number")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        """
        The name of the VPC endpoint service.
        """
        return pulumi.get(self, "service_name")

    @property
    @pulumi.getter(name="sourceVpc")
    def source_vpc(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The source VPC.
        """
        return pulumi.get(self, "source_vpc")

    @property
    @pulumi.getter
    def subnet(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The subnet.
        """
        return pulumi.get(self, "subnet")

    @property
    @pulumi.getter(name="transitGateway")
    def transit_gateway(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The transit gateway.
        """
        return pulumi.get(self, "transit_gateway")

    @property
    @pulumi.getter(name="transitGatewayRouteTableRoute")
    def transit_gateway_route_table_route(self) -> Optional['outputs.NetworkInsightsAnalysisTransitGatewayRouteTableRoute']:
        """
        The route in a transit gateway route table.
        """
        return pulumi.get(self, "transit_gateway_route_table_route")

    @property
    @pulumi.getter
    def vpc(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The component VPC.
        """
        return pulumi.get(self, "vpc")


@pulumi.output_type
class NetworkInsightsAnalysisPortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisPortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisPortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisPortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[int] = None,
                 to: Optional[int] = None):
        """
        :param int from_: The first port in the range.
        :param int to: The last port in the range.
        """
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[int]:
        """
        The first port in the range.
        """
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional[int]:
        """
        The last port in the range.
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisTransitGatewayRouteTableRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attachmentId":
            suggest = "attachment_id"
        elif key == "destinationCidr":
            suggest = "destination_cidr"
        elif key == "prefixListId":
            suggest = "prefix_list_id"
        elif key == "resourceId":
            suggest = "resource_id"
        elif key == "resourceType":
            suggest = "resource_type"
        elif key == "routeOrigin":
            suggest = "route_origin"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisTransitGatewayRouteTableRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisTransitGatewayRouteTableRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisTransitGatewayRouteTableRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attachment_id: Optional[str] = None,
                 destination_cidr: Optional[str] = None,
                 prefix_list_id: Optional[str] = None,
                 resource_id: Optional[str] = None,
                 resource_type: Optional[str] = None,
                 route_origin: Optional[str] = None,
                 state: Optional[str] = None):
        """
        :param str attachment_id: The ID of the route attachment.
        :param str destination_cidr: The CIDR block used for destination matches.
        :param str prefix_list_id: The ID of the prefix list.
        :param str resource_id: The ID of the resource for the route attachment.
        :param str resource_type: The resource type for the route attachment.
        :param str route_origin: The route origin. The following are the possible values:
               
               - static
               - propagated
        :param str state: The state of the route.
        """
        if attachment_id is not None:
            pulumi.set(__self__, "attachment_id", attachment_id)
        if destination_cidr is not None:
            pulumi.set(__self__, "destination_cidr", destination_cidr)
        if prefix_list_id is not None:
            pulumi.set(__self__, "prefix_list_id", prefix_list_id)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if route_origin is not None:
            pulumi.set(__self__, "route_origin", route_origin)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="attachmentId")
    def attachment_id(self) -> Optional[str]:
        """
        The ID of the route attachment.
        """
        return pulumi.get(self, "attachment_id")

    @property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> Optional[str]:
        """
        The CIDR block used for destination matches.
        """
        return pulumi.get(self, "destination_cidr")

    @property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> Optional[str]:
        """
        The ID of the prefix list.
        """
        return pulumi.get(self, "prefix_list_id")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        """
        The ID of the resource for the route attachment.
        """
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[str]:
        """
        The resource type for the route attachment.
        """
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter(name="routeOrigin")
    def route_origin(self) -> Optional[str]:
        """
        The route origin. The following are the possible values:

        - static
        - propagated
        """
        return pulumi.get(self, "route_origin")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        The state of the route.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class NetworkInsightsPathFilterPortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "toPort":
            suggest = "to_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsPathFilterPortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsPathFilterPortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsPathFilterPortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_port: Optional[int] = None,
                 to_port: Optional[int] = None):
        """
        :param int from_port: The first port in the range.
        :param int to_port: The last port in the range.
        """
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[int]:
        """
        The first port in the range.
        """
        return pulumi.get(self, "from_port")

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[int]:
        """
        The last port in the range.
        """
        return pulumi.get(self, "to_port")


@pulumi.output_type
class NetworkInsightsPathPathFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddress":
            suggest = "destination_address"
        elif key == "destinationPortRange":
            suggest = "destination_port_range"
        elif key == "sourceAddress":
            suggest = "source_address"
        elif key == "sourcePortRange":
            suggest = "source_port_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsPathPathFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsPathPathFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsPathPathFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_address: Optional[str] = None,
                 destination_port_range: Optional['outputs.NetworkInsightsPathFilterPortRange'] = None,
                 source_address: Optional[str] = None,
                 source_port_range: Optional['outputs.NetworkInsightsPathFilterPortRange'] = None):
        """
        :param str destination_address: The destination IPv4 address.
        :param 'NetworkInsightsPathFilterPortRange' destination_port_range: The destination port range.
        :param str source_address: The source IPv4 address.
        :param 'NetworkInsightsPathFilterPortRange' source_port_range: The source port range.
        """
        if destination_address is not None:
            pulumi.set(__self__, "destination_address", destination_address)
        if destination_port_range is not None:
            pulumi.set(__self__, "destination_port_range", destination_port_range)
        if source_address is not None:
            pulumi.set(__self__, "source_address", source_address)
        if source_port_range is not None:
            pulumi.set(__self__, "source_port_range", source_port_range)

    @property
    @pulumi.getter(name="destinationAddress")
    def destination_address(self) -> Optional[str]:
        """
        The destination IPv4 address.
        """
        return pulumi.get(self, "destination_address")

    @property
    @pulumi.getter(name="destinationPortRange")
    def destination_port_range(self) -> Optional['outputs.NetworkInsightsPathFilterPortRange']:
        """
        The destination port range.
        """
        return pulumi.get(self, "destination_port_range")

    @property
    @pulumi.getter(name="sourceAddress")
    def source_address(self) -> Optional[str]:
        """
        The source IPv4 address.
        """
        return pulumi.get(self, "source_address")

    @property
    @pulumi.getter(name="sourcePortRange")
    def source_port_range(self) -> Optional['outputs.NetworkInsightsPathFilterPortRange']:
        """
        The source port range.
        """
        return pulumi.get(self, "source_port_range")


@pulumi.output_type
class NetworkInterfaceAttachmentEnaSrdSpecification(dict):
    """
    ENA Express uses AWS Scalable Reliable Datagram (SRD) technology to increase the maximum bandwidth used per stream and minimize tail latency of network traffic between EC2 instances. With ENA Express, you can communicate between two EC2 instances in the same subnet within the same account, or in different accounts. Both sending and receiving instances must have ENA Express enabled.
     To improve the reliability of network packet delivery, ENA Express reorders network packets on the receiving end by default. However, some UDP-based applications are designed to handle network packets that are out of order to reduce the overhead for packet delivery at the network layer. When ENA Express is enabled, you can specify whether UDP network traffic uses it.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enaSrdEnabled":
            suggest = "ena_srd_enabled"
        elif key == "enaSrdUdpSpecification":
            suggest = "ena_srd_udp_specification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInterfaceAttachmentEnaSrdSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInterfaceAttachmentEnaSrdSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInterfaceAttachmentEnaSrdSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ena_srd_enabled: Optional[bool] = None,
                 ena_srd_udp_specification: Optional['outputs.NetworkInterfaceAttachmentEnaSrdSpecificationEnaSrdUdpSpecificationProperties'] = None):
        """
        ENA Express uses AWS Scalable Reliable Datagram (SRD) technology to increase the maximum bandwidth used per stream and minimize tail latency of network traffic between EC2 instances. With ENA Express, you can communicate between two EC2 instances in the same subnet within the same account, or in different accounts. Both sending and receiving instances must have ENA Express enabled.
         To improve the reliability of network packet delivery, ENA Express reorders network packets on the receiving end by default. However, some UDP-based applications are designed to handle network packets that are out of order to reduce the overhead for packet delivery at the network layer. When ENA Express is enabled, you can specify whether UDP network traffic uses it.
        :param bool ena_srd_enabled: Indicates whether ENA Express is enabled for the network interface.
        :param 'NetworkInterfaceAttachmentEnaSrdSpecificationEnaSrdUdpSpecificationProperties' ena_srd_udp_specification: Configures ENA Express for UDP network traffic.
        """
        if ena_srd_enabled is not None:
            pulumi.set(__self__, "ena_srd_enabled", ena_srd_enabled)
        if ena_srd_udp_specification is not None:
            pulumi.set(__self__, "ena_srd_udp_specification", ena_srd_udp_specification)

    @property
    @pulumi.getter(name="enaSrdEnabled")
    def ena_srd_enabled(self) -> Optional[bool]:
        """
        Indicates whether ENA Express is enabled for the network interface.
        """
        return pulumi.get(self, "ena_srd_enabled")

    @property
    @pulumi.getter(name="enaSrdUdpSpecification")
    def ena_srd_udp_specification(self) -> Optional['outputs.NetworkInterfaceAttachmentEnaSrdSpecificationEnaSrdUdpSpecificationProperties']:
        """
        Configures ENA Express for UDP network traffic.
        """
        return pulumi.get(self, "ena_srd_udp_specification")


@pulumi.output_type
class NetworkInterfaceAttachmentEnaSrdSpecificationEnaSrdUdpSpecificationProperties(dict):
    """
    Configures ENA Express for UDP network traffic.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enaSrdUdpEnabled":
            suggest = "ena_srd_udp_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInterfaceAttachmentEnaSrdSpecificationEnaSrdUdpSpecificationProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInterfaceAttachmentEnaSrdSpecificationEnaSrdUdpSpecificationProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInterfaceAttachmentEnaSrdSpecificationEnaSrdUdpSpecificationProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ena_srd_udp_enabled: Optional[bool] = None):
        """
        Configures ENA Express for UDP network traffic.
        """
        if ena_srd_udp_enabled is not None:
            pulumi.set(__self__, "ena_srd_udp_enabled", ena_srd_udp_enabled)

    @property
    @pulumi.getter(name="enaSrdUdpEnabled")
    def ena_srd_udp_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "ena_srd_udp_enabled")


@pulumi.output_type
class NetworkInterfaceConnectionTrackingSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tcpEstablishedTimeout":
            suggest = "tcp_established_timeout"
        elif key == "udpStreamTimeout":
            suggest = "udp_stream_timeout"
        elif key == "udpTimeout":
            suggest = "udp_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInterfaceConnectionTrackingSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInterfaceConnectionTrackingSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInterfaceConnectionTrackingSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tcp_established_timeout: Optional[int] = None,
                 udp_stream_timeout: Optional[int] = None,
                 udp_timeout: Optional[int] = None):
        """
        :param int tcp_established_timeout: Timeout (in seconds) for idle TCP connections in an established state. Min: 60 seconds. Max: 432000 seconds (5 days). Default: 432000 seconds. Recommended: Less than 432000 seconds.
        :param int udp_stream_timeout: Timeout (in seconds) for idle UDP flows classified as streams which have seen more than one request-response transaction. Min: 60 seconds. Max: 180 seconds (3 minutes). Default: 180 seconds.
        :param int udp_timeout: Timeout (in seconds) for idle UDP flows that have seen traffic only in a single direction or a single request-response transaction. Min: 30 seconds. Max: 60 seconds. Default: 30 seconds.
        """
        if tcp_established_timeout is not None:
            pulumi.set(__self__, "tcp_established_timeout", tcp_established_timeout)
        if udp_stream_timeout is not None:
            pulumi.set(__self__, "udp_stream_timeout", udp_stream_timeout)
        if udp_timeout is not None:
            pulumi.set(__self__, "udp_timeout", udp_timeout)

    @property
    @pulumi.getter(name="tcpEstablishedTimeout")
    def tcp_established_timeout(self) -> Optional[int]:
        """
        Timeout (in seconds) for idle TCP connections in an established state. Min: 60 seconds. Max: 432000 seconds (5 days). Default: 432000 seconds. Recommended: Less than 432000 seconds.
        """
        return pulumi.get(self, "tcp_established_timeout")

    @property
    @pulumi.getter(name="udpStreamTimeout")
    def udp_stream_timeout(self) -> Optional[int]:
        """
        Timeout (in seconds) for idle UDP flows classified as streams which have seen more than one request-response transaction. Min: 60 seconds. Max: 180 seconds (3 minutes). Default: 180 seconds.
        """
        return pulumi.get(self, "udp_stream_timeout")

    @property
    @pulumi.getter(name="udpTimeout")
    def udp_timeout(self) -> Optional[int]:
        """
        Timeout (in seconds) for idle UDP flows that have seen traffic only in a single direction or a single request-response transaction. Min: 30 seconds. Max: 60 seconds. Default: 30 seconds.
        """
        return pulumi.get(self, "udp_timeout")


@pulumi.output_type
class NetworkInterfaceInstanceIpv6Address(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv6Address":
            suggest = "ipv6_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInterfaceInstanceIpv6Address. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInterfaceInstanceIpv6Address.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInterfaceInstanceIpv6Address.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv6_address: str):
        """
        :param str ipv6_address: An IPv6 address to associate with the network interface.
        """
        pulumi.set(__self__, "ipv6_address", ipv6_address)

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> str:
        """
        An IPv6 address to associate with the network interface.
        """
        return pulumi.get(self, "ipv6_address")


@pulumi.output_type
class NetworkInterfaceIpv4PrefixSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv4Prefix":
            suggest = "ipv4_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInterfaceIpv4PrefixSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInterfaceIpv4PrefixSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInterfaceIpv4PrefixSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv4_prefix: str):
        """
        :param str ipv4_prefix: The IPv4 prefix. For information, see [Assigning prefixes to network interfaces](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-prefix-eni.html) in the *Amazon EC2 User Guide* .
        """
        pulumi.set(__self__, "ipv4_prefix", ipv4_prefix)

    @property
    @pulumi.getter(name="ipv4Prefix")
    def ipv4_prefix(self) -> str:
        """
        The IPv4 prefix. For information, see [Assigning prefixes to network interfaces](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-prefix-eni.html) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "ipv4_prefix")


@pulumi.output_type
class NetworkInterfaceIpv6PrefixSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv6Prefix":
            suggest = "ipv6_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInterfaceIpv6PrefixSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInterfaceIpv6PrefixSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInterfaceIpv6PrefixSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv6_prefix: str):
        """
        :param str ipv6_prefix: The IPv6 prefix. For information, see [Assigning prefixes to Amazon EC2 network interfaces](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-prefix-eni.html) in the *Amazon Elastic Compute Cloud User Guide* .
        """
        pulumi.set(__self__, "ipv6_prefix", ipv6_prefix)

    @property
    @pulumi.getter(name="ipv6Prefix")
    def ipv6_prefix(self) -> str:
        """
        The IPv6 prefix. For information, see [Assigning prefixes to Amazon EC2 network interfaces](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-prefix-eni.html) in the *Amazon Elastic Compute Cloud User Guide* .
        """
        return pulumi.get(self, "ipv6_prefix")


@pulumi.output_type
class NetworkInterfacePrivateIpAddressSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIpAddress":
            suggest = "private_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInterfacePrivateIpAddressSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInterfacePrivateIpAddressSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInterfacePrivateIpAddressSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 primary: bool,
                 private_ip_address: str):
        """
        :param bool primary: Sets the private IP address as the primary private address. You can set only one primary private IP address. If you don't specify a primary private IP address, Amazon EC2 automatically assigns a primary private IP address.
        :param str private_ip_address: The private IP address of the network interface.
        """
        pulumi.set(__self__, "primary", primary)
        pulumi.set(__self__, "private_ip_address", private_ip_address)

    @property
    @pulumi.getter
    def primary(self) -> bool:
        """
        Sets the private IP address as the primary private address. You can set only one primary private IP address. If you don't specify a primary private IP address, Amazon EC2 automatically assigns a primary private IP address.
        """
        return pulumi.get(self, "primary")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> str:
        """
        The private IP address of the network interface.
        """
        return pulumi.get(self, "private_ip_address")


@pulumi.output_type
class OptionsProperties(dict):
    """
    The options for the transit gateway vpc attachment.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applianceModeSupport":
            suggest = "appliance_mode_support"
        elif key == "dnsSupport":
            suggest = "dns_support"
        elif key == "ipv6Support":
            suggest = "ipv6_support"
        elif key == "securityGroupReferencingSupport":
            suggest = "security_group_referencing_support"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OptionsProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OptionsProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OptionsProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 appliance_mode_support: Optional[str] = None,
                 dns_support: Optional[str] = None,
                 ipv6_support: Optional[str] = None,
                 security_group_referencing_support: Optional[str] = None):
        """
        The options for the transit gateway vpc attachment.
        :param str appliance_mode_support: Indicates whether to enable Ipv6 Support for Vpc Attachment. Valid Values: enable | disable
        :param str dns_support: Indicates whether to enable DNS Support for Vpc Attachment. Valid Values: enable | disable
        :param str ipv6_support: Indicates whether to enable Ipv6 Support for Vpc Attachment. Valid Values: enable | disable
        :param str security_group_referencing_support: Indicates whether to enable Security Group referencing support for Vpc Attachment. Valid values: enable | disable
        """
        if appliance_mode_support is not None:
            pulumi.set(__self__, "appliance_mode_support", appliance_mode_support)
        if dns_support is not None:
            pulumi.set(__self__, "dns_support", dns_support)
        if ipv6_support is not None:
            pulumi.set(__self__, "ipv6_support", ipv6_support)
        if security_group_referencing_support is not None:
            pulumi.set(__self__, "security_group_referencing_support", security_group_referencing_support)

    @property
    @pulumi.getter(name="applianceModeSupport")
    def appliance_mode_support(self) -> Optional[str]:
        """
        Indicates whether to enable Ipv6 Support for Vpc Attachment. Valid Values: enable | disable
        """
        return pulumi.get(self, "appliance_mode_support")

    @property
    @pulumi.getter(name="dnsSupport")
    def dns_support(self) -> Optional[str]:
        """
        Indicates whether to enable DNS Support for Vpc Attachment. Valid Values: enable | disable
        """
        return pulumi.get(self, "dns_support")

    @property
    @pulumi.getter(name="ipv6Support")
    def ipv6_support(self) -> Optional[str]:
        """
        Indicates whether to enable Ipv6 Support for Vpc Attachment. Valid Values: enable | disable
        """
        return pulumi.get(self, "ipv6_support")

    @property
    @pulumi.getter(name="securityGroupReferencingSupport")
    def security_group_referencing_support(self) -> Optional[str]:
        """
        Indicates whether to enable Security Group referencing support for Vpc Attachment. Valid values: enable | disable
        """
        return pulumi.get(self, "security_group_referencing_support")


@pulumi.output_type
class PrefixListEntry(dict):
    def __init__(__self__, *,
                 cidr: str,
                 description: Optional[str] = None):
        """
        :param str cidr: The CIDR block.
        :param str description: A description for the entry.
               
               Constraints: Up to 255 characters in length.
        """
        pulumi.set(__self__, "cidr", cidr)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def cidr(self) -> str:
        """
        The CIDR block.
        """
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A description for the entry.

        Constraints: Up to 255 characters in length.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class PrivateDnsNameOptionsOnLaunchProperties(dict):
    """
    The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries to the instances should be handled. For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *User Guide*.
     Available options:
      +  EnableResourceNameDnsAAAARecord (true | false)
      +  EnableResourceNameDnsARecord (true | false)
      +  HostnameType (ip-name | resource-name)
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableResourceNameDnsARecord":
            suggest = "enable_resource_name_dns_a_record"
        elif key == "enableResourceNameDnsAaaaRecord":
            suggest = "enable_resource_name_dns_aaaa_record"
        elif key == "hostnameType":
            suggest = "hostname_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateDnsNameOptionsOnLaunchProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateDnsNameOptionsOnLaunchProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateDnsNameOptionsOnLaunchProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_resource_name_dns_a_record: Optional[bool] = None,
                 enable_resource_name_dns_aaaa_record: Optional[bool] = None,
                 hostname_type: Optional[str] = None):
        """
        The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries to the instances should be handled. For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *User Guide*.
         Available options:
          +  EnableResourceNameDnsAAAARecord (true | false)
          +  EnableResourceNameDnsARecord (true | false)
          +  HostnameType (ip-name | resource-name)
        :param bool enable_resource_name_dns_a_record: Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
        :param bool enable_resource_name_dns_aaaa_record: Indicates whether to respond to DNS queries for instance hostname with DNS AAAA records.
        :param str hostname_type: The type of hostname for EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID.
        """
        if enable_resource_name_dns_a_record is not None:
            pulumi.set(__self__, "enable_resource_name_dns_a_record", enable_resource_name_dns_a_record)
        if enable_resource_name_dns_aaaa_record is not None:
            pulumi.set(__self__, "enable_resource_name_dns_aaaa_record", enable_resource_name_dns_aaaa_record)
        if hostname_type is not None:
            pulumi.set(__self__, "hostname_type", hostname_type)

    @property
    @pulumi.getter(name="enableResourceNameDnsARecord")
    def enable_resource_name_dns_a_record(self) -> Optional[bool]:
        """
        Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
        """
        return pulumi.get(self, "enable_resource_name_dns_a_record")

    @property
    @pulumi.getter(name="enableResourceNameDnsAaaaRecord")
    def enable_resource_name_dns_aaaa_record(self) -> Optional[bool]:
        """
        Indicates whether to respond to DNS queries for instance hostname with DNS AAAA records.
        """
        return pulumi.get(self, "enable_resource_name_dns_aaaa_record")

    @property
    @pulumi.getter(name="hostnameType")
    def hostname_type(self) -> Optional[str]:
        """
        The type of hostname for EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID.
        """
        return pulumi.get(self, "hostname_type")


@pulumi.output_type
class SecurityGroupEgress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipProtocol":
            suggest = "ip_protocol"
        elif key == "cidrIp":
            suggest = "cidr_ip"
        elif key == "cidrIpv6":
            suggest = "cidr_ipv6"
        elif key == "destinationPrefixListId":
            suggest = "destination_prefix_list_id"
        elif key == "destinationSecurityGroupId":
            suggest = "destination_security_group_id"
        elif key == "fromPort":
            suggest = "from_port"
        elif key == "toPort":
            suggest = "to_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityGroupEgress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityGroupEgress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityGroupEgress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_protocol: str,
                 cidr_ip: Optional[str] = None,
                 cidr_ipv6: Optional[str] = None,
                 description: Optional[str] = None,
                 destination_prefix_list_id: Optional[str] = None,
                 destination_security_group_id: Optional[str] = None,
                 from_port: Optional[int] = None,
                 to_port: Optional[int] = None):
        """
        :param str ip_protocol: The IP protocol name ( `tcp` , `udp` , `icmp` , `icmpv6` ) or number (see [Protocol Numbers](https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml) ).
               
               Use `-1` to specify all protocols. When authorizing security group rules, specifying `-1` or a protocol number other than `tcp` , `udp` , `icmp` , or `icmpv6` allows traffic on all ports, regardless of any port range you specify. For `tcp` , `udp` , and `icmp` , you must specify a port range. For `icmpv6` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.
        :param str cidr_ip: The IPv4 address range, in CIDR format.
               
               You must specify exactly one of the following: `CidrIp` , `CidrIpv6` , `DestinationPrefixListId` , or `DestinationSecurityGroupId` .
               
               For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
        :param str cidr_ipv6: The IPv6 address range, in CIDR format.
               
               You must specify exactly one of the following: `CidrIp` , `CidrIpv6` , `DestinationPrefixListId` , or `DestinationSecurityGroupId` .
               
               For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
        :param str description: A description for the security group rule.
               
               Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
        :param str destination_prefix_list_id: The prefix list IDs for the destination AWS service. This is the AWS service that you want to access through a VPC endpoint from instances associated with the security group.
               
               You must specify exactly one of the following: `CidrIp` , `CidrIpv6` , `DestinationPrefixListId` , or `DestinationSecurityGroupId` .
        :param str destination_security_group_id: The ID of the destination VPC security group.
               
               You must specify exactly one of the following: `CidrIp` , `CidrIpv6` , `DestinationPrefixListId` , or `DestinationSecurityGroupId` .
        :param int from_port: If the protocol is TCP or UDP, this is the start of the port range. If the protocol is ICMP or ICMPv6, this is the ICMP type or -1 (all ICMP types).
        :param int to_port: If the protocol is TCP or UDP, this is the end of the port range. If the protocol is ICMP or ICMPv6, this is the ICMP code or -1 (all ICMP codes). If the start port is -1 (all ICMP types), then the end port must be -1 (all ICMP codes).
        """
        pulumi.set(__self__, "ip_protocol", ip_protocol)
        if cidr_ip is not None:
            pulumi.set(__self__, "cidr_ip", cidr_ip)
        if cidr_ipv6 is not None:
            pulumi.set(__self__, "cidr_ipv6", cidr_ipv6)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destination_prefix_list_id is not None:
            pulumi.set(__self__, "destination_prefix_list_id", destination_prefix_list_id)
        if destination_security_group_id is not None:
            pulumi.set(__self__, "destination_security_group_id", destination_security_group_id)
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)

    @property
    @pulumi.getter(name="ipProtocol")
    def ip_protocol(self) -> str:
        """
        The IP protocol name ( `tcp` , `udp` , `icmp` , `icmpv6` ) or number (see [Protocol Numbers](https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml) ).

        Use `-1` to specify all protocols. When authorizing security group rules, specifying `-1` or a protocol number other than `tcp` , `udp` , `icmp` , or `icmpv6` allows traffic on all ports, regardless of any port range you specify. For `tcp` , `udp` , and `icmp` , you must specify a port range. For `icmpv6` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.
        """
        return pulumi.get(self, "ip_protocol")

    @property
    @pulumi.getter(name="cidrIp")
    def cidr_ip(self) -> Optional[str]:
        """
        The IPv4 address range, in CIDR format.

        You must specify exactly one of the following: `CidrIp` , `CidrIpv6` , `DestinationPrefixListId` , or `DestinationSecurityGroupId` .

        For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "cidr_ip")

    @property
    @pulumi.getter(name="cidrIpv6")
    def cidr_ipv6(self) -> Optional[str]:
        """
        The IPv6 address range, in CIDR format.

        You must specify exactly one of the following: `CidrIp` , `CidrIpv6` , `DestinationPrefixListId` , or `DestinationSecurityGroupId` .

        For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "cidr_ipv6")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A description for the security group rule.

        Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="destinationPrefixListId")
    def destination_prefix_list_id(self) -> Optional[str]:
        """
        The prefix list IDs for the destination AWS service. This is the AWS service that you want to access through a VPC endpoint from instances associated with the security group.

        You must specify exactly one of the following: `CidrIp` , `CidrIpv6` , `DestinationPrefixListId` , or `DestinationSecurityGroupId` .
        """
        return pulumi.get(self, "destination_prefix_list_id")

    @property
    @pulumi.getter(name="destinationSecurityGroupId")
    def destination_security_group_id(self) -> Optional[str]:
        """
        The ID of the destination VPC security group.

        You must specify exactly one of the following: `CidrIp` , `CidrIpv6` , `DestinationPrefixListId` , or `DestinationSecurityGroupId` .
        """
        return pulumi.get(self, "destination_security_group_id")

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[int]:
        """
        If the protocol is TCP or UDP, this is the start of the port range. If the protocol is ICMP or ICMPv6, this is the ICMP type or -1 (all ICMP types).
        """
        return pulumi.get(self, "from_port")

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[int]:
        """
        If the protocol is TCP or UDP, this is the end of the port range. If the protocol is ICMP or ICMPv6, this is the ICMP code or -1 (all ICMP codes). If the start port is -1 (all ICMP types), then the end port must be -1 (all ICMP codes).
        """
        return pulumi.get(self, "to_port")


@pulumi.output_type
class SecurityGroupIngress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipProtocol":
            suggest = "ip_protocol"
        elif key == "cidrIp":
            suggest = "cidr_ip"
        elif key == "cidrIpv6":
            suggest = "cidr_ipv6"
        elif key == "fromPort":
            suggest = "from_port"
        elif key == "sourcePrefixListId":
            suggest = "source_prefix_list_id"
        elif key == "sourceSecurityGroupId":
            suggest = "source_security_group_id"
        elif key == "sourceSecurityGroupName":
            suggest = "source_security_group_name"
        elif key == "sourceSecurityGroupOwnerId":
            suggest = "source_security_group_owner_id"
        elif key == "toPort":
            suggest = "to_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityGroupIngress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityGroupIngress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityGroupIngress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_protocol: str,
                 cidr_ip: Optional[str] = None,
                 cidr_ipv6: Optional[str] = None,
                 description: Optional[str] = None,
                 from_port: Optional[int] = None,
                 source_prefix_list_id: Optional[str] = None,
                 source_security_group_id: Optional[str] = None,
                 source_security_group_name: Optional[str] = None,
                 source_security_group_owner_id: Optional[str] = None,
                 to_port: Optional[int] = None):
        """
        :param str ip_protocol: The IP protocol name ( `tcp` , `udp` , `icmp` , `icmpv6` ) or number (see [Protocol Numbers](https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml) ).
               
               Use `-1` to specify all protocols. When authorizing security group rules, specifying `-1` or a protocol number other than `tcp` , `udp` , `icmp` , or `icmpv6` allows traffic on all ports, regardless of any port range you specify. For `tcp` , `udp` , and `icmp` , you must specify a port range. For `icmpv6` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.
        :param str cidr_ip: The IPv4 address range, in CIDR format.
               
               You must specify exactly one of the following: `CidrIp` , `CidrIpv6` , `SourcePrefixListId` , or `SourceSecurityGroupId` .
               
               For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
        :param str cidr_ipv6: The IPv6 address range, in CIDR format.
               
               You must specify exactly one of the following: `CidrIp` , `CidrIpv6` , `SourcePrefixListId` , or `SourceSecurityGroupId` .
               
               For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
        :param str description: Updates the description of an ingress (inbound) security group rule. You can replace an existing description, or add a description to a rule that did not have one previously.
               
               Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
        :param int from_port: If the protocol is TCP or UDP, this is the start of the port range. If the protocol is ICMP or ICMPv6, this is the ICMP type or -1 (all ICMP types).
        :param str source_prefix_list_id: The ID of a prefix list.
        :param str source_security_group_id: The ID of the security group.
        :param str source_security_group_name: [Default VPC] The name of the source security group. You must specify either the security group ID or the security group name. You can't specify the group name in combination with an IP address range. Creates rules that grant full ICMP, UDP, and TCP access.
               
               For security groups in a nondefault VPC, you must specify the group ID.
        :param str source_security_group_owner_id: [nondefault VPC] The AWS account ID for the source security group, if the source security group is in a different account. You can't specify this property with an IP address range. Creates rules that grant full ICMP, UDP, and TCP access.
               
               If you specify `SourceSecurityGroupName` or `SourceSecurityGroupId` and that security group is owned by a different account than the account creating the stack, you must specify the `SourceSecurityGroupOwnerId` ; otherwise, this property is optional.
        :param int to_port: If the protocol is TCP or UDP, this is the end of the port range. If the protocol is ICMP or ICMPv6, this is the ICMP code or -1 (all ICMP codes). If the start port is -1 (all ICMP types), then the end port must be -1 (all ICMP codes).
        """
        pulumi.set(__self__, "ip_protocol", ip_protocol)
        if cidr_ip is not None:
            pulumi.set(__self__, "cidr_ip", cidr_ip)
        if cidr_ipv6 is not None:
            pulumi.set(__self__, "cidr_ipv6", cidr_ipv6)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if source_prefix_list_id is not None:
            pulumi.set(__self__, "source_prefix_list_id", source_prefix_list_id)
        if source_security_group_id is not None:
            pulumi.set(__self__, "source_security_group_id", source_security_group_id)
        if source_security_group_name is not None:
            pulumi.set(__self__, "source_security_group_name", source_security_group_name)
        if source_security_group_owner_id is not None:
            pulumi.set(__self__, "source_security_group_owner_id", source_security_group_owner_id)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)

    @property
    @pulumi.getter(name="ipProtocol")
    def ip_protocol(self) -> str:
        """
        The IP protocol name ( `tcp` , `udp` , `icmp` , `icmpv6` ) or number (see [Protocol Numbers](https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml) ).

        Use `-1` to specify all protocols. When authorizing security group rules, specifying `-1` or a protocol number other than `tcp` , `udp` , `icmp` , or `icmpv6` allows traffic on all ports, regardless of any port range you specify. For `tcp` , `udp` , and `icmp` , you must specify a port range. For `icmpv6` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.
        """
        return pulumi.get(self, "ip_protocol")

    @property
    @pulumi.getter(name="cidrIp")
    def cidr_ip(self) -> Optional[str]:
        """
        The IPv4 address range, in CIDR format.

        You must specify exactly one of the following: `CidrIp` , `CidrIpv6` , `SourcePrefixListId` , or `SourceSecurityGroupId` .

        For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "cidr_ip")

    @property
    @pulumi.getter(name="cidrIpv6")
    def cidr_ipv6(self) -> Optional[str]:
        """
        The IPv6 address range, in CIDR format.

        You must specify exactly one of the following: `CidrIp` , `CidrIpv6` , `SourcePrefixListId` , or `SourceSecurityGroupId` .

        For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "cidr_ipv6")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Updates the description of an ingress (inbound) security group rule. You can replace an existing description, or add a description to a rule that did not have one previously.

        Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[int]:
        """
        If the protocol is TCP or UDP, this is the start of the port range. If the protocol is ICMP or ICMPv6, this is the ICMP type or -1 (all ICMP types).
        """
        return pulumi.get(self, "from_port")

    @property
    @pulumi.getter(name="sourcePrefixListId")
    def source_prefix_list_id(self) -> Optional[str]:
        """
        The ID of a prefix list.
        """
        return pulumi.get(self, "source_prefix_list_id")

    @property
    @pulumi.getter(name="sourceSecurityGroupId")
    def source_security_group_id(self) -> Optional[str]:
        """
        The ID of the security group.
        """
        return pulumi.get(self, "source_security_group_id")

    @property
    @pulumi.getter(name="sourceSecurityGroupName")
    def source_security_group_name(self) -> Optional[str]:
        """
        [Default VPC] The name of the source security group. You must specify either the security group ID or the security group name. You can't specify the group name in combination with an IP address range. Creates rules that grant full ICMP, UDP, and TCP access.

        For security groups in a nondefault VPC, you must specify the group ID.
        """
        return pulumi.get(self, "source_security_group_name")

    @property
    @pulumi.getter(name="sourceSecurityGroupOwnerId")
    def source_security_group_owner_id(self) -> Optional[str]:
        """
        [nondefault VPC] The AWS account ID for the source security group, if the source security group is in a different account. You can't specify this property with an IP address range. Creates rules that grant full ICMP, UDP, and TCP access.

        If you specify `SourceSecurityGroupName` or `SourceSecurityGroupId` and that security group is owned by a different account than the account creating the stack, you must specify the `SourceSecurityGroupOwnerId` ; otherwise, this property is optional.
        """
        return pulumi.get(self, "source_security_group_owner_id")

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[int]:
        """
        If the protocol is TCP or UDP, this is the end of the port range. If the protocol is ICMP or ICMPv6, this is the ICMP code or -1 (all ICMP codes). If the start port is -1 (all ICMP types), then the end port must be -1 (all ICMP codes).
        """
        return pulumi.get(self, "to_port")


@pulumi.output_type
class SpotFleetAcceleratorCountRequest(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        :param int max: The maximum number of accelerators. To specify no maximum limit, omit this parameter. To exclude accelerator-enabled instance types, set `Max` to `0` .
        :param int min: The minimum number of accelerators. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        The maximum number of accelerators. To specify no maximum limit, omit this parameter. To exclude accelerator-enabled instance types, set `Max` to `0` .
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        The minimum number of accelerators. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetAcceleratorTotalMemoryMiBRequest(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        :param int max: The maximum amount of accelerator memory, in MiB. To specify no maximum limit, omit this parameter.
        :param int min: The minimum amount of accelerator memory, in MiB. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        The maximum amount of accelerator memory, in MiB. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        The minimum amount of accelerator memory, in MiB. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetBaselineEbsBandwidthMbpsRequest(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        :param int max: The maximum baseline bandwidth, in Mbps. To specify no maximum limit, omit this parameter.
        :param int min: The minimum baseline bandwidth, in Mbps. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        The maximum baseline bandwidth, in Mbps. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        The minimum baseline bandwidth, in Mbps. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetBlockDeviceMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "noDevice":
            suggest = "no_device"
        elif key == "virtualName":
            suggest = "virtual_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetBlockDeviceMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetBlockDeviceMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetBlockDeviceMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: str,
                 ebs: Optional['outputs.SpotFleetEbsBlockDevice'] = None,
                 no_device: Optional[str] = None,
                 virtual_name: Optional[str] = None):
        """
        :param str device_name: The device name (for example, `/dev/sdh` or `xvdh` ).
        :param 'SpotFleetEbsBlockDevice' ebs: Parameters used to automatically set up EBS volumes when the instance is launched.
        :param str no_device: To omit the device from the block device mapping, specify an empty string. When this property is specified, the device is removed from the block device mapping regardless of the assigned value.
        :param str virtual_name: The virtual device name ( `ephemeral` N). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for `ephemeral0` and `ephemeral1` . The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.
               
               NVMe instance store volumes are automatically enumerated and assigned a device name. Including them in your block device mapping has no effect.
               
               Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.
        """
        pulumi.set(__self__, "device_name", device_name)
        if ebs is not None:
            pulumi.set(__self__, "ebs", ebs)
        if no_device is not None:
            pulumi.set(__self__, "no_device", no_device)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        """
        The device name (for example, `/dev/sdh` or `xvdh` ).
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter
    def ebs(self) -> Optional['outputs.SpotFleetEbsBlockDevice']:
        """
        Parameters used to automatically set up EBS volumes when the instance is launched.
        """
        return pulumi.get(self, "ebs")

    @property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[str]:
        """
        To omit the device from the block device mapping, specify an empty string. When this property is specified, the device is removed from the block device mapping regardless of the assigned value.
        """
        return pulumi.get(self, "no_device")

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[str]:
        """
        The virtual device name ( `ephemeral` N). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for `ephemeral0` and `ephemeral1` . The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.

        NVMe instance store volumes are automatically enumerated and assigned a device name. Including them in your block device mapping has no effect.

        Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.
        """
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class SpotFleetClassicLoadBalancer(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: The name of the load balancer.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the load balancer.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SpotFleetClassicLoadBalancersConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "classicLoadBalancers":
            suggest = "classic_load_balancers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetClassicLoadBalancersConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetClassicLoadBalancersConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetClassicLoadBalancersConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 classic_load_balancers: Sequence['outputs.SpotFleetClassicLoadBalancer']):
        """
        :param Sequence['SpotFleetClassicLoadBalancer'] classic_load_balancers: One or more Classic Load Balancers.
        """
        pulumi.set(__self__, "classic_load_balancers", classic_load_balancers)

    @property
    @pulumi.getter(name="classicLoadBalancers")
    def classic_load_balancers(self) -> Sequence['outputs.SpotFleetClassicLoadBalancer']:
        """
        One or more Classic Load Balancers.
        """
        return pulumi.get(self, "classic_load_balancers")


@pulumi.output_type
class SpotFleetEbsBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetEbsBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetEbsBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetEbsBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_on_termination: Optional[bool] = None,
                 encrypted: Optional[bool] = None,
                 iops: Optional[int] = None,
                 snapshot_id: Optional[str] = None,
                 volume_size: Optional[int] = None,
                 volume_type: Optional['SpotFleetEbsBlockDeviceVolumeType'] = None):
        """
        :param bool delete_on_termination: Indicates whether the EBS volume is deleted on instance termination. For more information, see [Preserving Amazon EBS volumes on instance termination](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination) in the *Amazon EC2 User Guide* .
        :param bool encrypted: Indicates whether the encryption state of an EBS volume is changed while being restored from a backing snapshot. The effect of setting the encryption state to `true` depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see [Amazon EBS Encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-parameters) in the *Amazon EC2 User Guide* .
               
               In no case can you remove encryption from an encrypted volume.
               
               Encrypted volumes can only be attached to instances that support Amazon EBS encryption. For more information, see [Supported Instance Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances) .
               
               This parameter is not returned by [DescribeImageAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImageAttribute.html) .
        :param int iops: The number of I/O operations per second (IOPS). For `gp3` , `io1` , and `io2` volumes, this represents the number of IOPS that are provisioned for the volume. For `gp2` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.
               
               The following are the supported values for each volume type:
               
               - `gp3` : 3,000 - 16,000 IOPS
               - `io1` : 100 - 64,000 IOPS
               - `io2` : 100 - 256,000 IOPS
               
               For `io2` volumes, you can achieve up to 256,000 IOPS on [instances built on the Nitro System](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances) . On other instances, you can achieve performance up to 32,000 IOPS.
               
               This parameter is required for `io1` and `io2` volumes. The default for `gp3` volumes is 3,000 IOPS.
        :param str snapshot_id: The ID of the snapshot.
        :param int volume_size: The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size.
               
               The following are the supported sizes for each volume type:
               
               - `gp2` and `gp3` : 1 - 16,384 GiB
               - `io1` : 4 - 16,384 GiB
               - `io2` : 4 - 65,536 GiB
               - `st1` and `sc1` : 125 - 16,384 GiB
               - `standard` : 1 - 1024 GiB
        :param 'SpotFleetEbsBlockDeviceVolumeType' volume_type: The volume type. For more information, see [Amazon EBS volume types](https://docs.aws.amazon.com/ebs/latest/userguide/ebs-volume-types.html) in the *Amazon EBS User Guide* .
        """
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[bool]:
        """
        Indicates whether the EBS volume is deleted on instance termination. For more information, see [Preserving Amazon EBS volumes on instance termination](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[bool]:
        """
        Indicates whether the encryption state of an EBS volume is changed while being restored from a backing snapshot. The effect of setting the encryption state to `true` depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see [Amazon EBS Encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-parameters) in the *Amazon EC2 User Guide* .

        In no case can you remove encryption from an encrypted volume.

        Encrypted volumes can only be attached to instances that support Amazon EBS encryption. For more information, see [Supported Instance Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances) .

        This parameter is not returned by [DescribeImageAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImageAttribute.html) .
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        """
        The number of I/O operations per second (IOPS). For `gp3` , `io1` , and `io2` volumes, this represents the number of IOPS that are provisioned for the volume. For `gp2` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.

        The following are the supported values for each volume type:

        - `gp3` : 3,000 - 16,000 IOPS
        - `io1` : 100 - 64,000 IOPS
        - `io2` : 100 - 256,000 IOPS

        For `io2` volumes, you can achieve up to 256,000 IOPS on [instances built on the Nitro System](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances) . On other instances, you can achieve performance up to 32,000 IOPS.

        This parameter is required for `io1` and `io2` volumes. The default for `gp3` volumes is 3,000 IOPS.
        """
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        """
        The ID of the snapshot.
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[int]:
        """
        The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size.

        The following are the supported sizes for each volume type:

        - `gp2` and `gp3` : 1 - 16,384 GiB
        - `io1` : 4 - 16,384 GiB
        - `io2` : 4 - 65,536 GiB
        - `st1` and `sc1` : 125 - 16,384 GiB
        - `standard` : 1 - 1024 GiB
        """
        return pulumi.get(self, "volume_size")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional['SpotFleetEbsBlockDeviceVolumeType']:
        """
        The volume type. For more information, see [Amazon EBS volume types](https://docs.aws.amazon.com/ebs/latest/userguide/ebs-volume-types.html) in the *Amazon EBS User Guide* .
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class SpotFleetFleetLaunchTemplateSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTemplateId":
            suggest = "launch_template_id"
        elif key == "launchTemplateName":
            suggest = "launch_template_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetFleetLaunchTemplateSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetFleetLaunchTemplateSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetFleetLaunchTemplateSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 version: str,
                 launch_template_id: Optional[str] = None,
                 launch_template_name: Optional[str] = None):
        """
        :param str version: The version number of the launch template.
               
               Specifying `$Latest` or `$Default` for the template version number is not supported. However, you can specify `LatestVersionNumber` or `DefaultVersionNumber` using the `Fn::GetAtt` intrinsic function. For more information, see [Fn::GetAtt](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#aws-resource-ec2-launchtemplate-return-values-fn--getatt) .
        :param str launch_template_id: The ID of the launch template.
               
               You must specify the `LaunchTemplateId` or the `LaunchTemplateName` , but not both.
        :param str launch_template_name: The name of the launch template.
               
               You must specify the `LaunchTemplateName` or the `LaunchTemplateId` , but not both.
        """
        pulumi.set(__self__, "version", version)
        if launch_template_id is not None:
            pulumi.set(__self__, "launch_template_id", launch_template_id)
        if launch_template_name is not None:
            pulumi.set(__self__, "launch_template_name", launch_template_name)

    @property
    @pulumi.getter
    def version(self) -> str:
        """
        The version number of the launch template.

        Specifying `$Latest` or `$Default` for the template version number is not supported. However, you can specify `LatestVersionNumber` or `DefaultVersionNumber` using the `Fn::GetAtt` intrinsic function. For more information, see [Fn::GetAtt](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#aws-resource-ec2-launchtemplate-return-values-fn--getatt) .
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter(name="launchTemplateId")
    def launch_template_id(self) -> Optional[str]:
        """
        The ID of the launch template.

        You must specify the `LaunchTemplateId` or the `LaunchTemplateName` , but not both.
        """
        return pulumi.get(self, "launch_template_id")

    @property
    @pulumi.getter(name="launchTemplateName")
    def launch_template_name(self) -> Optional[str]:
        """
        The name of the launch template.

        You must specify the `LaunchTemplateName` or the `LaunchTemplateId` , but not both.
        """
        return pulumi.get(self, "launch_template_name")


@pulumi.output_type
class SpotFleetGroupIdentifier(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupId":
            suggest = "group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetGroupIdentifier. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetGroupIdentifier.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetGroupIdentifier.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_id: str):
        """
        :param str group_id: The ID of the security group.
        """
        pulumi.set(__self__, "group_id", group_id)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        """
        The ID of the security group.
        """
        return pulumi.get(self, "group_id")


@pulumi.output_type
class SpotFleetIamInstanceProfileSpecification(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None):
        """
        :param str arn: The Amazon Resource Name (ARN) of the instance profile.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the instance profile.
        """
        return pulumi.get(self, "arn")


@pulumi.output_type
class SpotFleetInstanceIpv6Address(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv6Address":
            suggest = "ipv6_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetInstanceIpv6Address. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetInstanceIpv6Address.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetInstanceIpv6Address.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv6_address: str):
        """
        :param str ipv6_address: The IPv6 address.
        """
        pulumi.set(__self__, "ipv6_address", ipv6_address)

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> str:
        """
        The IPv6 address.
        """
        return pulumi.get(self, "ipv6_address")


@pulumi.output_type
class SpotFleetInstanceNetworkInterfaceSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "associatePublicIpAddress":
            suggest = "associate_public_ip_address"
        elif key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "deviceIndex":
            suggest = "device_index"
        elif key == "ipv6AddressCount":
            suggest = "ipv6_address_count"
        elif key == "ipv6Addresses":
            suggest = "ipv6_addresses"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "privateIpAddresses":
            suggest = "private_ip_addresses"
        elif key == "secondaryPrivateIpAddressCount":
            suggest = "secondary_private_ip_address_count"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetInstanceNetworkInterfaceSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetInstanceNetworkInterfaceSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetInstanceNetworkInterfaceSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 associate_public_ip_address: Optional[bool] = None,
                 delete_on_termination: Optional[bool] = None,
                 description: Optional[str] = None,
                 device_index: Optional[int] = None,
                 groups: Optional[Sequence[str]] = None,
                 ipv6_address_count: Optional[int] = None,
                 ipv6_addresses: Optional[Sequence['outputs.SpotFleetInstanceIpv6Address']] = None,
                 network_interface_id: Optional[str] = None,
                 private_ip_addresses: Optional[Sequence['outputs.SpotFleetPrivateIpAddressSpecification']] = None,
                 secondary_private_ip_address_count: Optional[int] = None,
                 subnet_id: Optional[str] = None):
        """
        :param bool associate_public_ip_address: Indicates whether to assign a public IPv4 address to an instance you launch in a VPC. The public IP address can only be assigned to a network interface for eth0, and can only be assigned to a new network interface, not an existing one. You cannot specify more than one network interface in the request. If launching into a default subnet, the default value is `true` .
               
               AWS charges for all public IPv4 addresses, including public IPv4 addresses associated with running instances and Elastic IP addresses. For more information, see the *Public IPv4 Address* tab on the [Amazon VPC pricing page](https://docs.aws.amazon.com/vpc/pricing/) .
        :param bool delete_on_termination: Indicates whether the network interface is deleted when the instance is terminated.
        :param str description: The description of the network interface. Applies only if creating a network interface when launching an instance.
        :param int device_index: The position of the network interface in the attachment order. A primary network interface has a device index of 0.
               
               If you specify a network interface when launching an instance, you must specify the device index.
        :param Sequence[str] groups: The IDs of the security groups for the network interface. Applies only if creating a network interface when launching an instance.
        :param int ipv6_address_count: A number of IPv6 addresses to assign to the network interface. Amazon EC2 chooses the IPv6 addresses from the range of the subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.
        :param Sequence['SpotFleetInstanceIpv6Address'] ipv6_addresses: The IPv6 addresses to assign to the network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.
        :param str network_interface_id: The ID of the network interface.
               
               If you are creating a Spot Fleet, omit this parameter because you cant specify a network interface ID in a launch specification.
        :param Sequence['SpotFleetPrivateIpAddressSpecification'] private_ip_addresses: The private IPv4 addresses to assign to the network interface. Only one private IPv4 address can be designated as primary. You cannot specify this option if you're launching more than one instance in a [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) request.
        :param int secondary_private_ip_address_count: The number of secondary private IPv4 addresses. You can't specify this option and specify more than one private IP address using the private IP addresses option. You cannot specify this option if you're launching more than one instance in a [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) request.
        :param str subnet_id: The ID of the subnet associated with the network interface.
        """
        if associate_public_ip_address is not None:
            pulumi.set(__self__, "associate_public_ip_address", associate_public_ip_address)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if device_index is not None:
            pulumi.set(__self__, "device_index", device_index)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if ipv6_address_count is not None:
            pulumi.set(__self__, "ipv6_address_count", ipv6_address_count)
        if ipv6_addresses is not None:
            pulumi.set(__self__, "ipv6_addresses", ipv6_addresses)
        if network_interface_id is not None:
            pulumi.set(__self__, "network_interface_id", network_interface_id)
        if private_ip_addresses is not None:
            pulumi.set(__self__, "private_ip_addresses", private_ip_addresses)
        if secondary_private_ip_address_count is not None:
            pulumi.set(__self__, "secondary_private_ip_address_count", secondary_private_ip_address_count)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="associatePublicIpAddress")
    def associate_public_ip_address(self) -> Optional[bool]:
        """
        Indicates whether to assign a public IPv4 address to an instance you launch in a VPC. The public IP address can only be assigned to a network interface for eth0, and can only be assigned to a new network interface, not an existing one. You cannot specify more than one network interface in the request. If launching into a default subnet, the default value is `true` .

        AWS charges for all public IPv4 addresses, including public IPv4 addresses associated with running instances and Elastic IP addresses. For more information, see the *Public IPv4 Address* tab on the [Amazon VPC pricing page](https://docs.aws.amazon.com/vpc/pricing/) .
        """
        return pulumi.get(self, "associate_public_ip_address")

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[bool]:
        """
        Indicates whether the network interface is deleted when the instance is terminated.
        """
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the network interface. Applies only if creating a network interface when launching an instance.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> Optional[int]:
        """
        The position of the network interface in the attachment order. A primary network interface has a device index of 0.

        If you specify a network interface when launching an instance, you must specify the device index.
        """
        return pulumi.get(self, "device_index")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[str]]:
        """
        The IDs of the security groups for the network interface. Applies only if creating a network interface when launching an instance.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter(name="ipv6AddressCount")
    def ipv6_address_count(self) -> Optional[int]:
        """
        A number of IPv6 addresses to assign to the network interface. Amazon EC2 chooses the IPv6 addresses from the range of the subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.
        """
        return pulumi.get(self, "ipv6_address_count")

    @property
    @pulumi.getter(name="ipv6Addresses")
    def ipv6_addresses(self) -> Optional[Sequence['outputs.SpotFleetInstanceIpv6Address']]:
        """
        The IPv6 addresses to assign to the network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.
        """
        return pulumi.get(self, "ipv6_addresses")

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[str]:
        """
        The ID of the network interface.

        If you are creating a Spot Fleet, omit this parameter because you cant specify a network interface ID in a launch specification.
        """
        return pulumi.get(self, "network_interface_id")

    @property
    @pulumi.getter(name="privateIpAddresses")
    def private_ip_addresses(self) -> Optional[Sequence['outputs.SpotFleetPrivateIpAddressSpecification']]:
        """
        The private IPv4 addresses to assign to the network interface. Only one private IPv4 address can be designated as primary. You cannot specify this option if you're launching more than one instance in a [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) request.
        """
        return pulumi.get(self, "private_ip_addresses")

    @property
    @pulumi.getter(name="secondaryPrivateIpAddressCount")
    def secondary_private_ip_address_count(self) -> Optional[int]:
        """
        The number of secondary private IPv4 addresses. You can't specify this option and specify more than one private IP address using the private IP addresses option. You cannot specify this option if you're launching more than one instance in a [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) request.
        """
        return pulumi.get(self, "secondary_private_ip_address_count")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The ID of the subnet associated with the network interface.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class SpotFleetInstanceRequirementsRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceleratorCount":
            suggest = "accelerator_count"
        elif key == "acceleratorManufacturers":
            suggest = "accelerator_manufacturers"
        elif key == "acceleratorNames":
            suggest = "accelerator_names"
        elif key == "acceleratorTotalMemoryMiB":
            suggest = "accelerator_total_memory_mi_b"
        elif key == "acceleratorTypes":
            suggest = "accelerator_types"
        elif key == "allowedInstanceTypes":
            suggest = "allowed_instance_types"
        elif key == "bareMetal":
            suggest = "bare_metal"
        elif key == "baselineEbsBandwidthMbps":
            suggest = "baseline_ebs_bandwidth_mbps"
        elif key == "burstablePerformance":
            suggest = "burstable_performance"
        elif key == "cpuManufacturers":
            suggest = "cpu_manufacturers"
        elif key == "excludedInstanceTypes":
            suggest = "excluded_instance_types"
        elif key == "instanceGenerations":
            suggest = "instance_generations"
        elif key == "localStorage":
            suggest = "local_storage"
        elif key == "localStorageTypes":
            suggest = "local_storage_types"
        elif key == "maxSpotPriceAsPercentageOfOptimalOnDemandPrice":
            suggest = "max_spot_price_as_percentage_of_optimal_on_demand_price"
        elif key == "memoryGiBPerVCpu":
            suggest = "memory_gi_b_per_v_cpu"
        elif key == "memoryMiB":
            suggest = "memory_mi_b"
        elif key == "networkBandwidthGbps":
            suggest = "network_bandwidth_gbps"
        elif key == "networkInterfaceCount":
            suggest = "network_interface_count"
        elif key == "onDemandMaxPricePercentageOverLowestPrice":
            suggest = "on_demand_max_price_percentage_over_lowest_price"
        elif key == "requireHibernateSupport":
            suggest = "require_hibernate_support"
        elif key == "spotMaxPricePercentageOverLowestPrice":
            suggest = "spot_max_price_percentage_over_lowest_price"
        elif key == "totalLocalStorageGb":
            suggest = "total_local_storage_gb"
        elif key == "vCpuCount":
            suggest = "v_cpu_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetInstanceRequirementsRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetInstanceRequirementsRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetInstanceRequirementsRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accelerator_count: Optional['outputs.SpotFleetAcceleratorCountRequest'] = None,
                 accelerator_manufacturers: Optional[Sequence['SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem']] = None,
                 accelerator_names: Optional[Sequence['SpotFleetInstanceRequirementsRequestAcceleratorNamesItem']] = None,
                 accelerator_total_memory_mi_b: Optional['outputs.SpotFleetAcceleratorTotalMemoryMiBRequest'] = None,
                 accelerator_types: Optional[Sequence['SpotFleetInstanceRequirementsRequestAcceleratorTypesItem']] = None,
                 allowed_instance_types: Optional[Sequence[str]] = None,
                 bare_metal: Optional['SpotFleetInstanceRequirementsRequestBareMetal'] = None,
                 baseline_ebs_bandwidth_mbps: Optional['outputs.SpotFleetBaselineEbsBandwidthMbpsRequest'] = None,
                 burstable_performance: Optional['SpotFleetInstanceRequirementsRequestBurstablePerformance'] = None,
                 cpu_manufacturers: Optional[Sequence['SpotFleetInstanceRequirementsRequestCpuManufacturersItem']] = None,
                 excluded_instance_types: Optional[Sequence[str]] = None,
                 instance_generations: Optional[Sequence['SpotFleetInstanceRequirementsRequestInstanceGenerationsItem']] = None,
                 local_storage: Optional['SpotFleetInstanceRequirementsRequestLocalStorage'] = None,
                 local_storage_types: Optional[Sequence['SpotFleetInstanceRequirementsRequestLocalStorageTypesItem']] = None,
                 max_spot_price_as_percentage_of_optimal_on_demand_price: Optional[int] = None,
                 memory_gi_b_per_v_cpu: Optional['outputs.SpotFleetMemoryGiBPerVCpuRequest'] = None,
                 memory_mi_b: Optional['outputs.SpotFleetMemoryMiBRequest'] = None,
                 network_bandwidth_gbps: Optional['outputs.SpotFleetNetworkBandwidthGbpsRequest'] = None,
                 network_interface_count: Optional['outputs.SpotFleetNetworkInterfaceCountRequest'] = None,
                 on_demand_max_price_percentage_over_lowest_price: Optional[int] = None,
                 require_hibernate_support: Optional[bool] = None,
                 spot_max_price_percentage_over_lowest_price: Optional[int] = None,
                 total_local_storage_gb: Optional['outputs.SpotFleetTotalLocalStorageGbRequest'] = None,
                 v_cpu_count: Optional['outputs.SpotFleetVCpuCountRangeRequest'] = None):
        """
        :param 'SpotFleetAcceleratorCountRequest' accelerator_count: The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.
               
               To exclude accelerator-enabled instance types, set `Max` to `0` .
               
               Default: No minimum or maximum limits
        :param Sequence['SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem'] accelerator_manufacturers: Indicates whether instance types must have accelerators by specific manufacturers.
               
               - For instance types with AWS devices, specify `amazon-web-services` .
               - For instance types with AMD devices, specify `amd` .
               - For instance types with Habana devices, specify `habana` .
               - For instance types with NVIDIA devices, specify `nvidia` .
               - For instance types with Xilinx devices, specify `xilinx` .
               
               Default: Any manufacturer
        :param Sequence['SpotFleetInstanceRequirementsRequestAcceleratorNamesItem'] accelerator_names: The accelerators that must be on the instance type.
               
               - For instance types with NVIDIA A10G GPUs, specify `a10g` .
               - For instance types with NVIDIA A100 GPUs, specify `a100` .
               - For instance types with NVIDIA H100 GPUs, specify `h100` .
               - For instance types with AWS Inferentia chips, specify `inferentia` .
               - For instance types with NVIDIA GRID K520 GPUs, specify `k520` .
               - For instance types with NVIDIA K80 GPUs, specify `k80` .
               - For instance types with NVIDIA M60 GPUs, specify `m60` .
               - For instance types with AMD Radeon Pro V520 GPUs, specify `radeon-pro-v520` .
               - For instance types with NVIDIA T4 GPUs, specify `t4` .
               - For instance types with NVIDIA T4G GPUs, specify `t4g` .
               - For instance types with Xilinx VU9P FPGAs, specify `vu9p` .
               - For instance types with NVIDIA V100 GPUs, specify `v100` .
               
               Default: Any accelerator
        :param 'SpotFleetAcceleratorTotalMemoryMiBRequest' accelerator_total_memory_mi_b: The minimum and maximum amount of total accelerator memory, in MiB.
               
               Default: No minimum or maximum limits
        :param Sequence['SpotFleetInstanceRequirementsRequestAcceleratorTypesItem'] accelerator_types: The accelerator types that must be on the instance type.
               
               - To include instance types with GPU hardware, specify `gpu` .
               - To include instance types with FPGA hardware, specify `fpga` .
               - To include instance types with inference hardware, specify `inference` .
               
               Default: Any accelerator type
        :param Sequence[str] allowed_instance_types: The instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes.
               
               You can use strings with one or more wild cards, represented by an asterisk ( `*` ), to allow an instance type, size, or generation. The following are examples: `m5.8xlarge` , `c5*.*` , `m5a.*` , `r*` , `*3*` .
               
               For example, if you specify `c5*` ,Amazon EC2 will allow the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*` , Amazon EC2 will allow all the M5a instance types, but not the M5n instance types.
               
               > If you specify `AllowedInstanceTypes` , you can't specify `ExcludedInstanceTypes` . 
               
               Default: All instance types
        :param 'SpotFleetInstanceRequirementsRequestBareMetal' bare_metal: Indicates whether bare metal instance types must be included, excluded, or required.
               
               - To include bare metal instance types, specify `included` .
               - To require only bare metal instance types, specify `required` .
               - To exclude bare metal instance types, specify `excluded` .
               
               Default: `excluded`
        :param 'SpotFleetBaselineEbsBandwidthMbpsRequest' baseline_ebs_bandwidth_mbps: The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see [Amazon EBSoptimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the *Amazon EC2 User Guide* .
               
               Default: No minimum or maximum limits
        :param 'SpotFleetInstanceRequirementsRequestBurstablePerformance' burstable_performance: Indicates whether burstable performance T instance types are included, excluded, or required. For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) .
               
               - To include burstable performance instance types, specify `included` .
               - To require only burstable performance instance types, specify `required` .
               - To exclude burstable performance instance types, specify `excluded` .
               
               Default: `excluded`
        :param Sequence['SpotFleetInstanceRequirementsRequestCpuManufacturersItem'] cpu_manufacturers: The CPU manufacturers to include.
               
               - For instance types with Intel CPUs, specify `intel` .
               - For instance types with AMD CPUs, specify `amd` .
               - For instance types with AWS CPUs, specify `amazon-web-services` .
               
               > Don't confuse the CPU manufacturer with the CPU architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template. 
               
               Default: Any manufacturer
        :param Sequence[str] excluded_instance_types: The instance types to exclude.
               
               You can use strings with one or more wild cards, represented by an asterisk ( `*` ), to exclude an instance family, type, size, or generation. The following are examples: `m5.8xlarge` , `c5*.*` , `m5a.*` , `r*` , `*3*` .
               
               For example, if you specify `c5*` ,Amazon EC2 will exclude the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*` , Amazon EC2 will exclude all the M5a instance types, but not the M5n instance types.
               
               > If you specify `ExcludedInstanceTypes` , you can't specify `AllowedInstanceTypes` . 
               
               Default: No excluded instance types
        :param Sequence['SpotFleetInstanceRequirementsRequestInstanceGenerationsItem'] instance_generations: Indicates whether current or previous generation instance types are included. The current generation instance types are recommended for use. Current generation instance types are typically the latest two to three generations in each instance family. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .
               
               For current generation instance types, specify `current` .
               
               For previous generation instance types, specify `previous` .
               
               Default: Current and previous generation instance types
        :param 'SpotFleetInstanceRequirementsRequestLocalStorage' local_storage: Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, [Amazon EC2 instance store](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html) in the *Amazon EC2 User Guide* .
               
               - To include instance types with instance store volumes, specify `included` .
               - To require only instance types with instance store volumes, specify `required` .
               - To exclude instance types with instance store volumes, specify `excluded` .
               
               Default: `included`
        :param Sequence['SpotFleetInstanceRequirementsRequestLocalStorageTypesItem'] local_storage_types: The type of local storage that is required.
               
               - For instance types with hard disk drive (HDD) storage, specify `hdd` .
               - For instance types with solid state drive (SSD) storage, specify `ssd` .
               
               Default: `hdd` and `ssd`
        :param int max_spot_price_as_percentage_of_optimal_on_demand_price: [Price protection] The price protection threshold for Spot Instances, as a percentage of an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.
               
               The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
               
               If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is based on the per vCPU or per memory price instead of the per instance price.
               
               > Only one of `SpotMaxPricePercentageOverLowestPrice` or `MaxSpotPriceAsPercentageOfOptimalOnDemandPrice` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as `999999` .
        :param 'SpotFleetMemoryGiBPerVCpuRequest' memory_gi_b_per_v_cpu: The minimum and maximum amount of memory per vCPU, in GiB.
               
               Default: No minimum or maximum limits
        :param 'SpotFleetMemoryMiBRequest' memory_mi_b: The minimum and maximum amount of memory, in MiB.
        :param 'SpotFleetNetworkBandwidthGbpsRequest' network_bandwidth_gbps: The minimum and maximum amount of baseline network bandwidth, in gigabits per second (Gbps). For more information, see [Amazon EC2 instance network bandwidth](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-network-bandwidth.html) in the *Amazon EC2 User Guide* .
               
               Default: No minimum or maximum limits
        :param 'SpotFleetNetworkInterfaceCountRequest' network_interface_count: The minimum and maximum number of network interfaces.
               
               Default: No minimum or maximum limits
        :param int on_demand_max_price_percentage_over_lowest_price: [Price protection] The price protection threshold for On-Demand Instances, as a percentage higher than an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.
               
               The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
               
               To indicate no price protection threshold, specify a high value, such as `999999` .
               
               This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) .
               
               > If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price. 
               
               Default: `20`
        :param bool require_hibernate_support: Indicates whether instance types must support hibernation for On-Demand Instances.
               
               This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) .
               
               Default: `false`
        :param int spot_max_price_percentage_over_lowest_price: [Price protection] The price protection threshold for Spot Instances, as a percentage higher than an identified Spot price. The identified Spot price is the Spot price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified Spot price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose Spot price exceeds your specified threshold.
               
               The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
               
               If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.
               
               This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) .
               
               > Only one of `SpotMaxPricePercentageOverLowestPrice` or `MaxSpotPriceAsPercentageOfOptimalOnDemandPrice` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as `999999` . 
               
               Default: `100`
        :param 'SpotFleetTotalLocalStorageGbRequest' total_local_storage_gb: The minimum and maximum amount of total local storage, in GB.
               
               Default: No minimum or maximum limits
        :param 'SpotFleetVCpuCountRangeRequest' v_cpu_count: The minimum and maximum number of vCPUs.
        """
        if accelerator_count is not None:
            pulumi.set(__self__, "accelerator_count", accelerator_count)
        if accelerator_manufacturers is not None:
            pulumi.set(__self__, "accelerator_manufacturers", accelerator_manufacturers)
        if accelerator_names is not None:
            pulumi.set(__self__, "accelerator_names", accelerator_names)
        if accelerator_total_memory_mi_b is not None:
            pulumi.set(__self__, "accelerator_total_memory_mi_b", accelerator_total_memory_mi_b)
        if accelerator_types is not None:
            pulumi.set(__self__, "accelerator_types", accelerator_types)
        if allowed_instance_types is not None:
            pulumi.set(__self__, "allowed_instance_types", allowed_instance_types)
        if bare_metal is not None:
            pulumi.set(__self__, "bare_metal", bare_metal)
        if baseline_ebs_bandwidth_mbps is not None:
            pulumi.set(__self__, "baseline_ebs_bandwidth_mbps", baseline_ebs_bandwidth_mbps)
        if burstable_performance is not None:
            pulumi.set(__self__, "burstable_performance", burstable_performance)
        if cpu_manufacturers is not None:
            pulumi.set(__self__, "cpu_manufacturers", cpu_manufacturers)
        if excluded_instance_types is not None:
            pulumi.set(__self__, "excluded_instance_types", excluded_instance_types)
        if instance_generations is not None:
            pulumi.set(__self__, "instance_generations", instance_generations)
        if local_storage is not None:
            pulumi.set(__self__, "local_storage", local_storage)
        if local_storage_types is not None:
            pulumi.set(__self__, "local_storage_types", local_storage_types)
        if max_spot_price_as_percentage_of_optimal_on_demand_price is not None:
            pulumi.set(__self__, "max_spot_price_as_percentage_of_optimal_on_demand_price", max_spot_price_as_percentage_of_optimal_on_demand_price)
        if memory_gi_b_per_v_cpu is not None:
            pulumi.set(__self__, "memory_gi_b_per_v_cpu", memory_gi_b_per_v_cpu)
        if memory_mi_b is not None:
            pulumi.set(__self__, "memory_mi_b", memory_mi_b)
        if network_bandwidth_gbps is not None:
            pulumi.set(__self__, "network_bandwidth_gbps", network_bandwidth_gbps)
        if network_interface_count is not None:
            pulumi.set(__self__, "network_interface_count", network_interface_count)
        if on_demand_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "on_demand_max_price_percentage_over_lowest_price", on_demand_max_price_percentage_over_lowest_price)
        if require_hibernate_support is not None:
            pulumi.set(__self__, "require_hibernate_support", require_hibernate_support)
        if spot_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "spot_max_price_percentage_over_lowest_price", spot_max_price_percentage_over_lowest_price)
        if total_local_storage_gb is not None:
            pulumi.set(__self__, "total_local_storage_gb", total_local_storage_gb)
        if v_cpu_count is not None:
            pulumi.set(__self__, "v_cpu_count", v_cpu_count)

    @property
    @pulumi.getter(name="acceleratorCount")
    def accelerator_count(self) -> Optional['outputs.SpotFleetAcceleratorCountRequest']:
        """
        The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.

        To exclude accelerator-enabled instance types, set `Max` to `0` .

        Default: No minimum or maximum limits
        """
        return pulumi.get(self, "accelerator_count")

    @property
    @pulumi.getter(name="acceleratorManufacturers")
    def accelerator_manufacturers(self) -> Optional[Sequence['SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem']]:
        """
        Indicates whether instance types must have accelerators by specific manufacturers.

        - For instance types with AWS devices, specify `amazon-web-services` .
        - For instance types with AMD devices, specify `amd` .
        - For instance types with Habana devices, specify `habana` .
        - For instance types with NVIDIA devices, specify `nvidia` .
        - For instance types with Xilinx devices, specify `xilinx` .

        Default: Any manufacturer
        """
        return pulumi.get(self, "accelerator_manufacturers")

    @property
    @pulumi.getter(name="acceleratorNames")
    def accelerator_names(self) -> Optional[Sequence['SpotFleetInstanceRequirementsRequestAcceleratorNamesItem']]:
        """
        The accelerators that must be on the instance type.

        - For instance types with NVIDIA A10G GPUs, specify `a10g` .
        - For instance types with NVIDIA A100 GPUs, specify `a100` .
        - For instance types with NVIDIA H100 GPUs, specify `h100` .
        - For instance types with AWS Inferentia chips, specify `inferentia` .
        - For instance types with NVIDIA GRID K520 GPUs, specify `k520` .
        - For instance types with NVIDIA K80 GPUs, specify `k80` .
        - For instance types with NVIDIA M60 GPUs, specify `m60` .
        - For instance types with AMD Radeon Pro V520 GPUs, specify `radeon-pro-v520` .
        - For instance types with NVIDIA T4 GPUs, specify `t4` .
        - For instance types with NVIDIA T4G GPUs, specify `t4g` .
        - For instance types with Xilinx VU9P FPGAs, specify `vu9p` .
        - For instance types with NVIDIA V100 GPUs, specify `v100` .

        Default: Any accelerator
        """
        return pulumi.get(self, "accelerator_names")

    @property
    @pulumi.getter(name="acceleratorTotalMemoryMiB")
    def accelerator_total_memory_mi_b(self) -> Optional['outputs.SpotFleetAcceleratorTotalMemoryMiBRequest']:
        """
        The minimum and maximum amount of total accelerator memory, in MiB.

        Default: No minimum or maximum limits
        """
        return pulumi.get(self, "accelerator_total_memory_mi_b")

    @property
    @pulumi.getter(name="acceleratorTypes")
    def accelerator_types(self) -> Optional[Sequence['SpotFleetInstanceRequirementsRequestAcceleratorTypesItem']]:
        """
        The accelerator types that must be on the instance type.

        - To include instance types with GPU hardware, specify `gpu` .
        - To include instance types with FPGA hardware, specify `fpga` .
        - To include instance types with inference hardware, specify `inference` .

        Default: Any accelerator type
        """
        return pulumi.get(self, "accelerator_types")

    @property
    @pulumi.getter(name="allowedInstanceTypes")
    def allowed_instance_types(self) -> Optional[Sequence[str]]:
        """
        The instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes.

        You can use strings with one or more wild cards, represented by an asterisk ( `*` ), to allow an instance type, size, or generation. The following are examples: `m5.8xlarge` , `c5*.*` , `m5a.*` , `r*` , `*3*` .

        For example, if you specify `c5*` ,Amazon EC2 will allow the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*` , Amazon EC2 will allow all the M5a instance types, but not the M5n instance types.

        > If you specify `AllowedInstanceTypes` , you can't specify `ExcludedInstanceTypes` . 

        Default: All instance types
        """
        return pulumi.get(self, "allowed_instance_types")

    @property
    @pulumi.getter(name="bareMetal")
    def bare_metal(self) -> Optional['SpotFleetInstanceRequirementsRequestBareMetal']:
        """
        Indicates whether bare metal instance types must be included, excluded, or required.

        - To include bare metal instance types, specify `included` .
        - To require only bare metal instance types, specify `required` .
        - To exclude bare metal instance types, specify `excluded` .

        Default: `excluded`
        """
        return pulumi.get(self, "bare_metal")

    @property
    @pulumi.getter(name="baselineEbsBandwidthMbps")
    def baseline_ebs_bandwidth_mbps(self) -> Optional['outputs.SpotFleetBaselineEbsBandwidthMbpsRequest']:
        """
        The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see [Amazon EBSoptimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the *Amazon EC2 User Guide* .

        Default: No minimum or maximum limits
        """
        return pulumi.get(self, "baseline_ebs_bandwidth_mbps")

    @property
    @pulumi.getter(name="burstablePerformance")
    def burstable_performance(self) -> Optional['SpotFleetInstanceRequirementsRequestBurstablePerformance']:
        """
        Indicates whether burstable performance T instance types are included, excluded, or required. For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) .

        - To include burstable performance instance types, specify `included` .
        - To require only burstable performance instance types, specify `required` .
        - To exclude burstable performance instance types, specify `excluded` .

        Default: `excluded`
        """
        return pulumi.get(self, "burstable_performance")

    @property
    @pulumi.getter(name="cpuManufacturers")
    def cpu_manufacturers(self) -> Optional[Sequence['SpotFleetInstanceRequirementsRequestCpuManufacturersItem']]:
        """
        The CPU manufacturers to include.

        - For instance types with Intel CPUs, specify `intel` .
        - For instance types with AMD CPUs, specify `amd` .
        - For instance types with AWS CPUs, specify `amazon-web-services` .

        > Don't confuse the CPU manufacturer with the CPU architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template. 

        Default: Any manufacturer
        """
        return pulumi.get(self, "cpu_manufacturers")

    @property
    @pulumi.getter(name="excludedInstanceTypes")
    def excluded_instance_types(self) -> Optional[Sequence[str]]:
        """
        The instance types to exclude.

        You can use strings with one or more wild cards, represented by an asterisk ( `*` ), to exclude an instance family, type, size, or generation. The following are examples: `m5.8xlarge` , `c5*.*` , `m5a.*` , `r*` , `*3*` .

        For example, if you specify `c5*` ,Amazon EC2 will exclude the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*` , Amazon EC2 will exclude all the M5a instance types, but not the M5n instance types.

        > If you specify `ExcludedInstanceTypes` , you can't specify `AllowedInstanceTypes` . 

        Default: No excluded instance types
        """
        return pulumi.get(self, "excluded_instance_types")

    @property
    @pulumi.getter(name="instanceGenerations")
    def instance_generations(self) -> Optional[Sequence['SpotFleetInstanceRequirementsRequestInstanceGenerationsItem']]:
        """
        Indicates whether current or previous generation instance types are included. The current generation instance types are recommended for use. Current generation instance types are typically the latest two to three generations in each instance family. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .

        For current generation instance types, specify `current` .

        For previous generation instance types, specify `previous` .

        Default: Current and previous generation instance types
        """
        return pulumi.get(self, "instance_generations")

    @property
    @pulumi.getter(name="localStorage")
    def local_storage(self) -> Optional['SpotFleetInstanceRequirementsRequestLocalStorage']:
        """
        Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, [Amazon EC2 instance store](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html) in the *Amazon EC2 User Guide* .

        - To include instance types with instance store volumes, specify `included` .
        - To require only instance types with instance store volumes, specify `required` .
        - To exclude instance types with instance store volumes, specify `excluded` .

        Default: `included`
        """
        return pulumi.get(self, "local_storage")

    @property
    @pulumi.getter(name="localStorageTypes")
    def local_storage_types(self) -> Optional[Sequence['SpotFleetInstanceRequirementsRequestLocalStorageTypesItem']]:
        """
        The type of local storage that is required.

        - For instance types with hard disk drive (HDD) storage, specify `hdd` .
        - For instance types with solid state drive (SSD) storage, specify `ssd` .

        Default: `hdd` and `ssd`
        """
        return pulumi.get(self, "local_storage_types")

    @property
    @pulumi.getter(name="maxSpotPriceAsPercentageOfOptimalOnDemandPrice")
    def max_spot_price_as_percentage_of_optimal_on_demand_price(self) -> Optional[int]:
        """
        [Price protection] The price protection threshold for Spot Instances, as a percentage of an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.

        The parameter accepts an integer, which Amazon EC2 interprets as a percentage.

        If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is based on the per vCPU or per memory price instead of the per instance price.

        > Only one of `SpotMaxPricePercentageOverLowestPrice` or `MaxSpotPriceAsPercentageOfOptimalOnDemandPrice` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as `999999` .
        """
        return pulumi.get(self, "max_spot_price_as_percentage_of_optimal_on_demand_price")

    @property
    @pulumi.getter(name="memoryGiBPerVCpu")
    def memory_gi_b_per_v_cpu(self) -> Optional['outputs.SpotFleetMemoryGiBPerVCpuRequest']:
        """
        The minimum and maximum amount of memory per vCPU, in GiB.

        Default: No minimum or maximum limits
        """
        return pulumi.get(self, "memory_gi_b_per_v_cpu")

    @property
    @pulumi.getter(name="memoryMiB")
    def memory_mi_b(self) -> Optional['outputs.SpotFleetMemoryMiBRequest']:
        """
        The minimum and maximum amount of memory, in MiB.
        """
        return pulumi.get(self, "memory_mi_b")

    @property
    @pulumi.getter(name="networkBandwidthGbps")
    def network_bandwidth_gbps(self) -> Optional['outputs.SpotFleetNetworkBandwidthGbpsRequest']:
        """
        The minimum and maximum amount of baseline network bandwidth, in gigabits per second (Gbps). For more information, see [Amazon EC2 instance network bandwidth](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-network-bandwidth.html) in the *Amazon EC2 User Guide* .

        Default: No minimum or maximum limits
        """
        return pulumi.get(self, "network_bandwidth_gbps")

    @property
    @pulumi.getter(name="networkInterfaceCount")
    def network_interface_count(self) -> Optional['outputs.SpotFleetNetworkInterfaceCountRequest']:
        """
        The minimum and maximum number of network interfaces.

        Default: No minimum or maximum limits
        """
        return pulumi.get(self, "network_interface_count")

    @property
    @pulumi.getter(name="onDemandMaxPricePercentageOverLowestPrice")
    def on_demand_max_price_percentage_over_lowest_price(self) -> Optional[int]:
        """
        [Price protection] The price protection threshold for On-Demand Instances, as a percentage higher than an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.

        The parameter accepts an integer, which Amazon EC2 interprets as a percentage.

        To indicate no price protection threshold, specify a high value, such as `999999` .

        This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) .

        > If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price. 

        Default: `20`
        """
        return pulumi.get(self, "on_demand_max_price_percentage_over_lowest_price")

    @property
    @pulumi.getter(name="requireHibernateSupport")
    def require_hibernate_support(self) -> Optional[bool]:
        """
        Indicates whether instance types must support hibernation for On-Demand Instances.

        This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) .

        Default: `false`
        """
        return pulumi.get(self, "require_hibernate_support")

    @property
    @pulumi.getter(name="spotMaxPricePercentageOverLowestPrice")
    def spot_max_price_percentage_over_lowest_price(self) -> Optional[int]:
        """
        [Price protection] The price protection threshold for Spot Instances, as a percentage higher than an identified Spot price. The identified Spot price is the Spot price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified Spot price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose Spot price exceeds your specified threshold.

        The parameter accepts an integer, which Amazon EC2 interprets as a percentage.

        If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.

        This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) .

        > Only one of `SpotMaxPricePercentageOverLowestPrice` or `MaxSpotPriceAsPercentageOfOptimalOnDemandPrice` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as `999999` . 

        Default: `100`
        """
        return pulumi.get(self, "spot_max_price_percentage_over_lowest_price")

    @property
    @pulumi.getter(name="totalLocalStorageGb")
    def total_local_storage_gb(self) -> Optional['outputs.SpotFleetTotalLocalStorageGbRequest']:
        """
        The minimum and maximum amount of total local storage, in GB.

        Default: No minimum or maximum limits
        """
        return pulumi.get(self, "total_local_storage_gb")

    @property
    @pulumi.getter(name="vCpuCount")
    def v_cpu_count(self) -> Optional['outputs.SpotFleetVCpuCountRangeRequest']:
        """
        The minimum and maximum number of vCPUs.
        """
        return pulumi.get(self, "v_cpu_count")


@pulumi.output_type
class SpotFleetLaunchSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageId":
            suggest = "image_id"
        elif key == "blockDeviceMappings":
            suggest = "block_device_mappings"
        elif key == "ebsOptimized":
            suggest = "ebs_optimized"
        elif key == "iamInstanceProfile":
            suggest = "iam_instance_profile"
        elif key == "instanceRequirements":
            suggest = "instance_requirements"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "kernelId":
            suggest = "kernel_id"
        elif key == "keyName":
            suggest = "key_name"
        elif key == "networkInterfaces":
            suggest = "network_interfaces"
        elif key == "ramdiskId":
            suggest = "ramdisk_id"
        elif key == "securityGroups":
            suggest = "security_groups"
        elif key == "spotPrice":
            suggest = "spot_price"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "tagSpecifications":
            suggest = "tag_specifications"
        elif key == "userData":
            suggest = "user_data"
        elif key == "weightedCapacity":
            suggest = "weighted_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetLaunchSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetLaunchSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetLaunchSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_id: str,
                 block_device_mappings: Optional[Sequence['outputs.SpotFleetBlockDeviceMapping']] = None,
                 ebs_optimized: Optional[bool] = None,
                 iam_instance_profile: Optional['outputs.SpotFleetIamInstanceProfileSpecification'] = None,
                 instance_requirements: Optional['outputs.SpotFleetInstanceRequirementsRequest'] = None,
                 instance_type: Optional[str] = None,
                 kernel_id: Optional[str] = None,
                 key_name: Optional[str] = None,
                 monitoring: Optional['outputs.SpotFleetMonitoring'] = None,
                 network_interfaces: Optional[Sequence['outputs.SpotFleetInstanceNetworkInterfaceSpecification']] = None,
                 placement: Optional['outputs.SpotFleetSpotPlacement'] = None,
                 ramdisk_id: Optional[str] = None,
                 security_groups: Optional[Sequence['outputs.SpotFleetGroupIdentifier']] = None,
                 spot_price: Optional[str] = None,
                 subnet_id: Optional[str] = None,
                 tag_specifications: Optional[Sequence['outputs.SpotFleetTagSpecification']] = None,
                 user_data: Optional[str] = None,
                 weighted_capacity: Optional[float] = None):
        """
        :param str image_id: The ID of the AMI.
        :param Sequence['SpotFleetBlockDeviceMapping'] block_device_mappings: One or more block devices that are mapped to the Spot Instances. You can't specify both a snapshot ID and an encryption value. This is because only blank volumes can be encrypted on creation. If a snapshot is the basis for a volume, it is not blank and its encryption status is used for the volume encryption status.
        :param bool ebs_optimized: Indicates whether the instances are optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.
               
               Default: `false`
        :param 'SpotFleetIamInstanceProfileSpecification' iam_instance_profile: The IAM instance profile.
        :param 'SpotFleetInstanceRequirementsRequest' instance_requirements: The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with those attributes.
               
               > If you specify `InstanceRequirements` , you can't specify `InstanceType` .
        :param str instance_type: The instance type.
        :param str kernel_id: The ID of the kernel.
        :param str key_name: The name of the key pair.
        :param 'SpotFleetMonitoring' monitoring: Enable or disable monitoring for the instances.
        :param Sequence['SpotFleetInstanceNetworkInterfaceSpecification'] network_interfaces: The network interfaces.
        :param 'SpotFleetSpotPlacement' placement: The placement information.
        :param str ramdisk_id: The ID of the RAM disk. Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, refer to the AWS Resource Center and search for the kernel ID.
        :param Sequence['SpotFleetGroupIdentifier'] security_groups: The security groups.
               
               If you specify a network interface, you must specify any security groups as part of the network interface instead of using this parameter.
        :param str spot_price: The maximum price per unit hour that you are willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.
               
               > If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.
        :param str subnet_id: The IDs of the subnets in which to launch the instances. To specify multiple subnets, separate them using commas; for example, "subnet-1234abcdeexample1, subnet-0987cdef6example2".
               
               If you specify a network interface, you must specify any subnets as part of the network interface instead of using this parameter.
        :param Sequence['SpotFleetTagSpecification'] tag_specifications: The tags to apply during creation.
        :param str user_data: The base64-encoded user data that instances use when starting up. User data is limited to 16 KB.
        :param float weighted_capacity: The number of units provided by the specified instance type. These are the same units that you chose to set the target capacity in terms of instances, or a performance characteristic such as vCPUs, memory, or I/O.
               
               If the target capacity divided by this value is not a whole number, Amazon EC2 rounds the number of instances to the next whole number. If this value is not specified, the default is 1.
               
               > When specifying weights, the price used in the `lowestPrice` and `priceCapacityOptimized` allocation strategies is per *unit* hour (where the instance price is divided by the specified weight). However, if all the specified weights are above the requested `TargetCapacity` , resulting in only 1 instance being launched, the price used is per *instance* hour.
        """
        pulumi.set(__self__, "image_id", image_id)
        if block_device_mappings is not None:
            pulumi.set(__self__, "block_device_mappings", block_device_mappings)
        if ebs_optimized is not None:
            pulumi.set(__self__, "ebs_optimized", ebs_optimized)
        if iam_instance_profile is not None:
            pulumi.set(__self__, "iam_instance_profile", iam_instance_profile)
        if instance_requirements is not None:
            pulumi.set(__self__, "instance_requirements", instance_requirements)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if kernel_id is not None:
            pulumi.set(__self__, "kernel_id", kernel_id)
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if monitoring is not None:
            pulumi.set(__self__, "monitoring", monitoring)
        if network_interfaces is not None:
            pulumi.set(__self__, "network_interfaces", network_interfaces)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if ramdisk_id is not None:
            pulumi.set(__self__, "ramdisk_id", ramdisk_id)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if spot_price is not None:
            pulumi.set(__self__, "spot_price", spot_price)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if tag_specifications is not None:
            pulumi.set(__self__, "tag_specifications", tag_specifications)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)
        if weighted_capacity is not None:
            pulumi.set(__self__, "weighted_capacity", weighted_capacity)

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> str:
        """
        The ID of the AMI.
        """
        return pulumi.get(self, "image_id")

    @property
    @pulumi.getter(name="blockDeviceMappings")
    def block_device_mappings(self) -> Optional[Sequence['outputs.SpotFleetBlockDeviceMapping']]:
        """
        One or more block devices that are mapped to the Spot Instances. You can't specify both a snapshot ID and an encryption value. This is because only blank volumes can be encrypted on creation. If a snapshot is the basis for a volume, it is not blank and its encryption status is used for the volume encryption status.
        """
        return pulumi.get(self, "block_device_mappings")

    @property
    @pulumi.getter(name="ebsOptimized")
    def ebs_optimized(self) -> Optional[bool]:
        """
        Indicates whether the instances are optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.

        Default: `false`
        """
        return pulumi.get(self, "ebs_optimized")

    @property
    @pulumi.getter(name="iamInstanceProfile")
    def iam_instance_profile(self) -> Optional['outputs.SpotFleetIamInstanceProfileSpecification']:
        """
        The IAM instance profile.
        """
        return pulumi.get(self, "iam_instance_profile")

    @property
    @pulumi.getter(name="instanceRequirements")
    def instance_requirements(self) -> Optional['outputs.SpotFleetInstanceRequirementsRequest']:
        """
        The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with those attributes.

        > If you specify `InstanceRequirements` , you can't specify `InstanceType` .
        """
        return pulumi.get(self, "instance_requirements")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[str]:
        """
        The instance type.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="kernelId")
    def kernel_id(self) -> Optional[str]:
        """
        The ID of the kernel.
        """
        return pulumi.get(self, "kernel_id")

    @property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[str]:
        """
        The name of the key pair.
        """
        return pulumi.get(self, "key_name")

    @property
    @pulumi.getter
    def monitoring(self) -> Optional['outputs.SpotFleetMonitoring']:
        """
        Enable or disable monitoring for the instances.
        """
        return pulumi.get(self, "monitoring")

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Optional[Sequence['outputs.SpotFleetInstanceNetworkInterfaceSpecification']]:
        """
        The network interfaces.
        """
        return pulumi.get(self, "network_interfaces")

    @property
    @pulumi.getter
    def placement(self) -> Optional['outputs.SpotFleetSpotPlacement']:
        """
        The placement information.
        """
        return pulumi.get(self, "placement")

    @property
    @pulumi.getter(name="ramdiskId")
    def ramdisk_id(self) -> Optional[str]:
        """
        The ID of the RAM disk. Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, refer to the AWS Resource Center and search for the kernel ID.
        """
        return pulumi.get(self, "ramdisk_id")

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence['outputs.SpotFleetGroupIdentifier']]:
        """
        The security groups.

        If you specify a network interface, you must specify any security groups as part of the network interface instead of using this parameter.
        """
        return pulumi.get(self, "security_groups")

    @property
    @pulumi.getter(name="spotPrice")
    def spot_price(self) -> Optional[str]:
        """
        The maximum price per unit hour that you are willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.

        > If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.
        """
        return pulumi.get(self, "spot_price")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The IDs of the subnets in which to launch the instances. To specify multiple subnets, separate them using commas; for example, "subnet-1234abcdeexample1, subnet-0987cdef6example2".

        If you specify a network interface, you must specify any subnets as part of the network interface instead of using this parameter.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="tagSpecifications")
    def tag_specifications(self) -> Optional[Sequence['outputs.SpotFleetTagSpecification']]:
        """
        The tags to apply during creation.
        """
        return pulumi.get(self, "tag_specifications")

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[str]:
        """
        The base64-encoded user data that instances use when starting up. User data is limited to 16 KB.
        """
        return pulumi.get(self, "user_data")

    @property
    @pulumi.getter(name="weightedCapacity")
    def weighted_capacity(self) -> Optional[float]:
        """
        The number of units provided by the specified instance type. These are the same units that you chose to set the target capacity in terms of instances, or a performance characteristic such as vCPUs, memory, or I/O.

        If the target capacity divided by this value is not a whole number, Amazon EC2 rounds the number of instances to the next whole number. If this value is not specified, the default is 1.

        > When specifying weights, the price used in the `lowestPrice` and `priceCapacityOptimized` allocation strategies is per *unit* hour (where the instance price is divided by the specified weight). However, if all the specified weights are above the requested `TargetCapacity` , resulting in only 1 instance being launched, the price used is per *instance* hour.
        """
        return pulumi.get(self, "weighted_capacity")


@pulumi.output_type
class SpotFleetLaunchTemplateConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTemplateSpecification":
            suggest = "launch_template_specification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetLaunchTemplateConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetLaunchTemplateConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetLaunchTemplateConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 launch_template_specification: Optional['outputs.SpotFleetFleetLaunchTemplateSpecification'] = None,
                 overrides: Optional[Sequence['outputs.SpotFleetLaunchTemplateOverrides']] = None):
        """
        :param 'SpotFleetFleetLaunchTemplateSpecification' launch_template_specification: The launch template to use. Make sure that the launch template does not contain the `NetworkInterfaceId` parameter because you can't specify a network interface ID in a Spot Fleet.
        :param Sequence['SpotFleetLaunchTemplateOverrides'] overrides: Any parameters that you specify override the same parameters in the launch template.
        """
        if launch_template_specification is not None:
            pulumi.set(__self__, "launch_template_specification", launch_template_specification)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)

    @property
    @pulumi.getter(name="launchTemplateSpecification")
    def launch_template_specification(self) -> Optional['outputs.SpotFleetFleetLaunchTemplateSpecification']:
        """
        The launch template to use. Make sure that the launch template does not contain the `NetworkInterfaceId` parameter because you can't specify a network interface ID in a Spot Fleet.
        """
        return pulumi.get(self, "launch_template_specification")

    @property
    @pulumi.getter
    def overrides(self) -> Optional[Sequence['outputs.SpotFleetLaunchTemplateOverrides']]:
        """
        Any parameters that you specify override the same parameters in the launch template.
        """
        return pulumi.get(self, "overrides")


@pulumi.output_type
class SpotFleetLaunchTemplateOverrides(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "instanceRequirements":
            suggest = "instance_requirements"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "spotPrice":
            suggest = "spot_price"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "weightedCapacity":
            suggest = "weighted_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetLaunchTemplateOverrides. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetLaunchTemplateOverrides.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetLaunchTemplateOverrides.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone: Optional[str] = None,
                 instance_requirements: Optional['outputs.SpotFleetInstanceRequirementsRequest'] = None,
                 instance_type: Optional[str] = None,
                 priority: Optional[float] = None,
                 spot_price: Optional[str] = None,
                 subnet_id: Optional[str] = None,
                 weighted_capacity: Optional[float] = None):
        """
        :param str availability_zone: The Availability Zone in which to launch the instances.
        :param 'SpotFleetInstanceRequirementsRequest' instance_requirements: The instance requirements. When you specify instance requirements, Amazon EC2 will identify instance types with the provided requirements, and then use your On-Demand and Spot allocation strategies to launch instances from these instance types, in the same way as when you specify a list of instance types.
               
               > If you specify `InstanceRequirements` , you can't specify `InstanceType` .
        :param str instance_type: The instance type.
        :param float priority: The priority for the launch template override. The highest priority is launched first.
               
               If `OnDemandAllocationStrategy` is set to `prioritized` , Spot Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity.
               
               If the Spot `AllocationStrategy` is set to `capacityOptimizedPrioritized` , Spot Fleet uses priority on a best-effort basis to determine which launch template override to use in fulfilling Spot capacity, but optimizes for capacity first.
               
               Valid values are whole numbers starting at `0` . The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority. You can set the same priority for different launch template overrides.
        :param str spot_price: The maximum price per unit hour that you are willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.
               
               > If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.
        :param str subnet_id: The ID of the subnet in which to launch the instances.
        :param float weighted_capacity: The number of units provided by the specified instance type. These are the same units that you chose to set the target capacity in terms of instances, or a performance characteristic such as vCPUs, memory, or I/O.
               
               If the target capacity divided by this value is not a whole number, Amazon EC2 rounds the number of instances to the next whole number. If this value is not specified, the default is 1.
               
               > When specifying weights, the price used in the `lowestPrice` and `priceCapacityOptimized` allocation strategies is per *unit* hour (where the instance price is divided by the specified weight). However, if all the specified weights are above the requested `TargetCapacity` , resulting in only 1 instance being launched, the price used is per *instance* hour.
        """
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if instance_requirements is not None:
            pulumi.set(__self__, "instance_requirements", instance_requirements)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if spot_price is not None:
            pulumi.set(__self__, "spot_price", spot_price)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if weighted_capacity is not None:
            pulumi.set(__self__, "weighted_capacity", weighted_capacity)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[str]:
        """
        The Availability Zone in which to launch the instances.
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="instanceRequirements")
    def instance_requirements(self) -> Optional['outputs.SpotFleetInstanceRequirementsRequest']:
        """
        The instance requirements. When you specify instance requirements, Amazon EC2 will identify instance types with the provided requirements, and then use your On-Demand and Spot allocation strategies to launch instances from these instance types, in the same way as when you specify a list of instance types.

        > If you specify `InstanceRequirements` , you can't specify `InstanceType` .
        """
        return pulumi.get(self, "instance_requirements")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[str]:
        """
        The instance type.
        """
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter
    def priority(self) -> Optional[float]:
        """
        The priority for the launch template override. The highest priority is launched first.

        If `OnDemandAllocationStrategy` is set to `prioritized` , Spot Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity.

        If the Spot `AllocationStrategy` is set to `capacityOptimizedPrioritized` , Spot Fleet uses priority on a best-effort basis to determine which launch template override to use in fulfilling Spot capacity, but optimizes for capacity first.

        Valid values are whole numbers starting at `0` . The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority. You can set the same priority for different launch template overrides.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="spotPrice")
    def spot_price(self) -> Optional[str]:
        """
        The maximum price per unit hour that you are willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.

        > If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.
        """
        return pulumi.get(self, "spot_price")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The ID of the subnet in which to launch the instances.
        """
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="weightedCapacity")
    def weighted_capacity(self) -> Optional[float]:
        """
        The number of units provided by the specified instance type. These are the same units that you chose to set the target capacity in terms of instances, or a performance characteristic such as vCPUs, memory, or I/O.

        If the target capacity divided by this value is not a whole number, Amazon EC2 rounds the number of instances to the next whole number. If this value is not specified, the default is 1.

        > When specifying weights, the price used in the `lowestPrice` and `priceCapacityOptimized` allocation strategies is per *unit* hour (where the instance price is divided by the specified weight). However, if all the specified weights are above the requested `TargetCapacity` , resulting in only 1 instance being launched, the price used is per *instance* hour.
        """
        return pulumi.get(self, "weighted_capacity")


@pulumi.output_type
class SpotFleetLoadBalancersConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "classicLoadBalancersConfig":
            suggest = "classic_load_balancers_config"
        elif key == "targetGroupsConfig":
            suggest = "target_groups_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetLoadBalancersConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetLoadBalancersConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetLoadBalancersConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 classic_load_balancers_config: Optional['outputs.SpotFleetClassicLoadBalancersConfig'] = None,
                 target_groups_config: Optional['outputs.SpotFleetTargetGroupsConfig'] = None):
        """
        :param 'SpotFleetClassicLoadBalancersConfig' classic_load_balancers_config: The Classic Load Balancers.
        :param 'SpotFleetTargetGroupsConfig' target_groups_config: The target groups.
        """
        if classic_load_balancers_config is not None:
            pulumi.set(__self__, "classic_load_balancers_config", classic_load_balancers_config)
        if target_groups_config is not None:
            pulumi.set(__self__, "target_groups_config", target_groups_config)

    @property
    @pulumi.getter(name="classicLoadBalancersConfig")
    def classic_load_balancers_config(self) -> Optional['outputs.SpotFleetClassicLoadBalancersConfig']:
        """
        The Classic Load Balancers.
        """
        return pulumi.get(self, "classic_load_balancers_config")

    @property
    @pulumi.getter(name="targetGroupsConfig")
    def target_groups_config(self) -> Optional['outputs.SpotFleetTargetGroupsConfig']:
        """
        The target groups.
        """
        return pulumi.get(self, "target_groups_config")


@pulumi.output_type
class SpotFleetMemoryGiBPerVCpuRequest(dict):
    def __init__(__self__, *,
                 max: Optional[float] = None,
                 min: Optional[float] = None):
        """
        :param float max: The maximum amount of memory per vCPU, in GiB. To specify no maximum limit, omit this parameter.
        :param float min: The minimum amount of memory per vCPU, in GiB. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        """
        The maximum amount of memory per vCPU, in GiB. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        """
        The minimum amount of memory per vCPU, in GiB. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetMemoryMiBRequest(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        :param int max: The maximum amount of memory, in MiB. To specify no maximum limit, omit this parameter.
        :param int min: The minimum amount of memory, in MiB. To specify no minimum limit, specify `0` .
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        The maximum amount of memory, in MiB. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        The minimum amount of memory, in MiB. To specify no minimum limit, specify `0` .
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetMonitoring(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: Enables monitoring for the instance.
               
               Default: `false`
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Enables monitoring for the instance.

        Default: `false`
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class SpotFleetNetworkBandwidthGbpsRequest(dict):
    def __init__(__self__, *,
                 max: Optional[float] = None,
                 min: Optional[float] = None):
        """
        :param float max: The maximum amount of network bandwidth, in Gbps. To specify no maximum limit, omit this parameter.
        :param float min: The minimum amount of network bandwidth, in Gbps. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        """
        The maximum amount of network bandwidth, in Gbps. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        """
        The minimum amount of network bandwidth, in Gbps. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetNetworkInterfaceCountRequest(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        :param int max: The maximum number of network interfaces. To specify no maximum limit, omit this parameter.
        :param int min: The minimum number of network interfaces. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        The maximum number of network interfaces. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        The minimum number of network interfaces. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetPrivateIpAddressSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIpAddress":
            suggest = "private_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetPrivateIpAddressSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetPrivateIpAddressSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetPrivateIpAddressSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_ip_address: str,
                 primary: Optional[bool] = None):
        """
        :param str private_ip_address: The private IPv4 address.
        :param bool primary: Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.
        """
        pulumi.set(__self__, "private_ip_address", private_ip_address)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> str:
        """
        The private IPv4 address.
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter
    def primary(self) -> Optional[bool]:
        """
        Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.
        """
        return pulumi.get(self, "primary")


@pulumi.output_type
class SpotFleetRequestConfigData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iamFleetRole":
            suggest = "iam_fleet_role"
        elif key == "targetCapacity":
            suggest = "target_capacity"
        elif key == "allocationStrategy":
            suggest = "allocation_strategy"
        elif key == "excessCapacityTerminationPolicy":
            suggest = "excess_capacity_termination_policy"
        elif key == "instanceInterruptionBehavior":
            suggest = "instance_interruption_behavior"
        elif key == "instancePoolsToUseCount":
            suggest = "instance_pools_to_use_count"
        elif key == "launchSpecifications":
            suggest = "launch_specifications"
        elif key == "launchTemplateConfigs":
            suggest = "launch_template_configs"
        elif key == "loadBalancersConfig":
            suggest = "load_balancers_config"
        elif key == "onDemandAllocationStrategy":
            suggest = "on_demand_allocation_strategy"
        elif key == "onDemandMaxTotalPrice":
            suggest = "on_demand_max_total_price"
        elif key == "onDemandTargetCapacity":
            suggest = "on_demand_target_capacity"
        elif key == "replaceUnhealthyInstances":
            suggest = "replace_unhealthy_instances"
        elif key == "spotMaintenanceStrategies":
            suggest = "spot_maintenance_strategies"
        elif key == "spotMaxTotalPrice":
            suggest = "spot_max_total_price"
        elif key == "spotPrice":
            suggest = "spot_price"
        elif key == "tagSpecifications":
            suggest = "tag_specifications"
        elif key == "targetCapacityUnitType":
            suggest = "target_capacity_unit_type"
        elif key == "terminateInstancesWithExpiration":
            suggest = "terminate_instances_with_expiration"
        elif key == "validFrom":
            suggest = "valid_from"
        elif key == "validUntil":
            suggest = "valid_until"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetRequestConfigData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetRequestConfigData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetRequestConfigData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iam_fleet_role: str,
                 target_capacity: int,
                 allocation_strategy: Optional['SpotFleetRequestConfigDataAllocationStrategy'] = None,
                 context: Optional[str] = None,
                 excess_capacity_termination_policy: Optional['SpotFleetRequestConfigDataExcessCapacityTerminationPolicy'] = None,
                 instance_interruption_behavior: Optional['SpotFleetRequestConfigDataInstanceInterruptionBehavior'] = None,
                 instance_pools_to_use_count: Optional[int] = None,
                 launch_specifications: Optional[Sequence['outputs.SpotFleetLaunchSpecification']] = None,
                 launch_template_configs: Optional[Sequence['outputs.SpotFleetLaunchTemplateConfig']] = None,
                 load_balancers_config: Optional['outputs.SpotFleetLoadBalancersConfig'] = None,
                 on_demand_allocation_strategy: Optional[str] = None,
                 on_demand_max_total_price: Optional[str] = None,
                 on_demand_target_capacity: Optional[int] = None,
                 replace_unhealthy_instances: Optional[bool] = None,
                 spot_maintenance_strategies: Optional['outputs.SpotFleetSpotMaintenanceStrategies'] = None,
                 spot_max_total_price: Optional[str] = None,
                 spot_price: Optional[str] = None,
                 tag_specifications: Optional[Sequence['outputs.SpotFleetTagSpecification']] = None,
                 target_capacity_unit_type: Optional['SpotFleetRequestConfigDataTargetCapacityUnitType'] = None,
                 terminate_instances_with_expiration: Optional[bool] = None,
                 type: Optional['SpotFleetRequestConfigDataType'] = None,
                 valid_from: Optional[str] = None,
                 valid_until: Optional[str] = None):
        """
        :param str iam_fleet_role: The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role that grants the Spot Fleet the permission to request, launch, terminate, and tag instances on your behalf. For more information, see [Spot Fleet Prerequisites](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-requests.html#spot-fleet-prerequisites) in the *Amazon EC2 User Guide* . Spot Fleet can terminate Spot Instances on your behalf when you cancel its Spot Fleet request or when the Spot Fleet request expires, if you set `TerminateInstancesWithExpiration` .
        :param int target_capacity: The number of units to request for the Spot Fleet. You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is `maintain` , you can specify a target capacity of 0 and add capacity later.
        :param 'SpotFleetRequestConfigDataAllocationStrategy' allocation_strategy: The strategy that determines how to allocate the target Spot Instance capacity across the Spot Instance pools specified by the Spot Fleet launch configuration. For more information, see [Allocation strategies for Spot Instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-allocation-strategy.html) in the *Amazon EC2 User Guide* .
               
               - **priceCapacityOptimized (recommended)** - Spot Fleet identifies the pools with the highest capacity availability for the number of instances that are launching. This means that we will request Spot Instances from the pools that we believe have the lowest chance of interruption in the near term. Spot Fleet then requests Spot Instances from the lowest priced of these pools.
               - **capacityOptimized** - Spot Fleet identifies the pools with the highest capacity availability for the number of instances that are launching. This means that we will request Spot Instances from the pools that we believe have the lowest chance of interruption in the near term. To give certain instance types a higher chance of launching first, use `capacityOptimizedPrioritized` . Set a priority for each instance type by using the `Priority` parameter for `LaunchTemplateOverrides` . You can assign the same priority to different `LaunchTemplateOverrides` . EC2 implements the priorities on a best-effort basis, but optimizes for capacity first. `capacityOptimizedPrioritized` is supported only if your Spot Fleet uses a launch template. Note that if the `OnDemandAllocationStrategy` is set to `prioritized` , the same priority is applied when fulfilling On-Demand capacity.
               - **diversified** - Spot Fleet requests instances from all of the Spot Instance pools that you specify.
               - **lowestPrice (not recommended)** - > We don't recommend the `lowestPrice` allocation strategy because it has the highest risk of interruption for your Spot Instances. 
               
               Spot Fleet requests instances from the lowest priced Spot Instance pool that has available capacity. If the lowest priced pool doesn't have available capacity, the Spot Instances come from the next lowest priced pool that has available capacity. If a pool runs out of capacity before fulfilling your desired capacity, Spot Fleet will continue to fulfill your request by drawing from the next lowest priced pool. To ensure that your desired capacity is met, you might receive Spot Instances from several pools. Because this strategy only considers instance price and not capacity availability, it might lead to high interruption rates.
               
               Default: `lowestPrice`
        :param str context: Reserved.
        :param 'SpotFleetRequestConfigDataExcessCapacityTerminationPolicy' excess_capacity_termination_policy: Indicates whether running Spot Instances should be terminated if you decrease the target capacity of the Spot Fleet request below the current size of the Spot Fleet.
               
               Supported only for fleets of type `maintain` .
        :param 'SpotFleetRequestConfigDataInstanceInterruptionBehavior' instance_interruption_behavior: The behavior when a Spot Instance is interrupted. The default is `terminate` .
        :param int instance_pools_to_use_count: The number of Spot pools across which to allocate your target Spot capacity. Valid only when Spot *AllocationStrategy* is set to `lowest-price` . Spot Fleet selects the cheapest Spot pools and evenly allocates your target Spot capacity across the number of Spot pools that you specify.
               
               Note that Spot Fleet attempts to draw Spot Instances from the number of pools that you specify on a best effort basis. If a pool runs out of Spot capacity before fulfilling your target capacity, Spot Fleet will continue to fulfill your request by drawing from the next cheapest pool. To ensure that your target capacity is met, you might receive Spot Instances from more than the number of pools that you specified. Similarly, if most of the pools have no Spot capacity, you might receive your full target capacity from fewer than the number of pools that you specified.
        :param Sequence['SpotFleetLaunchSpecification'] launch_specifications: The launch specifications for the Spot Fleet request. If you specify `LaunchSpecifications` , you can't specify `LaunchTemplateConfigs` .
        :param Sequence['SpotFleetLaunchTemplateConfig'] launch_template_configs: The launch template and overrides. If you specify `LaunchTemplateConfigs` , you can't specify `LaunchSpecifications` .
        :param 'SpotFleetLoadBalancersConfig' load_balancers_config: One or more Classic Load Balancers and target groups to attach to the Spot Fleet request. Spot Fleet registers the running Spot Instances with the specified Classic Load Balancers and target groups.
               
               With Network Load Balancers, Spot Fleet cannot register instances that have the following instance types: C1, CC1, CC2, CG1, CG2, CR1, CS1, G1, G2, HI1, HS1, M1, M2, M3, and T1.
        :param str on_demand_allocation_strategy: The order of the launch template overrides to use in fulfilling On-Demand capacity. If you specify `lowestPrice` , Spot Fleet uses price to determine the order, launching the lowest price first. If you specify `prioritized` , Spot Fleet uses the priority that you assign to each Spot Fleet launch template override, launching the highest priority first. If you do not specify a value, Spot Fleet defaults to `lowestPrice` .
        :param str on_demand_max_total_price: The maximum amount per hour for On-Demand Instances that you're willing to pay. You can use the `onDemandMaxTotalPrice` parameter, the `spotMaxTotalPrice` parameter, or both parameters to ensure that your fleet cost does not exceed your budget. If you set a maximum price per hour for the On-Demand Instances and Spot Instances in your request, Spot Fleet will launch instances until it reaches the maximum amount you're willing to pay. When the maximum amount you're willing to pay is reached, the fleet stops launching instances even if it hasnt met the target capacity.
               
               > If your fleet includes T instances that are configured as `unlimited` , and if their average CPU usage exceeds the baseline utilization, you will incur a charge for surplus credits. The `onDemandMaxTotalPrice` does not account for surplus credits, and, if you use surplus credits, your final cost might be higher than what you specified for `onDemandMaxTotalPrice` . For more information, see [Surplus credits can incur charges](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-unlimited-mode-concepts.html#unlimited-mode-surplus-credits) in the *Amazon EC2 User Guide* .
        :param int on_demand_target_capacity: The number of On-Demand units to request. You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is `maintain` , you can specify a target capacity of 0 and add capacity later.
        :param bool replace_unhealthy_instances: Indicates whether Spot Fleet should replace unhealthy instances.
        :param 'SpotFleetSpotMaintenanceStrategies' spot_maintenance_strategies: The strategies for managing your Spot Instances that are at an elevated risk of being interrupted.
        :param str spot_max_total_price: The maximum amount per hour for Spot Instances that you're willing to pay. You can use the `spotMaxTotalPrice` parameter, the `onDemandMaxTotalPrice` parameter, or both parameters to ensure that your fleet cost does not exceed your budget. If you set a maximum price per hour for the On-Demand Instances and Spot Instances in your request, Spot Fleet will launch instances until it reaches the maximum amount you're willing to pay. When the maximum amount you're willing to pay is reached, the fleet stops launching instances even if it hasnt met the target capacity.
               
               > If your fleet includes T instances that are configured as `unlimited` , and if their average CPU usage exceeds the baseline utilization, you will incur a charge for surplus credits. The `spotMaxTotalPrice` does not account for surplus credits, and, if you use surplus credits, your final cost might be higher than what you specified for `spotMaxTotalPrice` . For more information, see [Surplus credits can incur charges](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-unlimited-mode-concepts.html#unlimited-mode-surplus-credits) in the *Amazon EC2 User Guide* .
        :param str spot_price: The maximum price per unit hour that you are willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.
               
               > If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.
        :param Sequence['SpotFleetTagSpecification'] tag_specifications: The key-value pair for tagging the Spot Fleet request on creation. The value for `ResourceType` must be `spot-fleet-request` , otherwise the Spot Fleet request fails. To tag instances at launch, specify the tags in the [launch template](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#create-launch-template) (valid only if you use `LaunchTemplateConfigs` ) or in the `[SpotFleetTagSpecification](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SpotFleetTagSpecification.html)` (valid only if you use `LaunchSpecifications` ). For information about tagging after launch, see [Tag your resources](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#tag-resources) .
        :param 'SpotFleetRequestConfigDataTargetCapacityUnitType' target_capacity_unit_type: The unit for the target capacity. You can specify this parameter only when using attribute-based instance type selection.
               
               Default: `units` (the number of instances)
        :param bool terminate_instances_with_expiration: Indicates whether running Spot Instances are terminated when the Spot Fleet request expires.
        :param 'SpotFleetRequestConfigDataType' type: The type of request. Indicates whether the Spot Fleet only requests the target capacity or also attempts to maintain it. When this value is `request` , the Spot Fleet only places the required requests. It does not attempt to replenish Spot Instances if capacity is diminished, nor does it submit requests in alternative Spot pools if capacity is not available. When this value is `maintain` , the Spot Fleet maintains the target capacity. The Spot Fleet places the required requests to meet capacity and automatically replenishes any interrupted instances. Default: `maintain` . `instant` is listed but is not used by Spot Fleet.
        :param str valid_from: The start date and time of the request, in UTC format ( *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z). By default, Amazon EC2 starts fulfilling the request immediately.
        :param str valid_until: The end date and time of the request, in UTC format ( *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z). After the end date and time, no new Spot Instance requests are placed or able to fulfill the request. If no value is specified, the Spot Fleet request remains until you cancel it.
        """
        pulumi.set(__self__, "iam_fleet_role", iam_fleet_role)
        pulumi.set(__self__, "target_capacity", target_capacity)
        if allocation_strategy is not None:
            pulumi.set(__self__, "allocation_strategy", allocation_strategy)
        if context is not None:
            pulumi.set(__self__, "context", context)
        if excess_capacity_termination_policy is not None:
            pulumi.set(__self__, "excess_capacity_termination_policy", excess_capacity_termination_policy)
        if instance_interruption_behavior is not None:
            pulumi.set(__self__, "instance_interruption_behavior", instance_interruption_behavior)
        if instance_pools_to_use_count is not None:
            pulumi.set(__self__, "instance_pools_to_use_count", instance_pools_to_use_count)
        if launch_specifications is not None:
            pulumi.set(__self__, "launch_specifications", launch_specifications)
        if launch_template_configs is not None:
            pulumi.set(__self__, "launch_template_configs", launch_template_configs)
        if load_balancers_config is not None:
            pulumi.set(__self__, "load_balancers_config", load_balancers_config)
        if on_demand_allocation_strategy is not None:
            pulumi.set(__self__, "on_demand_allocation_strategy", on_demand_allocation_strategy)
        if on_demand_max_total_price is not None:
            pulumi.set(__self__, "on_demand_max_total_price", on_demand_max_total_price)
        if on_demand_target_capacity is not None:
            pulumi.set(__self__, "on_demand_target_capacity", on_demand_target_capacity)
        if replace_unhealthy_instances is not None:
            pulumi.set(__self__, "replace_unhealthy_instances", replace_unhealthy_instances)
        if spot_maintenance_strategies is not None:
            pulumi.set(__self__, "spot_maintenance_strategies", spot_maintenance_strategies)
        if spot_max_total_price is not None:
            pulumi.set(__self__, "spot_max_total_price", spot_max_total_price)
        if spot_price is not None:
            pulumi.set(__self__, "spot_price", spot_price)
        if tag_specifications is not None:
            pulumi.set(__self__, "tag_specifications", tag_specifications)
        if target_capacity_unit_type is not None:
            pulumi.set(__self__, "target_capacity_unit_type", target_capacity_unit_type)
        if terminate_instances_with_expiration is not None:
            pulumi.set(__self__, "terminate_instances_with_expiration", terminate_instances_with_expiration)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if valid_from is not None:
            pulumi.set(__self__, "valid_from", valid_from)
        if valid_until is not None:
            pulumi.set(__self__, "valid_until", valid_until)

    @property
    @pulumi.getter(name="iamFleetRole")
    def iam_fleet_role(self) -> str:
        """
        The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role that grants the Spot Fleet the permission to request, launch, terminate, and tag instances on your behalf. For more information, see [Spot Fleet Prerequisites](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-requests.html#spot-fleet-prerequisites) in the *Amazon EC2 User Guide* . Spot Fleet can terminate Spot Instances on your behalf when you cancel its Spot Fleet request or when the Spot Fleet request expires, if you set `TerminateInstancesWithExpiration` .
        """
        return pulumi.get(self, "iam_fleet_role")

    @property
    @pulumi.getter(name="targetCapacity")
    def target_capacity(self) -> int:
        """
        The number of units to request for the Spot Fleet. You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is `maintain` , you can specify a target capacity of 0 and add capacity later.
        """
        return pulumi.get(self, "target_capacity")

    @property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> Optional['SpotFleetRequestConfigDataAllocationStrategy']:
        """
        The strategy that determines how to allocate the target Spot Instance capacity across the Spot Instance pools specified by the Spot Fleet launch configuration. For more information, see [Allocation strategies for Spot Instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-allocation-strategy.html) in the *Amazon EC2 User Guide* .

        - **priceCapacityOptimized (recommended)** - Spot Fleet identifies the pools with the highest capacity availability for the number of instances that are launching. This means that we will request Spot Instances from the pools that we believe have the lowest chance of interruption in the near term. Spot Fleet then requests Spot Instances from the lowest priced of these pools.
        - **capacityOptimized** - Spot Fleet identifies the pools with the highest capacity availability for the number of instances that are launching. This means that we will request Spot Instances from the pools that we believe have the lowest chance of interruption in the near term. To give certain instance types a higher chance of launching first, use `capacityOptimizedPrioritized` . Set a priority for each instance type by using the `Priority` parameter for `LaunchTemplateOverrides` . You can assign the same priority to different `LaunchTemplateOverrides` . EC2 implements the priorities on a best-effort basis, but optimizes for capacity first. `capacityOptimizedPrioritized` is supported only if your Spot Fleet uses a launch template. Note that if the `OnDemandAllocationStrategy` is set to `prioritized` , the same priority is applied when fulfilling On-Demand capacity.
        - **diversified** - Spot Fleet requests instances from all of the Spot Instance pools that you specify.
        - **lowestPrice (not recommended)** - > We don't recommend the `lowestPrice` allocation strategy because it has the highest risk of interruption for your Spot Instances. 

        Spot Fleet requests instances from the lowest priced Spot Instance pool that has available capacity. If the lowest priced pool doesn't have available capacity, the Spot Instances come from the next lowest priced pool that has available capacity. If a pool runs out of capacity before fulfilling your desired capacity, Spot Fleet will continue to fulfill your request by drawing from the next lowest priced pool. To ensure that your desired capacity is met, you might receive Spot Instances from several pools. Because this strategy only considers instance price and not capacity availability, it might lead to high interruption rates.

        Default: `lowestPrice`
        """
        return pulumi.get(self, "allocation_strategy")

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        """
        Reserved.
        """
        return pulumi.get(self, "context")

    @property
    @pulumi.getter(name="excessCapacityTerminationPolicy")
    def excess_capacity_termination_policy(self) -> Optional['SpotFleetRequestConfigDataExcessCapacityTerminationPolicy']:
        """
        Indicates whether running Spot Instances should be terminated if you decrease the target capacity of the Spot Fleet request below the current size of the Spot Fleet.

        Supported only for fleets of type `maintain` .
        """
        return pulumi.get(self, "excess_capacity_termination_policy")

    @property
    @pulumi.getter(name="instanceInterruptionBehavior")
    def instance_interruption_behavior(self) -> Optional['SpotFleetRequestConfigDataInstanceInterruptionBehavior']:
        """
        The behavior when a Spot Instance is interrupted. The default is `terminate` .
        """
        return pulumi.get(self, "instance_interruption_behavior")

    @property
    @pulumi.getter(name="instancePoolsToUseCount")
    def instance_pools_to_use_count(self) -> Optional[int]:
        """
        The number of Spot pools across which to allocate your target Spot capacity. Valid only when Spot *AllocationStrategy* is set to `lowest-price` . Spot Fleet selects the cheapest Spot pools and evenly allocates your target Spot capacity across the number of Spot pools that you specify.

        Note that Spot Fleet attempts to draw Spot Instances from the number of pools that you specify on a best effort basis. If a pool runs out of Spot capacity before fulfilling your target capacity, Spot Fleet will continue to fulfill your request by drawing from the next cheapest pool. To ensure that your target capacity is met, you might receive Spot Instances from more than the number of pools that you specified. Similarly, if most of the pools have no Spot capacity, you might receive your full target capacity from fewer than the number of pools that you specified.
        """
        return pulumi.get(self, "instance_pools_to_use_count")

    @property
    @pulumi.getter(name="launchSpecifications")
    def launch_specifications(self) -> Optional[Sequence['outputs.SpotFleetLaunchSpecification']]:
        """
        The launch specifications for the Spot Fleet request. If you specify `LaunchSpecifications` , you can't specify `LaunchTemplateConfigs` .
        """
        return pulumi.get(self, "launch_specifications")

    @property
    @pulumi.getter(name="launchTemplateConfigs")
    def launch_template_configs(self) -> Optional[Sequence['outputs.SpotFleetLaunchTemplateConfig']]:
        """
        The launch template and overrides. If you specify `LaunchTemplateConfigs` , you can't specify `LaunchSpecifications` .
        """
        return pulumi.get(self, "launch_template_configs")

    @property
    @pulumi.getter(name="loadBalancersConfig")
    def load_balancers_config(self) -> Optional['outputs.SpotFleetLoadBalancersConfig']:
        """
        One or more Classic Load Balancers and target groups to attach to the Spot Fleet request. Spot Fleet registers the running Spot Instances with the specified Classic Load Balancers and target groups.

        With Network Load Balancers, Spot Fleet cannot register instances that have the following instance types: C1, CC1, CC2, CG1, CG2, CR1, CS1, G1, G2, HI1, HS1, M1, M2, M3, and T1.
        """
        return pulumi.get(self, "load_balancers_config")

    @property
    @pulumi.getter(name="onDemandAllocationStrategy")
    def on_demand_allocation_strategy(self) -> Optional[str]:
        """
        The order of the launch template overrides to use in fulfilling On-Demand capacity. If you specify `lowestPrice` , Spot Fleet uses price to determine the order, launching the lowest price first. If you specify `prioritized` , Spot Fleet uses the priority that you assign to each Spot Fleet launch template override, launching the highest priority first. If you do not specify a value, Spot Fleet defaults to `lowestPrice` .
        """
        return pulumi.get(self, "on_demand_allocation_strategy")

    @property
    @pulumi.getter(name="onDemandMaxTotalPrice")
    def on_demand_max_total_price(self) -> Optional[str]:
        """
        The maximum amount per hour for On-Demand Instances that you're willing to pay. You can use the `onDemandMaxTotalPrice` parameter, the `spotMaxTotalPrice` parameter, or both parameters to ensure that your fleet cost does not exceed your budget. If you set a maximum price per hour for the On-Demand Instances and Spot Instances in your request, Spot Fleet will launch instances until it reaches the maximum amount you're willing to pay. When the maximum amount you're willing to pay is reached, the fleet stops launching instances even if it hasnt met the target capacity.

        > If your fleet includes T instances that are configured as `unlimited` , and if their average CPU usage exceeds the baseline utilization, you will incur a charge for surplus credits. The `onDemandMaxTotalPrice` does not account for surplus credits, and, if you use surplus credits, your final cost might be higher than what you specified for `onDemandMaxTotalPrice` . For more information, see [Surplus credits can incur charges](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-unlimited-mode-concepts.html#unlimited-mode-surplus-credits) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "on_demand_max_total_price")

    @property
    @pulumi.getter(name="onDemandTargetCapacity")
    def on_demand_target_capacity(self) -> Optional[int]:
        """
        The number of On-Demand units to request. You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is `maintain` , you can specify a target capacity of 0 and add capacity later.
        """
        return pulumi.get(self, "on_demand_target_capacity")

    @property
    @pulumi.getter(name="replaceUnhealthyInstances")
    def replace_unhealthy_instances(self) -> Optional[bool]:
        """
        Indicates whether Spot Fleet should replace unhealthy instances.
        """
        return pulumi.get(self, "replace_unhealthy_instances")

    @property
    @pulumi.getter(name="spotMaintenanceStrategies")
    def spot_maintenance_strategies(self) -> Optional['outputs.SpotFleetSpotMaintenanceStrategies']:
        """
        The strategies for managing your Spot Instances that are at an elevated risk of being interrupted.
        """
        return pulumi.get(self, "spot_maintenance_strategies")

    @property
    @pulumi.getter(name="spotMaxTotalPrice")
    def spot_max_total_price(self) -> Optional[str]:
        """
        The maximum amount per hour for Spot Instances that you're willing to pay. You can use the `spotMaxTotalPrice` parameter, the `onDemandMaxTotalPrice` parameter, or both parameters to ensure that your fleet cost does not exceed your budget. If you set a maximum price per hour for the On-Demand Instances and Spot Instances in your request, Spot Fleet will launch instances until it reaches the maximum amount you're willing to pay. When the maximum amount you're willing to pay is reached, the fleet stops launching instances even if it hasnt met the target capacity.

        > If your fleet includes T instances that are configured as `unlimited` , and if their average CPU usage exceeds the baseline utilization, you will incur a charge for surplus credits. The `spotMaxTotalPrice` does not account for surplus credits, and, if you use surplus credits, your final cost might be higher than what you specified for `spotMaxTotalPrice` . For more information, see [Surplus credits can incur charges](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-unlimited-mode-concepts.html#unlimited-mode-surplus-credits) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "spot_max_total_price")

    @property
    @pulumi.getter(name="spotPrice")
    def spot_price(self) -> Optional[str]:
        """
        The maximum price per unit hour that you are willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.

        > If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.
        """
        return pulumi.get(self, "spot_price")

    @property
    @pulumi.getter(name="tagSpecifications")
    def tag_specifications(self) -> Optional[Sequence['outputs.SpotFleetTagSpecification']]:
        """
        The key-value pair for tagging the Spot Fleet request on creation. The value for `ResourceType` must be `spot-fleet-request` , otherwise the Spot Fleet request fails. To tag instances at launch, specify the tags in the [launch template](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#create-launch-template) (valid only if you use `LaunchTemplateConfigs` ) or in the `[SpotFleetTagSpecification](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SpotFleetTagSpecification.html)` (valid only if you use `LaunchSpecifications` ). For information about tagging after launch, see [Tag your resources](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#tag-resources) .
        """
        return pulumi.get(self, "tag_specifications")

    @property
    @pulumi.getter(name="targetCapacityUnitType")
    def target_capacity_unit_type(self) -> Optional['SpotFleetRequestConfigDataTargetCapacityUnitType']:
        """
        The unit for the target capacity. You can specify this parameter only when using attribute-based instance type selection.

        Default: `units` (the number of instances)
        """
        return pulumi.get(self, "target_capacity_unit_type")

    @property
    @pulumi.getter(name="terminateInstancesWithExpiration")
    def terminate_instances_with_expiration(self) -> Optional[bool]:
        """
        Indicates whether running Spot Instances are terminated when the Spot Fleet request expires.
        """
        return pulumi.get(self, "terminate_instances_with_expiration")

    @property
    @pulumi.getter
    def type(self) -> Optional['SpotFleetRequestConfigDataType']:
        """
        The type of request. Indicates whether the Spot Fleet only requests the target capacity or also attempts to maintain it. When this value is `request` , the Spot Fleet only places the required requests. It does not attempt to replenish Spot Instances if capacity is diminished, nor does it submit requests in alternative Spot pools if capacity is not available. When this value is `maintain` , the Spot Fleet maintains the target capacity. The Spot Fleet places the required requests to meet capacity and automatically replenishes any interrupted instances. Default: `maintain` . `instant` is listed but is not used by Spot Fleet.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="validFrom")
    def valid_from(self) -> Optional[str]:
        """
        The start date and time of the request, in UTC format ( *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z). By default, Amazon EC2 starts fulfilling the request immediately.
        """
        return pulumi.get(self, "valid_from")

    @property
    @pulumi.getter(name="validUntil")
    def valid_until(self) -> Optional[str]:
        """
        The end date and time of the request, in UTC format ( *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z). After the end date and time, no new Spot Instance requests are placed or able to fulfill the request. If no value is specified, the Spot Fleet request remains until you cancel it.
        """
        return pulumi.get(self, "valid_until")


@pulumi.output_type
class SpotFleetSpotCapacityRebalance(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replacementStrategy":
            suggest = "replacement_strategy"
        elif key == "terminationDelay":
            suggest = "termination_delay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetSpotCapacityRebalance. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetSpotCapacityRebalance.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetSpotCapacityRebalance.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 replacement_strategy: Optional['SpotFleetSpotCapacityRebalanceReplacementStrategy'] = None,
                 termination_delay: Optional[int] = None):
        """
        :param 'SpotFleetSpotCapacityRebalanceReplacementStrategy' replacement_strategy: The replacement strategy to use. Only available for fleets of type `maintain` .
               
               `launch` - Spot Fleet launches a new replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet. Spot Fleet does not terminate the instances that receive a rebalance notification. You can terminate the old instances, or you can leave them running. You are charged for all instances while they are running.
               
               `launch-before-terminate` - Spot Fleet launches a new replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet, and then, after a delay that you specify (in `TerminationDelay` ), terminates the instances that received a rebalance notification.
        :param int termination_delay: The amount of time (in seconds) that Amazon EC2 waits before terminating the old Spot Instance after launching a new replacement Spot Instance.
               
               Required when `ReplacementStrategy` is set to `launch-before-terminate` .
               
               Not valid when `ReplacementStrategy` is set to `launch` .
               
               Valid values: Minimum value of `120` seconds. Maximum value of `7200` seconds.
        """
        if replacement_strategy is not None:
            pulumi.set(__self__, "replacement_strategy", replacement_strategy)
        if termination_delay is not None:
            pulumi.set(__self__, "termination_delay", termination_delay)

    @property
    @pulumi.getter(name="replacementStrategy")
    def replacement_strategy(self) -> Optional['SpotFleetSpotCapacityRebalanceReplacementStrategy']:
        """
        The replacement strategy to use. Only available for fleets of type `maintain` .

        `launch` - Spot Fleet launches a new replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet. Spot Fleet does not terminate the instances that receive a rebalance notification. You can terminate the old instances, or you can leave them running. You are charged for all instances while they are running.

        `launch-before-terminate` - Spot Fleet launches a new replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet, and then, after a delay that you specify (in `TerminationDelay` ), terminates the instances that received a rebalance notification.
        """
        return pulumi.get(self, "replacement_strategy")

    @property
    @pulumi.getter(name="terminationDelay")
    def termination_delay(self) -> Optional[int]:
        """
        The amount of time (in seconds) that Amazon EC2 waits before terminating the old Spot Instance after launching a new replacement Spot Instance.

        Required when `ReplacementStrategy` is set to `launch-before-terminate` .

        Not valid when `ReplacementStrategy` is set to `launch` .

        Valid values: Minimum value of `120` seconds. Maximum value of `7200` seconds.
        """
        return pulumi.get(self, "termination_delay")


@pulumi.output_type
class SpotFleetSpotMaintenanceStrategies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityRebalance":
            suggest = "capacity_rebalance"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetSpotMaintenanceStrategies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetSpotMaintenanceStrategies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetSpotMaintenanceStrategies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_rebalance: Optional['outputs.SpotFleetSpotCapacityRebalance'] = None):
        """
        :param 'SpotFleetSpotCapacityRebalance' capacity_rebalance: The Spot Instance replacement strategy to use when Amazon EC2 emits a signal that your Spot Instance is at an elevated risk of being interrupted. For more information, see [Capacity rebalancing](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-capacity-rebalance.html) in the *Amazon EC2 User Guide* .
        """
        if capacity_rebalance is not None:
            pulumi.set(__self__, "capacity_rebalance", capacity_rebalance)

    @property
    @pulumi.getter(name="capacityRebalance")
    def capacity_rebalance(self) -> Optional['outputs.SpotFleetSpotCapacityRebalance']:
        """
        The Spot Instance replacement strategy to use when Amazon EC2 emits a signal that your Spot Instance is at an elevated risk of being interrupted. For more information, see [Capacity rebalancing](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-capacity-rebalance.html) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "capacity_rebalance")


@pulumi.output_type
class SpotFleetSpotPlacement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "groupName":
            suggest = "group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetSpotPlacement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetSpotPlacement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetSpotPlacement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone: Optional[str] = None,
                 group_name: Optional[str] = None,
                 tenancy: Optional['SpotFleetSpotPlacementTenancy'] = None):
        """
        :param str availability_zone: The Availability Zone.
               
               To specify multiple Availability Zones, separate them using commas; for example, "us-west-2a, us-west-2b".
        :param str group_name: The name of the placement group.
        :param 'SpotFleetSpotPlacementTenancy' tenancy: The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of `dedicated` runs on single-tenant hardware. The `host` tenancy is not supported for Spot Instances.
        """
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if tenancy is not None:
            pulumi.set(__self__, "tenancy", tenancy)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[str]:
        """
        The Availability Zone.

        To specify multiple Availability Zones, separate them using commas; for example, "us-west-2a, us-west-2b".
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[str]:
        """
        The name of the placement group.
        """
        return pulumi.get(self, "group_name")

    @property
    @pulumi.getter
    def tenancy(self) -> Optional['SpotFleetSpotPlacementTenancy']:
        """
        The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of `dedicated` runs on single-tenant hardware. The `host` tenancy is not supported for Spot Instances.
        """
        return pulumi.get(self, "tenancy")


@pulumi.output_type
class SpotFleetTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The tag key.
        :param str value: The tag value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The tag value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SpotFleetTagSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetTagSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetTagSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetTagSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_type: Optional['SpotFleetTagSpecificationResourceType'] = None,
                 tags: Optional[Sequence['outputs.SpotFleetTag']] = None):
        """
        :param 'SpotFleetTagSpecificationResourceType' resource_type: The type of resource. Currently, the only resource type that is supported is `instance` . To tag the Spot Fleet request on creation, use the `TagSpecifications` parameter in `[SpotFleetRequestConfigData](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SpotFleetRequestConfigData.html)` .
        :param Sequence['SpotFleetTag'] tags: The tags.
        """
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional['SpotFleetTagSpecificationResourceType']:
        """
        The type of resource. Currently, the only resource type that is supported is `instance` . To tag the Spot Fleet request on creation, use the `TagSpecifications` parameter in `[SpotFleetRequestConfigData](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SpotFleetRequestConfigData.html)` .
        """
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.SpotFleetTag']]:
        """
        The tags.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SpotFleetTargetGroup(dict):
    def __init__(__self__, *,
                 arn: str):
        """
        :param str arn: The Amazon Resource Name (ARN) of the target group.
        """
        pulumi.set(__self__, "arn", arn)

    @property
    @pulumi.getter
    def arn(self) -> str:
        """
        The Amazon Resource Name (ARN) of the target group.
        """
        return pulumi.get(self, "arn")


@pulumi.output_type
class SpotFleetTargetGroupsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetGroups":
            suggest = "target_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetTargetGroupsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetTargetGroupsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetTargetGroupsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_groups: Sequence['outputs.SpotFleetTargetGroup']):
        """
        :param Sequence['SpotFleetTargetGroup'] target_groups: One or more target groups.
        """
        pulumi.set(__self__, "target_groups", target_groups)

    @property
    @pulumi.getter(name="targetGroups")
    def target_groups(self) -> Sequence['outputs.SpotFleetTargetGroup']:
        """
        One or more target groups.
        """
        return pulumi.get(self, "target_groups")


@pulumi.output_type
class SpotFleetTotalLocalStorageGbRequest(dict):
    def __init__(__self__, *,
                 max: Optional[float] = None,
                 min: Optional[float] = None):
        """
        :param float max: The maximum amount of total local storage, in GB. To specify no maximum limit, omit this parameter.
        :param float min: The minimum amount of total local storage, in GB. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        """
        The maximum amount of total local storage, in GB. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        """
        The minimum amount of total local storage, in GB. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetVCpuCountRangeRequest(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        :param int max: The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
        :param int min: The minimum number of vCPUs. To specify no minimum limit, specify `0` .
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        The minimum number of vCPUs. To specify no minimum limit, specify `0` .
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class SseSpecificationProperties(dict):
    """
    The configuration options for customer provided KMS encryption.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customerManagedKeyEnabled":
            suggest = "customer_managed_key_enabled"
        elif key == "kmsKeyArn":
            suggest = "kms_key_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SseSpecificationProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SseSpecificationProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SseSpecificationProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 customer_managed_key_enabled: Optional[bool] = None,
                 kms_key_arn: Optional[str] = None):
        """
        The configuration options for customer provided KMS encryption.
        :param bool customer_managed_key_enabled: Whether to encrypt the policy with the provided key or disable encryption
        :param str kms_key_arn: KMS Key Arn used to encrypt the group policy
        """
        if customer_managed_key_enabled is not None:
            pulumi.set(__self__, "customer_managed_key_enabled", customer_managed_key_enabled)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @property
    @pulumi.getter(name="customerManagedKeyEnabled")
    def customer_managed_key_enabled(self) -> Optional[bool]:
        """
        Whether to encrypt the policy with the provided key or disable encryption
        """
        return pulumi.get(self, "customer_managed_key_enabled")

    @property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[str]:
        """
        KMS Key Arn used to encrypt the group policy
        """
        return pulumi.get(self, "kms_key_arn")


@pulumi.output_type
class TagSpecification(dict):
    """
    Specifies the tags to apply to a resource when the resource is created for the launch template.
      ``TagSpecification`` is a property type of [TagSpecifications](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-tagspecifications). [TagSpecifications](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-tagspecifications) is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TagSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TagSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TagSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_type: Optional[str] = None,
                 tags: Optional[Sequence['outputs.LaunchTemplateTag']] = None):
        """
        Specifies the tags to apply to a resource when the resource is created for the launch template.
          ``TagSpecification`` is a property type of [TagSpecifications](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-tagspecifications). [TagSpecifications](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-tagspecifications) is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        :param str resource_type: The type of resource to tag. You can specify tags for the following resource types only: ``instance`` | ``volume`` | ``network-interface`` | ``spot-instances-request``. If the instance does not include the resource type that you specify, the instance launch fails. For example, not all instance types include a volume.
                To tag a resource after it has been created, see [CreateTags](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html).
        :param Sequence['LaunchTemplateTag'] tags: The tags to apply to the resource.
        """
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[str]:
        """
        The type of resource to tag. You can specify tags for the following resource types only: ``instance`` | ``volume`` | ``network-interface`` | ``spot-instances-request``. If the instance does not include the resource type that you specify, the instance launch fails. For example, not all instance types include a volume.
         To tag a resource after it has been created, see [CreateTags](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html).
        """
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.LaunchTemplateTag']]:
        """
        The tags to apply to the resource.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class TransitGatewayConnectOptions(dict):
    def __init__(__self__, *,
                 protocol: Optional[str] = None):
        """
        :param str protocol: The tunnel protocol.
        """
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The tunnel protocol.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class TransitGatewayPeeringAttachmentPeeringAttachmentStatus(dict):
    def __init__(__self__, *,
                 code: Optional[str] = None,
                 message: Optional[str] = None):
        """
        :param str code: The status code.
        :param str message: The status message, if applicable.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def code(self) -> Optional[str]:
        """
        The status code.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        The status message, if applicable.
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class VerifiedAccessEndpointLoadBalancerOptions(dict):
    """
    The load balancer details if creating the AWS Verified Access endpoint as load-balancertype.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loadBalancerArn":
            suggest = "load_balancer_arn"
        elif key == "subnetIds":
            suggest = "subnet_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VerifiedAccessEndpointLoadBalancerOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VerifiedAccessEndpointLoadBalancerOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VerifiedAccessEndpointLoadBalancerOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 load_balancer_arn: Optional[str] = None,
                 port: Optional[int] = None,
                 protocol: Optional[str] = None,
                 subnet_ids: Optional[Sequence[str]] = None):
        """
        The load balancer details if creating the AWS Verified Access endpoint as load-balancertype.
        :param str load_balancer_arn: The ARN of the load balancer.
        :param int port: The IP port number.
        :param str protocol: The IP protocol.
        :param Sequence[str] subnet_ids: The IDs of the subnets.
        """
        if load_balancer_arn is not None:
            pulumi.set(__self__, "load_balancer_arn", load_balancer_arn)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if subnet_ids is not None:
            pulumi.set(__self__, "subnet_ids", subnet_ids)

    @property
    @pulumi.getter(name="loadBalancerArn")
    def load_balancer_arn(self) -> Optional[str]:
        """
        The ARN of the load balancer.
        """
        return pulumi.get(self, "load_balancer_arn")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The IP port number.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The IP protocol.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Optional[Sequence[str]]:
        """
        The IDs of the subnets.
        """
        return pulumi.get(self, "subnet_ids")


@pulumi.output_type
class VerifiedAccessEndpointNetworkInterfaceOptions(dict):
    """
    The options for network-interface type endpoint.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkInterfaceId":
            suggest = "network_interface_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VerifiedAccessEndpointNetworkInterfaceOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VerifiedAccessEndpointNetworkInterfaceOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VerifiedAccessEndpointNetworkInterfaceOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_interface_id: Optional[str] = None,
                 port: Optional[int] = None,
                 protocol: Optional[str] = None):
        """
        The options for network-interface type endpoint.
        :param str network_interface_id: The ID of the network interface.
        :param int port: The IP port number.
        :param str protocol: The IP protocol.
        """
        if network_interface_id is not None:
            pulumi.set(__self__, "network_interface_id", network_interface_id)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[str]:
        """
        The ID of the network interface.
        """
        return pulumi.get(self, "network_interface_id")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The IP port number.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The IP protocol.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class VerifiedAccessEndpointSseSpecification(dict):
    """
    The configuration options for customer provided KMS encryption.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customerManagedKeyEnabled":
            suggest = "customer_managed_key_enabled"
        elif key == "kmsKeyArn":
            suggest = "kms_key_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VerifiedAccessEndpointSseSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VerifiedAccessEndpointSseSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VerifiedAccessEndpointSseSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 customer_managed_key_enabled: Optional[bool] = None,
                 kms_key_arn: Optional[str] = None):
        """
        The configuration options for customer provided KMS encryption.
        :param bool customer_managed_key_enabled: Whether to encrypt the policy with the provided key or disable encryption
        :param str kms_key_arn: KMS Key Arn used to encrypt the group policy
        """
        if customer_managed_key_enabled is not None:
            pulumi.set(__self__, "customer_managed_key_enabled", customer_managed_key_enabled)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @property
    @pulumi.getter(name="customerManagedKeyEnabled")
    def customer_managed_key_enabled(self) -> Optional[bool]:
        """
        Whether to encrypt the policy with the provided key or disable encryption
        """
        return pulumi.get(self, "customer_managed_key_enabled")

    @property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[str]:
        """
        KMS Key Arn used to encrypt the group policy
        """
        return pulumi.get(self, "kms_key_arn")


@pulumi.output_type
class VerifiedAccessGroupSseSpecification(dict):
    """
    The configuration options for customer provided KMS encryption.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customerManagedKeyEnabled":
            suggest = "customer_managed_key_enabled"
        elif key == "kmsKeyArn":
            suggest = "kms_key_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VerifiedAccessGroupSseSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VerifiedAccessGroupSseSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VerifiedAccessGroupSseSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 customer_managed_key_enabled: Optional[bool] = None,
                 kms_key_arn: Optional[str] = None):
        """
        The configuration options for customer provided KMS encryption.
        :param bool customer_managed_key_enabled: Whether to encrypt the policy with the provided key or disable encryption
        :param str kms_key_arn: KMS Key Arn used to encrypt the group policy
        """
        if customer_managed_key_enabled is not None:
            pulumi.set(__self__, "customer_managed_key_enabled", customer_managed_key_enabled)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @property
    @pulumi.getter(name="customerManagedKeyEnabled")
    def customer_managed_key_enabled(self) -> Optional[bool]:
        """
        Whether to encrypt the policy with the provided key or disable encryption
        """
        return pulumi.get(self, "customer_managed_key_enabled")

    @property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[str]:
        """
        KMS Key Arn used to encrypt the group policy
        """
        return pulumi.get(self, "kms_key_arn")


@pulumi.output_type
class VerifiedAccessInstanceVerifiedAccessLogs(dict):
    """
    The configuration options for AWS Verified Access instances.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudWatchLogs":
            suggest = "cloud_watch_logs"
        elif key == "includeTrustContext":
            suggest = "include_trust_context"
        elif key == "kinesisDataFirehose":
            suggest = "kinesis_data_firehose"
        elif key == "logVersion":
            suggest = "log_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VerifiedAccessInstanceVerifiedAccessLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VerifiedAccessInstanceVerifiedAccessLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VerifiedAccessInstanceVerifiedAccessLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_watch_logs: Optional['outputs.VerifiedAccessInstanceVerifiedAccessLogsCloudWatchLogsProperties'] = None,
                 include_trust_context: Optional[bool] = None,
                 kinesis_data_firehose: Optional['outputs.VerifiedAccessInstanceVerifiedAccessLogsKinesisDataFirehoseProperties'] = None,
                 log_version: Optional[str] = None,
                 s3: Optional['outputs.VerifiedAccessInstanceVerifiedAccessLogsS3Properties'] = None):
        """
        The configuration options for AWS Verified Access instances.
        :param 'VerifiedAccessInstanceVerifiedAccessLogsCloudWatchLogsProperties' cloud_watch_logs: Sends Verified Access logs to CloudWatch Logs.
        :param bool include_trust_context: Include claims from trust providers in Verified Access logs.
        :param 'VerifiedAccessInstanceVerifiedAccessLogsKinesisDataFirehoseProperties' kinesis_data_firehose: Sends Verified Access logs to Kinesis.
        :param str log_version: Select log version for Verified Access logs.
        :param 'VerifiedAccessInstanceVerifiedAccessLogsS3Properties' s3: Sends Verified Access logs to Amazon S3.
        """
        if cloud_watch_logs is not None:
            pulumi.set(__self__, "cloud_watch_logs", cloud_watch_logs)
        if include_trust_context is not None:
            pulumi.set(__self__, "include_trust_context", include_trust_context)
        if kinesis_data_firehose is not None:
            pulumi.set(__self__, "kinesis_data_firehose", kinesis_data_firehose)
        if log_version is not None:
            pulumi.set(__self__, "log_version", log_version)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @property
    @pulumi.getter(name="cloudWatchLogs")
    def cloud_watch_logs(self) -> Optional['outputs.VerifiedAccessInstanceVerifiedAccessLogsCloudWatchLogsProperties']:
        """
        Sends Verified Access logs to CloudWatch Logs.
        """
        return pulumi.get(self, "cloud_watch_logs")

    @property
    @pulumi.getter(name="includeTrustContext")
    def include_trust_context(self) -> Optional[bool]:
        """
        Include claims from trust providers in Verified Access logs.
        """
        return pulumi.get(self, "include_trust_context")

    @property
    @pulumi.getter(name="kinesisDataFirehose")
    def kinesis_data_firehose(self) -> Optional['outputs.VerifiedAccessInstanceVerifiedAccessLogsKinesisDataFirehoseProperties']:
        """
        Sends Verified Access logs to Kinesis.
        """
        return pulumi.get(self, "kinesis_data_firehose")

    @property
    @pulumi.getter(name="logVersion")
    def log_version(self) -> Optional[str]:
        """
        Select log version for Verified Access logs.
        """
        return pulumi.get(self, "log_version")

    @property
    @pulumi.getter
    def s3(self) -> Optional['outputs.VerifiedAccessInstanceVerifiedAccessLogsS3Properties']:
        """
        Sends Verified Access logs to Amazon S3.
        """
        return pulumi.get(self, "s3")


@pulumi.output_type
class VerifiedAccessInstanceVerifiedAccessLogsCloudWatchLogsProperties(dict):
    """
    Sends Verified Access logs to CloudWatch Logs.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logGroup":
            suggest = "log_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VerifiedAccessInstanceVerifiedAccessLogsCloudWatchLogsProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VerifiedAccessInstanceVerifiedAccessLogsCloudWatchLogsProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VerifiedAccessInstanceVerifiedAccessLogsCloudWatchLogsProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 log_group: Optional[str] = None):
        """
        Sends Verified Access logs to CloudWatch Logs.
        :param bool enabled: Indicates whether logging is enabled.
        :param str log_group: The ID of the CloudWatch Logs log group.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if log_group is not None:
            pulumi.set(__self__, "log_group", log_group)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Indicates whether logging is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="logGroup")
    def log_group(self) -> Optional[str]:
        """
        The ID of the CloudWatch Logs log group.
        """
        return pulumi.get(self, "log_group")


@pulumi.output_type
class VerifiedAccessInstanceVerifiedAccessLogsKinesisDataFirehoseProperties(dict):
    """
    Sends Verified Access logs to Kinesis.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deliveryStream":
            suggest = "delivery_stream"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VerifiedAccessInstanceVerifiedAccessLogsKinesisDataFirehoseProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VerifiedAccessInstanceVerifiedAccessLogsKinesisDataFirehoseProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VerifiedAccessInstanceVerifiedAccessLogsKinesisDataFirehoseProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delivery_stream: Optional[str] = None,
                 enabled: Optional[bool] = None):
        """
        Sends Verified Access logs to Kinesis.
        :param str delivery_stream: The ID of the delivery stream.
        :param bool enabled: Indicates whether logging is enabled.
        """
        if delivery_stream is not None:
            pulumi.set(__self__, "delivery_stream", delivery_stream)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="deliveryStream")
    def delivery_stream(self) -> Optional[str]:
        """
        The ID of the delivery stream.
        """
        return pulumi.get(self, "delivery_stream")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Indicates whether logging is enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class VerifiedAccessInstanceVerifiedAccessLogsS3Properties(dict):
    """
    Sends Verified Access logs to Amazon S3.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "bucketOwner":
            suggest = "bucket_owner"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VerifiedAccessInstanceVerifiedAccessLogsS3Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VerifiedAccessInstanceVerifiedAccessLogsS3Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VerifiedAccessInstanceVerifiedAccessLogsS3Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: Optional[str] = None,
                 bucket_owner: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 prefix: Optional[str] = None):
        """
        Sends Verified Access logs to Amazon S3.
        :param str bucket_name: The bucket name.
        :param str bucket_owner: The ID of the AWS account that owns the Amazon S3 bucket.
        :param bool enabled: Indicates whether logging is enabled.
        :param str prefix: The bucket prefix.
        """
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if bucket_owner is not None:
            pulumi.set(__self__, "bucket_owner", bucket_owner)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        """
        The bucket name.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="bucketOwner")
    def bucket_owner(self) -> Optional[str]:
        """
        The ID of the AWS account that owns the Amazon S3 bucket.
        """
        return pulumi.get(self, "bucket_owner")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Indicates whether logging is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        The bucket prefix.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class VerifiedAccessInstanceVerifiedAccessTrustProvider(dict):
    """
    A Verified Access Trust Provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceTrustProviderType":
            suggest = "device_trust_provider_type"
        elif key == "trustProviderType":
            suggest = "trust_provider_type"
        elif key == "userTrustProviderType":
            suggest = "user_trust_provider_type"
        elif key == "verifiedAccessTrustProviderId":
            suggest = "verified_access_trust_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VerifiedAccessInstanceVerifiedAccessTrustProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VerifiedAccessInstanceVerifiedAccessTrustProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VerifiedAccessInstanceVerifiedAccessTrustProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 device_trust_provider_type: Optional[str] = None,
                 trust_provider_type: Optional[str] = None,
                 user_trust_provider_type: Optional[str] = None,
                 verified_access_trust_provider_id: Optional[str] = None):
        """
        A Verified Access Trust Provider.
        :param str description: The description of trust provider.
        :param str device_trust_provider_type: The type of device-based trust provider.
        :param str trust_provider_type: The type of trust provider (user- or device-based).
        :param str user_trust_provider_type: The type of user-based trust provider.
        :param str verified_access_trust_provider_id: The ID of the trust provider.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if device_trust_provider_type is not None:
            pulumi.set(__self__, "device_trust_provider_type", device_trust_provider_type)
        if trust_provider_type is not None:
            pulumi.set(__self__, "trust_provider_type", trust_provider_type)
        if user_trust_provider_type is not None:
            pulumi.set(__self__, "user_trust_provider_type", user_trust_provider_type)
        if verified_access_trust_provider_id is not None:
            pulumi.set(__self__, "verified_access_trust_provider_id", verified_access_trust_provider_id)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of trust provider.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="deviceTrustProviderType")
    def device_trust_provider_type(self) -> Optional[str]:
        """
        The type of device-based trust provider.
        """
        return pulumi.get(self, "device_trust_provider_type")

    @property
    @pulumi.getter(name="trustProviderType")
    def trust_provider_type(self) -> Optional[str]:
        """
        The type of trust provider (user- or device-based).
        """
        return pulumi.get(self, "trust_provider_type")

    @property
    @pulumi.getter(name="userTrustProviderType")
    def user_trust_provider_type(self) -> Optional[str]:
        """
        The type of user-based trust provider.
        """
        return pulumi.get(self, "user_trust_provider_type")

    @property
    @pulumi.getter(name="verifiedAccessTrustProviderId")
    def verified_access_trust_provider_id(self) -> Optional[str]:
        """
        The ID of the trust provider.
        """
        return pulumi.get(self, "verified_access_trust_provider_id")


@pulumi.output_type
class VerifiedAccessTrustProviderDeviceOptions(dict):
    """
    The options for device identity based trust providers.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicSigningKeyUrl":
            suggest = "public_signing_key_url"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VerifiedAccessTrustProviderDeviceOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VerifiedAccessTrustProviderDeviceOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VerifiedAccessTrustProviderDeviceOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 public_signing_key_url: Optional[str] = None,
                 tenant_id: Optional[str] = None):
        """
        The options for device identity based trust providers.
        :param str public_signing_key_url: URL Verified Access will use to verify authenticity of the device tokens.
        :param str tenant_id: The ID of the tenant application with the device-identity provider.
        """
        if public_signing_key_url is not None:
            pulumi.set(__self__, "public_signing_key_url", public_signing_key_url)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="publicSigningKeyUrl")
    def public_signing_key_url(self) -> Optional[str]:
        """
        URL Verified Access will use to verify authenticity of the device tokens.
        """
        return pulumi.get(self, "public_signing_key_url")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The ID of the tenant application with the device-identity provider.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class VerifiedAccessTrustProviderOidcOptions(dict):
    """
    The OpenID Connect details for an oidc -type, user-identity based trust provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizationEndpoint":
            suggest = "authorization_endpoint"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "tokenEndpoint":
            suggest = "token_endpoint"
        elif key == "userInfoEndpoint":
            suggest = "user_info_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VerifiedAccessTrustProviderOidcOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VerifiedAccessTrustProviderOidcOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VerifiedAccessTrustProviderOidcOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorization_endpoint: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 issuer: Optional[str] = None,
                 scope: Optional[str] = None,
                 token_endpoint: Optional[str] = None,
                 user_info_endpoint: Optional[str] = None):
        """
        The OpenID Connect details for an oidc -type, user-identity based trust provider.
        :param str authorization_endpoint: The OIDC authorization endpoint.
        :param str client_id: The client identifier.
        :param str client_secret: The client secret.
        :param str issuer: The OIDC issuer.
        :param str scope: OpenID Connect (OIDC) scopes are used by an application during authentication to authorize access to details of a user. Each scope returns a specific set of user attributes.
        :param str token_endpoint: The OIDC token endpoint.
        :param str user_info_endpoint: The OIDC user info endpoint.
        """
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if user_info_endpoint is not None:
            pulumi.set(__self__, "user_info_endpoint", user_info_endpoint)

    @property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[str]:
        """
        The OIDC authorization endpoint.
        """
        return pulumi.get(self, "authorization_endpoint")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The client identifier.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The client secret.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter
    def issuer(self) -> Optional[str]:
        """
        The OIDC issuer.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        OpenID Connect (OIDC) scopes are used by an application during authentication to authorize access to details of a user. Each scope returns a specific set of user attributes.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[str]:
        """
        The OIDC token endpoint.
        """
        return pulumi.get(self, "token_endpoint")

    @property
    @pulumi.getter(name="userInfoEndpoint")
    def user_info_endpoint(self) -> Optional[str]:
        """
        The OIDC user info endpoint.
        """
        return pulumi.get(self, "user_info_endpoint")


@pulumi.output_type
class VpnConnectionVpnTunnelOptionsSpecification(dict):
    """
    The tunnel options for a single VPN tunnel.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preSharedKey":
            suggest = "pre_shared_key"
        elif key == "tunnelInsideCidr":
            suggest = "tunnel_inside_cidr"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnConnectionVpnTunnelOptionsSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnConnectionVpnTunnelOptionsSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnConnectionVpnTunnelOptionsSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pre_shared_key: Optional[str] = None,
                 tunnel_inside_cidr: Optional[str] = None):
        """
        The tunnel options for a single VPN tunnel.
        :param str pre_shared_key: The pre-shared key (PSK) to establish initial authentication between the virtual private gateway and customer gateway.
                Constraints: Allowed characters are alphanumeric characters, periods (.), and underscores (_). Must be between 8 and 64 characters in length and cannot start with zero (0).
        :param str tunnel_inside_cidr: The range of inside IP addresses for the tunnel. Any specified CIDR blocks must be unique across all VPN connections that use the same virtual private gateway. 
                Constraints: A size /30 CIDR block from the ``169.254.0.0/16`` range. The following CIDR blocks are reserved and cannot be used:
                 +   ``169.254.0.0/30`` 
                 +   ``169.254.1.0/30`` 
                 +   ``169.254.2.0/30`` 
                 +   ``169.254.3.0/30`` 
                 +   ``169.254.4.0/30`` 
                 +   ``169.254.5.0/30`` 
                 +   ``169.254.169.252/30``
        """
        if pre_shared_key is not None:
            pulumi.set(__self__, "pre_shared_key", pre_shared_key)
        if tunnel_inside_cidr is not None:
            pulumi.set(__self__, "tunnel_inside_cidr", tunnel_inside_cidr)

    @property
    @pulumi.getter(name="preSharedKey")
    def pre_shared_key(self) -> Optional[str]:
        """
        The pre-shared key (PSK) to establish initial authentication between the virtual private gateway and customer gateway.
         Constraints: Allowed characters are alphanumeric characters, periods (.), and underscores (_). Must be between 8 and 64 characters in length and cannot start with zero (0).
        """
        return pulumi.get(self, "pre_shared_key")

    @property
    @pulumi.getter(name="tunnelInsideCidr")
    def tunnel_inside_cidr(self) -> Optional[str]:
        """
        The range of inside IP addresses for the tunnel. Any specified CIDR blocks must be unique across all VPN connections that use the same virtual private gateway. 
         Constraints: A size /30 CIDR block from the ``169.254.0.0/16`` range. The following CIDR blocks are reserved and cannot be used:
          +   ``169.254.0.0/30`` 
          +   ``169.254.1.0/30`` 
          +   ``169.254.2.0/30`` 
          +   ``169.254.3.0/30`` 
          +   ``169.254.4.0/30`` 
          +   ``169.254.5.0/30`` 
          +   ``169.254.169.252/30``
        """
        return pulumi.get(self, "tunnel_inside_cidr")


