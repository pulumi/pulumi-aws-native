# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'BlockPublicAccessStatesProperties',
    'CapacityReservationCapacityAllocation',
    'CapacityReservationFleetInstanceTypeSpecification',
    'CapacityReservationFleetTag',
    'CapacityReservationFleetTagSpecification',
    'CapacityReservationTag',
    'CapacityReservationTagSpecification',
    'CommitmentInfoProperties',
    'CpuOptionsProperties',
    'CreditSpecificationProperties',
    'DestinationOptionsProperties',
    'Ec2FleetAcceleratorCountRequest',
    'Ec2FleetAcceleratorTotalMemoryMiBRequest',
    'Ec2FleetBaselineEbsBandwidthMbpsRequest',
    'Ec2FleetBaselinePerformanceFactorsRequest',
    'Ec2FleetBlockDeviceMapping',
    'Ec2FleetCapacityRebalance',
    'Ec2FleetCapacityReservationOptionsRequest',
    'Ec2FleetCpuPerformanceFactorRequest',
    'Ec2FleetEbsBlockDevice',
    'Ec2FleetFleetLaunchTemplateConfigRequest',
    'Ec2FleetFleetLaunchTemplateOverridesRequest',
    'Ec2FleetFleetLaunchTemplateSpecificationRequest',
    'Ec2FleetInstanceRequirementsRequest',
    'Ec2FleetMaintenanceStrategies',
    'Ec2FleetMemoryGiBPerVCpuRequest',
    'Ec2FleetMemoryMiBRequest',
    'Ec2FleetNetworkBandwidthGbpsRequest',
    'Ec2FleetNetworkInterfaceCountRequest',
    'Ec2FleetOnDemandOptionsRequest',
    'Ec2FleetPerformanceFactorReferenceRequest',
    'Ec2FleetPlacement',
    'Ec2FleetSpotOptionsRequest',
    'Ec2FleetTag',
    'Ec2FleetTagSpecification',
    'Ec2FleetTargetCapacitySpecificationRequest',
    'Ec2FleetTotalLocalStorageGbRequest',
    'Ec2FleetVCpuCountRangeRequest',
    'EnclaveOptionsProperties',
    'HibernationOptionsProperties',
    'InstanceAssociationParameter',
    'InstanceBlockDeviceMapping',
    'InstanceEbs',
    'InstanceElasticGpuSpecification',
    'InstanceElasticInferenceAccelerator',
    'InstanceEnaSrdSpecification',
    'InstanceEnaSrdUdpSpecification',
    'InstanceIpv6Address',
    'InstanceLaunchTemplateSpecification',
    'InstanceLicenseSpecification',
    'InstanceMetadataOptions',
    'InstanceNetworkInterface',
    'InstancePrivateDnsNameOptions',
    'InstancePrivateIpAddressSpecification',
    'InstanceSsmAssociation',
    'InstanceState',
    'InstanceVolume',
    'IpamOperatingRegion',
    'IpamOrganizationalUnitExclusion',
    'IpamPoolProvisionedCidr',
    'IpamPoolSourceResource',
    'IpamPoolTag',
    'IpamResourceDiscoveryIpamOperatingRegion',
    'IpamResourceDiscoveryOrganizationalUnitExclusion',
    'LaunchTemplateAcceleratorCount',
    'LaunchTemplateAcceleratorTotalMemoryMiB',
    'LaunchTemplateBaselineEbsBandwidthMbps',
    'LaunchTemplateBaselinePerformanceFactors',
    'LaunchTemplateBlockDeviceMapping',
    'LaunchTemplateCapacityReservationSpecification',
    'LaunchTemplateCapacityReservationTarget',
    'LaunchTemplateConnectionTrackingSpecification',
    'LaunchTemplateCpu',
    'LaunchTemplateCpuOptions',
    'LaunchTemplateCreditSpecification',
    'LaunchTemplateData',
    'LaunchTemplateEbs',
    'LaunchTemplateEnaSrdSpecification',
    'LaunchTemplateEnaSrdUdpSpecification',
    'LaunchTemplateEnclaveOptions',
    'LaunchTemplateHibernationOptions',
    'LaunchTemplateIamInstanceProfile',
    'LaunchTemplateInstanceMarketOptions',
    'LaunchTemplateInstanceRequirements',
    'LaunchTemplateIpv4PrefixSpecification',
    'LaunchTemplateIpv6Add',
    'LaunchTemplateIpv6PrefixSpecification',
    'LaunchTemplateLicenseSpecification',
    'LaunchTemplateMaintenanceOptions',
    'LaunchTemplateMemoryGiBPerVCpu',
    'LaunchTemplateMemoryMiB',
    'LaunchTemplateMetadataOptions',
    'LaunchTemplateMonitoring',
    'LaunchTemplateNetworkBandwidthGbps',
    'LaunchTemplateNetworkInterface',
    'LaunchTemplateNetworkInterfaceCount',
    'LaunchTemplateNetworkPerformanceOptions',
    'LaunchTemplatePlacement',
    'LaunchTemplatePrivateDnsNameOptions',
    'LaunchTemplatePrivateIpAdd',
    'LaunchTemplateReference',
    'LaunchTemplateSpotOptions',
    'LaunchTemplateTag',
    'LaunchTemplateTagSpecification',
    'LaunchTemplateTotalLocalStorageGb',
    'LaunchTemplateVCpuCount',
    'NetworkInsightsAccessScopeAccessScopePathRequest',
    'NetworkInsightsAccessScopePacketHeaderStatementRequest',
    'NetworkInsightsAccessScopePathStatementRequest',
    'NetworkInsightsAccessScopeResourceStatementRequest',
    'NetworkInsightsAccessScopeThroughResourcesStatementRequest',
    'NetworkInsightsAnalysisAdditionalDetail',
    'NetworkInsightsAnalysisAlternatePathHint',
    'NetworkInsightsAnalysisAnalysisAclRule',
    'NetworkInsightsAnalysisAnalysisComponent',
    'NetworkInsightsAnalysisAnalysisLoadBalancerListener',
    'NetworkInsightsAnalysisAnalysisLoadBalancerTarget',
    'NetworkInsightsAnalysisAnalysisPacketHeader',
    'NetworkInsightsAnalysisAnalysisRouteTableRoute',
    'NetworkInsightsAnalysisAnalysisSecurityGroupRule',
    'NetworkInsightsAnalysisExplanation',
    'NetworkInsightsAnalysisPathComponent',
    'NetworkInsightsAnalysisPortRange',
    'NetworkInsightsAnalysisTransitGatewayRouteTableRoute',
    'NetworkInsightsPathFilterPortRange',
    'NetworkInsightsPathPathFilter',
    'NetworkInterfaceAttachmentEnaSrdSpecification',
    'NetworkInterfaceAttachmentEnaSrdSpecificationEnaSrdUdpSpecificationProperties',
    'NetworkInterfaceConnectionTrackingSpecification',
    'NetworkInterfaceInstanceIpv6Address',
    'NetworkInterfaceIpv4PrefixSpecification',
    'NetworkInterfaceIpv6PrefixSpecification',
    'NetworkInterfacePrivateIpAddressSpecification',
    'OptionsProperties',
    'PrefixListEntry',
    'PrivateDnsNameOptionsOnLaunchProperties',
    'RouteServerPeerBgpOptions',
    'SecurityGroupEgress',
    'SecurityGroupIngress',
    'SpotFleetAcceleratorCountRequest',
    'SpotFleetAcceleratorTotalMemoryMiBRequest',
    'SpotFleetBaselineEbsBandwidthMbpsRequest',
    'SpotFleetBaselinePerformanceFactorsRequest',
    'SpotFleetBlockDeviceMapping',
    'SpotFleetClassicLoadBalancer',
    'SpotFleetClassicLoadBalancersConfig',
    'SpotFleetCpuPerformanceFactorRequest',
    'SpotFleetEbsBlockDevice',
    'SpotFleetFleetLaunchTemplateSpecification',
    'SpotFleetGroupIdentifier',
    'SpotFleetIamInstanceProfileSpecification',
    'SpotFleetInstanceIpv6Address',
    'SpotFleetInstanceNetworkInterfaceSpecification',
    'SpotFleetInstanceRequirementsRequest',
    'SpotFleetLaunchSpecification',
    'SpotFleetLaunchTemplateConfig',
    'SpotFleetLaunchTemplateOverrides',
    'SpotFleetLoadBalancersConfig',
    'SpotFleetMemoryGiBPerVCpuRequest',
    'SpotFleetMemoryMiBRequest',
    'SpotFleetMonitoring',
    'SpotFleetNetworkBandwidthGbpsRequest',
    'SpotFleetNetworkInterfaceCountRequest',
    'SpotFleetPerformanceFactorReferenceRequest',
    'SpotFleetPrivateIpAddressSpecification',
    'SpotFleetRequestConfigData',
    'SpotFleetSpotCapacityRebalance',
    'SpotFleetSpotMaintenanceStrategies',
    'SpotFleetSpotPlacement',
    'SpotFleetTag',
    'SpotFleetTagSpecification',
    'SpotFleetTargetGroup',
    'SpotFleetTargetGroupsConfig',
    'SpotFleetTotalLocalStorageGbRequest',
    'SpotFleetVCpuCountRangeRequest',
    'SseSpecificationProperties',
    'TagSpecification',
    'TrafficMirrorFilterRuleTrafficMirrorPortRange',
    'TransitGatewayConnectOptions',
    'TransitGatewayConnectPeerConfiguration',
    'TransitGatewayConnectPeerTransitGatewayAttachmentBgpConfiguration',
    'TransitGatewayPeeringAttachmentPeeringAttachmentStatus',
    'VerifiedAccessEndpointCidrOptions',
    'VerifiedAccessEndpointLoadBalancerOptions',
    'VerifiedAccessEndpointNetworkInterfaceOptions',
    'VerifiedAccessEndpointPortRange',
    'VerifiedAccessEndpointRdsOptions',
    'VerifiedAccessEndpointSseSpecification',
    'VerifiedAccessGroupSseSpecification',
    'VerifiedAccessInstanceVerifiedAccessLogs',
    'VerifiedAccessInstanceVerifiedAccessLogsCloudWatchLogsProperties',
    'VerifiedAccessInstanceVerifiedAccessLogsKinesisDataFirehoseProperties',
    'VerifiedAccessInstanceVerifiedAccessLogsS3Properties',
    'VerifiedAccessInstanceVerifiedAccessTrustProvider',
    'VerifiedAccessTrustProviderDeviceOptions',
    'VerifiedAccessTrustProviderNativeApplicationOidcOptions',
    'VerifiedAccessTrustProviderOidcOptions',
    'VpcEndpointDnsOptionsSpecification',
    'VpnConnectionCloudwatchLogOptionsSpecification',
    'VpnConnectionIkeVersionsRequestListValue',
    'VpnConnectionPhase1EncryptionAlgorithmsRequestListValue',
    'VpnConnectionPhase1IntegrityAlgorithmsRequestListValue',
    'VpnConnectionPhase1dhGroupNumbersRequestListValue',
    'VpnConnectionPhase2EncryptionAlgorithmsRequestListValue',
    'VpnConnectionPhase2IntegrityAlgorithmsRequestListValue',
    'VpnConnectionPhase2dhGroupNumbersRequestListValue',
    'VpnConnectionVpnTunnelLogOptionsSpecification',
    'VpnConnectionVpnTunnelOptionsSpecification',
]

@pulumi.output_type
class BlockPublicAccessStatesProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "internetGatewayBlockMode":
            suggest = "internet_gateway_block_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BlockPublicAccessStatesProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BlockPublicAccessStatesProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BlockPublicAccessStatesProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 internet_gateway_block_mode: Optional[_builtins.str] = None):
        """
        :param _builtins.str internet_gateway_block_mode: The mode of VPC BPA. Options here are off, block-bidirectional, block-ingress 
        """
        if internet_gateway_block_mode is not None:
            pulumi.set(__self__, "internet_gateway_block_mode", internet_gateway_block_mode)

    @_builtins.property
    @pulumi.getter(name="internetGatewayBlockMode")
    def internet_gateway_block_mode(self) -> Optional[_builtins.str]:
        """
        The mode of VPC BPA. Options here are off, block-bidirectional, block-ingress 
        """
        return pulumi.get(self, "internet_gateway_block_mode")


@pulumi.output_type
class CapacityReservationCapacityAllocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocationType":
            suggest = "allocation_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CapacityReservationCapacityAllocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CapacityReservationCapacityAllocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CapacityReservationCapacityAllocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocation_type: Optional[_builtins.str] = None,
                 count: Optional[_builtins.int] = None):
        """
        :param _builtins.str allocation_type: The usage type. `used` indicates that the instance capacity is in use by instances that are running in the Capacity Reservation.
        :param _builtins.int count: The amount of instance capacity associated with the usage. For example a value of `4` indicates that instance capacity for 4 instances is currently in use.
        """
        if allocation_type is not None:
            pulumi.set(__self__, "allocation_type", allocation_type)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @_builtins.property
    @pulumi.getter(name="allocationType")
    def allocation_type(self) -> Optional[_builtins.str]:
        """
        The usage type. `used` indicates that the instance capacity is in use by instances that are running in the Capacity Reservation.
        """
        return pulumi.get(self, "allocation_type")

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[_builtins.int]:
        """
        The amount of instance capacity associated with the usage. For example a value of `4` indicates that instance capacity for 4 instances is currently in use.
        """
        return pulumi.get(self, "count")


@pulumi.output_type
class CapacityReservationFleetInstanceTypeSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "availabilityZoneId":
            suggest = "availability_zone_id"
        elif key == "ebsOptimized":
            suggest = "ebs_optimized"
        elif key == "instancePlatform":
            suggest = "instance_platform"
        elif key == "instanceType":
            suggest = "instance_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CapacityReservationFleetInstanceTypeSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CapacityReservationFleetInstanceTypeSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CapacityReservationFleetInstanceTypeSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone: Optional[_builtins.str] = None,
                 availability_zone_id: Optional[_builtins.str] = None,
                 ebs_optimized: Optional[_builtins.bool] = None,
                 instance_platform: Optional[_builtins.str] = None,
                 instance_type: Optional[_builtins.str] = None,
                 priority: Optional[_builtins.int] = None,
                 weight: Optional[_builtins.float] = None):
        """
        :param _builtins.str availability_zone: The Availability Zone in which the Capacity Reservation Fleet reserves the capacity. A Capacity Reservation Fleet can't span Availability Zones. All instance type specifications that you specify for the Fleet must use the same Availability Zone.
        :param _builtins.str availability_zone_id: The ID of the Availability Zone in which the Capacity Reservation Fleet reserves the capacity. A Capacity Reservation Fleet can't span Availability Zones. All instance type specifications that you specify for the Fleet must use the same Availability Zone.
        :param _builtins.bool ebs_optimized: Indicates whether the Capacity Reservation Fleet supports EBS-optimized instances types. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using EBS-optimized instance types.
        :param _builtins.str instance_platform: The type of operating system for which the Capacity Reservation Fleet reserves capacity.
        :param _builtins.str instance_type: The instance type for which the Capacity Reservation Fleet reserves capacity.
        :param _builtins.int priority: The priority to assign to the instance type. This value is used to determine which of the instance types specified for the Fleet should be prioritized for use. A lower value indicates a high priority. For more information, see [Instance type priority](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#instance-priority) in the *Amazon EC2 User Guide* .
        :param _builtins.float weight: The number of capacity units provided by the specified instance type. This value, together with the total target capacity that you specify for the Fleet determine the number of instances for which the Fleet reserves capacity. Both values are based on units that make sense for your workload. For more information, see [Total target capacity](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#target-capacity) in the Amazon EC2 User Guide.
               
               Valid Range: Minimum value of `0.001` . Maximum value of `99.999` .
        """
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if availability_zone_id is not None:
            pulumi.set(__self__, "availability_zone_id", availability_zone_id)
        if ebs_optimized is not None:
            pulumi.set(__self__, "ebs_optimized", ebs_optimized)
        if instance_platform is not None:
            pulumi.set(__self__, "instance_platform", instance_platform)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[_builtins.str]:
        """
        The Availability Zone in which the Capacity Reservation Fleet reserves the capacity. A Capacity Reservation Fleet can't span Availability Zones. All instance type specifications that you specify for the Fleet must use the same Availability Zone.
        """
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter(name="availabilityZoneId")
    def availability_zone_id(self) -> Optional[_builtins.str]:
        """
        The ID of the Availability Zone in which the Capacity Reservation Fleet reserves the capacity. A Capacity Reservation Fleet can't span Availability Zones. All instance type specifications that you specify for the Fleet must use the same Availability Zone.
        """
        return pulumi.get(self, "availability_zone_id")

    @_builtins.property
    @pulumi.getter(name="ebsOptimized")
    def ebs_optimized(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the Capacity Reservation Fleet supports EBS-optimized instances types. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using EBS-optimized instance types.
        """
        return pulumi.get(self, "ebs_optimized")

    @_builtins.property
    @pulumi.getter(name="instancePlatform")
    def instance_platform(self) -> Optional[_builtins.str]:
        """
        The type of operating system for which the Capacity Reservation Fleet reserves capacity.
        """
        return pulumi.get(self, "instance_platform")

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[_builtins.str]:
        """
        The instance type for which the Capacity Reservation Fleet reserves capacity.
        """
        return pulumi.get(self, "instance_type")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.int]:
        """
        The priority to assign to the instance type. This value is used to determine which of the instance types specified for the Fleet should be prioritized for use. A lower value indicates a high priority. For more information, see [Instance type priority](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#instance-priority) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[_builtins.float]:
        """
        The number of capacity units provided by the specified instance type. This value, together with the total target capacity that you specify for the Fleet determine the number of instances for which the Fleet reserves capacity. Both values are based on units that make sense for your workload. For more information, see [Total target capacity](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/crfleet-concepts.html#target-capacity) in the Amazon EC2 User Guide.

        Valid Range: Minimum value of `0.001` . Maximum value of `99.999` .
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class CapacityReservationFleetTag(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: The tag key.
        :param _builtins.str value: The tag value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The tag value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CapacityReservationFleetTagSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CapacityReservationFleetTagSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CapacityReservationFleetTagSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CapacityReservationFleetTagSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_type: Optional[_builtins.str] = None,
                 tags: Optional[Sequence['outputs.CapacityReservationFleetTag']] = None):
        """
        :param _builtins.str resource_type: The type of resource to tag on creation. Specify `capacity-reservation-fleet` .
               
               To tag a resource after it has been created, see [CreateTags](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html) .
        :param Sequence['CapacityReservationFleetTag'] tags: The tags to apply to the resource.
        """
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[_builtins.str]:
        """
        The type of resource to tag on creation. Specify `capacity-reservation-fleet` .

        To tag a resource after it has been created, see [CreateTags](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html) .
        """
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.CapacityReservationFleetTag']]:
        """
        The tags to apply to the resource.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class CapacityReservationTag(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: The tag key.
        :param _builtins.str value: The tag value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The tag value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CapacityReservationTagSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CapacityReservationTagSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CapacityReservationTagSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CapacityReservationTagSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_type: Optional[_builtins.str] = None,
                 tags: Optional[Sequence['outputs.CapacityReservationTag']] = None):
        """
        :param _builtins.str resource_type: The type of resource to tag. Specify `capacity-reservation` .
        :param Sequence['CapacityReservationTag'] tags: The tags to apply to the resource.
        """
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[_builtins.str]:
        """
        The type of resource to tag. Specify `capacity-reservation` .
        """
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.CapacityReservationTag']]:
        """
        The tags to apply to the resource.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class CommitmentInfoProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commitmentEndDate":
            suggest = "commitment_end_date"
        elif key == "committedInstanceCount":
            suggest = "committed_instance_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CommitmentInfoProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CommitmentInfoProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CommitmentInfoProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 commitment_end_date: Optional[_builtins.str] = None,
                 committed_instance_count: Optional[_builtins.int] = None):
        """
        :param _builtins.str commitment_end_date: The date and time at which the commitment duration expires, in the ISO8601 format in the UTC time zone ( `YYYY-MM-DDThh:mm:ss.sssZ` ). You can't decrease the instance count or cancel the Capacity Reservation before this date and time.
        :param _builtins.int committed_instance_count: The instance capacity that you committed to when you requested the future-dated Capacity Reservation.
        """
        if commitment_end_date is not None:
            pulumi.set(__self__, "commitment_end_date", commitment_end_date)
        if committed_instance_count is not None:
            pulumi.set(__self__, "committed_instance_count", committed_instance_count)

    @_builtins.property
    @pulumi.getter(name="commitmentEndDate")
    def commitment_end_date(self) -> Optional[_builtins.str]:
        """
        The date and time at which the commitment duration expires, in the ISO8601 format in the UTC time zone ( `YYYY-MM-DDThh:mm:ss.sssZ` ). You can't decrease the instance count or cancel the Capacity Reservation before this date and time.
        """
        return pulumi.get(self, "commitment_end_date")

    @_builtins.property
    @pulumi.getter(name="committedInstanceCount")
    def committed_instance_count(self) -> Optional[_builtins.int]:
        """
        The instance capacity that you committed to when you requested the future-dated Capacity Reservation.
        """
        return pulumi.get(self, "committed_instance_count")


@pulumi.output_type
class CpuOptionsProperties(dict):
    """
    The CPU options for the instance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coreCount":
            suggest = "core_count"
        elif key == "threadsPerCore":
            suggest = "threads_per_core"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CpuOptionsProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CpuOptionsProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CpuOptionsProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 core_count: Optional[_builtins.int] = None,
                 threads_per_core: Optional[_builtins.int] = None):
        """
        The CPU options for the instance.
        :param _builtins.int core_count: The number of CPU cores for the instance.
        :param _builtins.int threads_per_core: The number of threads per CPU core.
        """
        if core_count is not None:
            pulumi.set(__self__, "core_count", core_count)
        if threads_per_core is not None:
            pulumi.set(__self__, "threads_per_core", threads_per_core)

    @_builtins.property
    @pulumi.getter(name="coreCount")
    def core_count(self) -> Optional[_builtins.int]:
        """
        The number of CPU cores for the instance.
        """
        return pulumi.get(self, "core_count")

    @_builtins.property
    @pulumi.getter(name="threadsPerCore")
    def threads_per_core(self) -> Optional[_builtins.int]:
        """
        The number of threads per CPU core.
        """
        return pulumi.get(self, "threads_per_core")


@pulumi.output_type
class CreditSpecificationProperties(dict):
    """
    The credit option for CPU usage of the burstable performance instance. Valid values are standard and unlimited.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuCredits":
            suggest = "cpu_credits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CreditSpecificationProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CreditSpecificationProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CreditSpecificationProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_credits: Optional[_builtins.str] = None):
        """
        The credit option for CPU usage of the burstable performance instance. Valid values are standard and unlimited.
        :param _builtins.str cpu_credits: The credit option for CPU usage of the instance.
               
               Valid values: `standard` | `unlimited`
               
               T3 instances with `host` tenancy do not support the `unlimited` CPU credit option.
        """
        if cpu_credits is not None:
            pulumi.set(__self__, "cpu_credits", cpu_credits)

    @_builtins.property
    @pulumi.getter(name="cpuCredits")
    def cpu_credits(self) -> Optional[_builtins.str]:
        """
        The credit option for CPU usage of the instance.

        Valid values: `standard` | `unlimited`

        T3 instances with `host` tenancy do not support the `unlimited` CPU credit option.
        """
        return pulumi.get(self, "cpu_credits")


@pulumi.output_type
class DestinationOptionsProperties(dict):
    """
    The destination options.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileFormat":
            suggest = "file_format"
        elif key == "hiveCompatiblePartitions":
            suggest = "hive_compatible_partitions"
        elif key == "perHourPartition":
            suggest = "per_hour_partition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationOptionsProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationOptionsProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationOptionsProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_format: 'FlowLogDestinationOptionsPropertiesFileFormat',
                 hive_compatible_partitions: _builtins.bool,
                 per_hour_partition: _builtins.bool):
        """
        The destination options.
        :param 'FlowLogDestinationOptionsPropertiesFileFormat' file_format: The format for the flow log. The default is `plain-text` .
        :param _builtins.bool hive_compatible_partitions: Indicates whether to use Hive-compatible prefixes for flow logs stored in Amazon S3. The default is `false` .
        :param _builtins.bool per_hour_partition: Indicates whether to partition the flow log per hour. This reduces the cost and response time for queries. The default is `false` .
        """
        pulumi.set(__self__, "file_format", file_format)
        pulumi.set(__self__, "hive_compatible_partitions", hive_compatible_partitions)
        pulumi.set(__self__, "per_hour_partition", per_hour_partition)

    @_builtins.property
    @pulumi.getter(name="fileFormat")
    def file_format(self) -> 'FlowLogDestinationOptionsPropertiesFileFormat':
        """
        The format for the flow log. The default is `plain-text` .
        """
        return pulumi.get(self, "file_format")

    @_builtins.property
    @pulumi.getter(name="hiveCompatiblePartitions")
    def hive_compatible_partitions(self) -> _builtins.bool:
        """
        Indicates whether to use Hive-compatible prefixes for flow logs stored in Amazon S3. The default is `false` .
        """
        return pulumi.get(self, "hive_compatible_partitions")

    @_builtins.property
    @pulumi.getter(name="perHourPartition")
    def per_hour_partition(self) -> _builtins.bool:
        """
        Indicates whether to partition the flow log per hour. This reduces the cost and response time for queries. The default is `false` .
        """
        return pulumi.get(self, "per_hour_partition")


@pulumi.output_type
class Ec2FleetAcceleratorCountRequest(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        """
        :param _builtins.int max: The maximum number of accelerators. To specify no maximum limit, omit this parameter. To exclude accelerator-enabled instance types, set `Max` to `0` .
        :param _builtins.int min: The minimum number of accelerators. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        """
        The maximum number of accelerators. To specify no maximum limit, omit this parameter. To exclude accelerator-enabled instance types, set `Max` to `0` .
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        """
        The minimum number of accelerators. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class Ec2FleetAcceleratorTotalMemoryMiBRequest(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        """
        :param _builtins.int max: The maximum amount of accelerator memory, in MiB. To specify no maximum limit, omit this parameter.
        :param _builtins.int min: The minimum amount of accelerator memory, in MiB. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        """
        The maximum amount of accelerator memory, in MiB. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        """
        The minimum amount of accelerator memory, in MiB. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class Ec2FleetBaselineEbsBandwidthMbpsRequest(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        """
        :param _builtins.int max: The maximum baseline bandwidth, in Mbps. To specify no maximum limit, omit this parameter.
        :param _builtins.int min: The minimum baseline bandwidth, in Mbps. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        """
        The maximum baseline bandwidth, in Mbps. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        """
        The minimum baseline bandwidth, in Mbps. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class Ec2FleetBaselinePerformanceFactorsRequest(dict):
    def __init__(__self__, *,
                 cpu: Optional['outputs.Ec2FleetCpuPerformanceFactorRequest'] = None):
        """
        :param 'Ec2FleetCpuPerformanceFactorRequest' cpu: The CPU performance to consider, using an instance family as the baseline reference.
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional['outputs.Ec2FleetCpuPerformanceFactorRequest']:
        """
        The CPU performance to consider, using an instance family as the baseline reference.
        """
        return pulumi.get(self, "cpu")


@pulumi.output_type
class Ec2FleetBlockDeviceMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "noDevice":
            suggest = "no_device"
        elif key == "virtualName":
            suggest = "virtual_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2FleetBlockDeviceMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2FleetBlockDeviceMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2FleetBlockDeviceMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: Optional[_builtins.str] = None,
                 ebs: Optional['outputs.Ec2FleetEbsBlockDevice'] = None,
                 no_device: Optional[_builtins.str] = None,
                 virtual_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str device_name: The device name. For available device names, see [Device names for volumes](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/device_naming.html) .
        :param 'Ec2FleetEbsBlockDevice' ebs: Parameters used to automatically set up EBS volumes when the instance is launched.
        :param _builtins.str no_device: To omit the device from the block device mapping, specify an empty string. When this property is specified, the device is removed from the block device mapping regardless of the assigned value.
        :param _builtins.str virtual_name: The virtual device name ( `ephemeral` N). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for `ephemeral0` and `ephemeral1` . The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.
               
               NVMe instance store volumes are automatically enumerated and assigned a device name. Including them in your block device mapping has no effect.
               
               Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.
        """
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if ebs is not None:
            pulumi.set(__self__, "ebs", ebs)
        if no_device is not None:
            pulumi.set(__self__, "no_device", no_device)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[_builtins.str]:
        """
        The device name. For available device names, see [Device names for volumes](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/device_naming.html) .
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter
    def ebs(self) -> Optional['outputs.Ec2FleetEbsBlockDevice']:
        """
        Parameters used to automatically set up EBS volumes when the instance is launched.
        """
        return pulumi.get(self, "ebs")

    @_builtins.property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[_builtins.str]:
        """
        To omit the device from the block device mapping, specify an empty string. When this property is specified, the device is removed from the block device mapping regardless of the assigned value.
        """
        return pulumi.get(self, "no_device")

    @_builtins.property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[_builtins.str]:
        """
        The virtual device name ( `ephemeral` N). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for `ephemeral0` and `ephemeral1` . The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.

        NVMe instance store volumes are automatically enumerated and assigned a device name. Including them in your block device mapping has no effect.

        Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.
        """
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class Ec2FleetCapacityRebalance(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replacementStrategy":
            suggest = "replacement_strategy"
        elif key == "terminationDelay":
            suggest = "termination_delay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2FleetCapacityRebalance. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2FleetCapacityRebalance.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2FleetCapacityRebalance.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 replacement_strategy: Optional['Ec2FleetCapacityRebalanceReplacementStrategy'] = None,
                 termination_delay: Optional[_builtins.int] = None):
        """
        :param 'Ec2FleetCapacityRebalanceReplacementStrategy' replacement_strategy: The replacement strategy to use. Only available for fleets of type `maintain` .
               
               `launch` - EC2 Fleet launches a replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet. EC2 Fleet does not terminate the instances that receive a rebalance notification. You can terminate the old instances, or you can leave them running. You are charged for all instances while they are running.
               
               `launch-before-terminate` - EC2 Fleet launches a replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet, and then, after a delay that you specify (in `TerminationDelay` ), terminates the instances that received a rebalance notification.
        :param _builtins.int termination_delay: The amount of time (in seconds) that Amazon EC2 waits before terminating the old Spot Instance after launching a new replacement Spot Instance.
               
               Required when `ReplacementStrategy` is set to `launch-before-terminate` .
               
               Not valid when `ReplacementStrategy` is set to `launch` .
               
               Valid values: Minimum value of `120` seconds. Maximum value of `7200` seconds.
        """
        if replacement_strategy is not None:
            pulumi.set(__self__, "replacement_strategy", replacement_strategy)
        if termination_delay is not None:
            pulumi.set(__self__, "termination_delay", termination_delay)

    @_builtins.property
    @pulumi.getter(name="replacementStrategy")
    def replacement_strategy(self) -> Optional['Ec2FleetCapacityRebalanceReplacementStrategy']:
        """
        The replacement strategy to use. Only available for fleets of type `maintain` .

        `launch` - EC2 Fleet launches a replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet. EC2 Fleet does not terminate the instances that receive a rebalance notification. You can terminate the old instances, or you can leave them running. You are charged for all instances while they are running.

        `launch-before-terminate` - EC2 Fleet launches a replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet, and then, after a delay that you specify (in `TerminationDelay` ), terminates the instances that received a rebalance notification.
        """
        return pulumi.get(self, "replacement_strategy")

    @_builtins.property
    @pulumi.getter(name="terminationDelay")
    def termination_delay(self) -> Optional[_builtins.int]:
        """
        The amount of time (in seconds) that Amazon EC2 waits before terminating the old Spot Instance after launching a new replacement Spot Instance.

        Required when `ReplacementStrategy` is set to `launch-before-terminate` .

        Not valid when `ReplacementStrategy` is set to `launch` .

        Valid values: Minimum value of `120` seconds. Maximum value of `7200` seconds.
        """
        return pulumi.get(self, "termination_delay")


@pulumi.output_type
class Ec2FleetCapacityReservationOptionsRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "usageStrategy":
            suggest = "usage_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2FleetCapacityReservationOptionsRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2FleetCapacityReservationOptionsRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2FleetCapacityReservationOptionsRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 usage_strategy: Optional['Ec2FleetCapacityReservationOptionsRequestUsageStrategy'] = None):
        """
        :param 'Ec2FleetCapacityReservationOptionsRequestUsageStrategy' usage_strategy: Indicates whether to use unused Capacity Reservations for fulfilling On-Demand capacity.
               
               If you specify `use-capacity-reservations-first` , the fleet uses unused Capacity Reservations to fulfill On-Demand capacity up to the target On-Demand capacity. If multiple instance pools have unused Capacity Reservations, the On-Demand allocation strategy ( `lowest-price` or `prioritized` ) is applied. If the number of unused Capacity Reservations is less than the On-Demand target capacity, the remaining On-Demand target capacity is launched according to the On-Demand allocation strategy ( `lowest-price` or `prioritized` ).
               
               If you do not specify a value, the fleet fulfils the On-Demand capacity according to the chosen On-Demand allocation strategy.
        """
        if usage_strategy is not None:
            pulumi.set(__self__, "usage_strategy", usage_strategy)

    @_builtins.property
    @pulumi.getter(name="usageStrategy")
    def usage_strategy(self) -> Optional['Ec2FleetCapacityReservationOptionsRequestUsageStrategy']:
        """
        Indicates whether to use unused Capacity Reservations for fulfilling On-Demand capacity.

        If you specify `use-capacity-reservations-first` , the fleet uses unused Capacity Reservations to fulfill On-Demand capacity up to the target On-Demand capacity. If multiple instance pools have unused Capacity Reservations, the On-Demand allocation strategy ( `lowest-price` or `prioritized` ) is applied. If the number of unused Capacity Reservations is less than the On-Demand target capacity, the remaining On-Demand target capacity is launched according to the On-Demand allocation strategy ( `lowest-price` or `prioritized` ).

        If you do not specify a value, the fleet fulfils the On-Demand capacity according to the chosen On-Demand allocation strategy.
        """
        return pulumi.get(self, "usage_strategy")


@pulumi.output_type
class Ec2FleetCpuPerformanceFactorRequest(dict):
    def __init__(__self__, *,
                 references: Optional[Sequence['outputs.Ec2FleetPerformanceFactorReferenceRequest']] = None):
        """
        :param Sequence['Ec2FleetPerformanceFactorReferenceRequest'] references: Specify an instance family to use as the baseline reference for CPU performance. All instance types that match your specified attributes will be compared against the CPU performance of the referenced instance family, regardless of CPU manufacturer or architecture differences.
               
               > Currently, only one instance family can be specified in the list.
        """
        if references is not None:
            pulumi.set(__self__, "references", references)

    @_builtins.property
    @pulumi.getter
    def references(self) -> Optional[Sequence['outputs.Ec2FleetPerformanceFactorReferenceRequest']]:
        """
        Specify an instance family to use as the baseline reference for CPU performance. All instance types that match your specified attributes will be compared against the CPU performance of the referenced instance family, regardless of CPU manufacturer or architecture differences.

        > Currently, only one instance family can be specified in the list.
        """
        return pulumi.get(self, "references")


@pulumi.output_type
class Ec2FleetEbsBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2FleetEbsBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2FleetEbsBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2FleetEbsBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_on_termination: Optional[_builtins.bool] = None,
                 encrypted: Optional[_builtins.bool] = None,
                 iops: Optional[_builtins.int] = None,
                 kms_key_id: Optional[_builtins.str] = None,
                 snapshot_id: Optional[_builtins.str] = None,
                 volume_size: Optional[_builtins.int] = None,
                 volume_type: Optional['Ec2FleetEbsBlockDeviceVolumeType'] = None):
        """
        :param _builtins.bool delete_on_termination: Indicates whether the EBS volume is deleted on instance termination. For more information, see [Preserving Amazon EBS volumes on instance termination](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination) in the *Amazon EC2 User Guide* .
        :param _builtins.bool encrypted: Indicates whether the encryption state of an EBS volume is changed while being restored from a backing snapshot. The effect of setting the encryption state to `true` depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see [Amazon EBS encryption](https://docs.aws.amazon.com/ebs/latest/userguide/ebs-encryption.html#encryption-parameters) in the *Amazon EBS User Guide* .
               
               In no case can you remove encryption from an encrypted volume.
               
               Encrypted volumes can only be attached to instances that support Amazon EBS encryption. For more information, see [Supported instance types](https://docs.aws.amazon.com/ebs/latest/userguide/ebs-encryption-requirements.html#ebs-encryption_supported_instances) .
               
               - If you are creating a block device mapping for a *new (empty) volume* , you can include this parameter, and specify either `true` for an encrypted volume, or `false` for an unencrypted volume. If you omit this parameter, it defaults to `false` (unencrypted).
               - If you are creating a block device mapping from an *existing encrypted or unencrypted snapshot* , you must omit this parameter. If you include this parameter, the request will fail, regardless of the value that you specify.
               - If you are creating a block device mapping from an *existing unencrypted volume* , you can include this parameter, but you must specify `false` . If you specify `true` , the request will fail. In this case, we recommend that you omit the parameter.
               - If you are creating a block device mapping from an *existing encrypted volume* , you can include this parameter, and specify either `true` or `false` . However, if you specify `false` , the parameter is ignored and the block device mapping is always encrypted. In this case, we recommend that you omit the parameter.
        :param _builtins.int iops: The number of I/O operations per second (IOPS). For `gp3` , `io1` , and `io2` volumes, this represents the number of IOPS that are provisioned for the volume. For `gp2` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.
               
               The following are the supported values for each volume type:
               
               - `gp3` : 3,000 - 80,000 IOPS
               - `io1` : 100 - 64,000 IOPS
               - `io2` : 100 - 256,000 IOPS
               
               For `io2` volumes, you can achieve up to 256,000 IOPS on [instances built on the Nitro System](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances) . On other instances, you can achieve performance up to 32,000 IOPS.
               
               This parameter is required for `io1` and `io2` volumes. The default for `gp3` volumes is 3,000 IOPS.
        :param _builtins.str kms_key_id: Identifier (key ID, key alias, key ARN, or alias ARN) of the customer managed KMS key to use for EBS encryption.
               
               This parameter is only supported on `BlockDeviceMapping` objects called by [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) , [RequestSpotFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotFleet.html) , and [RequestSpotInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotInstances.html) .
        :param _builtins.str snapshot_id: The ID of the snapshot.
        :param _builtins.int volume_size: The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size.
               
               The following are the supported sizes for each volume type:
               
               - `gp2` : 1 - 16,384 GiB
               - `gp3` : 1 - 65,536 GiB
               - `io1` : 4 - 16,384 GiB
               - `io2` : 4 - 65,536 GiB
               - `st1` and `sc1` : 125 - 16,384 GiB
               - `standard` : 1 - 1024 GiB
        :param 'Ec2FleetEbsBlockDeviceVolumeType' volume_type: The volume type. For more information, see [Amazon EBS volume types](https://docs.aws.amazon.com/ebs/latest/userguide/ebs-volume-types.html) in the *Amazon EBS User Guide* .
        """
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the EBS volume is deleted on instance termination. For more information, see [Preserving Amazon EBS volumes on instance termination](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the encryption state of an EBS volume is changed while being restored from a backing snapshot. The effect of setting the encryption state to `true` depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see [Amazon EBS encryption](https://docs.aws.amazon.com/ebs/latest/userguide/ebs-encryption.html#encryption-parameters) in the *Amazon EBS User Guide* .

        In no case can you remove encryption from an encrypted volume.

        Encrypted volumes can only be attached to instances that support Amazon EBS encryption. For more information, see [Supported instance types](https://docs.aws.amazon.com/ebs/latest/userguide/ebs-encryption-requirements.html#ebs-encryption_supported_instances) .

        - If you are creating a block device mapping for a *new (empty) volume* , you can include this parameter, and specify either `true` for an encrypted volume, or `false` for an unencrypted volume. If you omit this parameter, it defaults to `false` (unencrypted).
        - If you are creating a block device mapping from an *existing encrypted or unencrypted snapshot* , you must omit this parameter. If you include this parameter, the request will fail, regardless of the value that you specify.
        - If you are creating a block device mapping from an *existing unencrypted volume* , you can include this parameter, but you must specify `false` . If you specify `true` , the request will fail. In this case, we recommend that you omit the parameter.
        - If you are creating a block device mapping from an *existing encrypted volume* , you can include this parameter, and specify either `true` or `false` . However, if you specify `false` , the parameter is ignored and the block device mapping is always encrypted. In this case, we recommend that you omit the parameter.
        """
        return pulumi.get(self, "encrypted")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        """
        The number of I/O operations per second (IOPS). For `gp3` , `io1` , and `io2` volumes, this represents the number of IOPS that are provisioned for the volume. For `gp2` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.

        The following are the supported values for each volume type:

        - `gp3` : 3,000 - 80,000 IOPS
        - `io1` : 100 - 64,000 IOPS
        - `io2` : 100 - 256,000 IOPS

        For `io2` volumes, you can achieve up to 256,000 IOPS on [instances built on the Nitro System](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances) . On other instances, you can achieve performance up to 32,000 IOPS.

        This parameter is required for `io1` and `io2` volumes. The default for `gp3` volumes is 3,000 IOPS.
        """
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        """
        Identifier (key ID, key alias, key ARN, or alias ARN) of the customer managed KMS key to use for EBS encryption.

        This parameter is only supported on `BlockDeviceMapping` objects called by [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) , [RequestSpotFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotFleet.html) , and [RequestSpotInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotInstances.html) .
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[_builtins.str]:
        """
        The ID of the snapshot.
        """
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[_builtins.int]:
        """
        The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size.

        The following are the supported sizes for each volume type:

        - `gp2` : 1 - 16,384 GiB
        - `gp3` : 1 - 65,536 GiB
        - `io1` : 4 - 16,384 GiB
        - `io2` : 4 - 65,536 GiB
        - `st1` and `sc1` : 125 - 16,384 GiB
        - `standard` : 1 - 1024 GiB
        """
        return pulumi.get(self, "volume_size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional['Ec2FleetEbsBlockDeviceVolumeType']:
        """
        The volume type. For more information, see [Amazon EBS volume types](https://docs.aws.amazon.com/ebs/latest/userguide/ebs-volume-types.html) in the *Amazon EBS User Guide* .
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class Ec2FleetFleetLaunchTemplateConfigRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTemplateSpecification":
            suggest = "launch_template_specification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2FleetFleetLaunchTemplateConfigRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2FleetFleetLaunchTemplateConfigRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2FleetFleetLaunchTemplateConfigRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 launch_template_specification: Optional['outputs.Ec2FleetFleetLaunchTemplateSpecificationRequest'] = None,
                 overrides: Optional[Sequence['outputs.Ec2FleetFleetLaunchTemplateOverridesRequest']] = None):
        """
        :param 'Ec2FleetFleetLaunchTemplateSpecificationRequest' launch_template_specification: The launch template to use. You must specify either the launch template ID or launch template name in the request.
        :param Sequence['Ec2FleetFleetLaunchTemplateOverridesRequest'] overrides: Any parameters that you specify override the same parameters in the launch template.
               
               For fleets of type `request` and `maintain` , a maximum of 300 items is allowed across all launch templates.
        """
        if launch_template_specification is not None:
            pulumi.set(__self__, "launch_template_specification", launch_template_specification)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)

    @_builtins.property
    @pulumi.getter(name="launchTemplateSpecification")
    def launch_template_specification(self) -> Optional['outputs.Ec2FleetFleetLaunchTemplateSpecificationRequest']:
        """
        The launch template to use. You must specify either the launch template ID or launch template name in the request.
        """
        return pulumi.get(self, "launch_template_specification")

    @_builtins.property
    @pulumi.getter
    def overrides(self) -> Optional[Sequence['outputs.Ec2FleetFleetLaunchTemplateOverridesRequest']]:
        """
        Any parameters that you specify override the same parameters in the launch template.

        For fleets of type `request` and `maintain` , a maximum of 300 items is allowed across all launch templates.
        """
        return pulumi.get(self, "overrides")


@pulumi.output_type
class Ec2FleetFleetLaunchTemplateOverridesRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "blockDeviceMappings":
            suggest = "block_device_mappings"
        elif key == "instanceRequirements":
            suggest = "instance_requirements"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "maxPrice":
            suggest = "max_price"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "weightedCapacity":
            suggest = "weighted_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2FleetFleetLaunchTemplateOverridesRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2FleetFleetLaunchTemplateOverridesRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2FleetFleetLaunchTemplateOverridesRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone: Optional[_builtins.str] = None,
                 block_device_mappings: Optional[Sequence['outputs.Ec2FleetBlockDeviceMapping']] = None,
                 instance_requirements: Optional['outputs.Ec2FleetInstanceRequirementsRequest'] = None,
                 instance_type: Optional[_builtins.str] = None,
                 max_price: Optional[_builtins.str] = None,
                 placement: Optional['outputs.Ec2FleetPlacement'] = None,
                 priority: Optional[_builtins.float] = None,
                 subnet_id: Optional[_builtins.str] = None,
                 weighted_capacity: Optional[_builtins.float] = None):
        """
        :param _builtins.str availability_zone: The Availability Zone in which to launch the instances.
        :param Sequence['Ec2FleetBlockDeviceMapping'] block_device_mappings: The block device mappings, which define the EBS volumes and instance store volumes to attach to the instance at launch.
               
               Supported only for fleets of type `instant` .
               
               For more information, see [Block device mappings for volumes on Amazon EC2 instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/block-device-mapping-concepts.html) in the *Amazon EC2 User Guide* .
        :param 'Ec2FleetInstanceRequirementsRequest' instance_requirements: The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with those attributes.
               
               > If you specify `InstanceRequirements` , you can't specify `InstanceType` .
        :param _builtins.str instance_type: The instance type.
               
               `mac1.metal` is not supported as a launch template override.
               
               > If you specify `InstanceType` , you can't specify `InstanceRequirements` .
        :param _builtins.str max_price: The maximum price per unit hour that you are willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.
               
               > If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.
               > 
               > If you specify a maximum price, it must be more than USD $0.001. Specifying a value below USD $0.001 will result in an `InvalidParameterValue` error message.
        :param 'Ec2FleetPlacement' placement: The location where the instance launched, if applicable.
        :param _builtins.float priority: The priority for the launch template override. The highest priority is launched first.
               
               If the On-Demand `AllocationStrategy` is set to `prioritized` , EC2 Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity.
               
               If the Spot `AllocationStrategy` is set to `capacity-optimized-prioritized` , EC2 Fleet uses priority on a best-effort basis to determine which launch template override to use in fulfilling Spot capacity, but optimizes for capacity first.
               
               Valid values are whole numbers starting at `0` . The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority. You can set the same priority for different launch template overrides.
        :param _builtins.str subnet_id: The IDs of the subnets in which to launch the instances. Separate multiple subnet IDs using commas (for example, `subnet-1234abcdeexample1, subnet-0987cdef6example2` ). A request of type `instant` can have only one subnet ID.
        :param _builtins.float weighted_capacity: The number of units provided by the specified instance type. These are the same units that you chose to set the target capacity in terms of instances, or a performance characteristic such as vCPUs, memory, or I/O.
               
               If the target capacity divided by this value is not a whole number, Amazon EC2 rounds the number of instances to the next whole number. If this value is not specified, the default is 1.
               
               > When specifying weights, the price used in the `lowest-price` and `price-capacity-optimized` allocation strategies is per *unit* hour (where the instance price is divided by the specified weight). However, if all the specified weights are above the requested `TargetCapacity` , resulting in only 1 instance being launched, the price used is per *instance* hour.
        """
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if block_device_mappings is not None:
            pulumi.set(__self__, "block_device_mappings", block_device_mappings)
        if instance_requirements is not None:
            pulumi.set(__self__, "instance_requirements", instance_requirements)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if max_price is not None:
            pulumi.set(__self__, "max_price", max_price)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if weighted_capacity is not None:
            pulumi.set(__self__, "weighted_capacity", weighted_capacity)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[_builtins.str]:
        """
        The Availability Zone in which to launch the instances.
        """
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter(name="blockDeviceMappings")
    def block_device_mappings(self) -> Optional[Sequence['outputs.Ec2FleetBlockDeviceMapping']]:
        """
        The block device mappings, which define the EBS volumes and instance store volumes to attach to the instance at launch.

        Supported only for fleets of type `instant` .

        For more information, see [Block device mappings for volumes on Amazon EC2 instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/block-device-mapping-concepts.html) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "block_device_mappings")

    @_builtins.property
    @pulumi.getter(name="instanceRequirements")
    def instance_requirements(self) -> Optional['outputs.Ec2FleetInstanceRequirementsRequest']:
        """
        The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with those attributes.

        > If you specify `InstanceRequirements` , you can't specify `InstanceType` .
        """
        return pulumi.get(self, "instance_requirements")

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[_builtins.str]:
        """
        The instance type.

        `mac1.metal` is not supported as a launch template override.

        > If you specify `InstanceType` , you can't specify `InstanceRequirements` .
        """
        return pulumi.get(self, "instance_type")

    @_builtins.property
    @pulumi.getter(name="maxPrice")
    def max_price(self) -> Optional[_builtins.str]:
        """
        The maximum price per unit hour that you are willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.

        > If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.
        > 
        > If you specify a maximum price, it must be more than USD $0.001. Specifying a value below USD $0.001 will result in an `InvalidParameterValue` error message.
        """
        return pulumi.get(self, "max_price")

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional['outputs.Ec2FleetPlacement']:
        """
        The location where the instance launched, if applicable.
        """
        return pulumi.get(self, "placement")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.float]:
        """
        The priority for the launch template override. The highest priority is launched first.

        If the On-Demand `AllocationStrategy` is set to `prioritized` , EC2 Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity.

        If the Spot `AllocationStrategy` is set to `capacity-optimized-prioritized` , EC2 Fleet uses priority on a best-effort basis to determine which launch template override to use in fulfilling Spot capacity, but optimizes for capacity first.

        Valid values are whole numbers starting at `0` . The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority. You can set the same priority for different launch template overrides.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        The IDs of the subnets in which to launch the instances. Separate multiple subnet IDs using commas (for example, `subnet-1234abcdeexample1, subnet-0987cdef6example2` ). A request of type `instant` can have only one subnet ID.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="weightedCapacity")
    def weighted_capacity(self) -> Optional[_builtins.float]:
        """
        The number of units provided by the specified instance type. These are the same units that you chose to set the target capacity in terms of instances, or a performance characteristic such as vCPUs, memory, or I/O.

        If the target capacity divided by this value is not a whole number, Amazon EC2 rounds the number of instances to the next whole number. If this value is not specified, the default is 1.

        > When specifying weights, the price used in the `lowest-price` and `price-capacity-optimized` allocation strategies is per *unit* hour (where the instance price is divided by the specified weight). However, if all the specified weights are above the requested `TargetCapacity` , resulting in only 1 instance being launched, the price used is per *instance* hour.
        """
        return pulumi.get(self, "weighted_capacity")


@pulumi.output_type
class Ec2FleetFleetLaunchTemplateSpecificationRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTemplateId":
            suggest = "launch_template_id"
        elif key == "launchTemplateName":
            suggest = "launch_template_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2FleetFleetLaunchTemplateSpecificationRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2FleetFleetLaunchTemplateSpecificationRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2FleetFleetLaunchTemplateSpecificationRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 version: _builtins.str,
                 launch_template_id: Optional[_builtins.str] = None,
                 launch_template_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str version: The launch template version number, `$Latest` , or `$Default` . You must specify a value, otherwise the request fails.
               
               If the value is `$Latest` , Amazon EC2 uses the latest version of the launch template.
               
               If the value is `$Default` , Amazon EC2 uses the default version of the launch template.
        :param _builtins.str launch_template_id: The ID of the launch template.
               
               You must specify the `LaunchTemplateId` or the `LaunchTemplateName` , but not both.
        :param _builtins.str launch_template_name: The name of the launch template.
               
               You must specify the `LaunchTemplateName` or the `LaunchTemplateId` , but not both.
        """
        pulumi.set(__self__, "version", version)
        if launch_template_id is not None:
            pulumi.set(__self__, "launch_template_id", launch_template_id)
        if launch_template_name is not None:
            pulumi.set(__self__, "launch_template_name", launch_template_name)

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The launch template version number, `$Latest` , or `$Default` . You must specify a value, otherwise the request fails.

        If the value is `$Latest` , Amazon EC2 uses the latest version of the launch template.

        If the value is `$Default` , Amazon EC2 uses the default version of the launch template.
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter(name="launchTemplateId")
    def launch_template_id(self) -> Optional[_builtins.str]:
        """
        The ID of the launch template.

        You must specify the `LaunchTemplateId` or the `LaunchTemplateName` , but not both.
        """
        return pulumi.get(self, "launch_template_id")

    @_builtins.property
    @pulumi.getter(name="launchTemplateName")
    def launch_template_name(self) -> Optional[_builtins.str]:
        """
        The name of the launch template.

        You must specify the `LaunchTemplateName` or the `LaunchTemplateId` , but not both.
        """
        return pulumi.get(self, "launch_template_name")


@pulumi.output_type
class Ec2FleetInstanceRequirementsRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceleratorCount":
            suggest = "accelerator_count"
        elif key == "acceleratorManufacturers":
            suggest = "accelerator_manufacturers"
        elif key == "acceleratorNames":
            suggest = "accelerator_names"
        elif key == "acceleratorTotalMemoryMiB":
            suggest = "accelerator_total_memory_mi_b"
        elif key == "acceleratorTypes":
            suggest = "accelerator_types"
        elif key == "allowedInstanceTypes":
            suggest = "allowed_instance_types"
        elif key == "bareMetal":
            suggest = "bare_metal"
        elif key == "baselineEbsBandwidthMbps":
            suggest = "baseline_ebs_bandwidth_mbps"
        elif key == "baselinePerformanceFactors":
            suggest = "baseline_performance_factors"
        elif key == "burstablePerformance":
            suggest = "burstable_performance"
        elif key == "cpuManufacturers":
            suggest = "cpu_manufacturers"
        elif key == "excludedInstanceTypes":
            suggest = "excluded_instance_types"
        elif key == "instanceGenerations":
            suggest = "instance_generations"
        elif key == "localStorage":
            suggest = "local_storage"
        elif key == "localStorageTypes":
            suggest = "local_storage_types"
        elif key == "maxSpotPriceAsPercentageOfOptimalOnDemandPrice":
            suggest = "max_spot_price_as_percentage_of_optimal_on_demand_price"
        elif key == "memoryGiBPerVCpu":
            suggest = "memory_gi_b_per_v_cpu"
        elif key == "memoryMiB":
            suggest = "memory_mi_b"
        elif key == "networkBandwidthGbps":
            suggest = "network_bandwidth_gbps"
        elif key == "networkInterfaceCount":
            suggest = "network_interface_count"
        elif key == "onDemandMaxPricePercentageOverLowestPrice":
            suggest = "on_demand_max_price_percentage_over_lowest_price"
        elif key == "requireHibernateSupport":
            suggest = "require_hibernate_support"
        elif key == "spotMaxPricePercentageOverLowestPrice":
            suggest = "spot_max_price_percentage_over_lowest_price"
        elif key == "totalLocalStorageGb":
            suggest = "total_local_storage_gb"
        elif key == "vCpuCount":
            suggest = "v_cpu_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2FleetInstanceRequirementsRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2FleetInstanceRequirementsRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2FleetInstanceRequirementsRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accelerator_count: Optional['outputs.Ec2FleetAcceleratorCountRequest'] = None,
                 accelerator_manufacturers: Optional[Sequence['Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem']] = None,
                 accelerator_names: Optional[Sequence['Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem']] = None,
                 accelerator_total_memory_mi_b: Optional['outputs.Ec2FleetAcceleratorTotalMemoryMiBRequest'] = None,
                 accelerator_types: Optional[Sequence['Ec2FleetInstanceRequirementsRequestAcceleratorTypesItem']] = None,
                 allowed_instance_types: Optional[Sequence[_builtins.str]] = None,
                 bare_metal: Optional['Ec2FleetInstanceRequirementsRequestBareMetal'] = None,
                 baseline_ebs_bandwidth_mbps: Optional['outputs.Ec2FleetBaselineEbsBandwidthMbpsRequest'] = None,
                 baseline_performance_factors: Optional['outputs.Ec2FleetBaselinePerformanceFactorsRequest'] = None,
                 burstable_performance: Optional['Ec2FleetInstanceRequirementsRequestBurstablePerformance'] = None,
                 cpu_manufacturers: Optional[Sequence['Ec2FleetInstanceRequirementsRequestCpuManufacturersItem']] = None,
                 excluded_instance_types: Optional[Sequence[_builtins.str]] = None,
                 instance_generations: Optional[Sequence['Ec2FleetInstanceRequirementsRequestInstanceGenerationsItem']] = None,
                 local_storage: Optional['Ec2FleetInstanceRequirementsRequestLocalStorage'] = None,
                 local_storage_types: Optional[Sequence['Ec2FleetInstanceRequirementsRequestLocalStorageTypesItem']] = None,
                 max_spot_price_as_percentage_of_optimal_on_demand_price: Optional[_builtins.int] = None,
                 memory_gi_b_per_v_cpu: Optional['outputs.Ec2FleetMemoryGiBPerVCpuRequest'] = None,
                 memory_mi_b: Optional['outputs.Ec2FleetMemoryMiBRequest'] = None,
                 network_bandwidth_gbps: Optional['outputs.Ec2FleetNetworkBandwidthGbpsRequest'] = None,
                 network_interface_count: Optional['outputs.Ec2FleetNetworkInterfaceCountRequest'] = None,
                 on_demand_max_price_percentage_over_lowest_price: Optional[_builtins.int] = None,
                 require_hibernate_support: Optional[_builtins.bool] = None,
                 spot_max_price_percentage_over_lowest_price: Optional[_builtins.int] = None,
                 total_local_storage_gb: Optional['outputs.Ec2FleetTotalLocalStorageGbRequest'] = None,
                 v_cpu_count: Optional['outputs.Ec2FleetVCpuCountRangeRequest'] = None):
        """
        :param 'Ec2FleetAcceleratorCountRequest' accelerator_count: The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.
               
               To exclude accelerator-enabled instance types, set `Max` to `0` .
               
               Default: No minimum or maximum limits
        :param Sequence['Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem'] accelerator_manufacturers: Indicates whether instance types must have accelerators by specific manufacturers.
               
               - For instance types with AWS devices, specify `amazon-web-services` .
               - For instance types with AMD devices, specify `amd` .
               - For instance types with Habana devices, specify `habana` .
               - For instance types with NVIDIA devices, specify `nvidia` .
               - For instance types with Xilinx devices, specify `xilinx` .
               
               Default: Any manufacturer
        :param Sequence['Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem'] accelerator_names: The accelerators that must be on the instance type.
               
               - For instance types with NVIDIA A10G GPUs, specify `a10g` .
               - For instance types with NVIDIA A100 GPUs, specify `a100` .
               - For instance types with NVIDIA H100 GPUs, specify `h100` .
               - For instance types with AWS Inferentia chips, specify `inferentia` .
               - For instance types with NVIDIA GRID K520 GPUs, specify `k520` .
               - For instance types with NVIDIA K80 GPUs, specify `k80` .
               - For instance types with NVIDIA M60 GPUs, specify `m60` .
               - For instance types with AMD Radeon Pro V520 GPUs, specify `radeon-pro-v520` .
               - For instance types with NVIDIA T4 GPUs, specify `t4` .
               - For instance types with NVIDIA T4G GPUs, specify `t4g` .
               - For instance types with Xilinx VU9P FPGAs, specify `vu9p` .
               - For instance types with NVIDIA V100 GPUs, specify `v100` .
               
               Default: Any accelerator
        :param 'Ec2FleetAcceleratorTotalMemoryMiBRequest' accelerator_total_memory_mi_b: The minimum and maximum amount of total accelerator memory, in MiB.
               
               Default: No minimum or maximum limits
        :param Sequence['Ec2FleetInstanceRequirementsRequestAcceleratorTypesItem'] accelerator_types: The accelerator types that must be on the instance type.
               
               - For instance types with FPGA accelerators, specify `fpga` .
               - For instance types with GPU accelerators, specify `gpu` .
               - For instance types with Inference accelerators, specify `inference` .
               
               Default: Any accelerator type
        :param Sequence[_builtins.str] allowed_instance_types: The instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes.
               
               You can use strings with one or more wild cards, represented by an asterisk ( `*` ), to allow an instance type, size, or generation. The following are examples: `m5.8xlarge` , `c5*.*` , `m5a.*` , `r*` , `*3*` .
               
               For example, if you specify `c5*` ,Amazon EC2 will allow the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*` , Amazon EC2 will allow all the M5a instance types, but not the M5n instance types.
               
               > If you specify `AllowedInstanceTypes` , you can't specify `ExcludedInstanceTypes` . 
               
               Default: All instance types
        :param 'Ec2FleetInstanceRequirementsRequestBareMetal' bare_metal: Indicates whether bare metal instance types must be included, excluded, or required.
               
               - To include bare metal instance types, specify `included` .
               - To require only bare metal instance types, specify `required` .
               - To exclude bare metal instance types, specify `excluded` .
               
               Default: `excluded`
        :param 'Ec2FleetBaselineEbsBandwidthMbpsRequest' baseline_ebs_bandwidth_mbps: The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see [Amazon EBSoptimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the *Amazon EC2 User Guide* .
               
               Default: No minimum or maximum limits
        :param 'Ec2FleetBaselinePerformanceFactorsRequest' baseline_performance_factors: The baseline performance to consider, using an instance family as a baseline reference. The instance family establishes the lowest acceptable level of performance. Amazon EC2 uses this baseline to guide instance type selection, but there is no guarantee that the selected instance types will always exceed the baseline for every application. Currently, this parameter only supports CPU performance as a baseline performance factor. For more information, see [Performance protection](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html#ec2fleet-abis-performance-protection) in the *Amazon EC2 User Guide* .
        :param 'Ec2FleetInstanceRequirementsRequestBurstablePerformance' burstable_performance: Indicates whether burstable performance T instance types are included, excluded, or required. For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) .
               
               - To include burstable performance instance types, specify `included` .
               - To require only burstable performance instance types, specify `required` .
               - To exclude burstable performance instance types, specify `excluded` .
               
               Default: `excluded`
        :param Sequence['Ec2FleetInstanceRequirementsRequestCpuManufacturersItem'] cpu_manufacturers: The CPU manufacturers to include.
               
               - For instance types with Intel CPUs, specify `intel` .
               - For instance types with AMD CPUs, specify `amd` .
               - For instance types with AWS CPUs, specify `amazon-web-services` .
               - For instance types with Apple CPUs, specify `apple` .
               
               > Don't confuse the CPU manufacturer with the CPU architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template. 
               
               Default: Any manufacturer
        :param Sequence[_builtins.str] excluded_instance_types: The instance types to exclude.
               
               You can use strings with one or more wild cards, represented by an asterisk ( `*` ), to exclude an instance family, type, size, or generation. The following are examples: `m5.8xlarge` , `c5*.*` , `m5a.*` , `r*` , `*3*` .
               
               For example, if you specify `c5*` ,Amazon EC2 will exclude the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*` , Amazon EC2 will exclude all the M5a instance types, but not the M5n instance types.
               
               > If you specify `ExcludedInstanceTypes` , you can't specify `AllowedInstanceTypes` . 
               
               Default: No excluded instance types
        :param Sequence['Ec2FleetInstanceRequirementsRequestInstanceGenerationsItem'] instance_generations: Indicates whether current or previous generation instance types are included. The current generation instance types are recommended for use. Current generation instance types are typically the latest two to three generations in each instance family. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .
               
               For current generation instance types, specify `current` .
               
               For previous generation instance types, specify `previous` .
               
               Default: Current and previous generation instance types
        :param 'Ec2FleetInstanceRequirementsRequestLocalStorage' local_storage: Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, [Amazon EC2 instance store](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html) in the *Amazon EC2 User Guide* .
               
               - To include instance types with instance store volumes, specify `included` .
               - To require only instance types with instance store volumes, specify `required` .
               - To exclude instance types with instance store volumes, specify `excluded` .
               
               Default: `included`
        :param Sequence['Ec2FleetInstanceRequirementsRequestLocalStorageTypesItem'] local_storage_types: The type of local storage that is required.
               
               - For instance types with hard disk drive (HDD) storage, specify `hdd` .
               - For instance types with solid state drive (SSD) storage, specify `ssd` .
               
               Default: `hdd` and `ssd`
        :param _builtins.int max_spot_price_as_percentage_of_optimal_on_demand_price: [Price protection] The price protection threshold for Spot Instances, as a percentage of an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.
               
               The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
               
               If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is based on the per vCPU or per memory price instead of the per instance price.
               
               > Only one of `SpotMaxPricePercentageOverLowestPrice` or `MaxSpotPriceAsPercentageOfOptimalOnDemandPrice` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as `999999` .
        :param 'Ec2FleetMemoryGiBPerVCpuRequest' memory_gi_b_per_v_cpu: The minimum and maximum amount of memory per vCPU, in GiB.
               
               Default: No minimum or maximum limits
        :param 'Ec2FleetMemoryMiBRequest' memory_mi_b: The minimum and maximum amount of memory, in MiB.
        :param 'Ec2FleetNetworkBandwidthGbpsRequest' network_bandwidth_gbps: The minimum and maximum amount of baseline network bandwidth, in gigabits per second (Gbps). For more information, see [Amazon EC2 instance network bandwidth](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-network-bandwidth.html) in the *Amazon EC2 User Guide* .
               
               Default: No minimum or maximum limits
        :param 'Ec2FleetNetworkInterfaceCountRequest' network_interface_count: The minimum and maximum number of network interfaces.
               
               Default: No minimum or maximum limits
        :param _builtins.int on_demand_max_price_percentage_over_lowest_price: [Price protection] The price protection threshold for On-Demand Instances, as a percentage higher than an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.
               
               The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
               
               To indicate no price protection threshold, specify a high value, such as `999999` .
               
               This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) .
               
               > If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price. 
               
               Default: `20`
        :param _builtins.bool require_hibernate_support: Indicates whether instance types must support hibernation for On-Demand Instances.
               
               This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) .
               
               Default: `false`
        :param _builtins.int spot_max_price_percentage_over_lowest_price: [Price protection] The price protection threshold for Spot Instances, as a percentage higher than an identified Spot price. The identified Spot price is the Spot price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified Spot price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose Spot price exceeds your specified threshold.
               
               The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
               
               If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.
               
               This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) .
               
               > Only one of `SpotMaxPricePercentageOverLowestPrice` or `MaxSpotPriceAsPercentageOfOptimalOnDemandPrice` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as `999999` . 
               
               Default: `100`
        :param 'Ec2FleetTotalLocalStorageGbRequest' total_local_storage_gb: The minimum and maximum amount of total local storage, in GB.
               
               Default: No minimum or maximum limits
        :param 'Ec2FleetVCpuCountRangeRequest' v_cpu_count: The minimum and maximum number of vCPUs.
        """
        if accelerator_count is not None:
            pulumi.set(__self__, "accelerator_count", accelerator_count)
        if accelerator_manufacturers is not None:
            pulumi.set(__self__, "accelerator_manufacturers", accelerator_manufacturers)
        if accelerator_names is not None:
            pulumi.set(__self__, "accelerator_names", accelerator_names)
        if accelerator_total_memory_mi_b is not None:
            pulumi.set(__self__, "accelerator_total_memory_mi_b", accelerator_total_memory_mi_b)
        if accelerator_types is not None:
            pulumi.set(__self__, "accelerator_types", accelerator_types)
        if allowed_instance_types is not None:
            pulumi.set(__self__, "allowed_instance_types", allowed_instance_types)
        if bare_metal is not None:
            pulumi.set(__self__, "bare_metal", bare_metal)
        if baseline_ebs_bandwidth_mbps is not None:
            pulumi.set(__self__, "baseline_ebs_bandwidth_mbps", baseline_ebs_bandwidth_mbps)
        if baseline_performance_factors is not None:
            pulumi.set(__self__, "baseline_performance_factors", baseline_performance_factors)
        if burstable_performance is not None:
            pulumi.set(__self__, "burstable_performance", burstable_performance)
        if cpu_manufacturers is not None:
            pulumi.set(__self__, "cpu_manufacturers", cpu_manufacturers)
        if excluded_instance_types is not None:
            pulumi.set(__self__, "excluded_instance_types", excluded_instance_types)
        if instance_generations is not None:
            pulumi.set(__self__, "instance_generations", instance_generations)
        if local_storage is not None:
            pulumi.set(__self__, "local_storage", local_storage)
        if local_storage_types is not None:
            pulumi.set(__self__, "local_storage_types", local_storage_types)
        if max_spot_price_as_percentage_of_optimal_on_demand_price is not None:
            pulumi.set(__self__, "max_spot_price_as_percentage_of_optimal_on_demand_price", max_spot_price_as_percentage_of_optimal_on_demand_price)
        if memory_gi_b_per_v_cpu is not None:
            pulumi.set(__self__, "memory_gi_b_per_v_cpu", memory_gi_b_per_v_cpu)
        if memory_mi_b is not None:
            pulumi.set(__self__, "memory_mi_b", memory_mi_b)
        if network_bandwidth_gbps is not None:
            pulumi.set(__self__, "network_bandwidth_gbps", network_bandwidth_gbps)
        if network_interface_count is not None:
            pulumi.set(__self__, "network_interface_count", network_interface_count)
        if on_demand_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "on_demand_max_price_percentage_over_lowest_price", on_demand_max_price_percentage_over_lowest_price)
        if require_hibernate_support is not None:
            pulumi.set(__self__, "require_hibernate_support", require_hibernate_support)
        if spot_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "spot_max_price_percentage_over_lowest_price", spot_max_price_percentage_over_lowest_price)
        if total_local_storage_gb is not None:
            pulumi.set(__self__, "total_local_storage_gb", total_local_storage_gb)
        if v_cpu_count is not None:
            pulumi.set(__self__, "v_cpu_count", v_cpu_count)

    @_builtins.property
    @pulumi.getter(name="acceleratorCount")
    def accelerator_count(self) -> Optional['outputs.Ec2FleetAcceleratorCountRequest']:
        """
        The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.

        To exclude accelerator-enabled instance types, set `Max` to `0` .

        Default: No minimum or maximum limits
        """
        return pulumi.get(self, "accelerator_count")

    @_builtins.property
    @pulumi.getter(name="acceleratorManufacturers")
    def accelerator_manufacturers(self) -> Optional[Sequence['Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem']]:
        """
        Indicates whether instance types must have accelerators by specific manufacturers.

        - For instance types with AWS devices, specify `amazon-web-services` .
        - For instance types with AMD devices, specify `amd` .
        - For instance types with Habana devices, specify `habana` .
        - For instance types with NVIDIA devices, specify `nvidia` .
        - For instance types with Xilinx devices, specify `xilinx` .

        Default: Any manufacturer
        """
        return pulumi.get(self, "accelerator_manufacturers")

    @_builtins.property
    @pulumi.getter(name="acceleratorNames")
    def accelerator_names(self) -> Optional[Sequence['Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem']]:
        """
        The accelerators that must be on the instance type.

        - For instance types with NVIDIA A10G GPUs, specify `a10g` .
        - For instance types with NVIDIA A100 GPUs, specify `a100` .
        - For instance types with NVIDIA H100 GPUs, specify `h100` .
        - For instance types with AWS Inferentia chips, specify `inferentia` .
        - For instance types with NVIDIA GRID K520 GPUs, specify `k520` .
        - For instance types with NVIDIA K80 GPUs, specify `k80` .
        - For instance types with NVIDIA M60 GPUs, specify `m60` .
        - For instance types with AMD Radeon Pro V520 GPUs, specify `radeon-pro-v520` .
        - For instance types with NVIDIA T4 GPUs, specify `t4` .
        - For instance types with NVIDIA T4G GPUs, specify `t4g` .
        - For instance types with Xilinx VU9P FPGAs, specify `vu9p` .
        - For instance types with NVIDIA V100 GPUs, specify `v100` .

        Default: Any accelerator
        """
        return pulumi.get(self, "accelerator_names")

    @_builtins.property
    @pulumi.getter(name="acceleratorTotalMemoryMiB")
    def accelerator_total_memory_mi_b(self) -> Optional['outputs.Ec2FleetAcceleratorTotalMemoryMiBRequest']:
        """
        The minimum and maximum amount of total accelerator memory, in MiB.

        Default: No minimum or maximum limits
        """
        return pulumi.get(self, "accelerator_total_memory_mi_b")

    @_builtins.property
    @pulumi.getter(name="acceleratorTypes")
    def accelerator_types(self) -> Optional[Sequence['Ec2FleetInstanceRequirementsRequestAcceleratorTypesItem']]:
        """
        The accelerator types that must be on the instance type.

        - For instance types with FPGA accelerators, specify `fpga` .
        - For instance types with GPU accelerators, specify `gpu` .
        - For instance types with Inference accelerators, specify `inference` .

        Default: Any accelerator type
        """
        return pulumi.get(self, "accelerator_types")

    @_builtins.property
    @pulumi.getter(name="allowedInstanceTypes")
    def allowed_instance_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        The instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes.

        You can use strings with one or more wild cards, represented by an asterisk ( `*` ), to allow an instance type, size, or generation. The following are examples: `m5.8xlarge` , `c5*.*` , `m5a.*` , `r*` , `*3*` .

        For example, if you specify `c5*` ,Amazon EC2 will allow the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*` , Amazon EC2 will allow all the M5a instance types, but not the M5n instance types.

        > If you specify `AllowedInstanceTypes` , you can't specify `ExcludedInstanceTypes` . 

        Default: All instance types
        """
        return pulumi.get(self, "allowed_instance_types")

    @_builtins.property
    @pulumi.getter(name="bareMetal")
    def bare_metal(self) -> Optional['Ec2FleetInstanceRequirementsRequestBareMetal']:
        """
        Indicates whether bare metal instance types must be included, excluded, or required.

        - To include bare metal instance types, specify `included` .
        - To require only bare metal instance types, specify `required` .
        - To exclude bare metal instance types, specify `excluded` .

        Default: `excluded`
        """
        return pulumi.get(self, "bare_metal")

    @_builtins.property
    @pulumi.getter(name="baselineEbsBandwidthMbps")
    def baseline_ebs_bandwidth_mbps(self) -> Optional['outputs.Ec2FleetBaselineEbsBandwidthMbpsRequest']:
        """
        The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see [Amazon EBSoptimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the *Amazon EC2 User Guide* .

        Default: No minimum or maximum limits
        """
        return pulumi.get(self, "baseline_ebs_bandwidth_mbps")

    @_builtins.property
    @pulumi.getter(name="baselinePerformanceFactors")
    def baseline_performance_factors(self) -> Optional['outputs.Ec2FleetBaselinePerformanceFactorsRequest']:
        """
        The baseline performance to consider, using an instance family as a baseline reference. The instance family establishes the lowest acceptable level of performance. Amazon EC2 uses this baseline to guide instance type selection, but there is no guarantee that the selected instance types will always exceed the baseline for every application. Currently, this parameter only supports CPU performance as a baseline performance factor. For more information, see [Performance protection](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html#ec2fleet-abis-performance-protection) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "baseline_performance_factors")

    @_builtins.property
    @pulumi.getter(name="burstablePerformance")
    def burstable_performance(self) -> Optional['Ec2FleetInstanceRequirementsRequestBurstablePerformance']:
        """
        Indicates whether burstable performance T instance types are included, excluded, or required. For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) .

        - To include burstable performance instance types, specify `included` .
        - To require only burstable performance instance types, specify `required` .
        - To exclude burstable performance instance types, specify `excluded` .

        Default: `excluded`
        """
        return pulumi.get(self, "burstable_performance")

    @_builtins.property
    @pulumi.getter(name="cpuManufacturers")
    def cpu_manufacturers(self) -> Optional[Sequence['Ec2FleetInstanceRequirementsRequestCpuManufacturersItem']]:
        """
        The CPU manufacturers to include.

        - For instance types with Intel CPUs, specify `intel` .
        - For instance types with AMD CPUs, specify `amd` .
        - For instance types with AWS CPUs, specify `amazon-web-services` .
        - For instance types with Apple CPUs, specify `apple` .

        > Don't confuse the CPU manufacturer with the CPU architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template. 

        Default: Any manufacturer
        """
        return pulumi.get(self, "cpu_manufacturers")

    @_builtins.property
    @pulumi.getter(name="excludedInstanceTypes")
    def excluded_instance_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        The instance types to exclude.

        You can use strings with one or more wild cards, represented by an asterisk ( `*` ), to exclude an instance family, type, size, or generation. The following are examples: `m5.8xlarge` , `c5*.*` , `m5a.*` , `r*` , `*3*` .

        For example, if you specify `c5*` ,Amazon EC2 will exclude the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*` , Amazon EC2 will exclude all the M5a instance types, but not the M5n instance types.

        > If you specify `ExcludedInstanceTypes` , you can't specify `AllowedInstanceTypes` . 

        Default: No excluded instance types
        """
        return pulumi.get(self, "excluded_instance_types")

    @_builtins.property
    @pulumi.getter(name="instanceGenerations")
    def instance_generations(self) -> Optional[Sequence['Ec2FleetInstanceRequirementsRequestInstanceGenerationsItem']]:
        """
        Indicates whether current or previous generation instance types are included. The current generation instance types are recommended for use. Current generation instance types are typically the latest two to three generations in each instance family. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .

        For current generation instance types, specify `current` .

        For previous generation instance types, specify `previous` .

        Default: Current and previous generation instance types
        """
        return pulumi.get(self, "instance_generations")

    @_builtins.property
    @pulumi.getter(name="localStorage")
    def local_storage(self) -> Optional['Ec2FleetInstanceRequirementsRequestLocalStorage']:
        """
        Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, [Amazon EC2 instance store](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html) in the *Amazon EC2 User Guide* .

        - To include instance types with instance store volumes, specify `included` .
        - To require only instance types with instance store volumes, specify `required` .
        - To exclude instance types with instance store volumes, specify `excluded` .

        Default: `included`
        """
        return pulumi.get(self, "local_storage")

    @_builtins.property
    @pulumi.getter(name="localStorageTypes")
    def local_storage_types(self) -> Optional[Sequence['Ec2FleetInstanceRequirementsRequestLocalStorageTypesItem']]:
        """
        The type of local storage that is required.

        - For instance types with hard disk drive (HDD) storage, specify `hdd` .
        - For instance types with solid state drive (SSD) storage, specify `ssd` .

        Default: `hdd` and `ssd`
        """
        return pulumi.get(self, "local_storage_types")

    @_builtins.property
    @pulumi.getter(name="maxSpotPriceAsPercentageOfOptimalOnDemandPrice")
    def max_spot_price_as_percentage_of_optimal_on_demand_price(self) -> Optional[_builtins.int]:
        """
        [Price protection] The price protection threshold for Spot Instances, as a percentage of an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.

        The parameter accepts an integer, which Amazon EC2 interprets as a percentage.

        If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is based on the per vCPU or per memory price instead of the per instance price.

        > Only one of `SpotMaxPricePercentageOverLowestPrice` or `MaxSpotPriceAsPercentageOfOptimalOnDemandPrice` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as `999999` .
        """
        return pulumi.get(self, "max_spot_price_as_percentage_of_optimal_on_demand_price")

    @_builtins.property
    @pulumi.getter(name="memoryGiBPerVCpu")
    def memory_gi_b_per_v_cpu(self) -> Optional['outputs.Ec2FleetMemoryGiBPerVCpuRequest']:
        """
        The minimum and maximum amount of memory per vCPU, in GiB.

        Default: No minimum or maximum limits
        """
        return pulumi.get(self, "memory_gi_b_per_v_cpu")

    @_builtins.property
    @pulumi.getter(name="memoryMiB")
    def memory_mi_b(self) -> Optional['outputs.Ec2FleetMemoryMiBRequest']:
        """
        The minimum and maximum amount of memory, in MiB.
        """
        return pulumi.get(self, "memory_mi_b")

    @_builtins.property
    @pulumi.getter(name="networkBandwidthGbps")
    def network_bandwidth_gbps(self) -> Optional['outputs.Ec2FleetNetworkBandwidthGbpsRequest']:
        """
        The minimum and maximum amount of baseline network bandwidth, in gigabits per second (Gbps). For more information, see [Amazon EC2 instance network bandwidth](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-network-bandwidth.html) in the *Amazon EC2 User Guide* .

        Default: No minimum or maximum limits
        """
        return pulumi.get(self, "network_bandwidth_gbps")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceCount")
    def network_interface_count(self) -> Optional['outputs.Ec2FleetNetworkInterfaceCountRequest']:
        """
        The minimum and maximum number of network interfaces.

        Default: No minimum or maximum limits
        """
        return pulumi.get(self, "network_interface_count")

    @_builtins.property
    @pulumi.getter(name="onDemandMaxPricePercentageOverLowestPrice")
    def on_demand_max_price_percentage_over_lowest_price(self) -> Optional[_builtins.int]:
        """
        [Price protection] The price protection threshold for On-Demand Instances, as a percentage higher than an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.

        The parameter accepts an integer, which Amazon EC2 interprets as a percentage.

        To indicate no price protection threshold, specify a high value, such as `999999` .

        This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) .

        > If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price. 

        Default: `20`
        """
        return pulumi.get(self, "on_demand_max_price_percentage_over_lowest_price")

    @_builtins.property
    @pulumi.getter(name="requireHibernateSupport")
    def require_hibernate_support(self) -> Optional[_builtins.bool]:
        """
        Indicates whether instance types must support hibernation for On-Demand Instances.

        This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) .

        Default: `false`
        """
        return pulumi.get(self, "require_hibernate_support")

    @_builtins.property
    @pulumi.getter(name="spotMaxPricePercentageOverLowestPrice")
    def spot_max_price_percentage_over_lowest_price(self) -> Optional[_builtins.int]:
        """
        [Price protection] The price protection threshold for Spot Instances, as a percentage higher than an identified Spot price. The identified Spot price is the Spot price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified Spot price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose Spot price exceeds your specified threshold.

        The parameter accepts an integer, which Amazon EC2 interprets as a percentage.

        If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.

        This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) .

        > Only one of `SpotMaxPricePercentageOverLowestPrice` or `MaxSpotPriceAsPercentageOfOptimalOnDemandPrice` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as `999999` . 

        Default: `100`
        """
        return pulumi.get(self, "spot_max_price_percentage_over_lowest_price")

    @_builtins.property
    @pulumi.getter(name="totalLocalStorageGb")
    def total_local_storage_gb(self) -> Optional['outputs.Ec2FleetTotalLocalStorageGbRequest']:
        """
        The minimum and maximum amount of total local storage, in GB.

        Default: No minimum or maximum limits
        """
        return pulumi.get(self, "total_local_storage_gb")

    @_builtins.property
    @pulumi.getter(name="vCpuCount")
    def v_cpu_count(self) -> Optional['outputs.Ec2FleetVCpuCountRangeRequest']:
        """
        The minimum and maximum number of vCPUs.
        """
        return pulumi.get(self, "v_cpu_count")


@pulumi.output_type
class Ec2FleetMaintenanceStrategies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityRebalance":
            suggest = "capacity_rebalance"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2FleetMaintenanceStrategies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2FleetMaintenanceStrategies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2FleetMaintenanceStrategies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_rebalance: Optional['outputs.Ec2FleetCapacityRebalance'] = None):
        """
        :param 'Ec2FleetCapacityRebalance' capacity_rebalance: The strategy to use when Amazon EC2 emits a signal that your Spot Instance is at an elevated risk of being interrupted.
        """
        if capacity_rebalance is not None:
            pulumi.set(__self__, "capacity_rebalance", capacity_rebalance)

    @_builtins.property
    @pulumi.getter(name="capacityRebalance")
    def capacity_rebalance(self) -> Optional['outputs.Ec2FleetCapacityRebalance']:
        """
        The strategy to use when Amazon EC2 emits a signal that your Spot Instance is at an elevated risk of being interrupted.
        """
        return pulumi.get(self, "capacity_rebalance")


@pulumi.output_type
class Ec2FleetMemoryGiBPerVCpuRequest(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.float] = None,
                 min: Optional[_builtins.float] = None):
        """
        :param _builtins.float max: The maximum amount of memory per vCPU, in GiB. To specify no maximum limit, omit this parameter.
        :param _builtins.float min: The minimum amount of memory per vCPU, in GiB. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.float]:
        """
        The maximum amount of memory per vCPU, in GiB. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.float]:
        """
        The minimum amount of memory per vCPU, in GiB. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class Ec2FleetMemoryMiBRequest(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        """
        :param _builtins.int max: The maximum amount of memory, in MiB. To specify no maximum limit, omit this parameter.
        :param _builtins.int min: The minimum amount of memory, in MiB. To specify no minimum limit, specify `0` .
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        """
        The maximum amount of memory, in MiB. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        """
        The minimum amount of memory, in MiB. To specify no minimum limit, specify `0` .
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class Ec2FleetNetworkBandwidthGbpsRequest(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.float] = None,
                 min: Optional[_builtins.float] = None):
        """
        :param _builtins.float max: The maximum amount of network bandwidth, in Gbps. To specify no maximum limit, omit this parameter.
        :param _builtins.float min: The minimum amount of network bandwidth, in Gbps. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.float]:
        """
        The maximum amount of network bandwidth, in Gbps. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.float]:
        """
        The minimum amount of network bandwidth, in Gbps. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class Ec2FleetNetworkInterfaceCountRequest(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        """
        :param _builtins.int max: The maximum number of network interfaces. To specify no maximum limit, omit this parameter.
        :param _builtins.int min: The minimum number of network interfaces. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        """
        The maximum number of network interfaces. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        """
        The minimum number of network interfaces. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class Ec2FleetOnDemandOptionsRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocationStrategy":
            suggest = "allocation_strategy"
        elif key == "capacityReservationOptions":
            suggest = "capacity_reservation_options"
        elif key == "maxTotalPrice":
            suggest = "max_total_price"
        elif key == "minTargetCapacity":
            suggest = "min_target_capacity"
        elif key == "singleAvailabilityZone":
            suggest = "single_availability_zone"
        elif key == "singleInstanceType":
            suggest = "single_instance_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2FleetOnDemandOptionsRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2FleetOnDemandOptionsRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2FleetOnDemandOptionsRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocation_strategy: Optional[_builtins.str] = None,
                 capacity_reservation_options: Optional['outputs.Ec2FleetCapacityReservationOptionsRequest'] = None,
                 max_total_price: Optional[_builtins.str] = None,
                 min_target_capacity: Optional[_builtins.int] = None,
                 single_availability_zone: Optional[_builtins.bool] = None,
                 single_instance_type: Optional[_builtins.bool] = None):
        """
        :param _builtins.str allocation_strategy: The strategy that determines the order of the launch template overrides to use in fulfilling On-Demand capacity.
               
               `lowest-price` - EC2 Fleet uses price to determine the order, launching the lowest price first.
               
               `prioritized` - EC2 Fleet uses the priority that you assigned to each launch template override, launching the highest priority first.
               
               Default: `lowest-price`
        :param 'Ec2FleetCapacityReservationOptionsRequest' capacity_reservation_options: The strategy for using unused Capacity Reservations for fulfilling On-Demand capacity.
               
               Supported only for fleets of type `instant` .
        :param _builtins.str max_total_price: The maximum amount per hour for On-Demand Instances that you're willing to pay.
               
               > If your fleet includes T instances that are configured as `unlimited` , and if their average CPU usage exceeds the baseline utilization, you will incur a charge for surplus credits. The `MaxTotalPrice` does not account for surplus credits, and, if you use surplus credits, your final cost might be higher than what you specified for `MaxTotalPrice` . For more information, see [Surplus credits can incur charges](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-unlimited-mode-concepts.html#unlimited-mode-surplus-credits) in the *Amazon EC2 User Guide* .
        :param _builtins.int min_target_capacity: The minimum target capacity for On-Demand Instances in the fleet. If this minimum capacity isn't reached, no instances are launched.
               
               Constraints: Maximum value of `1000` . Supported only for fleets of type `instant` .
               
               At least one of the following must be specified: `SingleAvailabilityZone` | `SingleInstanceType`
        :param _builtins.bool single_availability_zone: Indicates that the fleet launches all On-Demand Instances into a single Availability Zone.
               
               Supported only for fleets of type `instant` .
        :param _builtins.bool single_instance_type: Indicates that the fleet uses a single instance type to launch all On-Demand Instances in the fleet.
               
               Supported only for fleets of type `instant` .
        """
        if allocation_strategy is not None:
            pulumi.set(__self__, "allocation_strategy", allocation_strategy)
        if capacity_reservation_options is not None:
            pulumi.set(__self__, "capacity_reservation_options", capacity_reservation_options)
        if max_total_price is not None:
            pulumi.set(__self__, "max_total_price", max_total_price)
        if min_target_capacity is not None:
            pulumi.set(__self__, "min_target_capacity", min_target_capacity)
        if single_availability_zone is not None:
            pulumi.set(__self__, "single_availability_zone", single_availability_zone)
        if single_instance_type is not None:
            pulumi.set(__self__, "single_instance_type", single_instance_type)

    @_builtins.property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> Optional[_builtins.str]:
        """
        The strategy that determines the order of the launch template overrides to use in fulfilling On-Demand capacity.

        `lowest-price` - EC2 Fleet uses price to determine the order, launching the lowest price first.

        `prioritized` - EC2 Fleet uses the priority that you assigned to each launch template override, launching the highest priority first.

        Default: `lowest-price`
        """
        return pulumi.get(self, "allocation_strategy")

    @_builtins.property
    @pulumi.getter(name="capacityReservationOptions")
    def capacity_reservation_options(self) -> Optional['outputs.Ec2FleetCapacityReservationOptionsRequest']:
        """
        The strategy for using unused Capacity Reservations for fulfilling On-Demand capacity.

        Supported only for fleets of type `instant` .
        """
        return pulumi.get(self, "capacity_reservation_options")

    @_builtins.property
    @pulumi.getter(name="maxTotalPrice")
    def max_total_price(self) -> Optional[_builtins.str]:
        """
        The maximum amount per hour for On-Demand Instances that you're willing to pay.

        > If your fleet includes T instances that are configured as `unlimited` , and if their average CPU usage exceeds the baseline utilization, you will incur a charge for surplus credits. The `MaxTotalPrice` does not account for surplus credits, and, if you use surplus credits, your final cost might be higher than what you specified for `MaxTotalPrice` . For more information, see [Surplus credits can incur charges](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-unlimited-mode-concepts.html#unlimited-mode-surplus-credits) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "max_total_price")

    @_builtins.property
    @pulumi.getter(name="minTargetCapacity")
    def min_target_capacity(self) -> Optional[_builtins.int]:
        """
        The minimum target capacity for On-Demand Instances in the fleet. If this minimum capacity isn't reached, no instances are launched.

        Constraints: Maximum value of `1000` . Supported only for fleets of type `instant` .

        At least one of the following must be specified: `SingleAvailabilityZone` | `SingleInstanceType`
        """
        return pulumi.get(self, "min_target_capacity")

    @_builtins.property
    @pulumi.getter(name="singleAvailabilityZone")
    def single_availability_zone(self) -> Optional[_builtins.bool]:
        """
        Indicates that the fleet launches all On-Demand Instances into a single Availability Zone.

        Supported only for fleets of type `instant` .
        """
        return pulumi.get(self, "single_availability_zone")

    @_builtins.property
    @pulumi.getter(name="singleInstanceType")
    def single_instance_type(self) -> Optional[_builtins.bool]:
        """
        Indicates that the fleet uses a single instance type to launch all On-Demand Instances in the fleet.

        Supported only for fleets of type `instant` .
        """
        return pulumi.get(self, "single_instance_type")


@pulumi.output_type
class Ec2FleetPerformanceFactorReferenceRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceFamily":
            suggest = "instance_family"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2FleetPerformanceFactorReferenceRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2FleetPerformanceFactorReferenceRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2FleetPerformanceFactorReferenceRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_family: Optional[_builtins.str] = None):
        """
        :param _builtins.str instance_family: The instance family to use as a baseline reference.
               
               > Ensure that you specify the correct value for the instance family. The instance family is everything before the period ( `.` ) in the instance type name. For example, in the instance type `c6i.large` , the instance family is `c6i` , not `c6` . For more information, see [Amazon EC2 instance type naming conventions](https://docs.aws.amazon.com/ec2/latest/instancetypes/instance-type-names.html) in *Amazon EC2 Instance Types* . 
               
               The following instance families are *not supported* for performance protection:
               
               - `c1`
               - `g3` | `g3s`
               - `hpc7g`
               - `m1` | `m2`
               - `mac1` | `mac2` | `mac2-m1ultra` | `mac2-m2` | `mac2-m2pro`
               - `p3dn` | `p4d` | `p5`
               - `t1`
               - `u-12tb1` | `u-18tb1` | `u-24tb1` | `u-3tb1` | `u-6tb1` | `u-9tb1` | `u7i-12tb` | `u7in-16tb` | `u7in-24tb` | `u7in-32tb`
               
               If you enable performance protection by specifying a supported instance family, the returned instance types will exclude the above unsupported instance families.
               
               If you specify an unsupported instance family as a value for baseline performance, the API returns an empty response response for [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) and an exception for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet.html) , [RequestSpotFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotFleet.html) , [ModifyFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyFleet.html) , and [ModifySpotFleetRequest](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifySpotFleetRequest.html) .
        """
        if instance_family is not None:
            pulumi.set(__self__, "instance_family", instance_family)

    @_builtins.property
    @pulumi.getter(name="instanceFamily")
    def instance_family(self) -> Optional[_builtins.str]:
        """
        The instance family to use as a baseline reference.

        > Ensure that you specify the correct value for the instance family. The instance family is everything before the period ( `.` ) in the instance type name. For example, in the instance type `c6i.large` , the instance family is `c6i` , not `c6` . For more information, see [Amazon EC2 instance type naming conventions](https://docs.aws.amazon.com/ec2/latest/instancetypes/instance-type-names.html) in *Amazon EC2 Instance Types* . 

        The following instance families are *not supported* for performance protection:

        - `c1`
        - `g3` | `g3s`
        - `hpc7g`
        - `m1` | `m2`
        - `mac1` | `mac2` | `mac2-m1ultra` | `mac2-m2` | `mac2-m2pro`
        - `p3dn` | `p4d` | `p5`
        - `t1`
        - `u-12tb1` | `u-18tb1` | `u-24tb1` | `u-3tb1` | `u-6tb1` | `u-9tb1` | `u7i-12tb` | `u7in-16tb` | `u7in-24tb` | `u7in-32tb`

        If you enable performance protection by specifying a supported instance family, the returned instance types will exclude the above unsupported instance families.

        If you specify an unsupported instance family as a value for baseline performance, the API returns an empty response response for [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) and an exception for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet.html) , [RequestSpotFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotFleet.html) , [ModifyFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyFleet.html) , and [ModifySpotFleetRequest](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifySpotFleetRequest.html) .
        """
        return pulumi.get(self, "instance_family")


@pulumi.output_type
class Ec2FleetPlacement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "groupName":
            suggest = "group_name"
        elif key == "hostId":
            suggest = "host_id"
        elif key == "hostResourceGroupArn":
            suggest = "host_resource_group_arn"
        elif key == "partitionNumber":
            suggest = "partition_number"
        elif key == "spreadDomain":
            suggest = "spread_domain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2FleetPlacement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2FleetPlacement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2FleetPlacement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 affinity: Optional[_builtins.str] = None,
                 availability_zone: Optional[_builtins.str] = None,
                 group_name: Optional[_builtins.str] = None,
                 host_id: Optional[_builtins.str] = None,
                 host_resource_group_arn: Optional[_builtins.str] = None,
                 partition_number: Optional[_builtins.int] = None,
                 spread_domain: Optional[_builtins.str] = None,
                 tenancy: Optional[_builtins.str] = None):
        """
        :param _builtins.str affinity: The affinity setting for the instance on the Dedicated Host.
               
               This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) or [ImportInstance](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html) .
        :param _builtins.str availability_zone: The Availability Zone of the instance.
               
               On input, you can specify `AvailabilityZone` or `AvailabilityZoneId` , but not both. If you specify neither one, Amazon EC2 automatically selects an Availability Zone for you.
               
               This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) .
        :param _builtins.str group_name: The name of the placement group that the instance is in.
               
               On input, you can specify `GroupId` or `GroupName` , but not both.
        :param _builtins.str host_id: The ID of the Dedicated Host on which the instance resides.
               
               This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) or [ImportInstance](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html) .
        :param _builtins.str host_resource_group_arn: The ARN of the host resource group in which to launch the instances.
               
               On input, if you specify this parameter, either omit the *Tenancy* parameter or set it to `host` .
               
               This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) .
        :param _builtins.int partition_number: The number of the partition that the instance is in. Valid only if the placement group strategy is set to `partition` .
               
               This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) .
        :param _builtins.str spread_domain: Reserved for future use.
        :param _builtins.str tenancy: The tenancy of the instance. An instance with a tenancy of `dedicated` runs on single-tenant hardware.
               
               This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) . The `host` tenancy is not supported for [ImportInstance](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html) or for T3 instances that are configured for the `unlimited` CPU credit option.
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if host_id is not None:
            pulumi.set(__self__, "host_id", host_id)
        if host_resource_group_arn is not None:
            pulumi.set(__self__, "host_resource_group_arn", host_resource_group_arn)
        if partition_number is not None:
            pulumi.set(__self__, "partition_number", partition_number)
        if spread_domain is not None:
            pulumi.set(__self__, "spread_domain", spread_domain)
        if tenancy is not None:
            pulumi.set(__self__, "tenancy", tenancy)

    @_builtins.property
    @pulumi.getter
    def affinity(self) -> Optional[_builtins.str]:
        """
        The affinity setting for the instance on the Dedicated Host.

        This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) or [ImportInstance](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html) .
        """
        return pulumi.get(self, "affinity")

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[_builtins.str]:
        """
        The Availability Zone of the instance.

        On input, you can specify `AvailabilityZone` or `AvailabilityZoneId` , but not both. If you specify neither one, Amazon EC2 automatically selects an Availability Zone for you.

        This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) .
        """
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[_builtins.str]:
        """
        The name of the placement group that the instance is in.

        On input, you can specify `GroupId` or `GroupName` , but not both.
        """
        return pulumi.get(self, "group_name")

    @_builtins.property
    @pulumi.getter(name="hostId")
    def host_id(self) -> Optional[_builtins.str]:
        """
        The ID of the Dedicated Host on which the instance resides.

        This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) or [ImportInstance](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html) .
        """
        return pulumi.get(self, "host_id")

    @_builtins.property
    @pulumi.getter(name="hostResourceGroupArn")
    def host_resource_group_arn(self) -> Optional[_builtins.str]:
        """
        The ARN of the host resource group in which to launch the instances.

        On input, if you specify this parameter, either omit the *Tenancy* parameter or set it to `host` .

        This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) .
        """
        return pulumi.get(self, "host_resource_group_arn")

    @_builtins.property
    @pulumi.getter(name="partitionNumber")
    def partition_number(self) -> Optional[_builtins.int]:
        """
        The number of the partition that the instance is in. Valid only if the placement group strategy is set to `partition` .

        This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) .
        """
        return pulumi.get(self, "partition_number")

    @_builtins.property
    @pulumi.getter(name="spreadDomain")
    def spread_domain(self) -> Optional[_builtins.str]:
        """
        Reserved for future use.
        """
        return pulumi.get(self, "spread_domain")

    @_builtins.property
    @pulumi.getter
    def tenancy(self) -> Optional[_builtins.str]:
        """
        The tenancy of the instance. An instance with a tenancy of `dedicated` runs on single-tenant hardware.

        This parameter is not supported for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet) . The `host` tenancy is not supported for [ImportInstance](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportInstance.html) or for T3 instances that are configured for the `unlimited` CPU credit option.
        """
        return pulumi.get(self, "tenancy")


@pulumi.output_type
class Ec2FleetSpotOptionsRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocationStrategy":
            suggest = "allocation_strategy"
        elif key == "instanceInterruptionBehavior":
            suggest = "instance_interruption_behavior"
        elif key == "instancePoolsToUseCount":
            suggest = "instance_pools_to_use_count"
        elif key == "maintenanceStrategies":
            suggest = "maintenance_strategies"
        elif key == "maxTotalPrice":
            suggest = "max_total_price"
        elif key == "minTargetCapacity":
            suggest = "min_target_capacity"
        elif key == "singleAvailabilityZone":
            suggest = "single_availability_zone"
        elif key == "singleInstanceType":
            suggest = "single_instance_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2FleetSpotOptionsRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2FleetSpotOptionsRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2FleetSpotOptionsRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocation_strategy: Optional['Ec2FleetSpotOptionsRequestAllocationStrategy'] = None,
                 instance_interruption_behavior: Optional['Ec2FleetSpotOptionsRequestInstanceInterruptionBehavior'] = None,
                 instance_pools_to_use_count: Optional[_builtins.int] = None,
                 maintenance_strategies: Optional['outputs.Ec2FleetMaintenanceStrategies'] = None,
                 max_total_price: Optional[_builtins.str] = None,
                 min_target_capacity: Optional[_builtins.int] = None,
                 single_availability_zone: Optional[_builtins.bool] = None,
                 single_instance_type: Optional[_builtins.bool] = None):
        """
        :param 'Ec2FleetSpotOptionsRequestAllocationStrategy' allocation_strategy: Indicates how to allocate the target Spot Instance capacity across the Spot Instance pools specified by the EC2 Fleet.
               
               If the allocation strategy is `lowestPrice` , EC2 Fleet launches instances from the Spot Instance pools with the lowest price. This is the default allocation strategy.
               
               If the allocation strategy is `diversified` , EC2 Fleet launches instances from all the Spot Instance pools that you specify.
               
               If the allocation strategy is `capacityOptimized` , EC2 Fleet launches instances from Spot Instance pools that are optimally chosen based on the available Spot Instance capacity.
               
               *Allowed Values* : `lowestPrice` | `diversified` | `capacityOptimized` | `capacityOptimizedPrioritized`
        :param 'Ec2FleetSpotOptionsRequestInstanceInterruptionBehavior' instance_interruption_behavior: The behavior when a Spot Instance is interrupted.
               
               Default: `terminate`
        :param _builtins.int instance_pools_to_use_count: The number of Spot pools across which to allocate your target Spot capacity. Supported only when Spot `AllocationStrategy` is set to `lowest-price` . EC2 Fleet selects the cheapest Spot pools and evenly allocates your target Spot capacity across the number of Spot pools that you specify.
               
               Note that EC2 Fleet attempts to draw Spot Instances from the number of pools that you specify on a best effort basis. If a pool runs out of Spot capacity before fulfilling your target capacity, EC2 Fleet will continue to fulfill your request by drawing from the next cheapest pool. To ensure that your target capacity is met, you might receive Spot Instances from more than the number of pools that you specified. Similarly, if most of the pools have no Spot capacity, you might receive your full target capacity from fewer than the number of pools that you specified.
        :param 'Ec2FleetMaintenanceStrategies' maintenance_strategies: The strategies for managing your Spot Instances that are at an elevated risk of being interrupted.
        :param _builtins.str max_total_price: The maximum amount per hour for Spot Instances that you're willing to pay. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.
               
               > If you specify a maximum price, your Spot Instances will be interrupted more frequently than if you do not specify this parameter. > If your fleet includes T instances that are configured as `unlimited` , and if their average CPU usage exceeds the baseline utilization, you will incur a charge for surplus credits. The `MaxTotalPrice` does not account for surplus credits, and, if you use surplus credits, your final cost might be higher than what you specified for `MaxTotalPrice` . For more information, see [Surplus credits can incur charges](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-unlimited-mode-concepts.html#unlimited-mode-surplus-credits) in the *Amazon EC2 User Guide* .
        :param _builtins.int min_target_capacity: The minimum target capacity for Spot Instances in the fleet. If this minimum capacity isn't reached, no instances are launched.
               
               Constraints: Maximum value of `1000` . Supported only for fleets of type `instant` .
               
               At least one of the following must be specified: `SingleAvailabilityZone` | `SingleInstanceType`
        :param _builtins.bool single_availability_zone: Indicates that the fleet launches all Spot Instances into a single Availability Zone.
               
               Supported only for fleets of type `instant` .
        :param _builtins.bool single_instance_type: Indicates that the fleet uses a single instance type to launch all Spot Instances in the fleet.
               
               Supported only for fleets of type `instant` .
        """
        if allocation_strategy is not None:
            pulumi.set(__self__, "allocation_strategy", allocation_strategy)
        if instance_interruption_behavior is not None:
            pulumi.set(__self__, "instance_interruption_behavior", instance_interruption_behavior)
        if instance_pools_to_use_count is not None:
            pulumi.set(__self__, "instance_pools_to_use_count", instance_pools_to_use_count)
        if maintenance_strategies is not None:
            pulumi.set(__self__, "maintenance_strategies", maintenance_strategies)
        if max_total_price is not None:
            pulumi.set(__self__, "max_total_price", max_total_price)
        if min_target_capacity is not None:
            pulumi.set(__self__, "min_target_capacity", min_target_capacity)
        if single_availability_zone is not None:
            pulumi.set(__self__, "single_availability_zone", single_availability_zone)
        if single_instance_type is not None:
            pulumi.set(__self__, "single_instance_type", single_instance_type)

    @_builtins.property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> Optional['Ec2FleetSpotOptionsRequestAllocationStrategy']:
        """
        Indicates how to allocate the target Spot Instance capacity across the Spot Instance pools specified by the EC2 Fleet.

        If the allocation strategy is `lowestPrice` , EC2 Fleet launches instances from the Spot Instance pools with the lowest price. This is the default allocation strategy.

        If the allocation strategy is `diversified` , EC2 Fleet launches instances from all the Spot Instance pools that you specify.

        If the allocation strategy is `capacityOptimized` , EC2 Fleet launches instances from Spot Instance pools that are optimally chosen based on the available Spot Instance capacity.

        *Allowed Values* : `lowestPrice` | `diversified` | `capacityOptimized` | `capacityOptimizedPrioritized`
        """
        return pulumi.get(self, "allocation_strategy")

    @_builtins.property
    @pulumi.getter(name="instanceInterruptionBehavior")
    def instance_interruption_behavior(self) -> Optional['Ec2FleetSpotOptionsRequestInstanceInterruptionBehavior']:
        """
        The behavior when a Spot Instance is interrupted.

        Default: `terminate`
        """
        return pulumi.get(self, "instance_interruption_behavior")

    @_builtins.property
    @pulumi.getter(name="instancePoolsToUseCount")
    def instance_pools_to_use_count(self) -> Optional[_builtins.int]:
        """
        The number of Spot pools across which to allocate your target Spot capacity. Supported only when Spot `AllocationStrategy` is set to `lowest-price` . EC2 Fleet selects the cheapest Spot pools and evenly allocates your target Spot capacity across the number of Spot pools that you specify.

        Note that EC2 Fleet attempts to draw Spot Instances from the number of pools that you specify on a best effort basis. If a pool runs out of Spot capacity before fulfilling your target capacity, EC2 Fleet will continue to fulfill your request by drawing from the next cheapest pool. To ensure that your target capacity is met, you might receive Spot Instances from more than the number of pools that you specified. Similarly, if most of the pools have no Spot capacity, you might receive your full target capacity from fewer than the number of pools that you specified.
        """
        return pulumi.get(self, "instance_pools_to_use_count")

    @_builtins.property
    @pulumi.getter(name="maintenanceStrategies")
    def maintenance_strategies(self) -> Optional['outputs.Ec2FleetMaintenanceStrategies']:
        """
        The strategies for managing your Spot Instances that are at an elevated risk of being interrupted.
        """
        return pulumi.get(self, "maintenance_strategies")

    @_builtins.property
    @pulumi.getter(name="maxTotalPrice")
    def max_total_price(self) -> Optional[_builtins.str]:
        """
        The maximum amount per hour for Spot Instances that you're willing to pay. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.

        > If you specify a maximum price, your Spot Instances will be interrupted more frequently than if you do not specify this parameter. > If your fleet includes T instances that are configured as `unlimited` , and if their average CPU usage exceeds the baseline utilization, you will incur a charge for surplus credits. The `MaxTotalPrice` does not account for surplus credits, and, if you use surplus credits, your final cost might be higher than what you specified for `MaxTotalPrice` . For more information, see [Surplus credits can incur charges](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-unlimited-mode-concepts.html#unlimited-mode-surplus-credits) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "max_total_price")

    @_builtins.property
    @pulumi.getter(name="minTargetCapacity")
    def min_target_capacity(self) -> Optional[_builtins.int]:
        """
        The minimum target capacity for Spot Instances in the fleet. If this minimum capacity isn't reached, no instances are launched.

        Constraints: Maximum value of `1000` . Supported only for fleets of type `instant` .

        At least one of the following must be specified: `SingleAvailabilityZone` | `SingleInstanceType`
        """
        return pulumi.get(self, "min_target_capacity")

    @_builtins.property
    @pulumi.getter(name="singleAvailabilityZone")
    def single_availability_zone(self) -> Optional[_builtins.bool]:
        """
        Indicates that the fleet launches all Spot Instances into a single Availability Zone.

        Supported only for fleets of type `instant` .
        """
        return pulumi.get(self, "single_availability_zone")

    @_builtins.property
    @pulumi.getter(name="singleInstanceType")
    def single_instance_type(self) -> Optional[_builtins.bool]:
        """
        Indicates that the fleet uses a single instance type to launch all Spot Instances in the fleet.

        Supported only for fleets of type `instant` .
        """
        return pulumi.get(self, "single_instance_type")


@pulumi.output_type
class Ec2FleetTag(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: The tag key.
        :param _builtins.str value: The tag value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The tag value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class Ec2FleetTagSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2FleetTagSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2FleetTagSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2FleetTagSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_type: Optional['Ec2FleetTagSpecificationResourceType'] = None,
                 tags: Optional[Sequence['outputs.Ec2FleetTag']] = None):
        """
        :param 'Ec2FleetTagSpecificationResourceType' resource_type: The type of resource to tag.
        :param Sequence['Ec2FleetTag'] tags: The tags to apply to the resource.
        """
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional['Ec2FleetTagSpecificationResourceType']:
        """
        The type of resource to tag.
        """
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.Ec2FleetTag']]:
        """
        The tags to apply to the resource.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class Ec2FleetTargetCapacitySpecificationRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "totalTargetCapacity":
            suggest = "total_target_capacity"
        elif key == "defaultTargetCapacityType":
            suggest = "default_target_capacity_type"
        elif key == "onDemandTargetCapacity":
            suggest = "on_demand_target_capacity"
        elif key == "spotTargetCapacity":
            suggest = "spot_target_capacity"
        elif key == "targetCapacityUnitType":
            suggest = "target_capacity_unit_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2FleetTargetCapacitySpecificationRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2FleetTargetCapacitySpecificationRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2FleetTargetCapacitySpecificationRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 total_target_capacity: _builtins.int,
                 default_target_capacity_type: Optional['Ec2FleetTargetCapacitySpecificationRequestDefaultTargetCapacityType'] = None,
                 on_demand_target_capacity: Optional[_builtins.int] = None,
                 spot_target_capacity: Optional[_builtins.int] = None,
                 target_capacity_unit_type: Optional['Ec2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType'] = None):
        """
        :param _builtins.int total_target_capacity: The number of units to request, filled using the default target capacity type.
        :param 'Ec2FleetTargetCapacitySpecificationRequestDefaultTargetCapacityType' default_target_capacity_type: The default target capacity type.
        :param _builtins.int on_demand_target_capacity: The number of On-Demand units to request.
        :param _builtins.int spot_target_capacity: The number of Spot units to request.
        :param 'Ec2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType' target_capacity_unit_type: The unit for the target capacity. You can specify this parameter only when using attributed-based instance type selection.
               
               Default: `units` (the number of instances)
        """
        pulumi.set(__self__, "total_target_capacity", total_target_capacity)
        if default_target_capacity_type is not None:
            pulumi.set(__self__, "default_target_capacity_type", default_target_capacity_type)
        if on_demand_target_capacity is not None:
            pulumi.set(__self__, "on_demand_target_capacity", on_demand_target_capacity)
        if spot_target_capacity is not None:
            pulumi.set(__self__, "spot_target_capacity", spot_target_capacity)
        if target_capacity_unit_type is not None:
            pulumi.set(__self__, "target_capacity_unit_type", target_capacity_unit_type)

    @_builtins.property
    @pulumi.getter(name="totalTargetCapacity")
    def total_target_capacity(self) -> _builtins.int:
        """
        The number of units to request, filled using the default target capacity type.
        """
        return pulumi.get(self, "total_target_capacity")

    @_builtins.property
    @pulumi.getter(name="defaultTargetCapacityType")
    def default_target_capacity_type(self) -> Optional['Ec2FleetTargetCapacitySpecificationRequestDefaultTargetCapacityType']:
        """
        The default target capacity type.
        """
        return pulumi.get(self, "default_target_capacity_type")

    @_builtins.property
    @pulumi.getter(name="onDemandTargetCapacity")
    def on_demand_target_capacity(self) -> Optional[_builtins.int]:
        """
        The number of On-Demand units to request.
        """
        return pulumi.get(self, "on_demand_target_capacity")

    @_builtins.property
    @pulumi.getter(name="spotTargetCapacity")
    def spot_target_capacity(self) -> Optional[_builtins.int]:
        """
        The number of Spot units to request.
        """
        return pulumi.get(self, "spot_target_capacity")

    @_builtins.property
    @pulumi.getter(name="targetCapacityUnitType")
    def target_capacity_unit_type(self) -> Optional['Ec2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType']:
        """
        The unit for the target capacity. You can specify this parameter only when using attributed-based instance type selection.

        Default: `units` (the number of instances)
        """
        return pulumi.get(self, "target_capacity_unit_type")


@pulumi.output_type
class Ec2FleetTotalLocalStorageGbRequest(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.float] = None,
                 min: Optional[_builtins.float] = None):
        """
        :param _builtins.float max: The maximum amount of total local storage, in GB. To specify no maximum limit, omit this parameter.
        :param _builtins.float min: The minimum amount of total local storage, in GB. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.float]:
        """
        The maximum amount of total local storage, in GB. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.float]:
        """
        The minimum amount of total local storage, in GB. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class Ec2FleetVCpuCountRangeRequest(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        """
        :param _builtins.int max: The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
        :param _builtins.int min: The minimum number of vCPUs. To specify no minimum limit, specify `0` .
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        """
        The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        """
        The minimum number of vCPUs. To specify no minimum limit, specify `0` .
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class EnclaveOptionsProperties(dict):
    """
    Indicates whether the instance is enabled for AWS Nitro Enclaves.
    """
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        Indicates whether the instance is enabled for AWS Nitro Enclaves.
        :param _builtins.bool enabled: If this parameter is set to true, the instance is enabled for AWS Nitro Enclaves; otherwise, it is not enabled for AWS Nitro Enclaves.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If this parameter is set to true, the instance is enabled for AWS Nitro Enclaves; otherwise, it is not enabled for AWS Nitro Enclaves.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class HibernationOptionsProperties(dict):
    """
    Indicates whether an instance is enabled for hibernation.
    """
    def __init__(__self__, *,
                 configured: Optional[_builtins.bool] = None):
        """
        Indicates whether an instance is enabled for hibernation.
        :param _builtins.bool configured: If you set this parameter to true, your instance is enabled for hibernation.
        """
        if configured is not None:
            pulumi.set(__self__, "configured", configured)

    @_builtins.property
    @pulumi.getter
    def configured(self) -> Optional[_builtins.bool]:
        """
        If you set this parameter to true, your instance is enabled for hibernation.
        """
        return pulumi.get(self, "configured")


@pulumi.output_type
class InstanceAssociationParameter(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: Sequence[_builtins.str]):
        """
        :param _builtins.str key: The name of an input parameter that is in the associated SSM document.
        :param Sequence[_builtins.str] value: The value of an input parameter.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The name of an input parameter that is in the associated SSM document.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Sequence[_builtins.str]:
        """
        The value of an input parameter.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class InstanceBlockDeviceMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "noDevice":
            suggest = "no_device"
        elif key == "virtualName":
            suggest = "virtual_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceBlockDeviceMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceBlockDeviceMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceBlockDeviceMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: _builtins.str,
                 ebs: Optional['outputs.InstanceEbs'] = None,
                 no_device: Optional[Any] = None,
                 virtual_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str device_name: The device name (for example, /dev/sdh or xvdh).
        :param 'InstanceEbs' ebs: Parameters used to automatically set up EBS volumes when the instance is launched.
        :param Any no_device: To omit the device from the block device mapping, specify an empty string.
               
               > After the instance is running, modifying this parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
        :param _builtins.str virtual_name: The virtual device name ( `ephemeral` N). The name must be in the form `ephemeral` *X* where *X* is a number starting from zero (0). For example, an instance type with 2 available instance store volumes can specify mappings for `ephemeral0` and `ephemeral1` . The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.
               
               NVMe instance store volumes are automatically enumerated and assigned a device name. Including them in your block device mapping has no effect.
               
               *Constraints* : For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.
               
               > After the instance is running, modifying this parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
        """
        pulumi.set(__self__, "device_name", device_name)
        if ebs is not None:
            pulumi.set(__self__, "ebs", ebs)
        if no_device is not None:
            pulumi.set(__self__, "no_device", no_device)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        """
        The device name (for example, /dev/sdh or xvdh).
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter
    def ebs(self) -> Optional['outputs.InstanceEbs']:
        """
        Parameters used to automatically set up EBS volumes when the instance is launched.
        """
        return pulumi.get(self, "ebs")

    @_builtins.property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[Any]:
        """
        To omit the device from the block device mapping, specify an empty string.

        > After the instance is running, modifying this parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
        """
        return pulumi.get(self, "no_device")

    @_builtins.property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[_builtins.str]:
        """
        The virtual device name ( `ephemeral` N). The name must be in the form `ephemeral` *X* where *X* is a number starting from zero (0). For example, an instance type with 2 available instance store volumes can specify mappings for `ephemeral0` and `ephemeral1` . The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.

        NVMe instance store volumes are automatically enumerated and assigned a device name. Including them in your block device mapping has no effect.

        *Constraints* : For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.

        > After the instance is running, modifying this parameter results in instance [replacement](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement) .
        """
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class InstanceEbs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceEbs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceEbs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceEbs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_on_termination: Optional[_builtins.bool] = None,
                 encrypted: Optional[_builtins.bool] = None,
                 iops: Optional[_builtins.int] = None,
                 kms_key_id: Optional[_builtins.str] = None,
                 snapshot_id: Optional[_builtins.str] = None,
                 volume_size: Optional[_builtins.int] = None,
                 volume_type: Optional[_builtins.str] = None):
        """
        :param _builtins.bool delete_on_termination: Indicates whether the EBS volume is deleted on instance termination.
        :param _builtins.bool encrypted: Indicates whether the volume should be encrypted.
        :param _builtins.int iops: The number of I/O operations per second (IOPS). For gp3, io1, and io2 volumes, this represents the number of IOPS that are provisioned for the volume. For gp2 volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.
        :param _builtins.str kms_key_id: The identifier of the AWS Key Management Service (AWS KMS) customer managed CMK to use for Amazon EBS encryption. If KmsKeyId is specified, the encrypted state must be true. If the encrypted state is true but you do not specify KmsKeyId, your AWS managed CMK for EBS is used.
        :param _builtins.str snapshot_id: The ID of the snapshot.
        :param _builtins.int volume_size: The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size.
        :param _builtins.str volume_type: The volume type.
        """
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the EBS volume is deleted on instance termination.
        """
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the volume should be encrypted.
        """
        return pulumi.get(self, "encrypted")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        """
        The number of I/O operations per second (IOPS). For gp3, io1, and io2 volumes, this represents the number of IOPS that are provisioned for the volume. For gp2 volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.
        """
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        """
        The identifier of the AWS Key Management Service (AWS KMS) customer managed CMK to use for Amazon EBS encryption. If KmsKeyId is specified, the encrypted state must be true. If the encrypted state is true but you do not specify KmsKeyId, your AWS managed CMK for EBS is used.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[_builtins.str]:
        """
        The ID of the snapshot.
        """
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[_builtins.int]:
        """
        The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size.
        """
        return pulumi.get(self, "volume_size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[_builtins.str]:
        """
        The volume type.
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class InstanceElasticGpuSpecification(dict):
    def __init__(__self__, *,
                 type: _builtins.str):
        """
        :param _builtins.str type: The type of Elastic Graphics accelerator. Amazon Elastic Graphics is no longer available.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of Elastic Graphics accelerator. Amazon Elastic Graphics is no longer available.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class InstanceElasticInferenceAccelerator(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 count: Optional[_builtins.int] = None):
        """
        :param _builtins.str type: The type of elastic inference accelerator. Amazon Elastic Inference is no longer available.
        :param _builtins.int count: The number of elastic inference accelerators to attach to the instance. Amazon Elastic Inference is no longer available.
        """
        pulumi.set(__self__, "type", type)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of elastic inference accelerator. Amazon Elastic Inference is no longer available.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[_builtins.int]:
        """
        The number of elastic inference accelerators to attach to the instance. Amazon Elastic Inference is no longer available.
        """
        return pulumi.get(self, "count")


@pulumi.output_type
class InstanceEnaSrdSpecification(dict):
    """
    Specifies the ENA Express settings for the network interface that's attached to the instance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enaSrdEnabled":
            suggest = "ena_srd_enabled"
        elif key == "enaSrdUdpSpecification":
            suggest = "ena_srd_udp_specification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceEnaSrdSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceEnaSrdSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceEnaSrdSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ena_srd_enabled: Optional[_builtins.bool] = None,
                 ena_srd_udp_specification: Optional['outputs.InstanceEnaSrdUdpSpecification'] = None):
        """
        Specifies the ENA Express settings for the network interface that's attached to the instance.
        :param _builtins.bool ena_srd_enabled: Specifies whether ENA Express is enabled for the network interface when you launch an instance.
        :param 'InstanceEnaSrdUdpSpecification' ena_srd_udp_specification: Configures ENA Express for UDP network traffic.
        """
        if ena_srd_enabled is not None:
            pulumi.set(__self__, "ena_srd_enabled", ena_srd_enabled)
        if ena_srd_udp_specification is not None:
            pulumi.set(__self__, "ena_srd_udp_specification", ena_srd_udp_specification)

    @_builtins.property
    @pulumi.getter(name="enaSrdEnabled")
    def ena_srd_enabled(self) -> Optional[_builtins.bool]:
        """
        Specifies whether ENA Express is enabled for the network interface when you launch an instance.
        """
        return pulumi.get(self, "ena_srd_enabled")

    @_builtins.property
    @pulumi.getter(name="enaSrdUdpSpecification")
    def ena_srd_udp_specification(self) -> Optional['outputs.InstanceEnaSrdUdpSpecification']:
        """
        Configures ENA Express for UDP network traffic.
        """
        return pulumi.get(self, "ena_srd_udp_specification")


@pulumi.output_type
class InstanceEnaSrdUdpSpecification(dict):
    """
    Contains ENA Express settings for UDP network traffic for the network interface that's attached to the instance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enaSrdUdpEnabled":
            suggest = "ena_srd_udp_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceEnaSrdUdpSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceEnaSrdUdpSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceEnaSrdUdpSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ena_srd_udp_enabled: Optional[_builtins.bool] = None):
        """
        Contains ENA Express settings for UDP network traffic for the network interface that's attached to the instance.
        :param _builtins.bool ena_srd_udp_enabled: Indicates whether UDP traffic uses ENA Express for your instance.
        """
        if ena_srd_udp_enabled is not None:
            pulumi.set(__self__, "ena_srd_udp_enabled", ena_srd_udp_enabled)

    @_builtins.property
    @pulumi.getter(name="enaSrdUdpEnabled")
    def ena_srd_udp_enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates whether UDP traffic uses ENA Express for your instance.
        """
        return pulumi.get(self, "ena_srd_udp_enabled")


@pulumi.output_type
class InstanceIpv6Address(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv6Address":
            suggest = "ipv6_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceIpv6Address. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceIpv6Address.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceIpv6Address.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv6_address: _builtins.str):
        """
        :param _builtins.str ipv6_address: The IPv6 address.
        """
        pulumi.set(__self__, "ipv6_address", ipv6_address)

    @_builtins.property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> _builtins.str:
        """
        The IPv6 address.
        """
        return pulumi.get(self, "ipv6_address")


@pulumi.output_type
class InstanceLaunchTemplateSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTemplateId":
            suggest = "launch_template_id"
        elif key == "launchTemplateName":
            suggest = "launch_template_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceLaunchTemplateSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceLaunchTemplateSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceLaunchTemplateSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 launch_template_id: Optional[_builtins.str] = None,
                 launch_template_name: Optional[_builtins.str] = None,
                 version: Optional[_builtins.str] = None):
        """
        :param _builtins.str launch_template_id: The ID of the launch template. You must specify the LaunchTemplateName or the LaunchTemplateId, but not both.
        :param _builtins.str launch_template_name: The name of the launch template. You must specify the LaunchTemplateName or the LaunchTemplateId, but not both.
        :param _builtins.str version: The version number of the launch template.
        """
        if launch_template_id is not None:
            pulumi.set(__self__, "launch_template_id", launch_template_id)
        if launch_template_name is not None:
            pulumi.set(__self__, "launch_template_name", launch_template_name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="launchTemplateId")
    def launch_template_id(self) -> Optional[_builtins.str]:
        """
        The ID of the launch template. You must specify the LaunchTemplateName or the LaunchTemplateId, but not both.
        """
        return pulumi.get(self, "launch_template_id")

    @_builtins.property
    @pulumi.getter(name="launchTemplateName")
    def launch_template_name(self) -> Optional[_builtins.str]:
        """
        The name of the launch template. You must specify the LaunchTemplateName or the LaunchTemplateId, but not both.
        """
        return pulumi.get(self, "launch_template_name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        The version number of the launch template.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class InstanceLicenseSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "licenseConfigurationArn":
            suggest = "license_configuration_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceLicenseSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceLicenseSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceLicenseSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 license_configuration_arn: _builtins.str):
        """
        :param _builtins.str license_configuration_arn: The Amazon Resource Name (ARN) of the license configuration.
        """
        pulumi.set(__self__, "license_configuration_arn", license_configuration_arn)

    @_builtins.property
    @pulumi.getter(name="licenseConfigurationArn")
    def license_configuration_arn(self) -> _builtins.str:
        """
        The Amazon Resource Name (ARN) of the license configuration.
        """
        return pulumi.get(self, "license_configuration_arn")


@pulumi.output_type
class InstanceMetadataOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpEndpoint":
            suggest = "http_endpoint"
        elif key == "httpProtocolIpv6":
            suggest = "http_protocol_ipv6"
        elif key == "httpPutResponseHopLimit":
            suggest = "http_put_response_hop_limit"
        elif key == "httpTokens":
            suggest = "http_tokens"
        elif key == "instanceMetadataTags":
            suggest = "instance_metadata_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceMetadataOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceMetadataOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceMetadataOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_endpoint: Optional['InstanceMetadataOptionsHttpEndpoint'] = None,
                 http_protocol_ipv6: Optional['InstanceMetadataOptionsHttpProtocolIpv6'] = None,
                 http_put_response_hop_limit: Optional[_builtins.int] = None,
                 http_tokens: Optional['InstanceMetadataOptionsHttpTokens'] = None,
                 instance_metadata_tags: Optional['InstanceMetadataOptionsInstanceMetadataTags'] = None):
        """
        :param 'InstanceMetadataOptionsHttpEndpoint' http_endpoint: Enables or disables the HTTP metadata endpoint on your instances. If you specify a value of disabled, you cannot access your instance metadata.
        :param 'InstanceMetadataOptionsHttpProtocolIpv6' http_protocol_ipv6: Enables or disables the IPv6 endpoint for the instance metadata service. To use this option, the instance must be a Nitro-based instance launched in a subnet that supports IPv6.
        :param _builtins.int http_put_response_hop_limit: The number of network hops that the metadata token can travel. Maximum is 64.
        :param 'InstanceMetadataOptionsHttpTokens' http_tokens: Indicates whether IMDSv2 is required.
        :param 'InstanceMetadataOptionsInstanceMetadataTags' instance_metadata_tags: Indicates whether tags from the instance are propagated to the EBS volumes.
        """
        if http_endpoint is not None:
            pulumi.set(__self__, "http_endpoint", http_endpoint)
        if http_protocol_ipv6 is not None:
            pulumi.set(__self__, "http_protocol_ipv6", http_protocol_ipv6)
        if http_put_response_hop_limit is not None:
            pulumi.set(__self__, "http_put_response_hop_limit", http_put_response_hop_limit)
        if http_tokens is not None:
            pulumi.set(__self__, "http_tokens", http_tokens)
        if instance_metadata_tags is not None:
            pulumi.set(__self__, "instance_metadata_tags", instance_metadata_tags)

    @_builtins.property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> Optional['InstanceMetadataOptionsHttpEndpoint']:
        """
        Enables or disables the HTTP metadata endpoint on your instances. If you specify a value of disabled, you cannot access your instance metadata.
        """
        return pulumi.get(self, "http_endpoint")

    @_builtins.property
    @pulumi.getter(name="httpProtocolIpv6")
    def http_protocol_ipv6(self) -> Optional['InstanceMetadataOptionsHttpProtocolIpv6']:
        """
        Enables or disables the IPv6 endpoint for the instance metadata service. To use this option, the instance must be a Nitro-based instance launched in a subnet that supports IPv6.
        """
        return pulumi.get(self, "http_protocol_ipv6")

    @_builtins.property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> Optional[_builtins.int]:
        """
        The number of network hops that the metadata token can travel. Maximum is 64.
        """
        return pulumi.get(self, "http_put_response_hop_limit")

    @_builtins.property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> Optional['InstanceMetadataOptionsHttpTokens']:
        """
        Indicates whether IMDSv2 is required.
        """
        return pulumi.get(self, "http_tokens")

    @_builtins.property
    @pulumi.getter(name="instanceMetadataTags")
    def instance_metadata_tags(self) -> Optional['InstanceMetadataOptionsInstanceMetadataTags']:
        """
        Indicates whether tags from the instance are propagated to the EBS volumes.
        """
        return pulumi.get(self, "instance_metadata_tags")


@pulumi.output_type
class InstanceNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceIndex":
            suggest = "device_index"
        elif key == "associateCarrierIpAddress":
            suggest = "associate_carrier_ip_address"
        elif key == "associatePublicIpAddress":
            suggest = "associate_public_ip_address"
        elif key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "enaSrdSpecification":
            suggest = "ena_srd_specification"
        elif key == "groupSet":
            suggest = "group_set"
        elif key == "ipv6AddressCount":
            suggest = "ipv6_address_count"
        elif key == "ipv6Addresses":
            suggest = "ipv6_addresses"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "privateIpAddress":
            suggest = "private_ip_address"
        elif key == "privateIpAddresses":
            suggest = "private_ip_addresses"
        elif key == "secondaryPrivateIpAddressCount":
            suggest = "secondary_private_ip_address_count"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_index: _builtins.str,
                 associate_carrier_ip_address: Optional[_builtins.bool] = None,
                 associate_public_ip_address: Optional[_builtins.bool] = None,
                 delete_on_termination: Optional[_builtins.bool] = None,
                 description: Optional[_builtins.str] = None,
                 ena_srd_specification: Optional['outputs.InstanceEnaSrdSpecification'] = None,
                 group_set: Optional[Sequence[_builtins.str]] = None,
                 ipv6_address_count: Optional[_builtins.int] = None,
                 ipv6_addresses: Optional[Sequence['outputs.InstanceIpv6Address']] = None,
                 network_interface_id: Optional[_builtins.str] = None,
                 private_ip_address: Optional[_builtins.str] = None,
                 private_ip_addresses: Optional[Sequence['outputs.InstancePrivateIpAddressSpecification']] = None,
                 secondary_private_ip_address_count: Optional[_builtins.int] = None,
                 subnet_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str device_index: The position of the network interface in the attachment order. A primary network interface has a device index of 0.
        :param _builtins.bool associate_carrier_ip_address: Not currently supported by AWS CloudFormation.
        :param _builtins.bool associate_public_ip_address: Indicates whether to assign a public IPv4 address to an instance you launch in a VPC.
        :param _builtins.bool delete_on_termination: If set to true, the interface is deleted when the instance is terminated.
        :param _builtins.str description: The description of the network interface.
        :param 'InstanceEnaSrdSpecification' ena_srd_specification: Configures ENA Express for UDP network traffic.
        :param Sequence[_builtins.str] group_set: The IDs of the security groups for the network interface.
        :param _builtins.int ipv6_address_count: A number of IPv6 addresses to assign to the network interface.
        :param Sequence['InstanceIpv6Address'] ipv6_addresses: The IPv6 addresses associated with the network interface.
        :param _builtins.str network_interface_id: The ID of the network interface.
        :param _builtins.str private_ip_address: The private IPv4 address of the network interface.
        :param Sequence['InstancePrivateIpAddressSpecification'] private_ip_addresses: One or more private IPv4 addresses to assign to the network interface.
        :param _builtins.int secondary_private_ip_address_count: The number of secondary private IPv4 addresses.
        :param _builtins.str subnet_id: The ID of the subnet.
        """
        pulumi.set(__self__, "device_index", device_index)
        if associate_carrier_ip_address is not None:
            pulumi.set(__self__, "associate_carrier_ip_address", associate_carrier_ip_address)
        if associate_public_ip_address is not None:
            pulumi.set(__self__, "associate_public_ip_address", associate_public_ip_address)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ena_srd_specification is not None:
            pulumi.set(__self__, "ena_srd_specification", ena_srd_specification)
        if group_set is not None:
            pulumi.set(__self__, "group_set", group_set)
        if ipv6_address_count is not None:
            pulumi.set(__self__, "ipv6_address_count", ipv6_address_count)
        if ipv6_addresses is not None:
            pulumi.set(__self__, "ipv6_addresses", ipv6_addresses)
        if network_interface_id is not None:
            pulumi.set(__self__, "network_interface_id", network_interface_id)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)
        if private_ip_addresses is not None:
            pulumi.set(__self__, "private_ip_addresses", private_ip_addresses)
        if secondary_private_ip_address_count is not None:
            pulumi.set(__self__, "secondary_private_ip_address_count", secondary_private_ip_address_count)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> _builtins.str:
        """
        The position of the network interface in the attachment order. A primary network interface has a device index of 0.
        """
        return pulumi.get(self, "device_index")

    @_builtins.property
    @pulumi.getter(name="associateCarrierIpAddress")
    def associate_carrier_ip_address(self) -> Optional[_builtins.bool]:
        """
        Not currently supported by AWS CloudFormation.
        """
        return pulumi.get(self, "associate_carrier_ip_address")

    @_builtins.property
    @pulumi.getter(name="associatePublicIpAddress")
    def associate_public_ip_address(self) -> Optional[_builtins.bool]:
        """
        Indicates whether to assign a public IPv4 address to an instance you launch in a VPC.
        """
        return pulumi.get(self, "associate_public_ip_address")

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[_builtins.bool]:
        """
        If set to true, the interface is deleted when the instance is terminated.
        """
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of the network interface.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="enaSrdSpecification")
    def ena_srd_specification(self) -> Optional['outputs.InstanceEnaSrdSpecification']:
        """
        Configures ENA Express for UDP network traffic.
        """
        return pulumi.get(self, "ena_srd_specification")

    @_builtins.property
    @pulumi.getter(name="groupSet")
    def group_set(self) -> Optional[Sequence[_builtins.str]]:
        """
        The IDs of the security groups for the network interface.
        """
        return pulumi.get(self, "group_set")

    @_builtins.property
    @pulumi.getter(name="ipv6AddressCount")
    def ipv6_address_count(self) -> Optional[_builtins.int]:
        """
        A number of IPv6 addresses to assign to the network interface.
        """
        return pulumi.get(self, "ipv6_address_count")

    @_builtins.property
    @pulumi.getter(name="ipv6Addresses")
    def ipv6_addresses(self) -> Optional[Sequence['outputs.InstanceIpv6Address']]:
        """
        The IPv6 addresses associated with the network interface.
        """
        return pulumi.get(self, "ipv6_addresses")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[_builtins.str]:
        """
        The ID of the network interface.
        """
        return pulumi.get(self, "network_interface_id")

    @_builtins.property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[_builtins.str]:
        """
        The private IPv4 address of the network interface.
        """
        return pulumi.get(self, "private_ip_address")

    @_builtins.property
    @pulumi.getter(name="privateIpAddresses")
    def private_ip_addresses(self) -> Optional[Sequence['outputs.InstancePrivateIpAddressSpecification']]:
        """
        One or more private IPv4 addresses to assign to the network interface.
        """
        return pulumi.get(self, "private_ip_addresses")

    @_builtins.property
    @pulumi.getter(name="secondaryPrivateIpAddressCount")
    def secondary_private_ip_address_count(self) -> Optional[_builtins.int]:
        """
        The number of secondary private IPv4 addresses.
        """
        return pulumi.get(self, "secondary_private_ip_address_count")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        The ID of the subnet.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class InstancePrivateDnsNameOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableResourceNameDnsARecord":
            suggest = "enable_resource_name_dns_a_record"
        elif key == "enableResourceNameDnsAaaaRecord":
            suggest = "enable_resource_name_dns_aaaa_record"
        elif key == "hostnameType":
            suggest = "hostname_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstancePrivateDnsNameOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstancePrivateDnsNameOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstancePrivateDnsNameOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_resource_name_dns_a_record: Optional[_builtins.bool] = None,
                 enable_resource_name_dns_aaaa_record: Optional[_builtins.bool] = None,
                 hostname_type: Optional['InstancePrivateDnsNameOptionsHostnameType'] = None):
        """
        :param _builtins.bool enable_resource_name_dns_a_record: Indicates whether to respond to DNS queries for instance hostnames with DNS A records. For more information, see Amazon EC2 instance hostname types in the Amazon Elastic Compute Cloud User Guide.
        :param _builtins.bool enable_resource_name_dns_aaaa_record: Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records. For more information, see Amazon EC2 instance hostname types in the Amazon Elastic Compute Cloud User Guide.
        :param 'InstancePrivateDnsNameOptionsHostnameType' hostname_type: The type of hostnames to assign to instances in the subnet at launch. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. For more information, see Amazon EC2 instance hostname types in the Amazon Elastic Compute Cloud User Guide.
        """
        if enable_resource_name_dns_a_record is not None:
            pulumi.set(__self__, "enable_resource_name_dns_a_record", enable_resource_name_dns_a_record)
        if enable_resource_name_dns_aaaa_record is not None:
            pulumi.set(__self__, "enable_resource_name_dns_aaaa_record", enable_resource_name_dns_aaaa_record)
        if hostname_type is not None:
            pulumi.set(__self__, "hostname_type", hostname_type)

    @_builtins.property
    @pulumi.getter(name="enableResourceNameDnsARecord")
    def enable_resource_name_dns_a_record(self) -> Optional[_builtins.bool]:
        """
        Indicates whether to respond to DNS queries for instance hostnames with DNS A records. For more information, see Amazon EC2 instance hostname types in the Amazon Elastic Compute Cloud User Guide.
        """
        return pulumi.get(self, "enable_resource_name_dns_a_record")

    @_builtins.property
    @pulumi.getter(name="enableResourceNameDnsAaaaRecord")
    def enable_resource_name_dns_aaaa_record(self) -> Optional[_builtins.bool]:
        """
        Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records. For more information, see Amazon EC2 instance hostname types in the Amazon Elastic Compute Cloud User Guide.
        """
        return pulumi.get(self, "enable_resource_name_dns_aaaa_record")

    @_builtins.property
    @pulumi.getter(name="hostnameType")
    def hostname_type(self) -> Optional['InstancePrivateDnsNameOptionsHostnameType']:
        """
        The type of hostnames to assign to instances in the subnet at launch. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. For more information, see Amazon EC2 instance hostname types in the Amazon Elastic Compute Cloud User Guide.
        """
        return pulumi.get(self, "hostname_type")


@pulumi.output_type
class InstancePrivateIpAddressSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIpAddress":
            suggest = "private_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstancePrivateIpAddressSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstancePrivateIpAddressSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstancePrivateIpAddressSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 primary: _builtins.bool,
                 private_ip_address: _builtins.str):
        """
        :param _builtins.bool primary: Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.
        :param _builtins.str private_ip_address: The private IPv4 addresses.
        """
        pulumi.set(__self__, "primary", primary)
        pulumi.set(__self__, "private_ip_address", private_ip_address)

    @_builtins.property
    @pulumi.getter
    def primary(self) -> _builtins.bool:
        """
        Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.
        """
        return pulumi.get(self, "primary")

    @_builtins.property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> _builtins.str:
        """
        The private IPv4 addresses.
        """
        return pulumi.get(self, "private_ip_address")


@pulumi.output_type
class InstanceSsmAssociation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "documentName":
            suggest = "document_name"
        elif key == "associationParameters":
            suggest = "association_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceSsmAssociation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceSsmAssociation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceSsmAssociation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 document_name: _builtins.str,
                 association_parameters: Optional[Sequence['outputs.InstanceAssociationParameter']] = None):
        """
        :param _builtins.str document_name: The name of an SSM document to associate with the instance.
        :param Sequence['InstanceAssociationParameter'] association_parameters: The input parameter values to use with the associated SSM document.
        """
        pulumi.set(__self__, "document_name", document_name)
        if association_parameters is not None:
            pulumi.set(__self__, "association_parameters", association_parameters)

    @_builtins.property
    @pulumi.getter(name="documentName")
    def document_name(self) -> _builtins.str:
        """
        The name of an SSM document to associate with the instance.
        """
        return pulumi.get(self, "document_name")

    @_builtins.property
    @pulumi.getter(name="associationParameters")
    def association_parameters(self) -> Optional[Sequence['outputs.InstanceAssociationParameter']]:
        """
        The input parameter values to use with the associated SSM document.
        """
        return pulumi.get(self, "association_parameters")


@pulumi.output_type
class InstanceState(dict):
    """
    The current state of the instance
    """
    def __init__(__self__, *,
                 code: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        The current state of the instance
        :param _builtins.str code: The state of the instance as a 16-bit unsigned integer.
        :param _builtins.str name: The current state of the instance.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[_builtins.str]:
        """
        The state of the instance as a 16-bit unsigned integer.
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The current state of the instance.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class InstanceVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "volumeId":
            suggest = "volume_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device: _builtins.str,
                 volume_id: _builtins.str):
        """
        :param _builtins.str device: The device name (for example, /dev/sdh or xvdh).
        :param _builtins.str volume_id: The ID of the EBS volume. The volume and instance must be within the same Availability Zone.
        """
        pulumi.set(__self__, "device", device)
        pulumi.set(__self__, "volume_id", volume_id)

    @_builtins.property
    @pulumi.getter
    def device(self) -> _builtins.str:
        """
        The device name (for example, /dev/sdh or xvdh).
        """
        return pulumi.get(self, "device")

    @_builtins.property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> _builtins.str:
        """
        The ID of the EBS volume. The volume and instance must be within the same Availability Zone.
        """
        return pulumi.get(self, "volume_id")


@pulumi.output_type
class IpamOperatingRegion(dict):
    """
    The regions IPAM is enabled for. Allows pools to be created in these regions, as well as enabling monitoring
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regionName":
            suggest = "region_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpamOperatingRegion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpamOperatingRegion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpamOperatingRegion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region_name: _builtins.str):
        """
        The regions IPAM is enabled for. Allows pools to be created in these regions, as well as enabling monitoring
        :param _builtins.str region_name: The name of the region.
        """
        pulumi.set(__self__, "region_name", region_name)

    @_builtins.property
    @pulumi.getter(name="regionName")
    def region_name(self) -> _builtins.str:
        """
        The name of the region.
        """
        return pulumi.get(self, "region_name")


@pulumi.output_type
class IpamOrganizationalUnitExclusion(dict):
    """
    If your IPAM is integrated with AWS Organizations and you add an organizational unit (OU) exclusion, IPAM will not manage the IP addresses in accounts in that OU exclusion.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "organizationsEntityPath":
            suggest = "organizations_entity_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpamOrganizationalUnitExclusion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpamOrganizationalUnitExclusion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpamOrganizationalUnitExclusion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 organizations_entity_path: _builtins.str):
        """
        If your IPAM is integrated with AWS Organizations and you add an organizational unit (OU) exclusion, IPAM will not manage the IP addresses in accounts in that OU exclusion.
        :param _builtins.str organizations_entity_path: An AWS Organizations entity path. Build the path for the OU(s) using AWS Organizations IDs separated by a '/'. Include all child OUs by ending the path with '/*'.
        """
        pulumi.set(__self__, "organizations_entity_path", organizations_entity_path)

    @_builtins.property
    @pulumi.getter(name="organizationsEntityPath")
    def organizations_entity_path(self) -> _builtins.str:
        """
        An AWS Organizations entity path. Build the path for the OU(s) using AWS Organizations IDs separated by a '/'. Include all child OUs by ending the path with '/*'.
        """
        return pulumi.get(self, "organizations_entity_path")


@pulumi.output_type
class IpamPoolProvisionedCidr(dict):
    """
    An address space to be inserted into this pool. All allocations must be made from this address space.
    """
    def __init__(__self__, *,
                 cidr: _builtins.str):
        """
        An address space to be inserted into this pool. All allocations must be made from this address space.
        :param _builtins.str cidr: The CIDR provisioned to the IPAM pool. A CIDR is a representation of an IP address and its associated network mask (or netmask) and refers to a range of IP addresses. An IPv4 CIDR example is `10.24.34.0/23` . An IPv6 CIDR example is `2001:DB8::/32` .
        """
        pulumi.set(__self__, "cidr", cidr)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> _builtins.str:
        """
        The CIDR provisioned to the IPAM pool. A CIDR is a representation of an IP address and its associated network mask (or netmask) and refers to a range of IP addresses. An IPv4 CIDR example is `10.24.34.0/23` . An IPv6 CIDR example is `2001:DB8::/32` .
        """
        return pulumi.get(self, "cidr")


@pulumi.output_type
class IpamPoolSourceResource(dict):
    """
    The resource associated with this pool's space. Depending on the ResourceType, setting a SourceResource changes which space can be provisioned in this pool and which types of resources can receive allocations
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceId":
            suggest = "resource_id"
        elif key == "resourceOwner":
            suggest = "resource_owner"
        elif key == "resourceRegion":
            suggest = "resource_region"
        elif key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpamPoolSourceResource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpamPoolSourceResource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpamPoolSourceResource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_id: _builtins.str,
                 resource_owner: _builtins.str,
                 resource_region: _builtins.str,
                 resource_type: _builtins.str):
        """
        The resource associated with this pool's space. Depending on the ResourceType, setting a SourceResource changes which space can be provisioned in this pool and which types of resources can receive allocations
        :param _builtins.str resource_id: The source resource ID.
        :param _builtins.str resource_owner: The source resource owner.
        :param _builtins.str resource_region: The source resource Region.
        :param _builtins.str resource_type: The source resource type.
        """
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_owner", resource_owner)
        pulumi.set(__self__, "resource_region", resource_region)
        pulumi.set(__self__, "resource_type", resource_type)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> _builtins.str:
        """
        The source resource ID.
        """
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="resourceOwner")
    def resource_owner(self) -> _builtins.str:
        """
        The source resource owner.
        """
        return pulumi.get(self, "resource_owner")

    @_builtins.property
    @pulumi.getter(name="resourceRegion")
    def resource_region(self) -> _builtins.str:
        """
        The source resource Region.
        """
        return pulumi.get(self, "resource_region")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        """
        The source resource type.
        """
        return pulumi.get(self, "resource_type")


@pulumi.output_type
class IpamPoolTag(dict):
    """
    A key-value pair to associate with a resource.
    """
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        A key-value pair to associate with a resource.
        :param _builtins.str key: The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        :param _builtins.str value: The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IpamResourceDiscoveryIpamOperatingRegion(dict):
    """
    The regions IPAM Resource Discovery is enabled for. Allows for monitoring.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regionName":
            suggest = "region_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpamResourceDiscoveryIpamOperatingRegion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpamResourceDiscoveryIpamOperatingRegion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpamResourceDiscoveryIpamOperatingRegion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region_name: _builtins.str):
        """
        The regions IPAM Resource Discovery is enabled for. Allows for monitoring.
        :param _builtins.str region_name: The name of the region.
        """
        pulumi.set(__self__, "region_name", region_name)

    @_builtins.property
    @pulumi.getter(name="regionName")
    def region_name(self) -> _builtins.str:
        """
        The name of the region.
        """
        return pulumi.get(self, "region_name")


@pulumi.output_type
class IpamResourceDiscoveryOrganizationalUnitExclusion(dict):
    """
    If your IPAM is integrated with AWS Organizations and you add an organizational unit (OU) exclusion, IPAM will not manage the IP addresses in accounts in that OU exclusion.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "organizationsEntityPath":
            suggest = "organizations_entity_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpamResourceDiscoveryOrganizationalUnitExclusion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpamResourceDiscoveryOrganizationalUnitExclusion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpamResourceDiscoveryOrganizationalUnitExclusion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 organizations_entity_path: _builtins.str):
        """
        If your IPAM is integrated with AWS Organizations and you add an organizational unit (OU) exclusion, IPAM will not manage the IP addresses in accounts in that OU exclusion.
        :param _builtins.str organizations_entity_path: An AWS Organizations entity path. Build the path for the OU(s) using AWS Organizations IDs separated by a '/'. Include all child OUs by ending the path with '/*'.
        """
        pulumi.set(__self__, "organizations_entity_path", organizations_entity_path)

    @_builtins.property
    @pulumi.getter(name="organizationsEntityPath")
    def organizations_entity_path(self) -> _builtins.str:
        """
        An AWS Organizations entity path. Build the path for the OU(s) using AWS Organizations IDs separated by a '/'. Include all child OUs by ending the path with '/*'.
        """
        return pulumi.get(self, "organizations_entity_path")


@pulumi.output_type
class LaunchTemplateAcceleratorCount(dict):
    """
    The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.
    """
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        """
        The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.
        :param _builtins.int max: The maximum number of accelerators. To specify no maximum limit, omit this parameter. To exclude accelerator-enabled instance types, set ``Max`` to ``0``.
        :param _builtins.int min: The minimum number of accelerators. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        """
        The maximum number of accelerators. To specify no maximum limit, omit this parameter. To exclude accelerator-enabled instance types, set ``Max`` to ``0``.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        """
        The minimum number of accelerators. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateAcceleratorTotalMemoryMiB(dict):
    """
    The minimum and maximum amount of total accelerator memory, in MiB.
    """
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        """
        The minimum and maximum amount of total accelerator memory, in MiB.
        :param _builtins.int max: The maximum amount of accelerator memory, in MiB. To specify no maximum limit, omit this parameter.
        :param _builtins.int min: The minimum amount of accelerator memory, in MiB. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        """
        The maximum amount of accelerator memory, in MiB. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        """
        The minimum amount of accelerator memory, in MiB. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateBaselineEbsBandwidthMbps(dict):
    """
    The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see [Amazon EBSoptimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the *Amazon EC2 User Guide*.
    """
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        """
        The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see [Amazon EBSoptimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the *Amazon EC2 User Guide*.
        :param _builtins.int max: The maximum baseline bandwidth, in Mbps. To specify no maximum limit, omit this parameter.
        :param _builtins.int min: The minimum baseline bandwidth, in Mbps. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        """
        The maximum baseline bandwidth, in Mbps. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        """
        The minimum baseline bandwidth, in Mbps. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateBaselinePerformanceFactors(dict):
    """
    The baseline performance to consider, using an instance family as a baseline reference. The instance family establishes the lowest acceptable level of performance. Amazon EC2 uses this baseline to guide instance type selection, but there is no guarantee that the selected instance types will always exceed the baseline for every application.
     Currently, this parameter only supports CPU performance as a baseline performance factor. For example, specifying ``c6i`` would use the CPU performance of the ``c6i`` family as the baseline reference.
    """
    def __init__(__self__, *,
                 cpu: Optional['outputs.LaunchTemplateCpu'] = None):
        """
        The baseline performance to consider, using an instance family as a baseline reference. The instance family establishes the lowest acceptable level of performance. Amazon EC2 uses this baseline to guide instance type selection, but there is no guarantee that the selected instance types will always exceed the baseline for every application.
         Currently, this parameter only supports CPU performance as a baseline performance factor. For example, specifying ``c6i`` would use the CPU performance of the ``c6i`` family as the baseline reference.
        :param 'LaunchTemplateCpu' cpu: The CPU performance to consider, using an instance family as the baseline reference.
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional['outputs.LaunchTemplateCpu']:
        """
        The CPU performance to consider, using an instance family as the baseline reference.
        """
        return pulumi.get(self, "cpu")


@pulumi.output_type
class LaunchTemplateBlockDeviceMapping(dict):
    """
    Specifies a block device mapping for a launch template. You must specify ``DeviceName`` plus exactly one of the following properties: ``Ebs``, ``NoDevice``, or ``VirtualName``.
     ``BlockDeviceMapping`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "noDevice":
            suggest = "no_device"
        elif key == "virtualName":
            suggest = "virtual_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateBlockDeviceMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateBlockDeviceMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateBlockDeviceMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: Optional[_builtins.str] = None,
                 ebs: Optional['outputs.LaunchTemplateEbs'] = None,
                 no_device: Optional[_builtins.str] = None,
                 virtual_name: Optional[_builtins.str] = None):
        """
        Specifies a block device mapping for a launch template. You must specify ``DeviceName`` plus exactly one of the following properties: ``Ebs``, ``NoDevice``, or ``VirtualName``.
         ``BlockDeviceMapping`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        :param _builtins.str device_name: The device name (for example, /dev/sdh or xvdh).
        :param 'LaunchTemplateEbs' ebs: Parameters used to automatically set up EBS volumes when the instance is launched.
        :param _builtins.str no_device: To omit the device from the block device mapping, specify an empty string.
        :param _builtins.str virtual_name: The virtual device name (ephemeralN). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for ephemeral0 and ephemeral1. The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.
        """
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if ebs is not None:
            pulumi.set(__self__, "ebs", ebs)
        if no_device is not None:
            pulumi.set(__self__, "no_device", no_device)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[_builtins.str]:
        """
        The device name (for example, /dev/sdh or xvdh).
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter
    def ebs(self) -> Optional['outputs.LaunchTemplateEbs']:
        """
        Parameters used to automatically set up EBS volumes when the instance is launched.
        """
        return pulumi.get(self, "ebs")

    @_builtins.property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[_builtins.str]:
        """
        To omit the device from the block device mapping, specify an empty string.
        """
        return pulumi.get(self, "no_device")

    @_builtins.property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[_builtins.str]:
        """
        The virtual device name (ephemeralN). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for ephemeral0 and ephemeral1. The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.
        """
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class LaunchTemplateCapacityReservationSpecification(dict):
    """
    Specifies an instance's Capacity Reservation targeting option. You can specify only one option at a time.
     ``CapacityReservationSpecification`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityReservationPreference":
            suggest = "capacity_reservation_preference"
        elif key == "capacityReservationTarget":
            suggest = "capacity_reservation_target"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateCapacityReservationSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateCapacityReservationSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateCapacityReservationSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_reservation_preference: Optional[_builtins.str] = None,
                 capacity_reservation_target: Optional['outputs.LaunchTemplateCapacityReservationTarget'] = None):
        """
        Specifies an instance's Capacity Reservation targeting option. You can specify only one option at a time.
         ``CapacityReservationSpecification`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        :param _builtins.str capacity_reservation_preference: Indicates the instance's Capacity Reservation preferences. Possible preferences include:
                 +  ``capacity-reservations-only`` - The instance will only run in a Capacity Reservation or Capacity Reservation group. If capacity isn't available, the instance will fail to launch.
                 +  ``open`` - The instance can run in any ``open`` Capacity Reservation that has matching attributes (instance type, platform, Availability Zone, tenancy).
                 +  ``none`` - The instance avoids running in a Capacity Reservation even if one is available. The instance runs in On-Demand capacity.
        :param 'LaunchTemplateCapacityReservationTarget' capacity_reservation_target: Information about the target Capacity Reservation or Capacity Reservation group.
        """
        if capacity_reservation_preference is not None:
            pulumi.set(__self__, "capacity_reservation_preference", capacity_reservation_preference)
        if capacity_reservation_target is not None:
            pulumi.set(__self__, "capacity_reservation_target", capacity_reservation_target)

    @_builtins.property
    @pulumi.getter(name="capacityReservationPreference")
    def capacity_reservation_preference(self) -> Optional[_builtins.str]:
        """
        Indicates the instance's Capacity Reservation preferences. Possible preferences include:
          +  ``capacity-reservations-only`` - The instance will only run in a Capacity Reservation or Capacity Reservation group. If capacity isn't available, the instance will fail to launch.
          +  ``open`` - The instance can run in any ``open`` Capacity Reservation that has matching attributes (instance type, platform, Availability Zone, tenancy).
          +  ``none`` - The instance avoids running in a Capacity Reservation even if one is available. The instance runs in On-Demand capacity.
        """
        return pulumi.get(self, "capacity_reservation_preference")

    @_builtins.property
    @pulumi.getter(name="capacityReservationTarget")
    def capacity_reservation_target(self) -> Optional['outputs.LaunchTemplateCapacityReservationTarget']:
        """
        Information about the target Capacity Reservation or Capacity Reservation group.
        """
        return pulumi.get(self, "capacity_reservation_target")


@pulumi.output_type
class LaunchTemplateCapacityReservationTarget(dict):
    """
    Specifies a target Capacity Reservation.
     ``CapacityReservationTarget`` is a property of the [Amazon EC2 LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html) property type.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityReservationId":
            suggest = "capacity_reservation_id"
        elif key == "capacityReservationResourceGroupArn":
            suggest = "capacity_reservation_resource_group_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateCapacityReservationTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateCapacityReservationTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateCapacityReservationTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_reservation_id: Optional[_builtins.str] = None,
                 capacity_reservation_resource_group_arn: Optional[_builtins.str] = None):
        """
        Specifies a target Capacity Reservation.
         ``CapacityReservationTarget`` is a property of the [Amazon EC2 LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html) property type.
        :param _builtins.str capacity_reservation_id: The ID of the Capacity Reservation in which to run the instance.
        :param _builtins.str capacity_reservation_resource_group_arn: The ARN of the Capacity Reservation resource group in which to run the instance.
        """
        if capacity_reservation_id is not None:
            pulumi.set(__self__, "capacity_reservation_id", capacity_reservation_id)
        if capacity_reservation_resource_group_arn is not None:
            pulumi.set(__self__, "capacity_reservation_resource_group_arn", capacity_reservation_resource_group_arn)

    @_builtins.property
    @pulumi.getter(name="capacityReservationId")
    def capacity_reservation_id(self) -> Optional[_builtins.str]:
        """
        The ID of the Capacity Reservation in which to run the instance.
        """
        return pulumi.get(self, "capacity_reservation_id")

    @_builtins.property
    @pulumi.getter(name="capacityReservationResourceGroupArn")
    def capacity_reservation_resource_group_arn(self) -> Optional[_builtins.str]:
        """
        The ARN of the Capacity Reservation resource group in which to run the instance.
        """
        return pulumi.get(self, "capacity_reservation_resource_group_arn")


@pulumi.output_type
class LaunchTemplateConnectionTrackingSpecification(dict):
    """
    A security group connection tracking specification that enables you to set the idle timeout for connection tracking on an Elastic network interface. For more information, see [Connection tracking timeouts](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-connection-tracking.html#connection-tracking-timeouts) in the *Amazon EC2 User Guide*.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tcpEstablishedTimeout":
            suggest = "tcp_established_timeout"
        elif key == "udpStreamTimeout":
            suggest = "udp_stream_timeout"
        elif key == "udpTimeout":
            suggest = "udp_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateConnectionTrackingSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateConnectionTrackingSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateConnectionTrackingSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tcp_established_timeout: Optional[_builtins.int] = None,
                 udp_stream_timeout: Optional[_builtins.int] = None,
                 udp_timeout: Optional[_builtins.int] = None):
        """
        A security group connection tracking specification that enables you to set the idle timeout for connection tracking on an Elastic network interface. For more information, see [Connection tracking timeouts](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-connection-tracking.html#connection-tracking-timeouts) in the *Amazon EC2 User Guide*.
        :param _builtins.int tcp_established_timeout: Timeout (in seconds) for idle TCP connections in an established state. Min: 60 seconds. Max: 432000 seconds (5 days). Default: 432000 seconds. Recommended: Less than 432000 seconds.
        :param _builtins.int udp_stream_timeout: Timeout (in seconds) for idle UDP flows classified as streams which have seen more than one request-response transaction. Min: 60 seconds. Max: 180 seconds (3 minutes). Default: 180 seconds.
        :param _builtins.int udp_timeout: Timeout (in seconds) for idle UDP flows that have seen traffic only in a single direction or a single request-response transaction. Min: 30 seconds. Max: 60 seconds. Default: 30 seconds.
        """
        if tcp_established_timeout is not None:
            pulumi.set(__self__, "tcp_established_timeout", tcp_established_timeout)
        if udp_stream_timeout is not None:
            pulumi.set(__self__, "udp_stream_timeout", udp_stream_timeout)
        if udp_timeout is not None:
            pulumi.set(__self__, "udp_timeout", udp_timeout)

    @_builtins.property
    @pulumi.getter(name="tcpEstablishedTimeout")
    def tcp_established_timeout(self) -> Optional[_builtins.int]:
        """
        Timeout (in seconds) for idle TCP connections in an established state. Min: 60 seconds. Max: 432000 seconds (5 days). Default: 432000 seconds. Recommended: Less than 432000 seconds.
        """
        return pulumi.get(self, "tcp_established_timeout")

    @_builtins.property
    @pulumi.getter(name="udpStreamTimeout")
    def udp_stream_timeout(self) -> Optional[_builtins.int]:
        """
        Timeout (in seconds) for idle UDP flows classified as streams which have seen more than one request-response transaction. Min: 60 seconds. Max: 180 seconds (3 minutes). Default: 180 seconds.
        """
        return pulumi.get(self, "udp_stream_timeout")

    @_builtins.property
    @pulumi.getter(name="udpTimeout")
    def udp_timeout(self) -> Optional[_builtins.int]:
        """
        Timeout (in seconds) for idle UDP flows that have seen traffic only in a single direction or a single request-response transaction. Min: 30 seconds. Max: 60 seconds. Default: 30 seconds.
        """
        return pulumi.get(self, "udp_timeout")


@pulumi.output_type
class LaunchTemplateCpu(dict):
    """
    Specifies the CPU performance to consider when using an instance family as the baseline reference.
    """
    def __init__(__self__, *,
                 references: Optional[Sequence['outputs.LaunchTemplateReference']] = None):
        """
        Specifies the CPU performance to consider when using an instance family as the baseline reference.
        :param Sequence['LaunchTemplateReference'] references: The instance family to use as the baseline reference for CPU performance. All instance types that match your specified attributes are compared against the CPU performance of the referenced instance family, regardless of CPU manufacturer or architecture differences.
        """
        if references is not None:
            pulumi.set(__self__, "references", references)

    @_builtins.property
    @pulumi.getter
    def references(self) -> Optional[Sequence['outputs.LaunchTemplateReference']]:
        """
        The instance family to use as the baseline reference for CPU performance. All instance types that match your specified attributes are compared against the CPU performance of the referenced instance family, regardless of CPU manufacturer or architecture differences.
        """
        return pulumi.get(self, "references")


@pulumi.output_type
class LaunchTemplateCpuOptions(dict):
    """
    Specifies the CPU options for an instance. For more information, see [Optimize CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the *User Guide*.
     ``CpuOptions`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "amdSevSnp":
            suggest = "amd_sev_snp"
        elif key == "coreCount":
            suggest = "core_count"
        elif key == "threadsPerCore":
            suggest = "threads_per_core"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateCpuOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateCpuOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateCpuOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amd_sev_snp: Optional['LaunchTemplateCpuOptionsAmdSevSnp'] = None,
                 core_count: Optional[_builtins.int] = None,
                 threads_per_core: Optional[_builtins.int] = None):
        """
        Specifies the CPU options for an instance. For more information, see [Optimize CPU options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the *User Guide*.
         ``CpuOptions`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        :param 'LaunchTemplateCpuOptionsAmdSevSnp' amd_sev_snp: Indicates whether to enable the instance for AMD SEV-SNP. AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only. For more information, see [AMD SEV-SNP for Amazon EC2 instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/sev-snp.html).
        :param _builtins.int core_count: The number of CPU cores for the instance.
        :param _builtins.int threads_per_core: The number of threads per CPU core. To disable multithreading for the instance, specify a value of ``1``. Otherwise, specify the default value of ``2``.
        """
        if amd_sev_snp is not None:
            pulumi.set(__self__, "amd_sev_snp", amd_sev_snp)
        if core_count is not None:
            pulumi.set(__self__, "core_count", core_count)
        if threads_per_core is not None:
            pulumi.set(__self__, "threads_per_core", threads_per_core)

    @_builtins.property
    @pulumi.getter(name="amdSevSnp")
    def amd_sev_snp(self) -> Optional['LaunchTemplateCpuOptionsAmdSevSnp']:
        """
        Indicates whether to enable the instance for AMD SEV-SNP. AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only. For more information, see [AMD SEV-SNP for Amazon EC2 instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/sev-snp.html).
        """
        return pulumi.get(self, "amd_sev_snp")

    @_builtins.property
    @pulumi.getter(name="coreCount")
    def core_count(self) -> Optional[_builtins.int]:
        """
        The number of CPU cores for the instance.
        """
        return pulumi.get(self, "core_count")

    @_builtins.property
    @pulumi.getter(name="threadsPerCore")
    def threads_per_core(self) -> Optional[_builtins.int]:
        """
        The number of threads per CPU core. To disable multithreading for the instance, specify a value of ``1``. Otherwise, specify the default value of ``2``.
        """
        return pulumi.get(self, "threads_per_core")


@pulumi.output_type
class LaunchTemplateCreditSpecification(dict):
    """
    Specifies the credit option for CPU usage of a T2, T3, or T3a instance.
     ``CreditSpecification`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuCredits":
            suggest = "cpu_credits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateCreditSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateCreditSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateCreditSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_credits: Optional[_builtins.str] = None):
        """
        Specifies the credit option for CPU usage of a T2, T3, or T3a instance.
         ``CreditSpecification`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        :param _builtins.str cpu_credits: The credit option for CPU usage of a T instance.
                Valid values: ``standard`` | ``unlimited``
        """
        if cpu_credits is not None:
            pulumi.set(__self__, "cpu_credits", cpu_credits)

    @_builtins.property
    @pulumi.getter(name="cpuCredits")
    def cpu_credits(self) -> Optional[_builtins.str]:
        """
        The credit option for CPU usage of a T instance.
         Valid values: ``standard`` | ``unlimited``
        """
        return pulumi.get(self, "cpu_credits")


@pulumi.output_type
class LaunchTemplateData(dict):
    """
    The information to include in the launch template.
      You must specify at least one parameter for the launch template data.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockDeviceMappings":
            suggest = "block_device_mappings"
        elif key == "capacityReservationSpecification":
            suggest = "capacity_reservation_specification"
        elif key == "cpuOptions":
            suggest = "cpu_options"
        elif key == "creditSpecification":
            suggest = "credit_specification"
        elif key == "disableApiStop":
            suggest = "disable_api_stop"
        elif key == "disableApiTermination":
            suggest = "disable_api_termination"
        elif key == "ebsOptimized":
            suggest = "ebs_optimized"
        elif key == "enclaveOptions":
            suggest = "enclave_options"
        elif key == "hibernationOptions":
            suggest = "hibernation_options"
        elif key == "iamInstanceProfile":
            suggest = "iam_instance_profile"
        elif key == "imageId":
            suggest = "image_id"
        elif key == "instanceInitiatedShutdownBehavior":
            suggest = "instance_initiated_shutdown_behavior"
        elif key == "instanceMarketOptions":
            suggest = "instance_market_options"
        elif key == "instanceRequirements":
            suggest = "instance_requirements"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "kernelId":
            suggest = "kernel_id"
        elif key == "keyName":
            suggest = "key_name"
        elif key == "licenseSpecifications":
            suggest = "license_specifications"
        elif key == "maintenanceOptions":
            suggest = "maintenance_options"
        elif key == "metadataOptions":
            suggest = "metadata_options"
        elif key == "networkInterfaces":
            suggest = "network_interfaces"
        elif key == "networkPerformanceOptions":
            suggest = "network_performance_options"
        elif key == "privateDnsNameOptions":
            suggest = "private_dns_name_options"
        elif key == "ramDiskId":
            suggest = "ram_disk_id"
        elif key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "securityGroups":
            suggest = "security_groups"
        elif key == "tagSpecifications":
            suggest = "tag_specifications"
        elif key == "userData":
            suggest = "user_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 block_device_mappings: Optional[Sequence['outputs.LaunchTemplateBlockDeviceMapping']] = None,
                 capacity_reservation_specification: Optional['outputs.LaunchTemplateCapacityReservationSpecification'] = None,
                 cpu_options: Optional['outputs.LaunchTemplateCpuOptions'] = None,
                 credit_specification: Optional['outputs.LaunchTemplateCreditSpecification'] = None,
                 disable_api_stop: Optional[_builtins.bool] = None,
                 disable_api_termination: Optional[_builtins.bool] = None,
                 ebs_optimized: Optional[_builtins.bool] = None,
                 enclave_options: Optional['outputs.LaunchTemplateEnclaveOptions'] = None,
                 hibernation_options: Optional['outputs.LaunchTemplateHibernationOptions'] = None,
                 iam_instance_profile: Optional['outputs.LaunchTemplateIamInstanceProfile'] = None,
                 image_id: Optional[_builtins.str] = None,
                 instance_initiated_shutdown_behavior: Optional[_builtins.str] = None,
                 instance_market_options: Optional['outputs.LaunchTemplateInstanceMarketOptions'] = None,
                 instance_requirements: Optional['outputs.LaunchTemplateInstanceRequirements'] = None,
                 instance_type: Optional[_builtins.str] = None,
                 kernel_id: Optional[_builtins.str] = None,
                 key_name: Optional[_builtins.str] = None,
                 license_specifications: Optional[Sequence['outputs.LaunchTemplateLicenseSpecification']] = None,
                 maintenance_options: Optional['outputs.LaunchTemplateMaintenanceOptions'] = None,
                 metadata_options: Optional['outputs.LaunchTemplateMetadataOptions'] = None,
                 monitoring: Optional['outputs.LaunchTemplateMonitoring'] = None,
                 network_interfaces: Optional[Sequence['outputs.LaunchTemplateNetworkInterface']] = None,
                 network_performance_options: Optional['outputs.LaunchTemplateNetworkPerformanceOptions'] = None,
                 placement: Optional['outputs.LaunchTemplatePlacement'] = None,
                 private_dns_name_options: Optional['outputs.LaunchTemplatePrivateDnsNameOptions'] = None,
                 ram_disk_id: Optional[_builtins.str] = None,
                 security_group_ids: Optional[Sequence[_builtins.str]] = None,
                 security_groups: Optional[Sequence[_builtins.str]] = None,
                 tag_specifications: Optional[Sequence['outputs.TagSpecification']] = None,
                 user_data: Optional[_builtins.str] = None):
        """
        The information to include in the launch template.
          You must specify at least one parameter for the launch template data.
        :param Sequence['LaunchTemplateBlockDeviceMapping'] block_device_mappings: The block device mapping.
        :param 'LaunchTemplateCapacityReservationSpecification' capacity_reservation_specification: The Capacity Reservation targeting option. If you do not specify this parameter, the instance's Capacity Reservation preference defaults to ``open``, which enables it to run in any open Capacity Reservation that has matching attributes (instance type, platform, Availability Zone).
        :param 'LaunchTemplateCpuOptions' cpu_options: The CPU options for the instance. For more information, see [CPU options for Amazon EC2 instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the *Amazon EC2 User Guide*.
        :param 'LaunchTemplateCreditSpecification' credit_specification: The credit option for CPU usage of the instance. Valid only for T instances.
        :param _builtins.bool disable_api_stop: Indicates whether to enable the instance for stop protection. For more information, see [Enable stop protection for your EC2 instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-stop-protection.html) in the *Amazon EC2 User Guide*.
        :param _builtins.bool disable_api_termination: Indicates whether termination protection is enabled for the instance. The default is ``false``, which means that you can terminate the instance using the Amazon EC2 console, command line tools, or API. You can enable termination protection when you launch an instance, while the instance is running, or while the instance is stopped.
        :param _builtins.bool ebs_optimized: Indicates whether the instance is optimized for Amazon EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.
        :param 'LaunchTemplateEnclaveOptions' enclave_options: Indicates whether the instance is enabled for AWS Nitro Enclaves. For more information, see [What is Nitro Enclaves?](https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html) in the *Nitro Enclaves User Guide*.
                You can't enable AWS Nitro Enclaves and hibernation on the same instance.
        :param 'LaunchTemplateHibernationOptions' hibernation_options: Indicates whether an instance is enabled for hibernation. This parameter is valid only if the instance meets the [hibernation prerequisites](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/hibernating-prerequisites.html). For more information, see [Hibernate your Amazon EC2 instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html) in the *Amazon EC2 User Guide*.
        :param 'LaunchTemplateIamInstanceProfile' iam_instance_profile: The name or Amazon Resource Name (ARN) of an IAM instance profile.
        :param _builtins.str image_id: The ID of the AMI. Alternatively, you can specify a Systems Manager parameter, which will resolve to an AMI ID on launch.
                Valid formats:
                 +   ``ami-0ac394d6a3example`` 
                 +   ``resolve:ssm:parameter-name`` 
                 +   ``resolve:ssm:parameter-name:version-number`` 
                 +   ``resolve:ssm:parameter-name:label`` 
                 
                For more information, see [Use a Systems Manager parameter to find an AMI](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/finding-an-ami.html#using-systems-manager-parameter-to-find-AMI) in the *Amazon Elastic Compute Cloud User Guide*.
        :param _builtins.str instance_initiated_shutdown_behavior: Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
                Default: ``stop``
        :param 'LaunchTemplateInstanceMarketOptions' instance_market_options: The market (purchasing) option for the instances.
        :param 'LaunchTemplateInstanceRequirements' instance_requirements: The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with these attributes.
                You must specify ``VCpuCount`` and ``MemoryMiB``. All other attributes are optional. Any unspecified optional attribute is set to its default.
                When you specify multiple attributes, you get instance types that satisfy all of the specified attributes. If you specify multiple values for an attribute, you get instance types that satisfy any of the specified values.
                To limit the list of instance types from which Amazon EC2 can identify matching instance types, you can use one of the following parameters, but not both in the same request:
                 +  ``AllowedInstanceTypes`` - The instance types to include in the list. All other instance types are ignored, even if they match your specified attributes.
                 +  ``ExcludedInstanceTypes`` - The instance types to exclude from the list, even if they match your specified attributes.
                 
                 If you specify ``InstanceRequirements``, you can't specify ``InstanceType``.
                Attribute-based instance type selection is only supported when using Auto Scaling groups, EC2 Fleet, and Spot Fleet to launch instances. If you plan to use the launch template in the [launch instance wizard](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-instance-wizard.html), or with the [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) API or [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html)AWS CloudFormation resource, you can't specify ``InstanceRequirements``.
                 For more information, see [Specify attributes for instance type selection for EC2 Fleet or Spot Fleet](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html) and [Spot placement score](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html) in the *Amazon EC2 User Guide*.
        :param _builtins.str instance_type: The instance type. For more information, see [Amazon EC2 instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide*.
                If you specify ``InstanceType``, you can't specify ``InstanceRequirements``.
        :param _builtins.str kernel_id: The ID of the kernel.
                We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [User Provided Kernels](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide*.
        :param _builtins.str key_name: The name of the key pair. You can create a key pair using [CreateKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html) or [ImportKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html).
                 If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.
        :param Sequence['LaunchTemplateLicenseSpecification'] license_specifications: The license configurations.
        :param 'LaunchTemplateMaintenanceOptions' maintenance_options: The maintenance options of your instance.
        :param 'LaunchTemplateMetadataOptions' metadata_options: The metadata options for the instance. For more information, see [Configure the Instance Metadata Service options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/configuring-instance-metadata-options.html) in the *Amazon EC2 User Guide*.
        :param 'LaunchTemplateMonitoring' monitoring: The monitoring for the instance.
        :param Sequence['LaunchTemplateNetworkInterface'] network_interfaces: The network interfaces for the instance.
        :param 'LaunchTemplateNetworkPerformanceOptions' network_performance_options: The settings for the network performance options for the instance. For more information, see [EC2 instance bandwidth weighting configuration](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/configure-bandwidth-weighting.html).
        :param 'LaunchTemplatePlacement' placement: The placement for the instance.
        :param 'LaunchTemplatePrivateDnsNameOptions' private_dns_name_options: The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries should be handled. For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *User Guide*.
        :param _builtins.str ram_disk_id: The ID of the RAM disk.
                 We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [User provided kernels](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide*.
        :param Sequence[_builtins.str] security_group_ids: The IDs of the security groups. You can specify the IDs of existing security groups and references to resources created by the stack template.
                If you specify a network interface, you must specify any security groups as part of the network interface instead.
        :param Sequence[_builtins.str] security_groups: The names of the security groups. For a nondefault VPC, you must use security group IDs instead.
                If you specify a network interface, you must specify any security groups as part of the network interface instead of using this parameter.
        :param Sequence['TagSpecification'] tag_specifications: The tags to apply to resources that are created during instance launch.
                To tag the launch template itself, use [TagSpecifications](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#cfn-ec2-launchtemplate-tagspecifications).
        :param _builtins.str user_data: The user data to make available to the instance. You must provide base64-encoded text. User data is limited to 16 KB. For more information, see [Run commands when you launch an EC2 instance with user data input](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html) in the *Amazon EC2 User Guide*.
                If you are creating the launch template for use with BATCH, the user data must be provided in the [MIME multi-part archive format](https://docs.aws.amazon.com/https://cloudinit.readthedocs.io/en/latest/topics/format.html#mime-multi-part-archive). For more information, see [Amazon EC2 user data in launch templates](https://docs.aws.amazon.com/batch/latest/userguide/launch-templates.html#lt-user-data) in the *User Guide*.
        """
        if block_device_mappings is not None:
            pulumi.set(__self__, "block_device_mappings", block_device_mappings)
        if capacity_reservation_specification is not None:
            pulumi.set(__self__, "capacity_reservation_specification", capacity_reservation_specification)
        if cpu_options is not None:
            pulumi.set(__self__, "cpu_options", cpu_options)
        if credit_specification is not None:
            pulumi.set(__self__, "credit_specification", credit_specification)
        if disable_api_stop is not None:
            pulumi.set(__self__, "disable_api_stop", disable_api_stop)
        if disable_api_termination is not None:
            pulumi.set(__self__, "disable_api_termination", disable_api_termination)
        if ebs_optimized is not None:
            pulumi.set(__self__, "ebs_optimized", ebs_optimized)
        if enclave_options is not None:
            pulumi.set(__self__, "enclave_options", enclave_options)
        if hibernation_options is not None:
            pulumi.set(__self__, "hibernation_options", hibernation_options)
        if iam_instance_profile is not None:
            pulumi.set(__self__, "iam_instance_profile", iam_instance_profile)
        if image_id is not None:
            pulumi.set(__self__, "image_id", image_id)
        if instance_initiated_shutdown_behavior is not None:
            pulumi.set(__self__, "instance_initiated_shutdown_behavior", instance_initiated_shutdown_behavior)
        if instance_market_options is not None:
            pulumi.set(__self__, "instance_market_options", instance_market_options)
        if instance_requirements is not None:
            pulumi.set(__self__, "instance_requirements", instance_requirements)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if kernel_id is not None:
            pulumi.set(__self__, "kernel_id", kernel_id)
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if license_specifications is not None:
            pulumi.set(__self__, "license_specifications", license_specifications)
        if maintenance_options is not None:
            pulumi.set(__self__, "maintenance_options", maintenance_options)
        if metadata_options is not None:
            pulumi.set(__self__, "metadata_options", metadata_options)
        if monitoring is not None:
            pulumi.set(__self__, "monitoring", monitoring)
        if network_interfaces is not None:
            pulumi.set(__self__, "network_interfaces", network_interfaces)
        if network_performance_options is not None:
            pulumi.set(__self__, "network_performance_options", network_performance_options)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if private_dns_name_options is not None:
            pulumi.set(__self__, "private_dns_name_options", private_dns_name_options)
        if ram_disk_id is not None:
            pulumi.set(__self__, "ram_disk_id", ram_disk_id)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if tag_specifications is not None:
            pulumi.set(__self__, "tag_specifications", tag_specifications)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)

    @_builtins.property
    @pulumi.getter(name="blockDeviceMappings")
    def block_device_mappings(self) -> Optional[Sequence['outputs.LaunchTemplateBlockDeviceMapping']]:
        """
        The block device mapping.
        """
        return pulumi.get(self, "block_device_mappings")

    @_builtins.property
    @pulumi.getter(name="capacityReservationSpecification")
    def capacity_reservation_specification(self) -> Optional['outputs.LaunchTemplateCapacityReservationSpecification']:
        """
        The Capacity Reservation targeting option. If you do not specify this parameter, the instance's Capacity Reservation preference defaults to ``open``, which enables it to run in any open Capacity Reservation that has matching attributes (instance type, platform, Availability Zone).
        """
        return pulumi.get(self, "capacity_reservation_specification")

    @_builtins.property
    @pulumi.getter(name="cpuOptions")
    def cpu_options(self) -> Optional['outputs.LaunchTemplateCpuOptions']:
        """
        The CPU options for the instance. For more information, see [CPU options for Amazon EC2 instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-optimize-cpu.html) in the *Amazon EC2 User Guide*.
        """
        return pulumi.get(self, "cpu_options")

    @_builtins.property
    @pulumi.getter(name="creditSpecification")
    def credit_specification(self) -> Optional['outputs.LaunchTemplateCreditSpecification']:
        """
        The credit option for CPU usage of the instance. Valid only for T instances.
        """
        return pulumi.get(self, "credit_specification")

    @_builtins.property
    @pulumi.getter(name="disableApiStop")
    def disable_api_stop(self) -> Optional[_builtins.bool]:
        """
        Indicates whether to enable the instance for stop protection. For more information, see [Enable stop protection for your EC2 instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-stop-protection.html) in the *Amazon EC2 User Guide*.
        """
        return pulumi.get(self, "disable_api_stop")

    @_builtins.property
    @pulumi.getter(name="disableApiTermination")
    def disable_api_termination(self) -> Optional[_builtins.bool]:
        """
        Indicates whether termination protection is enabled for the instance. The default is ``false``, which means that you can terminate the instance using the Amazon EC2 console, command line tools, or API. You can enable termination protection when you launch an instance, while the instance is running, or while the instance is stopped.
        """
        return pulumi.get(self, "disable_api_termination")

    @_builtins.property
    @pulumi.getter(name="ebsOptimized")
    def ebs_optimized(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the instance is optimized for Amazon EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance.
        """
        return pulumi.get(self, "ebs_optimized")

    @_builtins.property
    @pulumi.getter(name="enclaveOptions")
    def enclave_options(self) -> Optional['outputs.LaunchTemplateEnclaveOptions']:
        """
        Indicates whether the instance is enabled for AWS Nitro Enclaves. For more information, see [What is Nitro Enclaves?](https://docs.aws.amazon.com/enclaves/latest/user/nitro-enclave.html) in the *Nitro Enclaves User Guide*.
         You can't enable AWS Nitro Enclaves and hibernation on the same instance.
        """
        return pulumi.get(self, "enclave_options")

    @_builtins.property
    @pulumi.getter(name="hibernationOptions")
    def hibernation_options(self) -> Optional['outputs.LaunchTemplateHibernationOptions']:
        """
        Indicates whether an instance is enabled for hibernation. This parameter is valid only if the instance meets the [hibernation prerequisites](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/hibernating-prerequisites.html). For more information, see [Hibernate your Amazon EC2 instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html) in the *Amazon EC2 User Guide*.
        """
        return pulumi.get(self, "hibernation_options")

    @_builtins.property
    @pulumi.getter(name="iamInstanceProfile")
    def iam_instance_profile(self) -> Optional['outputs.LaunchTemplateIamInstanceProfile']:
        """
        The name or Amazon Resource Name (ARN) of an IAM instance profile.
        """
        return pulumi.get(self, "iam_instance_profile")

    @_builtins.property
    @pulumi.getter(name="imageId")
    def image_id(self) -> Optional[_builtins.str]:
        """
        The ID of the AMI. Alternatively, you can specify a Systems Manager parameter, which will resolve to an AMI ID on launch.
         Valid formats:
          +   ``ami-0ac394d6a3example`` 
          +   ``resolve:ssm:parameter-name`` 
          +   ``resolve:ssm:parameter-name:version-number`` 
          +   ``resolve:ssm:parameter-name:label`` 
          
         For more information, see [Use a Systems Manager parameter to find an AMI](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/finding-an-ami.html#using-systems-manager-parameter-to-find-AMI) in the *Amazon Elastic Compute Cloud User Guide*.
        """
        return pulumi.get(self, "image_id")

    @_builtins.property
    @pulumi.getter(name="instanceInitiatedShutdownBehavior")
    def instance_initiated_shutdown_behavior(self) -> Optional[_builtins.str]:
        """
        Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
         Default: ``stop``
        """
        return pulumi.get(self, "instance_initiated_shutdown_behavior")

    @_builtins.property
    @pulumi.getter(name="instanceMarketOptions")
    def instance_market_options(self) -> Optional['outputs.LaunchTemplateInstanceMarketOptions']:
        """
        The market (purchasing) option for the instances.
        """
        return pulumi.get(self, "instance_market_options")

    @_builtins.property
    @pulumi.getter(name="instanceRequirements")
    def instance_requirements(self) -> Optional['outputs.LaunchTemplateInstanceRequirements']:
        """
        The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with these attributes.
         You must specify ``VCpuCount`` and ``MemoryMiB``. All other attributes are optional. Any unspecified optional attribute is set to its default.
         When you specify multiple attributes, you get instance types that satisfy all of the specified attributes. If you specify multiple values for an attribute, you get instance types that satisfy any of the specified values.
         To limit the list of instance types from which Amazon EC2 can identify matching instance types, you can use one of the following parameters, but not both in the same request:
          +  ``AllowedInstanceTypes`` - The instance types to include in the list. All other instance types are ignored, even if they match your specified attributes.
          +  ``ExcludedInstanceTypes`` - The instance types to exclude from the list, even if they match your specified attributes.
          
          If you specify ``InstanceRequirements``, you can't specify ``InstanceType``.
         Attribute-based instance type selection is only supported when using Auto Scaling groups, EC2 Fleet, and Spot Fleet to launch instances. If you plan to use the launch template in the [launch instance wizard](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-instance-wizard.html), or with the [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) API or [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html)AWS CloudFormation resource, you can't specify ``InstanceRequirements``.
          For more information, see [Specify attributes for instance type selection for EC2 Fleet or Spot Fleet](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html) and [Spot placement score](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html) in the *Amazon EC2 User Guide*.
        """
        return pulumi.get(self, "instance_requirements")

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[_builtins.str]:
        """
        The instance type. For more information, see [Amazon EC2 instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide*.
         If you specify ``InstanceType``, you can't specify ``InstanceRequirements``.
        """
        return pulumi.get(self, "instance_type")

    @_builtins.property
    @pulumi.getter(name="kernelId")
    def kernel_id(self) -> Optional[_builtins.str]:
        """
        The ID of the kernel.
         We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [User Provided Kernels](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide*.
        """
        return pulumi.get(self, "kernel_id")

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[_builtins.str]:
        """
        The name of the key pair. You can create a key pair using [CreateKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateKeyPair.html) or [ImportKeyPair](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ImportKeyPair.html).
          If you do not specify a key pair, you can't connect to the instance unless you choose an AMI that is configured to allow users another way to log in.
        """
        return pulumi.get(self, "key_name")

    @_builtins.property
    @pulumi.getter(name="licenseSpecifications")
    def license_specifications(self) -> Optional[Sequence['outputs.LaunchTemplateLicenseSpecification']]:
        """
        The license configurations.
        """
        return pulumi.get(self, "license_specifications")

    @_builtins.property
    @pulumi.getter(name="maintenanceOptions")
    def maintenance_options(self) -> Optional['outputs.LaunchTemplateMaintenanceOptions']:
        """
        The maintenance options of your instance.
        """
        return pulumi.get(self, "maintenance_options")

    @_builtins.property
    @pulumi.getter(name="metadataOptions")
    def metadata_options(self) -> Optional['outputs.LaunchTemplateMetadataOptions']:
        """
        The metadata options for the instance. For more information, see [Configure the Instance Metadata Service options](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/configuring-instance-metadata-options.html) in the *Amazon EC2 User Guide*.
        """
        return pulumi.get(self, "metadata_options")

    @_builtins.property
    @pulumi.getter
    def monitoring(self) -> Optional['outputs.LaunchTemplateMonitoring']:
        """
        The monitoring for the instance.
        """
        return pulumi.get(self, "monitoring")

    @_builtins.property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Optional[Sequence['outputs.LaunchTemplateNetworkInterface']]:
        """
        The network interfaces for the instance.
        """
        return pulumi.get(self, "network_interfaces")

    @_builtins.property
    @pulumi.getter(name="networkPerformanceOptions")
    def network_performance_options(self) -> Optional['outputs.LaunchTemplateNetworkPerformanceOptions']:
        """
        The settings for the network performance options for the instance. For more information, see [EC2 instance bandwidth weighting configuration](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/configure-bandwidth-weighting.html).
        """
        return pulumi.get(self, "network_performance_options")

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional['outputs.LaunchTemplatePlacement']:
        """
        The placement for the instance.
        """
        return pulumi.get(self, "placement")

    @_builtins.property
    @pulumi.getter(name="privateDnsNameOptions")
    def private_dns_name_options(self) -> Optional['outputs.LaunchTemplatePrivateDnsNameOptions']:
        """
        The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries should be handled. For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *User Guide*.
        """
        return pulumi.get(self, "private_dns_name_options")

    @_builtins.property
    @pulumi.getter(name="ramDiskId")
    def ram_disk_id(self) -> Optional[_builtins.str]:
        """
        The ID of the RAM disk.
          We recommend that you use PV-GRUB instead of kernels and RAM disks. For more information, see [User provided kernels](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/UserProvidedkernels.html) in the *Amazon EC2 User Guide*.
        """
        return pulumi.get(self, "ram_disk_id")

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        The IDs of the security groups. You can specify the IDs of existing security groups and references to resources created by the stack template.
         If you specify a network interface, you must specify any security groups as part of the network interface instead.
        """
        return pulumi.get(self, "security_group_ids")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        The names of the security groups. For a nondefault VPC, you must use security group IDs instead.
         If you specify a network interface, you must specify any security groups as part of the network interface instead of using this parameter.
        """
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter(name="tagSpecifications")
    def tag_specifications(self) -> Optional[Sequence['outputs.TagSpecification']]:
        """
        The tags to apply to resources that are created during instance launch.
         To tag the launch template itself, use [TagSpecifications](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#cfn-ec2-launchtemplate-tagspecifications).
        """
        return pulumi.get(self, "tag_specifications")

    @_builtins.property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[_builtins.str]:
        """
        The user data to make available to the instance. You must provide base64-encoded text. User data is limited to 16 KB. For more information, see [Run commands when you launch an EC2 instance with user data input](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/user-data.html) in the *Amazon EC2 User Guide*.
         If you are creating the launch template for use with BATCH, the user data must be provided in the [MIME multi-part archive format](https://docs.aws.amazon.com/https://cloudinit.readthedocs.io/en/latest/topics/format.html#mime-multi-part-archive). For more information, see [Amazon EC2 user data in launch templates](https://docs.aws.amazon.com/batch/latest/userguide/launch-templates.html#lt-user-data) in the *User Guide*.
        """
        return pulumi.get(self, "user_data")


@pulumi.output_type
class LaunchTemplateEbs(dict):
    """
    Parameters for a block device for an EBS volume in an Amazon EC2 launch template.
     ``Ebs`` is a property of [AWS::EC2::LaunchTemplate BlockDeviceMapping](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping.html).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "volumeInitializationRate":
            suggest = "volume_initialization_rate"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateEbs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateEbs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateEbs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_on_termination: Optional[_builtins.bool] = None,
                 encrypted: Optional[_builtins.bool] = None,
                 iops: Optional[_builtins.int] = None,
                 kms_key_id: Optional[_builtins.str] = None,
                 snapshot_id: Optional[_builtins.str] = None,
                 throughput: Optional[_builtins.int] = None,
                 volume_initialization_rate: Optional[_builtins.int] = None,
                 volume_size: Optional[_builtins.int] = None,
                 volume_type: Optional[_builtins.str] = None):
        """
        Parameters for a block device for an EBS volume in an Amazon EC2 launch template.
         ``Ebs`` is a property of [AWS::EC2::LaunchTemplate BlockDeviceMapping](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-blockdevicemapping.html).
        :param _builtins.bool delete_on_termination: Indicates whether the EBS volume is deleted on instance termination.
        :param _builtins.bool encrypted: Indicates whether the EBS volume is encrypted. Encrypted volumes can only be attached to instances that support Amazon EBS encryption. If you are creating a volume from a snapshot, you can't specify an encryption value.
        :param _builtins.int iops: The number of I/O operations per second (IOPS). For ``gp3``, ``io1``, and ``io2`` volumes, this represents the number of IOPS that are provisioned for the volume. For ``gp2`` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.
                The following are the supported values for each volume type:
                 +  ``gp3``: 3,000 - 80,000 IOPS
                 +  ``io1``: 100 - 64,000 IOPS
                 +  ``io2``: 100 - 256,000 IOPS
                 
                For ``io2`` volumes, you can achieve up to 256,000 IOPS on [instances built on the Nitro System](https://docs.aws.amazon.com/ec2/latest/instancetypes/ec2-nitro-instances.html). On other instances, you can achieve performance up to 32,000 IOPS.
                This parameter is supported for ``io1``, ``io2``, and ``gp3`` volumes only.
        :param _builtins.str kms_key_id: Identifier (key ID, key alias, key ARN, or alias ARN) of the customer managed KMS key to use for EBS encryption.
        :param _builtins.str snapshot_id: The ID of the snapshot.
        :param _builtins.int throughput: The throughput to provision for a ``gp3`` volume, with a maximum of 2,000 MiB/s.
                Valid Range: Minimum value of 125. Maximum value of 2,000.
        :param _builtins.int volume_initialization_rate: Specifies the Amazon EBS Provisioned Rate for Volume Initialization (volume initialization rate), in MiB/s, at which to download the snapshot blocks from Amazon S3 to the volume. This is also known as *volume initialization*. Specifying a volume initialization rate ensures that the volume is initialized at a predictable and consistent rate after creation.
                This parameter is supported only for volumes created from snapshots. Omit this parameter if:
                 +  You want to create the volume using fast snapshot restore. You must specify a snapshot that is enabled for fast snapshot restore. In this case, the volume is fully initialized at creation.
                 If you specify a snapshot that is enabled for fast snapshot restore and a volume initialization rate, the volume will be initialized at the specified rate instead of fast snapshot restore.
                  +  You want to create a volume that is initialized at the default rate.
                 
                For more information, see [Initialize Amazon EBS volumes](https://docs.aws.amazon.com/ebs/latest/userguide/initalize-volume.html) in the *Amazon EC2 User Guide*.
                Valid range: 100 - 300 MiB/s
        :param _builtins.int volume_size: The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. The following are the supported volumes sizes for each volume type:
                 +  ``gp2``: 1 - 16,384 GiB
                 +  ``gp3``: 1 - 65,536 GiB
                 +  ``io1``: 4 - 16,384 GiB
                 +  ``io2``: 4 - 65,536 GiB
                 +  ``st1`` and ``sc1``: 125 - 16,384 GiB
                 +  ``standard``: 1 - 1024 GiB
        :param _builtins.str volume_type: The volume type. For more information, see [Amazon EBS volume types](https://docs.aws.amazon.com/ebs/latest/userguide/ebs-volume-types.html) in the *Amazon EBS User Guide*.
        """
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_initialization_rate is not None:
            pulumi.set(__self__, "volume_initialization_rate", volume_initialization_rate)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the EBS volume is deleted on instance termination.
        """
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the EBS volume is encrypted. Encrypted volumes can only be attached to instances that support Amazon EBS encryption. If you are creating a volume from a snapshot, you can't specify an encryption value.
        """
        return pulumi.get(self, "encrypted")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        """
        The number of I/O operations per second (IOPS). For ``gp3``, ``io1``, and ``io2`` volumes, this represents the number of IOPS that are provisioned for the volume. For ``gp2`` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.
         The following are the supported values for each volume type:
          +  ``gp3``: 3,000 - 80,000 IOPS
          +  ``io1``: 100 - 64,000 IOPS
          +  ``io2``: 100 - 256,000 IOPS
          
         For ``io2`` volumes, you can achieve up to 256,000 IOPS on [instances built on the Nitro System](https://docs.aws.amazon.com/ec2/latest/instancetypes/ec2-nitro-instances.html). On other instances, you can achieve performance up to 32,000 IOPS.
         This parameter is supported for ``io1``, ``io2``, and ``gp3`` volumes only.
        """
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        """
        Identifier (key ID, key alias, key ARN, or alias ARN) of the customer managed KMS key to use for EBS encryption.
        """
        return pulumi.get(self, "kms_key_id")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[_builtins.str]:
        """
        The ID of the snapshot.
        """
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter
    def throughput(self) -> Optional[_builtins.int]:
        """
        The throughput to provision for a ``gp3`` volume, with a maximum of 2,000 MiB/s.
         Valid Range: Minimum value of 125. Maximum value of 2,000.
        """
        return pulumi.get(self, "throughput")

    @_builtins.property
    @pulumi.getter(name="volumeInitializationRate")
    def volume_initialization_rate(self) -> Optional[_builtins.int]:
        """
        Specifies the Amazon EBS Provisioned Rate for Volume Initialization (volume initialization rate), in MiB/s, at which to download the snapshot blocks from Amazon S3 to the volume. This is also known as *volume initialization*. Specifying a volume initialization rate ensures that the volume is initialized at a predictable and consistent rate after creation.
         This parameter is supported only for volumes created from snapshots. Omit this parameter if:
          +  You want to create the volume using fast snapshot restore. You must specify a snapshot that is enabled for fast snapshot restore. In this case, the volume is fully initialized at creation.
          If you specify a snapshot that is enabled for fast snapshot restore and a volume initialization rate, the volume will be initialized at the specified rate instead of fast snapshot restore.
           +  You want to create a volume that is initialized at the default rate.
          
         For more information, see [Initialize Amazon EBS volumes](https://docs.aws.amazon.com/ebs/latest/userguide/initalize-volume.html) in the *Amazon EC2 User Guide*.
         Valid range: 100 - 300 MiB/s
        """
        return pulumi.get(self, "volume_initialization_rate")

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[_builtins.int]:
        """
        The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. The following are the supported volumes sizes for each volume type:
          +  ``gp2``: 1 - 16,384 GiB
          +  ``gp3``: 1 - 65,536 GiB
          +  ``io1``: 4 - 16,384 GiB
          +  ``io2``: 4 - 65,536 GiB
          +  ``st1`` and ``sc1``: 125 - 16,384 GiB
          +  ``standard``: 1 - 1024 GiB
        """
        return pulumi.get(self, "volume_size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[_builtins.str]:
        """
        The volume type. For more information, see [Amazon EBS volume types](https://docs.aws.amazon.com/ebs/latest/userguide/ebs-volume-types.html) in the *Amazon EBS User Guide*.
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class LaunchTemplateEnaSrdSpecification(dict):
    """
    ENA Express uses AWS Scalable Reliable Datagram (SRD) technology to increase the maximum bandwidth used per stream and minimize tail latency of network traffic between EC2 instances. With ENA Express, you can communicate between two EC2 instances in the same subnet within the same account, or in different accounts. Both sending and receiving instances must have ENA Express enabled.
     To improve the reliability of network packet delivery, ENA Express reorders network packets on the receiving end by default. However, some UDP-based applications are designed to handle network packets that are out of order to reduce the overhead for packet delivery at the network layer. When ENA Express is enabled, you can specify whether UDP network traffic uses it.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enaSrdEnabled":
            suggest = "ena_srd_enabled"
        elif key == "enaSrdUdpSpecification":
            suggest = "ena_srd_udp_specification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateEnaSrdSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateEnaSrdSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateEnaSrdSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ena_srd_enabled: Optional[_builtins.bool] = None,
                 ena_srd_udp_specification: Optional['outputs.LaunchTemplateEnaSrdUdpSpecification'] = None):
        """
        ENA Express uses AWS Scalable Reliable Datagram (SRD) technology to increase the maximum bandwidth used per stream and minimize tail latency of network traffic between EC2 instances. With ENA Express, you can communicate between two EC2 instances in the same subnet within the same account, or in different accounts. Both sending and receiving instances must have ENA Express enabled.
         To improve the reliability of network packet delivery, ENA Express reorders network packets on the receiving end by default. However, some UDP-based applications are designed to handle network packets that are out of order to reduce the overhead for packet delivery at the network layer. When ENA Express is enabled, you can specify whether UDP network traffic uses it.
        :param _builtins.bool ena_srd_enabled: Indicates whether ENA Express is enabled for the network interface.
        :param 'LaunchTemplateEnaSrdUdpSpecification' ena_srd_udp_specification: Configures ENA Express for UDP network traffic.
        """
        if ena_srd_enabled is not None:
            pulumi.set(__self__, "ena_srd_enabled", ena_srd_enabled)
        if ena_srd_udp_specification is not None:
            pulumi.set(__self__, "ena_srd_udp_specification", ena_srd_udp_specification)

    @_builtins.property
    @pulumi.getter(name="enaSrdEnabled")
    def ena_srd_enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates whether ENA Express is enabled for the network interface.
        """
        return pulumi.get(self, "ena_srd_enabled")

    @_builtins.property
    @pulumi.getter(name="enaSrdUdpSpecification")
    def ena_srd_udp_specification(self) -> Optional['outputs.LaunchTemplateEnaSrdUdpSpecification']:
        """
        Configures ENA Express for UDP network traffic.
        """
        return pulumi.get(self, "ena_srd_udp_specification")


@pulumi.output_type
class LaunchTemplateEnaSrdUdpSpecification(dict):
    """
    ENA Express is compatible with both TCP and UDP transport protocols. When it's enabled, TCP traffic automatically uses it. However, some UDP-based applications are designed to handle network packets that are out of order, without a need for retransmission, such as live video broadcasting or other near-real-time applications. For UDP traffic, you can specify whether to use ENA Express, based on your application environment needs.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enaSrdUdpEnabled":
            suggest = "ena_srd_udp_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateEnaSrdUdpSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateEnaSrdUdpSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateEnaSrdUdpSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ena_srd_udp_enabled: Optional[_builtins.bool] = None):
        """
        ENA Express is compatible with both TCP and UDP transport protocols. When it's enabled, TCP traffic automatically uses it. However, some UDP-based applications are designed to handle network packets that are out of order, without a need for retransmission, such as live video broadcasting or other near-real-time applications. For UDP traffic, you can specify whether to use ENA Express, based on your application environment needs.
        :param _builtins.bool ena_srd_udp_enabled: Indicates whether UDP traffic to and from the instance uses ENA Express. To specify this setting, you must first enable ENA Express.
        """
        if ena_srd_udp_enabled is not None:
            pulumi.set(__self__, "ena_srd_udp_enabled", ena_srd_udp_enabled)

    @_builtins.property
    @pulumi.getter(name="enaSrdUdpEnabled")
    def ena_srd_udp_enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates whether UDP traffic to and from the instance uses ENA Express. To specify this setting, you must first enable ENA Express.
        """
        return pulumi.get(self, "ena_srd_udp_enabled")


@pulumi.output_type
class LaunchTemplateEnclaveOptions(dict):
    """
    Indicates whether the instance is enabled for AWS Nitro Enclaves.
    """
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        Indicates whether the instance is enabled for AWS Nitro Enclaves.
        :param _builtins.bool enabled: If this parameter is set to ``true``, the instance is enabled for AWS Nitro Enclaves; otherwise, it is not enabled for AWS Nitro Enclaves.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If this parameter is set to ``true``, the instance is enabled for AWS Nitro Enclaves; otherwise, it is not enabled for AWS Nitro Enclaves.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class LaunchTemplateHibernationOptions(dict):
    """
    Specifies whether your instance is configured for hibernation. This parameter is valid only if the instance meets the [hibernation prerequisites](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html#hibernating-prerequisites). For more information, see [Hibernate Your Instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html) in the *Amazon EC2 User Guide*.
     ``HibernationOptions`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
    """
    def __init__(__self__, *,
                 configured: Optional[_builtins.bool] = None):
        """
        Specifies whether your instance is configured for hibernation. This parameter is valid only if the instance meets the [hibernation prerequisites](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html#hibernating-prerequisites). For more information, see [Hibernate Your Instance](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Hibernate.html) in the *Amazon EC2 User Guide*.
         ``HibernationOptions`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        :param _builtins.bool configured: If you set this parameter to ``true``, the instance is enabled for hibernation.
                Default: ``false``
        """
        if configured is not None:
            pulumi.set(__self__, "configured", configured)

    @_builtins.property
    @pulumi.getter
    def configured(self) -> Optional[_builtins.bool]:
        """
        If you set this parameter to ``true``, the instance is enabled for hibernation.
         Default: ``false``
        """
        return pulumi.get(self, "configured")


@pulumi.output_type
class LaunchTemplateIamInstanceProfile(dict):
    """
    Specifies an IAM instance profile, which is a container for an IAM role for your instance. You can use an IAM role to distribute your AWS credentials to your instances.
     If you are creating the launch template for use with an ASlong group, you can specify either the name or the ARN of the instance profile, but not both.
     ``IamInstanceProfile`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
    """
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        Specifies an IAM instance profile, which is a container for an IAM role for your instance. You can use an IAM role to distribute your AWS credentials to your instances.
         If you are creating the launch template for use with an ASlong group, you can specify either the name or the ARN of the instance profile, but not both.
         ``IamInstanceProfile`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        :param _builtins.str arn: The Amazon Resource Name (ARN) of the instance profile.
        :param _builtins.str name: The name of the instance profile.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the instance profile.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the instance profile.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LaunchTemplateInstanceMarketOptions(dict):
    """
    Specifies the market (purchasing) option for an instance.
     ``InstanceMarketOptions`` is a property of the [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "marketType":
            suggest = "market_type"
        elif key == "spotOptions":
            suggest = "spot_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateInstanceMarketOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateInstanceMarketOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateInstanceMarketOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 market_type: Optional[_builtins.str] = None,
                 spot_options: Optional['outputs.LaunchTemplateSpotOptions'] = None):
        """
        Specifies the market (purchasing) option for an instance.
         ``InstanceMarketOptions`` is a property of the [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        :param _builtins.str market_type: The market type.
        :param 'LaunchTemplateSpotOptions' spot_options: The options for Spot Instances.
        """
        if market_type is not None:
            pulumi.set(__self__, "market_type", market_type)
        if spot_options is not None:
            pulumi.set(__self__, "spot_options", spot_options)

    @_builtins.property
    @pulumi.getter(name="marketType")
    def market_type(self) -> Optional[_builtins.str]:
        """
        The market type.
        """
        return pulumi.get(self, "market_type")

    @_builtins.property
    @pulumi.getter(name="spotOptions")
    def spot_options(self) -> Optional['outputs.LaunchTemplateSpotOptions']:
        """
        The options for Spot Instances.
        """
        return pulumi.get(self, "spot_options")


@pulumi.output_type
class LaunchTemplateInstanceRequirements(dict):
    """
    The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with these attributes.
     You must specify ``VCpuCount`` and ``MemoryMiB``. All other attributes are optional. Any unspecified optional attribute is set to its default.
     When you specify multiple attributes, you get instance types that satisfy all of the specified attributes. If you specify multiple values for an attribute, you get instance types that satisfy any of the specified values.
     To limit the list of instance types from which Amazon EC2 can identify matching instance types, you can use one of the following parameters, but not both in the same request:
      +  ``AllowedInstanceTypes`` - The instance types to include in the list. All other instance types are ignored, even if they match your specified attributes.
      +  ``ExcludedInstanceTypes`` - The instance types to exclude from the list, even if they match your specified attributes.
      
      If you specify ``InstanceRequirements``, you can't specify ``InstanceType``.
     Attribute-based instance type selection is only supported when using Auto Scaling groups, EC2 Fleet, and Spot Fleet to launch instances. If you plan to use the launch template in the [launch instance wizard](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-instance-wizard.html), or with the [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) API or [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html)AWS CloudFormation resource, you can't specify ``InstanceRequirements``.
      For more information, see [Specify attributes for instance type selection for EC2 Fleet or Spot Fleet](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html) and [Spot placement score](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html) in the *Amazon EC2 User Guide*.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceleratorCount":
            suggest = "accelerator_count"
        elif key == "acceleratorManufacturers":
            suggest = "accelerator_manufacturers"
        elif key == "acceleratorNames":
            suggest = "accelerator_names"
        elif key == "acceleratorTotalMemoryMiB":
            suggest = "accelerator_total_memory_mi_b"
        elif key == "acceleratorTypes":
            suggest = "accelerator_types"
        elif key == "allowedInstanceTypes":
            suggest = "allowed_instance_types"
        elif key == "bareMetal":
            suggest = "bare_metal"
        elif key == "baselineEbsBandwidthMbps":
            suggest = "baseline_ebs_bandwidth_mbps"
        elif key == "baselinePerformanceFactors":
            suggest = "baseline_performance_factors"
        elif key == "burstablePerformance":
            suggest = "burstable_performance"
        elif key == "cpuManufacturers":
            suggest = "cpu_manufacturers"
        elif key == "excludedInstanceTypes":
            suggest = "excluded_instance_types"
        elif key == "instanceGenerations":
            suggest = "instance_generations"
        elif key == "localStorage":
            suggest = "local_storage"
        elif key == "localStorageTypes":
            suggest = "local_storage_types"
        elif key == "maxSpotPriceAsPercentageOfOptimalOnDemandPrice":
            suggest = "max_spot_price_as_percentage_of_optimal_on_demand_price"
        elif key == "memoryGiBPerVCpu":
            suggest = "memory_gi_b_per_v_cpu"
        elif key == "memoryMiB":
            suggest = "memory_mi_b"
        elif key == "networkBandwidthGbps":
            suggest = "network_bandwidth_gbps"
        elif key == "networkInterfaceCount":
            suggest = "network_interface_count"
        elif key == "onDemandMaxPricePercentageOverLowestPrice":
            suggest = "on_demand_max_price_percentage_over_lowest_price"
        elif key == "requireHibernateSupport":
            suggest = "require_hibernate_support"
        elif key == "spotMaxPricePercentageOverLowestPrice":
            suggest = "spot_max_price_percentage_over_lowest_price"
        elif key == "totalLocalStorageGb":
            suggest = "total_local_storage_gb"
        elif key == "vCpuCount":
            suggest = "v_cpu_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateInstanceRequirements. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateInstanceRequirements.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateInstanceRequirements.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accelerator_count: Optional['outputs.LaunchTemplateAcceleratorCount'] = None,
                 accelerator_manufacturers: Optional[Sequence[_builtins.str]] = None,
                 accelerator_names: Optional[Sequence[_builtins.str]] = None,
                 accelerator_total_memory_mi_b: Optional['outputs.LaunchTemplateAcceleratorTotalMemoryMiB'] = None,
                 accelerator_types: Optional[Sequence[_builtins.str]] = None,
                 allowed_instance_types: Optional[Sequence[_builtins.str]] = None,
                 bare_metal: Optional[_builtins.str] = None,
                 baseline_ebs_bandwidth_mbps: Optional['outputs.LaunchTemplateBaselineEbsBandwidthMbps'] = None,
                 baseline_performance_factors: Optional['outputs.LaunchTemplateBaselinePerformanceFactors'] = None,
                 burstable_performance: Optional[_builtins.str] = None,
                 cpu_manufacturers: Optional[Sequence[_builtins.str]] = None,
                 excluded_instance_types: Optional[Sequence[_builtins.str]] = None,
                 instance_generations: Optional[Sequence[_builtins.str]] = None,
                 local_storage: Optional[_builtins.str] = None,
                 local_storage_types: Optional[Sequence[_builtins.str]] = None,
                 max_spot_price_as_percentage_of_optimal_on_demand_price: Optional[_builtins.int] = None,
                 memory_gi_b_per_v_cpu: Optional['outputs.LaunchTemplateMemoryGiBPerVCpu'] = None,
                 memory_mi_b: Optional['outputs.LaunchTemplateMemoryMiB'] = None,
                 network_bandwidth_gbps: Optional['outputs.LaunchTemplateNetworkBandwidthGbps'] = None,
                 network_interface_count: Optional['outputs.LaunchTemplateNetworkInterfaceCount'] = None,
                 on_demand_max_price_percentage_over_lowest_price: Optional[_builtins.int] = None,
                 require_hibernate_support: Optional[_builtins.bool] = None,
                 spot_max_price_percentage_over_lowest_price: Optional[_builtins.int] = None,
                 total_local_storage_gb: Optional['outputs.LaunchTemplateTotalLocalStorageGb'] = None,
                 v_cpu_count: Optional['outputs.LaunchTemplateVCpuCount'] = None):
        """
        The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with these attributes.
         You must specify ``VCpuCount`` and ``MemoryMiB``. All other attributes are optional. Any unspecified optional attribute is set to its default.
         When you specify multiple attributes, you get instance types that satisfy all of the specified attributes. If you specify multiple values for an attribute, you get instance types that satisfy any of the specified values.
         To limit the list of instance types from which Amazon EC2 can identify matching instance types, you can use one of the following parameters, but not both in the same request:
          +  ``AllowedInstanceTypes`` - The instance types to include in the list. All other instance types are ignored, even if they match your specified attributes.
          +  ``ExcludedInstanceTypes`` - The instance types to exclude from the list, even if they match your specified attributes.
          
          If you specify ``InstanceRequirements``, you can't specify ``InstanceType``.
         Attribute-based instance type selection is only supported when using Auto Scaling groups, EC2 Fleet, and Spot Fleet to launch instances. If you plan to use the launch template in the [launch instance wizard](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-instance-wizard.html), or with the [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) API or [AWS::EC2::Instance](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html)AWS CloudFormation resource, you can't specify ``InstanceRequirements``.
          For more information, see [Specify attributes for instance type selection for EC2 Fleet or Spot Fleet](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html) and [Spot placement score](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-placement-score.html) in the *Amazon EC2 User Guide*.
        :param 'LaunchTemplateAcceleratorCount' accelerator_count: The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.
                To exclude accelerator-enabled instance types, set ``Max`` to ``0``.
                Default: No minimum or maximum limits
        :param Sequence[_builtins.str] accelerator_manufacturers: Indicates whether instance types must have accelerators by specific manufacturers.
                 +  For instance types with AWS devices, specify ``amazon-web-services``.
                 +  For instance types with AMD devices, specify ``amd``.
                 +  For instance types with Habana devices, specify ``habana``.
                 +  For instance types with NVIDIA devices, specify ``nvidia``.
                 +  For instance types with Xilinx devices, specify ``xilinx``.
                 
                Default: Any manufacturer
        :param Sequence[_builtins.str] accelerator_names: The accelerators that must be on the instance type.
                 +  For instance types with NVIDIA A10G GPUs, specify ``a10g``.
                 +  For instance types with NVIDIA A100 GPUs, specify ``a100``.
                 +  For instance types with NVIDIA H100 GPUs, specify ``h100``.
                 +  For instance types with AWS Inferentia chips, specify ``inferentia``.
                 +  For instance types with NVIDIA GRID K520 GPUs, specify ``k520``.
                 +  For instance types with NVIDIA K80 GPUs, specify ``k80``.
                 +  For instance types with NVIDIA M60 GPUs, specify ``m60``.
                 +  For instance types with AMD Radeon Pro V520 GPUs, specify ``radeon-pro-v520``.
                 +  For instance types with NVIDIA T4 GPUs, specify ``t4``.
                 +  For instance types with NVIDIA T4G GPUs, specify ``t4g``.
                 +  For instance types with Xilinx VU9P FPGAs, specify ``vu9p``.
                 +  For instance types with NVIDIA V100 GPUs, specify ``v100``.
                 
                Default: Any accelerator
        :param 'LaunchTemplateAcceleratorTotalMemoryMiB' accelerator_total_memory_mi_b: The minimum and maximum amount of total accelerator memory, in MiB.
                Default: No minimum or maximum limits
        :param Sequence[_builtins.str] accelerator_types: The accelerator types that must be on the instance type.
                 +  For instance types with FPGA accelerators, specify ``fpga``.
                 +  For instance types with GPU accelerators, specify ``gpu``.
                 +  For instance types with Inference accelerators, specify ``inference``.
                 
                Default: Any accelerator type
        :param Sequence[_builtins.str] allowed_instance_types: The instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes.
                You can use strings with one or more wild cards, represented by an asterisk (``*``), to allow an instance type, size, or generation. The following are examples: ``m5.8xlarge``, ``c5*.*``, ``m5a.*``, ``r*``, ``*3*``.
                For example, if you specify ``c5*``,Amazon EC2 will allow the entire C5 instance family, which includes all C5a and C5n instance types. If you specify ``m5a.*``, Amazon EC2 will allow all the M5a instance types, but not the M5n instance types.
                 If you specify ``AllowedInstanceTypes``, you can't specify ``ExcludedInstanceTypes``.
                 Default: All instance types
        :param _builtins.str bare_metal: Indicates whether bare metal instance types must be included, excluded, or required.
                 +  To include bare metal instance types, specify ``included``.
                 +  To require only bare metal instance types, specify ``required``.
                 +  To exclude bare metal instance types, specify ``excluded``.
                 
                Default: ``excluded``
        :param 'LaunchTemplateBaselineEbsBandwidthMbps' baseline_ebs_bandwidth_mbps: The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see [Amazon EBSoptimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the *Amazon EC2 User Guide*.
                Default: No minimum or maximum limits
        :param 'LaunchTemplateBaselinePerformanceFactors' baseline_performance_factors: The baseline performance to consider, using an instance family as a baseline reference. The instance family establishes the lowest acceptable level of performance. Amazon EC2 uses this baseline to guide instance type selection, but there is no guarantee that the selected instance types will always exceed the baseline for every application. Currently, this parameter only supports CPU performance as a baseline performance factor. For more information, see [Performance protection](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html#ec2fleet-abis-performance-protection) in the *Amazon EC2 User Guide*.
        :param _builtins.str burstable_performance: Indicates whether burstable performance T instance types are included, excluded, or required. For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html).
                 +  To include burstable performance instance types, specify ``included``.
                 +  To require only burstable performance instance types, specify ``required``.
                 +  To exclude burstable performance instance types, specify ``excluded``.
                 
                Default: ``excluded``
        :param Sequence[_builtins.str] cpu_manufacturers: The CPU manufacturers to include.
                 +  For instance types with Intel CPUs, specify ``intel``.
                 +  For instance types with AMD CPUs, specify ``amd``.
                 +  For instance types with AWS CPUs, specify ``amazon-web-services``.
                 +  For instance types with Apple CPUs, specify ``apple``.
                 
                 Don't confuse the CPU manufacturer with the CPU architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.
                 Default: Any manufacturer
        :param Sequence[_builtins.str] excluded_instance_types: The instance types to exclude.
                You can use strings with one or more wild cards, represented by an asterisk (``*``), to exclude an instance type, size, or generation. The following are examples: ``m5.8xlarge``, ``c5*.*``, ``m5a.*``, ``r*``, ``*3*``.
                For example, if you specify ``c5*``,Amazon EC2 will exclude the entire C5 instance family, which includes all C5a and C5n instance types. If you specify ``m5a.*``, Amazon EC2 will exclude all the M5a instance types, but not the M5n instance types.
                 If you specify ``ExcludedInstanceTypes``, you can't specify ``AllowedInstanceTypes``.
                 Default: No excluded instance types
        :param Sequence[_builtins.str] instance_generations: Indicates whether current or previous generation instance types are included. The current generation instance types are recommended for use. Current generation instance types are typically the latest two to three generations in each instance family. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide*.
                For current generation instance types, specify ``current``.
                For previous generation instance types, specify ``previous``.
                Default: Current and previous generation instance types
        :param _builtins.str local_storage: Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, [Amazon EC2 instance store](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html) in the *Amazon EC2 User Guide*.
                 +  To include instance types with instance store volumes, specify ``included``.
                 +  To require only instance types with instance store volumes, specify ``required``.
                 +  To exclude instance types with instance store volumes, specify ``excluded``.
                 
                Default: ``included``
        :param Sequence[_builtins.str] local_storage_types: The type of local storage that is required.
                 +  For instance types with hard disk drive (HDD) storage, specify ``hdd``.
                 +  For instance types with solid state drive (SSD) storage, specify ``ssd``.
                 
                Default: ``hdd`` and ``ssd``
        :param _builtins.int max_spot_price_as_percentage_of_optimal_on_demand_price: [Price protection] The price protection threshold for Spot Instances, as a percentage of an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.
                The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
                If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib``, the price protection threshold is based on the per vCPU or per memory price instead of the per instance price.
                 Only one of ``SpotMaxPricePercentageOverLowestPrice`` or ``MaxSpotPriceAsPercentageOfOptimalOnDemandPrice`` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as ``999999``.
        :param 'LaunchTemplateMemoryGiBPerVCpu' memory_gi_b_per_v_cpu: The minimum and maximum amount of memory per vCPU, in GiB.
                Default: No minimum or maximum limits
        :param 'LaunchTemplateMemoryMiB' memory_mi_b: The minimum and maximum amount of memory, in MiB.
        :param 'LaunchTemplateNetworkBandwidthGbps' network_bandwidth_gbps: The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps).
                Default: No minimum or maximum limits
        :param 'LaunchTemplateNetworkInterfaceCount' network_interface_count: The minimum and maximum number of network interfaces.
                Default: No minimum or maximum limits
        :param _builtins.int on_demand_max_price_percentage_over_lowest_price: [Price protection] The price protection threshold for On-Demand Instances, as a percentage higher than an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.
                The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
                To turn off price protection, specify a high value, such as ``999999``.
                This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html).
                 If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib``, the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.
                 Default: ``20``
        :param _builtins.bool require_hibernate_support: Indicates whether instance types must support hibernation for On-Demand Instances.
                This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html).
                Default: ``false``
        :param _builtins.int spot_max_price_percentage_over_lowest_price: [Price protection] The price protection threshold for Spot Instances, as a percentage higher than an identified Spot price. The identified Spot price is the Spot price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified Spot price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose Spot price exceeds your specified threshold.
                The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
                If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib``, the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.
                This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html).
                 Only one of ``SpotMaxPricePercentageOverLowestPrice`` or ``MaxSpotPriceAsPercentageOfOptimalOnDemandPrice`` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as ``999999``.
                 Default: ``100``
        :param 'LaunchTemplateTotalLocalStorageGb' total_local_storage_gb: The minimum and maximum amount of total local storage, in GB.
                Default: No minimum or maximum limits
        :param 'LaunchTemplateVCpuCount' v_cpu_count: The minimum and maximum number of vCPUs.
        """
        if accelerator_count is not None:
            pulumi.set(__self__, "accelerator_count", accelerator_count)
        if accelerator_manufacturers is not None:
            pulumi.set(__self__, "accelerator_manufacturers", accelerator_manufacturers)
        if accelerator_names is not None:
            pulumi.set(__self__, "accelerator_names", accelerator_names)
        if accelerator_total_memory_mi_b is not None:
            pulumi.set(__self__, "accelerator_total_memory_mi_b", accelerator_total_memory_mi_b)
        if accelerator_types is not None:
            pulumi.set(__self__, "accelerator_types", accelerator_types)
        if allowed_instance_types is not None:
            pulumi.set(__self__, "allowed_instance_types", allowed_instance_types)
        if bare_metal is not None:
            pulumi.set(__self__, "bare_metal", bare_metal)
        if baseline_ebs_bandwidth_mbps is not None:
            pulumi.set(__self__, "baseline_ebs_bandwidth_mbps", baseline_ebs_bandwidth_mbps)
        if baseline_performance_factors is not None:
            pulumi.set(__self__, "baseline_performance_factors", baseline_performance_factors)
        if burstable_performance is not None:
            pulumi.set(__self__, "burstable_performance", burstable_performance)
        if cpu_manufacturers is not None:
            pulumi.set(__self__, "cpu_manufacturers", cpu_manufacturers)
        if excluded_instance_types is not None:
            pulumi.set(__self__, "excluded_instance_types", excluded_instance_types)
        if instance_generations is not None:
            pulumi.set(__self__, "instance_generations", instance_generations)
        if local_storage is not None:
            pulumi.set(__self__, "local_storage", local_storage)
        if local_storage_types is not None:
            pulumi.set(__self__, "local_storage_types", local_storage_types)
        if max_spot_price_as_percentage_of_optimal_on_demand_price is not None:
            pulumi.set(__self__, "max_spot_price_as_percentage_of_optimal_on_demand_price", max_spot_price_as_percentage_of_optimal_on_demand_price)
        if memory_gi_b_per_v_cpu is not None:
            pulumi.set(__self__, "memory_gi_b_per_v_cpu", memory_gi_b_per_v_cpu)
        if memory_mi_b is not None:
            pulumi.set(__self__, "memory_mi_b", memory_mi_b)
        if network_bandwidth_gbps is not None:
            pulumi.set(__self__, "network_bandwidth_gbps", network_bandwidth_gbps)
        if network_interface_count is not None:
            pulumi.set(__self__, "network_interface_count", network_interface_count)
        if on_demand_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "on_demand_max_price_percentage_over_lowest_price", on_demand_max_price_percentage_over_lowest_price)
        if require_hibernate_support is not None:
            pulumi.set(__self__, "require_hibernate_support", require_hibernate_support)
        if spot_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "spot_max_price_percentage_over_lowest_price", spot_max_price_percentage_over_lowest_price)
        if total_local_storage_gb is not None:
            pulumi.set(__self__, "total_local_storage_gb", total_local_storage_gb)
        if v_cpu_count is not None:
            pulumi.set(__self__, "v_cpu_count", v_cpu_count)

    @_builtins.property
    @pulumi.getter(name="acceleratorCount")
    def accelerator_count(self) -> Optional['outputs.LaunchTemplateAcceleratorCount']:
        """
        The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.
         To exclude accelerator-enabled instance types, set ``Max`` to ``0``.
         Default: No minimum or maximum limits
        """
        return pulumi.get(self, "accelerator_count")

    @_builtins.property
    @pulumi.getter(name="acceleratorManufacturers")
    def accelerator_manufacturers(self) -> Optional[Sequence[_builtins.str]]:
        """
        Indicates whether instance types must have accelerators by specific manufacturers.
          +  For instance types with AWS devices, specify ``amazon-web-services``.
          +  For instance types with AMD devices, specify ``amd``.
          +  For instance types with Habana devices, specify ``habana``.
          +  For instance types with NVIDIA devices, specify ``nvidia``.
          +  For instance types with Xilinx devices, specify ``xilinx``.
          
         Default: Any manufacturer
        """
        return pulumi.get(self, "accelerator_manufacturers")

    @_builtins.property
    @pulumi.getter(name="acceleratorNames")
    def accelerator_names(self) -> Optional[Sequence[_builtins.str]]:
        """
        The accelerators that must be on the instance type.
          +  For instance types with NVIDIA A10G GPUs, specify ``a10g``.
          +  For instance types with NVIDIA A100 GPUs, specify ``a100``.
          +  For instance types with NVIDIA H100 GPUs, specify ``h100``.
          +  For instance types with AWS Inferentia chips, specify ``inferentia``.
          +  For instance types with NVIDIA GRID K520 GPUs, specify ``k520``.
          +  For instance types with NVIDIA K80 GPUs, specify ``k80``.
          +  For instance types with NVIDIA M60 GPUs, specify ``m60``.
          +  For instance types with AMD Radeon Pro V520 GPUs, specify ``radeon-pro-v520``.
          +  For instance types with NVIDIA T4 GPUs, specify ``t4``.
          +  For instance types with NVIDIA T4G GPUs, specify ``t4g``.
          +  For instance types with Xilinx VU9P FPGAs, specify ``vu9p``.
          +  For instance types with NVIDIA V100 GPUs, specify ``v100``.
          
         Default: Any accelerator
        """
        return pulumi.get(self, "accelerator_names")

    @_builtins.property
    @pulumi.getter(name="acceleratorTotalMemoryMiB")
    def accelerator_total_memory_mi_b(self) -> Optional['outputs.LaunchTemplateAcceleratorTotalMemoryMiB']:
        """
        The minimum and maximum amount of total accelerator memory, in MiB.
         Default: No minimum or maximum limits
        """
        return pulumi.get(self, "accelerator_total_memory_mi_b")

    @_builtins.property
    @pulumi.getter(name="acceleratorTypes")
    def accelerator_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        The accelerator types that must be on the instance type.
          +  For instance types with FPGA accelerators, specify ``fpga``.
          +  For instance types with GPU accelerators, specify ``gpu``.
          +  For instance types with Inference accelerators, specify ``inference``.
          
         Default: Any accelerator type
        """
        return pulumi.get(self, "accelerator_types")

    @_builtins.property
    @pulumi.getter(name="allowedInstanceTypes")
    def allowed_instance_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        The instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes.
         You can use strings with one or more wild cards, represented by an asterisk (``*``), to allow an instance type, size, or generation. The following are examples: ``m5.8xlarge``, ``c5*.*``, ``m5a.*``, ``r*``, ``*3*``.
         For example, if you specify ``c5*``,Amazon EC2 will allow the entire C5 instance family, which includes all C5a and C5n instance types. If you specify ``m5a.*``, Amazon EC2 will allow all the M5a instance types, but not the M5n instance types.
          If you specify ``AllowedInstanceTypes``, you can't specify ``ExcludedInstanceTypes``.
          Default: All instance types
        """
        return pulumi.get(self, "allowed_instance_types")

    @_builtins.property
    @pulumi.getter(name="bareMetal")
    def bare_metal(self) -> Optional[_builtins.str]:
        """
        Indicates whether bare metal instance types must be included, excluded, or required.
          +  To include bare metal instance types, specify ``included``.
          +  To require only bare metal instance types, specify ``required``.
          +  To exclude bare metal instance types, specify ``excluded``.
          
         Default: ``excluded``
        """
        return pulumi.get(self, "bare_metal")

    @_builtins.property
    @pulumi.getter(name="baselineEbsBandwidthMbps")
    def baseline_ebs_bandwidth_mbps(self) -> Optional['outputs.LaunchTemplateBaselineEbsBandwidthMbps']:
        """
        The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see [Amazon EBSoptimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the *Amazon EC2 User Guide*.
         Default: No minimum or maximum limits
        """
        return pulumi.get(self, "baseline_ebs_bandwidth_mbps")

    @_builtins.property
    @pulumi.getter(name="baselinePerformanceFactors")
    def baseline_performance_factors(self) -> Optional['outputs.LaunchTemplateBaselinePerformanceFactors']:
        """
        The baseline performance to consider, using an instance family as a baseline reference. The instance family establishes the lowest acceptable level of performance. Amazon EC2 uses this baseline to guide instance type selection, but there is no guarantee that the selected instance types will always exceed the baseline for every application. Currently, this parameter only supports CPU performance as a baseline performance factor. For more information, see [Performance protection](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html#ec2fleet-abis-performance-protection) in the *Amazon EC2 User Guide*.
        """
        return pulumi.get(self, "baseline_performance_factors")

    @_builtins.property
    @pulumi.getter(name="burstablePerformance")
    def burstable_performance(self) -> Optional[_builtins.str]:
        """
        Indicates whether burstable performance T instance types are included, excluded, or required. For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html).
          +  To include burstable performance instance types, specify ``included``.
          +  To require only burstable performance instance types, specify ``required``.
          +  To exclude burstable performance instance types, specify ``excluded``.
          
         Default: ``excluded``
        """
        return pulumi.get(self, "burstable_performance")

    @_builtins.property
    @pulumi.getter(name="cpuManufacturers")
    def cpu_manufacturers(self) -> Optional[Sequence[_builtins.str]]:
        """
        The CPU manufacturers to include.
          +  For instance types with Intel CPUs, specify ``intel``.
          +  For instance types with AMD CPUs, specify ``amd``.
          +  For instance types with AWS CPUs, specify ``amazon-web-services``.
          +  For instance types with Apple CPUs, specify ``apple``.
          
          Don't confuse the CPU manufacturer with the CPU architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template.
          Default: Any manufacturer
        """
        return pulumi.get(self, "cpu_manufacturers")

    @_builtins.property
    @pulumi.getter(name="excludedInstanceTypes")
    def excluded_instance_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        The instance types to exclude.
         You can use strings with one or more wild cards, represented by an asterisk (``*``), to exclude an instance type, size, or generation. The following are examples: ``m5.8xlarge``, ``c5*.*``, ``m5a.*``, ``r*``, ``*3*``.
         For example, if you specify ``c5*``,Amazon EC2 will exclude the entire C5 instance family, which includes all C5a and C5n instance types. If you specify ``m5a.*``, Amazon EC2 will exclude all the M5a instance types, but not the M5n instance types.
          If you specify ``ExcludedInstanceTypes``, you can't specify ``AllowedInstanceTypes``.
          Default: No excluded instance types
        """
        return pulumi.get(self, "excluded_instance_types")

    @_builtins.property
    @pulumi.getter(name="instanceGenerations")
    def instance_generations(self) -> Optional[Sequence[_builtins.str]]:
        """
        Indicates whether current or previous generation instance types are included. The current generation instance types are recommended for use. Current generation instance types are typically the latest two to three generations in each instance family. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide*.
         For current generation instance types, specify ``current``.
         For previous generation instance types, specify ``previous``.
         Default: Current and previous generation instance types
        """
        return pulumi.get(self, "instance_generations")

    @_builtins.property
    @pulumi.getter(name="localStorage")
    def local_storage(self) -> Optional[_builtins.str]:
        """
        Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, [Amazon EC2 instance store](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html) in the *Amazon EC2 User Guide*.
          +  To include instance types with instance store volumes, specify ``included``.
          +  To require only instance types with instance store volumes, specify ``required``.
          +  To exclude instance types with instance store volumes, specify ``excluded``.
          
         Default: ``included``
        """
        return pulumi.get(self, "local_storage")

    @_builtins.property
    @pulumi.getter(name="localStorageTypes")
    def local_storage_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        The type of local storage that is required.
          +  For instance types with hard disk drive (HDD) storage, specify ``hdd``.
          +  For instance types with solid state drive (SSD) storage, specify ``ssd``.
          
         Default: ``hdd`` and ``ssd``
        """
        return pulumi.get(self, "local_storage_types")

    @_builtins.property
    @pulumi.getter(name="maxSpotPriceAsPercentageOfOptimalOnDemandPrice")
    def max_spot_price_as_percentage_of_optimal_on_demand_price(self) -> Optional[_builtins.int]:
        """
        [Price protection] The price protection threshold for Spot Instances, as a percentage of an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.
         The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
         If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib``, the price protection threshold is based on the per vCPU or per memory price instead of the per instance price.
          Only one of ``SpotMaxPricePercentageOverLowestPrice`` or ``MaxSpotPriceAsPercentageOfOptimalOnDemandPrice`` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as ``999999``.
        """
        return pulumi.get(self, "max_spot_price_as_percentage_of_optimal_on_demand_price")

    @_builtins.property
    @pulumi.getter(name="memoryGiBPerVCpu")
    def memory_gi_b_per_v_cpu(self) -> Optional['outputs.LaunchTemplateMemoryGiBPerVCpu']:
        """
        The minimum and maximum amount of memory per vCPU, in GiB.
         Default: No minimum or maximum limits
        """
        return pulumi.get(self, "memory_gi_b_per_v_cpu")

    @_builtins.property
    @pulumi.getter(name="memoryMiB")
    def memory_mi_b(self) -> Optional['outputs.LaunchTemplateMemoryMiB']:
        """
        The minimum and maximum amount of memory, in MiB.
        """
        return pulumi.get(self, "memory_mi_b")

    @_builtins.property
    @pulumi.getter(name="networkBandwidthGbps")
    def network_bandwidth_gbps(self) -> Optional['outputs.LaunchTemplateNetworkBandwidthGbps']:
        """
        The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps).
         Default: No minimum or maximum limits
        """
        return pulumi.get(self, "network_bandwidth_gbps")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceCount")
    def network_interface_count(self) -> Optional['outputs.LaunchTemplateNetworkInterfaceCount']:
        """
        The minimum and maximum number of network interfaces.
         Default: No minimum or maximum limits
        """
        return pulumi.get(self, "network_interface_count")

    @_builtins.property
    @pulumi.getter(name="onDemandMaxPricePercentageOverLowestPrice")
    def on_demand_max_price_percentage_over_lowest_price(self) -> Optional[_builtins.int]:
        """
        [Price protection] The price protection threshold for On-Demand Instances, as a percentage higher than an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.
         The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
         To turn off price protection, specify a high value, such as ``999999``.
         This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html).
          If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib``, the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.
          Default: ``20``
        """
        return pulumi.get(self, "on_demand_max_price_percentage_over_lowest_price")

    @_builtins.property
    @pulumi.getter(name="requireHibernateSupport")
    def require_hibernate_support(self) -> Optional[_builtins.bool]:
        """
        Indicates whether instance types must support hibernation for On-Demand Instances.
         This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html).
         Default: ``false``
        """
        return pulumi.get(self, "require_hibernate_support")

    @_builtins.property
    @pulumi.getter(name="spotMaxPricePercentageOverLowestPrice")
    def spot_max_price_percentage_over_lowest_price(self) -> Optional[_builtins.int]:
        """
        [Price protection] The price protection threshold for Spot Instances, as a percentage higher than an identified Spot price. The identified Spot price is the Spot price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified Spot price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose Spot price exceeds your specified threshold.
         The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
         If you set ``TargetCapacityUnitType`` to ``vcpu`` or ``memory-mib``, the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.
         This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html).
          Only one of ``SpotMaxPricePercentageOverLowestPrice`` or ``MaxSpotPriceAsPercentageOfOptimalOnDemandPrice`` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as ``999999``.
          Default: ``100``
        """
        return pulumi.get(self, "spot_max_price_percentage_over_lowest_price")

    @_builtins.property
    @pulumi.getter(name="totalLocalStorageGb")
    def total_local_storage_gb(self) -> Optional['outputs.LaunchTemplateTotalLocalStorageGb']:
        """
        The minimum and maximum amount of total local storage, in GB.
         Default: No minimum or maximum limits
        """
        return pulumi.get(self, "total_local_storage_gb")

    @_builtins.property
    @pulumi.getter(name="vCpuCount")
    def v_cpu_count(self) -> Optional['outputs.LaunchTemplateVCpuCount']:
        """
        The minimum and maximum number of vCPUs.
        """
        return pulumi.get(self, "v_cpu_count")


@pulumi.output_type
class LaunchTemplateIpv4PrefixSpecification(dict):
    """
    Specifies an IPv4 prefix for a network interface.
     ``Ipv4PrefixSpecification`` is a property of [AWS::EC2::LaunchTemplate NetworkInterface](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv4Prefix":
            suggest = "ipv4_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateIpv4PrefixSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateIpv4PrefixSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateIpv4PrefixSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv4_prefix: Optional[_builtins.str] = None):
        """
        Specifies an IPv4 prefix for a network interface.
         ``Ipv4PrefixSpecification`` is a property of [AWS::EC2::LaunchTemplate NetworkInterface](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html).
        :param _builtins.str ipv4_prefix: The IPv4 prefix. For information, see [Assigning prefixes to network interfaces](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-prefix-eni.html) in the *Amazon EC2 User Guide*.
        """
        if ipv4_prefix is not None:
            pulumi.set(__self__, "ipv4_prefix", ipv4_prefix)

    @_builtins.property
    @pulumi.getter(name="ipv4Prefix")
    def ipv4_prefix(self) -> Optional[_builtins.str]:
        """
        The IPv4 prefix. For information, see [Assigning prefixes to network interfaces](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-prefix-eni.html) in the *Amazon EC2 User Guide*.
        """
        return pulumi.get(self, "ipv4_prefix")


@pulumi.output_type
class LaunchTemplateIpv6Add(dict):
    """
    Specifies an IPv6 address in an Amazon EC2 launch template.
     ``Ipv6Add`` is a property of [AWS::EC2::LaunchTemplate NetworkInterface](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv6Address":
            suggest = "ipv6_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateIpv6Add. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateIpv6Add.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateIpv6Add.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv6_address: Optional[_builtins.str] = None):
        """
        Specifies an IPv6 address in an Amazon EC2 launch template.
         ``Ipv6Add`` is a property of [AWS::EC2::LaunchTemplate NetworkInterface](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html).
        :param _builtins.str ipv6_address: One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. You can't use this option if you're specifying a number of IPv6 addresses.
        """
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)

    @_builtins.property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[_builtins.str]:
        """
        One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. You can't use this option if you're specifying a number of IPv6 addresses.
        """
        return pulumi.get(self, "ipv6_address")


@pulumi.output_type
class LaunchTemplateIpv6PrefixSpecification(dict):
    """
    Specifies an IPv6 prefix for a network interface.
     ``Ipv6PrefixSpecification`` is a property of [AWS::EC2::LaunchTemplate NetworkInterface](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv6Prefix":
            suggest = "ipv6_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateIpv6PrefixSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateIpv6PrefixSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateIpv6PrefixSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv6_prefix: Optional[_builtins.str] = None):
        """
        Specifies an IPv6 prefix for a network interface.
         ``Ipv6PrefixSpecification`` is a property of [AWS::EC2::LaunchTemplate NetworkInterface](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html).
        :param _builtins.str ipv6_prefix: The IPv6 prefix.
        """
        if ipv6_prefix is not None:
            pulumi.set(__self__, "ipv6_prefix", ipv6_prefix)

    @_builtins.property
    @pulumi.getter(name="ipv6Prefix")
    def ipv6_prefix(self) -> Optional[_builtins.str]:
        """
        The IPv6 prefix.
        """
        return pulumi.get(self, "ipv6_prefix")


@pulumi.output_type
class LaunchTemplateLicenseSpecification(dict):
    """
    Specifies a license configuration for an instance.
     ``LicenseSpecification`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "licenseConfigurationArn":
            suggest = "license_configuration_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateLicenseSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateLicenseSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateLicenseSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 license_configuration_arn: Optional[_builtins.str] = None):
        """
        Specifies a license configuration for an instance.
         ``LicenseSpecification`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        :param _builtins.str license_configuration_arn: The Amazon Resource Name (ARN) of the license configuration.
        """
        if license_configuration_arn is not None:
            pulumi.set(__self__, "license_configuration_arn", license_configuration_arn)

    @_builtins.property
    @pulumi.getter(name="licenseConfigurationArn")
    def license_configuration_arn(self) -> Optional[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the license configuration.
        """
        return pulumi.get(self, "license_configuration_arn")


@pulumi.output_type
class LaunchTemplateMaintenanceOptions(dict):
    """
    The maintenance options of your instance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoRecovery":
            suggest = "auto_recovery"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateMaintenanceOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateMaintenanceOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateMaintenanceOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_recovery: Optional[_builtins.str] = None):
        """
        The maintenance options of your instance.
        :param _builtins.str auto_recovery: Disables the automatic recovery behavior of your instance or sets it to default.
        """
        if auto_recovery is not None:
            pulumi.set(__self__, "auto_recovery", auto_recovery)

    @_builtins.property
    @pulumi.getter(name="autoRecovery")
    def auto_recovery(self) -> Optional[_builtins.str]:
        """
        Disables the automatic recovery behavior of your instance or sets it to default.
        """
        return pulumi.get(self, "auto_recovery")


@pulumi.output_type
class LaunchTemplateMemoryGiBPerVCpu(dict):
    """
    The minimum and maximum amount of memory per vCPU, in GiB.
    """
    def __init__(__self__, *,
                 max: Optional[_builtins.float] = None,
                 min: Optional[_builtins.float] = None):
        """
        The minimum and maximum amount of memory per vCPU, in GiB.
        :param _builtins.float max: The maximum amount of memory per vCPU, in GiB. To specify no maximum limit, omit this parameter.
        :param _builtins.float min: The minimum amount of memory per vCPU, in GiB. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.float]:
        """
        The maximum amount of memory per vCPU, in GiB. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.float]:
        """
        The minimum amount of memory per vCPU, in GiB. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateMemoryMiB(dict):
    """
    The minimum and maximum amount of memory, in MiB.
    """
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        """
        The minimum and maximum amount of memory, in MiB.
        :param _builtins.int max: The maximum amount of memory, in MiB. To specify no maximum limit, omit this parameter.
        :param _builtins.int min: The minimum amount of memory, in MiB. To specify no minimum limit, specify ``0``.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        """
        The maximum amount of memory, in MiB. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        """
        The minimum amount of memory, in MiB. To specify no minimum limit, specify ``0``.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateMetadataOptions(dict):
    """
    The metadata options for the instance. For more information, see [Instance metadata and user data](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html) in the *Amazon EC2 User Guide*.
     ``MetadataOptions`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpEndpoint":
            suggest = "http_endpoint"
        elif key == "httpProtocolIpv6":
            suggest = "http_protocol_ipv6"
        elif key == "httpPutResponseHopLimit":
            suggest = "http_put_response_hop_limit"
        elif key == "httpTokens":
            suggest = "http_tokens"
        elif key == "instanceMetadataTags":
            suggest = "instance_metadata_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateMetadataOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateMetadataOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateMetadataOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_endpoint: Optional[_builtins.str] = None,
                 http_protocol_ipv6: Optional[_builtins.str] = None,
                 http_put_response_hop_limit: Optional[_builtins.int] = None,
                 http_tokens: Optional[_builtins.str] = None,
                 instance_metadata_tags: Optional[_builtins.str] = None):
        """
        The metadata options for the instance. For more information, see [Instance metadata and user data](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-metadata.html) in the *Amazon EC2 User Guide*.
         ``MetadataOptions`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        :param _builtins.str http_endpoint: Enables or disables the HTTP metadata endpoint on your instances. If the parameter is not specified, the default state is ``enabled``.
                 If you specify a value of ``disabled``, you will not be able to access your instance metadata.
        :param _builtins.str http_protocol_ipv6: Enables or disables the IPv6 endpoint for the instance metadata service.
                Default: ``disabled``
        :param _builtins.int http_put_response_hop_limit: The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel.
                Default: ``1``
                Possible values: Integers from 1 to 64
        :param _builtins.str http_tokens: Indicates whether IMDSv2 is required.
                 +  ``optional`` - IMDSv2 is optional. You can choose whether to send a session token in your instance metadata retrieval requests. If you retrieve IAM role credentials without a session token, you receive the IMDSv1 role credentials. If you retrieve IAM role credentials using a valid session token, you receive the IMDSv2 role credentials.
                 +  ``required`` - IMDSv2 is required. You must send a session token in your instance metadata retrieval requests. With this option, retrieving the IAM role credentials always returns IMDSv2 credentials; IMDSv1 credentials are not available.
                 
                Default: If the value of ``ImdsSupport`` for the Amazon Machine Image (AMI) for your instance is ``v2.0``, the default is ``required``.
        :param _builtins.str instance_metadata_tags: Set to ``enabled`` to allow access to instance tags from the instance metadata. Set to ``disabled`` to turn off access to instance tags from the instance metadata. For more information, see [View tags for your EC2 instances using instance metadata](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/work-with-tags-in-IMDS.html).
                Default: ``disabled``
        """
        if http_endpoint is not None:
            pulumi.set(__self__, "http_endpoint", http_endpoint)
        if http_protocol_ipv6 is not None:
            pulumi.set(__self__, "http_protocol_ipv6", http_protocol_ipv6)
        if http_put_response_hop_limit is not None:
            pulumi.set(__self__, "http_put_response_hop_limit", http_put_response_hop_limit)
        if http_tokens is not None:
            pulumi.set(__self__, "http_tokens", http_tokens)
        if instance_metadata_tags is not None:
            pulumi.set(__self__, "instance_metadata_tags", instance_metadata_tags)

    @_builtins.property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> Optional[_builtins.str]:
        """
        Enables or disables the HTTP metadata endpoint on your instances. If the parameter is not specified, the default state is ``enabled``.
          If you specify a value of ``disabled``, you will not be able to access your instance metadata.
        """
        return pulumi.get(self, "http_endpoint")

    @_builtins.property
    @pulumi.getter(name="httpProtocolIpv6")
    def http_protocol_ipv6(self) -> Optional[_builtins.str]:
        """
        Enables or disables the IPv6 endpoint for the instance metadata service.
         Default: ``disabled``
        """
        return pulumi.get(self, "http_protocol_ipv6")

    @_builtins.property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> Optional[_builtins.int]:
        """
        The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel.
         Default: ``1``
         Possible values: Integers from 1 to 64
        """
        return pulumi.get(self, "http_put_response_hop_limit")

    @_builtins.property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> Optional[_builtins.str]:
        """
        Indicates whether IMDSv2 is required.
          +  ``optional`` - IMDSv2 is optional. You can choose whether to send a session token in your instance metadata retrieval requests. If you retrieve IAM role credentials without a session token, you receive the IMDSv1 role credentials. If you retrieve IAM role credentials using a valid session token, you receive the IMDSv2 role credentials.
          +  ``required`` - IMDSv2 is required. You must send a session token in your instance metadata retrieval requests. With this option, retrieving the IAM role credentials always returns IMDSv2 credentials; IMDSv1 credentials are not available.
          
         Default: If the value of ``ImdsSupport`` for the Amazon Machine Image (AMI) for your instance is ``v2.0``, the default is ``required``.
        """
        return pulumi.get(self, "http_tokens")

    @_builtins.property
    @pulumi.getter(name="instanceMetadataTags")
    def instance_metadata_tags(self) -> Optional[_builtins.str]:
        """
        Set to ``enabled`` to allow access to instance tags from the instance metadata. Set to ``disabled`` to turn off access to instance tags from the instance metadata. For more information, see [View tags for your EC2 instances using instance metadata](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/work-with-tags-in-IMDS.html).
         Default: ``disabled``
        """
        return pulumi.get(self, "instance_metadata_tags")


@pulumi.output_type
class LaunchTemplateMonitoring(dict):
    """
    Specifies whether detailed monitoring is enabled for an instance. For more information about detailed monitoring, see [Enable or turn off detailed monitoring for your instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-cloudwatch-new.html) in the *User Guide*.
     ``Monitoring`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
    """
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        Specifies whether detailed monitoring is enabled for an instance. For more information about detailed monitoring, see [Enable or turn off detailed monitoring for your instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-cloudwatch-new.html) in the *User Guide*.
         ``Monitoring`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        :param _builtins.bool enabled: Specify ``true`` to enable detailed monitoring. Otherwise, basic monitoring is enabled.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Specify ``true`` to enable detailed monitoring. Otherwise, basic monitoring is enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class LaunchTemplateNetworkBandwidthGbps(dict):
    """
    The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps).
      Setting the minimum bandwidth does not guarantee that your instance will achieve the minimum bandwidth. Amazon EC2 will identify instance types that support the specified minimum bandwidth, but the actual bandwidth of your instance might go below the specified minimum at times. For more information, see [Available instance bandwidth](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-network-bandwidth.html#available-instance-bandwidth) in the *Amazon EC2 User Guide*.
    """
    def __init__(__self__, *,
                 max: Optional[_builtins.float] = None,
                 min: Optional[_builtins.float] = None):
        """
        The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps).
          Setting the minimum bandwidth does not guarantee that your instance will achieve the minimum bandwidth. Amazon EC2 will identify instance types that support the specified minimum bandwidth, but the actual bandwidth of your instance might go below the specified minimum at times. For more information, see [Available instance bandwidth](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-network-bandwidth.html#available-instance-bandwidth) in the *Amazon EC2 User Guide*.
        :param _builtins.float max: The maximum amount of network bandwidth, in Gbps. To specify no maximum limit, omit this parameter.
        :param _builtins.float min: The minimum amount of network bandwidth, in Gbps. If this parameter is not specified, there is no minimum limit.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.float]:
        """
        The maximum amount of network bandwidth, in Gbps. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.float]:
        """
        The minimum amount of network bandwidth, in Gbps. If this parameter is not specified, there is no minimum limit.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateNetworkInterface(dict):
    """
    Specifies the parameters for a network interface.
     ``NetworkInterface`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "associateCarrierIpAddress":
            suggest = "associate_carrier_ip_address"
        elif key == "associatePublicIpAddress":
            suggest = "associate_public_ip_address"
        elif key == "connectionTrackingSpecification":
            suggest = "connection_tracking_specification"
        elif key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "deviceIndex":
            suggest = "device_index"
        elif key == "enaQueueCount":
            suggest = "ena_queue_count"
        elif key == "enaSrdSpecification":
            suggest = "ena_srd_specification"
        elif key == "interfaceType":
            suggest = "interface_type"
        elif key == "ipv4PrefixCount":
            suggest = "ipv4_prefix_count"
        elif key == "ipv4Prefixes":
            suggest = "ipv4_prefixes"
        elif key == "ipv6AddressCount":
            suggest = "ipv6_address_count"
        elif key == "ipv6Addresses":
            suggest = "ipv6_addresses"
        elif key == "ipv6PrefixCount":
            suggest = "ipv6_prefix_count"
        elif key == "ipv6Prefixes":
            suggest = "ipv6_prefixes"
        elif key == "networkCardIndex":
            suggest = "network_card_index"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "primaryIpv6":
            suggest = "primary_ipv6"
        elif key == "privateIpAddress":
            suggest = "private_ip_address"
        elif key == "privateIpAddresses":
            suggest = "private_ip_addresses"
        elif key == "secondaryPrivateIpAddressCount":
            suggest = "secondary_private_ip_address_count"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 associate_carrier_ip_address: Optional[_builtins.bool] = None,
                 associate_public_ip_address: Optional[_builtins.bool] = None,
                 connection_tracking_specification: Optional['outputs.LaunchTemplateConnectionTrackingSpecification'] = None,
                 delete_on_termination: Optional[_builtins.bool] = None,
                 description: Optional[_builtins.str] = None,
                 device_index: Optional[_builtins.int] = None,
                 ena_queue_count: Optional[_builtins.int] = None,
                 ena_srd_specification: Optional['outputs.LaunchTemplateEnaSrdSpecification'] = None,
                 groups: Optional[Sequence[_builtins.str]] = None,
                 interface_type: Optional[_builtins.str] = None,
                 ipv4_prefix_count: Optional[_builtins.int] = None,
                 ipv4_prefixes: Optional[Sequence['outputs.LaunchTemplateIpv4PrefixSpecification']] = None,
                 ipv6_address_count: Optional[_builtins.int] = None,
                 ipv6_addresses: Optional[Sequence['outputs.LaunchTemplateIpv6Add']] = None,
                 ipv6_prefix_count: Optional[_builtins.int] = None,
                 ipv6_prefixes: Optional[Sequence['outputs.LaunchTemplateIpv6PrefixSpecification']] = None,
                 network_card_index: Optional[_builtins.int] = None,
                 network_interface_id: Optional[_builtins.str] = None,
                 primary_ipv6: Optional[_builtins.bool] = None,
                 private_ip_address: Optional[_builtins.str] = None,
                 private_ip_addresses: Optional[Sequence['outputs.LaunchTemplatePrivateIpAdd']] = None,
                 secondary_private_ip_address_count: Optional[_builtins.int] = None,
                 subnet_id: Optional[_builtins.str] = None):
        """
        Specifies the parameters for a network interface.
         ``NetworkInterface`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        :param _builtins.bool associate_carrier_ip_address: Associates a Carrier IP address with eth0 for a new network interface.
                Use this option when you launch an instance in a Wavelength Zone and want to associate a Carrier IP address with the network interface. For more information about Carrier IP addresses, see [Carrier IP addresses](https://docs.aws.amazon.com/wavelength/latest/developerguide/how-wavelengths-work.html#provider-owned-ip) in the *Developer Guide*.
        :param _builtins.bool associate_public_ip_address: Associates a public IPv4 address with eth0 for a new network interface.
                AWS charges for all public IPv4 addresses, including public IPv4 addresses associated with running instances and Elastic IP addresses. For more information, see the *Public IPv4 Address* tab on the [Amazon VPC pricing page](https://docs.aws.amazon.com/vpc/pricing/).
        :param 'LaunchTemplateConnectionTrackingSpecification' connection_tracking_specification: A connection tracking specification for the network interface.
        :param _builtins.bool delete_on_termination: Indicates whether the network interface is deleted when the instance is terminated.
        :param _builtins.str description: A description for the network interface.
        :param _builtins.int device_index: The device index for the network interface attachment. The primary network interface has a device index of 0. If the network interface is of type ``interface``, you must specify a device index.
                If you create a launch template that includes secondary network interfaces but no primary network interface, and you specify it using the ``LaunchTemplate`` property of ``AWS::EC2::Instance``, then you must include a primary network interface using the ``NetworkInterfaces`` property of ``AWS::EC2::Instance``.
        :param _builtins.int ena_queue_count: The number of ENA queues to be created with the instance.
        :param 'LaunchTemplateEnaSrdSpecification' ena_srd_specification: The ENA Express configuration for the network interface.
        :param Sequence[_builtins.str] groups: The IDs of one or more security groups.
        :param _builtins.str interface_type: The type of network interface. To create an Elastic Fabric Adapter (EFA), specify ``efa`` or ``efa``. For more information, see [Elastic Fabric Adapter for AI/ML and HPC workloads on Amazon EC2](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/efa.html) in the *Amazon EC2 User Guide*.
                If you are not creating an EFA, specify ``interface`` or omit this parameter.
                If you specify ``efa-only``, do not assign any IP addresses to the network interface. EFA-only network interfaces do not support IP addresses.
                Valid values: ``interface`` | ``efa`` | ``efa-only``
        :param _builtins.int ipv4_prefix_count: The number of IPv4 prefixes to be automatically assigned to the network interface. You cannot use this option if you use the ``Ipv4Prefix`` option.
        :param Sequence['LaunchTemplateIpv4PrefixSpecification'] ipv4_prefixes: One or more IPv4 prefixes to be assigned to the network interface. You cannot use this option if you use the ``Ipv4PrefixCount`` option.
        :param _builtins.int ipv6_address_count: The number of IPv6 addresses to assign to a network interface. Amazon EC2 automatically selects the IPv6 addresses from the subnet range. You can't use this option if specifying specific IPv6 addresses.
        :param Sequence['LaunchTemplateIpv6Add'] ipv6_addresses: One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. You can't use this option if you're specifying a number of IPv6 addresses.
        :param _builtins.int ipv6_prefix_count: The number of IPv6 prefixes to be automatically assigned to the network interface. You cannot use this option if you use the ``Ipv6Prefix`` option.
        :param Sequence['LaunchTemplateIpv6PrefixSpecification'] ipv6_prefixes: One or more IPv6 prefixes to be assigned to the network interface. You cannot use this option if you use the ``Ipv6PrefixCount`` option.
        :param _builtins.int network_card_index: The index of the network card. Some instance types support multiple network cards. The primary network interface must be assigned to network card index 0. The default is network card index 0.
        :param _builtins.str network_interface_id: The ID of the network interface.
        :param _builtins.bool primary_ipv6: The primary IPv6 address of the network interface. When you enable an IPv6 GUA address to be a primary IPv6, the first IPv6 GUA will be made the primary IPv6 address until the instance is terminated or the network interface is detached. For more information about primary IPv6 addresses, see [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html).
        :param _builtins.str private_ip_address: The primary private IPv4 address of the network interface.
        :param Sequence['LaunchTemplatePrivateIpAdd'] private_ip_addresses: One or more private IPv4 addresses.
        :param _builtins.int secondary_private_ip_address_count: The number of secondary private IPv4 addresses to assign to a network interface.
        :param _builtins.str subnet_id: The ID of the subnet for the network interface.
        """
        if associate_carrier_ip_address is not None:
            pulumi.set(__self__, "associate_carrier_ip_address", associate_carrier_ip_address)
        if associate_public_ip_address is not None:
            pulumi.set(__self__, "associate_public_ip_address", associate_public_ip_address)
        if connection_tracking_specification is not None:
            pulumi.set(__self__, "connection_tracking_specification", connection_tracking_specification)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if device_index is not None:
            pulumi.set(__self__, "device_index", device_index)
        if ena_queue_count is not None:
            pulumi.set(__self__, "ena_queue_count", ena_queue_count)
        if ena_srd_specification is not None:
            pulumi.set(__self__, "ena_srd_specification", ena_srd_specification)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if interface_type is not None:
            pulumi.set(__self__, "interface_type", interface_type)
        if ipv4_prefix_count is not None:
            pulumi.set(__self__, "ipv4_prefix_count", ipv4_prefix_count)
        if ipv4_prefixes is not None:
            pulumi.set(__self__, "ipv4_prefixes", ipv4_prefixes)
        if ipv6_address_count is not None:
            pulumi.set(__self__, "ipv6_address_count", ipv6_address_count)
        if ipv6_addresses is not None:
            pulumi.set(__self__, "ipv6_addresses", ipv6_addresses)
        if ipv6_prefix_count is not None:
            pulumi.set(__self__, "ipv6_prefix_count", ipv6_prefix_count)
        if ipv6_prefixes is not None:
            pulumi.set(__self__, "ipv6_prefixes", ipv6_prefixes)
        if network_card_index is not None:
            pulumi.set(__self__, "network_card_index", network_card_index)
        if network_interface_id is not None:
            pulumi.set(__self__, "network_interface_id", network_interface_id)
        if primary_ipv6 is not None:
            pulumi.set(__self__, "primary_ipv6", primary_ipv6)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)
        if private_ip_addresses is not None:
            pulumi.set(__self__, "private_ip_addresses", private_ip_addresses)
        if secondary_private_ip_address_count is not None:
            pulumi.set(__self__, "secondary_private_ip_address_count", secondary_private_ip_address_count)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="associateCarrierIpAddress")
    def associate_carrier_ip_address(self) -> Optional[_builtins.bool]:
        """
        Associates a Carrier IP address with eth0 for a new network interface.
         Use this option when you launch an instance in a Wavelength Zone and want to associate a Carrier IP address with the network interface. For more information about Carrier IP addresses, see [Carrier IP addresses](https://docs.aws.amazon.com/wavelength/latest/developerguide/how-wavelengths-work.html#provider-owned-ip) in the *Developer Guide*.
        """
        return pulumi.get(self, "associate_carrier_ip_address")

    @_builtins.property
    @pulumi.getter(name="associatePublicIpAddress")
    def associate_public_ip_address(self) -> Optional[_builtins.bool]:
        """
        Associates a public IPv4 address with eth0 for a new network interface.
         AWS charges for all public IPv4 addresses, including public IPv4 addresses associated with running instances and Elastic IP addresses. For more information, see the *Public IPv4 Address* tab on the [Amazon VPC pricing page](https://docs.aws.amazon.com/vpc/pricing/).
        """
        return pulumi.get(self, "associate_public_ip_address")

    @_builtins.property
    @pulumi.getter(name="connectionTrackingSpecification")
    def connection_tracking_specification(self) -> Optional['outputs.LaunchTemplateConnectionTrackingSpecification']:
        """
        A connection tracking specification for the network interface.
        """
        return pulumi.get(self, "connection_tracking_specification")

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the network interface is deleted when the instance is terminated.
        """
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description for the network interface.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> Optional[_builtins.int]:
        """
        The device index for the network interface attachment. The primary network interface has a device index of 0. If the network interface is of type ``interface``, you must specify a device index.
         If you create a launch template that includes secondary network interfaces but no primary network interface, and you specify it using the ``LaunchTemplate`` property of ``AWS::EC2::Instance``, then you must include a primary network interface using the ``NetworkInterfaces`` property of ``AWS::EC2::Instance``.
        """
        return pulumi.get(self, "device_index")

    @_builtins.property
    @pulumi.getter(name="enaQueueCount")
    def ena_queue_count(self) -> Optional[_builtins.int]:
        """
        The number of ENA queues to be created with the instance.
        """
        return pulumi.get(self, "ena_queue_count")

    @_builtins.property
    @pulumi.getter(name="enaSrdSpecification")
    def ena_srd_specification(self) -> Optional['outputs.LaunchTemplateEnaSrdSpecification']:
        """
        The ENA Express configuration for the network interface.
        """
        return pulumi.get(self, "ena_srd_specification")

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        The IDs of one or more security groups.
        """
        return pulumi.get(self, "groups")

    @_builtins.property
    @pulumi.getter(name="interfaceType")
    def interface_type(self) -> Optional[_builtins.str]:
        """
        The type of network interface. To create an Elastic Fabric Adapter (EFA), specify ``efa`` or ``efa``. For more information, see [Elastic Fabric Adapter for AI/ML and HPC workloads on Amazon EC2](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/efa.html) in the *Amazon EC2 User Guide*.
         If you are not creating an EFA, specify ``interface`` or omit this parameter.
         If you specify ``efa-only``, do not assign any IP addresses to the network interface. EFA-only network interfaces do not support IP addresses.
         Valid values: ``interface`` | ``efa`` | ``efa-only``
        """
        return pulumi.get(self, "interface_type")

    @_builtins.property
    @pulumi.getter(name="ipv4PrefixCount")
    def ipv4_prefix_count(self) -> Optional[_builtins.int]:
        """
        The number of IPv4 prefixes to be automatically assigned to the network interface. You cannot use this option if you use the ``Ipv4Prefix`` option.
        """
        return pulumi.get(self, "ipv4_prefix_count")

    @_builtins.property
    @pulumi.getter(name="ipv4Prefixes")
    def ipv4_prefixes(self) -> Optional[Sequence['outputs.LaunchTemplateIpv4PrefixSpecification']]:
        """
        One or more IPv4 prefixes to be assigned to the network interface. You cannot use this option if you use the ``Ipv4PrefixCount`` option.
        """
        return pulumi.get(self, "ipv4_prefixes")

    @_builtins.property
    @pulumi.getter(name="ipv6AddressCount")
    def ipv6_address_count(self) -> Optional[_builtins.int]:
        """
        The number of IPv6 addresses to assign to a network interface. Amazon EC2 automatically selects the IPv6 addresses from the subnet range. You can't use this option if specifying specific IPv6 addresses.
        """
        return pulumi.get(self, "ipv6_address_count")

    @_builtins.property
    @pulumi.getter(name="ipv6Addresses")
    def ipv6_addresses(self) -> Optional[Sequence['outputs.LaunchTemplateIpv6Add']]:
        """
        One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet. You can't use this option if you're specifying a number of IPv6 addresses.
        """
        return pulumi.get(self, "ipv6_addresses")

    @_builtins.property
    @pulumi.getter(name="ipv6PrefixCount")
    def ipv6_prefix_count(self) -> Optional[_builtins.int]:
        """
        The number of IPv6 prefixes to be automatically assigned to the network interface. You cannot use this option if you use the ``Ipv6Prefix`` option.
        """
        return pulumi.get(self, "ipv6_prefix_count")

    @_builtins.property
    @pulumi.getter(name="ipv6Prefixes")
    def ipv6_prefixes(self) -> Optional[Sequence['outputs.LaunchTemplateIpv6PrefixSpecification']]:
        """
        One or more IPv6 prefixes to be assigned to the network interface. You cannot use this option if you use the ``Ipv6PrefixCount`` option.
        """
        return pulumi.get(self, "ipv6_prefixes")

    @_builtins.property
    @pulumi.getter(name="networkCardIndex")
    def network_card_index(self) -> Optional[_builtins.int]:
        """
        The index of the network card. Some instance types support multiple network cards. The primary network interface must be assigned to network card index 0. The default is network card index 0.
        """
        return pulumi.get(self, "network_card_index")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[_builtins.str]:
        """
        The ID of the network interface.
        """
        return pulumi.get(self, "network_interface_id")

    @_builtins.property
    @pulumi.getter(name="primaryIpv6")
    def primary_ipv6(self) -> Optional[_builtins.bool]:
        """
        The primary IPv6 address of the network interface. When you enable an IPv6 GUA address to be a primary IPv6, the first IPv6 GUA will be made the primary IPv6 address until the instance is terminated or the network interface is detached. For more information about primary IPv6 addresses, see [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html).
        """
        return pulumi.get(self, "primary_ipv6")

    @_builtins.property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[_builtins.str]:
        """
        The primary private IPv4 address of the network interface.
        """
        return pulumi.get(self, "private_ip_address")

    @_builtins.property
    @pulumi.getter(name="privateIpAddresses")
    def private_ip_addresses(self) -> Optional[Sequence['outputs.LaunchTemplatePrivateIpAdd']]:
        """
        One or more private IPv4 addresses.
        """
        return pulumi.get(self, "private_ip_addresses")

    @_builtins.property
    @pulumi.getter(name="secondaryPrivateIpAddressCount")
    def secondary_private_ip_address_count(self) -> Optional[_builtins.int]:
        """
        The number of secondary private IPv4 addresses to assign to a network interface.
        """
        return pulumi.get(self, "secondary_private_ip_address_count")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        The ID of the subnet for the network interface.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class LaunchTemplateNetworkInterfaceCount(dict):
    """
    The minimum and maximum number of network interfaces.
    """
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        """
        The minimum and maximum number of network interfaces.
        :param _builtins.int max: The maximum number of network interfaces. To specify no maximum limit, omit this parameter.
        :param _builtins.int min: The minimum number of network interfaces. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        """
        The maximum number of network interfaces. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        """
        The minimum number of network interfaces. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateNetworkPerformanceOptions(dict):
    """
    Contains settings for the network performance options for the instance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bandwidthWeighting":
            suggest = "bandwidth_weighting"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateNetworkPerformanceOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateNetworkPerformanceOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateNetworkPerformanceOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bandwidth_weighting: Optional[_builtins.str] = None):
        """
        Contains settings for the network performance options for the instance.
        :param _builtins.str bandwidth_weighting: Specify the bandwidth weighting option to boost the associated type of baseline bandwidth, as follows:
                 + default This option uses the standard bandwidth configuration for your instance type. + vpc-1 This option boosts your networking baseline bandwidth and reduces your EBS baseline bandwidth. + ebs-1 This option boosts your EBS baseline bandwidth and reduces your networking baseline bandwidth.
        """
        if bandwidth_weighting is not None:
            pulumi.set(__self__, "bandwidth_weighting", bandwidth_weighting)

    @_builtins.property
    @pulumi.getter(name="bandwidthWeighting")
    def bandwidth_weighting(self) -> Optional[_builtins.str]:
        """
        Specify the bandwidth weighting option to boost the associated type of baseline bandwidth, as follows:
          + default This option uses the standard bandwidth configuration for your instance type. + vpc-1 This option boosts your networking baseline bandwidth and reduces your EBS baseline bandwidth. + ebs-1 This option boosts your EBS baseline bandwidth and reduces your networking baseline bandwidth.
        """
        return pulumi.get(self, "bandwidth_weighting")


@pulumi.output_type
class LaunchTemplatePlacement(dict):
    """
    Specifies the placement of an instance.
     ``Placement`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "groupId":
            suggest = "group_id"
        elif key == "groupName":
            suggest = "group_name"
        elif key == "hostId":
            suggest = "host_id"
        elif key == "hostResourceGroupArn":
            suggest = "host_resource_group_arn"
        elif key == "partitionNumber":
            suggest = "partition_number"
        elif key == "spreadDomain":
            suggest = "spread_domain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplatePlacement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplatePlacement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplatePlacement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 affinity: Optional[_builtins.str] = None,
                 availability_zone: Optional[_builtins.str] = None,
                 group_id: Optional[_builtins.str] = None,
                 group_name: Optional[_builtins.str] = None,
                 host_id: Optional[_builtins.str] = None,
                 host_resource_group_arn: Optional[_builtins.str] = None,
                 partition_number: Optional[_builtins.int] = None,
                 spread_domain: Optional[_builtins.str] = None,
                 tenancy: Optional[_builtins.str] = None):
        """
        Specifies the placement of an instance.
         ``Placement`` is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        :param _builtins.str affinity: The affinity setting for an instance on a Dedicated Host.
        :param _builtins.str availability_zone: The Availability Zone for the instance.
                Either ``AvailabilityZone`` or ``AvailabilityZoneId`` can be specified, but not both
        :param _builtins.str group_id: The Group Id of a placement group. You must specify the Placement Group *Group Id* to launch an instance in a shared placement group.
        :param _builtins.str group_name: The name of the placement group for the instance.
        :param _builtins.str host_id: The ID of the Dedicated Host for the instance.
        :param _builtins.str host_resource_group_arn: The ARN of the host resource group in which to launch the instances. If you specify a host resource group ARN, omit the *Tenancy* parameter or set it to ``host``.
        :param _builtins.int partition_number: The number of the partition the instance should launch in. Valid only if the placement group strategy is set to ``partition``.
        :param _builtins.str spread_domain: Reserved for future use.
        :param _builtins.str tenancy: The tenancy of the instance. An instance with a tenancy of dedicated runs on single-tenant hardware.
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if host_id is not None:
            pulumi.set(__self__, "host_id", host_id)
        if host_resource_group_arn is not None:
            pulumi.set(__self__, "host_resource_group_arn", host_resource_group_arn)
        if partition_number is not None:
            pulumi.set(__self__, "partition_number", partition_number)
        if spread_domain is not None:
            pulumi.set(__self__, "spread_domain", spread_domain)
        if tenancy is not None:
            pulumi.set(__self__, "tenancy", tenancy)

    @_builtins.property
    @pulumi.getter
    def affinity(self) -> Optional[_builtins.str]:
        """
        The affinity setting for an instance on a Dedicated Host.
        """
        return pulumi.get(self, "affinity")

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[_builtins.str]:
        """
        The Availability Zone for the instance.
         Either ``AvailabilityZone`` or ``AvailabilityZoneId`` can be specified, but not both
        """
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[_builtins.str]:
        """
        The Group Id of a placement group. You must specify the Placement Group *Group Id* to launch an instance in a shared placement group.
        """
        return pulumi.get(self, "group_id")

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[_builtins.str]:
        """
        The name of the placement group for the instance.
        """
        return pulumi.get(self, "group_name")

    @_builtins.property
    @pulumi.getter(name="hostId")
    def host_id(self) -> Optional[_builtins.str]:
        """
        The ID of the Dedicated Host for the instance.
        """
        return pulumi.get(self, "host_id")

    @_builtins.property
    @pulumi.getter(name="hostResourceGroupArn")
    def host_resource_group_arn(self) -> Optional[_builtins.str]:
        """
        The ARN of the host resource group in which to launch the instances. If you specify a host resource group ARN, omit the *Tenancy* parameter or set it to ``host``.
        """
        return pulumi.get(self, "host_resource_group_arn")

    @_builtins.property
    @pulumi.getter(name="partitionNumber")
    def partition_number(self) -> Optional[_builtins.int]:
        """
        The number of the partition the instance should launch in. Valid only if the placement group strategy is set to ``partition``.
        """
        return pulumi.get(self, "partition_number")

    @_builtins.property
    @pulumi.getter(name="spreadDomain")
    def spread_domain(self) -> Optional[_builtins.str]:
        """
        Reserved for future use.
        """
        return pulumi.get(self, "spread_domain")

    @_builtins.property
    @pulumi.getter
    def tenancy(self) -> Optional[_builtins.str]:
        """
        The tenancy of the instance. An instance with a tenancy of dedicated runs on single-tenant hardware.
        """
        return pulumi.get(self, "tenancy")


@pulumi.output_type
class LaunchTemplatePrivateDnsNameOptions(dict):
    """
    The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries should be handled. For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *User Guide*.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableResourceNameDnsARecord":
            suggest = "enable_resource_name_dns_a_record"
        elif key == "enableResourceNameDnsAaaaRecord":
            suggest = "enable_resource_name_dns_aaaa_record"
        elif key == "hostnameType":
            suggest = "hostname_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplatePrivateDnsNameOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplatePrivateDnsNameOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplatePrivateDnsNameOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_resource_name_dns_a_record: Optional[_builtins.bool] = None,
                 enable_resource_name_dns_aaaa_record: Optional[_builtins.bool] = None,
                 hostname_type: Optional[_builtins.str] = None):
        """
        The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries should be handled. For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *User Guide*.
        :param _builtins.bool enable_resource_name_dns_a_record: Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
        :param _builtins.bool enable_resource_name_dns_aaaa_record: Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
        :param _builtins.str hostname_type: The type of hostname for EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *User Guide*.
        """
        if enable_resource_name_dns_a_record is not None:
            pulumi.set(__self__, "enable_resource_name_dns_a_record", enable_resource_name_dns_a_record)
        if enable_resource_name_dns_aaaa_record is not None:
            pulumi.set(__self__, "enable_resource_name_dns_aaaa_record", enable_resource_name_dns_aaaa_record)
        if hostname_type is not None:
            pulumi.set(__self__, "hostname_type", hostname_type)

    @_builtins.property
    @pulumi.getter(name="enableResourceNameDnsARecord")
    def enable_resource_name_dns_a_record(self) -> Optional[_builtins.bool]:
        """
        Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
        """
        return pulumi.get(self, "enable_resource_name_dns_a_record")

    @_builtins.property
    @pulumi.getter(name="enableResourceNameDnsAaaaRecord")
    def enable_resource_name_dns_aaaa_record(self) -> Optional[_builtins.bool]:
        """
        Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
        """
        return pulumi.get(self, "enable_resource_name_dns_aaaa_record")

    @_builtins.property
    @pulumi.getter(name="hostnameType")
    def hostname_type(self) -> Optional[_builtins.str]:
        """
        The type of hostname for EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID. For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *User Guide*.
        """
        return pulumi.get(self, "hostname_type")


@pulumi.output_type
class LaunchTemplatePrivateIpAdd(dict):
    """
    Specifies a secondary private IPv4 address for a network interface.
     ``PrivateIpAdd`` is a property of [AWS::EC2::LaunchTemplate NetworkInterface](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIpAddress":
            suggest = "private_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplatePrivateIpAdd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplatePrivateIpAdd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplatePrivateIpAdd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 primary: Optional[_builtins.bool] = None,
                 private_ip_address: Optional[_builtins.str] = None):
        """
        Specifies a secondary private IPv4 address for a network interface.
         ``PrivateIpAdd`` is a property of [AWS::EC2::LaunchTemplate NetworkInterface](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-networkinterface.html).
        :param _builtins.bool primary: Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.
        :param _builtins.str private_ip_address: The private IPv4 address.
        """
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)

    @_builtins.property
    @pulumi.getter
    def primary(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.
        """
        return pulumi.get(self, "primary")

    @_builtins.property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[_builtins.str]:
        """
        The private IPv4 address.
        """
        return pulumi.get(self, "private_ip_address")


@pulumi.output_type
class LaunchTemplateReference(dict):
    """
    Specifies an instance family to use as the baseline reference for CPU performance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceFamily":
            suggest = "instance_family"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateReference. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateReference.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateReference.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_family: Optional[_builtins.str] = None):
        """
        Specifies an instance family to use as the baseline reference for CPU performance.
        :param _builtins.str instance_family: The instance family to use as a baseline reference.
                 Ensure that you specify the correct value for the instance family. The instance family is everything before the period (``.``) in the instance type name. For example, in the instance type ``c6i.large``, the instance family is ``c6i``, not ``c6``. For more information, see [Amazon EC2 instance type naming conventions](https://docs.aws.amazon.com/ec2/latest/instancetypes/instance-type-names.html) in *Amazon EC2 Instance Types*.
                 The following instance families are *not supported* for performance protection:
                 +   ``c1`` 
                 +  ``g3`` | ``g3s``
                 +   ``hpc7g`` 
                 +  ``m1`` | ``m2``
                 +  ``mac1`` | ``mac2`` | ``mac2-m1ultra`` | ``mac2-m2`` | ``mac2-m2pro``
                 +  ``p3dn`` | ``p4d`` | ``p5``
                 +   ``t1`` 
                 +  ``u-12tb1`` | ``u-18tb1`` | ``u-24tb1`` | ``u-3tb1`` | ``u-6tb1`` | ``u-9tb1`` | ``u7i-12tb`` | ``u7in-16tb`` | ``u7in-24tb`` | ``u7in-32tb``
                 
                If you enable performance protection by specifying a supported instance family, the returned instance types will exclude the above unsupported instance families.
        """
        if instance_family is not None:
            pulumi.set(__self__, "instance_family", instance_family)

    @_builtins.property
    @pulumi.getter(name="instanceFamily")
    def instance_family(self) -> Optional[_builtins.str]:
        """
        The instance family to use as a baseline reference.
          Ensure that you specify the correct value for the instance family. The instance family is everything before the period (``.``) in the instance type name. For example, in the instance type ``c6i.large``, the instance family is ``c6i``, not ``c6``. For more information, see [Amazon EC2 instance type naming conventions](https://docs.aws.amazon.com/ec2/latest/instancetypes/instance-type-names.html) in *Amazon EC2 Instance Types*.
          The following instance families are *not supported* for performance protection:
          +   ``c1`` 
          +  ``g3`` | ``g3s``
          +   ``hpc7g`` 
          +  ``m1`` | ``m2``
          +  ``mac1`` | ``mac2`` | ``mac2-m1ultra`` | ``mac2-m2`` | ``mac2-m2pro``
          +  ``p3dn`` | ``p4d`` | ``p5``
          +   ``t1`` 
          +  ``u-12tb1`` | ``u-18tb1`` | ``u-24tb1`` | ``u-3tb1`` | ``u-6tb1`` | ``u-9tb1`` | ``u7i-12tb`` | ``u7in-16tb`` | ``u7in-24tb`` | ``u7in-32tb``
          
         If you enable performance protection by specifying a supported instance family, the returned instance types will exclude the above unsupported instance families.
        """
        return pulumi.get(self, "instance_family")


@pulumi.output_type
class LaunchTemplateSpotOptions(dict):
    """
    Specifies options for Spot Instances.
     ``SpotOptions`` is a property of [AWS::EC2::LaunchTemplate InstanceMarketOptions](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancemarketoptions.html).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockDurationMinutes":
            suggest = "block_duration_minutes"
        elif key == "instanceInterruptionBehavior":
            suggest = "instance_interruption_behavior"
        elif key == "maxPrice":
            suggest = "max_price"
        elif key == "spotInstanceType":
            suggest = "spot_instance_type"
        elif key == "validUntil":
            suggest = "valid_until"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateSpotOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateSpotOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateSpotOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 block_duration_minutes: Optional[_builtins.int] = None,
                 instance_interruption_behavior: Optional[_builtins.str] = None,
                 max_price: Optional[_builtins.str] = None,
                 spot_instance_type: Optional[_builtins.str] = None,
                 valid_until: Optional[_builtins.str] = None):
        """
        Specifies options for Spot Instances.
         ``SpotOptions`` is a property of [AWS::EC2::LaunchTemplate InstanceMarketOptions](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata-instancemarketoptions.html).
        :param _builtins.int block_duration_minutes: Deprecated.
        :param _builtins.str instance_interruption_behavior: The behavior when a Spot Instance is interrupted. The default is ``terminate``.
        :param _builtins.str max_price: The maximum hourly price you're willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price. If you do specify this parameter, it must be more than USD $0.001. Specifying a value below USD $0.001 will result in an ``InvalidParameterValue`` error message when the launch template is used to launch an instance.
                 If you specify a maximum price, your Spot Instances will be interrupted more frequently than if you do not specify this parameter.
        :param _builtins.str spot_instance_type: The Spot Instance request type.
                If you are using Spot Instances with an Auto Scaling group, use ``one-time`` requests, as the ASlong service handles requesting new Spot Instances whenever the group is below its desired capacity.
        :param _builtins.str valid_until: The end date of the request, in UTC format (*YYYY-MM-DD*T*HH:MM:SS*Z). Supported only for persistent requests.
                 +  For a persistent request, the request remains active until the ``ValidUntil`` date and time is reached. Otherwise, the request remains active until you cancel it.
                 +  For a one-time request, ``ValidUntil`` is not supported. The request remains active until all instances launch or you cancel the request.
                 
                Default: 7 days from the current date
        """
        if block_duration_minutes is not None:
            pulumi.set(__self__, "block_duration_minutes", block_duration_minutes)
        if instance_interruption_behavior is not None:
            pulumi.set(__self__, "instance_interruption_behavior", instance_interruption_behavior)
        if max_price is not None:
            pulumi.set(__self__, "max_price", max_price)
        if spot_instance_type is not None:
            pulumi.set(__self__, "spot_instance_type", spot_instance_type)
        if valid_until is not None:
            pulumi.set(__self__, "valid_until", valid_until)

    @_builtins.property
    @pulumi.getter(name="blockDurationMinutes")
    def block_duration_minutes(self) -> Optional[_builtins.int]:
        """
        Deprecated.
        """
        return pulumi.get(self, "block_duration_minutes")

    @_builtins.property
    @pulumi.getter(name="instanceInterruptionBehavior")
    def instance_interruption_behavior(self) -> Optional[_builtins.str]:
        """
        The behavior when a Spot Instance is interrupted. The default is ``terminate``.
        """
        return pulumi.get(self, "instance_interruption_behavior")

    @_builtins.property
    @pulumi.getter(name="maxPrice")
    def max_price(self) -> Optional[_builtins.str]:
        """
        The maximum hourly price you're willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price. If you do specify this parameter, it must be more than USD $0.001. Specifying a value below USD $0.001 will result in an ``InvalidParameterValue`` error message when the launch template is used to launch an instance.
          If you specify a maximum price, your Spot Instances will be interrupted more frequently than if you do not specify this parameter.
        """
        return pulumi.get(self, "max_price")

    @_builtins.property
    @pulumi.getter(name="spotInstanceType")
    def spot_instance_type(self) -> Optional[_builtins.str]:
        """
        The Spot Instance request type.
         If you are using Spot Instances with an Auto Scaling group, use ``one-time`` requests, as the ASlong service handles requesting new Spot Instances whenever the group is below its desired capacity.
        """
        return pulumi.get(self, "spot_instance_type")

    @_builtins.property
    @pulumi.getter(name="validUntil")
    def valid_until(self) -> Optional[_builtins.str]:
        """
        The end date of the request, in UTC format (*YYYY-MM-DD*T*HH:MM:SS*Z). Supported only for persistent requests.
          +  For a persistent request, the request remains active until the ``ValidUntil`` date and time is reached. Otherwise, the request remains active until you cancel it.
          +  For a one-time request, ``ValidUntil`` is not supported. The request remains active until all instances launch or you cancel the request.
          
         Default: 7 days from the current date
        """
        return pulumi.get(self, "valid_until")


@pulumi.output_type
class LaunchTemplateTag(dict):
    """
    Specifies a tag. For more information, see [Resource tags](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html).
    """
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        Specifies a tag. For more information, see [Resource tags](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-resource-tags.html).
        :param _builtins.str key: The tag key.
        :param _builtins.str value: The tag value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The tag value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class LaunchTemplateTagSpecification(dict):
    """
    Specifies the tags to apply to the launch template during creation.
     To specify the tags for the resources that are created during instance launch, use [AWS::EC2::LaunchTemplate TagSpecification](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-tagspecification.html).
     ``LaunchTemplateTagSpecification`` is a property of [AWS::EC2::LaunchTemplate](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateTagSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateTagSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateTagSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_type: Optional[_builtins.str] = None,
                 tags: Optional[Sequence['outputs.LaunchTemplateTag']] = None):
        """
        Specifies the tags to apply to the launch template during creation.
         To specify the tags for the resources that are created during instance launch, use [AWS::EC2::LaunchTemplate TagSpecification](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-tagspecification.html).
         ``LaunchTemplateTagSpecification`` is a property of [AWS::EC2::LaunchTemplate](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html).
        :param _builtins.str resource_type: The type of resource. To tag a launch template, ``ResourceType`` must be ``launch-template``.
        :param Sequence['LaunchTemplateTag'] tags: The tags for the resource.
        """
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[_builtins.str]:
        """
        The type of resource. To tag a launch template, ``ResourceType`` must be ``launch-template``.
        """
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.LaunchTemplateTag']]:
        """
        The tags for the resource.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class LaunchTemplateTotalLocalStorageGb(dict):
    """
    The minimum and maximum amount of total local storage, in GB.
    """
    def __init__(__self__, *,
                 max: Optional[_builtins.float] = None,
                 min: Optional[_builtins.float] = None):
        """
        The minimum and maximum amount of total local storage, in GB.
        :param _builtins.float max: The maximum amount of total local storage, in GB. To specify no maximum limit, omit this parameter.
        :param _builtins.float min: The minimum amount of total local storage, in GB. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.float]:
        """
        The maximum amount of total local storage, in GB. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.float]:
        """
        The minimum amount of total local storage, in GB. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateVCpuCount(dict):
    """
    The minimum and maximum number of vCPUs.
    """
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        """
        The minimum and maximum number of vCPUs.
        :param _builtins.int max: The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
        :param _builtins.int min: The minimum number of vCPUs. To specify no minimum limit, specify ``0``.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        """
        The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        """
        The minimum number of vCPUs. To specify no minimum limit, specify ``0``.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class NetworkInsightsAccessScopeAccessScopePathRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "throughResources":
            suggest = "through_resources"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAccessScopeAccessScopePathRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAccessScopeAccessScopePathRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAccessScopeAccessScopePathRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: Optional['outputs.NetworkInsightsAccessScopePathStatementRequest'] = None,
                 source: Optional['outputs.NetworkInsightsAccessScopePathStatementRequest'] = None,
                 through_resources: Optional[Sequence['outputs.NetworkInsightsAccessScopeThroughResourcesStatementRequest']] = None):
        """
        :param 'NetworkInsightsAccessScopePathStatementRequest' destination: The destination.
        :param 'NetworkInsightsAccessScopePathStatementRequest' source: The source.
        :param Sequence['NetworkInsightsAccessScopeThroughResourcesStatementRequest'] through_resources: The through resources.
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if through_resources is not None:
            pulumi.set(__self__, "through_resources", through_resources)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional['outputs.NetworkInsightsAccessScopePathStatementRequest']:
        """
        The destination.
        """
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional['outputs.NetworkInsightsAccessScopePathStatementRequest']:
        """
        The source.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="throughResources")
    def through_resources(self) -> Optional[Sequence['outputs.NetworkInsightsAccessScopeThroughResourcesStatementRequest']]:
        """
        The through resources.
        """
        return pulumi.get(self, "through_resources")


@pulumi.output_type
class NetworkInsightsAccessScopePacketHeaderStatementRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddresses":
            suggest = "destination_addresses"
        elif key == "destinationPorts":
            suggest = "destination_ports"
        elif key == "destinationPrefixLists":
            suggest = "destination_prefix_lists"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourcePorts":
            suggest = "source_ports"
        elif key == "sourcePrefixLists":
            suggest = "source_prefix_lists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAccessScopePacketHeaderStatementRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAccessScopePacketHeaderStatementRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAccessScopePacketHeaderStatementRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_addresses: Optional[Sequence[_builtins.str]] = None,
                 destination_ports: Optional[Sequence[_builtins.str]] = None,
                 destination_prefix_lists: Optional[Sequence[_builtins.str]] = None,
                 protocols: Optional[Sequence['NetworkInsightsAccessScopeProtocol']] = None,
                 source_addresses: Optional[Sequence[_builtins.str]] = None,
                 source_ports: Optional[Sequence[_builtins.str]] = None,
                 source_prefix_lists: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] destination_addresses: The destination addresses.
        :param Sequence[_builtins.str] destination_ports: The destination ports.
        :param Sequence[_builtins.str] destination_prefix_lists: The destination prefix lists.
        :param Sequence['NetworkInsightsAccessScopeProtocol'] protocols: The protocols.
        :param Sequence[_builtins.str] source_addresses: The source addresses.
        :param Sequence[_builtins.str] source_ports: The source ports.
        :param Sequence[_builtins.str] source_prefix_lists: The source prefix lists.
        """
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if destination_ports is not None:
            pulumi.set(__self__, "destination_ports", destination_ports)
        if destination_prefix_lists is not None:
            pulumi.set(__self__, "destination_prefix_lists", destination_prefix_lists)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_ports is not None:
            pulumi.set(__self__, "source_ports", source_ports)
        if source_prefix_lists is not None:
            pulumi.set(__self__, "source_prefix_lists", source_prefix_lists)

    @_builtins.property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        The destination addresses.
        """
        return pulumi.get(self, "destination_addresses")

    @_builtins.property
    @pulumi.getter(name="destinationPorts")
    def destination_ports(self) -> Optional[Sequence[_builtins.str]]:
        """
        The destination ports.
        """
        return pulumi.get(self, "destination_ports")

    @_builtins.property
    @pulumi.getter(name="destinationPrefixLists")
    def destination_prefix_lists(self) -> Optional[Sequence[_builtins.str]]:
        """
        The destination prefix lists.
        """
        return pulumi.get(self, "destination_prefix_lists")

    @_builtins.property
    @pulumi.getter
    def protocols(self) -> Optional[Sequence['NetworkInsightsAccessScopeProtocol']]:
        """
        The protocols.
        """
        return pulumi.get(self, "protocols")

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        The source addresses.
        """
        return pulumi.get(self, "source_addresses")

    @_builtins.property
    @pulumi.getter(name="sourcePorts")
    def source_ports(self) -> Optional[Sequence[_builtins.str]]:
        """
        The source ports.
        """
        return pulumi.get(self, "source_ports")

    @_builtins.property
    @pulumi.getter(name="sourcePrefixLists")
    def source_prefix_lists(self) -> Optional[Sequence[_builtins.str]]:
        """
        The source prefix lists.
        """
        return pulumi.get(self, "source_prefix_lists")


@pulumi.output_type
class NetworkInsightsAccessScopePathStatementRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "packetHeaderStatement":
            suggest = "packet_header_statement"
        elif key == "resourceStatement":
            suggest = "resource_statement"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAccessScopePathStatementRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAccessScopePathStatementRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAccessScopePathStatementRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 packet_header_statement: Optional['outputs.NetworkInsightsAccessScopePacketHeaderStatementRequest'] = None,
                 resource_statement: Optional['outputs.NetworkInsightsAccessScopeResourceStatementRequest'] = None):
        """
        :param 'NetworkInsightsAccessScopePacketHeaderStatementRequest' packet_header_statement: The packet header statement.
        :param 'NetworkInsightsAccessScopeResourceStatementRequest' resource_statement: The resource statement.
        """
        if packet_header_statement is not None:
            pulumi.set(__self__, "packet_header_statement", packet_header_statement)
        if resource_statement is not None:
            pulumi.set(__self__, "resource_statement", resource_statement)

    @_builtins.property
    @pulumi.getter(name="packetHeaderStatement")
    def packet_header_statement(self) -> Optional['outputs.NetworkInsightsAccessScopePacketHeaderStatementRequest']:
        """
        The packet header statement.
        """
        return pulumi.get(self, "packet_header_statement")

    @_builtins.property
    @pulumi.getter(name="resourceStatement")
    def resource_statement(self) -> Optional['outputs.NetworkInsightsAccessScopeResourceStatementRequest']:
        """
        The resource statement.
        """
        return pulumi.get(self, "resource_statement")


@pulumi.output_type
class NetworkInsightsAccessScopeResourceStatementRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceTypes":
            suggest = "resource_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAccessScopeResourceStatementRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAccessScopeResourceStatementRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAccessScopeResourceStatementRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_types: Optional[Sequence[_builtins.str]] = None,
                 resources: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] resource_types: The resource types.
        :param Sequence[_builtins.str] resources: The resources.
        """
        if resource_types is not None:
            pulumi.set(__self__, "resource_types", resource_types)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter(name="resourceTypes")
    def resource_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        The resource types.
        """
        return pulumi.get(self, "resource_types")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional[Sequence[_builtins.str]]:
        """
        The resources.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class NetworkInsightsAccessScopeThroughResourcesStatementRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceStatement":
            suggest = "resource_statement"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAccessScopeThroughResourcesStatementRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAccessScopeThroughResourcesStatementRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAccessScopeThroughResourcesStatementRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_statement: Optional['outputs.NetworkInsightsAccessScopeResourceStatementRequest'] = None):
        """
        :param 'NetworkInsightsAccessScopeResourceStatementRequest' resource_statement: The resource statement.
        """
        if resource_statement is not None:
            pulumi.set(__self__, "resource_statement", resource_statement)

    @_builtins.property
    @pulumi.getter(name="resourceStatement")
    def resource_statement(self) -> Optional['outputs.NetworkInsightsAccessScopeResourceStatementRequest']:
        """
        The resource statement.
        """
        return pulumi.get(self, "resource_statement")


@pulumi.output_type
class NetworkInsightsAnalysisAdditionalDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalDetailType":
            suggest = "additional_detail_type"
        elif key == "loadBalancers":
            suggest = "load_balancers"
        elif key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisAdditionalDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisAdditionalDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisAdditionalDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_detail_type: Optional[_builtins.str] = None,
                 component: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 load_balancers: Optional[Sequence['outputs.NetworkInsightsAnalysisAnalysisComponent']] = None,
                 service_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str additional_detail_type: The additional detail code.
        :param 'NetworkInsightsAnalysisAnalysisComponent' component: The path component.
        :param Sequence['NetworkInsightsAnalysisAnalysisComponent'] load_balancers: The load balancers.
        :param _builtins.str service_name: The name of the VPC endpoint service.
        """
        if additional_detail_type is not None:
            pulumi.set(__self__, "additional_detail_type", additional_detail_type)
        if component is not None:
            pulumi.set(__self__, "component", component)
        if load_balancers is not None:
            pulumi.set(__self__, "load_balancers", load_balancers)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @_builtins.property
    @pulumi.getter(name="additionalDetailType")
    def additional_detail_type(self) -> Optional[_builtins.str]:
        """
        The additional detail code.
        """
        return pulumi.get(self, "additional_detail_type")

    @_builtins.property
    @pulumi.getter
    def component(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The path component.
        """
        return pulumi.get(self, "component")

    @_builtins.property
    @pulumi.getter(name="loadBalancers")
    def load_balancers(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisAnalysisComponent']]:
        """
        The load balancers.
        """
        return pulumi.get(self, "load_balancers")

    @_builtins.property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[_builtins.str]:
        """
        The name of the VPC endpoint service.
        """
        return pulumi.get(self, "service_name")


@pulumi.output_type
class NetworkInsightsAnalysisAlternatePathHint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "componentArn":
            suggest = "component_arn"
        elif key == "componentId":
            suggest = "component_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisAlternatePathHint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisAlternatePathHint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisAlternatePathHint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component_arn: Optional[_builtins.str] = None,
                 component_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str component_arn: The Amazon Resource Name (ARN) of the component.
        :param _builtins.str component_id: The ID of the component.
        """
        if component_arn is not None:
            pulumi.set(__self__, "component_arn", component_arn)
        if component_id is not None:
            pulumi.set(__self__, "component_id", component_id)

    @_builtins.property
    @pulumi.getter(name="componentArn")
    def component_arn(self) -> Optional[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the component.
        """
        return pulumi.get(self, "component_arn")

    @_builtins.property
    @pulumi.getter(name="componentId")
    def component_id(self) -> Optional[_builtins.str]:
        """
        The ID of the component.
        """
        return pulumi.get(self, "component_id")


@pulumi.output_type
class NetworkInsightsAnalysisAnalysisAclRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portRange":
            suggest = "port_range"
        elif key == "ruleAction":
            suggest = "rule_action"
        elif key == "ruleNumber":
            suggest = "rule_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisAnalysisAclRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisAnalysisAclRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisAnalysisAclRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr: Optional[_builtins.str] = None,
                 egress: Optional[_builtins.bool] = None,
                 port_range: Optional['outputs.NetworkInsightsAnalysisPortRange'] = None,
                 protocol: Optional[_builtins.str] = None,
                 rule_action: Optional[_builtins.str] = None,
                 rule_number: Optional[_builtins.int] = None):
        """
        :param _builtins.str cidr: The IPv4 address range, in CIDR notation.
        :param _builtins.bool egress: Indicates whether the rule is an outbound rule.
        :param 'NetworkInsightsAnalysisPortRange' port_range: The range of ports.
        :param _builtins.str protocol: The protocol.
        :param _builtins.str rule_action: Indicates whether to allow or deny traffic that matches the rule.
        :param _builtins.int rule_number: The rule number.
        """
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if egress is not None:
            pulumi.set(__self__, "egress", egress)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if rule_action is not None:
            pulumi.set(__self__, "rule_action", rule_action)
        if rule_number is not None:
            pulumi.set(__self__, "rule_number", rule_number)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> Optional[_builtins.str]:
        """
        The IPv4 address range, in CIDR notation.
        """
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter
    def egress(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the rule is an outbound rule.
        """
        return pulumi.get(self, "egress")

    @_builtins.property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional['outputs.NetworkInsightsAnalysisPortRange']:
        """
        The range of ports.
        """
        return pulumi.get(self, "port_range")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        The protocol.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="ruleAction")
    def rule_action(self) -> Optional[_builtins.str]:
        """
        Indicates whether to allow or deny traffic that matches the rule.
        """
        return pulumi.get(self, "rule_action")

    @_builtins.property
    @pulumi.getter(name="ruleNumber")
    def rule_number(self) -> Optional[_builtins.int]:
        """
        The rule number.
        """
        return pulumi.get(self, "rule_number")


@pulumi.output_type
class NetworkInsightsAnalysisAnalysisComponent(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: The Amazon Resource Name (ARN) of the component.
        :param _builtins.str id: The ID of the component.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the component.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The ID of the component.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class NetworkInsightsAnalysisAnalysisLoadBalancerListener(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instancePort":
            suggest = "instance_port"
        elif key == "loadBalancerPort":
            suggest = "load_balancer_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisAnalysisLoadBalancerListener. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisAnalysisLoadBalancerListener.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisAnalysisLoadBalancerListener.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_port: Optional[_builtins.int] = None,
                 load_balancer_port: Optional[_builtins.int] = None):
        """
        :param _builtins.int instance_port: [Classic Load Balancers] The back-end port for the listener.
        :param _builtins.int load_balancer_port: The port on which the load balancer is listening.
        """
        if instance_port is not None:
            pulumi.set(__self__, "instance_port", instance_port)
        if load_balancer_port is not None:
            pulumi.set(__self__, "load_balancer_port", load_balancer_port)

    @_builtins.property
    @pulumi.getter(name="instancePort")
    def instance_port(self) -> Optional[_builtins.int]:
        """
        [Classic Load Balancers] The back-end port for the listener.
        """
        return pulumi.get(self, "instance_port")

    @_builtins.property
    @pulumi.getter(name="loadBalancerPort")
    def load_balancer_port(self) -> Optional[_builtins.int]:
        """
        The port on which the load balancer is listening.
        """
        return pulumi.get(self, "load_balancer_port")


@pulumi.output_type
class NetworkInsightsAnalysisAnalysisLoadBalancerTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisAnalysisLoadBalancerTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisAnalysisLoadBalancerTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisAnalysisLoadBalancerTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None,
                 availability_zone: Optional[_builtins.str] = None,
                 instance: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 port: Optional[_builtins.int] = None):
        """
        :param _builtins.str address: The IP address.
        :param _builtins.str availability_zone: The Availability Zone.
        :param 'NetworkInsightsAnalysisAnalysisComponent' instance: Information about the instance.
        :param _builtins.int port: The port on which the target is listening.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if instance is not None:
            pulumi.set(__self__, "instance", instance)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        The IP address.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[_builtins.str]:
        """
        The Availability Zone.
        """
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter
    def instance(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        Information about the instance.
        """
        return pulumi.get(self, "instance")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port on which the target is listening.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class NetworkInsightsAnalysisAnalysisPacketHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddresses":
            suggest = "destination_addresses"
        elif key == "destinationPortRanges":
            suggest = "destination_port_ranges"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourcePortRanges":
            suggest = "source_port_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisAnalysisPacketHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisAnalysisPacketHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisAnalysisPacketHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_addresses: Optional[Sequence[_builtins.str]] = None,
                 destination_port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisPortRange']] = None,
                 protocol: Optional[_builtins.str] = None,
                 source_addresses: Optional[Sequence[_builtins.str]] = None,
                 source_port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisPortRange']] = None):
        """
        :param Sequence[_builtins.str] destination_addresses: The destination addresses.
        :param Sequence['NetworkInsightsAnalysisPortRange'] destination_port_ranges: The destination port ranges.
        :param _builtins.str protocol: The protocol.
        :param Sequence[_builtins.str] source_addresses: The source addresses.
        :param Sequence['NetworkInsightsAnalysisPortRange'] source_port_ranges: The source port ranges.
        """
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if destination_port_ranges is not None:
            pulumi.set(__self__, "destination_port_ranges", destination_port_ranges)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_port_ranges is not None:
            pulumi.set(__self__, "source_port_ranges", source_port_ranges)

    @_builtins.property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        The destination addresses.
        """
        return pulumi.get(self, "destination_addresses")

    @_builtins.property
    @pulumi.getter(name="destinationPortRanges")
    def destination_port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisPortRange']]:
        """
        The destination port ranges.
        """
        return pulumi.get(self, "destination_port_ranges")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        The protocol.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        The source addresses.
        """
        return pulumi.get(self, "source_addresses")

    @_builtins.property
    @pulumi.getter(name="sourcePortRanges")
    def source_port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisPortRange']]:
        """
        The source port ranges.
        """
        return pulumi.get(self, "source_port_ranges")


@pulumi.output_type
class NetworkInsightsAnalysisAnalysisRouteTableRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationCidr":
            suggest = "destination_cidr"
        elif key == "destinationPrefixListId":
            suggest = "destination_prefix_list_id"
        elif key == "egressOnlyInternetGatewayId":
            suggest = "egress_only_internet_gateway_id"
        elif key == "gatewayId":
            suggest = "gateway_id"
        elif key == "instanceId":
            suggest = "instance_id"
        elif key == "natGatewayId":
            suggest = "nat_gateway_id"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "transitGatewayId":
            suggest = "transit_gateway_id"
        elif key == "vpcPeeringConnectionId":
            suggest = "vpc_peering_connection_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisAnalysisRouteTableRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisAnalysisRouteTableRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisAnalysisRouteTableRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_cidr: Optional[_builtins.str] = None,
                 destination_prefix_list_id: Optional[_builtins.str] = None,
                 egress_only_internet_gateway_id: Optional[_builtins.str] = None,
                 gateway_id: Optional[_builtins.str] = None,
                 instance_id: Optional[_builtins.str] = None,
                 nat_gateway_id: Optional[_builtins.str] = None,
                 network_interface_id: Optional[_builtins.str] = None,
                 origin: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None,
                 transit_gateway_id: Optional[_builtins.str] = None,
                 vpc_peering_connection_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str destination_cidr: The destination IPv4 address, in CIDR notation.
        :param _builtins.str destination_prefix_list_id: The prefix of the AWS service.
        :param _builtins.str egress_only_internet_gateway_id: The ID of an egress-only internet gateway.
        :param _builtins.str gateway_id: The ID of the gateway, such as an internet gateway or virtual private gateway.
        :param _builtins.str instance_id: The ID of the instance, such as a NAT instance.
        :param _builtins.str nat_gateway_id: The ID of a NAT gateway.
        :param _builtins.str network_interface_id: The ID of a network interface.
        :param _builtins.str origin: Describes how the route was created. The following are the possible values:
               
               - CreateRouteTable - The route was automatically created when the route table was created.
               - CreateRoute - The route was manually added to the route table.
               - EnableVgwRoutePropagation - The route was propagated by route propagation.
        :param _builtins.str state: The state. The following are the possible values:
               
               - active
               - blackhole
        :param _builtins.str transit_gateway_id: The ID of a transit gateway.
        :param _builtins.str vpc_peering_connection_id: The ID of a VPC peering connection.
        """
        if destination_cidr is not None:
            pulumi.set(__self__, "destination_cidr", destination_cidr)
        if destination_prefix_list_id is not None:
            pulumi.set(__self__, "destination_prefix_list_id", destination_prefix_list_id)
        if egress_only_internet_gateway_id is not None:
            pulumi.set(__self__, "egress_only_internet_gateway_id", egress_only_internet_gateway_id)
        if gateway_id is not None:
            pulumi.set(__self__, "gateway_id", gateway_id)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if nat_gateway_id is not None:
            pulumi.set(__self__, "nat_gateway_id", nat_gateway_id)
        if network_interface_id is not None:
            pulumi.set(__self__, "network_interface_id", network_interface_id)
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if transit_gateway_id is not None:
            pulumi.set(__self__, "transit_gateway_id", transit_gateway_id)
        if vpc_peering_connection_id is not None:
            pulumi.set(__self__, "vpc_peering_connection_id", vpc_peering_connection_id)

    @_builtins.property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> Optional[_builtins.str]:
        """
        The destination IPv4 address, in CIDR notation.
        """
        return pulumi.get(self, "destination_cidr")

    @_builtins.property
    @pulumi.getter(name="destinationPrefixListId")
    def destination_prefix_list_id(self) -> Optional[_builtins.str]:
        """
        The prefix of the AWS service.
        """
        return pulumi.get(self, "destination_prefix_list_id")

    @_builtins.property
    @pulumi.getter(name="egressOnlyInternetGatewayId")
    def egress_only_internet_gateway_id(self) -> Optional[_builtins.str]:
        """
        The ID of an egress-only internet gateway.
        """
        return pulumi.get(self, "egress_only_internet_gateway_id")

    @_builtins.property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> Optional[_builtins.str]:
        """
        The ID of the gateway, such as an internet gateway or virtual private gateway.
        """
        return pulumi.get(self, "gateway_id")

    @_builtins.property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[_builtins.str]:
        """
        The ID of the instance, such as a NAT instance.
        """
        return pulumi.get(self, "instance_id")

    @_builtins.property
    @pulumi.getter(name="natGatewayId")
    def nat_gateway_id(self) -> Optional[_builtins.str]:
        """
        The ID of a NAT gateway.
        """
        return pulumi.get(self, "nat_gateway_id")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[_builtins.str]:
        """
        The ID of a network interface.
        """
        return pulumi.get(self, "network_interface_id")

    @_builtins.property
    @pulumi.getter
    def origin(self) -> Optional[_builtins.str]:
        """
        Describes how the route was created. The following are the possible values:

        - CreateRouteTable - The route was automatically created when the route table was created.
        - CreateRoute - The route was manually added to the route table.
        - EnableVgwRoutePropagation - The route was propagated by route propagation.
        """
        return pulumi.get(self, "origin")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        The state. The following are the possible values:

        - active
        - blackhole
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="transitGatewayId")
    def transit_gateway_id(self) -> Optional[_builtins.str]:
        """
        The ID of a transit gateway.
        """
        return pulumi.get(self, "transit_gateway_id")

    @_builtins.property
    @pulumi.getter(name="vpcPeeringConnectionId")
    def vpc_peering_connection_id(self) -> Optional[_builtins.str]:
        """
        The ID of a VPC peering connection.
        """
        return pulumi.get(self, "vpc_peering_connection_id")


@pulumi.output_type
class NetworkInsightsAnalysisAnalysisSecurityGroupRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portRange":
            suggest = "port_range"
        elif key == "prefixListId":
            suggest = "prefix_list_id"
        elif key == "securityGroupId":
            suggest = "security_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisAnalysisSecurityGroupRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisAnalysisSecurityGroupRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisAnalysisSecurityGroupRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr: Optional[_builtins.str] = None,
                 direction: Optional[_builtins.str] = None,
                 port_range: Optional['outputs.NetworkInsightsAnalysisPortRange'] = None,
                 prefix_list_id: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None,
                 security_group_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str cidr: The IPv4 address range, in CIDR notation.
        :param _builtins.str direction: The direction. The following are the possible values:
               
               - egress
               - ingress
        :param 'NetworkInsightsAnalysisPortRange' port_range: The port range.
        :param _builtins.str prefix_list_id: The prefix list ID.
        :param _builtins.str protocol: The protocol name.
        :param _builtins.str security_group_id: The security group ID.
        """
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if prefix_list_id is not None:
            pulumi.set(__self__, "prefix_list_id", prefix_list_id)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if security_group_id is not None:
            pulumi.set(__self__, "security_group_id", security_group_id)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> Optional[_builtins.str]:
        """
        The IPv4 address range, in CIDR notation.
        """
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        The direction. The following are the possible values:

        - egress
        - ingress
        """
        return pulumi.get(self, "direction")

    @_builtins.property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional['outputs.NetworkInsightsAnalysisPortRange']:
        """
        The port range.
        """
        return pulumi.get(self, "port_range")

    @_builtins.property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> Optional[_builtins.str]:
        """
        The prefix list ID.
        """
        return pulumi.get(self, "prefix_list_id")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        The protocol name.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> Optional[_builtins.str]:
        """
        The security group ID.
        """
        return pulumi.get(self, "security_group_id")


@pulumi.output_type
class NetworkInsightsAnalysisExplanation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aclRule":
            suggest = "acl_rule"
        elif key == "attachedTo":
            suggest = "attached_to"
        elif key == "availabilityZones":
            suggest = "availability_zones"
        elif key == "classicLoadBalancerListener":
            suggest = "classic_load_balancer_listener"
        elif key == "componentAccount":
            suggest = "component_account"
        elif key == "componentRegion":
            suggest = "component_region"
        elif key == "customerGateway":
            suggest = "customer_gateway"
        elif key == "destinationVpc":
            suggest = "destination_vpc"
        elif key == "elasticLoadBalancerListener":
            suggest = "elastic_load_balancer_listener"
        elif key == "explanationCode":
            suggest = "explanation_code"
        elif key == "ingressRouteTable":
            suggest = "ingress_route_table"
        elif key == "internetGateway":
            suggest = "internet_gateway"
        elif key == "loadBalancerArn":
            suggest = "load_balancer_arn"
        elif key == "loadBalancerListenerPort":
            suggest = "load_balancer_listener_port"
        elif key == "loadBalancerTarget":
            suggest = "load_balancer_target"
        elif key == "loadBalancerTargetGroup":
            suggest = "load_balancer_target_group"
        elif key == "loadBalancerTargetGroups":
            suggest = "load_balancer_target_groups"
        elif key == "loadBalancerTargetPort":
            suggest = "load_balancer_target_port"
        elif key == "missingComponent":
            suggest = "missing_component"
        elif key == "natGateway":
            suggest = "nat_gateway"
        elif key == "networkInterface":
            suggest = "network_interface"
        elif key == "packetField":
            suggest = "packet_field"
        elif key == "portRanges":
            suggest = "port_ranges"
        elif key == "prefixList":
            suggest = "prefix_list"
        elif key == "routeTable":
            suggest = "route_table"
        elif key == "routeTableRoute":
            suggest = "route_table_route"
        elif key == "securityGroup":
            suggest = "security_group"
        elif key == "securityGroupRule":
            suggest = "security_group_rule"
        elif key == "securityGroups":
            suggest = "security_groups"
        elif key == "sourceVpc":
            suggest = "source_vpc"
        elif key == "subnetRouteTable":
            suggest = "subnet_route_table"
        elif key == "transitGateway":
            suggest = "transit_gateway"
        elif key == "transitGatewayAttachment":
            suggest = "transit_gateway_attachment"
        elif key == "transitGatewayRouteTable":
            suggest = "transit_gateway_route_table"
        elif key == "transitGatewayRouteTableRoute":
            suggest = "transit_gateway_route_table_route"
        elif key == "vpcEndpoint":
            suggest = "vpc_endpoint"
        elif key == "vpcPeeringConnection":
            suggest = "vpc_peering_connection"
        elif key == "vpnConnection":
            suggest = "vpn_connection"
        elif key == "vpnGateway":
            suggest = "vpn_gateway"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisExplanation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisExplanation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisExplanation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acl: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 acl_rule: Optional['outputs.NetworkInsightsAnalysisAnalysisAclRule'] = None,
                 address: Optional[_builtins.str] = None,
                 addresses: Optional[Sequence[_builtins.str]] = None,
                 attached_to: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 availability_zones: Optional[Sequence[_builtins.str]] = None,
                 cidrs: Optional[Sequence[_builtins.str]] = None,
                 classic_load_balancer_listener: Optional['outputs.NetworkInsightsAnalysisAnalysisLoadBalancerListener'] = None,
                 component: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 component_account: Optional[_builtins.str] = None,
                 component_region: Optional[_builtins.str] = None,
                 customer_gateway: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 destination: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 destination_vpc: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 direction: Optional[_builtins.str] = None,
                 elastic_load_balancer_listener: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 explanation_code: Optional[_builtins.str] = None,
                 ingress_route_table: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 internet_gateway: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 load_balancer_arn: Optional[_builtins.str] = None,
                 load_balancer_listener_port: Optional[_builtins.int] = None,
                 load_balancer_target: Optional['outputs.NetworkInsightsAnalysisAnalysisLoadBalancerTarget'] = None,
                 load_balancer_target_group: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 load_balancer_target_groups: Optional[Sequence['outputs.NetworkInsightsAnalysisAnalysisComponent']] = None,
                 load_balancer_target_port: Optional[_builtins.int] = None,
                 missing_component: Optional[_builtins.str] = None,
                 nat_gateway: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 network_interface: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 packet_field: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisPortRange']] = None,
                 prefix_list: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 protocols: Optional[Sequence[_builtins.str]] = None,
                 route_table: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 route_table_route: Optional['outputs.NetworkInsightsAnalysisAnalysisRouteTableRoute'] = None,
                 security_group: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 security_group_rule: Optional['outputs.NetworkInsightsAnalysisAnalysisSecurityGroupRule'] = None,
                 security_groups: Optional[Sequence['outputs.NetworkInsightsAnalysisAnalysisComponent']] = None,
                 source_vpc: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 state: Optional[_builtins.str] = None,
                 subnet: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 subnet_route_table: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 transit_gateway: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 transit_gateway_attachment: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 transit_gateway_route_table: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 transit_gateway_route_table_route: Optional['outputs.NetworkInsightsAnalysisTransitGatewayRouteTableRoute'] = None,
                 vpc: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 vpc_endpoint: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 vpc_peering_connection: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 vpn_connection: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 vpn_gateway: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None):
        """
        :param 'NetworkInsightsAnalysisAnalysisComponent' acl: The network ACL.
        :param 'NetworkInsightsAnalysisAnalysisAclRule' acl_rule: The network ACL rule.
        :param _builtins.str address: The IPv4 address, in CIDR notation.
        :param Sequence[_builtins.str] addresses: The IPv4 addresses, in CIDR notation.
        :param 'NetworkInsightsAnalysisAnalysisComponent' attached_to: The resource to which the component is attached.
        :param Sequence[_builtins.str] availability_zones: The Availability Zones.
        :param Sequence[_builtins.str] cidrs: The CIDR ranges.
        :param 'NetworkInsightsAnalysisAnalysisLoadBalancerListener' classic_load_balancer_listener: The listener for a Classic Load Balancer.
        :param 'NetworkInsightsAnalysisAnalysisComponent' component: The component.
        :param _builtins.str component_account: The AWS account for the component.
        :param _builtins.str component_region: The Region for the component.
        :param 'NetworkInsightsAnalysisAnalysisComponent' customer_gateway: The customer gateway.
        :param 'NetworkInsightsAnalysisAnalysisComponent' destination: The destination.
        :param 'NetworkInsightsAnalysisAnalysisComponent' destination_vpc: The destination VPC.
        :param _builtins.str direction: The direction. The following are the possible values:
               
               - egress
               - ingress
        :param 'NetworkInsightsAnalysisAnalysisComponent' elastic_load_balancer_listener: The load balancer listener.
        :param _builtins.str explanation_code: The explanation code.
        :param 'NetworkInsightsAnalysisAnalysisComponent' ingress_route_table: The route table.
        :param 'NetworkInsightsAnalysisAnalysisComponent' internet_gateway: The internet gateway.
        :param _builtins.str load_balancer_arn: The Amazon Resource Name (ARN) of the load balancer.
        :param _builtins.int load_balancer_listener_port: The listener port of the load balancer.
        :param 'NetworkInsightsAnalysisAnalysisLoadBalancerTarget' load_balancer_target: The target.
        :param 'NetworkInsightsAnalysisAnalysisComponent' load_balancer_target_group: The target group.
        :param Sequence['NetworkInsightsAnalysisAnalysisComponent'] load_balancer_target_groups: The target groups.
        :param _builtins.int load_balancer_target_port: The target port.
        :param _builtins.str missing_component: The missing component.
        :param 'NetworkInsightsAnalysisAnalysisComponent' nat_gateway: The NAT gateway.
        :param 'NetworkInsightsAnalysisAnalysisComponent' network_interface: The network interface.
        :param _builtins.str packet_field: The packet field.
        :param _builtins.int port: The port.
        :param Sequence['NetworkInsightsAnalysisPortRange'] port_ranges: The port ranges.
        :param 'NetworkInsightsAnalysisAnalysisComponent' prefix_list: The prefix list.
        :param Sequence[_builtins.str] protocols: The protocols.
        :param 'NetworkInsightsAnalysisAnalysisComponent' route_table: The route table.
        :param 'NetworkInsightsAnalysisAnalysisRouteTableRoute' route_table_route: The route table route.
        :param 'NetworkInsightsAnalysisAnalysisComponent' security_group: The security group.
        :param 'NetworkInsightsAnalysisAnalysisSecurityGroupRule' security_group_rule: The security group rule.
        :param Sequence['NetworkInsightsAnalysisAnalysisComponent'] security_groups: The security groups.
        :param 'NetworkInsightsAnalysisAnalysisComponent' source_vpc: The source VPC.
        :param _builtins.str state: The state.
        :param 'NetworkInsightsAnalysisAnalysisComponent' subnet: The subnet.
        :param 'NetworkInsightsAnalysisAnalysisComponent' subnet_route_table: The route table for the subnet.
        :param 'NetworkInsightsAnalysisAnalysisComponent' transit_gateway: The transit gateway.
        :param 'NetworkInsightsAnalysisAnalysisComponent' transit_gateway_attachment: The transit gateway attachment.
        :param 'NetworkInsightsAnalysisAnalysisComponent' transit_gateway_route_table: The transit gateway route table.
        :param 'NetworkInsightsAnalysisTransitGatewayRouteTableRoute' transit_gateway_route_table_route: The transit gateway route table route.
        :param 'NetworkInsightsAnalysisAnalysisComponent' vpc: The component VPC.
        :param 'NetworkInsightsAnalysisAnalysisComponent' vpc_endpoint: The VPC endpoint.
        :param 'NetworkInsightsAnalysisAnalysisComponent' vpc_peering_connection: The VPC peering connection.
        :param 'NetworkInsightsAnalysisAnalysisComponent' vpn_connection: The VPN connection.
        :param 'NetworkInsightsAnalysisAnalysisComponent' vpn_gateway: The VPN gateway.
        """
        if acl is not None:
            pulumi.set(__self__, "acl", acl)
        if acl_rule is not None:
            pulumi.set(__self__, "acl_rule", acl_rule)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)
        if attached_to is not None:
            pulumi.set(__self__, "attached_to", attached_to)
        if availability_zones is not None:
            pulumi.set(__self__, "availability_zones", availability_zones)
        if cidrs is not None:
            pulumi.set(__self__, "cidrs", cidrs)
        if classic_load_balancer_listener is not None:
            pulumi.set(__self__, "classic_load_balancer_listener", classic_load_balancer_listener)
        if component is not None:
            pulumi.set(__self__, "component", component)
        if component_account is not None:
            pulumi.set(__self__, "component_account", component_account)
        if component_region is not None:
            pulumi.set(__self__, "component_region", component_region)
        if customer_gateway is not None:
            pulumi.set(__self__, "customer_gateway", customer_gateway)
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if destination_vpc is not None:
            pulumi.set(__self__, "destination_vpc", destination_vpc)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if elastic_load_balancer_listener is not None:
            pulumi.set(__self__, "elastic_load_balancer_listener", elastic_load_balancer_listener)
        if explanation_code is not None:
            pulumi.set(__self__, "explanation_code", explanation_code)
        if ingress_route_table is not None:
            pulumi.set(__self__, "ingress_route_table", ingress_route_table)
        if internet_gateway is not None:
            pulumi.set(__self__, "internet_gateway", internet_gateway)
        if load_balancer_arn is not None:
            pulumi.set(__self__, "load_balancer_arn", load_balancer_arn)
        if load_balancer_listener_port is not None:
            pulumi.set(__self__, "load_balancer_listener_port", load_balancer_listener_port)
        if load_balancer_target is not None:
            pulumi.set(__self__, "load_balancer_target", load_balancer_target)
        if load_balancer_target_group is not None:
            pulumi.set(__self__, "load_balancer_target_group", load_balancer_target_group)
        if load_balancer_target_groups is not None:
            pulumi.set(__self__, "load_balancer_target_groups", load_balancer_target_groups)
        if load_balancer_target_port is not None:
            pulumi.set(__self__, "load_balancer_target_port", load_balancer_target_port)
        if missing_component is not None:
            pulumi.set(__self__, "missing_component", missing_component)
        if nat_gateway is not None:
            pulumi.set(__self__, "nat_gateway", nat_gateway)
        if network_interface is not None:
            pulumi.set(__self__, "network_interface", network_interface)
        if packet_field is not None:
            pulumi.set(__self__, "packet_field", packet_field)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if prefix_list is not None:
            pulumi.set(__self__, "prefix_list", prefix_list)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if route_table is not None:
            pulumi.set(__self__, "route_table", route_table)
        if route_table_route is not None:
            pulumi.set(__self__, "route_table_route", route_table_route)
        if security_group is not None:
            pulumi.set(__self__, "security_group", security_group)
        if security_group_rule is not None:
            pulumi.set(__self__, "security_group_rule", security_group_rule)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if source_vpc is not None:
            pulumi.set(__self__, "source_vpc", source_vpc)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)
        if subnet_route_table is not None:
            pulumi.set(__self__, "subnet_route_table", subnet_route_table)
        if transit_gateway is not None:
            pulumi.set(__self__, "transit_gateway", transit_gateway)
        if transit_gateway_attachment is not None:
            pulumi.set(__self__, "transit_gateway_attachment", transit_gateway_attachment)
        if transit_gateway_route_table is not None:
            pulumi.set(__self__, "transit_gateway_route_table", transit_gateway_route_table)
        if transit_gateway_route_table_route is not None:
            pulumi.set(__self__, "transit_gateway_route_table_route", transit_gateway_route_table_route)
        if vpc is not None:
            pulumi.set(__self__, "vpc", vpc)
        if vpc_endpoint is not None:
            pulumi.set(__self__, "vpc_endpoint", vpc_endpoint)
        if vpc_peering_connection is not None:
            pulumi.set(__self__, "vpc_peering_connection", vpc_peering_connection)
        if vpn_connection is not None:
            pulumi.set(__self__, "vpn_connection", vpn_connection)
        if vpn_gateway is not None:
            pulumi.set(__self__, "vpn_gateway", vpn_gateway)

    @_builtins.property
    @pulumi.getter
    def acl(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The network ACL.
        """
        return pulumi.get(self, "acl")

    @_builtins.property
    @pulumi.getter(name="aclRule")
    def acl_rule(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisAclRule']:
        """
        The network ACL rule.
        """
        return pulumi.get(self, "acl_rule")

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        The IPv4 address, in CIDR notation.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        The IPv4 addresses, in CIDR notation.
        """
        return pulumi.get(self, "addresses")

    @_builtins.property
    @pulumi.getter(name="attachedTo")
    def attached_to(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The resource to which the component is attached.
        """
        return pulumi.get(self, "attached_to")

    @_builtins.property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Optional[Sequence[_builtins.str]]:
        """
        The Availability Zones.
        """
        return pulumi.get(self, "availability_zones")

    @_builtins.property
    @pulumi.getter
    def cidrs(self) -> Optional[Sequence[_builtins.str]]:
        """
        The CIDR ranges.
        """
        return pulumi.get(self, "cidrs")

    @_builtins.property
    @pulumi.getter(name="classicLoadBalancerListener")
    def classic_load_balancer_listener(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisLoadBalancerListener']:
        """
        The listener for a Classic Load Balancer.
        """
        return pulumi.get(self, "classic_load_balancer_listener")

    @_builtins.property
    @pulumi.getter
    def component(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The component.
        """
        return pulumi.get(self, "component")

    @_builtins.property
    @pulumi.getter(name="componentAccount")
    def component_account(self) -> Optional[_builtins.str]:
        """
        The AWS account for the component.
        """
        return pulumi.get(self, "component_account")

    @_builtins.property
    @pulumi.getter(name="componentRegion")
    def component_region(self) -> Optional[_builtins.str]:
        """
        The Region for the component.
        """
        return pulumi.get(self, "component_region")

    @_builtins.property
    @pulumi.getter(name="customerGateway")
    def customer_gateway(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The customer gateway.
        """
        return pulumi.get(self, "customer_gateway")

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The destination.
        """
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="destinationVpc")
    def destination_vpc(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The destination VPC.
        """
        return pulumi.get(self, "destination_vpc")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        The direction. The following are the possible values:

        - egress
        - ingress
        """
        return pulumi.get(self, "direction")

    @_builtins.property
    @pulumi.getter(name="elasticLoadBalancerListener")
    def elastic_load_balancer_listener(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The load balancer listener.
        """
        return pulumi.get(self, "elastic_load_balancer_listener")

    @_builtins.property
    @pulumi.getter(name="explanationCode")
    def explanation_code(self) -> Optional[_builtins.str]:
        """
        The explanation code.
        """
        return pulumi.get(self, "explanation_code")

    @_builtins.property
    @pulumi.getter(name="ingressRouteTable")
    def ingress_route_table(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The route table.
        """
        return pulumi.get(self, "ingress_route_table")

    @_builtins.property
    @pulumi.getter(name="internetGateway")
    def internet_gateway(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The internet gateway.
        """
        return pulumi.get(self, "internet_gateway")

    @_builtins.property
    @pulumi.getter(name="loadBalancerArn")
    def load_balancer_arn(self) -> Optional[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the load balancer.
        """
        return pulumi.get(self, "load_balancer_arn")

    @_builtins.property
    @pulumi.getter(name="loadBalancerListenerPort")
    def load_balancer_listener_port(self) -> Optional[_builtins.int]:
        """
        The listener port of the load balancer.
        """
        return pulumi.get(self, "load_balancer_listener_port")

    @_builtins.property
    @pulumi.getter(name="loadBalancerTarget")
    def load_balancer_target(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisLoadBalancerTarget']:
        """
        The target.
        """
        return pulumi.get(self, "load_balancer_target")

    @_builtins.property
    @pulumi.getter(name="loadBalancerTargetGroup")
    def load_balancer_target_group(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The target group.
        """
        return pulumi.get(self, "load_balancer_target_group")

    @_builtins.property
    @pulumi.getter(name="loadBalancerTargetGroups")
    def load_balancer_target_groups(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisAnalysisComponent']]:
        """
        The target groups.
        """
        return pulumi.get(self, "load_balancer_target_groups")

    @_builtins.property
    @pulumi.getter(name="loadBalancerTargetPort")
    def load_balancer_target_port(self) -> Optional[_builtins.int]:
        """
        The target port.
        """
        return pulumi.get(self, "load_balancer_target_port")

    @_builtins.property
    @pulumi.getter(name="missingComponent")
    def missing_component(self) -> Optional[_builtins.str]:
        """
        The missing component.
        """
        return pulumi.get(self, "missing_component")

    @_builtins.property
    @pulumi.getter(name="natGateway")
    def nat_gateway(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The NAT gateway.
        """
        return pulumi.get(self, "nat_gateway")

    @_builtins.property
    @pulumi.getter(name="networkInterface")
    def network_interface(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The network interface.
        """
        return pulumi.get(self, "network_interface")

    @_builtins.property
    @pulumi.getter(name="packetField")
    def packet_field(self) -> Optional[_builtins.str]:
        """
        The packet field.
        """
        return pulumi.get(self, "packet_field")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisPortRange']]:
        """
        The port ranges.
        """
        return pulumi.get(self, "port_ranges")

    @_builtins.property
    @pulumi.getter(name="prefixList")
    def prefix_list(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The prefix list.
        """
        return pulumi.get(self, "prefix_list")

    @_builtins.property
    @pulumi.getter
    def protocols(self) -> Optional[Sequence[_builtins.str]]:
        """
        The protocols.
        """
        return pulumi.get(self, "protocols")

    @_builtins.property
    @pulumi.getter(name="routeTable")
    def route_table(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The route table.
        """
        return pulumi.get(self, "route_table")

    @_builtins.property
    @pulumi.getter(name="routeTableRoute")
    def route_table_route(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisRouteTableRoute']:
        """
        The route table route.
        """
        return pulumi.get(self, "route_table_route")

    @_builtins.property
    @pulumi.getter(name="securityGroup")
    def security_group(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The security group.
        """
        return pulumi.get(self, "security_group")

    @_builtins.property
    @pulumi.getter(name="securityGroupRule")
    def security_group_rule(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisSecurityGroupRule']:
        """
        The security group rule.
        """
        return pulumi.get(self, "security_group_rule")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisAnalysisComponent']]:
        """
        The security groups.
        """
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter(name="sourceVpc")
    def source_vpc(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The source VPC.
        """
        return pulumi.get(self, "source_vpc")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        The state.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The subnet.
        """
        return pulumi.get(self, "subnet")

    @_builtins.property
    @pulumi.getter(name="subnetRouteTable")
    def subnet_route_table(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The route table for the subnet.
        """
        return pulumi.get(self, "subnet_route_table")

    @_builtins.property
    @pulumi.getter(name="transitGateway")
    def transit_gateway(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The transit gateway.
        """
        return pulumi.get(self, "transit_gateway")

    @_builtins.property
    @pulumi.getter(name="transitGatewayAttachment")
    def transit_gateway_attachment(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The transit gateway attachment.
        """
        return pulumi.get(self, "transit_gateway_attachment")

    @_builtins.property
    @pulumi.getter(name="transitGatewayRouteTable")
    def transit_gateway_route_table(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The transit gateway route table.
        """
        return pulumi.get(self, "transit_gateway_route_table")

    @_builtins.property
    @pulumi.getter(name="transitGatewayRouteTableRoute")
    def transit_gateway_route_table_route(self) -> Optional['outputs.NetworkInsightsAnalysisTransitGatewayRouteTableRoute']:
        """
        The transit gateway route table route.
        """
        return pulumi.get(self, "transit_gateway_route_table_route")

    @_builtins.property
    @pulumi.getter
    def vpc(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The component VPC.
        """
        return pulumi.get(self, "vpc")

    @_builtins.property
    @pulumi.getter(name="vpcEndpoint")
    def vpc_endpoint(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The VPC endpoint.
        """
        return pulumi.get(self, "vpc_endpoint")

    @_builtins.property
    @pulumi.getter(name="vpcPeeringConnection")
    def vpc_peering_connection(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The VPC peering connection.
        """
        return pulumi.get(self, "vpc_peering_connection")

    @_builtins.property
    @pulumi.getter(name="vpnConnection")
    def vpn_connection(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The VPN connection.
        """
        return pulumi.get(self, "vpn_connection")

    @_builtins.property
    @pulumi.getter(name="vpnGateway")
    def vpn_gateway(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The VPN gateway.
        """
        return pulumi.get(self, "vpn_gateway")


@pulumi.output_type
class NetworkInsightsAnalysisPathComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aclRule":
            suggest = "acl_rule"
        elif key == "additionalDetails":
            suggest = "additional_details"
        elif key == "destinationVpc":
            suggest = "destination_vpc"
        elif key == "elasticLoadBalancerListener":
            suggest = "elastic_load_balancer_listener"
        elif key == "inboundHeader":
            suggest = "inbound_header"
        elif key == "outboundHeader":
            suggest = "outbound_header"
        elif key == "routeTableRoute":
            suggest = "route_table_route"
        elif key == "securityGroupRule":
            suggest = "security_group_rule"
        elif key == "sequenceNumber":
            suggest = "sequence_number"
        elif key == "serviceName":
            suggest = "service_name"
        elif key == "sourceVpc":
            suggest = "source_vpc"
        elif key == "transitGateway":
            suggest = "transit_gateway"
        elif key == "transitGatewayRouteTableRoute":
            suggest = "transit_gateway_route_table_route"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisPathComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisPathComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisPathComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acl_rule: Optional['outputs.NetworkInsightsAnalysisAnalysisAclRule'] = None,
                 additional_details: Optional[Sequence['outputs.NetworkInsightsAnalysisAdditionalDetail']] = None,
                 component: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 destination_vpc: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 elastic_load_balancer_listener: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 explanations: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanation']] = None,
                 inbound_header: Optional['outputs.NetworkInsightsAnalysisAnalysisPacketHeader'] = None,
                 outbound_header: Optional['outputs.NetworkInsightsAnalysisAnalysisPacketHeader'] = None,
                 route_table_route: Optional['outputs.NetworkInsightsAnalysisAnalysisRouteTableRoute'] = None,
                 security_group_rule: Optional['outputs.NetworkInsightsAnalysisAnalysisSecurityGroupRule'] = None,
                 sequence_number: Optional[_builtins.int] = None,
                 service_name: Optional[_builtins.str] = None,
                 source_vpc: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 subnet: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 transit_gateway: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 transit_gateway_route_table_route: Optional['outputs.NetworkInsightsAnalysisTransitGatewayRouteTableRoute'] = None,
                 vpc: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None):
        """
        :param 'NetworkInsightsAnalysisAnalysisAclRule' acl_rule: The network ACL rule.
        :param Sequence['NetworkInsightsAnalysisAdditionalDetail'] additional_details: The additional details.
        :param 'NetworkInsightsAnalysisAnalysisComponent' component: The component.
        :param 'NetworkInsightsAnalysisAnalysisComponent' destination_vpc: The destination VPC.
        :param 'NetworkInsightsAnalysisAnalysisComponent' elastic_load_balancer_listener: The load balancer listener.
        :param Sequence['NetworkInsightsAnalysisExplanation'] explanations: The explanation codes.
        :param 'NetworkInsightsAnalysisAnalysisPacketHeader' inbound_header: The inbound header.
        :param 'NetworkInsightsAnalysisAnalysisPacketHeader' outbound_header: The outbound header.
        :param 'NetworkInsightsAnalysisAnalysisRouteTableRoute' route_table_route: The route table route.
        :param 'NetworkInsightsAnalysisAnalysisSecurityGroupRule' security_group_rule: The security group rule.
        :param _builtins.int sequence_number: The sequence number.
        :param _builtins.str service_name: The name of the VPC endpoint service.
        :param 'NetworkInsightsAnalysisAnalysisComponent' source_vpc: The source VPC.
        :param 'NetworkInsightsAnalysisAnalysisComponent' subnet: The subnet.
        :param 'NetworkInsightsAnalysisAnalysisComponent' transit_gateway: The transit gateway.
        :param 'NetworkInsightsAnalysisTransitGatewayRouteTableRoute' transit_gateway_route_table_route: The route in a transit gateway route table.
        :param 'NetworkInsightsAnalysisAnalysisComponent' vpc: The component VPC.
        """
        if acl_rule is not None:
            pulumi.set(__self__, "acl_rule", acl_rule)
        if additional_details is not None:
            pulumi.set(__self__, "additional_details", additional_details)
        if component is not None:
            pulumi.set(__self__, "component", component)
        if destination_vpc is not None:
            pulumi.set(__self__, "destination_vpc", destination_vpc)
        if elastic_load_balancer_listener is not None:
            pulumi.set(__self__, "elastic_load_balancer_listener", elastic_load_balancer_listener)
        if explanations is not None:
            pulumi.set(__self__, "explanations", explanations)
        if inbound_header is not None:
            pulumi.set(__self__, "inbound_header", inbound_header)
        if outbound_header is not None:
            pulumi.set(__self__, "outbound_header", outbound_header)
        if route_table_route is not None:
            pulumi.set(__self__, "route_table_route", route_table_route)
        if security_group_rule is not None:
            pulumi.set(__self__, "security_group_rule", security_group_rule)
        if sequence_number is not None:
            pulumi.set(__self__, "sequence_number", sequence_number)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)
        if source_vpc is not None:
            pulumi.set(__self__, "source_vpc", source_vpc)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)
        if transit_gateway is not None:
            pulumi.set(__self__, "transit_gateway", transit_gateway)
        if transit_gateway_route_table_route is not None:
            pulumi.set(__self__, "transit_gateway_route_table_route", transit_gateway_route_table_route)
        if vpc is not None:
            pulumi.set(__self__, "vpc", vpc)

    @_builtins.property
    @pulumi.getter(name="aclRule")
    def acl_rule(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisAclRule']:
        """
        The network ACL rule.
        """
        return pulumi.get(self, "acl_rule")

    @_builtins.property
    @pulumi.getter(name="additionalDetails")
    def additional_details(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisAdditionalDetail']]:
        """
        The additional details.
        """
        return pulumi.get(self, "additional_details")

    @_builtins.property
    @pulumi.getter
    def component(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The component.
        """
        return pulumi.get(self, "component")

    @_builtins.property
    @pulumi.getter(name="destinationVpc")
    def destination_vpc(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The destination VPC.
        """
        return pulumi.get(self, "destination_vpc")

    @_builtins.property
    @pulumi.getter(name="elasticLoadBalancerListener")
    def elastic_load_balancer_listener(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The load balancer listener.
        """
        return pulumi.get(self, "elastic_load_balancer_listener")

    @_builtins.property
    @pulumi.getter
    def explanations(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanation']]:
        """
        The explanation codes.
        """
        return pulumi.get(self, "explanations")

    @_builtins.property
    @pulumi.getter(name="inboundHeader")
    def inbound_header(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisPacketHeader']:
        """
        The inbound header.
        """
        return pulumi.get(self, "inbound_header")

    @_builtins.property
    @pulumi.getter(name="outboundHeader")
    def outbound_header(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisPacketHeader']:
        """
        The outbound header.
        """
        return pulumi.get(self, "outbound_header")

    @_builtins.property
    @pulumi.getter(name="routeTableRoute")
    def route_table_route(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisRouteTableRoute']:
        """
        The route table route.
        """
        return pulumi.get(self, "route_table_route")

    @_builtins.property
    @pulumi.getter(name="securityGroupRule")
    def security_group_rule(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisSecurityGroupRule']:
        """
        The security group rule.
        """
        return pulumi.get(self, "security_group_rule")

    @_builtins.property
    @pulumi.getter(name="sequenceNumber")
    def sequence_number(self) -> Optional[_builtins.int]:
        """
        The sequence number.
        """
        return pulumi.get(self, "sequence_number")

    @_builtins.property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[_builtins.str]:
        """
        The name of the VPC endpoint service.
        """
        return pulumi.get(self, "service_name")

    @_builtins.property
    @pulumi.getter(name="sourceVpc")
    def source_vpc(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The source VPC.
        """
        return pulumi.get(self, "source_vpc")

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The subnet.
        """
        return pulumi.get(self, "subnet")

    @_builtins.property
    @pulumi.getter(name="transitGateway")
    def transit_gateway(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The transit gateway.
        """
        return pulumi.get(self, "transit_gateway")

    @_builtins.property
    @pulumi.getter(name="transitGatewayRouteTableRoute")
    def transit_gateway_route_table_route(self) -> Optional['outputs.NetworkInsightsAnalysisTransitGatewayRouteTableRoute']:
        """
        The route in a transit gateway route table.
        """
        return pulumi.get(self, "transit_gateway_route_table_route")

    @_builtins.property
    @pulumi.getter
    def vpc(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        """
        The component VPC.
        """
        return pulumi.get(self, "vpc")


@pulumi.output_type
class NetworkInsightsAnalysisPortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisPortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisPortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisPortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[_builtins.int] = None,
                 to: Optional[_builtins.int] = None):
        """
        :param _builtins.int from_: The first port in the range.
        :param _builtins.int to: The last port in the range.
        """
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[_builtins.int]:
        """
        The first port in the range.
        """
        return pulumi.get(self, "from_")

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[_builtins.int]:
        """
        The last port in the range.
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisTransitGatewayRouteTableRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attachmentId":
            suggest = "attachment_id"
        elif key == "destinationCidr":
            suggest = "destination_cidr"
        elif key == "prefixListId":
            suggest = "prefix_list_id"
        elif key == "resourceId":
            suggest = "resource_id"
        elif key == "resourceType":
            suggest = "resource_type"
        elif key == "routeOrigin":
            suggest = "route_origin"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisTransitGatewayRouteTableRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisTransitGatewayRouteTableRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisTransitGatewayRouteTableRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attachment_id: Optional[_builtins.str] = None,
                 destination_cidr: Optional[_builtins.str] = None,
                 prefix_list_id: Optional[_builtins.str] = None,
                 resource_id: Optional[_builtins.str] = None,
                 resource_type: Optional[_builtins.str] = None,
                 route_origin: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.str attachment_id: The ID of the route attachment.
        :param _builtins.str destination_cidr: The CIDR block used for destination matches.
        :param _builtins.str prefix_list_id: The ID of the prefix list.
        :param _builtins.str resource_id: The ID of the resource for the route attachment.
        :param _builtins.str resource_type: The resource type for the route attachment.
        :param _builtins.str route_origin: The route origin. The following are the possible values:
               
               - static
               - propagated
        :param _builtins.str state: The state of the route.
        """
        if attachment_id is not None:
            pulumi.set(__self__, "attachment_id", attachment_id)
        if destination_cidr is not None:
            pulumi.set(__self__, "destination_cidr", destination_cidr)
        if prefix_list_id is not None:
            pulumi.set(__self__, "prefix_list_id", prefix_list_id)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if route_origin is not None:
            pulumi.set(__self__, "route_origin", route_origin)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="attachmentId")
    def attachment_id(self) -> Optional[_builtins.str]:
        """
        The ID of the route attachment.
        """
        return pulumi.get(self, "attachment_id")

    @_builtins.property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> Optional[_builtins.str]:
        """
        The CIDR block used for destination matches.
        """
        return pulumi.get(self, "destination_cidr")

    @_builtins.property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> Optional[_builtins.str]:
        """
        The ID of the prefix list.
        """
        return pulumi.get(self, "prefix_list_id")

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[_builtins.str]:
        """
        The ID of the resource for the route attachment.
        """
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[_builtins.str]:
        """
        The resource type for the route attachment.
        """
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter(name="routeOrigin")
    def route_origin(self) -> Optional[_builtins.str]:
        """
        The route origin. The following are the possible values:

        - static
        - propagated
        """
        return pulumi.get(self, "route_origin")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        The state of the route.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class NetworkInsightsPathFilterPortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "toPort":
            suggest = "to_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsPathFilterPortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsPathFilterPortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsPathFilterPortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_port: Optional[_builtins.int] = None,
                 to_port: Optional[_builtins.int] = None):
        """
        :param _builtins.int from_port: The first port in the range.
        :param _builtins.int to_port: The last port in the range.
        """
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[_builtins.int]:
        """
        The first port in the range.
        """
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[_builtins.int]:
        """
        The last port in the range.
        """
        return pulumi.get(self, "to_port")


@pulumi.output_type
class NetworkInsightsPathPathFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddress":
            suggest = "destination_address"
        elif key == "destinationPortRange":
            suggest = "destination_port_range"
        elif key == "sourceAddress":
            suggest = "source_address"
        elif key == "sourcePortRange":
            suggest = "source_port_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsPathPathFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsPathPathFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsPathPathFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_address: Optional[_builtins.str] = None,
                 destination_port_range: Optional['outputs.NetworkInsightsPathFilterPortRange'] = None,
                 source_address: Optional[_builtins.str] = None,
                 source_port_range: Optional['outputs.NetworkInsightsPathFilterPortRange'] = None):
        """
        :param _builtins.str destination_address: The destination IPv4 address.
        :param 'NetworkInsightsPathFilterPortRange' destination_port_range: The destination port range.
        :param _builtins.str source_address: The source IPv4 address.
        :param 'NetworkInsightsPathFilterPortRange' source_port_range: The source port range.
        """
        if destination_address is not None:
            pulumi.set(__self__, "destination_address", destination_address)
        if destination_port_range is not None:
            pulumi.set(__self__, "destination_port_range", destination_port_range)
        if source_address is not None:
            pulumi.set(__self__, "source_address", source_address)
        if source_port_range is not None:
            pulumi.set(__self__, "source_port_range", source_port_range)

    @_builtins.property
    @pulumi.getter(name="destinationAddress")
    def destination_address(self) -> Optional[_builtins.str]:
        """
        The destination IPv4 address.
        """
        return pulumi.get(self, "destination_address")

    @_builtins.property
    @pulumi.getter(name="destinationPortRange")
    def destination_port_range(self) -> Optional['outputs.NetworkInsightsPathFilterPortRange']:
        """
        The destination port range.
        """
        return pulumi.get(self, "destination_port_range")

    @_builtins.property
    @pulumi.getter(name="sourceAddress")
    def source_address(self) -> Optional[_builtins.str]:
        """
        The source IPv4 address.
        """
        return pulumi.get(self, "source_address")

    @_builtins.property
    @pulumi.getter(name="sourcePortRange")
    def source_port_range(self) -> Optional['outputs.NetworkInsightsPathFilterPortRange']:
        """
        The source port range.
        """
        return pulumi.get(self, "source_port_range")


@pulumi.output_type
class NetworkInterfaceAttachmentEnaSrdSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enaSrdEnabled":
            suggest = "ena_srd_enabled"
        elif key == "enaSrdUdpSpecification":
            suggest = "ena_srd_udp_specification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInterfaceAttachmentEnaSrdSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInterfaceAttachmentEnaSrdSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInterfaceAttachmentEnaSrdSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ena_srd_enabled: Optional[_builtins.bool] = None,
                 ena_srd_udp_specification: Optional['outputs.NetworkInterfaceAttachmentEnaSrdSpecificationEnaSrdUdpSpecificationProperties'] = None):
        """
        :param _builtins.bool ena_srd_enabled: Indicates whether ENA Express is enabled for the network interface.
        :param 'NetworkInterfaceAttachmentEnaSrdSpecificationEnaSrdUdpSpecificationProperties' ena_srd_udp_specification: Configures ENA Express for UDP network traffic.
        """
        if ena_srd_enabled is not None:
            pulumi.set(__self__, "ena_srd_enabled", ena_srd_enabled)
        if ena_srd_udp_specification is not None:
            pulumi.set(__self__, "ena_srd_udp_specification", ena_srd_udp_specification)

    @_builtins.property
    @pulumi.getter(name="enaSrdEnabled")
    def ena_srd_enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates whether ENA Express is enabled for the network interface.
        """
        return pulumi.get(self, "ena_srd_enabled")

    @_builtins.property
    @pulumi.getter(name="enaSrdUdpSpecification")
    def ena_srd_udp_specification(self) -> Optional['outputs.NetworkInterfaceAttachmentEnaSrdSpecificationEnaSrdUdpSpecificationProperties']:
        """
        Configures ENA Express for UDP network traffic.
        """
        return pulumi.get(self, "ena_srd_udp_specification")


@pulumi.output_type
class NetworkInterfaceAttachmentEnaSrdSpecificationEnaSrdUdpSpecificationProperties(dict):
    """
    Configures ENA Express for UDP network traffic.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enaSrdUdpEnabled":
            suggest = "ena_srd_udp_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInterfaceAttachmentEnaSrdSpecificationEnaSrdUdpSpecificationProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInterfaceAttachmentEnaSrdSpecificationEnaSrdUdpSpecificationProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInterfaceAttachmentEnaSrdSpecificationEnaSrdUdpSpecificationProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ena_srd_udp_enabled: Optional[_builtins.bool] = None):
        """
        Configures ENA Express for UDP network traffic.
        """
        if ena_srd_udp_enabled is not None:
            pulumi.set(__self__, "ena_srd_udp_enabled", ena_srd_udp_enabled)

    @_builtins.property
    @pulumi.getter(name="enaSrdUdpEnabled")
    def ena_srd_udp_enabled(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "ena_srd_udp_enabled")


@pulumi.output_type
class NetworkInterfaceConnectionTrackingSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tcpEstablishedTimeout":
            suggest = "tcp_established_timeout"
        elif key == "udpStreamTimeout":
            suggest = "udp_stream_timeout"
        elif key == "udpTimeout":
            suggest = "udp_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInterfaceConnectionTrackingSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInterfaceConnectionTrackingSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInterfaceConnectionTrackingSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tcp_established_timeout: Optional[_builtins.int] = None,
                 udp_stream_timeout: Optional[_builtins.int] = None,
                 udp_timeout: Optional[_builtins.int] = None):
        """
        :param _builtins.int tcp_established_timeout: Timeout (in seconds) for idle TCP connections in an established state. Min: 60 seconds. Max: 432000 seconds (5 days). Default: 432000 seconds. Recommended: Less than 432000 seconds.
        :param _builtins.int udp_stream_timeout: Timeout (in seconds) for idle UDP flows classified as streams which have seen more than one request-response transaction. Min: 60 seconds. Max: 180 seconds (3 minutes). Default: 180 seconds.
        :param _builtins.int udp_timeout: Timeout (in seconds) for idle UDP flows that have seen traffic only in a single direction or a single request-response transaction. Min: 30 seconds. Max: 60 seconds. Default: 30 seconds.
        """
        if tcp_established_timeout is not None:
            pulumi.set(__self__, "tcp_established_timeout", tcp_established_timeout)
        if udp_stream_timeout is not None:
            pulumi.set(__self__, "udp_stream_timeout", udp_stream_timeout)
        if udp_timeout is not None:
            pulumi.set(__self__, "udp_timeout", udp_timeout)

    @_builtins.property
    @pulumi.getter(name="tcpEstablishedTimeout")
    def tcp_established_timeout(self) -> Optional[_builtins.int]:
        """
        Timeout (in seconds) for idle TCP connections in an established state. Min: 60 seconds. Max: 432000 seconds (5 days). Default: 432000 seconds. Recommended: Less than 432000 seconds.
        """
        return pulumi.get(self, "tcp_established_timeout")

    @_builtins.property
    @pulumi.getter(name="udpStreamTimeout")
    def udp_stream_timeout(self) -> Optional[_builtins.int]:
        """
        Timeout (in seconds) for idle UDP flows classified as streams which have seen more than one request-response transaction. Min: 60 seconds. Max: 180 seconds (3 minutes). Default: 180 seconds.
        """
        return pulumi.get(self, "udp_stream_timeout")

    @_builtins.property
    @pulumi.getter(name="udpTimeout")
    def udp_timeout(self) -> Optional[_builtins.int]:
        """
        Timeout (in seconds) for idle UDP flows that have seen traffic only in a single direction or a single request-response transaction. Min: 30 seconds. Max: 60 seconds. Default: 30 seconds.
        """
        return pulumi.get(self, "udp_timeout")


@pulumi.output_type
class NetworkInterfaceInstanceIpv6Address(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv6Address":
            suggest = "ipv6_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInterfaceInstanceIpv6Address. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInterfaceInstanceIpv6Address.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInterfaceInstanceIpv6Address.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv6_address: _builtins.str):
        """
        :param _builtins.str ipv6_address: An IPv6 address to associate with the network interface.
        """
        pulumi.set(__self__, "ipv6_address", ipv6_address)

    @_builtins.property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> _builtins.str:
        """
        An IPv6 address to associate with the network interface.
        """
        return pulumi.get(self, "ipv6_address")


@pulumi.output_type
class NetworkInterfaceIpv4PrefixSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv4Prefix":
            suggest = "ipv4_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInterfaceIpv4PrefixSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInterfaceIpv4PrefixSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInterfaceIpv4PrefixSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv4_prefix: _builtins.str):
        """
        :param _builtins.str ipv4_prefix: The IPv4 prefix. For information, see [Assigning prefixes to network interfaces](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-prefix-eni.html) in the *Amazon EC2 User Guide* .
        """
        pulumi.set(__self__, "ipv4_prefix", ipv4_prefix)

    @_builtins.property
    @pulumi.getter(name="ipv4Prefix")
    def ipv4_prefix(self) -> _builtins.str:
        """
        The IPv4 prefix. For information, see [Assigning prefixes to network interfaces](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-prefix-eni.html) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "ipv4_prefix")


@pulumi.output_type
class NetworkInterfaceIpv6PrefixSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv6Prefix":
            suggest = "ipv6_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInterfaceIpv6PrefixSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInterfaceIpv6PrefixSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInterfaceIpv6PrefixSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv6_prefix: _builtins.str):
        """
        :param _builtins.str ipv6_prefix: The IPv6 prefix. For information, see [Assigning prefixes to Amazon EC2 network interfaces](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-prefix-eni.html) in the *Amazon Elastic Compute Cloud User Guide* .
        """
        pulumi.set(__self__, "ipv6_prefix", ipv6_prefix)

    @_builtins.property
    @pulumi.getter(name="ipv6Prefix")
    def ipv6_prefix(self) -> _builtins.str:
        """
        The IPv6 prefix. For information, see [Assigning prefixes to Amazon EC2 network interfaces](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-prefix-eni.html) in the *Amazon Elastic Compute Cloud User Guide* .
        """
        return pulumi.get(self, "ipv6_prefix")


@pulumi.output_type
class NetworkInterfacePrivateIpAddressSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIpAddress":
            suggest = "private_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInterfacePrivateIpAddressSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInterfacePrivateIpAddressSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInterfacePrivateIpAddressSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 primary: _builtins.bool,
                 private_ip_address: _builtins.str):
        """
        :param _builtins.bool primary: Sets the private IP address as the primary private address. You can set only one primary private IP address. If you don't specify a primary private IP address, Amazon EC2 automatically assigns a primary private IP address.
        :param _builtins.str private_ip_address: The private IP address of the network interface.
        """
        pulumi.set(__self__, "primary", primary)
        pulumi.set(__self__, "private_ip_address", private_ip_address)

    @_builtins.property
    @pulumi.getter
    def primary(self) -> _builtins.bool:
        """
        Sets the private IP address as the primary private address. You can set only one primary private IP address. If you don't specify a primary private IP address, Amazon EC2 automatically assigns a primary private IP address.
        """
        return pulumi.get(self, "primary")

    @_builtins.property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> _builtins.str:
        """
        The private IP address of the network interface.
        """
        return pulumi.get(self, "private_ip_address")


@pulumi.output_type
class OptionsProperties(dict):
    """
    The options for the transit gateway vpc attachment.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applianceModeSupport":
            suggest = "appliance_mode_support"
        elif key == "dnsSupport":
            suggest = "dns_support"
        elif key == "ipv6Support":
            suggest = "ipv6_support"
        elif key == "securityGroupReferencingSupport":
            suggest = "security_group_referencing_support"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OptionsProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OptionsProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OptionsProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 appliance_mode_support: Optional[_builtins.str] = None,
                 dns_support: Optional[_builtins.str] = None,
                 ipv6_support: Optional[_builtins.str] = None,
                 security_group_referencing_support: Optional[_builtins.str] = None):
        """
        The options for the transit gateway vpc attachment.
        :param _builtins.str appliance_mode_support: Indicates whether to enable Ipv6 Support for Vpc Attachment. Valid Values: enable | disable
        :param _builtins.str dns_support: Indicates whether to enable DNS Support for Vpc Attachment. Valid Values: enable | disable
        :param _builtins.str ipv6_support: Indicates whether to enable Ipv6 Support for Vpc Attachment. Valid Values: enable | disable
        :param _builtins.str security_group_referencing_support: Indicates whether to enable Security Group referencing support for Vpc Attachment. Valid values: enable | disable
        """
        if appliance_mode_support is not None:
            pulumi.set(__self__, "appliance_mode_support", appliance_mode_support)
        if dns_support is not None:
            pulumi.set(__self__, "dns_support", dns_support)
        if ipv6_support is not None:
            pulumi.set(__self__, "ipv6_support", ipv6_support)
        if security_group_referencing_support is not None:
            pulumi.set(__self__, "security_group_referencing_support", security_group_referencing_support)

    @_builtins.property
    @pulumi.getter(name="applianceModeSupport")
    def appliance_mode_support(self) -> Optional[_builtins.str]:
        """
        Indicates whether to enable Ipv6 Support for Vpc Attachment. Valid Values: enable | disable
        """
        return pulumi.get(self, "appliance_mode_support")

    @_builtins.property
    @pulumi.getter(name="dnsSupport")
    def dns_support(self) -> Optional[_builtins.str]:
        """
        Indicates whether to enable DNS Support for Vpc Attachment. Valid Values: enable | disable
        """
        return pulumi.get(self, "dns_support")

    @_builtins.property
    @pulumi.getter(name="ipv6Support")
    def ipv6_support(self) -> Optional[_builtins.str]:
        """
        Indicates whether to enable Ipv6 Support for Vpc Attachment. Valid Values: enable | disable
        """
        return pulumi.get(self, "ipv6_support")

    @_builtins.property
    @pulumi.getter(name="securityGroupReferencingSupport")
    def security_group_referencing_support(self) -> Optional[_builtins.str]:
        """
        Indicates whether to enable Security Group referencing support for Vpc Attachment. Valid values: enable | disable
        """
        return pulumi.get(self, "security_group_referencing_support")


@pulumi.output_type
class PrefixListEntry(dict):
    def __init__(__self__, *,
                 cidr: _builtins.str,
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str cidr: The CIDR block.
        :param _builtins.str description: A description for the entry.
               
               Constraints: Up to 255 characters in length.
        """
        pulumi.set(__self__, "cidr", cidr)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> _builtins.str:
        """
        The CIDR block.
        """
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description for the entry.

        Constraints: Up to 255 characters in length.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class PrivateDnsNameOptionsOnLaunchProperties(dict):
    """
    The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries to the instances should be handled. For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *User Guide*.
     Available options:
      +  EnableResourceNameDnsAAAARecord (true | false)
      +  EnableResourceNameDnsARecord (true | false)
      +  HostnameType (ip-name | resource-name)
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableResourceNameDnsARecord":
            suggest = "enable_resource_name_dns_a_record"
        elif key == "enableResourceNameDnsAaaaRecord":
            suggest = "enable_resource_name_dns_aaaa_record"
        elif key == "hostnameType":
            suggest = "hostname_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateDnsNameOptionsOnLaunchProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateDnsNameOptionsOnLaunchProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateDnsNameOptionsOnLaunchProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_resource_name_dns_a_record: Optional[_builtins.bool] = None,
                 enable_resource_name_dns_aaaa_record: Optional[_builtins.bool] = None,
                 hostname_type: Optional[_builtins.str] = None):
        """
        The hostname type for EC2 instances launched into this subnet and how DNS A and AAAA record queries to the instances should be handled. For more information, see [Amazon EC2 instance hostname types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-naming.html) in the *User Guide*.
         Available options:
          +  EnableResourceNameDnsAAAARecord (true | false)
          +  EnableResourceNameDnsARecord (true | false)
          +  HostnameType (ip-name | resource-name)
        :param _builtins.bool enable_resource_name_dns_a_record: Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
        :param _builtins.bool enable_resource_name_dns_aaaa_record: Indicates whether to respond to DNS queries for instance hostname with DNS AAAA records.
        :param _builtins.str hostname_type: The type of hostname for EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID.
        """
        if enable_resource_name_dns_a_record is not None:
            pulumi.set(__self__, "enable_resource_name_dns_a_record", enable_resource_name_dns_a_record)
        if enable_resource_name_dns_aaaa_record is not None:
            pulumi.set(__self__, "enable_resource_name_dns_aaaa_record", enable_resource_name_dns_aaaa_record)
        if hostname_type is not None:
            pulumi.set(__self__, "hostname_type", hostname_type)

    @_builtins.property
    @pulumi.getter(name="enableResourceNameDnsARecord")
    def enable_resource_name_dns_a_record(self) -> Optional[_builtins.bool]:
        """
        Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
        """
        return pulumi.get(self, "enable_resource_name_dns_a_record")

    @_builtins.property
    @pulumi.getter(name="enableResourceNameDnsAaaaRecord")
    def enable_resource_name_dns_aaaa_record(self) -> Optional[_builtins.bool]:
        """
        Indicates whether to respond to DNS queries for instance hostname with DNS AAAA records.
        """
        return pulumi.get(self, "enable_resource_name_dns_aaaa_record")

    @_builtins.property
    @pulumi.getter(name="hostnameType")
    def hostname_type(self) -> Optional[_builtins.str]:
        """
        The type of hostname for EC2 instances. For IPv4 only subnets, an instance DNS name must be based on the instance IPv4 address. For IPv6 only subnets, an instance DNS name must be based on the instance ID. For dual-stack subnets, you can specify whether DNS names use the instance IPv4 address or the instance ID.
        """
        return pulumi.get(self, "hostname_type")


@pulumi.output_type
class RouteServerPeerBgpOptions(dict):
    """
    BGP Options
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "peerAsn":
            suggest = "peer_asn"
        elif key == "peerLivenessDetection":
            suggest = "peer_liveness_detection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RouteServerPeerBgpOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RouteServerPeerBgpOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RouteServerPeerBgpOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 peer_asn: Optional[_builtins.int] = None,
                 peer_liveness_detection: Optional['RouteServerPeerBgpOptionsPeerLivenessDetection'] = None):
        """
        BGP Options
        :param _builtins.int peer_asn: BGP ASN of the Route Server Peer
        :param 'RouteServerPeerBgpOptionsPeerLivenessDetection' peer_liveness_detection: BGP Liveness Detection
        """
        if peer_asn is not None:
            pulumi.set(__self__, "peer_asn", peer_asn)
        if peer_liveness_detection is not None:
            pulumi.set(__self__, "peer_liveness_detection", peer_liveness_detection)

    @_builtins.property
    @pulumi.getter(name="peerAsn")
    def peer_asn(self) -> Optional[_builtins.int]:
        """
        BGP ASN of the Route Server Peer
        """
        return pulumi.get(self, "peer_asn")

    @_builtins.property
    @pulumi.getter(name="peerLivenessDetection")
    def peer_liveness_detection(self) -> Optional['RouteServerPeerBgpOptionsPeerLivenessDetection']:
        """
        BGP Liveness Detection
        """
        return pulumi.get(self, "peer_liveness_detection")


@pulumi.output_type
class SecurityGroupEgress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipProtocol":
            suggest = "ip_protocol"
        elif key == "cidrIp":
            suggest = "cidr_ip"
        elif key == "cidrIpv6":
            suggest = "cidr_ipv6"
        elif key == "destinationPrefixListId":
            suggest = "destination_prefix_list_id"
        elif key == "destinationSecurityGroupId":
            suggest = "destination_security_group_id"
        elif key == "fromPort":
            suggest = "from_port"
        elif key == "toPort":
            suggest = "to_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityGroupEgress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityGroupEgress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityGroupEgress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_protocol: _builtins.str,
                 cidr_ip: Optional[_builtins.str] = None,
                 cidr_ipv6: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 destination_prefix_list_id: Optional[_builtins.str] = None,
                 destination_security_group_id: Optional[_builtins.str] = None,
                 from_port: Optional[_builtins.int] = None,
                 to_port: Optional[_builtins.int] = None):
        """
        :param _builtins.str ip_protocol: The IP protocol name ( `tcp` , `udp` , `icmp` , `icmpv6` ) or number (see [Protocol Numbers](https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml) ).
               
               Use `-1` to specify all protocols. When authorizing security group rules, specifying `-1` or a protocol number other than `tcp` , `udp` , `icmp` , or `icmpv6` allows traffic on all ports, regardless of any port range you specify. For `tcp` , `udp` , and `icmp` , you must specify a port range. For `icmpv6` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.
        :param _builtins.str cidr_ip: The IPv4 address range, in CIDR format.
               
               You must specify exactly one of the following: `CidrIp` , `CidrIpv6` , `DestinationPrefixListId` , or `DestinationSecurityGroupId` .
               
               For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
        :param _builtins.str cidr_ipv6: The IPv6 address range, in CIDR format.
               
               You must specify exactly one of the following: `CidrIp` , `CidrIpv6` , `DestinationPrefixListId` , or `DestinationSecurityGroupId` .
               
               For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
        :param _builtins.str description: A description for the security group rule.
               
               Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
        :param _builtins.str destination_prefix_list_id: The prefix list IDs for the destination AWS service. This is the AWS service that you want to access through a VPC endpoint from instances associated with the security group.
               
               You must specify exactly one of the following: `CidrIp` , `CidrIpv6` , `DestinationPrefixListId` , or `DestinationSecurityGroupId` .
        :param _builtins.str destination_security_group_id: The ID of the destination VPC security group.
               
               You must specify exactly one of the following: `CidrIp` , `CidrIpv6` , `DestinationPrefixListId` , or `DestinationSecurityGroupId` .
        :param _builtins.int from_port: If the protocol is TCP or UDP, this is the start of the port range. If the protocol is ICMP or ICMPv6, this is the ICMP type or -1 (all ICMP types).
        :param _builtins.int to_port: If the protocol is TCP or UDP, this is the end of the port range. If the protocol is ICMP or ICMPv6, this is the ICMP code or -1 (all ICMP codes). If the start port is -1 (all ICMP types), then the end port must be -1 (all ICMP codes).
        """
        pulumi.set(__self__, "ip_protocol", ip_protocol)
        if cidr_ip is not None:
            pulumi.set(__self__, "cidr_ip", cidr_ip)
        if cidr_ipv6 is not None:
            pulumi.set(__self__, "cidr_ipv6", cidr_ipv6)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destination_prefix_list_id is not None:
            pulumi.set(__self__, "destination_prefix_list_id", destination_prefix_list_id)
        if destination_security_group_id is not None:
            pulumi.set(__self__, "destination_security_group_id", destination_security_group_id)
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)

    @_builtins.property
    @pulumi.getter(name="ipProtocol")
    def ip_protocol(self) -> _builtins.str:
        """
        The IP protocol name ( `tcp` , `udp` , `icmp` , `icmpv6` ) or number (see [Protocol Numbers](https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml) ).

        Use `-1` to specify all protocols. When authorizing security group rules, specifying `-1` or a protocol number other than `tcp` , `udp` , `icmp` , or `icmpv6` allows traffic on all ports, regardless of any port range you specify. For `tcp` , `udp` , and `icmp` , you must specify a port range. For `icmpv6` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.
        """
        return pulumi.get(self, "ip_protocol")

    @_builtins.property
    @pulumi.getter(name="cidrIp")
    def cidr_ip(self) -> Optional[_builtins.str]:
        """
        The IPv4 address range, in CIDR format.

        You must specify exactly one of the following: `CidrIp` , `CidrIpv6` , `DestinationPrefixListId` , or `DestinationSecurityGroupId` .

        For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "cidr_ip")

    @_builtins.property
    @pulumi.getter(name="cidrIpv6")
    def cidr_ipv6(self) -> Optional[_builtins.str]:
        """
        The IPv6 address range, in CIDR format.

        You must specify exactly one of the following: `CidrIp` , `CidrIpv6` , `DestinationPrefixListId` , or `DestinationSecurityGroupId` .

        For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "cidr_ipv6")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A description for the security group rule.

        Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="destinationPrefixListId")
    def destination_prefix_list_id(self) -> Optional[_builtins.str]:
        """
        The prefix list IDs for the destination AWS service. This is the AWS service that you want to access through a VPC endpoint from instances associated with the security group.

        You must specify exactly one of the following: `CidrIp` , `CidrIpv6` , `DestinationPrefixListId` , or `DestinationSecurityGroupId` .
        """
        return pulumi.get(self, "destination_prefix_list_id")

    @_builtins.property
    @pulumi.getter(name="destinationSecurityGroupId")
    def destination_security_group_id(self) -> Optional[_builtins.str]:
        """
        The ID of the destination VPC security group.

        You must specify exactly one of the following: `CidrIp` , `CidrIpv6` , `DestinationPrefixListId` , or `DestinationSecurityGroupId` .
        """
        return pulumi.get(self, "destination_security_group_id")

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[_builtins.int]:
        """
        If the protocol is TCP or UDP, this is the start of the port range. If the protocol is ICMP or ICMPv6, this is the ICMP type or -1 (all ICMP types).
        """
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[_builtins.int]:
        """
        If the protocol is TCP or UDP, this is the end of the port range. If the protocol is ICMP or ICMPv6, this is the ICMP code or -1 (all ICMP codes). If the start port is -1 (all ICMP types), then the end port must be -1 (all ICMP codes).
        """
        return pulumi.get(self, "to_port")


@pulumi.output_type
class SecurityGroupIngress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipProtocol":
            suggest = "ip_protocol"
        elif key == "cidrIp":
            suggest = "cidr_ip"
        elif key == "cidrIpv6":
            suggest = "cidr_ipv6"
        elif key == "fromPort":
            suggest = "from_port"
        elif key == "sourcePrefixListId":
            suggest = "source_prefix_list_id"
        elif key == "sourceSecurityGroupId":
            suggest = "source_security_group_id"
        elif key == "sourceSecurityGroupName":
            suggest = "source_security_group_name"
        elif key == "sourceSecurityGroupOwnerId":
            suggest = "source_security_group_owner_id"
        elif key == "toPort":
            suggest = "to_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityGroupIngress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityGroupIngress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityGroupIngress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_protocol: _builtins.str,
                 cidr_ip: Optional[_builtins.str] = None,
                 cidr_ipv6: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 from_port: Optional[_builtins.int] = None,
                 source_prefix_list_id: Optional[_builtins.str] = None,
                 source_security_group_id: Optional[_builtins.str] = None,
                 source_security_group_name: Optional[_builtins.str] = None,
                 source_security_group_owner_id: Optional[_builtins.str] = None,
                 to_port: Optional[_builtins.int] = None):
        """
        :param _builtins.str ip_protocol: The IP protocol name ( `tcp` , `udp` , `icmp` , `icmpv6` ) or number (see [Protocol Numbers](https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml) ).
               
               Use `-1` to specify all protocols. When authorizing security group rules, specifying `-1` or a protocol number other than `tcp` , `udp` , `icmp` , or `icmpv6` allows traffic on all ports, regardless of any port range you specify. For `tcp` , `udp` , and `icmp` , you must specify a port range. For `icmpv6` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.
        :param _builtins.str cidr_ip: The IPv4 address range, in CIDR format.
               
               You must specify exactly one of the following: `CidrIp` , `CidrIpv6` , `SourcePrefixListId` , or `SourceSecurityGroupId` .
               
               For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
        :param _builtins.str cidr_ipv6: The IPv6 address range, in CIDR format.
               
               You must specify exactly one of the following: `CidrIp` , `CidrIpv6` , `SourcePrefixListId` , or `SourceSecurityGroupId` .
               
               For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
        :param _builtins.str description: Updates the description of an ingress (inbound) security group rule. You can replace an existing description, or add a description to a rule that did not have one previously.
               
               Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
        :param _builtins.int from_port: If the protocol is TCP or UDP, this is the start of the port range. If the protocol is ICMP or ICMPv6, this is the ICMP type or -1 (all ICMP types).
        :param _builtins.str source_prefix_list_id: The ID of a prefix list.
        :param _builtins.str source_security_group_id: The ID of the security group.
        :param _builtins.str source_security_group_name: [Default VPC] The name of the source security group. You must specify either the security group ID or the security group name. You can't specify the group name in combination with an IP address range. Creates rules that grant full ICMP, UDP, and TCP access.
               
               For security groups in a nondefault VPC, you must specify the group ID.
        :param _builtins.str source_security_group_owner_id: [nondefault VPC] The AWS account ID for the source security group, if the source security group is in a different account. You can't specify this property with an IP address range. Creates rules that grant full ICMP, UDP, and TCP access.
               
               If you specify `SourceSecurityGroupName` or `SourceSecurityGroupId` and that security group is owned by a different account than the account creating the stack, you must specify the `SourceSecurityGroupOwnerId` ; otherwise, this property is optional.
        :param _builtins.int to_port: If the protocol is TCP or UDP, this is the end of the port range. If the protocol is ICMP or ICMPv6, this is the ICMP code or -1 (all ICMP codes). If the start port is -1 (all ICMP types), then the end port must be -1 (all ICMP codes).
        """
        pulumi.set(__self__, "ip_protocol", ip_protocol)
        if cidr_ip is not None:
            pulumi.set(__self__, "cidr_ip", cidr_ip)
        if cidr_ipv6 is not None:
            pulumi.set(__self__, "cidr_ipv6", cidr_ipv6)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if source_prefix_list_id is not None:
            pulumi.set(__self__, "source_prefix_list_id", source_prefix_list_id)
        if source_security_group_id is not None:
            pulumi.set(__self__, "source_security_group_id", source_security_group_id)
        if source_security_group_name is not None:
            pulumi.set(__self__, "source_security_group_name", source_security_group_name)
        if source_security_group_owner_id is not None:
            pulumi.set(__self__, "source_security_group_owner_id", source_security_group_owner_id)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)

    @_builtins.property
    @pulumi.getter(name="ipProtocol")
    def ip_protocol(self) -> _builtins.str:
        """
        The IP protocol name ( `tcp` , `udp` , `icmp` , `icmpv6` ) or number (see [Protocol Numbers](https://docs.aws.amazon.com/http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml) ).

        Use `-1` to specify all protocols. When authorizing security group rules, specifying `-1` or a protocol number other than `tcp` , `udp` , `icmp` , or `icmpv6` allows traffic on all ports, regardless of any port range you specify. For `tcp` , `udp` , and `icmp` , you must specify a port range. For `icmpv6` , the port range is optional; if you omit the port range, traffic for all types and codes is allowed.
        """
        return pulumi.get(self, "ip_protocol")

    @_builtins.property
    @pulumi.getter(name="cidrIp")
    def cidr_ip(self) -> Optional[_builtins.str]:
        """
        The IPv4 address range, in CIDR format.

        You must specify exactly one of the following: `CidrIp` , `CidrIpv6` , `SourcePrefixListId` , or `SourceSecurityGroupId` .

        For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "cidr_ip")

    @_builtins.property
    @pulumi.getter(name="cidrIpv6")
    def cidr_ipv6(self) -> Optional[_builtins.str]:
        """
        The IPv6 address range, in CIDR format.

        You must specify exactly one of the following: `CidrIp` , `CidrIpv6` , `SourcePrefixListId` , or `SourceSecurityGroupId` .

        For examples of rules that you can add to security groups for specific access scenarios, see [Security group rules for different use cases](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/security-group-rules-reference.html) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "cidr_ipv6")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Updates the description of an ingress (inbound) security group rule. You can replace an existing description, or add a description to a rule that did not have one previously.

        Constraints: Up to 255 characters in length. Allowed characters are a-z, A-Z, 0-9, spaces, and ._-:/()#,@[]+=;{}!$*
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[_builtins.int]:
        """
        If the protocol is TCP or UDP, this is the start of the port range. If the protocol is ICMP or ICMPv6, this is the ICMP type or -1 (all ICMP types).
        """
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter(name="sourcePrefixListId")
    def source_prefix_list_id(self) -> Optional[_builtins.str]:
        """
        The ID of a prefix list.
        """
        return pulumi.get(self, "source_prefix_list_id")

    @_builtins.property
    @pulumi.getter(name="sourceSecurityGroupId")
    def source_security_group_id(self) -> Optional[_builtins.str]:
        """
        The ID of the security group.
        """
        return pulumi.get(self, "source_security_group_id")

    @_builtins.property
    @pulumi.getter(name="sourceSecurityGroupName")
    def source_security_group_name(self) -> Optional[_builtins.str]:
        """
        [Default VPC] The name of the source security group. You must specify either the security group ID or the security group name. You can't specify the group name in combination with an IP address range. Creates rules that grant full ICMP, UDP, and TCP access.

        For security groups in a nondefault VPC, you must specify the group ID.
        """
        return pulumi.get(self, "source_security_group_name")

    @_builtins.property
    @pulumi.getter(name="sourceSecurityGroupOwnerId")
    def source_security_group_owner_id(self) -> Optional[_builtins.str]:
        """
        [nondefault VPC] The AWS account ID for the source security group, if the source security group is in a different account. You can't specify this property with an IP address range. Creates rules that grant full ICMP, UDP, and TCP access.

        If you specify `SourceSecurityGroupName` or `SourceSecurityGroupId` and that security group is owned by a different account than the account creating the stack, you must specify the `SourceSecurityGroupOwnerId` ; otherwise, this property is optional.
        """
        return pulumi.get(self, "source_security_group_owner_id")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[_builtins.int]:
        """
        If the protocol is TCP or UDP, this is the end of the port range. If the protocol is ICMP or ICMPv6, this is the ICMP code or -1 (all ICMP codes). If the start port is -1 (all ICMP types), then the end port must be -1 (all ICMP codes).
        """
        return pulumi.get(self, "to_port")


@pulumi.output_type
class SpotFleetAcceleratorCountRequest(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        """
        :param _builtins.int max: The maximum number of accelerators. To specify no maximum limit, omit this parameter. To exclude accelerator-enabled instance types, set `Max` to `0` .
        :param _builtins.int min: The minimum number of accelerators. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        """
        The maximum number of accelerators. To specify no maximum limit, omit this parameter. To exclude accelerator-enabled instance types, set `Max` to `0` .
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        """
        The minimum number of accelerators. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetAcceleratorTotalMemoryMiBRequest(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        """
        :param _builtins.int max: The maximum amount of accelerator memory, in MiB. To specify no maximum limit, omit this parameter.
        :param _builtins.int min: The minimum amount of accelerator memory, in MiB. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        """
        The maximum amount of accelerator memory, in MiB. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        """
        The minimum amount of accelerator memory, in MiB. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetBaselineEbsBandwidthMbpsRequest(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        """
        :param _builtins.int max: The maximum baseline bandwidth, in Mbps. To specify no maximum limit, omit this parameter.
        :param _builtins.int min: The minimum baseline bandwidth, in Mbps. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        """
        The maximum baseline bandwidth, in Mbps. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        """
        The minimum baseline bandwidth, in Mbps. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetBaselinePerformanceFactorsRequest(dict):
    def __init__(__self__, *,
                 cpu: Optional['outputs.SpotFleetCpuPerformanceFactorRequest'] = None):
        """
        :param 'SpotFleetCpuPerformanceFactorRequest' cpu: The CPU performance to consider, using an instance family as the baseline reference.
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional['outputs.SpotFleetCpuPerformanceFactorRequest']:
        """
        The CPU performance to consider, using an instance family as the baseline reference.
        """
        return pulumi.get(self, "cpu")


@pulumi.output_type
class SpotFleetBlockDeviceMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "noDevice":
            suggest = "no_device"
        elif key == "virtualName":
            suggest = "virtual_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetBlockDeviceMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetBlockDeviceMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetBlockDeviceMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: _builtins.str,
                 ebs: Optional['outputs.SpotFleetEbsBlockDevice'] = None,
                 no_device: Optional[_builtins.str] = None,
                 virtual_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str device_name: The device name. For available device names, see [Device names for volumes](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/device_naming.html) .
        :param 'SpotFleetEbsBlockDevice' ebs: Parameters used to automatically set up EBS volumes when the instance is launched.
        :param _builtins.str no_device: To omit the device from the block device mapping, specify an empty string. When this property is specified, the device is removed from the block device mapping regardless of the assigned value.
        :param _builtins.str virtual_name: The virtual device name ( `ephemeral` N). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for `ephemeral0` and `ephemeral1` . The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.
               
               NVMe instance store volumes are automatically enumerated and assigned a device name. Including them in your block device mapping has no effect.
               
               Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.
        """
        pulumi.set(__self__, "device_name", device_name)
        if ebs is not None:
            pulumi.set(__self__, "ebs", ebs)
        if no_device is not None:
            pulumi.set(__self__, "no_device", no_device)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @_builtins.property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> _builtins.str:
        """
        The device name. For available device names, see [Device names for volumes](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/device_naming.html) .
        """
        return pulumi.get(self, "device_name")

    @_builtins.property
    @pulumi.getter
    def ebs(self) -> Optional['outputs.SpotFleetEbsBlockDevice']:
        """
        Parameters used to automatically set up EBS volumes when the instance is launched.
        """
        return pulumi.get(self, "ebs")

    @_builtins.property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[_builtins.str]:
        """
        To omit the device from the block device mapping, specify an empty string. When this property is specified, the device is removed from the block device mapping regardless of the assigned value.
        """
        return pulumi.get(self, "no_device")

    @_builtins.property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[_builtins.str]:
        """
        The virtual device name ( `ephemeral` N). Instance store volumes are numbered starting from 0. An instance type with 2 available instance store volumes can specify mappings for `ephemeral0` and `ephemeral1` . The number of available instance store volumes depends on the instance type. After you connect to the instance, you must mount the volume.

        NVMe instance store volumes are automatically enumerated and assigned a device name. Including them in your block device mapping has no effect.

        Constraints: For M3 instances, you must specify instance store volumes in the block device mapping for the instance. When you launch an M3 instance, we ignore any instance store volumes specified in the block device mapping for the AMI.
        """
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class SpotFleetClassicLoadBalancer(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: The name of the load balancer.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the load balancer.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SpotFleetClassicLoadBalancersConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "classicLoadBalancers":
            suggest = "classic_load_balancers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetClassicLoadBalancersConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetClassicLoadBalancersConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetClassicLoadBalancersConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 classic_load_balancers: Sequence['outputs.SpotFleetClassicLoadBalancer']):
        """
        :param Sequence['SpotFleetClassicLoadBalancer'] classic_load_balancers: One or more Classic Load Balancers.
        """
        pulumi.set(__self__, "classic_load_balancers", classic_load_balancers)

    @_builtins.property
    @pulumi.getter(name="classicLoadBalancers")
    def classic_load_balancers(self) -> Sequence['outputs.SpotFleetClassicLoadBalancer']:
        """
        One or more Classic Load Balancers.
        """
        return pulumi.get(self, "classic_load_balancers")


@pulumi.output_type
class SpotFleetCpuPerformanceFactorRequest(dict):
    def __init__(__self__, *,
                 references: Optional[Sequence['outputs.SpotFleetPerformanceFactorReferenceRequest']] = None):
        """
        :param Sequence['SpotFleetPerformanceFactorReferenceRequest'] references: Specify an instance family to use as the baseline reference for CPU performance. All instance types that match your specified attributes will be compared against the CPU performance of the referenced instance family, regardless of CPU manufacturer or architecture differences.
               
               > Currently, only one instance family can be specified in the list.
        """
        if references is not None:
            pulumi.set(__self__, "references", references)

    @_builtins.property
    @pulumi.getter
    def references(self) -> Optional[Sequence['outputs.SpotFleetPerformanceFactorReferenceRequest']]:
        """
        Specify an instance family to use as the baseline reference for CPU performance. All instance types that match your specified attributes will be compared against the CPU performance of the referenced instance family, regardless of CPU manufacturer or architecture differences.

        > Currently, only one instance family can be specified in the list.
        """
        return pulumi.get(self, "references")


@pulumi.output_type
class SpotFleetEbsBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetEbsBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetEbsBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetEbsBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_on_termination: Optional[_builtins.bool] = None,
                 encrypted: Optional[_builtins.bool] = None,
                 iops: Optional[_builtins.int] = None,
                 snapshot_id: Optional[_builtins.str] = None,
                 volume_size: Optional[_builtins.int] = None,
                 volume_type: Optional['SpotFleetEbsBlockDeviceVolumeType'] = None):
        """
        :param _builtins.bool delete_on_termination: Indicates whether the EBS volume is deleted on instance termination. For more information, see [Preserving Amazon EBS volumes on instance termination](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination) in the *Amazon EC2 User Guide* .
        :param _builtins.bool encrypted: Indicates whether the encryption state of an EBS volume is changed while being restored from a backing snapshot. The effect of setting the encryption state to `true` depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see [Amazon EBS Encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-parameters) in the *Amazon EC2 User Guide* .
               
               In no case can you remove encryption from an encrypted volume.
               
               Encrypted volumes can only be attached to instances that support Amazon EBS encryption. For more information, see [Supported Instance Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances) .
               
               This parameter is not returned by [DescribeImageAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImageAttribute.html) .
        :param _builtins.int iops: The number of I/O operations per second (IOPS). For `gp3` , `io1` , and `io2` volumes, this represents the number of IOPS that are provisioned for the volume. For `gp2` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.
               
               The following are the supported values for each volume type:
               
               - `gp3` : 3,000 - 80,000 IOPS
               - `io1` : 100 - 64,000 IOPS
               - `io2` : 100 - 256,000 IOPS
               
               For `io2` volumes, you can achieve up to 256,000 IOPS on [instances built on the Nitro System](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances) . On other instances, you can achieve performance up to 32,000 IOPS.
               
               This parameter is required for `io1` and `io2` volumes. The default for `gp3` volumes is 3,000 IOPS.
        :param _builtins.str snapshot_id: The ID of the snapshot.
        :param _builtins.int volume_size: The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size.
               
               The following are the supported sizes for each volume type:
               
               - `gp2` : 1 - 16,384 GiB
               - `gp3` : 1 - 65,536 GiB
               - `io1` : 4 - 16,384 GiB
               - `io2` : 4 - 65,536 GiB
               - `st1` and `sc1` : 125 - 16,384 GiB
               - `standard` : 1 - 1024 GiB
        :param 'SpotFleetEbsBlockDeviceVolumeType' volume_type: The volume type. For more information, see [Amazon EBS volume types](https://docs.aws.amazon.com/ebs/latest/userguide/ebs-volume-types.html) in the *Amazon EBS User Guide* .
        """
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the EBS volume is deleted on instance termination. For more information, see [Preserving Amazon EBS volumes on instance termination](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/terminating-instances.html#preserving-volumes-on-termination) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter
    def encrypted(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the encryption state of an EBS volume is changed while being restored from a backing snapshot. The effect of setting the encryption state to `true` depends on the volume origin (new or from a snapshot), starting encryption state, ownership, and whether encryption by default is enabled. For more information, see [Amazon EBS Encryption](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#encryption-parameters) in the *Amazon EC2 User Guide* .

        In no case can you remove encryption from an encrypted volume.

        Encrypted volumes can only be attached to instances that support Amazon EBS encryption. For more information, see [Supported Instance Types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances) .

        This parameter is not returned by [DescribeImageAttribute](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImageAttribute.html) .
        """
        return pulumi.get(self, "encrypted")

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[_builtins.int]:
        """
        The number of I/O operations per second (IOPS). For `gp3` , `io1` , and `io2` volumes, this represents the number of IOPS that are provisioned for the volume. For `gp2` volumes, this represents the baseline performance of the volume and the rate at which the volume accumulates I/O credits for bursting.

        The following are the supported values for each volume type:

        - `gp3` : 3,000 - 80,000 IOPS
        - `io1` : 100 - 64,000 IOPS
        - `io2` : 100 - 256,000 IOPS

        For `io2` volumes, you can achieve up to 256,000 IOPS on [instances built on the Nitro System](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html#ec2-nitro-instances) . On other instances, you can achieve performance up to 32,000 IOPS.

        This parameter is required for `io1` and `io2` volumes. The default for `gp3` volumes is 3,000 IOPS.
        """
        return pulumi.get(self, "iops")

    @_builtins.property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[_builtins.str]:
        """
        The ID of the snapshot.
        """
        return pulumi.get(self, "snapshot_id")

    @_builtins.property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[_builtins.int]:
        """
        The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size. If you specify a snapshot, the default is the snapshot size. You can specify a volume size that is equal to or larger than the snapshot size.

        The following are the supported sizes for each volume type:

        - `gp2` : 1 - 16,384 GiB
        - `gp3` : 1 - 65,536 GiB
        - `io1` : 4 - 16,384 GiB
        - `io2` : 4 - 65,536 GiB
        - `st1` and `sc1` : 125 - 16,384 GiB
        - `standard` : 1 - 1024 GiB
        """
        return pulumi.get(self, "volume_size")

    @_builtins.property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional['SpotFleetEbsBlockDeviceVolumeType']:
        """
        The volume type. For more information, see [Amazon EBS volume types](https://docs.aws.amazon.com/ebs/latest/userguide/ebs-volume-types.html) in the *Amazon EBS User Guide* .
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class SpotFleetFleetLaunchTemplateSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTemplateId":
            suggest = "launch_template_id"
        elif key == "launchTemplateName":
            suggest = "launch_template_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetFleetLaunchTemplateSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetFleetLaunchTemplateSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetFleetLaunchTemplateSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 version: _builtins.str,
                 launch_template_id: Optional[_builtins.str] = None,
                 launch_template_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str version: The version number of the launch template.
               
               Specifying `$Latest` or `$Default` for the template version number is not supported. However, you can specify `LatestVersionNumber` or `DefaultVersionNumber` using the `Fn::GetAtt` intrinsic function. For more information, see [Fn::GetAtt](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#aws-resource-ec2-launchtemplate-return-values-fn--getatt) .
        :param _builtins.str launch_template_id: The ID of the launch template.
               
               You must specify the `LaunchTemplateId` or the `LaunchTemplateName` , but not both.
        :param _builtins.str launch_template_name: The name of the launch template.
               
               You must specify the `LaunchTemplateName` or the `LaunchTemplateId` , but not both.
        """
        pulumi.set(__self__, "version", version)
        if launch_template_id is not None:
            pulumi.set(__self__, "launch_template_id", launch_template_id)
        if launch_template_name is not None:
            pulumi.set(__self__, "launch_template_name", launch_template_name)

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The version number of the launch template.

        Specifying `$Latest` or `$Default` for the template version number is not supported. However, you can specify `LatestVersionNumber` or `DefaultVersionNumber` using the `Fn::GetAtt` intrinsic function. For more information, see [Fn::GetAtt](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-launchtemplate.html#aws-resource-ec2-launchtemplate-return-values-fn--getatt) .
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter(name="launchTemplateId")
    def launch_template_id(self) -> Optional[_builtins.str]:
        """
        The ID of the launch template.

        You must specify the `LaunchTemplateId` or the `LaunchTemplateName` , but not both.
        """
        return pulumi.get(self, "launch_template_id")

    @_builtins.property
    @pulumi.getter(name="launchTemplateName")
    def launch_template_name(self) -> Optional[_builtins.str]:
        """
        The name of the launch template.

        You must specify the `LaunchTemplateName` or the `LaunchTemplateId` , but not both.
        """
        return pulumi.get(self, "launch_template_name")


@pulumi.output_type
class SpotFleetGroupIdentifier(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupId":
            suggest = "group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetGroupIdentifier. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetGroupIdentifier.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetGroupIdentifier.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_id: _builtins.str):
        """
        :param _builtins.str group_id: The ID of the security group.
        """
        pulumi.set(__self__, "group_id", group_id)

    @_builtins.property
    @pulumi.getter(name="groupId")
    def group_id(self) -> _builtins.str:
        """
        The ID of the security group.
        """
        return pulumi.get(self, "group_id")


@pulumi.output_type
class SpotFleetIamInstanceProfileSpecification(dict):
    def __init__(__self__, *,
                 arn: Optional[_builtins.str] = None):
        """
        :param _builtins.str arn: The Amazon Resource Name (ARN) of the instance profile.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> Optional[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the instance profile.
        """
        return pulumi.get(self, "arn")


@pulumi.output_type
class SpotFleetInstanceIpv6Address(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv6Address":
            suggest = "ipv6_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetInstanceIpv6Address. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetInstanceIpv6Address.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetInstanceIpv6Address.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv6_address: _builtins.str):
        """
        :param _builtins.str ipv6_address: The IPv6 address.
        """
        pulumi.set(__self__, "ipv6_address", ipv6_address)

    @_builtins.property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> _builtins.str:
        """
        The IPv6 address.
        """
        return pulumi.get(self, "ipv6_address")


@pulumi.output_type
class SpotFleetInstanceNetworkInterfaceSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "associatePublicIpAddress":
            suggest = "associate_public_ip_address"
        elif key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "deviceIndex":
            suggest = "device_index"
        elif key == "ipv6AddressCount":
            suggest = "ipv6_address_count"
        elif key == "ipv6Addresses":
            suggest = "ipv6_addresses"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "privateIpAddresses":
            suggest = "private_ip_addresses"
        elif key == "secondaryPrivateIpAddressCount":
            suggest = "secondary_private_ip_address_count"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetInstanceNetworkInterfaceSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetInstanceNetworkInterfaceSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetInstanceNetworkInterfaceSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 associate_public_ip_address: Optional[_builtins.bool] = None,
                 delete_on_termination: Optional[_builtins.bool] = None,
                 description: Optional[_builtins.str] = None,
                 device_index: Optional[_builtins.int] = None,
                 groups: Optional[Sequence[_builtins.str]] = None,
                 ipv6_address_count: Optional[_builtins.int] = None,
                 ipv6_addresses: Optional[Sequence['outputs.SpotFleetInstanceIpv6Address']] = None,
                 network_interface_id: Optional[_builtins.str] = None,
                 private_ip_addresses: Optional[Sequence['outputs.SpotFleetPrivateIpAddressSpecification']] = None,
                 secondary_private_ip_address_count: Optional[_builtins.int] = None,
                 subnet_id: Optional[_builtins.str] = None):
        """
        :param _builtins.bool associate_public_ip_address: Indicates whether to assign a public IPv4 address to an instance you launch in a VPC. The public IP address can only be assigned to a network interface for eth0, and can only be assigned to a new network interface, not an existing one. You cannot specify more than one network interface in the request. If launching into a default subnet, the default value is `true` .
               
               AWS charges for all public IPv4 addresses, including public IPv4 addresses associated with running instances and Elastic IP addresses. For more information, see the *Public IPv4 Address* tab on the [Amazon VPC pricing page](https://docs.aws.amazon.com/vpc/pricing/) .
        :param _builtins.bool delete_on_termination: Indicates whether the network interface is deleted when the instance is terminated.
        :param _builtins.str description: The description of the network interface. Applies only if creating a network interface when launching an instance.
        :param _builtins.int device_index: The position of the network interface in the attachment order. A primary network interface has a device index of 0.
               
               If you specify a network interface when launching an instance, you must specify the device index.
        :param Sequence[_builtins.str] groups: The IDs of the security groups for the network interface. Applies only if creating a network interface when launching an instance.
        :param _builtins.int ipv6_address_count: A number of IPv6 addresses to assign to the network interface. Amazon EC2 chooses the IPv6 addresses from the range of the subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.
        :param Sequence['SpotFleetInstanceIpv6Address'] ipv6_addresses: The IPv6 addresses to assign to the network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.
        :param _builtins.str network_interface_id: The ID of the network interface.
               
               If you are creating a Spot Fleet, omit this parameter because you cant specify a network interface ID in a launch specification.
        :param Sequence['SpotFleetPrivateIpAddressSpecification'] private_ip_addresses: The private IPv4 addresses to assign to the network interface. Only one private IPv4 address can be designated as primary. You cannot specify this option if you're launching more than one instance in a [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) request.
        :param _builtins.int secondary_private_ip_address_count: The number of secondary private IPv4 addresses. You cant specify this parameter and also specify a secondary private IP address using the `PrivateIpAddress` parameter.
        :param _builtins.str subnet_id: The ID of the subnet associated with the network interface.
        """
        if associate_public_ip_address is not None:
            pulumi.set(__self__, "associate_public_ip_address", associate_public_ip_address)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if device_index is not None:
            pulumi.set(__self__, "device_index", device_index)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if ipv6_address_count is not None:
            pulumi.set(__self__, "ipv6_address_count", ipv6_address_count)
        if ipv6_addresses is not None:
            pulumi.set(__self__, "ipv6_addresses", ipv6_addresses)
        if network_interface_id is not None:
            pulumi.set(__self__, "network_interface_id", network_interface_id)
        if private_ip_addresses is not None:
            pulumi.set(__self__, "private_ip_addresses", private_ip_addresses)
        if secondary_private_ip_address_count is not None:
            pulumi.set(__self__, "secondary_private_ip_address_count", secondary_private_ip_address_count)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="associatePublicIpAddress")
    def associate_public_ip_address(self) -> Optional[_builtins.bool]:
        """
        Indicates whether to assign a public IPv4 address to an instance you launch in a VPC. The public IP address can only be assigned to a network interface for eth0, and can only be assigned to a new network interface, not an existing one. You cannot specify more than one network interface in the request. If launching into a default subnet, the default value is `true` .

        AWS charges for all public IPv4 addresses, including public IPv4 addresses associated with running instances and Elastic IP addresses. For more information, see the *Public IPv4 Address* tab on the [Amazon VPC pricing page](https://docs.aws.amazon.com/vpc/pricing/) .
        """
        return pulumi.get(self, "associate_public_ip_address")

    @_builtins.property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the network interface is deleted when the instance is terminated.
        """
        return pulumi.get(self, "delete_on_termination")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of the network interface. Applies only if creating a network interface when launching an instance.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> Optional[_builtins.int]:
        """
        The position of the network interface in the attachment order. A primary network interface has a device index of 0.

        If you specify a network interface when launching an instance, you must specify the device index.
        """
        return pulumi.get(self, "device_index")

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        The IDs of the security groups for the network interface. Applies only if creating a network interface when launching an instance.
        """
        return pulumi.get(self, "groups")

    @_builtins.property
    @pulumi.getter(name="ipv6AddressCount")
    def ipv6_address_count(self) -> Optional[_builtins.int]:
        """
        A number of IPv6 addresses to assign to the network interface. Amazon EC2 chooses the IPv6 addresses from the range of the subnet. You cannot specify this option and the option to assign specific IPv6 addresses in the same request. You can specify this option if you've specified a minimum number of instances to launch.
        """
        return pulumi.get(self, "ipv6_address_count")

    @_builtins.property
    @pulumi.getter(name="ipv6Addresses")
    def ipv6_addresses(self) -> Optional[Sequence['outputs.SpotFleetInstanceIpv6Address']]:
        """
        The IPv6 addresses to assign to the network interface. You cannot specify this option and the option to assign a number of IPv6 addresses in the same request. You cannot specify this option if you've specified a minimum number of instances to launch.
        """
        return pulumi.get(self, "ipv6_addresses")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[_builtins.str]:
        """
        The ID of the network interface.

        If you are creating a Spot Fleet, omit this parameter because you cant specify a network interface ID in a launch specification.
        """
        return pulumi.get(self, "network_interface_id")

    @_builtins.property
    @pulumi.getter(name="privateIpAddresses")
    def private_ip_addresses(self) -> Optional[Sequence['outputs.SpotFleetPrivateIpAddressSpecification']]:
        """
        The private IPv4 addresses to assign to the network interface. Only one private IPv4 address can be designated as primary. You cannot specify this option if you're launching more than one instance in a [RunInstances](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RunInstances.html) request.
        """
        return pulumi.get(self, "private_ip_addresses")

    @_builtins.property
    @pulumi.getter(name="secondaryPrivateIpAddressCount")
    def secondary_private_ip_address_count(self) -> Optional[_builtins.int]:
        """
        The number of secondary private IPv4 addresses. You cant specify this parameter and also specify a secondary private IP address using the `PrivateIpAddress` parameter.
        """
        return pulumi.get(self, "secondary_private_ip_address_count")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        The ID of the subnet associated with the network interface.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class SpotFleetInstanceRequirementsRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceleratorCount":
            suggest = "accelerator_count"
        elif key == "acceleratorManufacturers":
            suggest = "accelerator_manufacturers"
        elif key == "acceleratorNames":
            suggest = "accelerator_names"
        elif key == "acceleratorTotalMemoryMiB":
            suggest = "accelerator_total_memory_mi_b"
        elif key == "acceleratorTypes":
            suggest = "accelerator_types"
        elif key == "allowedInstanceTypes":
            suggest = "allowed_instance_types"
        elif key == "bareMetal":
            suggest = "bare_metal"
        elif key == "baselineEbsBandwidthMbps":
            suggest = "baseline_ebs_bandwidth_mbps"
        elif key == "baselinePerformanceFactors":
            suggest = "baseline_performance_factors"
        elif key == "burstablePerformance":
            suggest = "burstable_performance"
        elif key == "cpuManufacturers":
            suggest = "cpu_manufacturers"
        elif key == "excludedInstanceTypes":
            suggest = "excluded_instance_types"
        elif key == "instanceGenerations":
            suggest = "instance_generations"
        elif key == "localStorage":
            suggest = "local_storage"
        elif key == "localStorageTypes":
            suggest = "local_storage_types"
        elif key == "maxSpotPriceAsPercentageOfOptimalOnDemandPrice":
            suggest = "max_spot_price_as_percentage_of_optimal_on_demand_price"
        elif key == "memoryGiBPerVCpu":
            suggest = "memory_gi_b_per_v_cpu"
        elif key == "memoryMiB":
            suggest = "memory_mi_b"
        elif key == "networkBandwidthGbps":
            suggest = "network_bandwidth_gbps"
        elif key == "networkInterfaceCount":
            suggest = "network_interface_count"
        elif key == "onDemandMaxPricePercentageOverLowestPrice":
            suggest = "on_demand_max_price_percentage_over_lowest_price"
        elif key == "requireHibernateSupport":
            suggest = "require_hibernate_support"
        elif key == "spotMaxPricePercentageOverLowestPrice":
            suggest = "spot_max_price_percentage_over_lowest_price"
        elif key == "totalLocalStorageGb":
            suggest = "total_local_storage_gb"
        elif key == "vCpuCount":
            suggest = "v_cpu_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetInstanceRequirementsRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetInstanceRequirementsRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetInstanceRequirementsRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accelerator_count: Optional['outputs.SpotFleetAcceleratorCountRequest'] = None,
                 accelerator_manufacturers: Optional[Sequence['SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem']] = None,
                 accelerator_names: Optional[Sequence['SpotFleetInstanceRequirementsRequestAcceleratorNamesItem']] = None,
                 accelerator_total_memory_mi_b: Optional['outputs.SpotFleetAcceleratorTotalMemoryMiBRequest'] = None,
                 accelerator_types: Optional[Sequence['SpotFleetInstanceRequirementsRequestAcceleratorTypesItem']] = None,
                 allowed_instance_types: Optional[Sequence[_builtins.str]] = None,
                 bare_metal: Optional['SpotFleetInstanceRequirementsRequestBareMetal'] = None,
                 baseline_ebs_bandwidth_mbps: Optional['outputs.SpotFleetBaselineEbsBandwidthMbpsRequest'] = None,
                 baseline_performance_factors: Optional['outputs.SpotFleetBaselinePerformanceFactorsRequest'] = None,
                 burstable_performance: Optional['SpotFleetInstanceRequirementsRequestBurstablePerformance'] = None,
                 cpu_manufacturers: Optional[Sequence['SpotFleetInstanceRequirementsRequestCpuManufacturersItem']] = None,
                 excluded_instance_types: Optional[Sequence[_builtins.str]] = None,
                 instance_generations: Optional[Sequence['SpotFleetInstanceRequirementsRequestInstanceGenerationsItem']] = None,
                 local_storage: Optional['SpotFleetInstanceRequirementsRequestLocalStorage'] = None,
                 local_storage_types: Optional[Sequence['SpotFleetInstanceRequirementsRequestLocalStorageTypesItem']] = None,
                 max_spot_price_as_percentage_of_optimal_on_demand_price: Optional[_builtins.int] = None,
                 memory_gi_b_per_v_cpu: Optional['outputs.SpotFleetMemoryGiBPerVCpuRequest'] = None,
                 memory_mi_b: Optional['outputs.SpotFleetMemoryMiBRequest'] = None,
                 network_bandwidth_gbps: Optional['outputs.SpotFleetNetworkBandwidthGbpsRequest'] = None,
                 network_interface_count: Optional['outputs.SpotFleetNetworkInterfaceCountRequest'] = None,
                 on_demand_max_price_percentage_over_lowest_price: Optional[_builtins.int] = None,
                 require_hibernate_support: Optional[_builtins.bool] = None,
                 spot_max_price_percentage_over_lowest_price: Optional[_builtins.int] = None,
                 total_local_storage_gb: Optional['outputs.SpotFleetTotalLocalStorageGbRequest'] = None,
                 v_cpu_count: Optional['outputs.SpotFleetVCpuCountRangeRequest'] = None):
        """
        :param 'SpotFleetAcceleratorCountRequest' accelerator_count: The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.
               
               To exclude accelerator-enabled instance types, set `Max` to `0` .
               
               Default: No minimum or maximum limits
        :param Sequence['SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem'] accelerator_manufacturers: Indicates whether instance types must have accelerators by specific manufacturers.
               
               - For instance types with AWS devices, specify `amazon-web-services` .
               - For instance types with AMD devices, specify `amd` .
               - For instance types with Habana devices, specify `habana` .
               - For instance types with NVIDIA devices, specify `nvidia` .
               - For instance types with Xilinx devices, specify `xilinx` .
               
               Default: Any manufacturer
        :param Sequence['SpotFleetInstanceRequirementsRequestAcceleratorNamesItem'] accelerator_names: The accelerators that must be on the instance type.
               
               - For instance types with NVIDIA A10G GPUs, specify `a10g` .
               - For instance types with NVIDIA A100 GPUs, specify `a100` .
               - For instance types with NVIDIA H100 GPUs, specify `h100` .
               - For instance types with AWS Inferentia chips, specify `inferentia` .
               - For instance types with NVIDIA GRID K520 GPUs, specify `k520` .
               - For instance types with NVIDIA K80 GPUs, specify `k80` .
               - For instance types with NVIDIA M60 GPUs, specify `m60` .
               - For instance types with AMD Radeon Pro V520 GPUs, specify `radeon-pro-v520` .
               - For instance types with NVIDIA T4 GPUs, specify `t4` .
               - For instance types with NVIDIA T4G GPUs, specify `t4g` .
               - For instance types with Xilinx VU9P FPGAs, specify `vu9p` .
               - For instance types with NVIDIA V100 GPUs, specify `v100` .
               
               Default: Any accelerator
        :param 'SpotFleetAcceleratorTotalMemoryMiBRequest' accelerator_total_memory_mi_b: The minimum and maximum amount of total accelerator memory, in MiB.
               
               Default: No minimum or maximum limits
        :param Sequence['SpotFleetInstanceRequirementsRequestAcceleratorTypesItem'] accelerator_types: The accelerator types that must be on the instance type.
               
               - For instance types with FPGA accelerators, specify `fpga` .
               - For instance types with GPU accelerators, specify `gpu` .
               - For instance types with Inference accelerators, specify `inference` .
               
               Default: Any accelerator type
        :param Sequence[_builtins.str] allowed_instance_types: The instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes.
               
               You can use strings with one or more wild cards, represented by an asterisk ( `*` ), to allow an instance type, size, or generation. The following are examples: `m5.8xlarge` , `c5*.*` , `m5a.*` , `r*` , `*3*` .
               
               For example, if you specify `c5*` ,Amazon EC2 will allow the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*` , Amazon EC2 will allow all the M5a instance types, but not the M5n instance types.
               
               > If you specify `AllowedInstanceTypes` , you can't specify `ExcludedInstanceTypes` . 
               
               Default: All instance types
        :param 'SpotFleetInstanceRequirementsRequestBareMetal' bare_metal: Indicates whether bare metal instance types must be included, excluded, or required.
               
               - To include bare metal instance types, specify `included` .
               - To require only bare metal instance types, specify `required` .
               - To exclude bare metal instance types, specify `excluded` .
               
               Default: `excluded`
        :param 'SpotFleetBaselineEbsBandwidthMbpsRequest' baseline_ebs_bandwidth_mbps: The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see [Amazon EBSoptimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the *Amazon EC2 User Guide* .
               
               Default: No minimum or maximum limits
        :param 'SpotFleetBaselinePerformanceFactorsRequest' baseline_performance_factors: The baseline performance to consider, using an instance family as a baseline reference. The instance family establishes the lowest acceptable level of performance. Amazon EC2 uses this baseline to guide instance type selection, but there is no guarantee that the selected instance types will always exceed the baseline for every application. Currently, this parameter only supports CPU performance as a baseline performance factor. For more information, see [Performance protection](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html#ec2fleet-abis-performance-protection) in the *Amazon EC2 User Guide* .
        :param 'SpotFleetInstanceRequirementsRequestBurstablePerformance' burstable_performance: Indicates whether burstable performance T instance types are included, excluded, or required. For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) .
               
               - To include burstable performance instance types, specify `included` .
               - To require only burstable performance instance types, specify `required` .
               - To exclude burstable performance instance types, specify `excluded` .
               
               Default: `excluded`
        :param Sequence['SpotFleetInstanceRequirementsRequestCpuManufacturersItem'] cpu_manufacturers: The CPU manufacturers to include.
               
               - For instance types with Intel CPUs, specify `intel` .
               - For instance types with AMD CPUs, specify `amd` .
               - For instance types with AWS CPUs, specify `amazon-web-services` .
               - For instance types with Apple CPUs, specify `apple` .
               
               > Don't confuse the CPU manufacturer with the CPU architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template. 
               
               Default: Any manufacturer
        :param Sequence[_builtins.str] excluded_instance_types: The instance types to exclude.
               
               You can use strings with one or more wild cards, represented by an asterisk ( `*` ), to exclude an instance family, type, size, or generation. The following are examples: `m5.8xlarge` , `c5*.*` , `m5a.*` , `r*` , `*3*` .
               
               For example, if you specify `c5*` ,Amazon EC2 will exclude the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*` , Amazon EC2 will exclude all the M5a instance types, but not the M5n instance types.
               
               > If you specify `ExcludedInstanceTypes` , you can't specify `AllowedInstanceTypes` . 
               
               Default: No excluded instance types
        :param Sequence['SpotFleetInstanceRequirementsRequestInstanceGenerationsItem'] instance_generations: Indicates whether current or previous generation instance types are included. The current generation instance types are recommended for use. Current generation instance types are typically the latest two to three generations in each instance family. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .
               
               For current generation instance types, specify `current` .
               
               For previous generation instance types, specify `previous` .
               
               Default: Current and previous generation instance types
        :param 'SpotFleetInstanceRequirementsRequestLocalStorage' local_storage: Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, [Amazon EC2 instance store](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html) in the *Amazon EC2 User Guide* .
               
               - To include instance types with instance store volumes, specify `included` .
               - To require only instance types with instance store volumes, specify `required` .
               - To exclude instance types with instance store volumes, specify `excluded` .
               
               Default: `included`
        :param Sequence['SpotFleetInstanceRequirementsRequestLocalStorageTypesItem'] local_storage_types: The type of local storage that is required.
               
               - For instance types with hard disk drive (HDD) storage, specify `hdd` .
               - For instance types with solid state drive (SSD) storage, specify `ssd` .
               
               Default: `hdd` and `ssd`
        :param _builtins.int max_spot_price_as_percentage_of_optimal_on_demand_price: [Price protection] The price protection threshold for Spot Instances, as a percentage of an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.
               
               The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
               
               If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is based on the per vCPU or per memory price instead of the per instance price.
               
               > Only one of `SpotMaxPricePercentageOverLowestPrice` or `MaxSpotPriceAsPercentageOfOptimalOnDemandPrice` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as `999999` .
        :param 'SpotFleetMemoryGiBPerVCpuRequest' memory_gi_b_per_v_cpu: The minimum and maximum amount of memory per vCPU, in GiB.
               
               Default: No minimum or maximum limits
        :param 'SpotFleetMemoryMiBRequest' memory_mi_b: The minimum and maximum amount of memory, in MiB.
        :param 'SpotFleetNetworkBandwidthGbpsRequest' network_bandwidth_gbps: The minimum and maximum amount of baseline network bandwidth, in gigabits per second (Gbps). For more information, see [Amazon EC2 instance network bandwidth](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-network-bandwidth.html) in the *Amazon EC2 User Guide* .
               
               Default: No minimum or maximum limits
        :param 'SpotFleetNetworkInterfaceCountRequest' network_interface_count: The minimum and maximum number of network interfaces.
               
               Default: No minimum or maximum limits
        :param _builtins.int on_demand_max_price_percentage_over_lowest_price: [Price protection] The price protection threshold for On-Demand Instances, as a percentage higher than an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.
               
               The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
               
               To indicate no price protection threshold, specify a high value, such as `999999` .
               
               This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) .
               
               > If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price. 
               
               Default: `20`
        :param _builtins.bool require_hibernate_support: Indicates whether instance types must support hibernation for On-Demand Instances.
               
               This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) .
               
               Default: `false`
        :param _builtins.int spot_max_price_percentage_over_lowest_price: [Price protection] The price protection threshold for Spot Instances, as a percentage higher than an identified Spot price. The identified Spot price is the Spot price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified Spot price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose Spot price exceeds your specified threshold.
               
               The parameter accepts an integer, which Amazon EC2 interprets as a percentage.
               
               If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.
               
               This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) .
               
               > Only one of `SpotMaxPricePercentageOverLowestPrice` or `MaxSpotPriceAsPercentageOfOptimalOnDemandPrice` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as `999999` . 
               
               Default: `100`
        :param 'SpotFleetTotalLocalStorageGbRequest' total_local_storage_gb: The minimum and maximum amount of total local storage, in GB.
               
               Default: No minimum or maximum limits
        :param 'SpotFleetVCpuCountRangeRequest' v_cpu_count: The minimum and maximum number of vCPUs.
        """
        if accelerator_count is not None:
            pulumi.set(__self__, "accelerator_count", accelerator_count)
        if accelerator_manufacturers is not None:
            pulumi.set(__self__, "accelerator_manufacturers", accelerator_manufacturers)
        if accelerator_names is not None:
            pulumi.set(__self__, "accelerator_names", accelerator_names)
        if accelerator_total_memory_mi_b is not None:
            pulumi.set(__self__, "accelerator_total_memory_mi_b", accelerator_total_memory_mi_b)
        if accelerator_types is not None:
            pulumi.set(__self__, "accelerator_types", accelerator_types)
        if allowed_instance_types is not None:
            pulumi.set(__self__, "allowed_instance_types", allowed_instance_types)
        if bare_metal is not None:
            pulumi.set(__self__, "bare_metal", bare_metal)
        if baseline_ebs_bandwidth_mbps is not None:
            pulumi.set(__self__, "baseline_ebs_bandwidth_mbps", baseline_ebs_bandwidth_mbps)
        if baseline_performance_factors is not None:
            pulumi.set(__self__, "baseline_performance_factors", baseline_performance_factors)
        if burstable_performance is not None:
            pulumi.set(__self__, "burstable_performance", burstable_performance)
        if cpu_manufacturers is not None:
            pulumi.set(__self__, "cpu_manufacturers", cpu_manufacturers)
        if excluded_instance_types is not None:
            pulumi.set(__self__, "excluded_instance_types", excluded_instance_types)
        if instance_generations is not None:
            pulumi.set(__self__, "instance_generations", instance_generations)
        if local_storage is not None:
            pulumi.set(__self__, "local_storage", local_storage)
        if local_storage_types is not None:
            pulumi.set(__self__, "local_storage_types", local_storage_types)
        if max_spot_price_as_percentage_of_optimal_on_demand_price is not None:
            pulumi.set(__self__, "max_spot_price_as_percentage_of_optimal_on_demand_price", max_spot_price_as_percentage_of_optimal_on_demand_price)
        if memory_gi_b_per_v_cpu is not None:
            pulumi.set(__self__, "memory_gi_b_per_v_cpu", memory_gi_b_per_v_cpu)
        if memory_mi_b is not None:
            pulumi.set(__self__, "memory_mi_b", memory_mi_b)
        if network_bandwidth_gbps is not None:
            pulumi.set(__self__, "network_bandwidth_gbps", network_bandwidth_gbps)
        if network_interface_count is not None:
            pulumi.set(__self__, "network_interface_count", network_interface_count)
        if on_demand_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "on_demand_max_price_percentage_over_lowest_price", on_demand_max_price_percentage_over_lowest_price)
        if require_hibernate_support is not None:
            pulumi.set(__self__, "require_hibernate_support", require_hibernate_support)
        if spot_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "spot_max_price_percentage_over_lowest_price", spot_max_price_percentage_over_lowest_price)
        if total_local_storage_gb is not None:
            pulumi.set(__self__, "total_local_storage_gb", total_local_storage_gb)
        if v_cpu_count is not None:
            pulumi.set(__self__, "v_cpu_count", v_cpu_count)

    @_builtins.property
    @pulumi.getter(name="acceleratorCount")
    def accelerator_count(self) -> Optional['outputs.SpotFleetAcceleratorCountRequest']:
        """
        The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferentia chips) on an instance.

        To exclude accelerator-enabled instance types, set `Max` to `0` .

        Default: No minimum or maximum limits
        """
        return pulumi.get(self, "accelerator_count")

    @_builtins.property
    @pulumi.getter(name="acceleratorManufacturers")
    def accelerator_manufacturers(self) -> Optional[Sequence['SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem']]:
        """
        Indicates whether instance types must have accelerators by specific manufacturers.

        - For instance types with AWS devices, specify `amazon-web-services` .
        - For instance types with AMD devices, specify `amd` .
        - For instance types with Habana devices, specify `habana` .
        - For instance types with NVIDIA devices, specify `nvidia` .
        - For instance types with Xilinx devices, specify `xilinx` .

        Default: Any manufacturer
        """
        return pulumi.get(self, "accelerator_manufacturers")

    @_builtins.property
    @pulumi.getter(name="acceleratorNames")
    def accelerator_names(self) -> Optional[Sequence['SpotFleetInstanceRequirementsRequestAcceleratorNamesItem']]:
        """
        The accelerators that must be on the instance type.

        - For instance types with NVIDIA A10G GPUs, specify `a10g` .
        - For instance types with NVIDIA A100 GPUs, specify `a100` .
        - For instance types with NVIDIA H100 GPUs, specify `h100` .
        - For instance types with AWS Inferentia chips, specify `inferentia` .
        - For instance types with NVIDIA GRID K520 GPUs, specify `k520` .
        - For instance types with NVIDIA K80 GPUs, specify `k80` .
        - For instance types with NVIDIA M60 GPUs, specify `m60` .
        - For instance types with AMD Radeon Pro V520 GPUs, specify `radeon-pro-v520` .
        - For instance types with NVIDIA T4 GPUs, specify `t4` .
        - For instance types with NVIDIA T4G GPUs, specify `t4g` .
        - For instance types with Xilinx VU9P FPGAs, specify `vu9p` .
        - For instance types with NVIDIA V100 GPUs, specify `v100` .

        Default: Any accelerator
        """
        return pulumi.get(self, "accelerator_names")

    @_builtins.property
    @pulumi.getter(name="acceleratorTotalMemoryMiB")
    def accelerator_total_memory_mi_b(self) -> Optional['outputs.SpotFleetAcceleratorTotalMemoryMiBRequest']:
        """
        The minimum and maximum amount of total accelerator memory, in MiB.

        Default: No minimum or maximum limits
        """
        return pulumi.get(self, "accelerator_total_memory_mi_b")

    @_builtins.property
    @pulumi.getter(name="acceleratorTypes")
    def accelerator_types(self) -> Optional[Sequence['SpotFleetInstanceRequirementsRequestAcceleratorTypesItem']]:
        """
        The accelerator types that must be on the instance type.

        - For instance types with FPGA accelerators, specify `fpga` .
        - For instance types with GPU accelerators, specify `gpu` .
        - For instance types with Inference accelerators, specify `inference` .

        Default: Any accelerator type
        """
        return pulumi.get(self, "accelerator_types")

    @_builtins.property
    @pulumi.getter(name="allowedInstanceTypes")
    def allowed_instance_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        The instance types to apply your specified attributes against. All other instance types are ignored, even if they match your specified attributes.

        You can use strings with one or more wild cards, represented by an asterisk ( `*` ), to allow an instance type, size, or generation. The following are examples: `m5.8xlarge` , `c5*.*` , `m5a.*` , `r*` , `*3*` .

        For example, if you specify `c5*` ,Amazon EC2 will allow the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*` , Amazon EC2 will allow all the M5a instance types, but not the M5n instance types.

        > If you specify `AllowedInstanceTypes` , you can't specify `ExcludedInstanceTypes` . 

        Default: All instance types
        """
        return pulumi.get(self, "allowed_instance_types")

    @_builtins.property
    @pulumi.getter(name="bareMetal")
    def bare_metal(self) -> Optional['SpotFleetInstanceRequirementsRequestBareMetal']:
        """
        Indicates whether bare metal instance types must be included, excluded, or required.

        - To include bare metal instance types, specify `included` .
        - To require only bare metal instance types, specify `required` .
        - To exclude bare metal instance types, specify `excluded` .

        Default: `excluded`
        """
        return pulumi.get(self, "bare_metal")

    @_builtins.property
    @pulumi.getter(name="baselineEbsBandwidthMbps")
    def baseline_ebs_bandwidth_mbps(self) -> Optional['outputs.SpotFleetBaselineEbsBandwidthMbpsRequest']:
        """
        The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps. For more information, see [Amazon EBSoptimized instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-optimized.html) in the *Amazon EC2 User Guide* .

        Default: No minimum or maximum limits
        """
        return pulumi.get(self, "baseline_ebs_bandwidth_mbps")

    @_builtins.property
    @pulumi.getter(name="baselinePerformanceFactors")
    def baseline_performance_factors(self) -> Optional['outputs.SpotFleetBaselinePerformanceFactorsRequest']:
        """
        The baseline performance to consider, using an instance family as a baseline reference. The instance family establishes the lowest acceptable level of performance. Amazon EC2 uses this baseline to guide instance type selection, but there is no guarantee that the selected instance types will always exceed the baseline for every application. Currently, this parameter only supports CPU performance as a baseline performance factor. For more information, see [Performance protection](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-fleet-attribute-based-instance-type-selection.html#ec2fleet-abis-performance-protection) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "baseline_performance_factors")

    @_builtins.property
    @pulumi.getter(name="burstablePerformance")
    def burstable_performance(self) -> Optional['SpotFleetInstanceRequirementsRequestBurstablePerformance']:
        """
        Indicates whether burstable performance T instance types are included, excluded, or required. For more information, see [Burstable performance instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances.html) .

        - To include burstable performance instance types, specify `included` .
        - To require only burstable performance instance types, specify `required` .
        - To exclude burstable performance instance types, specify `excluded` .

        Default: `excluded`
        """
        return pulumi.get(self, "burstable_performance")

    @_builtins.property
    @pulumi.getter(name="cpuManufacturers")
    def cpu_manufacturers(self) -> Optional[Sequence['SpotFleetInstanceRequirementsRequestCpuManufacturersItem']]:
        """
        The CPU manufacturers to include.

        - For instance types with Intel CPUs, specify `intel` .
        - For instance types with AMD CPUs, specify `amd` .
        - For instance types with AWS CPUs, specify `amazon-web-services` .
        - For instance types with Apple CPUs, specify `apple` .

        > Don't confuse the CPU manufacturer with the CPU architecture. Instances will be launched with a compatible CPU architecture based on the Amazon Machine Image (AMI) that you specify in your launch template. 

        Default: Any manufacturer
        """
        return pulumi.get(self, "cpu_manufacturers")

    @_builtins.property
    @pulumi.getter(name="excludedInstanceTypes")
    def excluded_instance_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        The instance types to exclude.

        You can use strings with one or more wild cards, represented by an asterisk ( `*` ), to exclude an instance family, type, size, or generation. The following are examples: `m5.8xlarge` , `c5*.*` , `m5a.*` , `r*` , `*3*` .

        For example, if you specify `c5*` ,Amazon EC2 will exclude the entire C5 instance family, which includes all C5a and C5n instance types. If you specify `m5a.*` , Amazon EC2 will exclude all the M5a instance types, but not the M5n instance types.

        > If you specify `ExcludedInstanceTypes` , you can't specify `AllowedInstanceTypes` . 

        Default: No excluded instance types
        """
        return pulumi.get(self, "excluded_instance_types")

    @_builtins.property
    @pulumi.getter(name="instanceGenerations")
    def instance_generations(self) -> Optional[Sequence['SpotFleetInstanceRequirementsRequestInstanceGenerationsItem']]:
        """
        Indicates whether current or previous generation instance types are included. The current generation instance types are recommended for use. Current generation instance types are typically the latest two to three generations in each instance family. For more information, see [Instance types](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-types.html) in the *Amazon EC2 User Guide* .

        For current generation instance types, specify `current` .

        For previous generation instance types, specify `previous` .

        Default: Current and previous generation instance types
        """
        return pulumi.get(self, "instance_generations")

    @_builtins.property
    @pulumi.getter(name="localStorage")
    def local_storage(self) -> Optional['SpotFleetInstanceRequirementsRequestLocalStorage']:
        """
        Indicates whether instance types with instance store volumes are included, excluded, or required. For more information, [Amazon EC2 instance store](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/InstanceStorage.html) in the *Amazon EC2 User Guide* .

        - To include instance types with instance store volumes, specify `included` .
        - To require only instance types with instance store volumes, specify `required` .
        - To exclude instance types with instance store volumes, specify `excluded` .

        Default: `included`
        """
        return pulumi.get(self, "local_storage")

    @_builtins.property
    @pulumi.getter(name="localStorageTypes")
    def local_storage_types(self) -> Optional[Sequence['SpotFleetInstanceRequirementsRequestLocalStorageTypesItem']]:
        """
        The type of local storage that is required.

        - For instance types with hard disk drive (HDD) storage, specify `hdd` .
        - For instance types with solid state drive (SSD) storage, specify `ssd` .

        Default: `hdd` and `ssd`
        """
        return pulumi.get(self, "local_storage_types")

    @_builtins.property
    @pulumi.getter(name="maxSpotPriceAsPercentageOfOptimalOnDemandPrice")
    def max_spot_price_as_percentage_of_optimal_on_demand_price(self) -> Optional[_builtins.int]:
        """
        [Price protection] The price protection threshold for Spot Instances, as a percentage of an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.

        The parameter accepts an integer, which Amazon EC2 interprets as a percentage.

        If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is based on the per vCPU or per memory price instead of the per instance price.

        > Only one of `SpotMaxPricePercentageOverLowestPrice` or `MaxSpotPriceAsPercentageOfOptimalOnDemandPrice` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as `999999` .
        """
        return pulumi.get(self, "max_spot_price_as_percentage_of_optimal_on_demand_price")

    @_builtins.property
    @pulumi.getter(name="memoryGiBPerVCpu")
    def memory_gi_b_per_v_cpu(self) -> Optional['outputs.SpotFleetMemoryGiBPerVCpuRequest']:
        """
        The minimum and maximum amount of memory per vCPU, in GiB.

        Default: No minimum or maximum limits
        """
        return pulumi.get(self, "memory_gi_b_per_v_cpu")

    @_builtins.property
    @pulumi.getter(name="memoryMiB")
    def memory_mi_b(self) -> Optional['outputs.SpotFleetMemoryMiBRequest']:
        """
        The minimum and maximum amount of memory, in MiB.
        """
        return pulumi.get(self, "memory_mi_b")

    @_builtins.property
    @pulumi.getter(name="networkBandwidthGbps")
    def network_bandwidth_gbps(self) -> Optional['outputs.SpotFleetNetworkBandwidthGbpsRequest']:
        """
        The minimum and maximum amount of baseline network bandwidth, in gigabits per second (Gbps). For more information, see [Amazon EC2 instance network bandwidth](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-network-bandwidth.html) in the *Amazon EC2 User Guide* .

        Default: No minimum or maximum limits
        """
        return pulumi.get(self, "network_bandwidth_gbps")

    @_builtins.property
    @pulumi.getter(name="networkInterfaceCount")
    def network_interface_count(self) -> Optional['outputs.SpotFleetNetworkInterfaceCountRequest']:
        """
        The minimum and maximum number of network interfaces.

        Default: No minimum or maximum limits
        """
        return pulumi.get(self, "network_interface_count")

    @_builtins.property
    @pulumi.getter(name="onDemandMaxPricePercentageOverLowestPrice")
    def on_demand_max_price_percentage_over_lowest_price(self) -> Optional[_builtins.int]:
        """
        [Price protection] The price protection threshold for On-Demand Instances, as a percentage higher than an identified On-Demand price. The identified On-Demand price is the price of the lowest priced current generation C, M, or R instance type with your specified attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose price exceeds your specified threshold.

        The parameter accepts an integer, which Amazon EC2 interprets as a percentage.

        To indicate no price protection threshold, specify a high value, such as `999999` .

        This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) .

        > If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price. 

        Default: `20`
        """
        return pulumi.get(self, "on_demand_max_price_percentage_over_lowest_price")

    @_builtins.property
    @pulumi.getter(name="requireHibernateSupport")
    def require_hibernate_support(self) -> Optional[_builtins.bool]:
        """
        Indicates whether instance types must support hibernation for On-Demand Instances.

        This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) .

        Default: `false`
        """
        return pulumi.get(self, "require_hibernate_support")

    @_builtins.property
    @pulumi.getter(name="spotMaxPricePercentageOverLowestPrice")
    def spot_max_price_percentage_over_lowest_price(self) -> Optional[_builtins.int]:
        """
        [Price protection] The price protection threshold for Spot Instances, as a percentage higher than an identified Spot price. The identified Spot price is the Spot price of the lowest priced current generation C, M, or R instance type with your specified attributes. If no current generation C, M, or R instance type matches your attributes, then the identified Spot price is from the lowest priced current generation instance types, and failing that, from the lowest priced previous generation instance types that match your attributes. When Amazon EC2 selects instance types with your attributes, it will exclude instance types whose Spot price exceeds your specified threshold.

        The parameter accepts an integer, which Amazon EC2 interprets as a percentage.

        If you set `TargetCapacityUnitType` to `vcpu` or `memory-mib` , the price protection threshold is applied based on the per-vCPU or per-memory price instead of the per-instance price.

        This parameter is not supported for [GetSpotPlacementScores](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetSpotPlacementScores.html) and [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) .

        > Only one of `SpotMaxPricePercentageOverLowestPrice` or `MaxSpotPriceAsPercentageOfOptimalOnDemandPrice` can be specified. If you don't specify either, Amazon EC2 will automatically apply optimal price protection to consistently select from a wide range of instance types. To indicate no price protection threshold for Spot Instances, meaning you want to consider all instance types that match your attributes, include one of these parameters and specify a high value, such as `999999` . 

        Default: `100`
        """
        return pulumi.get(self, "spot_max_price_percentage_over_lowest_price")

    @_builtins.property
    @pulumi.getter(name="totalLocalStorageGb")
    def total_local_storage_gb(self) -> Optional['outputs.SpotFleetTotalLocalStorageGbRequest']:
        """
        The minimum and maximum amount of total local storage, in GB.

        Default: No minimum or maximum limits
        """
        return pulumi.get(self, "total_local_storage_gb")

    @_builtins.property
    @pulumi.getter(name="vCpuCount")
    def v_cpu_count(self) -> Optional['outputs.SpotFleetVCpuCountRangeRequest']:
        """
        The minimum and maximum number of vCPUs.
        """
        return pulumi.get(self, "v_cpu_count")


@pulumi.output_type
class SpotFleetLaunchSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageId":
            suggest = "image_id"
        elif key == "blockDeviceMappings":
            suggest = "block_device_mappings"
        elif key == "ebsOptimized":
            suggest = "ebs_optimized"
        elif key == "iamInstanceProfile":
            suggest = "iam_instance_profile"
        elif key == "instanceRequirements":
            suggest = "instance_requirements"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "kernelId":
            suggest = "kernel_id"
        elif key == "keyName":
            suggest = "key_name"
        elif key == "networkInterfaces":
            suggest = "network_interfaces"
        elif key == "ramdiskId":
            suggest = "ramdisk_id"
        elif key == "securityGroups":
            suggest = "security_groups"
        elif key == "spotPrice":
            suggest = "spot_price"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "tagSpecifications":
            suggest = "tag_specifications"
        elif key == "userData":
            suggest = "user_data"
        elif key == "weightedCapacity":
            suggest = "weighted_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetLaunchSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetLaunchSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetLaunchSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_id: _builtins.str,
                 block_device_mappings: Optional[Sequence['outputs.SpotFleetBlockDeviceMapping']] = None,
                 ebs_optimized: Optional[_builtins.bool] = None,
                 iam_instance_profile: Optional['outputs.SpotFleetIamInstanceProfileSpecification'] = None,
                 instance_requirements: Optional['outputs.SpotFleetInstanceRequirementsRequest'] = None,
                 instance_type: Optional[_builtins.str] = None,
                 kernel_id: Optional[_builtins.str] = None,
                 key_name: Optional[_builtins.str] = None,
                 monitoring: Optional['outputs.SpotFleetMonitoring'] = None,
                 network_interfaces: Optional[Sequence['outputs.SpotFleetInstanceNetworkInterfaceSpecification']] = None,
                 placement: Optional['outputs.SpotFleetSpotPlacement'] = None,
                 ramdisk_id: Optional[_builtins.str] = None,
                 security_groups: Optional[Sequence['outputs.SpotFleetGroupIdentifier']] = None,
                 spot_price: Optional[_builtins.str] = None,
                 subnet_id: Optional[_builtins.str] = None,
                 tag_specifications: Optional[Sequence['outputs.SpotFleetTagSpecification']] = None,
                 user_data: Optional[_builtins.str] = None,
                 weighted_capacity: Optional[_builtins.float] = None):
        """
        :param _builtins.str image_id: The ID of the AMI.
        :param Sequence['SpotFleetBlockDeviceMapping'] block_device_mappings: One or more block devices that are mapped to the Spot Instances. You can't specify both a snapshot ID and an encryption value. This is because only blank volumes can be encrypted on creation. If a snapshot is the basis for a volume, it is not blank and its encryption status is used for the volume encryption status.
        :param _builtins.bool ebs_optimized: Indicates whether the instances are optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.
               
               Default: `false`
        :param 'SpotFleetIamInstanceProfileSpecification' iam_instance_profile: The IAM instance profile.
        :param 'SpotFleetInstanceRequirementsRequest' instance_requirements: The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with those attributes.
               
               > If you specify `InstanceRequirements` , you can't specify `InstanceType` .
        :param _builtins.str instance_type: The instance type.
        :param _builtins.str kernel_id: The ID of the kernel.
        :param _builtins.str key_name: The name of the key pair.
        :param 'SpotFleetMonitoring' monitoring: Enable or disable monitoring for the instances.
        :param Sequence['SpotFleetInstanceNetworkInterfaceSpecification'] network_interfaces: The network interfaces.
        :param 'SpotFleetSpotPlacement' placement: The placement information.
        :param _builtins.str ramdisk_id: The ID of the RAM disk. Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, refer to the AWS Resource Center and search for the kernel ID.
        :param Sequence['SpotFleetGroupIdentifier'] security_groups: The security groups.
               
               If you specify a network interface, you must specify any security groups as part of the network interface instead of using this parameter.
        :param _builtins.str spot_price: The maximum price per unit hour that you are willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.
               
               > If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.
        :param _builtins.str subnet_id: The IDs of the subnets in which to launch the instances. To specify multiple subnets, separate them using commas; for example, "subnet-1234abcdeexample1, subnet-0987cdef6example2".
               
               If you specify a network interface, you must specify any subnets as part of the network interface instead of using this parameter.
        :param Sequence['SpotFleetTagSpecification'] tag_specifications: The tags to apply during creation.
        :param _builtins.str user_data: The base64-encoded user data that instances use when starting up. User data is limited to 16 KB.
        :param _builtins.float weighted_capacity: The number of units provided by the specified instance type. These are the same units that you chose to set the target capacity in terms of instances, or a performance characteristic such as vCPUs, memory, or I/O.
               
               If the target capacity divided by this value is not a whole number, Amazon EC2 rounds the number of instances to the next whole number. If this value is not specified, the default is 1.
               
               > When specifying weights, the price used in the `lowestPrice` and `priceCapacityOptimized` allocation strategies is per *unit* hour (where the instance price is divided by the specified weight). However, if all the specified weights are above the requested `TargetCapacity` , resulting in only 1 instance being launched, the price used is per *instance* hour.
        """
        pulumi.set(__self__, "image_id", image_id)
        if block_device_mappings is not None:
            pulumi.set(__self__, "block_device_mappings", block_device_mappings)
        if ebs_optimized is not None:
            pulumi.set(__self__, "ebs_optimized", ebs_optimized)
        if iam_instance_profile is not None:
            pulumi.set(__self__, "iam_instance_profile", iam_instance_profile)
        if instance_requirements is not None:
            pulumi.set(__self__, "instance_requirements", instance_requirements)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if kernel_id is not None:
            pulumi.set(__self__, "kernel_id", kernel_id)
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if monitoring is not None:
            pulumi.set(__self__, "monitoring", monitoring)
        if network_interfaces is not None:
            pulumi.set(__self__, "network_interfaces", network_interfaces)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if ramdisk_id is not None:
            pulumi.set(__self__, "ramdisk_id", ramdisk_id)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if spot_price is not None:
            pulumi.set(__self__, "spot_price", spot_price)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if tag_specifications is not None:
            pulumi.set(__self__, "tag_specifications", tag_specifications)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)
        if weighted_capacity is not None:
            pulumi.set(__self__, "weighted_capacity", weighted_capacity)

    @_builtins.property
    @pulumi.getter(name="imageId")
    def image_id(self) -> _builtins.str:
        """
        The ID of the AMI.
        """
        return pulumi.get(self, "image_id")

    @_builtins.property
    @pulumi.getter(name="blockDeviceMappings")
    def block_device_mappings(self) -> Optional[Sequence['outputs.SpotFleetBlockDeviceMapping']]:
        """
        One or more block devices that are mapped to the Spot Instances. You can't specify both a snapshot ID and an encryption value. This is because only blank volumes can be encrypted on creation. If a snapshot is the basis for a volume, it is not blank and its encryption status is used for the volume encryption status.
        """
        return pulumi.get(self, "block_device_mappings")

    @_builtins.property
    @pulumi.getter(name="ebsOptimized")
    def ebs_optimized(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the instances are optimized for EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS Optimized instance.

        Default: `false`
        """
        return pulumi.get(self, "ebs_optimized")

    @_builtins.property
    @pulumi.getter(name="iamInstanceProfile")
    def iam_instance_profile(self) -> Optional['outputs.SpotFleetIamInstanceProfileSpecification']:
        """
        The IAM instance profile.
        """
        return pulumi.get(self, "iam_instance_profile")

    @_builtins.property
    @pulumi.getter(name="instanceRequirements")
    def instance_requirements(self) -> Optional['outputs.SpotFleetInstanceRequirementsRequest']:
        """
        The attributes for the instance types. When you specify instance attributes, Amazon EC2 will identify instance types with those attributes.

        > If you specify `InstanceRequirements` , you can't specify `InstanceType` .
        """
        return pulumi.get(self, "instance_requirements")

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[_builtins.str]:
        """
        The instance type.
        """
        return pulumi.get(self, "instance_type")

    @_builtins.property
    @pulumi.getter(name="kernelId")
    def kernel_id(self) -> Optional[_builtins.str]:
        """
        The ID of the kernel.
        """
        return pulumi.get(self, "kernel_id")

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[_builtins.str]:
        """
        The name of the key pair.
        """
        return pulumi.get(self, "key_name")

    @_builtins.property
    @pulumi.getter
    def monitoring(self) -> Optional['outputs.SpotFleetMonitoring']:
        """
        Enable or disable monitoring for the instances.
        """
        return pulumi.get(self, "monitoring")

    @_builtins.property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Optional[Sequence['outputs.SpotFleetInstanceNetworkInterfaceSpecification']]:
        """
        The network interfaces.
        """
        return pulumi.get(self, "network_interfaces")

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional['outputs.SpotFleetSpotPlacement']:
        """
        The placement information.
        """
        return pulumi.get(self, "placement")

    @_builtins.property
    @pulumi.getter(name="ramdiskId")
    def ramdisk_id(self) -> Optional[_builtins.str]:
        """
        The ID of the RAM disk. Some kernels require additional drivers at launch. Check the kernel requirements for information about whether you need to specify a RAM disk. To find kernel requirements, refer to the AWS Resource Center and search for the kernel ID.
        """
        return pulumi.get(self, "ramdisk_id")

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence['outputs.SpotFleetGroupIdentifier']]:
        """
        The security groups.

        If you specify a network interface, you must specify any security groups as part of the network interface instead of using this parameter.
        """
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter(name="spotPrice")
    def spot_price(self) -> Optional[_builtins.str]:
        """
        The maximum price per unit hour that you are willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.

        > If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.
        """
        return pulumi.get(self, "spot_price")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        The IDs of the subnets in which to launch the instances. To specify multiple subnets, separate them using commas; for example, "subnet-1234abcdeexample1, subnet-0987cdef6example2".

        If you specify a network interface, you must specify any subnets as part of the network interface instead of using this parameter.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="tagSpecifications")
    def tag_specifications(self) -> Optional[Sequence['outputs.SpotFleetTagSpecification']]:
        """
        The tags to apply during creation.
        """
        return pulumi.get(self, "tag_specifications")

    @_builtins.property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[_builtins.str]:
        """
        The base64-encoded user data that instances use when starting up. User data is limited to 16 KB.
        """
        return pulumi.get(self, "user_data")

    @_builtins.property
    @pulumi.getter(name="weightedCapacity")
    def weighted_capacity(self) -> Optional[_builtins.float]:
        """
        The number of units provided by the specified instance type. These are the same units that you chose to set the target capacity in terms of instances, or a performance characteristic such as vCPUs, memory, or I/O.

        If the target capacity divided by this value is not a whole number, Amazon EC2 rounds the number of instances to the next whole number. If this value is not specified, the default is 1.

        > When specifying weights, the price used in the `lowestPrice` and `priceCapacityOptimized` allocation strategies is per *unit* hour (where the instance price is divided by the specified weight). However, if all the specified weights are above the requested `TargetCapacity` , resulting in only 1 instance being launched, the price used is per *instance* hour.
        """
        return pulumi.get(self, "weighted_capacity")


@pulumi.output_type
class SpotFleetLaunchTemplateConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTemplateSpecification":
            suggest = "launch_template_specification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetLaunchTemplateConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetLaunchTemplateConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetLaunchTemplateConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 launch_template_specification: Optional['outputs.SpotFleetFleetLaunchTemplateSpecification'] = None,
                 overrides: Optional[Sequence['outputs.SpotFleetLaunchTemplateOverrides']] = None):
        """
        :param 'SpotFleetFleetLaunchTemplateSpecification' launch_template_specification: The launch template to use. Make sure that the launch template does not contain the `NetworkInterfaceId` parameter because you can't specify a network interface ID in a Spot Fleet.
        :param Sequence['SpotFleetLaunchTemplateOverrides'] overrides: Any parameters that you specify override the same parameters in the launch template.
        """
        if launch_template_specification is not None:
            pulumi.set(__self__, "launch_template_specification", launch_template_specification)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)

    @_builtins.property
    @pulumi.getter(name="launchTemplateSpecification")
    def launch_template_specification(self) -> Optional['outputs.SpotFleetFleetLaunchTemplateSpecification']:
        """
        The launch template to use. Make sure that the launch template does not contain the `NetworkInterfaceId` parameter because you can't specify a network interface ID in a Spot Fleet.
        """
        return pulumi.get(self, "launch_template_specification")

    @_builtins.property
    @pulumi.getter
    def overrides(self) -> Optional[Sequence['outputs.SpotFleetLaunchTemplateOverrides']]:
        """
        Any parameters that you specify override the same parameters in the launch template.
        """
        return pulumi.get(self, "overrides")


@pulumi.output_type
class SpotFleetLaunchTemplateOverrides(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "instanceRequirements":
            suggest = "instance_requirements"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "spotPrice":
            suggest = "spot_price"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "weightedCapacity":
            suggest = "weighted_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetLaunchTemplateOverrides. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetLaunchTemplateOverrides.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetLaunchTemplateOverrides.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone: Optional[_builtins.str] = None,
                 instance_requirements: Optional['outputs.SpotFleetInstanceRequirementsRequest'] = None,
                 instance_type: Optional[_builtins.str] = None,
                 priority: Optional[_builtins.float] = None,
                 spot_price: Optional[_builtins.str] = None,
                 subnet_id: Optional[_builtins.str] = None,
                 weighted_capacity: Optional[_builtins.float] = None):
        """
        :param _builtins.str availability_zone: The Availability Zone in which to launch the instances.
        :param 'SpotFleetInstanceRequirementsRequest' instance_requirements: The instance requirements. When you specify instance requirements, Amazon EC2 will identify instance types with the provided requirements, and then use your On-Demand and Spot allocation strategies to launch instances from these instance types, in the same way as when you specify a list of instance types.
               
               > If you specify `InstanceRequirements` , you can't specify `InstanceType` .
        :param _builtins.str instance_type: The instance type.
        :param _builtins.float priority: The priority for the launch template override. The highest priority is launched first.
               
               If `OnDemandAllocationStrategy` is set to `prioritized` , Spot Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity.
               
               If the Spot `AllocationStrategy` is set to `capacityOptimizedPrioritized` , Spot Fleet uses priority on a best-effort basis to determine which launch template override to use in fulfilling Spot capacity, but optimizes for capacity first.
               
               Valid values are whole numbers starting at `0` . The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority. You can set the same priority for different launch template overrides.
        :param _builtins.str spot_price: The maximum price per unit hour that you are willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.
               
               > If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.
        :param _builtins.str subnet_id: The ID of the subnet in which to launch the instances.
        :param _builtins.float weighted_capacity: The number of units provided by the specified instance type. These are the same units that you chose to set the target capacity in terms of instances, or a performance characteristic such as vCPUs, memory, or I/O.
               
               If the target capacity divided by this value is not a whole number, Amazon EC2 rounds the number of instances to the next whole number. If this value is not specified, the default is 1.
               
               > When specifying weights, the price used in the `lowestPrice` and `priceCapacityOptimized` allocation strategies is per *unit* hour (where the instance price is divided by the specified weight). However, if all the specified weights are above the requested `TargetCapacity` , resulting in only 1 instance being launched, the price used is per *instance* hour.
        """
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if instance_requirements is not None:
            pulumi.set(__self__, "instance_requirements", instance_requirements)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if spot_price is not None:
            pulumi.set(__self__, "spot_price", spot_price)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if weighted_capacity is not None:
            pulumi.set(__self__, "weighted_capacity", weighted_capacity)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[_builtins.str]:
        """
        The Availability Zone in which to launch the instances.
        """
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter(name="instanceRequirements")
    def instance_requirements(self) -> Optional['outputs.SpotFleetInstanceRequirementsRequest']:
        """
        The instance requirements. When you specify instance requirements, Amazon EC2 will identify instance types with the provided requirements, and then use your On-Demand and Spot allocation strategies to launch instances from these instance types, in the same way as when you specify a list of instance types.

        > If you specify `InstanceRequirements` , you can't specify `InstanceType` .
        """
        return pulumi.get(self, "instance_requirements")

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[_builtins.str]:
        """
        The instance type.
        """
        return pulumi.get(self, "instance_type")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.float]:
        """
        The priority for the launch template override. The highest priority is launched first.

        If `OnDemandAllocationStrategy` is set to `prioritized` , Spot Fleet uses priority to determine which launch template override to use first in fulfilling On-Demand capacity.

        If the Spot `AllocationStrategy` is set to `capacityOptimizedPrioritized` , Spot Fleet uses priority on a best-effort basis to determine which launch template override to use in fulfilling Spot capacity, but optimizes for capacity first.

        Valid values are whole numbers starting at `0` . The lower the number, the higher the priority. If no number is set, the launch template override has the lowest priority. You can set the same priority for different launch template overrides.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="spotPrice")
    def spot_price(self) -> Optional[_builtins.str]:
        """
        The maximum price per unit hour that you are willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.

        > If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.
        """
        return pulumi.get(self, "spot_price")

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[_builtins.str]:
        """
        The ID of the subnet in which to launch the instances.
        """
        return pulumi.get(self, "subnet_id")

    @_builtins.property
    @pulumi.getter(name="weightedCapacity")
    def weighted_capacity(self) -> Optional[_builtins.float]:
        """
        The number of units provided by the specified instance type. These are the same units that you chose to set the target capacity in terms of instances, or a performance characteristic such as vCPUs, memory, or I/O.

        If the target capacity divided by this value is not a whole number, Amazon EC2 rounds the number of instances to the next whole number. If this value is not specified, the default is 1.

        > When specifying weights, the price used in the `lowestPrice` and `priceCapacityOptimized` allocation strategies is per *unit* hour (where the instance price is divided by the specified weight). However, if all the specified weights are above the requested `TargetCapacity` , resulting in only 1 instance being launched, the price used is per *instance* hour.
        """
        return pulumi.get(self, "weighted_capacity")


@pulumi.output_type
class SpotFleetLoadBalancersConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "classicLoadBalancersConfig":
            suggest = "classic_load_balancers_config"
        elif key == "targetGroupsConfig":
            suggest = "target_groups_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetLoadBalancersConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetLoadBalancersConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetLoadBalancersConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 classic_load_balancers_config: Optional['outputs.SpotFleetClassicLoadBalancersConfig'] = None,
                 target_groups_config: Optional['outputs.SpotFleetTargetGroupsConfig'] = None):
        """
        :param 'SpotFleetClassicLoadBalancersConfig' classic_load_balancers_config: The Classic Load Balancers.
        :param 'SpotFleetTargetGroupsConfig' target_groups_config: The target groups.
        """
        if classic_load_balancers_config is not None:
            pulumi.set(__self__, "classic_load_balancers_config", classic_load_balancers_config)
        if target_groups_config is not None:
            pulumi.set(__self__, "target_groups_config", target_groups_config)

    @_builtins.property
    @pulumi.getter(name="classicLoadBalancersConfig")
    def classic_load_balancers_config(self) -> Optional['outputs.SpotFleetClassicLoadBalancersConfig']:
        """
        The Classic Load Balancers.
        """
        return pulumi.get(self, "classic_load_balancers_config")

    @_builtins.property
    @pulumi.getter(name="targetGroupsConfig")
    def target_groups_config(self) -> Optional['outputs.SpotFleetTargetGroupsConfig']:
        """
        The target groups.
        """
        return pulumi.get(self, "target_groups_config")


@pulumi.output_type
class SpotFleetMemoryGiBPerVCpuRequest(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.float] = None,
                 min: Optional[_builtins.float] = None):
        """
        :param _builtins.float max: The maximum amount of memory per vCPU, in GiB. To specify no maximum limit, omit this parameter.
        :param _builtins.float min: The minimum amount of memory per vCPU, in GiB. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.float]:
        """
        The maximum amount of memory per vCPU, in GiB. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.float]:
        """
        The minimum amount of memory per vCPU, in GiB. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetMemoryMiBRequest(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        """
        :param _builtins.int max: The maximum amount of memory, in MiB. To specify no maximum limit, omit this parameter.
        :param _builtins.int min: The minimum amount of memory, in MiB. To specify no minimum limit, specify `0` .
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        """
        The maximum amount of memory, in MiB. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        """
        The minimum amount of memory, in MiB. To specify no minimum limit, specify `0` .
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetMonitoring(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Enables monitoring for the instance.
               
               Default: `false`
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enables monitoring for the instance.

        Default: `false`
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class SpotFleetNetworkBandwidthGbpsRequest(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.float] = None,
                 min: Optional[_builtins.float] = None):
        """
        :param _builtins.float max: The maximum amount of network bandwidth, in Gbps. To specify no maximum limit, omit this parameter.
        :param _builtins.float min: The minimum amount of network bandwidth, in Gbps. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.float]:
        """
        The maximum amount of network bandwidth, in Gbps. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.float]:
        """
        The minimum amount of network bandwidth, in Gbps. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetNetworkInterfaceCountRequest(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        """
        :param _builtins.int max: The maximum number of network interfaces. To specify no maximum limit, omit this parameter.
        :param _builtins.int min: The minimum number of network interfaces. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        """
        The maximum number of network interfaces. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        """
        The minimum number of network interfaces. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetPerformanceFactorReferenceRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceFamily":
            suggest = "instance_family"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetPerformanceFactorReferenceRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetPerformanceFactorReferenceRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetPerformanceFactorReferenceRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_family: Optional[_builtins.str] = None):
        """
        :param _builtins.str instance_family: The instance family to use as a baseline reference.
               
               > Ensure that you specify the correct value for the instance family. The instance family is everything before the period ( `.` ) in the instance type name. For example, in the instance type `c6i.large` , the instance family is `c6i` , not `c6` . For more information, see [Amazon EC2 instance type naming conventions](https://docs.aws.amazon.com/ec2/latest/instancetypes/instance-type-names.html) in *Amazon EC2 Instance Types* . 
               
               The following instance families are *not supported* for performance protection:
               
               - `c1`
               - `g3` | `g3s`
               - `hpc7g`
               - `m1` | `m2`
               - `mac1` | `mac2` | `mac2-m1ultra` | `mac2-m2` | `mac2-m2pro`
               - `p3dn` | `p4d` | `p5`
               - `t1`
               - `u-12tb1` | `u-18tb1` | `u-24tb1` | `u-3tb1` | `u-6tb1` | `u-9tb1` | `u7i-12tb` | `u7in-16tb` | `u7in-24tb` | `u7in-32tb`
               
               If you enable performance protection by specifying a supported instance family, the returned instance types will exclude the above unsupported instance families.
               
               If you specify an unsupported instance family as a value for baseline performance, the API returns an empty response for [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) and an exception for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet.html) , [RequestSpotFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotFleet.html) , [ModifyFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyFleet.html) , and [ModifySpotFleetRequest](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifySpotFleetRequest.html) .
        """
        if instance_family is not None:
            pulumi.set(__self__, "instance_family", instance_family)

    @_builtins.property
    @pulumi.getter(name="instanceFamily")
    def instance_family(self) -> Optional[_builtins.str]:
        """
        The instance family to use as a baseline reference.

        > Ensure that you specify the correct value for the instance family. The instance family is everything before the period ( `.` ) in the instance type name. For example, in the instance type `c6i.large` , the instance family is `c6i` , not `c6` . For more information, see [Amazon EC2 instance type naming conventions](https://docs.aws.amazon.com/ec2/latest/instancetypes/instance-type-names.html) in *Amazon EC2 Instance Types* . 

        The following instance families are *not supported* for performance protection:

        - `c1`
        - `g3` | `g3s`
        - `hpc7g`
        - `m1` | `m2`
        - `mac1` | `mac2` | `mac2-m1ultra` | `mac2-m2` | `mac2-m2pro`
        - `p3dn` | `p4d` | `p5`
        - `t1`
        - `u-12tb1` | `u-18tb1` | `u-24tb1` | `u-3tb1` | `u-6tb1` | `u-9tb1` | `u7i-12tb` | `u7in-16tb` | `u7in-24tb` | `u7in-32tb`

        If you enable performance protection by specifying a supported instance family, the returned instance types will exclude the above unsupported instance families.

        If you specify an unsupported instance family as a value for baseline performance, the API returns an empty response for [GetInstanceTypesFromInstanceRequirements](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_GetInstanceTypesFromInstanceRequirements.html) and an exception for [CreateFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateFleet.html) , [RequestSpotFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_RequestSpotFleet.html) , [ModifyFleet](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyFleet.html) , and [ModifySpotFleetRequest](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifySpotFleetRequest.html) .
        """
        return pulumi.get(self, "instance_family")


@pulumi.output_type
class SpotFleetPrivateIpAddressSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIpAddress":
            suggest = "private_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetPrivateIpAddressSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetPrivateIpAddressSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetPrivateIpAddressSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_ip_address: _builtins.str,
                 primary: Optional[_builtins.bool] = None):
        """
        :param _builtins.str private_ip_address: The private IPv4 address.
        :param _builtins.bool primary: Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.
        """
        pulumi.set(__self__, "private_ip_address", private_ip_address)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)

    @_builtins.property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> _builtins.str:
        """
        The private IPv4 address.
        """
        return pulumi.get(self, "private_ip_address")

    @_builtins.property
    @pulumi.getter
    def primary(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.
        """
        return pulumi.get(self, "primary")


@pulumi.output_type
class SpotFleetRequestConfigData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iamFleetRole":
            suggest = "iam_fleet_role"
        elif key == "targetCapacity":
            suggest = "target_capacity"
        elif key == "allocationStrategy":
            suggest = "allocation_strategy"
        elif key == "excessCapacityTerminationPolicy":
            suggest = "excess_capacity_termination_policy"
        elif key == "instanceInterruptionBehavior":
            suggest = "instance_interruption_behavior"
        elif key == "instancePoolsToUseCount":
            suggest = "instance_pools_to_use_count"
        elif key == "launchSpecifications":
            suggest = "launch_specifications"
        elif key == "launchTemplateConfigs":
            suggest = "launch_template_configs"
        elif key == "loadBalancersConfig":
            suggest = "load_balancers_config"
        elif key == "onDemandAllocationStrategy":
            suggest = "on_demand_allocation_strategy"
        elif key == "onDemandMaxTotalPrice":
            suggest = "on_demand_max_total_price"
        elif key == "onDemandTargetCapacity":
            suggest = "on_demand_target_capacity"
        elif key == "replaceUnhealthyInstances":
            suggest = "replace_unhealthy_instances"
        elif key == "spotMaintenanceStrategies":
            suggest = "spot_maintenance_strategies"
        elif key == "spotMaxTotalPrice":
            suggest = "spot_max_total_price"
        elif key == "spotPrice":
            suggest = "spot_price"
        elif key == "tagSpecifications":
            suggest = "tag_specifications"
        elif key == "targetCapacityUnitType":
            suggest = "target_capacity_unit_type"
        elif key == "terminateInstancesWithExpiration":
            suggest = "terminate_instances_with_expiration"
        elif key == "validFrom":
            suggest = "valid_from"
        elif key == "validUntil":
            suggest = "valid_until"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetRequestConfigData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetRequestConfigData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetRequestConfigData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iam_fleet_role: _builtins.str,
                 target_capacity: _builtins.int,
                 allocation_strategy: Optional['SpotFleetRequestConfigDataAllocationStrategy'] = None,
                 context: Optional[_builtins.str] = None,
                 excess_capacity_termination_policy: Optional['SpotFleetRequestConfigDataExcessCapacityTerminationPolicy'] = None,
                 instance_interruption_behavior: Optional['SpotFleetRequestConfigDataInstanceInterruptionBehavior'] = None,
                 instance_pools_to_use_count: Optional[_builtins.int] = None,
                 launch_specifications: Optional[Sequence['outputs.SpotFleetLaunchSpecification']] = None,
                 launch_template_configs: Optional[Sequence['outputs.SpotFleetLaunchTemplateConfig']] = None,
                 load_balancers_config: Optional['outputs.SpotFleetLoadBalancersConfig'] = None,
                 on_demand_allocation_strategy: Optional[_builtins.str] = None,
                 on_demand_max_total_price: Optional[_builtins.str] = None,
                 on_demand_target_capacity: Optional[_builtins.int] = None,
                 replace_unhealthy_instances: Optional[_builtins.bool] = None,
                 spot_maintenance_strategies: Optional['outputs.SpotFleetSpotMaintenanceStrategies'] = None,
                 spot_max_total_price: Optional[_builtins.str] = None,
                 spot_price: Optional[_builtins.str] = None,
                 tag_specifications: Optional[Sequence['outputs.SpotFleetTagSpecification']] = None,
                 target_capacity_unit_type: Optional['SpotFleetRequestConfigDataTargetCapacityUnitType'] = None,
                 terminate_instances_with_expiration: Optional[_builtins.bool] = None,
                 type: Optional['SpotFleetRequestConfigDataType'] = None,
                 valid_from: Optional[_builtins.str] = None,
                 valid_until: Optional[_builtins.str] = None):
        """
        :param _builtins.str iam_fleet_role: The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role that grants the Spot Fleet the permission to request, launch, terminate, and tag instances on your behalf. For more information, see [Spot Fleet Prerequisites](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-requests.html#spot-fleet-prerequisites) in the *Amazon EC2 User Guide* . Spot Fleet can terminate Spot Instances on your behalf when you cancel its Spot Fleet request or when the Spot Fleet request expires, if you set `TerminateInstancesWithExpiration` .
        :param _builtins.int target_capacity: The number of units to request for the Spot Fleet. You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is `maintain` , you can specify a target capacity of 0 and add capacity later.
        :param 'SpotFleetRequestConfigDataAllocationStrategy' allocation_strategy: The strategy that determines how to allocate the target Spot Instance capacity across the Spot Instance pools specified by the Spot Fleet launch configuration. For more information, see [Allocation strategies for Spot Instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-allocation-strategy.html) in the *Amazon EC2 User Guide* .
               
               - **priceCapacityOptimized (recommended)** - Spot Fleet identifies the pools with the highest capacity availability for the number of instances that are launching. This means that we will request Spot Instances from the pools that we believe have the lowest chance of interruption in the near term. Spot Fleet then requests Spot Instances from the lowest priced of these pools.
               - **capacityOptimized** - Spot Fleet identifies the pools with the highest capacity availability for the number of instances that are launching. This means that we will request Spot Instances from the pools that we believe have the lowest chance of interruption in the near term. To give certain instance types a higher chance of launching first, use `capacityOptimizedPrioritized` . Set a priority for each instance type by using the `Priority` parameter for `LaunchTemplateOverrides` . You can assign the same priority to different `LaunchTemplateOverrides` . EC2 implements the priorities on a best-effort basis, but optimizes for capacity first. `capacityOptimizedPrioritized` is supported only if your Spot Fleet uses a launch template. Note that if the `OnDemandAllocationStrategy` is set to `prioritized` , the same priority is applied when fulfilling On-Demand capacity.
               - **diversified** - Spot Fleet requests instances from all of the Spot Instance pools that you specify.
               - **lowestPrice (not recommended)** - > We don't recommend the `lowestPrice` allocation strategy because it has the highest risk of interruption for your Spot Instances. 
               
               Spot Fleet requests instances from the lowest priced Spot Instance pool that has available capacity. If the lowest priced pool doesn't have available capacity, the Spot Instances come from the next lowest priced pool that has available capacity. If a pool runs out of capacity before fulfilling your desired capacity, Spot Fleet will continue to fulfill your request by drawing from the next lowest priced pool. To ensure that your desired capacity is met, you might receive Spot Instances from several pools. Because this strategy only considers instance price and not capacity availability, it might lead to high interruption rates.
               
               Default: `lowestPrice`
        :param _builtins.str context: Reserved.
        :param 'SpotFleetRequestConfigDataExcessCapacityTerminationPolicy' excess_capacity_termination_policy: Indicates whether running Spot Instances should be terminated if you decrease the target capacity of the Spot Fleet request below the current size of the Spot Fleet.
               
               Supported only for fleets of type `maintain` .
        :param 'SpotFleetRequestConfigDataInstanceInterruptionBehavior' instance_interruption_behavior: The behavior when a Spot Instance is interrupted. The default is `terminate` .
        :param _builtins.int instance_pools_to_use_count: The number of Spot pools across which to allocate your target Spot capacity. Valid only when Spot *AllocationStrategy* is set to `lowest-price` . Spot Fleet selects the cheapest Spot pools and evenly allocates your target Spot capacity across the number of Spot pools that you specify.
               
               Note that Spot Fleet attempts to draw Spot Instances from the number of pools that you specify on a best effort basis. If a pool runs out of Spot capacity before fulfilling your target capacity, Spot Fleet will continue to fulfill your request by drawing from the next cheapest pool. To ensure that your target capacity is met, you might receive Spot Instances from more than the number of pools that you specified. Similarly, if most of the pools have no Spot capacity, you might receive your full target capacity from fewer than the number of pools that you specified.
        :param Sequence['SpotFleetLaunchSpecification'] launch_specifications: The launch specifications for the Spot Fleet request. If you specify `LaunchSpecifications` , you can't specify `LaunchTemplateConfigs` .
        :param Sequence['SpotFleetLaunchTemplateConfig'] launch_template_configs: The launch template and overrides. If you specify `LaunchTemplateConfigs` , you can't specify `LaunchSpecifications` .
        :param 'SpotFleetLoadBalancersConfig' load_balancers_config: One or more Classic Load Balancers and target groups to attach to the Spot Fleet request. Spot Fleet registers the running Spot Instances with the specified Classic Load Balancers and target groups.
               
               With Network Load Balancers, Spot Fleet cannot register instances that have the following instance types: C1, CC1, CC2, CG1, CG2, CR1, CS1, G1, G2, HI1, HS1, M1, M2, M3, and T1.
        :param _builtins.str on_demand_allocation_strategy: The order of the launch template overrides to use in fulfilling On-Demand capacity. If you specify `lowestPrice` , Spot Fleet uses price to determine the order, launching the lowest price first. If you specify `prioritized` , Spot Fleet uses the priority that you assign to each Spot Fleet launch template override, launching the highest priority first. If you do not specify a value, Spot Fleet defaults to `lowestPrice` .
        :param _builtins.str on_demand_max_total_price: The maximum amount per hour for On-Demand Instances that you're willing to pay. You can use the `onDemandMaxTotalPrice` parameter, the `spotMaxTotalPrice` parameter, or both parameters to ensure that your fleet cost does not exceed your budget. If you set a maximum price per hour for the On-Demand Instances and Spot Instances in your request, Spot Fleet will launch instances until it reaches the maximum amount you're willing to pay. When the maximum amount you're willing to pay is reached, the fleet stops launching instances even if it hasnt met the target capacity.
               
               > If your fleet includes T instances that are configured as `unlimited` , and if their average CPU usage exceeds the baseline utilization, you will incur a charge for surplus credits. The `onDemandMaxTotalPrice` does not account for surplus credits, and, if you use surplus credits, your final cost might be higher than what you specified for `onDemandMaxTotalPrice` . For more information, see [Surplus credits can incur charges](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-unlimited-mode-concepts.html#unlimited-mode-surplus-credits) in the *Amazon EC2 User Guide* .
        :param _builtins.int on_demand_target_capacity: The number of On-Demand units to request. You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is `maintain` , you can specify a target capacity of 0 and add capacity later.
        :param _builtins.bool replace_unhealthy_instances: Indicates whether Spot Fleet should replace unhealthy instances.
        :param 'SpotFleetSpotMaintenanceStrategies' spot_maintenance_strategies: The strategies for managing your Spot Instances that are at an elevated risk of being interrupted.
        :param _builtins.str spot_max_total_price: The maximum amount per hour for Spot Instances that you're willing to pay. You can use the `spotMaxTotalPrice` parameter, the `onDemandMaxTotalPrice` parameter, or both parameters to ensure that your fleet cost does not exceed your budget. If you set a maximum price per hour for the On-Demand Instances and Spot Instances in your request, Spot Fleet will launch instances until it reaches the maximum amount you're willing to pay. When the maximum amount you're willing to pay is reached, the fleet stops launching instances even if it hasnt met the target capacity.
               
               > If your fleet includes T instances that are configured as `unlimited` , and if their average CPU usage exceeds the baseline utilization, you will incur a charge for surplus credits. The `spotMaxTotalPrice` does not account for surplus credits, and, if you use surplus credits, your final cost might be higher than what you specified for `spotMaxTotalPrice` . For more information, see [Surplus credits can incur charges](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-unlimited-mode-concepts.html#unlimited-mode-surplus-credits) in the *Amazon EC2 User Guide* .
        :param _builtins.str spot_price: The maximum price per unit hour that you are willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.
               
               > If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.
        :param Sequence['SpotFleetTagSpecification'] tag_specifications: The key-value pair for tagging the Spot Fleet request on creation. The value for `ResourceType` must be `spot-fleet-request` , otherwise the Spot Fleet request fails. To tag instances at launch, specify the tags in the [launch template](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#create-launch-template) (valid only if you use `LaunchTemplateConfigs` ) or in the `[SpotFleetTagSpecification](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SpotFleetTagSpecification.html)` (valid only if you use `LaunchSpecifications` ). For information about tagging after launch, see [Tag your resources](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#tag-resources) .
        :param 'SpotFleetRequestConfigDataTargetCapacityUnitType' target_capacity_unit_type: The unit for the target capacity. You can specify this parameter only when using attribute-based instance type selection.
               
               Default: `units` (the number of instances)
        :param _builtins.bool terminate_instances_with_expiration: Indicates whether running Spot Instances are terminated when the Spot Fleet request expires.
        :param 'SpotFleetRequestConfigDataType' type: The type of request. Indicates whether the Spot Fleet only requests the target capacity or also attempts to maintain it. When this value is `request` , the Spot Fleet only places the required requests. It does not attempt to replenish Spot Instances if capacity is diminished, nor does it submit requests in alternative Spot pools if capacity is not available. When this value is `maintain` , the Spot Fleet maintains the target capacity. The Spot Fleet places the required requests to meet capacity and automatically replenishes any interrupted instances. Default: `maintain` . `instant` is listed but is not used by Spot Fleet.
        :param _builtins.str valid_from: The start date and time of the request, in UTC format ( *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z). By default, Amazon EC2 starts fulfilling the request immediately.
        :param _builtins.str valid_until: The end date and time of the request, in UTC format ( *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z). After the end date and time, no new Spot Instance requests are placed or able to fulfill the request. If no value is specified, the Spot Fleet request remains until you cancel it.
        """
        pulumi.set(__self__, "iam_fleet_role", iam_fleet_role)
        pulumi.set(__self__, "target_capacity", target_capacity)
        if allocation_strategy is not None:
            pulumi.set(__self__, "allocation_strategy", allocation_strategy)
        if context is not None:
            pulumi.set(__self__, "context", context)
        if excess_capacity_termination_policy is not None:
            pulumi.set(__self__, "excess_capacity_termination_policy", excess_capacity_termination_policy)
        if instance_interruption_behavior is not None:
            pulumi.set(__self__, "instance_interruption_behavior", instance_interruption_behavior)
        if instance_pools_to_use_count is not None:
            pulumi.set(__self__, "instance_pools_to_use_count", instance_pools_to_use_count)
        if launch_specifications is not None:
            pulumi.set(__self__, "launch_specifications", launch_specifications)
        if launch_template_configs is not None:
            pulumi.set(__self__, "launch_template_configs", launch_template_configs)
        if load_balancers_config is not None:
            pulumi.set(__self__, "load_balancers_config", load_balancers_config)
        if on_demand_allocation_strategy is not None:
            pulumi.set(__self__, "on_demand_allocation_strategy", on_demand_allocation_strategy)
        if on_demand_max_total_price is not None:
            pulumi.set(__self__, "on_demand_max_total_price", on_demand_max_total_price)
        if on_demand_target_capacity is not None:
            pulumi.set(__self__, "on_demand_target_capacity", on_demand_target_capacity)
        if replace_unhealthy_instances is not None:
            pulumi.set(__self__, "replace_unhealthy_instances", replace_unhealthy_instances)
        if spot_maintenance_strategies is not None:
            pulumi.set(__self__, "spot_maintenance_strategies", spot_maintenance_strategies)
        if spot_max_total_price is not None:
            pulumi.set(__self__, "spot_max_total_price", spot_max_total_price)
        if spot_price is not None:
            pulumi.set(__self__, "spot_price", spot_price)
        if tag_specifications is not None:
            pulumi.set(__self__, "tag_specifications", tag_specifications)
        if target_capacity_unit_type is not None:
            pulumi.set(__self__, "target_capacity_unit_type", target_capacity_unit_type)
        if terminate_instances_with_expiration is not None:
            pulumi.set(__self__, "terminate_instances_with_expiration", terminate_instances_with_expiration)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if valid_from is not None:
            pulumi.set(__self__, "valid_from", valid_from)
        if valid_until is not None:
            pulumi.set(__self__, "valid_until", valid_until)

    @_builtins.property
    @pulumi.getter(name="iamFleetRole")
    def iam_fleet_role(self) -> _builtins.str:
        """
        The Amazon Resource Name (ARN) of an AWS Identity and Access Management (IAM) role that grants the Spot Fleet the permission to request, launch, terminate, and tag instances on your behalf. For more information, see [Spot Fleet Prerequisites](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-requests.html#spot-fleet-prerequisites) in the *Amazon EC2 User Guide* . Spot Fleet can terminate Spot Instances on your behalf when you cancel its Spot Fleet request or when the Spot Fleet request expires, if you set `TerminateInstancesWithExpiration` .
        """
        return pulumi.get(self, "iam_fleet_role")

    @_builtins.property
    @pulumi.getter(name="targetCapacity")
    def target_capacity(self) -> _builtins.int:
        """
        The number of units to request for the Spot Fleet. You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is `maintain` , you can specify a target capacity of 0 and add capacity later.
        """
        return pulumi.get(self, "target_capacity")

    @_builtins.property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> Optional['SpotFleetRequestConfigDataAllocationStrategy']:
        """
        The strategy that determines how to allocate the target Spot Instance capacity across the Spot Instance pools specified by the Spot Fleet launch configuration. For more information, see [Allocation strategies for Spot Instances](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-allocation-strategy.html) in the *Amazon EC2 User Guide* .

        - **priceCapacityOptimized (recommended)** - Spot Fleet identifies the pools with the highest capacity availability for the number of instances that are launching. This means that we will request Spot Instances from the pools that we believe have the lowest chance of interruption in the near term. Spot Fleet then requests Spot Instances from the lowest priced of these pools.
        - **capacityOptimized** - Spot Fleet identifies the pools with the highest capacity availability for the number of instances that are launching. This means that we will request Spot Instances from the pools that we believe have the lowest chance of interruption in the near term. To give certain instance types a higher chance of launching first, use `capacityOptimizedPrioritized` . Set a priority for each instance type by using the `Priority` parameter for `LaunchTemplateOverrides` . You can assign the same priority to different `LaunchTemplateOverrides` . EC2 implements the priorities on a best-effort basis, but optimizes for capacity first. `capacityOptimizedPrioritized` is supported only if your Spot Fleet uses a launch template. Note that if the `OnDemandAllocationStrategy` is set to `prioritized` , the same priority is applied when fulfilling On-Demand capacity.
        - **diversified** - Spot Fleet requests instances from all of the Spot Instance pools that you specify.
        - **lowestPrice (not recommended)** - > We don't recommend the `lowestPrice` allocation strategy because it has the highest risk of interruption for your Spot Instances. 

        Spot Fleet requests instances from the lowest priced Spot Instance pool that has available capacity. If the lowest priced pool doesn't have available capacity, the Spot Instances come from the next lowest priced pool that has available capacity. If a pool runs out of capacity before fulfilling your desired capacity, Spot Fleet will continue to fulfill your request by drawing from the next lowest priced pool. To ensure that your desired capacity is met, you might receive Spot Instances from several pools. Because this strategy only considers instance price and not capacity availability, it might lead to high interruption rates.

        Default: `lowestPrice`
        """
        return pulumi.get(self, "allocation_strategy")

    @_builtins.property
    @pulumi.getter
    def context(self) -> Optional[_builtins.str]:
        """
        Reserved.
        """
        return pulumi.get(self, "context")

    @_builtins.property
    @pulumi.getter(name="excessCapacityTerminationPolicy")
    def excess_capacity_termination_policy(self) -> Optional['SpotFleetRequestConfigDataExcessCapacityTerminationPolicy']:
        """
        Indicates whether running Spot Instances should be terminated if you decrease the target capacity of the Spot Fleet request below the current size of the Spot Fleet.

        Supported only for fleets of type `maintain` .
        """
        return pulumi.get(self, "excess_capacity_termination_policy")

    @_builtins.property
    @pulumi.getter(name="instanceInterruptionBehavior")
    def instance_interruption_behavior(self) -> Optional['SpotFleetRequestConfigDataInstanceInterruptionBehavior']:
        """
        The behavior when a Spot Instance is interrupted. The default is `terminate` .
        """
        return pulumi.get(self, "instance_interruption_behavior")

    @_builtins.property
    @pulumi.getter(name="instancePoolsToUseCount")
    def instance_pools_to_use_count(self) -> Optional[_builtins.int]:
        """
        The number of Spot pools across which to allocate your target Spot capacity. Valid only when Spot *AllocationStrategy* is set to `lowest-price` . Spot Fleet selects the cheapest Spot pools and evenly allocates your target Spot capacity across the number of Spot pools that you specify.

        Note that Spot Fleet attempts to draw Spot Instances from the number of pools that you specify on a best effort basis. If a pool runs out of Spot capacity before fulfilling your target capacity, Spot Fleet will continue to fulfill your request by drawing from the next cheapest pool. To ensure that your target capacity is met, you might receive Spot Instances from more than the number of pools that you specified. Similarly, if most of the pools have no Spot capacity, you might receive your full target capacity from fewer than the number of pools that you specified.
        """
        return pulumi.get(self, "instance_pools_to_use_count")

    @_builtins.property
    @pulumi.getter(name="launchSpecifications")
    def launch_specifications(self) -> Optional[Sequence['outputs.SpotFleetLaunchSpecification']]:
        """
        The launch specifications for the Spot Fleet request. If you specify `LaunchSpecifications` , you can't specify `LaunchTemplateConfigs` .
        """
        return pulumi.get(self, "launch_specifications")

    @_builtins.property
    @pulumi.getter(name="launchTemplateConfigs")
    def launch_template_configs(self) -> Optional[Sequence['outputs.SpotFleetLaunchTemplateConfig']]:
        """
        The launch template and overrides. If you specify `LaunchTemplateConfigs` , you can't specify `LaunchSpecifications` .
        """
        return pulumi.get(self, "launch_template_configs")

    @_builtins.property
    @pulumi.getter(name="loadBalancersConfig")
    def load_balancers_config(self) -> Optional['outputs.SpotFleetLoadBalancersConfig']:
        """
        One or more Classic Load Balancers and target groups to attach to the Spot Fleet request. Spot Fleet registers the running Spot Instances with the specified Classic Load Balancers and target groups.

        With Network Load Balancers, Spot Fleet cannot register instances that have the following instance types: C1, CC1, CC2, CG1, CG2, CR1, CS1, G1, G2, HI1, HS1, M1, M2, M3, and T1.
        """
        return pulumi.get(self, "load_balancers_config")

    @_builtins.property
    @pulumi.getter(name="onDemandAllocationStrategy")
    def on_demand_allocation_strategy(self) -> Optional[_builtins.str]:
        """
        The order of the launch template overrides to use in fulfilling On-Demand capacity. If you specify `lowestPrice` , Spot Fleet uses price to determine the order, launching the lowest price first. If you specify `prioritized` , Spot Fleet uses the priority that you assign to each Spot Fleet launch template override, launching the highest priority first. If you do not specify a value, Spot Fleet defaults to `lowestPrice` .
        """
        return pulumi.get(self, "on_demand_allocation_strategy")

    @_builtins.property
    @pulumi.getter(name="onDemandMaxTotalPrice")
    def on_demand_max_total_price(self) -> Optional[_builtins.str]:
        """
        The maximum amount per hour for On-Demand Instances that you're willing to pay. You can use the `onDemandMaxTotalPrice` parameter, the `spotMaxTotalPrice` parameter, or both parameters to ensure that your fleet cost does not exceed your budget. If you set a maximum price per hour for the On-Demand Instances and Spot Instances in your request, Spot Fleet will launch instances until it reaches the maximum amount you're willing to pay. When the maximum amount you're willing to pay is reached, the fleet stops launching instances even if it hasnt met the target capacity.

        > If your fleet includes T instances that are configured as `unlimited` , and if their average CPU usage exceeds the baseline utilization, you will incur a charge for surplus credits. The `onDemandMaxTotalPrice` does not account for surplus credits, and, if you use surplus credits, your final cost might be higher than what you specified for `onDemandMaxTotalPrice` . For more information, see [Surplus credits can incur charges](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-unlimited-mode-concepts.html#unlimited-mode-surplus-credits) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "on_demand_max_total_price")

    @_builtins.property
    @pulumi.getter(name="onDemandTargetCapacity")
    def on_demand_target_capacity(self) -> Optional[_builtins.int]:
        """
        The number of On-Demand units to request. You can choose to set the target capacity in terms of instances or a performance characteristic that is important to your application workload, such as vCPUs, memory, or I/O. If the request type is `maintain` , you can specify a target capacity of 0 and add capacity later.
        """
        return pulumi.get(self, "on_demand_target_capacity")

    @_builtins.property
    @pulumi.getter(name="replaceUnhealthyInstances")
    def replace_unhealthy_instances(self) -> Optional[_builtins.bool]:
        """
        Indicates whether Spot Fleet should replace unhealthy instances.
        """
        return pulumi.get(self, "replace_unhealthy_instances")

    @_builtins.property
    @pulumi.getter(name="spotMaintenanceStrategies")
    def spot_maintenance_strategies(self) -> Optional['outputs.SpotFleetSpotMaintenanceStrategies']:
        """
        The strategies for managing your Spot Instances that are at an elevated risk of being interrupted.
        """
        return pulumi.get(self, "spot_maintenance_strategies")

    @_builtins.property
    @pulumi.getter(name="spotMaxTotalPrice")
    def spot_max_total_price(self) -> Optional[_builtins.str]:
        """
        The maximum amount per hour for Spot Instances that you're willing to pay. You can use the `spotMaxTotalPrice` parameter, the `onDemandMaxTotalPrice` parameter, or both parameters to ensure that your fleet cost does not exceed your budget. If you set a maximum price per hour for the On-Demand Instances and Spot Instances in your request, Spot Fleet will launch instances until it reaches the maximum amount you're willing to pay. When the maximum amount you're willing to pay is reached, the fleet stops launching instances even if it hasnt met the target capacity.

        > If your fleet includes T instances that are configured as `unlimited` , and if their average CPU usage exceeds the baseline utilization, you will incur a charge for surplus credits. The `spotMaxTotalPrice` does not account for surplus credits, and, if you use surplus credits, your final cost might be higher than what you specified for `spotMaxTotalPrice` . For more information, see [Surplus credits can incur charges](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/burstable-performance-instances-unlimited-mode-concepts.html#unlimited-mode-surplus-credits) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "spot_max_total_price")

    @_builtins.property
    @pulumi.getter(name="spotPrice")
    def spot_price(self) -> Optional[_builtins.str]:
        """
        The maximum price per unit hour that you are willing to pay for a Spot Instance. We do not recommend using this parameter because it can lead to increased interruptions. If you do not specify this parameter, you will pay the current Spot price.

        > If you specify a maximum price, your instances will be interrupted more frequently than if you do not specify this parameter.
        """
        return pulumi.get(self, "spot_price")

    @_builtins.property
    @pulumi.getter(name="tagSpecifications")
    def tag_specifications(self) -> Optional[Sequence['outputs.SpotFleetTagSpecification']]:
        """
        The key-value pair for tagging the Spot Fleet request on creation. The value for `ResourceType` must be `spot-fleet-request` , otherwise the Spot Fleet request fails. To tag instances at launch, specify the tags in the [launch template](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html#create-launch-template) (valid only if you use `LaunchTemplateConfigs` ) or in the `[SpotFleetTagSpecification](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SpotFleetTagSpecification.html)` (valid only if you use `LaunchSpecifications` ). For information about tagging after launch, see [Tag your resources](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#tag-resources) .
        """
        return pulumi.get(self, "tag_specifications")

    @_builtins.property
    @pulumi.getter(name="targetCapacityUnitType")
    def target_capacity_unit_type(self) -> Optional['SpotFleetRequestConfigDataTargetCapacityUnitType']:
        """
        The unit for the target capacity. You can specify this parameter only when using attribute-based instance type selection.

        Default: `units` (the number of instances)
        """
        return pulumi.get(self, "target_capacity_unit_type")

    @_builtins.property
    @pulumi.getter(name="terminateInstancesWithExpiration")
    def terminate_instances_with_expiration(self) -> Optional[_builtins.bool]:
        """
        Indicates whether running Spot Instances are terminated when the Spot Fleet request expires.
        """
        return pulumi.get(self, "terminate_instances_with_expiration")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional['SpotFleetRequestConfigDataType']:
        """
        The type of request. Indicates whether the Spot Fleet only requests the target capacity or also attempts to maintain it. When this value is `request` , the Spot Fleet only places the required requests. It does not attempt to replenish Spot Instances if capacity is diminished, nor does it submit requests in alternative Spot pools if capacity is not available. When this value is `maintain` , the Spot Fleet maintains the target capacity. The Spot Fleet places the required requests to meet capacity and automatically replenishes any interrupted instances. Default: `maintain` . `instant` is listed but is not used by Spot Fleet.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="validFrom")
    def valid_from(self) -> Optional[_builtins.str]:
        """
        The start date and time of the request, in UTC format ( *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z). By default, Amazon EC2 starts fulfilling the request immediately.
        """
        return pulumi.get(self, "valid_from")

    @_builtins.property
    @pulumi.getter(name="validUntil")
    def valid_until(self) -> Optional[_builtins.str]:
        """
        The end date and time of the request, in UTC format ( *YYYY* - *MM* - *DD* T *HH* : *MM* : *SS* Z). After the end date and time, no new Spot Instance requests are placed or able to fulfill the request. If no value is specified, the Spot Fleet request remains until you cancel it.
        """
        return pulumi.get(self, "valid_until")


@pulumi.output_type
class SpotFleetSpotCapacityRebalance(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replacementStrategy":
            suggest = "replacement_strategy"
        elif key == "terminationDelay":
            suggest = "termination_delay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetSpotCapacityRebalance. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetSpotCapacityRebalance.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetSpotCapacityRebalance.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 replacement_strategy: Optional['SpotFleetSpotCapacityRebalanceReplacementStrategy'] = None,
                 termination_delay: Optional[_builtins.int] = None):
        """
        :param 'SpotFleetSpotCapacityRebalanceReplacementStrategy' replacement_strategy: The replacement strategy to use. Only available for fleets of type `maintain` .
               
               `launch` - Spot Fleet launches a new replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet. Spot Fleet does not terminate the instances that receive a rebalance notification. You can terminate the old instances, or you can leave them running. You are charged for all instances while they are running.
               
               `launch-before-terminate` - Spot Fleet launches a new replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet, and then, after a delay that you specify (in `TerminationDelay` ), terminates the instances that received a rebalance notification.
        :param _builtins.int termination_delay: The amount of time (in seconds) that Amazon EC2 waits before terminating the old Spot Instance after launching a new replacement Spot Instance.
               
               Required when `ReplacementStrategy` is set to `launch-before-terminate` .
               
               Not valid when `ReplacementStrategy` is set to `launch` .
               
               Valid values: Minimum value of `120` seconds. Maximum value of `7200` seconds.
        """
        if replacement_strategy is not None:
            pulumi.set(__self__, "replacement_strategy", replacement_strategy)
        if termination_delay is not None:
            pulumi.set(__self__, "termination_delay", termination_delay)

    @_builtins.property
    @pulumi.getter(name="replacementStrategy")
    def replacement_strategy(self) -> Optional['SpotFleetSpotCapacityRebalanceReplacementStrategy']:
        """
        The replacement strategy to use. Only available for fleets of type `maintain` .

        `launch` - Spot Fleet launches a new replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet. Spot Fleet does not terminate the instances that receive a rebalance notification. You can terminate the old instances, or you can leave them running. You are charged for all instances while they are running.

        `launch-before-terminate` - Spot Fleet launches a new replacement Spot Instance when a rebalance notification is emitted for an existing Spot Instance in the fleet, and then, after a delay that you specify (in `TerminationDelay` ), terminates the instances that received a rebalance notification.
        """
        return pulumi.get(self, "replacement_strategy")

    @_builtins.property
    @pulumi.getter(name="terminationDelay")
    def termination_delay(self) -> Optional[_builtins.int]:
        """
        The amount of time (in seconds) that Amazon EC2 waits before terminating the old Spot Instance after launching a new replacement Spot Instance.

        Required when `ReplacementStrategy` is set to `launch-before-terminate` .

        Not valid when `ReplacementStrategy` is set to `launch` .

        Valid values: Minimum value of `120` seconds. Maximum value of `7200` seconds.
        """
        return pulumi.get(self, "termination_delay")


@pulumi.output_type
class SpotFleetSpotMaintenanceStrategies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityRebalance":
            suggest = "capacity_rebalance"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetSpotMaintenanceStrategies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetSpotMaintenanceStrategies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetSpotMaintenanceStrategies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_rebalance: Optional['outputs.SpotFleetSpotCapacityRebalance'] = None):
        """
        :param 'SpotFleetSpotCapacityRebalance' capacity_rebalance: The Spot Instance replacement strategy to use when Amazon EC2 emits a signal that your Spot Instance is at an elevated risk of being interrupted. For more information, see [Capacity rebalancing](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-capacity-rebalance.html) in the *Amazon EC2 User Guide* .
        """
        if capacity_rebalance is not None:
            pulumi.set(__self__, "capacity_rebalance", capacity_rebalance)

    @_builtins.property
    @pulumi.getter(name="capacityRebalance")
    def capacity_rebalance(self) -> Optional['outputs.SpotFleetSpotCapacityRebalance']:
        """
        The Spot Instance replacement strategy to use when Amazon EC2 emits a signal that your Spot Instance is at an elevated risk of being interrupted. For more information, see [Capacity rebalancing](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/spot-fleet-capacity-rebalance.html) in the *Amazon EC2 User Guide* .
        """
        return pulumi.get(self, "capacity_rebalance")


@pulumi.output_type
class SpotFleetSpotPlacement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "groupName":
            suggest = "group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetSpotPlacement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetSpotPlacement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetSpotPlacement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone: Optional[_builtins.str] = None,
                 group_name: Optional[_builtins.str] = None,
                 tenancy: Optional['SpotFleetSpotPlacementTenancy'] = None):
        """
        :param _builtins.str availability_zone: The Availability Zone.
               
               To specify multiple Availability Zones, separate them using commas; for example, "us-west-2a, us-west-2b".
        :param _builtins.str group_name: The name of the placement group.
        :param 'SpotFleetSpotPlacementTenancy' tenancy: The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of `dedicated` runs on single-tenant hardware. The `host` tenancy is not supported for Spot Instances.
        """
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if tenancy is not None:
            pulumi.set(__self__, "tenancy", tenancy)

    @_builtins.property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[_builtins.str]:
        """
        The Availability Zone.

        To specify multiple Availability Zones, separate them using commas; for example, "us-west-2a, us-west-2b".
        """
        return pulumi.get(self, "availability_zone")

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[_builtins.str]:
        """
        The name of the placement group.
        """
        return pulumi.get(self, "group_name")

    @_builtins.property
    @pulumi.getter
    def tenancy(self) -> Optional['SpotFleetSpotPlacementTenancy']:
        """
        The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of `dedicated` runs on single-tenant hardware. The `host` tenancy is not supported for Spot Instances.
        """
        return pulumi.get(self, "tenancy")


@pulumi.output_type
class SpotFleetTag(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: The tag key.
        :param _builtins.str value: The tag value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The tag key.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The tag value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SpotFleetTagSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetTagSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetTagSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetTagSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_type: Optional['SpotFleetTagSpecificationResourceType'] = None,
                 tags: Optional[Sequence['outputs.SpotFleetTag']] = None):
        """
        :param 'SpotFleetTagSpecificationResourceType' resource_type: The type of resource. Currently, the only resource type that is supported is `instance` . To tag the Spot Fleet request on creation, use the `TagSpecifications` parameter in `[SpotFleetRequestConfigData](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SpotFleetRequestConfigData.html)` .
        :param Sequence['SpotFleetTag'] tags: The tags.
        """
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional['SpotFleetTagSpecificationResourceType']:
        """
        The type of resource. Currently, the only resource type that is supported is `instance` . To tag the Spot Fleet request on creation, use the `TagSpecifications` parameter in `[SpotFleetRequestConfigData](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_SpotFleetRequestConfigData.html)` .
        """
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.SpotFleetTag']]:
        """
        The tags.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SpotFleetTargetGroup(dict):
    def __init__(__self__, *,
                 arn: _builtins.str):
        """
        :param _builtins.str arn: The Amazon Resource Name (ARN) of the target group.
        """
        pulumi.set(__self__, "arn", arn)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> _builtins.str:
        """
        The Amazon Resource Name (ARN) of the target group.
        """
        return pulumi.get(self, "arn")


@pulumi.output_type
class SpotFleetTargetGroupsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetGroups":
            suggest = "target_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetTargetGroupsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetTargetGroupsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetTargetGroupsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_groups: Sequence['outputs.SpotFleetTargetGroup']):
        """
        :param Sequence['SpotFleetTargetGroup'] target_groups: One or more target groups.
        """
        pulumi.set(__self__, "target_groups", target_groups)

    @_builtins.property
    @pulumi.getter(name="targetGroups")
    def target_groups(self) -> Sequence['outputs.SpotFleetTargetGroup']:
        """
        One or more target groups.
        """
        return pulumi.get(self, "target_groups")


@pulumi.output_type
class SpotFleetTotalLocalStorageGbRequest(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.float] = None,
                 min: Optional[_builtins.float] = None):
        """
        :param _builtins.float max: The maximum amount of total local storage, in GB. To specify no maximum limit, omit this parameter.
        :param _builtins.float min: The minimum amount of total local storage, in GB. To specify no minimum limit, omit this parameter.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.float]:
        """
        The maximum amount of total local storage, in GB. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.float]:
        """
        The minimum amount of total local storage, in GB. To specify no minimum limit, omit this parameter.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetVCpuCountRangeRequest(dict):
    def __init__(__self__, *,
                 max: Optional[_builtins.int] = None,
                 min: Optional[_builtins.int] = None):
        """
        :param _builtins.int max: The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
        :param _builtins.int min: The minimum number of vCPUs. To specify no minimum limit, specify `0` .
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[_builtins.int]:
        """
        The maximum number of vCPUs. To specify no maximum limit, omit this parameter.
        """
        return pulumi.get(self, "max")

    @_builtins.property
    @pulumi.getter
    def min(self) -> Optional[_builtins.int]:
        """
        The minimum number of vCPUs. To specify no minimum limit, specify `0` .
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class SseSpecificationProperties(dict):
    """
    The configuration options for customer provided KMS encryption.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customerManagedKeyEnabled":
            suggest = "customer_managed_key_enabled"
        elif key == "kmsKeyArn":
            suggest = "kms_key_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SseSpecificationProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SseSpecificationProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SseSpecificationProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 customer_managed_key_enabled: Optional[_builtins.bool] = None,
                 kms_key_arn: Optional[_builtins.str] = None):
        """
        The configuration options for customer provided KMS encryption.
        :param _builtins.bool customer_managed_key_enabled: Whether to encrypt the policy with the provided key or disable encryption
        :param _builtins.str kms_key_arn: KMS Key Arn used to encrypt the group policy
        """
        if customer_managed_key_enabled is not None:
            pulumi.set(__self__, "customer_managed_key_enabled", customer_managed_key_enabled)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @_builtins.property
    @pulumi.getter(name="customerManagedKeyEnabled")
    def customer_managed_key_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to encrypt the policy with the provided key or disable encryption
        """
        return pulumi.get(self, "customer_managed_key_enabled")

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[_builtins.str]:
        """
        KMS Key Arn used to encrypt the group policy
        """
        return pulumi.get(self, "kms_key_arn")


@pulumi.output_type
class TagSpecification(dict):
    """
    Specifies the tags to apply to resources that are created during instance launch.
     ``TagSpecification`` is a property type of [TagSpecifications](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-tagspecifications). [TagSpecifications](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-tagspecifications) is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TagSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TagSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TagSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_type: Optional[_builtins.str] = None,
                 tags: Optional[Sequence['outputs.LaunchTemplateTag']] = None):
        """
        Specifies the tags to apply to resources that are created during instance launch.
         ``TagSpecification`` is a property type of [TagSpecifications](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-tagspecifications). [TagSpecifications](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html#cfn-ec2-launchtemplate-launchtemplatedata-tagspecifications) is a property of [AWS::EC2::LaunchTemplate LaunchTemplateData](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-launchtemplate-launchtemplatedata.html).
        :param _builtins.str resource_type: The type of resource to tag. You can specify tags for the following resource types only: ``instance`` | ``volume`` | ``network-interface`` | ``spot-instances-request``. If the instance does not include the resource type that you specify, the instance launch fails. For example, not all instance types include a volume.
                To tag a resource after it has been created, see [CreateTags](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html).
        :param Sequence['LaunchTemplateTag'] tags: The tags to apply to the resource.
        """
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[_builtins.str]:
        """
        The type of resource to tag. You can specify tags for the following resource types only: ``instance`` | ``volume`` | ``network-interface`` | ``spot-instances-request``. If the instance does not include the resource type that you specify, the instance launch fails. For example, not all instance types include a volume.
         To tag a resource after it has been created, see [CreateTags](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_CreateTags.html).
        """
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.LaunchTemplateTag']]:
        """
        The tags to apply to the resource.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class TrafficMirrorFilterRuleTrafficMirrorPortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "toPort":
            suggest = "to_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TrafficMirrorFilterRuleTrafficMirrorPortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TrafficMirrorFilterRuleTrafficMirrorPortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TrafficMirrorFilterRuleTrafficMirrorPortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_port: _builtins.int,
                 to_port: _builtins.int):
        """
        :param _builtins.int from_port: The first port in the Traffic Mirror port range.
        :param _builtins.int to_port: The last port in the Traffic Mirror port range.
        """
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "to_port", to_port)

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> _builtins.int:
        """
        The first port in the Traffic Mirror port range.
        """
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> _builtins.int:
        """
        The last port in the Traffic Mirror port range.
        """
        return pulumi.get(self, "to_port")


@pulumi.output_type
class TransitGatewayConnectOptions(dict):
    def __init__(__self__, *,
                 protocol: Optional[_builtins.str] = None):
        """
        :param _builtins.str protocol: The tunnel protocol.
        """
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        The tunnel protocol.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class TransitGatewayConnectPeerConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insideCidrBlocks":
            suggest = "inside_cidr_blocks"
        elif key == "peerAddress":
            suggest = "peer_address"
        elif key == "bgpConfigurations":
            suggest = "bgp_configurations"
        elif key == "transitGatewayAddress":
            suggest = "transit_gateway_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TransitGatewayConnectPeerConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TransitGatewayConnectPeerConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TransitGatewayConnectPeerConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inside_cidr_blocks: Sequence[_builtins.str],
                 peer_address: _builtins.str,
                 bgp_configurations: Optional[Sequence['outputs.TransitGatewayConnectPeerTransitGatewayAttachmentBgpConfiguration']] = None,
                 protocol: Optional[_builtins.str] = None,
                 transit_gateway_address: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] inside_cidr_blocks: The range of interior BGP peer IP addresses.
        :param _builtins.str peer_address: The peer IP address (GRE outer IP address) on the appliance side of the Connect peer.
        :param Sequence['TransitGatewayConnectPeerTransitGatewayAttachmentBgpConfiguration'] bgp_configurations: The BGP configuration details.
        :param _builtins.str protocol: The tunnel protocol.
        :param _builtins.str transit_gateway_address: The Connect peer IP address on the transit gateway side of the tunnel.
        """
        pulumi.set(__self__, "inside_cidr_blocks", inside_cidr_blocks)
        pulumi.set(__self__, "peer_address", peer_address)
        if bgp_configurations is not None:
            pulumi.set(__self__, "bgp_configurations", bgp_configurations)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if transit_gateway_address is not None:
            pulumi.set(__self__, "transit_gateway_address", transit_gateway_address)

    @_builtins.property
    @pulumi.getter(name="insideCidrBlocks")
    def inside_cidr_blocks(self) -> Sequence[_builtins.str]:
        """
        The range of interior BGP peer IP addresses.
        """
        return pulumi.get(self, "inside_cidr_blocks")

    @_builtins.property
    @pulumi.getter(name="peerAddress")
    def peer_address(self) -> _builtins.str:
        """
        The peer IP address (GRE outer IP address) on the appliance side of the Connect peer.
        """
        return pulumi.get(self, "peer_address")

    @_builtins.property
    @pulumi.getter(name="bgpConfigurations")
    def bgp_configurations(self) -> Optional[Sequence['outputs.TransitGatewayConnectPeerTransitGatewayAttachmentBgpConfiguration']]:
        """
        The BGP configuration details.
        """
        return pulumi.get(self, "bgp_configurations")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        The tunnel protocol.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="transitGatewayAddress")
    def transit_gateway_address(self) -> Optional[_builtins.str]:
        """
        The Connect peer IP address on the transit gateway side of the tunnel.
        """
        return pulumi.get(self, "transit_gateway_address")


@pulumi.output_type
class TransitGatewayConnectPeerTransitGatewayAttachmentBgpConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bgpStatus":
            suggest = "bgp_status"
        elif key == "peerAddress":
            suggest = "peer_address"
        elif key == "peerAsn":
            suggest = "peer_asn"
        elif key == "transitGatewayAddress":
            suggest = "transit_gateway_address"
        elif key == "transitGatewayAsn":
            suggest = "transit_gateway_asn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TransitGatewayConnectPeerTransitGatewayAttachmentBgpConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TransitGatewayConnectPeerTransitGatewayAttachmentBgpConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TransitGatewayConnectPeerTransitGatewayAttachmentBgpConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bgp_status: Optional[_builtins.str] = None,
                 peer_address: Optional[_builtins.str] = None,
                 peer_asn: Optional[_builtins.float] = None,
                 transit_gateway_address: Optional[_builtins.str] = None,
                 transit_gateway_asn: Optional[_builtins.float] = None):
        """
        :param _builtins.str bgp_status: The BGP status.
        :param _builtins.str peer_address: The interior BGP peer IP address for the appliance.
        :param _builtins.float peer_asn: The peer Autonomous System Number (ASN).
        :param _builtins.str transit_gateway_address: The interior BGP peer IP address for the transit gateway.
        :param _builtins.float transit_gateway_asn: The transit gateway Autonomous System Number (ASN).
        """
        if bgp_status is not None:
            pulumi.set(__self__, "bgp_status", bgp_status)
        if peer_address is not None:
            pulumi.set(__self__, "peer_address", peer_address)
        if peer_asn is not None:
            pulumi.set(__self__, "peer_asn", peer_asn)
        if transit_gateway_address is not None:
            pulumi.set(__self__, "transit_gateway_address", transit_gateway_address)
        if transit_gateway_asn is not None:
            pulumi.set(__self__, "transit_gateway_asn", transit_gateway_asn)

    @_builtins.property
    @pulumi.getter(name="bgpStatus")
    def bgp_status(self) -> Optional[_builtins.str]:
        """
        The BGP status.
        """
        return pulumi.get(self, "bgp_status")

    @_builtins.property
    @pulumi.getter(name="peerAddress")
    def peer_address(self) -> Optional[_builtins.str]:
        """
        The interior BGP peer IP address for the appliance.
        """
        return pulumi.get(self, "peer_address")

    @_builtins.property
    @pulumi.getter(name="peerAsn")
    def peer_asn(self) -> Optional[_builtins.float]:
        """
        The peer Autonomous System Number (ASN).
        """
        return pulumi.get(self, "peer_asn")

    @_builtins.property
    @pulumi.getter(name="transitGatewayAddress")
    def transit_gateway_address(self) -> Optional[_builtins.str]:
        """
        The interior BGP peer IP address for the transit gateway.
        """
        return pulumi.get(self, "transit_gateway_address")

    @_builtins.property
    @pulumi.getter(name="transitGatewayAsn")
    def transit_gateway_asn(self) -> Optional[_builtins.float]:
        """
        The transit gateway Autonomous System Number (ASN).
        """
        return pulumi.get(self, "transit_gateway_asn")


@pulumi.output_type
class TransitGatewayPeeringAttachmentPeeringAttachmentStatus(dict):
    def __init__(__self__, *,
                 code: Optional[_builtins.str] = None,
                 message: Optional[_builtins.str] = None):
        """
        :param _builtins.str code: The status code.
        :param _builtins.str message: The status message, if applicable.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[_builtins.str]:
        """
        The status code.
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        The status message, if applicable.
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class VerifiedAccessEndpointCidrOptions(dict):
    """
    The options for cidr type endpoint.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portRanges":
            suggest = "port_ranges"
        elif key == "subnetIds":
            suggest = "subnet_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VerifiedAccessEndpointCidrOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VerifiedAccessEndpointCidrOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VerifiedAccessEndpointCidrOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr: Optional[_builtins.str] = None,
                 port_ranges: Optional[Sequence['outputs.VerifiedAccessEndpointPortRange']] = None,
                 protocol: Optional[_builtins.str] = None,
                 subnet_ids: Optional[Sequence[_builtins.str]] = None):
        """
        The options for cidr type endpoint.
        :param _builtins.str cidr: The IP address range, in CIDR notation.
        :param Sequence['VerifiedAccessEndpointPortRange'] port_ranges: The list of port range.
        :param _builtins.str protocol: The IP protocol.
        :param Sequence[_builtins.str] subnet_ids: The IDs of the subnets.
        """
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if subnet_ids is not None:
            pulumi.set(__self__, "subnet_ids", subnet_ids)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> Optional[_builtins.str]:
        """
        The IP address range, in CIDR notation.
        """
        return pulumi.get(self, "cidr")

    @_builtins.property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[Sequence['outputs.VerifiedAccessEndpointPortRange']]:
        """
        The list of port range.
        """
        return pulumi.get(self, "port_ranges")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        The IP protocol.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        The IDs of the subnets.
        """
        return pulumi.get(self, "subnet_ids")


@pulumi.output_type
class VerifiedAccessEndpointLoadBalancerOptions(dict):
    """
    The load balancer details if creating the AWS Verified Access endpoint as load-balancertype.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loadBalancerArn":
            suggest = "load_balancer_arn"
        elif key == "portRanges":
            suggest = "port_ranges"
        elif key == "subnetIds":
            suggest = "subnet_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VerifiedAccessEndpointLoadBalancerOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VerifiedAccessEndpointLoadBalancerOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VerifiedAccessEndpointLoadBalancerOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 load_balancer_arn: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_ranges: Optional[Sequence['outputs.VerifiedAccessEndpointPortRange']] = None,
                 protocol: Optional[_builtins.str] = None,
                 subnet_ids: Optional[Sequence[_builtins.str]] = None):
        """
        The load balancer details if creating the AWS Verified Access endpoint as load-balancertype.
        :param _builtins.str load_balancer_arn: The ARN of the load balancer.
        :param _builtins.int port: The IP port number.
        :param Sequence['VerifiedAccessEndpointPortRange'] port_ranges: The list of port range.
        :param _builtins.str protocol: The IP protocol.
        :param Sequence[_builtins.str] subnet_ids: The IDs of the subnets.
        """
        if load_balancer_arn is not None:
            pulumi.set(__self__, "load_balancer_arn", load_balancer_arn)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if subnet_ids is not None:
            pulumi.set(__self__, "subnet_ids", subnet_ids)

    @_builtins.property
    @pulumi.getter(name="loadBalancerArn")
    def load_balancer_arn(self) -> Optional[_builtins.str]:
        """
        The ARN of the load balancer.
        """
        return pulumi.get(self, "load_balancer_arn")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The IP port number.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[Sequence['outputs.VerifiedAccessEndpointPortRange']]:
        """
        The list of port range.
        """
        return pulumi.get(self, "port_ranges")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        The IP protocol.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        The IDs of the subnets.
        """
        return pulumi.get(self, "subnet_ids")


@pulumi.output_type
class VerifiedAccessEndpointNetworkInterfaceOptions(dict):
    """
    The options for network-interface type endpoint.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "portRanges":
            suggest = "port_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VerifiedAccessEndpointNetworkInterfaceOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VerifiedAccessEndpointNetworkInterfaceOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VerifiedAccessEndpointNetworkInterfaceOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_interface_id: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 port_ranges: Optional[Sequence['outputs.VerifiedAccessEndpointPortRange']] = None,
                 protocol: Optional[_builtins.str] = None):
        """
        The options for network-interface type endpoint.
        :param _builtins.str network_interface_id: The ID of the network interface.
        :param _builtins.int port: The IP port number.
        :param Sequence['VerifiedAccessEndpointPortRange'] port_ranges: The list of port ranges.
        :param _builtins.str protocol: The IP protocol.
        """
        if network_interface_id is not None:
            pulumi.set(__self__, "network_interface_id", network_interface_id)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[_builtins.str]:
        """
        The ID of the network interface.
        """
        return pulumi.get(self, "network_interface_id")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The IP port number.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[Sequence['outputs.VerifiedAccessEndpointPortRange']]:
        """
        The list of port ranges.
        """
        return pulumi.get(self, "port_ranges")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        The IP protocol.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class VerifiedAccessEndpointPortRange(dict):
    """
    The IP port range.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "toPort":
            suggest = "to_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VerifiedAccessEndpointPortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VerifiedAccessEndpointPortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VerifiedAccessEndpointPortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_port: Optional[_builtins.int] = None,
                 to_port: Optional[_builtins.int] = None):
        """
        The IP port range.
        :param _builtins.int from_port: The first port in the range.
        :param _builtins.int to_port: The last port in the range.
        """
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)

    @_builtins.property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[_builtins.int]:
        """
        The first port in the range.
        """
        return pulumi.get(self, "from_port")

    @_builtins.property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[_builtins.int]:
        """
        The last port in the range.
        """
        return pulumi.get(self, "to_port")


@pulumi.output_type
class VerifiedAccessEndpointRdsOptions(dict):
    """
    The options for rds type endpoint.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rdsDbClusterArn":
            suggest = "rds_db_cluster_arn"
        elif key == "rdsDbInstanceArn":
            suggest = "rds_db_instance_arn"
        elif key == "rdsDbProxyArn":
            suggest = "rds_db_proxy_arn"
        elif key == "rdsEndpoint":
            suggest = "rds_endpoint"
        elif key == "subnetIds":
            suggest = "subnet_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VerifiedAccessEndpointRdsOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VerifiedAccessEndpointRdsOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VerifiedAccessEndpointRdsOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port: Optional[_builtins.int] = None,
                 protocol: Optional[_builtins.str] = None,
                 rds_db_cluster_arn: Optional[_builtins.str] = None,
                 rds_db_instance_arn: Optional[_builtins.str] = None,
                 rds_db_proxy_arn: Optional[_builtins.str] = None,
                 rds_endpoint: Optional[_builtins.str] = None,
                 subnet_ids: Optional[Sequence[_builtins.str]] = None):
        """
        The options for rds type endpoint.
        :param _builtins.int port: The IP port number.
        :param _builtins.str protocol: The IP protocol.
        :param _builtins.str rds_db_cluster_arn: The ARN of the RDS DB cluster.
        :param _builtins.str rds_db_instance_arn: The ARN of the RDS DB instance.
        :param _builtins.str rds_db_proxy_arn: The ARN of the RDS DB proxy.
        :param _builtins.str rds_endpoint: The RDS endpoint.
        :param Sequence[_builtins.str] subnet_ids: The IDs of the subnets.
        """
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if rds_db_cluster_arn is not None:
            pulumi.set(__self__, "rds_db_cluster_arn", rds_db_cluster_arn)
        if rds_db_instance_arn is not None:
            pulumi.set(__self__, "rds_db_instance_arn", rds_db_instance_arn)
        if rds_db_proxy_arn is not None:
            pulumi.set(__self__, "rds_db_proxy_arn", rds_db_proxy_arn)
        if rds_endpoint is not None:
            pulumi.set(__self__, "rds_endpoint", rds_endpoint)
        if subnet_ids is not None:
            pulumi.set(__self__, "subnet_ids", subnet_ids)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The IP port number.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        The IP protocol.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="rdsDbClusterArn")
    def rds_db_cluster_arn(self) -> Optional[_builtins.str]:
        """
        The ARN of the RDS DB cluster.
        """
        return pulumi.get(self, "rds_db_cluster_arn")

    @_builtins.property
    @pulumi.getter(name="rdsDbInstanceArn")
    def rds_db_instance_arn(self) -> Optional[_builtins.str]:
        """
        The ARN of the RDS DB instance.
        """
        return pulumi.get(self, "rds_db_instance_arn")

    @_builtins.property
    @pulumi.getter(name="rdsDbProxyArn")
    def rds_db_proxy_arn(self) -> Optional[_builtins.str]:
        """
        The ARN of the RDS DB proxy.
        """
        return pulumi.get(self, "rds_db_proxy_arn")

    @_builtins.property
    @pulumi.getter(name="rdsEndpoint")
    def rds_endpoint(self) -> Optional[_builtins.str]:
        """
        The RDS endpoint.
        """
        return pulumi.get(self, "rds_endpoint")

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        The IDs of the subnets.
        """
        return pulumi.get(self, "subnet_ids")


@pulumi.output_type
class VerifiedAccessEndpointSseSpecification(dict):
    """
    The configuration options for customer provided KMS encryption.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customerManagedKeyEnabled":
            suggest = "customer_managed_key_enabled"
        elif key == "kmsKeyArn":
            suggest = "kms_key_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VerifiedAccessEndpointSseSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VerifiedAccessEndpointSseSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VerifiedAccessEndpointSseSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 customer_managed_key_enabled: Optional[_builtins.bool] = None,
                 kms_key_arn: Optional[_builtins.str] = None):
        """
        The configuration options for customer provided KMS encryption.
        :param _builtins.bool customer_managed_key_enabled: Whether to encrypt the policy with the provided key or disable encryption
        :param _builtins.str kms_key_arn: KMS Key Arn used to encrypt the group policy
        """
        if customer_managed_key_enabled is not None:
            pulumi.set(__self__, "customer_managed_key_enabled", customer_managed_key_enabled)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @_builtins.property
    @pulumi.getter(name="customerManagedKeyEnabled")
    def customer_managed_key_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to encrypt the policy with the provided key or disable encryption
        """
        return pulumi.get(self, "customer_managed_key_enabled")

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[_builtins.str]:
        """
        KMS Key Arn used to encrypt the group policy
        """
        return pulumi.get(self, "kms_key_arn")


@pulumi.output_type
class VerifiedAccessGroupSseSpecification(dict):
    """
    The configuration options for customer provided KMS encryption.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customerManagedKeyEnabled":
            suggest = "customer_managed_key_enabled"
        elif key == "kmsKeyArn":
            suggest = "kms_key_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VerifiedAccessGroupSseSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VerifiedAccessGroupSseSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VerifiedAccessGroupSseSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 customer_managed_key_enabled: Optional[_builtins.bool] = None,
                 kms_key_arn: Optional[_builtins.str] = None):
        """
        The configuration options for customer provided KMS encryption.
        :param _builtins.bool customer_managed_key_enabled: Whether to encrypt the policy with the provided key or disable encryption
        :param _builtins.str kms_key_arn: KMS Key Arn used to encrypt the group policy
        """
        if customer_managed_key_enabled is not None:
            pulumi.set(__self__, "customer_managed_key_enabled", customer_managed_key_enabled)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @_builtins.property
    @pulumi.getter(name="customerManagedKeyEnabled")
    def customer_managed_key_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to encrypt the policy with the provided key or disable encryption
        """
        return pulumi.get(self, "customer_managed_key_enabled")

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[_builtins.str]:
        """
        KMS Key Arn used to encrypt the group policy
        """
        return pulumi.get(self, "kms_key_arn")


@pulumi.output_type
class VerifiedAccessInstanceVerifiedAccessLogs(dict):
    """
    The configuration options for AWS Verified Access instances.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudWatchLogs":
            suggest = "cloud_watch_logs"
        elif key == "includeTrustContext":
            suggest = "include_trust_context"
        elif key == "kinesisDataFirehose":
            suggest = "kinesis_data_firehose"
        elif key == "logVersion":
            suggest = "log_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VerifiedAccessInstanceVerifiedAccessLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VerifiedAccessInstanceVerifiedAccessLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VerifiedAccessInstanceVerifiedAccessLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_watch_logs: Optional['outputs.VerifiedAccessInstanceVerifiedAccessLogsCloudWatchLogsProperties'] = None,
                 include_trust_context: Optional[_builtins.bool] = None,
                 kinesis_data_firehose: Optional['outputs.VerifiedAccessInstanceVerifiedAccessLogsKinesisDataFirehoseProperties'] = None,
                 log_version: Optional[_builtins.str] = None,
                 s3: Optional['outputs.VerifiedAccessInstanceVerifiedAccessLogsS3Properties'] = None):
        """
        The configuration options for AWS Verified Access instances.
        :param 'VerifiedAccessInstanceVerifiedAccessLogsCloudWatchLogsProperties' cloud_watch_logs: Sends Verified Access logs to CloudWatch Logs.
        :param _builtins.bool include_trust_context: Include claims from trust providers in Verified Access logs.
        :param 'VerifiedAccessInstanceVerifiedAccessLogsKinesisDataFirehoseProperties' kinesis_data_firehose: Sends Verified Access logs to Kinesis.
        :param _builtins.str log_version: Select log version for Verified Access logs.
        :param 'VerifiedAccessInstanceVerifiedAccessLogsS3Properties' s3: Sends Verified Access logs to Amazon S3.
        """
        if cloud_watch_logs is not None:
            pulumi.set(__self__, "cloud_watch_logs", cloud_watch_logs)
        if include_trust_context is not None:
            pulumi.set(__self__, "include_trust_context", include_trust_context)
        if kinesis_data_firehose is not None:
            pulumi.set(__self__, "kinesis_data_firehose", kinesis_data_firehose)
        if log_version is not None:
            pulumi.set(__self__, "log_version", log_version)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @_builtins.property
    @pulumi.getter(name="cloudWatchLogs")
    def cloud_watch_logs(self) -> Optional['outputs.VerifiedAccessInstanceVerifiedAccessLogsCloudWatchLogsProperties']:
        """
        Sends Verified Access logs to CloudWatch Logs.
        """
        return pulumi.get(self, "cloud_watch_logs")

    @_builtins.property
    @pulumi.getter(name="includeTrustContext")
    def include_trust_context(self) -> Optional[_builtins.bool]:
        """
        Include claims from trust providers in Verified Access logs.
        """
        return pulumi.get(self, "include_trust_context")

    @_builtins.property
    @pulumi.getter(name="kinesisDataFirehose")
    def kinesis_data_firehose(self) -> Optional['outputs.VerifiedAccessInstanceVerifiedAccessLogsKinesisDataFirehoseProperties']:
        """
        Sends Verified Access logs to Kinesis.
        """
        return pulumi.get(self, "kinesis_data_firehose")

    @_builtins.property
    @pulumi.getter(name="logVersion")
    def log_version(self) -> Optional[_builtins.str]:
        """
        Select log version for Verified Access logs.
        """
        return pulumi.get(self, "log_version")

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional['outputs.VerifiedAccessInstanceVerifiedAccessLogsS3Properties']:
        """
        Sends Verified Access logs to Amazon S3.
        """
        return pulumi.get(self, "s3")


@pulumi.output_type
class VerifiedAccessInstanceVerifiedAccessLogsCloudWatchLogsProperties(dict):
    """
    Sends Verified Access logs to CloudWatch Logs.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logGroup":
            suggest = "log_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VerifiedAccessInstanceVerifiedAccessLogsCloudWatchLogsProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VerifiedAccessInstanceVerifiedAccessLogsCloudWatchLogsProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VerifiedAccessInstanceVerifiedAccessLogsCloudWatchLogsProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 log_group: Optional[_builtins.str] = None):
        """
        Sends Verified Access logs to CloudWatch Logs.
        :param _builtins.bool enabled: Indicates whether logging is enabled.
        :param _builtins.str log_group: The ID of the CloudWatch Logs log group.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if log_group is not None:
            pulumi.set(__self__, "log_group", log_group)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates whether logging is enabled.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="logGroup")
    def log_group(self) -> Optional[_builtins.str]:
        """
        The ID of the CloudWatch Logs log group.
        """
        return pulumi.get(self, "log_group")


@pulumi.output_type
class VerifiedAccessInstanceVerifiedAccessLogsKinesisDataFirehoseProperties(dict):
    """
    Sends Verified Access logs to Kinesis.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deliveryStream":
            suggest = "delivery_stream"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VerifiedAccessInstanceVerifiedAccessLogsKinesisDataFirehoseProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VerifiedAccessInstanceVerifiedAccessLogsKinesisDataFirehoseProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VerifiedAccessInstanceVerifiedAccessLogsKinesisDataFirehoseProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delivery_stream: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None):
        """
        Sends Verified Access logs to Kinesis.
        :param _builtins.str delivery_stream: The ID of the delivery stream.
        :param _builtins.bool enabled: Indicates whether logging is enabled.
        """
        if delivery_stream is not None:
            pulumi.set(__self__, "delivery_stream", delivery_stream)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="deliveryStream")
    def delivery_stream(self) -> Optional[_builtins.str]:
        """
        The ID of the delivery stream.
        """
        return pulumi.get(self, "delivery_stream")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates whether logging is enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class VerifiedAccessInstanceVerifiedAccessLogsS3Properties(dict):
    """
    Sends Verified Access logs to Amazon S3.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "bucketOwner":
            suggest = "bucket_owner"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VerifiedAccessInstanceVerifiedAccessLogsS3Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VerifiedAccessInstanceVerifiedAccessLogsS3Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VerifiedAccessInstanceVerifiedAccessLogsS3Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: Optional[_builtins.str] = None,
                 bucket_owner: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None,
                 prefix: Optional[_builtins.str] = None):
        """
        Sends Verified Access logs to Amazon S3.
        :param _builtins.str bucket_name: The bucket name.
        :param _builtins.str bucket_owner: The ID of the AWS account that owns the Amazon S3 bucket.
        :param _builtins.bool enabled: Indicates whether logging is enabled.
        :param _builtins.str prefix: The bucket prefix.
        """
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if bucket_owner is not None:
            pulumi.set(__self__, "bucket_owner", bucket_owner)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[_builtins.str]:
        """
        The bucket name.
        """
        return pulumi.get(self, "bucket_name")

    @_builtins.property
    @pulumi.getter(name="bucketOwner")
    def bucket_owner(self) -> Optional[_builtins.str]:
        """
        The ID of the AWS account that owns the Amazon S3 bucket.
        """
        return pulumi.get(self, "bucket_owner")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates whether logging is enabled.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.str]:
        """
        The bucket prefix.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class VerifiedAccessInstanceVerifiedAccessTrustProvider(dict):
    """
    A Verified Access Trust Provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceTrustProviderType":
            suggest = "device_trust_provider_type"
        elif key == "trustProviderType":
            suggest = "trust_provider_type"
        elif key == "userTrustProviderType":
            suggest = "user_trust_provider_type"
        elif key == "verifiedAccessTrustProviderId":
            suggest = "verified_access_trust_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VerifiedAccessInstanceVerifiedAccessTrustProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VerifiedAccessInstanceVerifiedAccessTrustProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VerifiedAccessInstanceVerifiedAccessTrustProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 device_trust_provider_type: Optional[_builtins.str] = None,
                 trust_provider_type: Optional[_builtins.str] = None,
                 user_trust_provider_type: Optional[_builtins.str] = None,
                 verified_access_trust_provider_id: Optional[_builtins.str] = None):
        """
        A Verified Access Trust Provider.
        :param _builtins.str description: The description of trust provider.
        :param _builtins.str device_trust_provider_type: The type of device-based trust provider.
        :param _builtins.str trust_provider_type: The type of trust provider (user- or device-based).
        :param _builtins.str user_trust_provider_type: The type of user-based trust provider.
        :param _builtins.str verified_access_trust_provider_id: The ID of the trust provider.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if device_trust_provider_type is not None:
            pulumi.set(__self__, "device_trust_provider_type", device_trust_provider_type)
        if trust_provider_type is not None:
            pulumi.set(__self__, "trust_provider_type", trust_provider_type)
        if user_trust_provider_type is not None:
            pulumi.set(__self__, "user_trust_provider_type", user_trust_provider_type)
        if verified_access_trust_provider_id is not None:
            pulumi.set(__self__, "verified_access_trust_provider_id", verified_access_trust_provider_id)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of trust provider.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="deviceTrustProviderType")
    def device_trust_provider_type(self) -> Optional[_builtins.str]:
        """
        The type of device-based trust provider.
        """
        return pulumi.get(self, "device_trust_provider_type")

    @_builtins.property
    @pulumi.getter(name="trustProviderType")
    def trust_provider_type(self) -> Optional[_builtins.str]:
        """
        The type of trust provider (user- or device-based).
        """
        return pulumi.get(self, "trust_provider_type")

    @_builtins.property
    @pulumi.getter(name="userTrustProviderType")
    def user_trust_provider_type(self) -> Optional[_builtins.str]:
        """
        The type of user-based trust provider.
        """
        return pulumi.get(self, "user_trust_provider_type")

    @_builtins.property
    @pulumi.getter(name="verifiedAccessTrustProviderId")
    def verified_access_trust_provider_id(self) -> Optional[_builtins.str]:
        """
        The ID of the trust provider.
        """
        return pulumi.get(self, "verified_access_trust_provider_id")


@pulumi.output_type
class VerifiedAccessTrustProviderDeviceOptions(dict):
    """
    The options for device identity based trust providers.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicSigningKeyUrl":
            suggest = "public_signing_key_url"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VerifiedAccessTrustProviderDeviceOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VerifiedAccessTrustProviderDeviceOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VerifiedAccessTrustProviderDeviceOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 public_signing_key_url: Optional[_builtins.str] = None,
                 tenant_id: Optional[_builtins.str] = None):
        """
        The options for device identity based trust providers.
        :param _builtins.str public_signing_key_url: URL Verified Access will use to verify authenticity of the device tokens.
        :param _builtins.str tenant_id: The ID of the tenant application with the device-identity provider.
        """
        if public_signing_key_url is not None:
            pulumi.set(__self__, "public_signing_key_url", public_signing_key_url)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter(name="publicSigningKeyUrl")
    def public_signing_key_url(self) -> Optional[_builtins.str]:
        """
        URL Verified Access will use to verify authenticity of the device tokens.
        """
        return pulumi.get(self, "public_signing_key_url")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[_builtins.str]:
        """
        The ID of the tenant application with the device-identity provider.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class VerifiedAccessTrustProviderNativeApplicationOidcOptions(dict):
    """
    The OpenID Connect details for an oidc -type, user-identity based trust provider for L4.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizationEndpoint":
            suggest = "authorization_endpoint"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "publicSigningKeyEndpoint":
            suggest = "public_signing_key_endpoint"
        elif key == "tokenEndpoint":
            suggest = "token_endpoint"
        elif key == "userInfoEndpoint":
            suggest = "user_info_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VerifiedAccessTrustProviderNativeApplicationOidcOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VerifiedAccessTrustProviderNativeApplicationOidcOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VerifiedAccessTrustProviderNativeApplicationOidcOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorization_endpoint: Optional[_builtins.str] = None,
                 client_id: Optional[_builtins.str] = None,
                 client_secret: Optional[_builtins.str] = None,
                 issuer: Optional[_builtins.str] = None,
                 public_signing_key_endpoint: Optional[_builtins.str] = None,
                 scope: Optional[_builtins.str] = None,
                 token_endpoint: Optional[_builtins.str] = None,
                 user_info_endpoint: Optional[_builtins.str] = None):
        """
        The OpenID Connect details for an oidc -type, user-identity based trust provider for L4.
        :param _builtins.str authorization_endpoint: The OIDC authorization endpoint.
        :param _builtins.str client_id: The client identifier.
        :param _builtins.str client_secret: The client secret.
        :param _builtins.str issuer: The OIDC issuer.
        :param _builtins.str public_signing_key_endpoint: The public signing key for endpoint
        :param _builtins.str scope: OpenID Connect (OIDC) scopes are used by an application during authentication to authorize access to details of a user. Each scope returns a specific set of user attributes.
        :param _builtins.str token_endpoint: The OIDC token endpoint.
        :param _builtins.str user_info_endpoint: The OIDC user info endpoint.
        """
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if public_signing_key_endpoint is not None:
            pulumi.set(__self__, "public_signing_key_endpoint", public_signing_key_endpoint)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if user_info_endpoint is not None:
            pulumi.set(__self__, "user_info_endpoint", user_info_endpoint)

    @_builtins.property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[_builtins.str]:
        """
        The OIDC authorization endpoint.
        """
        return pulumi.get(self, "authorization_endpoint")

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        The client identifier.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[_builtins.str]:
        """
        The client secret.
        """
        return pulumi.get(self, "client_secret")

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[_builtins.str]:
        """
        The OIDC issuer.
        """
        return pulumi.get(self, "issuer")

    @_builtins.property
    @pulumi.getter(name="publicSigningKeyEndpoint")
    def public_signing_key_endpoint(self) -> Optional[_builtins.str]:
        """
        The public signing key for endpoint
        """
        return pulumi.get(self, "public_signing_key_endpoint")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[_builtins.str]:
        """
        OpenID Connect (OIDC) scopes are used by an application during authentication to authorize access to details of a user. Each scope returns a specific set of user attributes.
        """
        return pulumi.get(self, "scope")

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[_builtins.str]:
        """
        The OIDC token endpoint.
        """
        return pulumi.get(self, "token_endpoint")

    @_builtins.property
    @pulumi.getter(name="userInfoEndpoint")
    def user_info_endpoint(self) -> Optional[_builtins.str]:
        """
        The OIDC user info endpoint.
        """
        return pulumi.get(self, "user_info_endpoint")


@pulumi.output_type
class VerifiedAccessTrustProviderOidcOptions(dict):
    """
    The OpenID Connect details for an oidc -type, user-identity based trust provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizationEndpoint":
            suggest = "authorization_endpoint"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "tokenEndpoint":
            suggest = "token_endpoint"
        elif key == "userInfoEndpoint":
            suggest = "user_info_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VerifiedAccessTrustProviderOidcOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VerifiedAccessTrustProviderOidcOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VerifiedAccessTrustProviderOidcOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorization_endpoint: Optional[_builtins.str] = None,
                 client_id: Optional[_builtins.str] = None,
                 client_secret: Optional[_builtins.str] = None,
                 issuer: Optional[_builtins.str] = None,
                 scope: Optional[_builtins.str] = None,
                 token_endpoint: Optional[_builtins.str] = None,
                 user_info_endpoint: Optional[_builtins.str] = None):
        """
        The OpenID Connect details for an oidc -type, user-identity based trust provider.
        :param _builtins.str authorization_endpoint: The OIDC authorization endpoint.
        :param _builtins.str client_id: The client identifier.
        :param _builtins.str client_secret: The client secret.
        :param _builtins.str issuer: The OIDC issuer.
        :param _builtins.str scope: OpenID Connect (OIDC) scopes are used by an application during authentication to authorize access to details of a user. Each scope returns a specific set of user attributes.
        :param _builtins.str token_endpoint: The OIDC token endpoint.
        :param _builtins.str user_info_endpoint: The OIDC user info endpoint.
        """
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if user_info_endpoint is not None:
            pulumi.set(__self__, "user_info_endpoint", user_info_endpoint)

    @_builtins.property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[_builtins.str]:
        """
        The OIDC authorization endpoint.
        """
        return pulumi.get(self, "authorization_endpoint")

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        The client identifier.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[_builtins.str]:
        """
        The client secret.
        """
        return pulumi.get(self, "client_secret")

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[_builtins.str]:
        """
        The OIDC issuer.
        """
        return pulumi.get(self, "issuer")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[_builtins.str]:
        """
        OpenID Connect (OIDC) scopes are used by an application during authentication to authorize access to details of a user. Each scope returns a specific set of user attributes.
        """
        return pulumi.get(self, "scope")

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[_builtins.str]:
        """
        The OIDC token endpoint.
        """
        return pulumi.get(self, "token_endpoint")

    @_builtins.property
    @pulumi.getter(name="userInfoEndpoint")
    def user_info_endpoint(self) -> Optional[_builtins.str]:
        """
        The OIDC user info endpoint.
        """
        return pulumi.get(self, "user_info_endpoint")


@pulumi.output_type
class VpcEndpointDnsOptionsSpecification(dict):
    """
    Describes the DNS options for an endpoint.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsRecordIpType":
            suggest = "dns_record_ip_type"
        elif key == "privateDnsOnlyForInboundResolverEndpoint":
            suggest = "private_dns_only_for_inbound_resolver_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcEndpointDnsOptionsSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcEndpointDnsOptionsSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcEndpointDnsOptionsSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_record_ip_type: Optional['VpcEndpointDnsOptionsSpecificationDnsRecordIpType'] = None,
                 private_dns_only_for_inbound_resolver_endpoint: Optional['VpcEndpointDnsOptionsSpecificationPrivateDnsOnlyForInboundResolverEndpoint'] = None):
        """
        Describes the DNS options for an endpoint.
        :param 'VpcEndpointDnsOptionsSpecificationDnsRecordIpType' dns_record_ip_type: The DNS records created for the endpoint.
        :param 'VpcEndpointDnsOptionsSpecificationPrivateDnsOnlyForInboundResolverEndpoint' private_dns_only_for_inbound_resolver_endpoint: Indicates whether to enable private DNS only for inbound endpoints. This option is available only for services that support both gateway and interface endpoints. It routes traffic that originates from the VPC to the gateway endpoint and traffic that originates from on-premises to the interface endpoint.
        """
        if dns_record_ip_type is not None:
            pulumi.set(__self__, "dns_record_ip_type", dns_record_ip_type)
        if private_dns_only_for_inbound_resolver_endpoint is not None:
            pulumi.set(__self__, "private_dns_only_for_inbound_resolver_endpoint", private_dns_only_for_inbound_resolver_endpoint)

    @_builtins.property
    @pulumi.getter(name="dnsRecordIpType")
    def dns_record_ip_type(self) -> Optional['VpcEndpointDnsOptionsSpecificationDnsRecordIpType']:
        """
        The DNS records created for the endpoint.
        """
        return pulumi.get(self, "dns_record_ip_type")

    @_builtins.property
    @pulumi.getter(name="privateDnsOnlyForInboundResolverEndpoint")
    def private_dns_only_for_inbound_resolver_endpoint(self) -> Optional['VpcEndpointDnsOptionsSpecificationPrivateDnsOnlyForInboundResolverEndpoint']:
        """
        Indicates whether to enable private DNS only for inbound endpoints. This option is available only for services that support both gateway and interface endpoints. It routes traffic that originates from the VPC to the gateway endpoint and traffic that originates from on-premises to the interface endpoint.
        """
        return pulumi.get(self, "private_dns_only_for_inbound_resolver_endpoint")


@pulumi.output_type
class VpnConnectionCloudwatchLogOptionsSpecification(dict):
    """
    Options for sending VPN tunnel logs to CloudWatch.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logEnabled":
            suggest = "log_enabled"
        elif key == "logGroupArn":
            suggest = "log_group_arn"
        elif key == "logOutputFormat":
            suggest = "log_output_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnConnectionCloudwatchLogOptionsSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnConnectionCloudwatchLogOptionsSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnConnectionCloudwatchLogOptionsSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_enabled: Optional[_builtins.bool] = None,
                 log_group_arn: Optional[_builtins.str] = None,
                 log_output_format: Optional['VpnConnectionCloudwatchLogOptionsSpecificationLogOutputFormat'] = None):
        """
        Options for sending VPN tunnel logs to CloudWatch.
        :param _builtins.bool log_enabled: Enable or disable VPN tunnel logging feature. Default value is ``False``.
                Valid values: ``True`` | ``False``
        :param _builtins.str log_group_arn: The Amazon Resource Name (ARN) of the CloudWatch log group to send logs to.
        :param 'VpnConnectionCloudwatchLogOptionsSpecificationLogOutputFormat' log_output_format: Set log format. Default format is ``json``.
                Valid values: ``json`` | ``text``
        """
        if log_enabled is not None:
            pulumi.set(__self__, "log_enabled", log_enabled)
        if log_group_arn is not None:
            pulumi.set(__self__, "log_group_arn", log_group_arn)
        if log_output_format is not None:
            pulumi.set(__self__, "log_output_format", log_output_format)

    @_builtins.property
    @pulumi.getter(name="logEnabled")
    def log_enabled(self) -> Optional[_builtins.bool]:
        """
        Enable or disable VPN tunnel logging feature. Default value is ``False``.
         Valid values: ``True`` | ``False``
        """
        return pulumi.get(self, "log_enabled")

    @_builtins.property
    @pulumi.getter(name="logGroupArn")
    def log_group_arn(self) -> Optional[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the CloudWatch log group to send logs to.
        """
        return pulumi.get(self, "log_group_arn")

    @_builtins.property
    @pulumi.getter(name="logOutputFormat")
    def log_output_format(self) -> Optional['VpnConnectionCloudwatchLogOptionsSpecificationLogOutputFormat']:
        """
        Set log format. Default format is ``json``.
         Valid values: ``json`` | ``text``
        """
        return pulumi.get(self, "log_output_format")


@pulumi.output_type
class VpnConnectionIkeVersionsRequestListValue(dict):
    """
    The IKE version that is permitted for the VPN tunnel.
    """
    def __init__(__self__, *,
                 value: Optional['VpnConnectionIkeVersionsRequestListValueValue'] = None):
        """
        The IKE version that is permitted for the VPN tunnel.
        :param 'VpnConnectionIkeVersionsRequestListValueValue' value: The IKE version.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional['VpnConnectionIkeVersionsRequestListValueValue']:
        """
        The IKE version.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class VpnConnectionPhase1EncryptionAlgorithmsRequestListValue(dict):
    """
    Specifies the encryption algorithm for the VPN tunnel for phase 1 IKE negotiations.
    """
    def __init__(__self__, *,
                 value: Optional['VpnConnectionPhase1EncryptionAlgorithmsRequestListValueValue'] = None):
        """
        Specifies the encryption algorithm for the VPN tunnel for phase 1 IKE negotiations.
        :param 'VpnConnectionPhase1EncryptionAlgorithmsRequestListValueValue' value: The value for the encryption algorithm.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional['VpnConnectionPhase1EncryptionAlgorithmsRequestListValueValue']:
        """
        The value for the encryption algorithm.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class VpnConnectionPhase1IntegrityAlgorithmsRequestListValue(dict):
    """
    Specifies the integrity algorithm for the VPN tunnel for phase 1 IKE negotiations.
    """
    def __init__(__self__, *,
                 value: Optional['VpnConnectionPhase1IntegrityAlgorithmsRequestListValueValue'] = None):
        """
        Specifies the integrity algorithm for the VPN tunnel for phase 1 IKE negotiations.
        :param 'VpnConnectionPhase1IntegrityAlgorithmsRequestListValueValue' value: The value for the integrity algorithm.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional['VpnConnectionPhase1IntegrityAlgorithmsRequestListValueValue']:
        """
        The value for the integrity algorithm.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class VpnConnectionPhase1dhGroupNumbersRequestListValue(dict):
    """
    Specifies a Diffie-Hellman group number for the VPN tunnel for phase 1 IKE negotiations.
    """
    def __init__(__self__, *,
                 value: Optional[_builtins.int] = None):
        """
        Specifies a Diffie-Hellman group number for the VPN tunnel for phase 1 IKE negotiations.
        :param _builtins.int value: The Diffie-Hellmann group number.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.int]:
        """
        The Diffie-Hellmann group number.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class VpnConnectionPhase2EncryptionAlgorithmsRequestListValue(dict):
    """
    Specifies the encryption algorithm for the VPN tunnel for phase 2 IKE negotiations.
    """
    def __init__(__self__, *,
                 value: Optional['VpnConnectionPhase2EncryptionAlgorithmsRequestListValueValue'] = None):
        """
        Specifies the encryption algorithm for the VPN tunnel for phase 2 IKE negotiations.
        :param 'VpnConnectionPhase2EncryptionAlgorithmsRequestListValueValue' value: The encryption algorithm.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional['VpnConnectionPhase2EncryptionAlgorithmsRequestListValueValue']:
        """
        The encryption algorithm.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class VpnConnectionPhase2IntegrityAlgorithmsRequestListValue(dict):
    """
    Specifies the integrity algorithm for the VPN tunnel for phase 2 IKE negotiations.
    """
    def __init__(__self__, *,
                 value: Optional['VpnConnectionPhase2IntegrityAlgorithmsRequestListValueValue'] = None):
        """
        Specifies the integrity algorithm for the VPN tunnel for phase 2 IKE negotiations.
        :param 'VpnConnectionPhase2IntegrityAlgorithmsRequestListValueValue' value: The integrity algorithm.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional['VpnConnectionPhase2IntegrityAlgorithmsRequestListValueValue']:
        """
        The integrity algorithm.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class VpnConnectionPhase2dhGroupNumbersRequestListValue(dict):
    """
    Specifies a Diffie-Hellman group number for the VPN tunnel for phase 2 IKE negotiations.
    """
    def __init__(__self__, *,
                 value: Optional[_builtins.int] = None):
        """
        Specifies a Diffie-Hellman group number for the VPN tunnel for phase 2 IKE negotiations.
        :param _builtins.int value: The Diffie-Hellmann group number.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.int]:
        """
        The Diffie-Hellmann group number.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class VpnConnectionVpnTunnelLogOptionsSpecification(dict):
    """
    Options for logging VPN tunnel activity.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudwatchLogOptions":
            suggest = "cloudwatch_log_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnConnectionVpnTunnelLogOptionsSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnConnectionVpnTunnelLogOptionsSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnConnectionVpnTunnelLogOptionsSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloudwatch_log_options: Optional['outputs.VpnConnectionCloudwatchLogOptionsSpecification'] = None):
        """
        Options for logging VPN tunnel activity.
        :param 'VpnConnectionCloudwatchLogOptionsSpecification' cloudwatch_log_options: Options for sending VPN tunnel logs to CloudWatch.
        """
        if cloudwatch_log_options is not None:
            pulumi.set(__self__, "cloudwatch_log_options", cloudwatch_log_options)

    @_builtins.property
    @pulumi.getter(name="cloudwatchLogOptions")
    def cloudwatch_log_options(self) -> Optional['outputs.VpnConnectionCloudwatchLogOptionsSpecification']:
        """
        Options for sending VPN tunnel logs to CloudWatch.
        """
        return pulumi.get(self, "cloudwatch_log_options")


@pulumi.output_type
class VpnConnectionVpnTunnelOptionsSpecification(dict):
    """
    The tunnel options for a single VPN tunnel.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dpdTimeoutAction":
            suggest = "dpd_timeout_action"
        elif key == "dpdTimeoutSeconds":
            suggest = "dpd_timeout_seconds"
        elif key == "enableTunnelLifecycleControl":
            suggest = "enable_tunnel_lifecycle_control"
        elif key == "ikeVersions":
            suggest = "ike_versions"
        elif key == "logOptions":
            suggest = "log_options"
        elif key == "phase1EncryptionAlgorithms":
            suggest = "phase1_encryption_algorithms"
        elif key == "phase1IntegrityAlgorithms":
            suggest = "phase1_integrity_algorithms"
        elif key == "phase1LifetimeSeconds":
            suggest = "phase1_lifetime_seconds"
        elif key == "phase1dhGroupNumbers":
            suggest = "phase1dh_group_numbers"
        elif key == "phase2EncryptionAlgorithms":
            suggest = "phase2_encryption_algorithms"
        elif key == "phase2IntegrityAlgorithms":
            suggest = "phase2_integrity_algorithms"
        elif key == "phase2LifetimeSeconds":
            suggest = "phase2_lifetime_seconds"
        elif key == "phase2dhGroupNumbers":
            suggest = "phase2dh_group_numbers"
        elif key == "preSharedKey":
            suggest = "pre_shared_key"
        elif key == "rekeyFuzzPercentage":
            suggest = "rekey_fuzz_percentage"
        elif key == "rekeyMarginTimeSeconds":
            suggest = "rekey_margin_time_seconds"
        elif key == "replayWindowSize":
            suggest = "replay_window_size"
        elif key == "startupAction":
            suggest = "startup_action"
        elif key == "tunnelInsideCidr":
            suggest = "tunnel_inside_cidr"
        elif key == "tunnelInsideIpv6Cidr":
            suggest = "tunnel_inside_ipv6_cidr"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnConnectionVpnTunnelOptionsSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnConnectionVpnTunnelOptionsSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnConnectionVpnTunnelOptionsSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dpd_timeout_action: Optional['VpnConnectionVpnTunnelOptionsSpecificationDpdTimeoutAction'] = None,
                 dpd_timeout_seconds: Optional[_builtins.int] = None,
                 enable_tunnel_lifecycle_control: Optional[_builtins.bool] = None,
                 ike_versions: Optional[Sequence['outputs.VpnConnectionIkeVersionsRequestListValue']] = None,
                 log_options: Optional['outputs.VpnConnectionVpnTunnelLogOptionsSpecification'] = None,
                 phase1_encryption_algorithms: Optional[Sequence['outputs.VpnConnectionPhase1EncryptionAlgorithmsRequestListValue']] = None,
                 phase1_integrity_algorithms: Optional[Sequence['outputs.VpnConnectionPhase1IntegrityAlgorithmsRequestListValue']] = None,
                 phase1_lifetime_seconds: Optional[_builtins.int] = None,
                 phase1dh_group_numbers: Optional[Sequence['outputs.VpnConnectionPhase1dhGroupNumbersRequestListValue']] = None,
                 phase2_encryption_algorithms: Optional[Sequence['outputs.VpnConnectionPhase2EncryptionAlgorithmsRequestListValue']] = None,
                 phase2_integrity_algorithms: Optional[Sequence['outputs.VpnConnectionPhase2IntegrityAlgorithmsRequestListValue']] = None,
                 phase2_lifetime_seconds: Optional[_builtins.int] = None,
                 phase2dh_group_numbers: Optional[Sequence['outputs.VpnConnectionPhase2dhGroupNumbersRequestListValue']] = None,
                 pre_shared_key: Optional[_builtins.str] = None,
                 rekey_fuzz_percentage: Optional[_builtins.int] = None,
                 rekey_margin_time_seconds: Optional[_builtins.int] = None,
                 replay_window_size: Optional[_builtins.int] = None,
                 startup_action: Optional['VpnConnectionVpnTunnelOptionsSpecificationStartupAction'] = None,
                 tunnel_inside_cidr: Optional[_builtins.str] = None,
                 tunnel_inside_ipv6_cidr: Optional[_builtins.str] = None):
        """
        The tunnel options for a single VPN tunnel.
        :param 'VpnConnectionVpnTunnelOptionsSpecificationDpdTimeoutAction' dpd_timeout_action: The action to take after DPD timeout occurs. Specify ``restart`` to restart the IKE initiation. Specify ``clear`` to end the IKE session.
                Valid Values: ``clear`` | ``none`` | ``restart``
                Default: ``clear``
        :param _builtins.int dpd_timeout_seconds: The number of seconds after which a DPD timeout occurs.
                Constraints: A value greater than or equal to 30.
                Default: ``30``
        :param _builtins.bool enable_tunnel_lifecycle_control: Turn on or off tunnel endpoint lifecycle control feature.
        :param Sequence['VpnConnectionIkeVersionsRequestListValue'] ike_versions: The IKE versions that are permitted for the VPN tunnel.
                Valid values: ``ikev1`` | ``ikev2``
        :param 'VpnConnectionVpnTunnelLogOptionsSpecification' log_options: Options for logging VPN tunnel activity.
        :param Sequence['VpnConnectionPhase1EncryptionAlgorithmsRequestListValue'] phase1_encryption_algorithms: One or more encryption algorithms that are permitted for the VPN tunnel for phase 1 IKE negotiations.
                Valid values: ``AES128`` | ``AES256`` | ``AES128-GCM-16`` | ``AES256-GCM-16``
        :param Sequence['VpnConnectionPhase1IntegrityAlgorithmsRequestListValue'] phase1_integrity_algorithms: One or more integrity algorithms that are permitted for the VPN tunnel for phase 1 IKE negotiations.
                Valid values: ``SHA1`` | ``SHA2-256`` | ``SHA2-384`` | ``SHA2-512``
        :param _builtins.int phase1_lifetime_seconds: The lifetime for phase 1 of the IKE negotiation, in seconds.
                Constraints: A value between 900 and 28,800.
                Default: ``28800``
        :param Sequence['VpnConnectionPhase1dhGroupNumbersRequestListValue'] phase1dh_group_numbers: One or more Diffie-Hellman group numbers that are permitted for the VPN tunnel for phase 1 IKE negotiations.
                Valid values: ``2`` | ``14`` | ``15`` | ``16`` | ``17`` | ``18`` | ``19`` | ``20`` | ``21`` | ``22`` | ``23`` | ``24``
        :param Sequence['VpnConnectionPhase2EncryptionAlgorithmsRequestListValue'] phase2_encryption_algorithms: One or more encryption algorithms that are permitted for the VPN tunnel for phase 2 IKE negotiations.
                Valid values: ``AES128`` | ``AES256`` | ``AES128-GCM-16`` | ``AES256-GCM-16``
        :param Sequence['VpnConnectionPhase2IntegrityAlgorithmsRequestListValue'] phase2_integrity_algorithms: One or more integrity algorithms that are permitted for the VPN tunnel for phase 2 IKE negotiations.
                Valid values: ``SHA1`` | ``SHA2-256`` | ``SHA2-384`` | ``SHA2-512``
        :param _builtins.int phase2_lifetime_seconds: The lifetime for phase 2 of the IKE negotiation, in seconds.
                Constraints: A value between 900 and 3,600. The value must be less than the value for ``Phase1LifetimeSeconds``.
                Default: ``3600``
        :param Sequence['VpnConnectionPhase2dhGroupNumbersRequestListValue'] phase2dh_group_numbers: One or more Diffie-Hellman group numbers that are permitted for the VPN tunnel for phase 2 IKE negotiations.
                Valid values: ``2`` | ``5`` | ``14`` | ``15`` | ``16`` | ``17`` | ``18`` | ``19`` | ``20`` | ``21`` | ``22`` | ``23`` | ``24``
        :param _builtins.str pre_shared_key: The pre-shared key (PSK) to establish initial authentication between the virtual private gateway and customer gateway.
                Constraints: Allowed characters are alphanumeric characters, periods (.), and underscores (_). Must be between 8 and 64 characters in length and cannot start with zero (0).
        :param _builtins.int rekey_fuzz_percentage: The percentage of the rekey window (determined by ``RekeyMarginTimeSeconds``) during which the rekey time is randomly selected.
                Constraints: A value between 0 and 100.
                Default: ``100``
        :param _builtins.int rekey_margin_time_seconds: The margin time, in seconds, before the phase 2 lifetime expires, during which the AWS side of the VPN connection performs an IKE rekey. The exact time of the rekey is randomly selected based on the value for ``RekeyFuzzPercentage``.
                Constraints: A value between 60 and half of ``Phase2LifetimeSeconds``.
                Default: ``270``
        :param _builtins.int replay_window_size: The number of packets in an IKE replay window.
                Constraints: A value between 64 and 2048.
                Default: ``1024``
        :param 'VpnConnectionVpnTunnelOptionsSpecificationStartupAction' startup_action: The action to take when the establishing the tunnel for the VPN connection. By default, your customer gateway device must initiate the IKE negotiation and bring up the tunnel. Specify ``start`` for AWS to initiate the IKE negotiation.
                Valid Values: ``add`` | ``start``
                Default: ``add``
        :param _builtins.str tunnel_inside_cidr: The range of inside IP addresses for the tunnel. Any specified CIDR blocks must be unique across all VPN connections that use the same virtual private gateway. 
                Constraints: A size /30 CIDR block from the ``169.254.0.0/16`` range. The following CIDR blocks are reserved and cannot be used:
                 +   ``169.254.0.0/30`` 
                 +   ``169.254.1.0/30`` 
                 +   ``169.254.2.0/30`` 
                 +   ``169.254.3.0/30`` 
                 +   ``169.254.4.0/30`` 
                 +   ``169.254.5.0/30`` 
                 +   ``169.254.169.252/30``
        :param _builtins.str tunnel_inside_ipv6_cidr: The range of inside IPv6 addresses for the tunnel. Any specified CIDR blocks must be unique across all VPN connections that use the same transit gateway.
                Constraints: A size /126 CIDR block from the local ``fd00::/8`` range.
        """
        if dpd_timeout_action is not None:
            pulumi.set(__self__, "dpd_timeout_action", dpd_timeout_action)
        if dpd_timeout_seconds is not None:
            pulumi.set(__self__, "dpd_timeout_seconds", dpd_timeout_seconds)
        if enable_tunnel_lifecycle_control is not None:
            pulumi.set(__self__, "enable_tunnel_lifecycle_control", enable_tunnel_lifecycle_control)
        if ike_versions is not None:
            pulumi.set(__self__, "ike_versions", ike_versions)
        if log_options is not None:
            pulumi.set(__self__, "log_options", log_options)
        if phase1_encryption_algorithms is not None:
            pulumi.set(__self__, "phase1_encryption_algorithms", phase1_encryption_algorithms)
        if phase1_integrity_algorithms is not None:
            pulumi.set(__self__, "phase1_integrity_algorithms", phase1_integrity_algorithms)
        if phase1_lifetime_seconds is not None:
            pulumi.set(__self__, "phase1_lifetime_seconds", phase1_lifetime_seconds)
        if phase1dh_group_numbers is not None:
            pulumi.set(__self__, "phase1dh_group_numbers", phase1dh_group_numbers)
        if phase2_encryption_algorithms is not None:
            pulumi.set(__self__, "phase2_encryption_algorithms", phase2_encryption_algorithms)
        if phase2_integrity_algorithms is not None:
            pulumi.set(__self__, "phase2_integrity_algorithms", phase2_integrity_algorithms)
        if phase2_lifetime_seconds is not None:
            pulumi.set(__self__, "phase2_lifetime_seconds", phase2_lifetime_seconds)
        if phase2dh_group_numbers is not None:
            pulumi.set(__self__, "phase2dh_group_numbers", phase2dh_group_numbers)
        if pre_shared_key is not None:
            pulumi.set(__self__, "pre_shared_key", pre_shared_key)
        if rekey_fuzz_percentage is not None:
            pulumi.set(__self__, "rekey_fuzz_percentage", rekey_fuzz_percentage)
        if rekey_margin_time_seconds is not None:
            pulumi.set(__self__, "rekey_margin_time_seconds", rekey_margin_time_seconds)
        if replay_window_size is not None:
            pulumi.set(__self__, "replay_window_size", replay_window_size)
        if startup_action is not None:
            pulumi.set(__self__, "startup_action", startup_action)
        if tunnel_inside_cidr is not None:
            pulumi.set(__self__, "tunnel_inside_cidr", tunnel_inside_cidr)
        if tunnel_inside_ipv6_cidr is not None:
            pulumi.set(__self__, "tunnel_inside_ipv6_cidr", tunnel_inside_ipv6_cidr)

    @_builtins.property
    @pulumi.getter(name="dpdTimeoutAction")
    def dpd_timeout_action(self) -> Optional['VpnConnectionVpnTunnelOptionsSpecificationDpdTimeoutAction']:
        """
        The action to take after DPD timeout occurs. Specify ``restart`` to restart the IKE initiation. Specify ``clear`` to end the IKE session.
         Valid Values: ``clear`` | ``none`` | ``restart``
         Default: ``clear``
        """
        return pulumi.get(self, "dpd_timeout_action")

    @_builtins.property
    @pulumi.getter(name="dpdTimeoutSeconds")
    def dpd_timeout_seconds(self) -> Optional[_builtins.int]:
        """
        The number of seconds after which a DPD timeout occurs.
         Constraints: A value greater than or equal to 30.
         Default: ``30``
        """
        return pulumi.get(self, "dpd_timeout_seconds")

    @_builtins.property
    @pulumi.getter(name="enableTunnelLifecycleControl")
    def enable_tunnel_lifecycle_control(self) -> Optional[_builtins.bool]:
        """
        Turn on or off tunnel endpoint lifecycle control feature.
        """
        return pulumi.get(self, "enable_tunnel_lifecycle_control")

    @_builtins.property
    @pulumi.getter(name="ikeVersions")
    def ike_versions(self) -> Optional[Sequence['outputs.VpnConnectionIkeVersionsRequestListValue']]:
        """
        The IKE versions that are permitted for the VPN tunnel.
         Valid values: ``ikev1`` | ``ikev2``
        """
        return pulumi.get(self, "ike_versions")

    @_builtins.property
    @pulumi.getter(name="logOptions")
    def log_options(self) -> Optional['outputs.VpnConnectionVpnTunnelLogOptionsSpecification']:
        """
        Options for logging VPN tunnel activity.
        """
        return pulumi.get(self, "log_options")

    @_builtins.property
    @pulumi.getter(name="phase1EncryptionAlgorithms")
    def phase1_encryption_algorithms(self) -> Optional[Sequence['outputs.VpnConnectionPhase1EncryptionAlgorithmsRequestListValue']]:
        """
        One or more encryption algorithms that are permitted for the VPN tunnel for phase 1 IKE negotiations.
         Valid values: ``AES128`` | ``AES256`` | ``AES128-GCM-16`` | ``AES256-GCM-16``
        """
        return pulumi.get(self, "phase1_encryption_algorithms")

    @_builtins.property
    @pulumi.getter(name="phase1IntegrityAlgorithms")
    def phase1_integrity_algorithms(self) -> Optional[Sequence['outputs.VpnConnectionPhase1IntegrityAlgorithmsRequestListValue']]:
        """
        One or more integrity algorithms that are permitted for the VPN tunnel for phase 1 IKE negotiations.
         Valid values: ``SHA1`` | ``SHA2-256`` | ``SHA2-384`` | ``SHA2-512``
        """
        return pulumi.get(self, "phase1_integrity_algorithms")

    @_builtins.property
    @pulumi.getter(name="phase1LifetimeSeconds")
    def phase1_lifetime_seconds(self) -> Optional[_builtins.int]:
        """
        The lifetime for phase 1 of the IKE negotiation, in seconds.
         Constraints: A value between 900 and 28,800.
         Default: ``28800``
        """
        return pulumi.get(self, "phase1_lifetime_seconds")

    @_builtins.property
    @pulumi.getter(name="phase1dhGroupNumbers")
    def phase1dh_group_numbers(self) -> Optional[Sequence['outputs.VpnConnectionPhase1dhGroupNumbersRequestListValue']]:
        """
        One or more Diffie-Hellman group numbers that are permitted for the VPN tunnel for phase 1 IKE negotiations.
         Valid values: ``2`` | ``14`` | ``15`` | ``16`` | ``17`` | ``18`` | ``19`` | ``20`` | ``21`` | ``22`` | ``23`` | ``24``
        """
        return pulumi.get(self, "phase1dh_group_numbers")

    @_builtins.property
    @pulumi.getter(name="phase2EncryptionAlgorithms")
    def phase2_encryption_algorithms(self) -> Optional[Sequence['outputs.VpnConnectionPhase2EncryptionAlgorithmsRequestListValue']]:
        """
        One or more encryption algorithms that are permitted for the VPN tunnel for phase 2 IKE negotiations.
         Valid values: ``AES128`` | ``AES256`` | ``AES128-GCM-16`` | ``AES256-GCM-16``
        """
        return pulumi.get(self, "phase2_encryption_algorithms")

    @_builtins.property
    @pulumi.getter(name="phase2IntegrityAlgorithms")
    def phase2_integrity_algorithms(self) -> Optional[Sequence['outputs.VpnConnectionPhase2IntegrityAlgorithmsRequestListValue']]:
        """
        One or more integrity algorithms that are permitted for the VPN tunnel for phase 2 IKE negotiations.
         Valid values: ``SHA1`` | ``SHA2-256`` | ``SHA2-384`` | ``SHA2-512``
        """
        return pulumi.get(self, "phase2_integrity_algorithms")

    @_builtins.property
    @pulumi.getter(name="phase2LifetimeSeconds")
    def phase2_lifetime_seconds(self) -> Optional[_builtins.int]:
        """
        The lifetime for phase 2 of the IKE negotiation, in seconds.
         Constraints: A value between 900 and 3,600. The value must be less than the value for ``Phase1LifetimeSeconds``.
         Default: ``3600``
        """
        return pulumi.get(self, "phase2_lifetime_seconds")

    @_builtins.property
    @pulumi.getter(name="phase2dhGroupNumbers")
    def phase2dh_group_numbers(self) -> Optional[Sequence['outputs.VpnConnectionPhase2dhGroupNumbersRequestListValue']]:
        """
        One or more Diffie-Hellman group numbers that are permitted for the VPN tunnel for phase 2 IKE negotiations.
         Valid values: ``2`` | ``5`` | ``14`` | ``15`` | ``16`` | ``17`` | ``18`` | ``19`` | ``20`` | ``21`` | ``22`` | ``23`` | ``24``
        """
        return pulumi.get(self, "phase2dh_group_numbers")

    @_builtins.property
    @pulumi.getter(name="preSharedKey")
    def pre_shared_key(self) -> Optional[_builtins.str]:
        """
        The pre-shared key (PSK) to establish initial authentication between the virtual private gateway and customer gateway.
         Constraints: Allowed characters are alphanumeric characters, periods (.), and underscores (_). Must be between 8 and 64 characters in length and cannot start with zero (0).
        """
        return pulumi.get(self, "pre_shared_key")

    @_builtins.property
    @pulumi.getter(name="rekeyFuzzPercentage")
    def rekey_fuzz_percentage(self) -> Optional[_builtins.int]:
        """
        The percentage of the rekey window (determined by ``RekeyMarginTimeSeconds``) during which the rekey time is randomly selected.
         Constraints: A value between 0 and 100.
         Default: ``100``
        """
        return pulumi.get(self, "rekey_fuzz_percentage")

    @_builtins.property
    @pulumi.getter(name="rekeyMarginTimeSeconds")
    def rekey_margin_time_seconds(self) -> Optional[_builtins.int]:
        """
        The margin time, in seconds, before the phase 2 lifetime expires, during which the AWS side of the VPN connection performs an IKE rekey. The exact time of the rekey is randomly selected based on the value for ``RekeyFuzzPercentage``.
         Constraints: A value between 60 and half of ``Phase2LifetimeSeconds``.
         Default: ``270``
        """
        return pulumi.get(self, "rekey_margin_time_seconds")

    @_builtins.property
    @pulumi.getter(name="replayWindowSize")
    def replay_window_size(self) -> Optional[_builtins.int]:
        """
        The number of packets in an IKE replay window.
         Constraints: A value between 64 and 2048.
         Default: ``1024``
        """
        return pulumi.get(self, "replay_window_size")

    @_builtins.property
    @pulumi.getter(name="startupAction")
    def startup_action(self) -> Optional['VpnConnectionVpnTunnelOptionsSpecificationStartupAction']:
        """
        The action to take when the establishing the tunnel for the VPN connection. By default, your customer gateway device must initiate the IKE negotiation and bring up the tunnel. Specify ``start`` for AWS to initiate the IKE negotiation.
         Valid Values: ``add`` | ``start``
         Default: ``add``
        """
        return pulumi.get(self, "startup_action")

    @_builtins.property
    @pulumi.getter(name="tunnelInsideCidr")
    def tunnel_inside_cidr(self) -> Optional[_builtins.str]:
        """
        The range of inside IP addresses for the tunnel. Any specified CIDR blocks must be unique across all VPN connections that use the same virtual private gateway. 
         Constraints: A size /30 CIDR block from the ``169.254.0.0/16`` range. The following CIDR blocks are reserved and cannot be used:
          +   ``169.254.0.0/30`` 
          +   ``169.254.1.0/30`` 
          +   ``169.254.2.0/30`` 
          +   ``169.254.3.0/30`` 
          +   ``169.254.4.0/30`` 
          +   ``169.254.5.0/30`` 
          +   ``169.254.169.252/30``
        """
        return pulumi.get(self, "tunnel_inside_cidr")

    @_builtins.property
    @pulumi.getter(name="tunnelInsideIpv6Cidr")
    def tunnel_inside_ipv6_cidr(self) -> Optional[_builtins.str]:
        """
        The range of inside IPv6 addresses for the tunnel. Any specified CIDR blocks must be unique across all VPN connections that use the same transit gateway.
         Constraints: A size /126 CIDR block from the local ``fd00::/8`` range.
        """
        return pulumi.get(self, "tunnel_inside_ipv6_cidr")


