# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'CapacityReservationFleetInstanceTypeSpecification',
    'CapacityReservationFleetTag',
    'CapacityReservationFleetTagSpecification',
    'CapacityReservationTag',
    'CapacityReservationTagSpecification',
    'CarrierGatewayTag',
    'ClientVpnEndpointCertificateAuthenticationRequest',
    'ClientVpnEndpointClientAuthenticationRequest',
    'ClientVpnEndpointClientConnectOptions',
    'ClientVpnEndpointClientLoginBannerOptions',
    'ClientVpnEndpointConnectionLogOptions',
    'ClientVpnEndpointDirectoryServiceAuthenticationRequest',
    'ClientVpnEndpointFederatedAuthenticationRequest',
    'ClientVpnEndpointTag',
    'ClientVpnEndpointTagSpecification',
    'CustomerGatewayTag',
    'DestinationOptionsProperties',
    'DhcpOptionsTag',
    'Ec2FleetAcceleratorCountRequest',
    'Ec2FleetAcceleratorTotalMemoryMiBRequest',
    'Ec2FleetBaselineEbsBandwidthMbpsRequest',
    'Ec2FleetCapacityRebalance',
    'Ec2FleetCapacityReservationOptionsRequest',
    'Ec2FleetFleetLaunchTemplateConfigRequest',
    'Ec2FleetFleetLaunchTemplateOverridesRequest',
    'Ec2FleetFleetLaunchTemplateSpecificationRequest',
    'Ec2FleetInstanceRequirementsRequest',
    'Ec2FleetMaintenanceStrategies',
    'Ec2FleetMemoryGiBPerVCpuRequest',
    'Ec2FleetMemoryMiBRequest',
    'Ec2FleetNetworkBandwidthGbpsRequest',
    'Ec2FleetNetworkInterfaceCountRequest',
    'Ec2FleetOnDemandOptionsRequest',
    'Ec2FleetPlacement',
    'Ec2FleetSpotOptionsRequest',
    'Ec2FleetTag',
    'Ec2FleetTagSpecification',
    'Ec2FleetTargetCapacitySpecificationRequest',
    'Ec2FleetTotalLocalStorageGbRequest',
    'Ec2FleetVCpuCountRangeRequest',
    'EipTag',
    'FlowLogTag',
    'InstanceAssociationParameter',
    'InstanceBlockDeviceMapping',
    'InstanceConnectEndpointTag',
    'InstanceCpuOptions',
    'InstanceCreditSpecification',
    'InstanceEbs',
    'InstanceElasticGpuSpecification',
    'InstanceElasticInferenceAccelerator',
    'InstanceEnclaveOptions',
    'InstanceHibernationOptions',
    'InstanceIpv6Address',
    'InstanceLaunchTemplateSpecification',
    'InstanceLicenseSpecification',
    'InstanceNetworkInterface',
    'InstanceNoDevice',
    'InstancePrivateDnsNameOptions',
    'InstancePrivateIpAddressSpecification',
    'InstanceSsmAssociation',
    'InstanceTag',
    'InstanceVolume',
    'InternetGatewayTag',
    'IpamOperatingRegion',
    'IpamPoolProvisionedCidr',
    'IpamPoolTag',
    'IpamResourceDiscoveryAssociationTag',
    'IpamResourceDiscoveryIpamOperatingRegion',
    'IpamResourceDiscoveryTag',
    'IpamScopeTag',
    'IpamTag',
    'KeyPairTag',
    'LaunchTemplateAcceleratorCount',
    'LaunchTemplateAcceleratorTotalMemoryMiB',
    'LaunchTemplateBaselineEbsBandwidthMbps',
    'LaunchTemplateBlockDeviceMapping',
    'LaunchTemplateCapacityReservationSpecification',
    'LaunchTemplateCapacityReservationTarget',
    'LaunchTemplateCpuOptions',
    'LaunchTemplateCreditSpecification',
    'LaunchTemplateData',
    'LaunchTemplateEbs',
    'LaunchTemplateElasticGpuSpecification',
    'LaunchTemplateElasticInferenceAccelerator',
    'LaunchTemplateEnclaveOptions',
    'LaunchTemplateHibernationOptions',
    'LaunchTemplateIamInstanceProfile',
    'LaunchTemplateInstanceMarketOptions',
    'LaunchTemplateInstanceRequirements',
    'LaunchTemplateIpv4PrefixSpecification',
    'LaunchTemplateIpv6Add',
    'LaunchTemplateIpv6PrefixSpecification',
    'LaunchTemplateLicenseSpecification',
    'LaunchTemplateMaintenanceOptions',
    'LaunchTemplateMemoryGiBPerVCpu',
    'LaunchTemplateMemoryMiB',
    'LaunchTemplateMetadataOptions',
    'LaunchTemplateMonitoring',
    'LaunchTemplateNetworkBandwidthGbps',
    'LaunchTemplateNetworkInterface',
    'LaunchTemplateNetworkInterfaceCount',
    'LaunchTemplatePlacement',
    'LaunchTemplatePrivateDnsNameOptions',
    'LaunchTemplatePrivateIpAdd',
    'LaunchTemplateSpotOptions',
    'LaunchTemplateTag',
    'LaunchTemplateTagSpecification',
    'LaunchTemplateTotalLocalStorageGb',
    'LaunchTemplateVCpuCount',
    'LocalGatewayRouteTableTag',
    'LocalGatewayRouteTableVirtualInterfaceGroupAssociationTag',
    'LocalGatewayRouteTableVpcAssociationTag',
    'NatGatewayTag',
    'NetworkAclEntryIcmp',
    'NetworkAclEntryPortRange',
    'NetworkAclTag',
    'NetworkInsightsAccessScopeAccessScopePathRequest',
    'NetworkInsightsAccessScopeAnalysisTag',
    'NetworkInsightsAccessScopePacketHeaderStatementRequest',
    'NetworkInsightsAccessScopePathStatementRequest',
    'NetworkInsightsAccessScopeResourceStatementRequest',
    'NetworkInsightsAccessScopeTag',
    'NetworkInsightsAccessScopeThroughResourcesStatementRequest',
    'NetworkInsightsAnalysisAdditionalDetail',
    'NetworkInsightsAnalysisAlternatePathHint',
    'NetworkInsightsAnalysisAnalysisAclRule',
    'NetworkInsightsAnalysisAnalysisComponent',
    'NetworkInsightsAnalysisAnalysisLoadBalancerListener',
    'NetworkInsightsAnalysisAnalysisLoadBalancerTarget',
    'NetworkInsightsAnalysisAnalysisPacketHeader',
    'NetworkInsightsAnalysisAnalysisRouteTableRoute',
    'NetworkInsightsAnalysisAnalysisSecurityGroupRule',
    'NetworkInsightsAnalysisExplanation',
    'NetworkInsightsAnalysisPathComponent',
    'NetworkInsightsAnalysisPortRange',
    'NetworkInsightsAnalysisTag',
    'NetworkInsightsAnalysisTransitGatewayRouteTableRoute',
    'NetworkInsightsPathFilterPortRange',
    'NetworkInsightsPathPathFilter',
    'NetworkInsightsPathTag',
    'NetworkInterfaceInstanceIpv6Address',
    'NetworkInterfaceIpv4PrefixSpecification',
    'NetworkInterfaceIpv6PrefixSpecification',
    'NetworkInterfacePrivateIpAddressSpecification',
    'NetworkInterfaceTag',
    'OptionsProperties',
    'PlacementGroupTag',
    'PrefixListEntry',
    'PrefixListTag',
    'PrivateDnsNameOptionsOnLaunchProperties',
    'RouteTableTag',
    'SecurityGroupEgress',
    'SecurityGroupIngress',
    'SecurityGroupTag',
    'SpotFleetAcceleratorCountRequest',
    'SpotFleetAcceleratorTotalMemoryMiBRequest',
    'SpotFleetBaselineEbsBandwidthMbpsRequest',
    'SpotFleetBlockDeviceMapping',
    'SpotFleetClassicLoadBalancer',
    'SpotFleetClassicLoadBalancersConfig',
    'SpotFleetEbsBlockDevice',
    'SpotFleetFleetLaunchTemplateSpecification',
    'SpotFleetGroupIdentifier',
    'SpotFleetIamInstanceProfileSpecification',
    'SpotFleetInstanceIpv6Address',
    'SpotFleetInstanceNetworkInterfaceSpecification',
    'SpotFleetInstanceRequirementsRequest',
    'SpotFleetLaunchSpecification',
    'SpotFleetLaunchTemplateConfig',
    'SpotFleetLaunchTemplateOverrides',
    'SpotFleetLoadBalancersConfig',
    'SpotFleetMemoryGiBPerVCpuRequest',
    'SpotFleetMemoryMiBRequest',
    'SpotFleetMonitoring',
    'SpotFleetNetworkBandwidthGbpsRequest',
    'SpotFleetNetworkInterfaceCountRequest',
    'SpotFleetPrivateIpAddressSpecification',
    'SpotFleetRequestConfigData',
    'SpotFleetSpotCapacityRebalance',
    'SpotFleetSpotMaintenanceStrategies',
    'SpotFleetSpotPlacement',
    'SpotFleetTag',
    'SpotFleetTagSpecification',
    'SpotFleetTargetGroup',
    'SpotFleetTargetGroupsConfig',
    'SpotFleetTotalLocalStorageGbRequest',
    'SpotFleetVCpuCountRangeRequest',
    'SseSpecificationProperties',
    'SubnetTag',
    'TagSpecification',
    'TrafficMirrorFilterRuleTrafficMirrorPortRange',
    'TrafficMirrorFilterTag',
    'TrafficMirrorSessionTag',
    'TrafficMirrorTargetTag',
    'TransitGatewayAttachmentTag',
    'TransitGatewayConnectOptions',
    'TransitGatewayConnectTag',
    'TransitGatewayMulticastDomainTag',
    'TransitGatewayPeeringAttachmentPeeringAttachmentStatus',
    'TransitGatewayPeeringAttachmentTag',
    'TransitGatewayRouteTableTag',
    'TransitGatewayTag',
    'TransitGatewayVpcAttachmentTag',
    'VerifiedAccessEndpointLoadBalancerOptions',
    'VerifiedAccessEndpointNetworkInterfaceOptions',
    'VerifiedAccessEndpointSseSpecification',
    'VerifiedAccessEndpointTag',
    'VerifiedAccessGroupSseSpecification',
    'VerifiedAccessGroupTag',
    'VerifiedAccessInstanceTag',
    'VerifiedAccessInstanceVerifiedAccessLogs',
    'VerifiedAccessInstanceVerifiedAccessLogsCloudWatchLogsProperties',
    'VerifiedAccessInstanceVerifiedAccessLogsKinesisDataFirehoseProperties',
    'VerifiedAccessInstanceVerifiedAccessLogsS3Properties',
    'VerifiedAccessInstanceVerifiedAccessTrustProvider',
    'VerifiedAccessTrustProviderDeviceOptions',
    'VerifiedAccessTrustProviderOidcOptions',
    'VerifiedAccessTrustProviderTag',
    'VolumeTag',
    'VpcPeeringConnectionTag',
    'VpcTag',
    'VpnConnectionTag',
    'VpnConnectionVpnTunnelOptionsSpecification',
    'VpnGatewayTag',
]

@pulumi.output_type
class CapacityReservationFleetInstanceTypeSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "availabilityZoneId":
            suggest = "availability_zone_id"
        elif key == "ebsOptimized":
            suggest = "ebs_optimized"
        elif key == "instancePlatform":
            suggest = "instance_platform"
        elif key == "instanceType":
            suggest = "instance_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CapacityReservationFleetInstanceTypeSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CapacityReservationFleetInstanceTypeSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CapacityReservationFleetInstanceTypeSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone: Optional[str] = None,
                 availability_zone_id: Optional[str] = None,
                 ebs_optimized: Optional[bool] = None,
                 instance_platform: Optional[str] = None,
                 instance_type: Optional[str] = None,
                 priority: Optional[int] = None,
                 weight: Optional[float] = None):
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if availability_zone_id is not None:
            pulumi.set(__self__, "availability_zone_id", availability_zone_id)
        if ebs_optimized is not None:
            pulumi.set(__self__, "ebs_optimized", ebs_optimized)
        if instance_platform is not None:
            pulumi.set(__self__, "instance_platform", instance_platform)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[str]:
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="availabilityZoneId")
    def availability_zone_id(self) -> Optional[str]:
        return pulumi.get(self, "availability_zone_id")

    @property
    @pulumi.getter(name="ebsOptimized")
    def ebs_optimized(self) -> Optional[bool]:
        return pulumi.get(self, "ebs_optimized")

    @property
    @pulumi.getter(name="instancePlatform")
    def instance_platform(self) -> Optional[str]:
        return pulumi.get(self, "instance_platform")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[str]:
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def weight(self) -> Optional[float]:
        return pulumi.get(self, "weight")


@pulumi.output_type
class CapacityReservationFleetTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class CapacityReservationFleetTagSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CapacityReservationFleetTagSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CapacityReservationFleetTagSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CapacityReservationFleetTagSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_type: Optional[str] = None,
                 tags: Optional[Sequence['outputs.CapacityReservationFleetTag']] = None):
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[str]:
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.CapacityReservationFleetTag']]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class CapacityReservationTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class CapacityReservationTagSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CapacityReservationTagSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CapacityReservationTagSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CapacityReservationTagSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_type: Optional[str] = None,
                 tags: Optional[Sequence['outputs.CapacityReservationTag']] = None):
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[str]:
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.CapacityReservationTag']]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class CarrierGatewayTag(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ClientVpnEndpointCertificateAuthenticationRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientRootCertificateChainArn":
            suggest = "client_root_certificate_chain_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientVpnEndpointCertificateAuthenticationRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientVpnEndpointCertificateAuthenticationRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientVpnEndpointCertificateAuthenticationRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_root_certificate_chain_arn: str):
        pulumi.set(__self__, "client_root_certificate_chain_arn", client_root_certificate_chain_arn)

    @property
    @pulumi.getter(name="clientRootCertificateChainArn")
    def client_root_certificate_chain_arn(self) -> str:
        return pulumi.get(self, "client_root_certificate_chain_arn")


@pulumi.output_type
class ClientVpnEndpointClientAuthenticationRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDirectory":
            suggest = "active_directory"
        elif key == "federatedAuthentication":
            suggest = "federated_authentication"
        elif key == "mutualAuthentication":
            suggest = "mutual_authentication"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientVpnEndpointClientAuthenticationRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientVpnEndpointClientAuthenticationRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientVpnEndpointClientAuthenticationRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 active_directory: Optional['outputs.ClientVpnEndpointDirectoryServiceAuthenticationRequest'] = None,
                 federated_authentication: Optional['outputs.ClientVpnEndpointFederatedAuthenticationRequest'] = None,
                 mutual_authentication: Optional['outputs.ClientVpnEndpointCertificateAuthenticationRequest'] = None):
        pulumi.set(__self__, "type", type)
        if active_directory is not None:
            pulumi.set(__self__, "active_directory", active_directory)
        if federated_authentication is not None:
            pulumi.set(__self__, "federated_authentication", federated_authentication)
        if mutual_authentication is not None:
            pulumi.set(__self__, "mutual_authentication", mutual_authentication)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="activeDirectory")
    def active_directory(self) -> Optional['outputs.ClientVpnEndpointDirectoryServiceAuthenticationRequest']:
        return pulumi.get(self, "active_directory")

    @property
    @pulumi.getter(name="federatedAuthentication")
    def federated_authentication(self) -> Optional['outputs.ClientVpnEndpointFederatedAuthenticationRequest']:
        return pulumi.get(self, "federated_authentication")

    @property
    @pulumi.getter(name="mutualAuthentication")
    def mutual_authentication(self) -> Optional['outputs.ClientVpnEndpointCertificateAuthenticationRequest']:
        return pulumi.get(self, "mutual_authentication")


@pulumi.output_type
class ClientVpnEndpointClientConnectOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lambdaFunctionArn":
            suggest = "lambda_function_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientVpnEndpointClientConnectOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientVpnEndpointClientConnectOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientVpnEndpointClientConnectOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 lambda_function_arn: Optional[str] = None):
        pulumi.set(__self__, "enabled", enabled)
        if lambda_function_arn is not None:
            pulumi.set(__self__, "lambda_function_arn", lambda_function_arn)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="lambdaFunctionArn")
    def lambda_function_arn(self) -> Optional[str]:
        return pulumi.get(self, "lambda_function_arn")


@pulumi.output_type
class ClientVpnEndpointClientLoginBannerOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bannerText":
            suggest = "banner_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientVpnEndpointClientLoginBannerOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientVpnEndpointClientLoginBannerOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientVpnEndpointClientLoginBannerOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 banner_text: Optional[str] = None):
        pulumi.set(__self__, "enabled", enabled)
        if banner_text is not None:
            pulumi.set(__self__, "banner_text", banner_text)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="bannerText")
    def banner_text(self) -> Optional[str]:
        return pulumi.get(self, "banner_text")


@pulumi.output_type
class ClientVpnEndpointConnectionLogOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudwatchLogGroup":
            suggest = "cloudwatch_log_group"
        elif key == "cloudwatchLogStream":
            suggest = "cloudwatch_log_stream"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientVpnEndpointConnectionLogOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientVpnEndpointConnectionLogOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientVpnEndpointConnectionLogOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 cloudwatch_log_group: Optional[str] = None,
                 cloudwatch_log_stream: Optional[str] = None):
        pulumi.set(__self__, "enabled", enabled)
        if cloudwatch_log_group is not None:
            pulumi.set(__self__, "cloudwatch_log_group", cloudwatch_log_group)
        if cloudwatch_log_stream is not None:
            pulumi.set(__self__, "cloudwatch_log_stream", cloudwatch_log_stream)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="cloudwatchLogGroup")
    def cloudwatch_log_group(self) -> Optional[str]:
        return pulumi.get(self, "cloudwatch_log_group")

    @property
    @pulumi.getter(name="cloudwatchLogStream")
    def cloudwatch_log_stream(self) -> Optional[str]:
        return pulumi.get(self, "cloudwatch_log_stream")


@pulumi.output_type
class ClientVpnEndpointDirectoryServiceAuthenticationRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "directoryId":
            suggest = "directory_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientVpnEndpointDirectoryServiceAuthenticationRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientVpnEndpointDirectoryServiceAuthenticationRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientVpnEndpointDirectoryServiceAuthenticationRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 directory_id: str):
        pulumi.set(__self__, "directory_id", directory_id)

    @property
    @pulumi.getter(name="directoryId")
    def directory_id(self) -> str:
        return pulumi.get(self, "directory_id")


@pulumi.output_type
class ClientVpnEndpointFederatedAuthenticationRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "samlProviderArn":
            suggest = "saml_provider_arn"
        elif key == "selfServiceSamlProviderArn":
            suggest = "self_service_saml_provider_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientVpnEndpointFederatedAuthenticationRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientVpnEndpointFederatedAuthenticationRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientVpnEndpointFederatedAuthenticationRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 saml_provider_arn: str,
                 self_service_saml_provider_arn: Optional[str] = None):
        pulumi.set(__self__, "saml_provider_arn", saml_provider_arn)
        if self_service_saml_provider_arn is not None:
            pulumi.set(__self__, "self_service_saml_provider_arn", self_service_saml_provider_arn)

    @property
    @pulumi.getter(name="samlProviderArn")
    def saml_provider_arn(self) -> str:
        return pulumi.get(self, "saml_provider_arn")

    @property
    @pulumi.getter(name="selfServiceSamlProviderArn")
    def self_service_saml_provider_arn(self) -> Optional[str]:
        return pulumi.get(self, "self_service_saml_provider_arn")


@pulumi.output_type
class ClientVpnEndpointTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class ClientVpnEndpointTagSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClientVpnEndpointTagSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClientVpnEndpointTagSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClientVpnEndpointTagSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_type: str,
                 tags: Sequence['outputs.ClientVpnEndpointTag']):
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> str:
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.ClientVpnEndpointTag']:
        return pulumi.get(self, "tags")


@pulumi.output_type
class CustomerGatewayTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class DestinationOptionsProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileFormat":
            suggest = "file_format"
        elif key == "hiveCompatiblePartitions":
            suggest = "hive_compatible_partitions"
        elif key == "perHourPartition":
            suggest = "per_hour_partition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationOptionsProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationOptionsProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationOptionsProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_format: 'FlowLogDestinationOptionsPropertiesFileFormat',
                 hive_compatible_partitions: bool,
                 per_hour_partition: bool):
        pulumi.set(__self__, "file_format", file_format)
        pulumi.set(__self__, "hive_compatible_partitions", hive_compatible_partitions)
        pulumi.set(__self__, "per_hour_partition", per_hour_partition)

    @property
    @pulumi.getter(name="fileFormat")
    def file_format(self) -> 'FlowLogDestinationOptionsPropertiesFileFormat':
        return pulumi.get(self, "file_format")

    @property
    @pulumi.getter(name="hiveCompatiblePartitions")
    def hive_compatible_partitions(self) -> bool:
        return pulumi.get(self, "hive_compatible_partitions")

    @property
    @pulumi.getter(name="perHourPartition")
    def per_hour_partition(self) -> bool:
        return pulumi.get(self, "per_hour_partition")


@pulumi.output_type
class DhcpOptionsTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class Ec2FleetAcceleratorCountRequest(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class Ec2FleetAcceleratorTotalMemoryMiBRequest(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class Ec2FleetBaselineEbsBandwidthMbpsRequest(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class Ec2FleetCapacityRebalance(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replacementStrategy":
            suggest = "replacement_strategy"
        elif key == "terminationDelay":
            suggest = "termination_delay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2FleetCapacityRebalance. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2FleetCapacityRebalance.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2FleetCapacityRebalance.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 replacement_strategy: Optional['Ec2FleetCapacityRebalanceReplacementStrategy'] = None,
                 termination_delay: Optional[int] = None):
        if replacement_strategy is not None:
            pulumi.set(__self__, "replacement_strategy", replacement_strategy)
        if termination_delay is not None:
            pulumi.set(__self__, "termination_delay", termination_delay)

    @property
    @pulumi.getter(name="replacementStrategy")
    def replacement_strategy(self) -> Optional['Ec2FleetCapacityRebalanceReplacementStrategy']:
        return pulumi.get(self, "replacement_strategy")

    @property
    @pulumi.getter(name="terminationDelay")
    def termination_delay(self) -> Optional[int]:
        return pulumi.get(self, "termination_delay")


@pulumi.output_type
class Ec2FleetCapacityReservationOptionsRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "usageStrategy":
            suggest = "usage_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2FleetCapacityReservationOptionsRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2FleetCapacityReservationOptionsRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2FleetCapacityReservationOptionsRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 usage_strategy: Optional['Ec2FleetCapacityReservationOptionsRequestUsageStrategy'] = None):
        if usage_strategy is not None:
            pulumi.set(__self__, "usage_strategy", usage_strategy)

    @property
    @pulumi.getter(name="usageStrategy")
    def usage_strategy(self) -> Optional['Ec2FleetCapacityReservationOptionsRequestUsageStrategy']:
        return pulumi.get(self, "usage_strategy")


@pulumi.output_type
class Ec2FleetFleetLaunchTemplateConfigRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTemplateSpecification":
            suggest = "launch_template_specification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2FleetFleetLaunchTemplateConfigRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2FleetFleetLaunchTemplateConfigRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2FleetFleetLaunchTemplateConfigRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 launch_template_specification: Optional['outputs.Ec2FleetFleetLaunchTemplateSpecificationRequest'] = None,
                 overrides: Optional[Sequence['outputs.Ec2FleetFleetLaunchTemplateOverridesRequest']] = None):
        if launch_template_specification is not None:
            pulumi.set(__self__, "launch_template_specification", launch_template_specification)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)

    @property
    @pulumi.getter(name="launchTemplateSpecification")
    def launch_template_specification(self) -> Optional['outputs.Ec2FleetFleetLaunchTemplateSpecificationRequest']:
        return pulumi.get(self, "launch_template_specification")

    @property
    @pulumi.getter
    def overrides(self) -> Optional[Sequence['outputs.Ec2FleetFleetLaunchTemplateOverridesRequest']]:
        return pulumi.get(self, "overrides")


@pulumi.output_type
class Ec2FleetFleetLaunchTemplateOverridesRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "instanceRequirements":
            suggest = "instance_requirements"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "maxPrice":
            suggest = "max_price"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "weightedCapacity":
            suggest = "weighted_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2FleetFleetLaunchTemplateOverridesRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2FleetFleetLaunchTemplateOverridesRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2FleetFleetLaunchTemplateOverridesRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone: Optional[str] = None,
                 instance_requirements: Optional['outputs.Ec2FleetInstanceRequirementsRequest'] = None,
                 instance_type: Optional[str] = None,
                 max_price: Optional[str] = None,
                 placement: Optional['outputs.Ec2FleetPlacement'] = None,
                 priority: Optional[float] = None,
                 subnet_id: Optional[str] = None,
                 weighted_capacity: Optional[float] = None):
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if instance_requirements is not None:
            pulumi.set(__self__, "instance_requirements", instance_requirements)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if max_price is not None:
            pulumi.set(__self__, "max_price", max_price)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if weighted_capacity is not None:
            pulumi.set(__self__, "weighted_capacity", weighted_capacity)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[str]:
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="instanceRequirements")
    def instance_requirements(self) -> Optional['outputs.Ec2FleetInstanceRequirementsRequest']:
        return pulumi.get(self, "instance_requirements")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[str]:
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="maxPrice")
    def max_price(self) -> Optional[str]:
        return pulumi.get(self, "max_price")

    @property
    @pulumi.getter
    def placement(self) -> Optional['outputs.Ec2FleetPlacement']:
        return pulumi.get(self, "placement")

    @property
    @pulumi.getter
    def priority(self) -> Optional[float]:
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="weightedCapacity")
    def weighted_capacity(self) -> Optional[float]:
        return pulumi.get(self, "weighted_capacity")


@pulumi.output_type
class Ec2FleetFleetLaunchTemplateSpecificationRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTemplateId":
            suggest = "launch_template_id"
        elif key == "launchTemplateName":
            suggest = "launch_template_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2FleetFleetLaunchTemplateSpecificationRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2FleetFleetLaunchTemplateSpecificationRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2FleetFleetLaunchTemplateSpecificationRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 version: str,
                 launch_template_id: Optional[str] = None,
                 launch_template_name: Optional[str] = None):
        pulumi.set(__self__, "version", version)
        if launch_template_id is not None:
            pulumi.set(__self__, "launch_template_id", launch_template_id)
        if launch_template_name is not None:
            pulumi.set(__self__, "launch_template_name", launch_template_name)

    @property
    @pulumi.getter
    def version(self) -> str:
        return pulumi.get(self, "version")

    @property
    @pulumi.getter(name="launchTemplateId")
    def launch_template_id(self) -> Optional[str]:
        return pulumi.get(self, "launch_template_id")

    @property
    @pulumi.getter(name="launchTemplateName")
    def launch_template_name(self) -> Optional[str]:
        return pulumi.get(self, "launch_template_name")


@pulumi.output_type
class Ec2FleetInstanceRequirementsRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceleratorCount":
            suggest = "accelerator_count"
        elif key == "acceleratorManufacturers":
            suggest = "accelerator_manufacturers"
        elif key == "acceleratorNames":
            suggest = "accelerator_names"
        elif key == "acceleratorTotalMemoryMiB":
            suggest = "accelerator_total_memory_mi_b"
        elif key == "acceleratorTypes":
            suggest = "accelerator_types"
        elif key == "allowedInstanceTypes":
            suggest = "allowed_instance_types"
        elif key == "bareMetal":
            suggest = "bare_metal"
        elif key == "baselineEbsBandwidthMbps":
            suggest = "baseline_ebs_bandwidth_mbps"
        elif key == "burstablePerformance":
            suggest = "burstable_performance"
        elif key == "cpuManufacturers":
            suggest = "cpu_manufacturers"
        elif key == "excludedInstanceTypes":
            suggest = "excluded_instance_types"
        elif key == "instanceGenerations":
            suggest = "instance_generations"
        elif key == "localStorage":
            suggest = "local_storage"
        elif key == "localStorageTypes":
            suggest = "local_storage_types"
        elif key == "memoryGiBPerVCpu":
            suggest = "memory_gi_b_per_v_cpu"
        elif key == "memoryMiB":
            suggest = "memory_mi_b"
        elif key == "networkBandwidthGbps":
            suggest = "network_bandwidth_gbps"
        elif key == "networkInterfaceCount":
            suggest = "network_interface_count"
        elif key == "onDemandMaxPricePercentageOverLowestPrice":
            suggest = "on_demand_max_price_percentage_over_lowest_price"
        elif key == "requireHibernateSupport":
            suggest = "require_hibernate_support"
        elif key == "spotMaxPricePercentageOverLowestPrice":
            suggest = "spot_max_price_percentage_over_lowest_price"
        elif key == "totalLocalStorageGb":
            suggest = "total_local_storage_gb"
        elif key == "vCpuCount":
            suggest = "v_cpu_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2FleetInstanceRequirementsRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2FleetInstanceRequirementsRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2FleetInstanceRequirementsRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accelerator_count: Optional['outputs.Ec2FleetAcceleratorCountRequest'] = None,
                 accelerator_manufacturers: Optional[Sequence['Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem']] = None,
                 accelerator_names: Optional[Sequence['Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem']] = None,
                 accelerator_total_memory_mi_b: Optional['outputs.Ec2FleetAcceleratorTotalMemoryMiBRequest'] = None,
                 accelerator_types: Optional[Sequence['Ec2FleetInstanceRequirementsRequestAcceleratorTypesItem']] = None,
                 allowed_instance_types: Optional[Sequence[str]] = None,
                 bare_metal: Optional['Ec2FleetInstanceRequirementsRequestBareMetal'] = None,
                 baseline_ebs_bandwidth_mbps: Optional['outputs.Ec2FleetBaselineEbsBandwidthMbpsRequest'] = None,
                 burstable_performance: Optional['Ec2FleetInstanceRequirementsRequestBurstablePerformance'] = None,
                 cpu_manufacturers: Optional[Sequence['Ec2FleetInstanceRequirementsRequestCpuManufacturersItem']] = None,
                 excluded_instance_types: Optional[Sequence[str]] = None,
                 instance_generations: Optional[Sequence['Ec2FleetInstanceRequirementsRequestInstanceGenerationsItem']] = None,
                 local_storage: Optional['Ec2FleetInstanceRequirementsRequestLocalStorage'] = None,
                 local_storage_types: Optional[Sequence['Ec2FleetInstanceRequirementsRequestLocalStorageTypesItem']] = None,
                 memory_gi_b_per_v_cpu: Optional['outputs.Ec2FleetMemoryGiBPerVCpuRequest'] = None,
                 memory_mi_b: Optional['outputs.Ec2FleetMemoryMiBRequest'] = None,
                 network_bandwidth_gbps: Optional['outputs.Ec2FleetNetworkBandwidthGbpsRequest'] = None,
                 network_interface_count: Optional['outputs.Ec2FleetNetworkInterfaceCountRequest'] = None,
                 on_demand_max_price_percentage_over_lowest_price: Optional[int] = None,
                 require_hibernate_support: Optional[bool] = None,
                 spot_max_price_percentage_over_lowest_price: Optional[int] = None,
                 total_local_storage_gb: Optional['outputs.Ec2FleetTotalLocalStorageGbRequest'] = None,
                 v_cpu_count: Optional['outputs.Ec2FleetVCpuCountRangeRequest'] = None):
        if accelerator_count is not None:
            pulumi.set(__self__, "accelerator_count", accelerator_count)
        if accelerator_manufacturers is not None:
            pulumi.set(__self__, "accelerator_manufacturers", accelerator_manufacturers)
        if accelerator_names is not None:
            pulumi.set(__self__, "accelerator_names", accelerator_names)
        if accelerator_total_memory_mi_b is not None:
            pulumi.set(__self__, "accelerator_total_memory_mi_b", accelerator_total_memory_mi_b)
        if accelerator_types is not None:
            pulumi.set(__self__, "accelerator_types", accelerator_types)
        if allowed_instance_types is not None:
            pulumi.set(__self__, "allowed_instance_types", allowed_instance_types)
        if bare_metal is not None:
            pulumi.set(__self__, "bare_metal", bare_metal)
        if baseline_ebs_bandwidth_mbps is not None:
            pulumi.set(__self__, "baseline_ebs_bandwidth_mbps", baseline_ebs_bandwidth_mbps)
        if burstable_performance is not None:
            pulumi.set(__self__, "burstable_performance", burstable_performance)
        if cpu_manufacturers is not None:
            pulumi.set(__self__, "cpu_manufacturers", cpu_manufacturers)
        if excluded_instance_types is not None:
            pulumi.set(__self__, "excluded_instance_types", excluded_instance_types)
        if instance_generations is not None:
            pulumi.set(__self__, "instance_generations", instance_generations)
        if local_storage is not None:
            pulumi.set(__self__, "local_storage", local_storage)
        if local_storage_types is not None:
            pulumi.set(__self__, "local_storage_types", local_storage_types)
        if memory_gi_b_per_v_cpu is not None:
            pulumi.set(__self__, "memory_gi_b_per_v_cpu", memory_gi_b_per_v_cpu)
        if memory_mi_b is not None:
            pulumi.set(__self__, "memory_mi_b", memory_mi_b)
        if network_bandwidth_gbps is not None:
            pulumi.set(__self__, "network_bandwidth_gbps", network_bandwidth_gbps)
        if network_interface_count is not None:
            pulumi.set(__self__, "network_interface_count", network_interface_count)
        if on_demand_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "on_demand_max_price_percentage_over_lowest_price", on_demand_max_price_percentage_over_lowest_price)
        if require_hibernate_support is not None:
            pulumi.set(__self__, "require_hibernate_support", require_hibernate_support)
        if spot_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "spot_max_price_percentage_over_lowest_price", spot_max_price_percentage_over_lowest_price)
        if total_local_storage_gb is not None:
            pulumi.set(__self__, "total_local_storage_gb", total_local_storage_gb)
        if v_cpu_count is not None:
            pulumi.set(__self__, "v_cpu_count", v_cpu_count)

    @property
    @pulumi.getter(name="acceleratorCount")
    def accelerator_count(self) -> Optional['outputs.Ec2FleetAcceleratorCountRequest']:
        return pulumi.get(self, "accelerator_count")

    @property
    @pulumi.getter(name="acceleratorManufacturers")
    def accelerator_manufacturers(self) -> Optional[Sequence['Ec2FleetInstanceRequirementsRequestAcceleratorManufacturersItem']]:
        return pulumi.get(self, "accelerator_manufacturers")

    @property
    @pulumi.getter(name="acceleratorNames")
    def accelerator_names(self) -> Optional[Sequence['Ec2FleetInstanceRequirementsRequestAcceleratorNamesItem']]:
        return pulumi.get(self, "accelerator_names")

    @property
    @pulumi.getter(name="acceleratorTotalMemoryMiB")
    def accelerator_total_memory_mi_b(self) -> Optional['outputs.Ec2FleetAcceleratorTotalMemoryMiBRequest']:
        return pulumi.get(self, "accelerator_total_memory_mi_b")

    @property
    @pulumi.getter(name="acceleratorTypes")
    def accelerator_types(self) -> Optional[Sequence['Ec2FleetInstanceRequirementsRequestAcceleratorTypesItem']]:
        return pulumi.get(self, "accelerator_types")

    @property
    @pulumi.getter(name="allowedInstanceTypes")
    def allowed_instance_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allowed_instance_types")

    @property
    @pulumi.getter(name="bareMetal")
    def bare_metal(self) -> Optional['Ec2FleetInstanceRequirementsRequestBareMetal']:
        return pulumi.get(self, "bare_metal")

    @property
    @pulumi.getter(name="baselineEbsBandwidthMbps")
    def baseline_ebs_bandwidth_mbps(self) -> Optional['outputs.Ec2FleetBaselineEbsBandwidthMbpsRequest']:
        return pulumi.get(self, "baseline_ebs_bandwidth_mbps")

    @property
    @pulumi.getter(name="burstablePerformance")
    def burstable_performance(self) -> Optional['Ec2FleetInstanceRequirementsRequestBurstablePerformance']:
        return pulumi.get(self, "burstable_performance")

    @property
    @pulumi.getter(name="cpuManufacturers")
    def cpu_manufacturers(self) -> Optional[Sequence['Ec2FleetInstanceRequirementsRequestCpuManufacturersItem']]:
        return pulumi.get(self, "cpu_manufacturers")

    @property
    @pulumi.getter(name="excludedInstanceTypes")
    def excluded_instance_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_instance_types")

    @property
    @pulumi.getter(name="instanceGenerations")
    def instance_generations(self) -> Optional[Sequence['Ec2FleetInstanceRequirementsRequestInstanceGenerationsItem']]:
        return pulumi.get(self, "instance_generations")

    @property
    @pulumi.getter(name="localStorage")
    def local_storage(self) -> Optional['Ec2FleetInstanceRequirementsRequestLocalStorage']:
        return pulumi.get(self, "local_storage")

    @property
    @pulumi.getter(name="localStorageTypes")
    def local_storage_types(self) -> Optional[Sequence['Ec2FleetInstanceRequirementsRequestLocalStorageTypesItem']]:
        return pulumi.get(self, "local_storage_types")

    @property
    @pulumi.getter(name="memoryGiBPerVCpu")
    def memory_gi_b_per_v_cpu(self) -> Optional['outputs.Ec2FleetMemoryGiBPerVCpuRequest']:
        return pulumi.get(self, "memory_gi_b_per_v_cpu")

    @property
    @pulumi.getter(name="memoryMiB")
    def memory_mi_b(self) -> Optional['outputs.Ec2FleetMemoryMiBRequest']:
        return pulumi.get(self, "memory_mi_b")

    @property
    @pulumi.getter(name="networkBandwidthGbps")
    def network_bandwidth_gbps(self) -> Optional['outputs.Ec2FleetNetworkBandwidthGbpsRequest']:
        return pulumi.get(self, "network_bandwidth_gbps")

    @property
    @pulumi.getter(name="networkInterfaceCount")
    def network_interface_count(self) -> Optional['outputs.Ec2FleetNetworkInterfaceCountRequest']:
        return pulumi.get(self, "network_interface_count")

    @property
    @pulumi.getter(name="onDemandMaxPricePercentageOverLowestPrice")
    def on_demand_max_price_percentage_over_lowest_price(self) -> Optional[int]:
        return pulumi.get(self, "on_demand_max_price_percentage_over_lowest_price")

    @property
    @pulumi.getter(name="requireHibernateSupport")
    def require_hibernate_support(self) -> Optional[bool]:
        return pulumi.get(self, "require_hibernate_support")

    @property
    @pulumi.getter(name="spotMaxPricePercentageOverLowestPrice")
    def spot_max_price_percentage_over_lowest_price(self) -> Optional[int]:
        return pulumi.get(self, "spot_max_price_percentage_over_lowest_price")

    @property
    @pulumi.getter(name="totalLocalStorageGb")
    def total_local_storage_gb(self) -> Optional['outputs.Ec2FleetTotalLocalStorageGbRequest']:
        return pulumi.get(self, "total_local_storage_gb")

    @property
    @pulumi.getter(name="vCpuCount")
    def v_cpu_count(self) -> Optional['outputs.Ec2FleetVCpuCountRangeRequest']:
        return pulumi.get(self, "v_cpu_count")


@pulumi.output_type
class Ec2FleetMaintenanceStrategies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityRebalance":
            suggest = "capacity_rebalance"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2FleetMaintenanceStrategies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2FleetMaintenanceStrategies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2FleetMaintenanceStrategies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_rebalance: Optional['outputs.Ec2FleetCapacityRebalance'] = None):
        if capacity_rebalance is not None:
            pulumi.set(__self__, "capacity_rebalance", capacity_rebalance)

    @property
    @pulumi.getter(name="capacityRebalance")
    def capacity_rebalance(self) -> Optional['outputs.Ec2FleetCapacityRebalance']:
        return pulumi.get(self, "capacity_rebalance")


@pulumi.output_type
class Ec2FleetMemoryGiBPerVCpuRequest(dict):
    def __init__(__self__, *,
                 max: Optional[float] = None,
                 min: Optional[float] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        return pulumi.get(self, "min")


@pulumi.output_type
class Ec2FleetMemoryMiBRequest(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class Ec2FleetNetworkBandwidthGbpsRequest(dict):
    def __init__(__self__, *,
                 max: Optional[float] = None,
                 min: Optional[float] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        return pulumi.get(self, "min")


@pulumi.output_type
class Ec2FleetNetworkInterfaceCountRequest(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class Ec2FleetOnDemandOptionsRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocationStrategy":
            suggest = "allocation_strategy"
        elif key == "capacityReservationOptions":
            suggest = "capacity_reservation_options"
        elif key == "maxTotalPrice":
            suggest = "max_total_price"
        elif key == "minTargetCapacity":
            suggest = "min_target_capacity"
        elif key == "singleAvailabilityZone":
            suggest = "single_availability_zone"
        elif key == "singleInstanceType":
            suggest = "single_instance_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2FleetOnDemandOptionsRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2FleetOnDemandOptionsRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2FleetOnDemandOptionsRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocation_strategy: Optional[str] = None,
                 capacity_reservation_options: Optional['outputs.Ec2FleetCapacityReservationOptionsRequest'] = None,
                 max_total_price: Optional[str] = None,
                 min_target_capacity: Optional[int] = None,
                 single_availability_zone: Optional[bool] = None,
                 single_instance_type: Optional[bool] = None):
        if allocation_strategy is not None:
            pulumi.set(__self__, "allocation_strategy", allocation_strategy)
        if capacity_reservation_options is not None:
            pulumi.set(__self__, "capacity_reservation_options", capacity_reservation_options)
        if max_total_price is not None:
            pulumi.set(__self__, "max_total_price", max_total_price)
        if min_target_capacity is not None:
            pulumi.set(__self__, "min_target_capacity", min_target_capacity)
        if single_availability_zone is not None:
            pulumi.set(__self__, "single_availability_zone", single_availability_zone)
        if single_instance_type is not None:
            pulumi.set(__self__, "single_instance_type", single_instance_type)

    @property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> Optional[str]:
        return pulumi.get(self, "allocation_strategy")

    @property
    @pulumi.getter(name="capacityReservationOptions")
    def capacity_reservation_options(self) -> Optional['outputs.Ec2FleetCapacityReservationOptionsRequest']:
        return pulumi.get(self, "capacity_reservation_options")

    @property
    @pulumi.getter(name="maxTotalPrice")
    def max_total_price(self) -> Optional[str]:
        return pulumi.get(self, "max_total_price")

    @property
    @pulumi.getter(name="minTargetCapacity")
    def min_target_capacity(self) -> Optional[int]:
        return pulumi.get(self, "min_target_capacity")

    @property
    @pulumi.getter(name="singleAvailabilityZone")
    def single_availability_zone(self) -> Optional[bool]:
        return pulumi.get(self, "single_availability_zone")

    @property
    @pulumi.getter(name="singleInstanceType")
    def single_instance_type(self) -> Optional[bool]:
        return pulumi.get(self, "single_instance_type")


@pulumi.output_type
class Ec2FleetPlacement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "groupName":
            suggest = "group_name"
        elif key == "hostId":
            suggest = "host_id"
        elif key == "hostResourceGroupArn":
            suggest = "host_resource_group_arn"
        elif key == "partitionNumber":
            suggest = "partition_number"
        elif key == "spreadDomain":
            suggest = "spread_domain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2FleetPlacement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2FleetPlacement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2FleetPlacement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 affinity: Optional[str] = None,
                 availability_zone: Optional[str] = None,
                 group_name: Optional[str] = None,
                 host_id: Optional[str] = None,
                 host_resource_group_arn: Optional[str] = None,
                 partition_number: Optional[int] = None,
                 spread_domain: Optional[str] = None,
                 tenancy: Optional[str] = None):
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if host_id is not None:
            pulumi.set(__self__, "host_id", host_id)
        if host_resource_group_arn is not None:
            pulumi.set(__self__, "host_resource_group_arn", host_resource_group_arn)
        if partition_number is not None:
            pulumi.set(__self__, "partition_number", partition_number)
        if spread_domain is not None:
            pulumi.set(__self__, "spread_domain", spread_domain)
        if tenancy is not None:
            pulumi.set(__self__, "tenancy", tenancy)

    @property
    @pulumi.getter
    def affinity(self) -> Optional[str]:
        return pulumi.get(self, "affinity")

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[str]:
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[str]:
        return pulumi.get(self, "group_name")

    @property
    @pulumi.getter(name="hostId")
    def host_id(self) -> Optional[str]:
        return pulumi.get(self, "host_id")

    @property
    @pulumi.getter(name="hostResourceGroupArn")
    def host_resource_group_arn(self) -> Optional[str]:
        return pulumi.get(self, "host_resource_group_arn")

    @property
    @pulumi.getter(name="partitionNumber")
    def partition_number(self) -> Optional[int]:
        return pulumi.get(self, "partition_number")

    @property
    @pulumi.getter(name="spreadDomain")
    def spread_domain(self) -> Optional[str]:
        return pulumi.get(self, "spread_domain")

    @property
    @pulumi.getter
    def tenancy(self) -> Optional[str]:
        return pulumi.get(self, "tenancy")


@pulumi.output_type
class Ec2FleetSpotOptionsRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocationStrategy":
            suggest = "allocation_strategy"
        elif key == "instanceInterruptionBehavior":
            suggest = "instance_interruption_behavior"
        elif key == "instancePoolsToUseCount":
            suggest = "instance_pools_to_use_count"
        elif key == "maintenanceStrategies":
            suggest = "maintenance_strategies"
        elif key == "maxTotalPrice":
            suggest = "max_total_price"
        elif key == "minTargetCapacity":
            suggest = "min_target_capacity"
        elif key == "singleAvailabilityZone":
            suggest = "single_availability_zone"
        elif key == "singleInstanceType":
            suggest = "single_instance_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2FleetSpotOptionsRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2FleetSpotOptionsRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2FleetSpotOptionsRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocation_strategy: Optional['Ec2FleetSpotOptionsRequestAllocationStrategy'] = None,
                 instance_interruption_behavior: Optional['Ec2FleetSpotOptionsRequestInstanceInterruptionBehavior'] = None,
                 instance_pools_to_use_count: Optional[int] = None,
                 maintenance_strategies: Optional['outputs.Ec2FleetMaintenanceStrategies'] = None,
                 max_total_price: Optional[str] = None,
                 min_target_capacity: Optional[int] = None,
                 single_availability_zone: Optional[bool] = None,
                 single_instance_type: Optional[bool] = None):
        if allocation_strategy is not None:
            pulumi.set(__self__, "allocation_strategy", allocation_strategy)
        if instance_interruption_behavior is not None:
            pulumi.set(__self__, "instance_interruption_behavior", instance_interruption_behavior)
        if instance_pools_to_use_count is not None:
            pulumi.set(__self__, "instance_pools_to_use_count", instance_pools_to_use_count)
        if maintenance_strategies is not None:
            pulumi.set(__self__, "maintenance_strategies", maintenance_strategies)
        if max_total_price is not None:
            pulumi.set(__self__, "max_total_price", max_total_price)
        if min_target_capacity is not None:
            pulumi.set(__self__, "min_target_capacity", min_target_capacity)
        if single_availability_zone is not None:
            pulumi.set(__self__, "single_availability_zone", single_availability_zone)
        if single_instance_type is not None:
            pulumi.set(__self__, "single_instance_type", single_instance_type)

    @property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> Optional['Ec2FleetSpotOptionsRequestAllocationStrategy']:
        return pulumi.get(self, "allocation_strategy")

    @property
    @pulumi.getter(name="instanceInterruptionBehavior")
    def instance_interruption_behavior(self) -> Optional['Ec2FleetSpotOptionsRequestInstanceInterruptionBehavior']:
        return pulumi.get(self, "instance_interruption_behavior")

    @property
    @pulumi.getter(name="instancePoolsToUseCount")
    def instance_pools_to_use_count(self) -> Optional[int]:
        return pulumi.get(self, "instance_pools_to_use_count")

    @property
    @pulumi.getter(name="maintenanceStrategies")
    def maintenance_strategies(self) -> Optional['outputs.Ec2FleetMaintenanceStrategies']:
        return pulumi.get(self, "maintenance_strategies")

    @property
    @pulumi.getter(name="maxTotalPrice")
    def max_total_price(self) -> Optional[str]:
        return pulumi.get(self, "max_total_price")

    @property
    @pulumi.getter(name="minTargetCapacity")
    def min_target_capacity(self) -> Optional[int]:
        return pulumi.get(self, "min_target_capacity")

    @property
    @pulumi.getter(name="singleAvailabilityZone")
    def single_availability_zone(self) -> Optional[bool]:
        return pulumi.get(self, "single_availability_zone")

    @property
    @pulumi.getter(name="singleInstanceType")
    def single_instance_type(self) -> Optional[bool]:
        return pulumi.get(self, "single_instance_type")


@pulumi.output_type
class Ec2FleetTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class Ec2FleetTagSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2FleetTagSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2FleetTagSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2FleetTagSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_type: Optional['Ec2FleetTagSpecificationResourceType'] = None,
                 tags: Optional[Sequence['outputs.Ec2FleetTag']] = None):
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional['Ec2FleetTagSpecificationResourceType']:
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.Ec2FleetTag']]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class Ec2FleetTargetCapacitySpecificationRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "totalTargetCapacity":
            suggest = "total_target_capacity"
        elif key == "defaultTargetCapacityType":
            suggest = "default_target_capacity_type"
        elif key == "onDemandTargetCapacity":
            suggest = "on_demand_target_capacity"
        elif key == "spotTargetCapacity":
            suggest = "spot_target_capacity"
        elif key == "targetCapacityUnitType":
            suggest = "target_capacity_unit_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Ec2FleetTargetCapacitySpecificationRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Ec2FleetTargetCapacitySpecificationRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Ec2FleetTargetCapacitySpecificationRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 total_target_capacity: int,
                 default_target_capacity_type: Optional['Ec2FleetTargetCapacitySpecificationRequestDefaultTargetCapacityType'] = None,
                 on_demand_target_capacity: Optional[int] = None,
                 spot_target_capacity: Optional[int] = None,
                 target_capacity_unit_type: Optional['Ec2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType'] = None):
        pulumi.set(__self__, "total_target_capacity", total_target_capacity)
        if default_target_capacity_type is not None:
            pulumi.set(__self__, "default_target_capacity_type", default_target_capacity_type)
        if on_demand_target_capacity is not None:
            pulumi.set(__self__, "on_demand_target_capacity", on_demand_target_capacity)
        if spot_target_capacity is not None:
            pulumi.set(__self__, "spot_target_capacity", spot_target_capacity)
        if target_capacity_unit_type is not None:
            pulumi.set(__self__, "target_capacity_unit_type", target_capacity_unit_type)

    @property
    @pulumi.getter(name="totalTargetCapacity")
    def total_target_capacity(self) -> int:
        return pulumi.get(self, "total_target_capacity")

    @property
    @pulumi.getter(name="defaultTargetCapacityType")
    def default_target_capacity_type(self) -> Optional['Ec2FleetTargetCapacitySpecificationRequestDefaultTargetCapacityType']:
        return pulumi.get(self, "default_target_capacity_type")

    @property
    @pulumi.getter(name="onDemandTargetCapacity")
    def on_demand_target_capacity(self) -> Optional[int]:
        return pulumi.get(self, "on_demand_target_capacity")

    @property
    @pulumi.getter(name="spotTargetCapacity")
    def spot_target_capacity(self) -> Optional[int]:
        return pulumi.get(self, "spot_target_capacity")

    @property
    @pulumi.getter(name="targetCapacityUnitType")
    def target_capacity_unit_type(self) -> Optional['Ec2FleetTargetCapacitySpecificationRequestTargetCapacityUnitType']:
        return pulumi.get(self, "target_capacity_unit_type")


@pulumi.output_type
class Ec2FleetTotalLocalStorageGbRequest(dict):
    def __init__(__self__, *,
                 max: Optional[float] = None,
                 min: Optional[float] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        return pulumi.get(self, "min")


@pulumi.output_type
class Ec2FleetVCpuCountRangeRequest(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class EipTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class FlowLogTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class InstanceAssociationParameter(dict):
    def __init__(__self__, *,
                 key: str,
                 value: Sequence[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Sequence[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class InstanceBlockDeviceMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "noDevice":
            suggest = "no_device"
        elif key == "virtualName":
            suggest = "virtual_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceBlockDeviceMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceBlockDeviceMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceBlockDeviceMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: str,
                 ebs: Optional['outputs.InstanceEbs'] = None,
                 no_device: Optional['outputs.InstanceNoDevice'] = None,
                 virtual_name: Optional[str] = None):
        pulumi.set(__self__, "device_name", device_name)
        if ebs is not None:
            pulumi.set(__self__, "ebs", ebs)
        if no_device is not None:
            pulumi.set(__self__, "no_device", no_device)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter
    def ebs(self) -> Optional['outputs.InstanceEbs']:
        return pulumi.get(self, "ebs")

    @property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional['outputs.InstanceNoDevice']:
        return pulumi.get(self, "no_device")

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[str]:
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class InstanceConnectEndpointTag(dict):
    """
    A key-value pair to associate with a resource.
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        A key-value pair to associate with a resource.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class InstanceCpuOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coreCount":
            suggest = "core_count"
        elif key == "threadsPerCore":
            suggest = "threads_per_core"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceCpuOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceCpuOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceCpuOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 core_count: Optional[int] = None,
                 threads_per_core: Optional[int] = None):
        if core_count is not None:
            pulumi.set(__self__, "core_count", core_count)
        if threads_per_core is not None:
            pulumi.set(__self__, "threads_per_core", threads_per_core)

    @property
    @pulumi.getter(name="coreCount")
    def core_count(self) -> Optional[int]:
        return pulumi.get(self, "core_count")

    @property
    @pulumi.getter(name="threadsPerCore")
    def threads_per_core(self) -> Optional[int]:
        return pulumi.get(self, "threads_per_core")


@pulumi.output_type
class InstanceCreditSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuCredits":
            suggest = "cpu_credits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceCreditSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceCreditSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceCreditSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_credits: Optional[str] = None):
        if cpu_credits is not None:
            pulumi.set(__self__, "cpu_credits", cpu_credits)

    @property
    @pulumi.getter(name="cpuCredits")
    def cpu_credits(self) -> Optional[str]:
        return pulumi.get(self, "cpu_credits")


@pulumi.output_type
class InstanceEbs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceEbs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceEbs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceEbs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_on_termination: Optional[bool] = None,
                 encrypted: Optional[bool] = None,
                 iops: Optional[int] = None,
                 kms_key_id: Optional[str] = None,
                 snapshot_id: Optional[str] = None,
                 volume_size: Optional[int] = None,
                 volume_type: Optional[str] = None):
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[bool]:
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[bool]:
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[int]:
        return pulumi.get(self, "volume_size")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[str]:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class InstanceElasticGpuSpecification(dict):
    def __init__(__self__, *,
                 type: str):
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class InstanceElasticInferenceAccelerator(dict):
    def __init__(__self__, *,
                 type: str,
                 count: Optional[int] = None):
        pulumi.set(__self__, "type", type)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        return pulumi.get(self, "count")


@pulumi.output_type
class InstanceEnclaveOptions(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class InstanceHibernationOptions(dict):
    def __init__(__self__, *,
                 configured: Optional[bool] = None):
        if configured is not None:
            pulumi.set(__self__, "configured", configured)

    @property
    @pulumi.getter
    def configured(self) -> Optional[bool]:
        return pulumi.get(self, "configured")


@pulumi.output_type
class InstanceIpv6Address(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv6Address":
            suggest = "ipv6_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceIpv6Address. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceIpv6Address.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceIpv6Address.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv6_address: str):
        pulumi.set(__self__, "ipv6_address", ipv6_address)

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> str:
        return pulumi.get(self, "ipv6_address")


@pulumi.output_type
class InstanceLaunchTemplateSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTemplateId":
            suggest = "launch_template_id"
        elif key == "launchTemplateName":
            suggest = "launch_template_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceLaunchTemplateSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceLaunchTemplateSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceLaunchTemplateSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 version: str,
                 launch_template_id: Optional[str] = None,
                 launch_template_name: Optional[str] = None):
        pulumi.set(__self__, "version", version)
        if launch_template_id is not None:
            pulumi.set(__self__, "launch_template_id", launch_template_id)
        if launch_template_name is not None:
            pulumi.set(__self__, "launch_template_name", launch_template_name)

    @property
    @pulumi.getter
    def version(self) -> str:
        return pulumi.get(self, "version")

    @property
    @pulumi.getter(name="launchTemplateId")
    def launch_template_id(self) -> Optional[str]:
        return pulumi.get(self, "launch_template_id")

    @property
    @pulumi.getter(name="launchTemplateName")
    def launch_template_name(self) -> Optional[str]:
        return pulumi.get(self, "launch_template_name")


@pulumi.output_type
class InstanceLicenseSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "licenseConfigurationArn":
            suggest = "license_configuration_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceLicenseSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceLicenseSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceLicenseSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 license_configuration_arn: str):
        pulumi.set(__self__, "license_configuration_arn", license_configuration_arn)

    @property
    @pulumi.getter(name="licenseConfigurationArn")
    def license_configuration_arn(self) -> str:
        return pulumi.get(self, "license_configuration_arn")


@pulumi.output_type
class InstanceNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceIndex":
            suggest = "device_index"
        elif key == "associateCarrierIpAddress":
            suggest = "associate_carrier_ip_address"
        elif key == "associatePublicIpAddress":
            suggest = "associate_public_ip_address"
        elif key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "groupSet":
            suggest = "group_set"
        elif key == "ipv6AddressCount":
            suggest = "ipv6_address_count"
        elif key == "ipv6Addresses":
            suggest = "ipv6_addresses"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "privateIpAddress":
            suggest = "private_ip_address"
        elif key == "privateIpAddresses":
            suggest = "private_ip_addresses"
        elif key == "secondaryPrivateIpAddressCount":
            suggest = "secondary_private_ip_address_count"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_index: str,
                 associate_carrier_ip_address: Optional[bool] = None,
                 associate_public_ip_address: Optional[bool] = None,
                 delete_on_termination: Optional[bool] = None,
                 description: Optional[str] = None,
                 group_set: Optional[Sequence[str]] = None,
                 ipv6_address_count: Optional[int] = None,
                 ipv6_addresses: Optional[Sequence['outputs.InstanceIpv6Address']] = None,
                 network_interface_id: Optional[str] = None,
                 private_ip_address: Optional[str] = None,
                 private_ip_addresses: Optional[Sequence['outputs.InstancePrivateIpAddressSpecification']] = None,
                 secondary_private_ip_address_count: Optional[int] = None,
                 subnet_id: Optional[str] = None):
        pulumi.set(__self__, "device_index", device_index)
        if associate_carrier_ip_address is not None:
            pulumi.set(__self__, "associate_carrier_ip_address", associate_carrier_ip_address)
        if associate_public_ip_address is not None:
            pulumi.set(__self__, "associate_public_ip_address", associate_public_ip_address)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if group_set is not None:
            pulumi.set(__self__, "group_set", group_set)
        if ipv6_address_count is not None:
            pulumi.set(__self__, "ipv6_address_count", ipv6_address_count)
        if ipv6_addresses is not None:
            pulumi.set(__self__, "ipv6_addresses", ipv6_addresses)
        if network_interface_id is not None:
            pulumi.set(__self__, "network_interface_id", network_interface_id)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)
        if private_ip_addresses is not None:
            pulumi.set(__self__, "private_ip_addresses", private_ip_addresses)
        if secondary_private_ip_address_count is not None:
            pulumi.set(__self__, "secondary_private_ip_address_count", secondary_private_ip_address_count)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> str:
        return pulumi.get(self, "device_index")

    @property
    @pulumi.getter(name="associateCarrierIpAddress")
    def associate_carrier_ip_address(self) -> Optional[bool]:
        return pulumi.get(self, "associate_carrier_ip_address")

    @property
    @pulumi.getter(name="associatePublicIpAddress")
    def associate_public_ip_address(self) -> Optional[bool]:
        return pulumi.get(self, "associate_public_ip_address")

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[bool]:
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="groupSet")
    def group_set(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "group_set")

    @property
    @pulumi.getter(name="ipv6AddressCount")
    def ipv6_address_count(self) -> Optional[int]:
        return pulumi.get(self, "ipv6_address_count")

    @property
    @pulumi.getter(name="ipv6Addresses")
    def ipv6_addresses(self) -> Optional[Sequence['outputs.InstanceIpv6Address']]:
        return pulumi.get(self, "ipv6_addresses")

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[str]:
        return pulumi.get(self, "network_interface_id")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[str]:
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="privateIpAddresses")
    def private_ip_addresses(self) -> Optional[Sequence['outputs.InstancePrivateIpAddressSpecification']]:
        return pulumi.get(self, "private_ip_addresses")

    @property
    @pulumi.getter(name="secondaryPrivateIpAddressCount")
    def secondary_private_ip_address_count(self) -> Optional[int]:
        return pulumi.get(self, "secondary_private_ip_address_count")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class InstanceNoDevice(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class InstancePrivateDnsNameOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableResourceNameDnsARecord":
            suggest = "enable_resource_name_dns_a_record"
        elif key == "enableResourceNameDnsAaaaRecord":
            suggest = "enable_resource_name_dns_aaaa_record"
        elif key == "hostnameType":
            suggest = "hostname_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstancePrivateDnsNameOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstancePrivateDnsNameOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstancePrivateDnsNameOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_resource_name_dns_a_record: Optional[bool] = None,
                 enable_resource_name_dns_aaaa_record: Optional[bool] = None,
                 hostname_type: Optional[str] = None):
        if enable_resource_name_dns_a_record is not None:
            pulumi.set(__self__, "enable_resource_name_dns_a_record", enable_resource_name_dns_a_record)
        if enable_resource_name_dns_aaaa_record is not None:
            pulumi.set(__self__, "enable_resource_name_dns_aaaa_record", enable_resource_name_dns_aaaa_record)
        if hostname_type is not None:
            pulumi.set(__self__, "hostname_type", hostname_type)

    @property
    @pulumi.getter(name="enableResourceNameDnsARecord")
    def enable_resource_name_dns_a_record(self) -> Optional[bool]:
        return pulumi.get(self, "enable_resource_name_dns_a_record")

    @property
    @pulumi.getter(name="enableResourceNameDnsAaaaRecord")
    def enable_resource_name_dns_aaaa_record(self) -> Optional[bool]:
        return pulumi.get(self, "enable_resource_name_dns_aaaa_record")

    @property
    @pulumi.getter(name="hostnameType")
    def hostname_type(self) -> Optional[str]:
        return pulumi.get(self, "hostname_type")


@pulumi.output_type
class InstancePrivateIpAddressSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIpAddress":
            suggest = "private_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstancePrivateIpAddressSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstancePrivateIpAddressSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstancePrivateIpAddressSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 primary: bool,
                 private_ip_address: str):
        pulumi.set(__self__, "primary", primary)
        pulumi.set(__self__, "private_ip_address", private_ip_address)

    @property
    @pulumi.getter
    def primary(self) -> bool:
        return pulumi.get(self, "primary")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> str:
        return pulumi.get(self, "private_ip_address")


@pulumi.output_type
class InstanceSsmAssociation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "documentName":
            suggest = "document_name"
        elif key == "associationParameters":
            suggest = "association_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceSsmAssociation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceSsmAssociation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceSsmAssociation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 document_name: str,
                 association_parameters: Optional[Sequence['outputs.InstanceAssociationParameter']] = None):
        pulumi.set(__self__, "document_name", document_name)
        if association_parameters is not None:
            pulumi.set(__self__, "association_parameters", association_parameters)

    @property
    @pulumi.getter(name="documentName")
    def document_name(self) -> str:
        return pulumi.get(self, "document_name")

    @property
    @pulumi.getter(name="associationParameters")
    def association_parameters(self) -> Optional[Sequence['outputs.InstanceAssociationParameter']]:
        return pulumi.get(self, "association_parameters")


@pulumi.output_type
class InstanceTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class InstanceVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "volumeId":
            suggest = "volume_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device: str,
                 volume_id: str):
        pulumi.set(__self__, "device", device)
        pulumi.set(__self__, "volume_id", volume_id)

    @property
    @pulumi.getter
    def device(self) -> str:
        return pulumi.get(self, "device")

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> str:
        return pulumi.get(self, "volume_id")


@pulumi.output_type
class InternetGatewayTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class IpamOperatingRegion(dict):
    """
    The regions IPAM is enabled for. Allows pools to be created in these regions, as well as enabling monitoring
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regionName":
            suggest = "region_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpamOperatingRegion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpamOperatingRegion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpamOperatingRegion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region_name: str):
        """
        The regions IPAM is enabled for. Allows pools to be created in these regions, as well as enabling monitoring
        :param str region_name: The name of the region.
        """
        pulumi.set(__self__, "region_name", region_name)

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> str:
        """
        The name of the region.
        """
        return pulumi.get(self, "region_name")


@pulumi.output_type
class IpamPoolProvisionedCidr(dict):
    """
    An address space to be inserted into this pool. All allocations must be made from this address space.
    """
    def __init__(__self__, *,
                 cidr: str):
        """
        An address space to be inserted into this pool. All allocations must be made from this address space.
        """
        pulumi.set(__self__, "cidr", cidr)

    @property
    @pulumi.getter
    def cidr(self) -> str:
        return pulumi.get(self, "cidr")


@pulumi.output_type
class IpamPoolTag(dict):
    """
    A key-value pair to associate with a resource.
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        A key-value pair to associate with a resource.
        :param str key: The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        :param str value: The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IpamResourceDiscoveryAssociationTag(dict):
    """
    A key-value pair to associate with a resource.
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        A key-value pair to associate with a resource.
        :param str key: The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        :param str value: The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IpamResourceDiscoveryIpamOperatingRegion(dict):
    """
    The regions IPAM Resource Discovery is enabled for. Allows for monitoring.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "regionName":
            suggest = "region_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpamResourceDiscoveryIpamOperatingRegion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpamResourceDiscoveryIpamOperatingRegion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpamResourceDiscoveryIpamOperatingRegion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region_name: str):
        """
        The regions IPAM Resource Discovery is enabled for. Allows for monitoring.
        :param str region_name: The name of the region.
        """
        pulumi.set(__self__, "region_name", region_name)

    @property
    @pulumi.getter(name="regionName")
    def region_name(self) -> str:
        """
        The name of the region.
        """
        return pulumi.get(self, "region_name")


@pulumi.output_type
class IpamResourceDiscoveryTag(dict):
    """
    A key-value pair to associate with a resource.
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        A key-value pair to associate with a resource.
        :param str key: The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        :param str value: The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IpamScopeTag(dict):
    """
    A key-value pair to associate with a resource.
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        A key-value pair to associate with a resource.
        :param str key: The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        :param str value: The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class IpamTag(dict):
    """
    A key-value pair to associate with a resource.
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        A key-value pair to associate with a resource.
        :param str key: The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        :param str value: The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class KeyPairTag(dict):
    """
    A key-value pair to associate with a resource.
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        A key-value pair to associate with a resource.
        :param str key: The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        :param str value: The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class LaunchTemplateAcceleratorCount(dict):
    """
    The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferential chips) on an instance.
    """
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        The minimum and maximum number of accelerators (GPUs, FPGAs, or AWS Inferential chips) on an instance.
        :param int max: The maximum number of accelerators.
        :param int min: The minimum number of accelerators.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        The maximum number of accelerators.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        The minimum number of accelerators.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateAcceleratorTotalMemoryMiB(dict):
    """
    The minimum and maximum amount of total accelerator memory, in MiB.
    """
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        The minimum and maximum amount of total accelerator memory, in MiB.
        :param int max: The maximum amount of accelerator memory, in MiB.
        :param int min: The minimum amount of accelerator memory, in MiB.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        The maximum amount of accelerator memory, in MiB.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        The minimum amount of accelerator memory, in MiB.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateBaselineEbsBandwidthMbps(dict):
    """
    The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps.
    """
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        The minimum and maximum baseline bandwidth to Amazon EBS, in Mbps.
        :param int max: The maximum baseline bandwidth, in Mbps.
        :param int min: The minimum baseline bandwidth, in Mbps.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        The maximum baseline bandwidth, in Mbps.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        The minimum baseline bandwidth, in Mbps.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateBlockDeviceMapping(dict):
    """
    Information about a block device mapping for an Amazon EC2 launch template.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "noDevice":
            suggest = "no_device"
        elif key == "virtualName":
            suggest = "virtual_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateBlockDeviceMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateBlockDeviceMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateBlockDeviceMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: Optional[str] = None,
                 ebs: Optional['outputs.LaunchTemplateEbs'] = None,
                 no_device: Optional[str] = None,
                 virtual_name: Optional[str] = None):
        """
        Information about a block device mapping for an Amazon EC2 launch template.
        :param str device_name: The user data to make available to the instance.
        :param str no_device: To omit the device from the block device mapping, specify an empty string.
        :param str virtual_name: The virtual device name (ephemeralN).
        """
        if device_name is not None:
            pulumi.set(__self__, "device_name", device_name)
        if ebs is not None:
            pulumi.set(__self__, "ebs", ebs)
        if no_device is not None:
            pulumi.set(__self__, "no_device", no_device)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[str]:
        """
        The user data to make available to the instance.
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter
    def ebs(self) -> Optional['outputs.LaunchTemplateEbs']:
        return pulumi.get(self, "ebs")

    @property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[str]:
        """
        To omit the device from the block device mapping, specify an empty string.
        """
        return pulumi.get(self, "no_device")

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[str]:
        """
        The virtual device name (ephemeralN).
        """
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class LaunchTemplateCapacityReservationSpecification(dict):
    """
    Specifies an instance's Capacity Reservation targeting option.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityReservationPreference":
            suggest = "capacity_reservation_preference"
        elif key == "capacityReservationTarget":
            suggest = "capacity_reservation_target"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateCapacityReservationSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateCapacityReservationSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateCapacityReservationSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_reservation_preference: Optional[str] = None,
                 capacity_reservation_target: Optional['outputs.LaunchTemplateCapacityReservationTarget'] = None):
        """
        Specifies an instance's Capacity Reservation targeting option.
        :param str capacity_reservation_preference: Indicates the instance's Capacity Reservation preferences.
        """
        if capacity_reservation_preference is not None:
            pulumi.set(__self__, "capacity_reservation_preference", capacity_reservation_preference)
        if capacity_reservation_target is not None:
            pulumi.set(__self__, "capacity_reservation_target", capacity_reservation_target)

    @property
    @pulumi.getter(name="capacityReservationPreference")
    def capacity_reservation_preference(self) -> Optional[str]:
        """
        Indicates the instance's Capacity Reservation preferences.
        """
        return pulumi.get(self, "capacity_reservation_preference")

    @property
    @pulumi.getter(name="capacityReservationTarget")
    def capacity_reservation_target(self) -> Optional['outputs.LaunchTemplateCapacityReservationTarget']:
        return pulumi.get(self, "capacity_reservation_target")


@pulumi.output_type
class LaunchTemplateCapacityReservationTarget(dict):
    """
    Specifies a target Capacity Reservation.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityReservationId":
            suggest = "capacity_reservation_id"
        elif key == "capacityReservationResourceGroupArn":
            suggest = "capacity_reservation_resource_group_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateCapacityReservationTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateCapacityReservationTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateCapacityReservationTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_reservation_id: Optional[str] = None,
                 capacity_reservation_resource_group_arn: Optional[str] = None):
        """
        Specifies a target Capacity Reservation.
        :param str capacity_reservation_id: The ID of the Capacity Reservation in which to run the instance.
        :param str capacity_reservation_resource_group_arn: The ARN of the Capacity Reservation resource group in which to run the instance.
        """
        if capacity_reservation_id is not None:
            pulumi.set(__self__, "capacity_reservation_id", capacity_reservation_id)
        if capacity_reservation_resource_group_arn is not None:
            pulumi.set(__self__, "capacity_reservation_resource_group_arn", capacity_reservation_resource_group_arn)

    @property
    @pulumi.getter(name="capacityReservationId")
    def capacity_reservation_id(self) -> Optional[str]:
        """
        The ID of the Capacity Reservation in which to run the instance.
        """
        return pulumi.get(self, "capacity_reservation_id")

    @property
    @pulumi.getter(name="capacityReservationResourceGroupArn")
    def capacity_reservation_resource_group_arn(self) -> Optional[str]:
        """
        The ARN of the Capacity Reservation resource group in which to run the instance.
        """
        return pulumi.get(self, "capacity_reservation_resource_group_arn")


@pulumi.output_type
class LaunchTemplateCpuOptions(dict):
    """
    specifies the CPU options for an instance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "amdSevSnp":
            suggest = "amd_sev_snp"
        elif key == "coreCount":
            suggest = "core_count"
        elif key == "threadsPerCore":
            suggest = "threads_per_core"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateCpuOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateCpuOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateCpuOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amd_sev_snp: Optional['LaunchTemplateCpuOptionsAmdSevSnp'] = None,
                 core_count: Optional[int] = None,
                 threads_per_core: Optional[int] = None):
        """
        specifies the CPU options for an instance.
        :param 'LaunchTemplateCpuOptionsAmdSevSnp' amd_sev_snp: Indicates whether to enable the instance for AMD SEV-SNP. AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only.
        :param int core_count: The number of CPU cores for the instance.
        :param int threads_per_core: The number of threads per CPU core. To disable multithreading for the instance, specify a value of 1. Otherwise, specify the default value of 2.
        """
        if amd_sev_snp is not None:
            pulumi.set(__self__, "amd_sev_snp", amd_sev_snp)
        if core_count is not None:
            pulumi.set(__self__, "core_count", core_count)
        if threads_per_core is not None:
            pulumi.set(__self__, "threads_per_core", threads_per_core)

    @property
    @pulumi.getter(name="amdSevSnp")
    def amd_sev_snp(self) -> Optional['LaunchTemplateCpuOptionsAmdSevSnp']:
        """
        Indicates whether to enable the instance for AMD SEV-SNP. AMD SEV-SNP is supported with M6a, R6a, and C6a instance types only.
        """
        return pulumi.get(self, "amd_sev_snp")

    @property
    @pulumi.getter(name="coreCount")
    def core_count(self) -> Optional[int]:
        """
        The number of CPU cores for the instance.
        """
        return pulumi.get(self, "core_count")

    @property
    @pulumi.getter(name="threadsPerCore")
    def threads_per_core(self) -> Optional[int]:
        """
        The number of threads per CPU core. To disable multithreading for the instance, specify a value of 1. Otherwise, specify the default value of 2.
        """
        return pulumi.get(self, "threads_per_core")


@pulumi.output_type
class LaunchTemplateCreditSpecification(dict):
    """
    The user data to make available to the instance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuCredits":
            suggest = "cpu_credits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateCreditSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateCreditSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateCreditSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_credits: Optional[str] = None):
        """
        The user data to make available to the instance.
        :param str cpu_credits: The user data to make available to the instance.
        """
        if cpu_credits is not None:
            pulumi.set(__self__, "cpu_credits", cpu_credits)

    @property
    @pulumi.getter(name="cpuCredits")
    def cpu_credits(self) -> Optional[str]:
        """
        The user data to make available to the instance.
        """
        return pulumi.get(self, "cpu_credits")


@pulumi.output_type
class LaunchTemplateData(dict):
    """
    The information for the launch template.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockDeviceMappings":
            suggest = "block_device_mappings"
        elif key == "capacityReservationSpecification":
            suggest = "capacity_reservation_specification"
        elif key == "cpuOptions":
            suggest = "cpu_options"
        elif key == "creditSpecification":
            suggest = "credit_specification"
        elif key == "disableApiStop":
            suggest = "disable_api_stop"
        elif key == "disableApiTermination":
            suggest = "disable_api_termination"
        elif key == "ebsOptimized":
            suggest = "ebs_optimized"
        elif key == "elasticGpuSpecifications":
            suggest = "elastic_gpu_specifications"
        elif key == "elasticInferenceAccelerators":
            suggest = "elastic_inference_accelerators"
        elif key == "enclaveOptions":
            suggest = "enclave_options"
        elif key == "hibernationOptions":
            suggest = "hibernation_options"
        elif key == "iamInstanceProfile":
            suggest = "iam_instance_profile"
        elif key == "imageId":
            suggest = "image_id"
        elif key == "instanceInitiatedShutdownBehavior":
            suggest = "instance_initiated_shutdown_behavior"
        elif key == "instanceMarketOptions":
            suggest = "instance_market_options"
        elif key == "instanceRequirements":
            suggest = "instance_requirements"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "kernelId":
            suggest = "kernel_id"
        elif key == "keyName":
            suggest = "key_name"
        elif key == "licenseSpecifications":
            suggest = "license_specifications"
        elif key == "maintenanceOptions":
            suggest = "maintenance_options"
        elif key == "metadataOptions":
            suggest = "metadata_options"
        elif key == "networkInterfaces":
            suggest = "network_interfaces"
        elif key == "privateDnsNameOptions":
            suggest = "private_dns_name_options"
        elif key == "ramDiskId":
            suggest = "ram_disk_id"
        elif key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "securityGroups":
            suggest = "security_groups"
        elif key == "tagSpecifications":
            suggest = "tag_specifications"
        elif key == "userData":
            suggest = "user_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 block_device_mappings: Optional[Sequence['outputs.LaunchTemplateBlockDeviceMapping']] = None,
                 capacity_reservation_specification: Optional['outputs.LaunchTemplateCapacityReservationSpecification'] = None,
                 cpu_options: Optional['outputs.LaunchTemplateCpuOptions'] = None,
                 credit_specification: Optional['outputs.LaunchTemplateCreditSpecification'] = None,
                 disable_api_stop: Optional[bool] = None,
                 disable_api_termination: Optional[bool] = None,
                 ebs_optimized: Optional[bool] = None,
                 elastic_gpu_specifications: Optional[Sequence['outputs.LaunchTemplateElasticGpuSpecification']] = None,
                 elastic_inference_accelerators: Optional[Sequence['outputs.LaunchTemplateElasticInferenceAccelerator']] = None,
                 enclave_options: Optional['outputs.LaunchTemplateEnclaveOptions'] = None,
                 hibernation_options: Optional['outputs.LaunchTemplateHibernationOptions'] = None,
                 iam_instance_profile: Optional['outputs.LaunchTemplateIamInstanceProfile'] = None,
                 image_id: Optional[str] = None,
                 instance_initiated_shutdown_behavior: Optional[str] = None,
                 instance_market_options: Optional['outputs.LaunchTemplateInstanceMarketOptions'] = None,
                 instance_requirements: Optional['outputs.LaunchTemplateInstanceRequirements'] = None,
                 instance_type: Optional[str] = None,
                 kernel_id: Optional[str] = None,
                 key_name: Optional[str] = None,
                 license_specifications: Optional[Sequence['outputs.LaunchTemplateLicenseSpecification']] = None,
                 maintenance_options: Optional['outputs.LaunchTemplateMaintenanceOptions'] = None,
                 metadata_options: Optional['outputs.LaunchTemplateMetadataOptions'] = None,
                 monitoring: Optional['outputs.LaunchTemplateMonitoring'] = None,
                 network_interfaces: Optional[Sequence['outputs.LaunchTemplateNetworkInterface']] = None,
                 placement: Optional['outputs.LaunchTemplatePlacement'] = None,
                 private_dns_name_options: Optional['outputs.LaunchTemplatePrivateDnsNameOptions'] = None,
                 ram_disk_id: Optional[str] = None,
                 security_group_ids: Optional[Sequence[str]] = None,
                 security_groups: Optional[Sequence[str]] = None,
                 tag_specifications: Optional[Sequence['outputs.TagSpecification']] = None,
                 user_data: Optional[str] = None):
        """
        The information for the launch template.
        :param Sequence['LaunchTemplateBlockDeviceMapping'] block_device_mappings: The block device mapping.
        :param bool disable_api_stop: Indicates whether to enable the instance for stop protection.
        :param bool disable_api_termination: If you set this parameter to true, you can't terminate the instance using the Amazon EC2 console, CLI, or API.
        :param bool ebs_optimized: Indicates whether the instance is optimized for Amazon EBS I/O.
        :param Sequence['LaunchTemplateElasticGpuSpecification'] elastic_gpu_specifications: An elastic GPU to associate with the instance.
        :param Sequence['LaunchTemplateElasticInferenceAccelerator'] elastic_inference_accelerators: The elastic inference accelerator for the instance.
        :param str image_id: The ID of the AMI. Alternatively, you can specify a Systems Manager parameter, which will resolve to an AMI ID on launch.
        :param str instance_initiated_shutdown_behavior: Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
        :param str kernel_id: The ID of the kernel.
        :param str key_name: The name of the EC2 key pair
        :param Sequence['LaunchTemplateLicenseSpecification'] license_specifications: The license configurations.
        :param Sequence['LaunchTemplateNetworkInterface'] network_interfaces: If you specify a network interface, you must specify any security groups and subnets as part of the network interface.
        :param Sequence[str] security_group_ids: One or more security group IDs. 
        :param Sequence[str] security_groups: One or more security group names.
        :param Sequence['TagSpecification'] tag_specifications: The tags to apply to the resources that are created during instance launch.
        :param str user_data: The user data to make available to the instance.
        """
        if block_device_mappings is not None:
            pulumi.set(__self__, "block_device_mappings", block_device_mappings)
        if capacity_reservation_specification is not None:
            pulumi.set(__self__, "capacity_reservation_specification", capacity_reservation_specification)
        if cpu_options is not None:
            pulumi.set(__self__, "cpu_options", cpu_options)
        if credit_specification is not None:
            pulumi.set(__self__, "credit_specification", credit_specification)
        if disable_api_stop is not None:
            pulumi.set(__self__, "disable_api_stop", disable_api_stop)
        if disable_api_termination is not None:
            pulumi.set(__self__, "disable_api_termination", disable_api_termination)
        if ebs_optimized is not None:
            pulumi.set(__self__, "ebs_optimized", ebs_optimized)
        if elastic_gpu_specifications is not None:
            pulumi.set(__self__, "elastic_gpu_specifications", elastic_gpu_specifications)
        if elastic_inference_accelerators is not None:
            pulumi.set(__self__, "elastic_inference_accelerators", elastic_inference_accelerators)
        if enclave_options is not None:
            pulumi.set(__self__, "enclave_options", enclave_options)
        if hibernation_options is not None:
            pulumi.set(__self__, "hibernation_options", hibernation_options)
        if iam_instance_profile is not None:
            pulumi.set(__self__, "iam_instance_profile", iam_instance_profile)
        if image_id is not None:
            pulumi.set(__self__, "image_id", image_id)
        if instance_initiated_shutdown_behavior is not None:
            pulumi.set(__self__, "instance_initiated_shutdown_behavior", instance_initiated_shutdown_behavior)
        if instance_market_options is not None:
            pulumi.set(__self__, "instance_market_options", instance_market_options)
        if instance_requirements is not None:
            pulumi.set(__self__, "instance_requirements", instance_requirements)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if kernel_id is not None:
            pulumi.set(__self__, "kernel_id", kernel_id)
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if license_specifications is not None:
            pulumi.set(__self__, "license_specifications", license_specifications)
        if maintenance_options is not None:
            pulumi.set(__self__, "maintenance_options", maintenance_options)
        if metadata_options is not None:
            pulumi.set(__self__, "metadata_options", metadata_options)
        if monitoring is not None:
            pulumi.set(__self__, "monitoring", monitoring)
        if network_interfaces is not None:
            pulumi.set(__self__, "network_interfaces", network_interfaces)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if private_dns_name_options is not None:
            pulumi.set(__self__, "private_dns_name_options", private_dns_name_options)
        if ram_disk_id is not None:
            pulumi.set(__self__, "ram_disk_id", ram_disk_id)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if tag_specifications is not None:
            pulumi.set(__self__, "tag_specifications", tag_specifications)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)

    @property
    @pulumi.getter(name="blockDeviceMappings")
    def block_device_mappings(self) -> Optional[Sequence['outputs.LaunchTemplateBlockDeviceMapping']]:
        """
        The block device mapping.
        """
        return pulumi.get(self, "block_device_mappings")

    @property
    @pulumi.getter(name="capacityReservationSpecification")
    def capacity_reservation_specification(self) -> Optional['outputs.LaunchTemplateCapacityReservationSpecification']:
        return pulumi.get(self, "capacity_reservation_specification")

    @property
    @pulumi.getter(name="cpuOptions")
    def cpu_options(self) -> Optional['outputs.LaunchTemplateCpuOptions']:
        return pulumi.get(self, "cpu_options")

    @property
    @pulumi.getter(name="creditSpecification")
    def credit_specification(self) -> Optional['outputs.LaunchTemplateCreditSpecification']:
        return pulumi.get(self, "credit_specification")

    @property
    @pulumi.getter(name="disableApiStop")
    def disable_api_stop(self) -> Optional[bool]:
        """
        Indicates whether to enable the instance for stop protection.
        """
        return pulumi.get(self, "disable_api_stop")

    @property
    @pulumi.getter(name="disableApiTermination")
    def disable_api_termination(self) -> Optional[bool]:
        """
        If you set this parameter to true, you can't terminate the instance using the Amazon EC2 console, CLI, or API.
        """
        return pulumi.get(self, "disable_api_termination")

    @property
    @pulumi.getter(name="ebsOptimized")
    def ebs_optimized(self) -> Optional[bool]:
        """
        Indicates whether the instance is optimized for Amazon EBS I/O.
        """
        return pulumi.get(self, "ebs_optimized")

    @property
    @pulumi.getter(name="elasticGpuSpecifications")
    def elastic_gpu_specifications(self) -> Optional[Sequence['outputs.LaunchTemplateElasticGpuSpecification']]:
        """
        An elastic GPU to associate with the instance.
        """
        return pulumi.get(self, "elastic_gpu_specifications")

    @property
    @pulumi.getter(name="elasticInferenceAccelerators")
    def elastic_inference_accelerators(self) -> Optional[Sequence['outputs.LaunchTemplateElasticInferenceAccelerator']]:
        """
        The elastic inference accelerator for the instance.
        """
        return pulumi.get(self, "elastic_inference_accelerators")

    @property
    @pulumi.getter(name="enclaveOptions")
    def enclave_options(self) -> Optional['outputs.LaunchTemplateEnclaveOptions']:
        return pulumi.get(self, "enclave_options")

    @property
    @pulumi.getter(name="hibernationOptions")
    def hibernation_options(self) -> Optional['outputs.LaunchTemplateHibernationOptions']:
        return pulumi.get(self, "hibernation_options")

    @property
    @pulumi.getter(name="iamInstanceProfile")
    def iam_instance_profile(self) -> Optional['outputs.LaunchTemplateIamInstanceProfile']:
        return pulumi.get(self, "iam_instance_profile")

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> Optional[str]:
        """
        The ID of the AMI. Alternatively, you can specify a Systems Manager parameter, which will resolve to an AMI ID on launch.
        """
        return pulumi.get(self, "image_id")

    @property
    @pulumi.getter(name="instanceInitiatedShutdownBehavior")
    def instance_initiated_shutdown_behavior(self) -> Optional[str]:
        """
        Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown).
        """
        return pulumi.get(self, "instance_initiated_shutdown_behavior")

    @property
    @pulumi.getter(name="instanceMarketOptions")
    def instance_market_options(self) -> Optional['outputs.LaunchTemplateInstanceMarketOptions']:
        return pulumi.get(self, "instance_market_options")

    @property
    @pulumi.getter(name="instanceRequirements")
    def instance_requirements(self) -> Optional['outputs.LaunchTemplateInstanceRequirements']:
        return pulumi.get(self, "instance_requirements")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[str]:
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="kernelId")
    def kernel_id(self) -> Optional[str]:
        """
        The ID of the kernel.
        """
        return pulumi.get(self, "kernel_id")

    @property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[str]:
        """
        The name of the EC2 key pair
        """
        return pulumi.get(self, "key_name")

    @property
    @pulumi.getter(name="licenseSpecifications")
    def license_specifications(self) -> Optional[Sequence['outputs.LaunchTemplateLicenseSpecification']]:
        """
        The license configurations.
        """
        return pulumi.get(self, "license_specifications")

    @property
    @pulumi.getter(name="maintenanceOptions")
    def maintenance_options(self) -> Optional['outputs.LaunchTemplateMaintenanceOptions']:
        return pulumi.get(self, "maintenance_options")

    @property
    @pulumi.getter(name="metadataOptions")
    def metadata_options(self) -> Optional['outputs.LaunchTemplateMetadataOptions']:
        return pulumi.get(self, "metadata_options")

    @property
    @pulumi.getter
    def monitoring(self) -> Optional['outputs.LaunchTemplateMonitoring']:
        return pulumi.get(self, "monitoring")

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Optional[Sequence['outputs.LaunchTemplateNetworkInterface']]:
        """
        If you specify a network interface, you must specify any security groups and subnets as part of the network interface.
        """
        return pulumi.get(self, "network_interfaces")

    @property
    @pulumi.getter
    def placement(self) -> Optional['outputs.LaunchTemplatePlacement']:
        return pulumi.get(self, "placement")

    @property
    @pulumi.getter(name="privateDnsNameOptions")
    def private_dns_name_options(self) -> Optional['outputs.LaunchTemplatePrivateDnsNameOptions']:
        return pulumi.get(self, "private_dns_name_options")

    @property
    @pulumi.getter(name="ramDiskId")
    def ram_disk_id(self) -> Optional[str]:
        return pulumi.get(self, "ram_disk_id")

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[str]]:
        """
        One or more security group IDs. 
        """
        return pulumi.get(self, "security_group_ids")

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[str]]:
        """
        One or more security group names.
        """
        return pulumi.get(self, "security_groups")

    @property
    @pulumi.getter(name="tagSpecifications")
    def tag_specifications(self) -> Optional[Sequence['outputs.TagSpecification']]:
        """
        The tags to apply to the resources that are created during instance launch.
        """
        return pulumi.get(self, "tag_specifications")

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[str]:
        """
        The user data to make available to the instance.
        """
        return pulumi.get(self, "user_data")


@pulumi.output_type
class LaunchTemplateEbs(dict):
    """
    Parameters for a block device for an EBS volume in an Amazon EC2 launch template.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateEbs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateEbs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateEbs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_on_termination: Optional[bool] = None,
                 encrypted: Optional[bool] = None,
                 iops: Optional[int] = None,
                 kms_key_id: Optional[str] = None,
                 snapshot_id: Optional[str] = None,
                 throughput: Optional[int] = None,
                 volume_size: Optional[int] = None,
                 volume_type: Optional[str] = None):
        """
        Parameters for a block device for an EBS volume in an Amazon EC2 launch template.
        :param bool delete_on_termination: Indicates whether the EBS volume is deleted on instance termination.
        :param bool encrypted: Indicates whether the EBS volume is encrypted. Encrypted volumes can only be attached to instances that support Amazon EBS encryption. If you are creating a volume from a snapshot, you can't specify an encryption value.
        :param int iops: The number of I/O operations per second (IOPS).
        :param str kms_key_id: The ARN of the symmetric AWS Key Management Service (AWS KMS) CMK used for encryption.
        :param str snapshot_id: The ID of the snapshot.
        :param int throughput: The throughput to provision for a gp3 volume, with a maximum of 1,000 MiB/s.
        :param int volume_size: The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size.
        :param str volume_type: The volume type.
        """
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[bool]:
        """
        Indicates whether the EBS volume is deleted on instance termination.
        """
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[bool]:
        """
        Indicates whether the EBS volume is encrypted. Encrypted volumes can only be attached to instances that support Amazon EBS encryption. If you are creating a volume from a snapshot, you can't specify an encryption value.
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        """
        The number of I/O operations per second (IOPS).
        """
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        """
        The ARN of the symmetric AWS Key Management Service (AWS KMS) CMK used for encryption.
        """
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        """
        The ID of the snapshot.
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter
    def throughput(self) -> Optional[int]:
        """
        The throughput to provision for a gp3 volume, with a maximum of 1,000 MiB/s.
        """
        return pulumi.get(self, "throughput")

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[int]:
        """
        The size of the volume, in GiBs. You must specify either a snapshot ID or a volume size.
        """
        return pulumi.get(self, "volume_size")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[str]:
        """
        The volume type.
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class LaunchTemplateElasticGpuSpecification(dict):
    """
    Specifies a specification for an Elastic GPU for launch template.
    """
    def __init__(__self__, *,
                 type: Optional[str] = None):
        """
        Specifies a specification for an Elastic GPU for launch template.
        :param str type: The type of Elastic Graphics accelerator.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of Elastic Graphics accelerator.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class LaunchTemplateElasticInferenceAccelerator(dict):
    """
    Specifies an elastic inference accelerator.
    """
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 type: Optional[str] = None):
        """
        Specifies an elastic inference accelerator.
        :param int count: The number of elastic inference accelerators to attach to the instance.
        :param str type: The type of elastic inference accelerator.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The number of elastic inference accelerators to attach to the instance.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of elastic inference accelerator.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class LaunchTemplateEnclaveOptions(dict):
    """
    Indicates whether the instance is enabled for AWS Nitro Enclaves.
    """
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        Indicates whether the instance is enabled for AWS Nitro Enclaves.
        :param bool enabled: If this parameter is set to true, the instance is enabled for AWS Nitro Enclaves; otherwise, it is not enabled for AWS Nitro Enclaves.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        If this parameter is set to true, the instance is enabled for AWS Nitro Enclaves; otherwise, it is not enabled for AWS Nitro Enclaves.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class LaunchTemplateHibernationOptions(dict):
    """
    Specifies whether your instance is configured for hibernation.
    """
    def __init__(__self__, *,
                 configured: Optional[bool] = None):
        """
        Specifies whether your instance is configured for hibernation.
        :param bool configured: TIf you set this parameter to true, the instance is enabled for hibernation.
        """
        if configured is not None:
            pulumi.set(__self__, "configured", configured)

    @property
    @pulumi.getter
    def configured(self) -> Optional[bool]:
        """
        TIf you set this parameter to true, the instance is enabled for hibernation.
        """
        return pulumi.get(self, "configured")


@pulumi.output_type
class LaunchTemplateIamInstanceProfile(dict):
    """
    Specifies an IAM instance profile, which is a container for an IAM role for your instance.
    """
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 name: Optional[str] = None):
        """
        Specifies an IAM instance profile, which is a container for an IAM role for your instance.
        :param str arn: The Amazon Resource Name (ARN) of the instance profile.
        :param str name: The name of the instance profile.
        """
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the instance profile.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the instance profile.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LaunchTemplateInstanceMarketOptions(dict):
    """
    The market (purchasing) option for the instances.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "marketType":
            suggest = "market_type"
        elif key == "spotOptions":
            suggest = "spot_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateInstanceMarketOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateInstanceMarketOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateInstanceMarketOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 market_type: Optional[str] = None,
                 spot_options: Optional['outputs.LaunchTemplateSpotOptions'] = None):
        """
        The market (purchasing) option for the instances.
        :param str market_type: The market type.
        """
        if market_type is not None:
            pulumi.set(__self__, "market_type", market_type)
        if spot_options is not None:
            pulumi.set(__self__, "spot_options", spot_options)

    @property
    @pulumi.getter(name="marketType")
    def market_type(self) -> Optional[str]:
        """
        The market type.
        """
        return pulumi.get(self, "market_type")

    @property
    @pulumi.getter(name="spotOptions")
    def spot_options(self) -> Optional['outputs.LaunchTemplateSpotOptions']:
        return pulumi.get(self, "spot_options")


@pulumi.output_type
class LaunchTemplateInstanceRequirements(dict):
    """
    The attributes for the instance types.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceleratorCount":
            suggest = "accelerator_count"
        elif key == "acceleratorManufacturers":
            suggest = "accelerator_manufacturers"
        elif key == "acceleratorNames":
            suggest = "accelerator_names"
        elif key == "acceleratorTotalMemoryMiB":
            suggest = "accelerator_total_memory_mi_b"
        elif key == "acceleratorTypes":
            suggest = "accelerator_types"
        elif key == "allowedInstanceTypes":
            suggest = "allowed_instance_types"
        elif key == "bareMetal":
            suggest = "bare_metal"
        elif key == "baselineEbsBandwidthMbps":
            suggest = "baseline_ebs_bandwidth_mbps"
        elif key == "burstablePerformance":
            suggest = "burstable_performance"
        elif key == "cpuManufacturers":
            suggest = "cpu_manufacturers"
        elif key == "excludedInstanceTypes":
            suggest = "excluded_instance_types"
        elif key == "instanceGenerations":
            suggest = "instance_generations"
        elif key == "localStorage":
            suggest = "local_storage"
        elif key == "localStorageTypes":
            suggest = "local_storage_types"
        elif key == "memoryGiBPerVCpu":
            suggest = "memory_gi_b_per_v_cpu"
        elif key == "memoryMiB":
            suggest = "memory_mi_b"
        elif key == "networkBandwidthGbps":
            suggest = "network_bandwidth_gbps"
        elif key == "networkInterfaceCount":
            suggest = "network_interface_count"
        elif key == "onDemandMaxPricePercentageOverLowestPrice":
            suggest = "on_demand_max_price_percentage_over_lowest_price"
        elif key == "requireHibernateSupport":
            suggest = "require_hibernate_support"
        elif key == "spotMaxPricePercentageOverLowestPrice":
            suggest = "spot_max_price_percentage_over_lowest_price"
        elif key == "totalLocalStorageGb":
            suggest = "total_local_storage_gb"
        elif key == "vCpuCount":
            suggest = "v_cpu_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateInstanceRequirements. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateInstanceRequirements.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateInstanceRequirements.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accelerator_count: Optional['outputs.LaunchTemplateAcceleratorCount'] = None,
                 accelerator_manufacturers: Optional[Sequence[str]] = None,
                 accelerator_names: Optional[Sequence[str]] = None,
                 accelerator_total_memory_mi_b: Optional['outputs.LaunchTemplateAcceleratorTotalMemoryMiB'] = None,
                 accelerator_types: Optional[Sequence[str]] = None,
                 allowed_instance_types: Optional[Sequence[str]] = None,
                 bare_metal: Optional[str] = None,
                 baseline_ebs_bandwidth_mbps: Optional['outputs.LaunchTemplateBaselineEbsBandwidthMbps'] = None,
                 burstable_performance: Optional[str] = None,
                 cpu_manufacturers: Optional[Sequence[str]] = None,
                 excluded_instance_types: Optional[Sequence[str]] = None,
                 instance_generations: Optional[Sequence[str]] = None,
                 local_storage: Optional[str] = None,
                 local_storage_types: Optional[Sequence[str]] = None,
                 memory_gi_b_per_v_cpu: Optional['outputs.LaunchTemplateMemoryGiBPerVCpu'] = None,
                 memory_mi_b: Optional['outputs.LaunchTemplateMemoryMiB'] = None,
                 network_bandwidth_gbps: Optional['outputs.LaunchTemplateNetworkBandwidthGbps'] = None,
                 network_interface_count: Optional['outputs.LaunchTemplateNetworkInterfaceCount'] = None,
                 on_demand_max_price_percentage_over_lowest_price: Optional[int] = None,
                 require_hibernate_support: Optional[bool] = None,
                 spot_max_price_percentage_over_lowest_price: Optional[int] = None,
                 total_local_storage_gb: Optional['outputs.LaunchTemplateTotalLocalStorageGb'] = None,
                 v_cpu_count: Optional['outputs.LaunchTemplateVCpuCount'] = None):
        """
        The attributes for the instance types.
        :param Sequence[str] accelerator_manufacturers: Indicates whether instance types must have accelerators by specific manufacturers.
        :param Sequence[str] accelerator_names: The accelerators that must be on the instance type.
        :param Sequence[str] accelerator_types: The accelerator types that must be on the instance type.
        :param Sequence[str] allowed_instance_types: The instance types to apply your specified attributes against.
        :param str bare_metal: Indicates whether bare metal instance types must be included, excluded, or required.
        :param Sequence[str] cpu_manufacturers: The CPU manufacturers to include.
        :param Sequence[str] excluded_instance_types: The instance types to exclude.
        :param Sequence[str] instance_generations: Indicates whether current or previous generation instance types are included.
        :param str local_storage: The user data to make available to the instance.
        :param Sequence[str] local_storage_types: The type of local storage that is required.
        :param int on_demand_max_price_percentage_over_lowest_price: The price protection threshold for On-Demand Instances.
        :param bool require_hibernate_support: Indicates whether instance types must support hibernation for On-Demand Instances.
        :param int spot_max_price_percentage_over_lowest_price: The price protection threshold for Spot Instances.
        """
        if accelerator_count is not None:
            pulumi.set(__self__, "accelerator_count", accelerator_count)
        if accelerator_manufacturers is not None:
            pulumi.set(__self__, "accelerator_manufacturers", accelerator_manufacturers)
        if accelerator_names is not None:
            pulumi.set(__self__, "accelerator_names", accelerator_names)
        if accelerator_total_memory_mi_b is not None:
            pulumi.set(__self__, "accelerator_total_memory_mi_b", accelerator_total_memory_mi_b)
        if accelerator_types is not None:
            pulumi.set(__self__, "accelerator_types", accelerator_types)
        if allowed_instance_types is not None:
            pulumi.set(__self__, "allowed_instance_types", allowed_instance_types)
        if bare_metal is not None:
            pulumi.set(__self__, "bare_metal", bare_metal)
        if baseline_ebs_bandwidth_mbps is not None:
            pulumi.set(__self__, "baseline_ebs_bandwidth_mbps", baseline_ebs_bandwidth_mbps)
        if burstable_performance is not None:
            pulumi.set(__self__, "burstable_performance", burstable_performance)
        if cpu_manufacturers is not None:
            pulumi.set(__self__, "cpu_manufacturers", cpu_manufacturers)
        if excluded_instance_types is not None:
            pulumi.set(__self__, "excluded_instance_types", excluded_instance_types)
        if instance_generations is not None:
            pulumi.set(__self__, "instance_generations", instance_generations)
        if local_storage is not None:
            pulumi.set(__self__, "local_storage", local_storage)
        if local_storage_types is not None:
            pulumi.set(__self__, "local_storage_types", local_storage_types)
        if memory_gi_b_per_v_cpu is not None:
            pulumi.set(__self__, "memory_gi_b_per_v_cpu", memory_gi_b_per_v_cpu)
        if memory_mi_b is not None:
            pulumi.set(__self__, "memory_mi_b", memory_mi_b)
        if network_bandwidth_gbps is not None:
            pulumi.set(__self__, "network_bandwidth_gbps", network_bandwidth_gbps)
        if network_interface_count is not None:
            pulumi.set(__self__, "network_interface_count", network_interface_count)
        if on_demand_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "on_demand_max_price_percentage_over_lowest_price", on_demand_max_price_percentage_over_lowest_price)
        if require_hibernate_support is not None:
            pulumi.set(__self__, "require_hibernate_support", require_hibernate_support)
        if spot_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "spot_max_price_percentage_over_lowest_price", spot_max_price_percentage_over_lowest_price)
        if total_local_storage_gb is not None:
            pulumi.set(__self__, "total_local_storage_gb", total_local_storage_gb)
        if v_cpu_count is not None:
            pulumi.set(__self__, "v_cpu_count", v_cpu_count)

    @property
    @pulumi.getter(name="acceleratorCount")
    def accelerator_count(self) -> Optional['outputs.LaunchTemplateAcceleratorCount']:
        return pulumi.get(self, "accelerator_count")

    @property
    @pulumi.getter(name="acceleratorManufacturers")
    def accelerator_manufacturers(self) -> Optional[Sequence[str]]:
        """
        Indicates whether instance types must have accelerators by specific manufacturers.
        """
        return pulumi.get(self, "accelerator_manufacturers")

    @property
    @pulumi.getter(name="acceleratorNames")
    def accelerator_names(self) -> Optional[Sequence[str]]:
        """
        The accelerators that must be on the instance type.
        """
        return pulumi.get(self, "accelerator_names")

    @property
    @pulumi.getter(name="acceleratorTotalMemoryMiB")
    def accelerator_total_memory_mi_b(self) -> Optional['outputs.LaunchTemplateAcceleratorTotalMemoryMiB']:
        return pulumi.get(self, "accelerator_total_memory_mi_b")

    @property
    @pulumi.getter(name="acceleratorTypes")
    def accelerator_types(self) -> Optional[Sequence[str]]:
        """
        The accelerator types that must be on the instance type.
        """
        return pulumi.get(self, "accelerator_types")

    @property
    @pulumi.getter(name="allowedInstanceTypes")
    def allowed_instance_types(self) -> Optional[Sequence[str]]:
        """
        The instance types to apply your specified attributes against.
        """
        return pulumi.get(self, "allowed_instance_types")

    @property
    @pulumi.getter(name="bareMetal")
    def bare_metal(self) -> Optional[str]:
        """
        Indicates whether bare metal instance types must be included, excluded, or required.
        """
        return pulumi.get(self, "bare_metal")

    @property
    @pulumi.getter(name="baselineEbsBandwidthMbps")
    def baseline_ebs_bandwidth_mbps(self) -> Optional['outputs.LaunchTemplateBaselineEbsBandwidthMbps']:
        return pulumi.get(self, "baseline_ebs_bandwidth_mbps")

    @property
    @pulumi.getter(name="burstablePerformance")
    def burstable_performance(self) -> Optional[str]:
        return pulumi.get(self, "burstable_performance")

    @property
    @pulumi.getter(name="cpuManufacturers")
    def cpu_manufacturers(self) -> Optional[Sequence[str]]:
        """
        The CPU manufacturers to include.
        """
        return pulumi.get(self, "cpu_manufacturers")

    @property
    @pulumi.getter(name="excludedInstanceTypes")
    def excluded_instance_types(self) -> Optional[Sequence[str]]:
        """
        The instance types to exclude.
        """
        return pulumi.get(self, "excluded_instance_types")

    @property
    @pulumi.getter(name="instanceGenerations")
    def instance_generations(self) -> Optional[Sequence[str]]:
        """
        Indicates whether current or previous generation instance types are included.
        """
        return pulumi.get(self, "instance_generations")

    @property
    @pulumi.getter(name="localStorage")
    def local_storage(self) -> Optional[str]:
        """
        The user data to make available to the instance.
        """
        return pulumi.get(self, "local_storage")

    @property
    @pulumi.getter(name="localStorageTypes")
    def local_storage_types(self) -> Optional[Sequence[str]]:
        """
        The type of local storage that is required.
        """
        return pulumi.get(self, "local_storage_types")

    @property
    @pulumi.getter(name="memoryGiBPerVCpu")
    def memory_gi_b_per_v_cpu(self) -> Optional['outputs.LaunchTemplateMemoryGiBPerVCpu']:
        return pulumi.get(self, "memory_gi_b_per_v_cpu")

    @property
    @pulumi.getter(name="memoryMiB")
    def memory_mi_b(self) -> Optional['outputs.LaunchTemplateMemoryMiB']:
        return pulumi.get(self, "memory_mi_b")

    @property
    @pulumi.getter(name="networkBandwidthGbps")
    def network_bandwidth_gbps(self) -> Optional['outputs.LaunchTemplateNetworkBandwidthGbps']:
        return pulumi.get(self, "network_bandwidth_gbps")

    @property
    @pulumi.getter(name="networkInterfaceCount")
    def network_interface_count(self) -> Optional['outputs.LaunchTemplateNetworkInterfaceCount']:
        return pulumi.get(self, "network_interface_count")

    @property
    @pulumi.getter(name="onDemandMaxPricePercentageOverLowestPrice")
    def on_demand_max_price_percentage_over_lowest_price(self) -> Optional[int]:
        """
        The price protection threshold for On-Demand Instances.
        """
        return pulumi.get(self, "on_demand_max_price_percentage_over_lowest_price")

    @property
    @pulumi.getter(name="requireHibernateSupport")
    def require_hibernate_support(self) -> Optional[bool]:
        """
        Indicates whether instance types must support hibernation for On-Demand Instances.
        """
        return pulumi.get(self, "require_hibernate_support")

    @property
    @pulumi.getter(name="spotMaxPricePercentageOverLowestPrice")
    def spot_max_price_percentage_over_lowest_price(self) -> Optional[int]:
        """
        The price protection threshold for Spot Instances.
        """
        return pulumi.get(self, "spot_max_price_percentage_over_lowest_price")

    @property
    @pulumi.getter(name="totalLocalStorageGb")
    def total_local_storage_gb(self) -> Optional['outputs.LaunchTemplateTotalLocalStorageGb']:
        return pulumi.get(self, "total_local_storage_gb")

    @property
    @pulumi.getter(name="vCpuCount")
    def v_cpu_count(self) -> Optional['outputs.LaunchTemplateVCpuCount']:
        return pulumi.get(self, "v_cpu_count")


@pulumi.output_type
class LaunchTemplateIpv4PrefixSpecification(dict):
    """
    Specifies an IPv4 prefix for a network interface.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv4Prefix":
            suggest = "ipv4_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateIpv4PrefixSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateIpv4PrefixSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateIpv4PrefixSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv4_prefix: Optional[str] = None):
        """
        Specifies an IPv4 prefix for a network interface.
        :param str ipv4_prefix: The IPv4 prefix.
        """
        if ipv4_prefix is not None:
            pulumi.set(__self__, "ipv4_prefix", ipv4_prefix)

    @property
    @pulumi.getter(name="ipv4Prefix")
    def ipv4_prefix(self) -> Optional[str]:
        """
        The IPv4 prefix.
        """
        return pulumi.get(self, "ipv4_prefix")


@pulumi.output_type
class LaunchTemplateIpv6Add(dict):
    """
    Specifies an IPv6 address.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv6Address":
            suggest = "ipv6_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateIpv6Add. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateIpv6Add.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateIpv6Add.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv6_address: Optional[str] = None):
        """
        Specifies an IPv6 address.
        """
        if ipv6_address is not None:
            pulumi.set(__self__, "ipv6_address", ipv6_address)

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> Optional[str]:
        return pulumi.get(self, "ipv6_address")


@pulumi.output_type
class LaunchTemplateIpv6PrefixSpecification(dict):
    """
    Specifies an IPv6 prefix for a network interface.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv6Prefix":
            suggest = "ipv6_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateIpv6PrefixSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateIpv6PrefixSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateIpv6PrefixSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv6_prefix: Optional[str] = None):
        """
        Specifies an IPv6 prefix for a network interface.
        """
        if ipv6_prefix is not None:
            pulumi.set(__self__, "ipv6_prefix", ipv6_prefix)

    @property
    @pulumi.getter(name="ipv6Prefix")
    def ipv6_prefix(self) -> Optional[str]:
        return pulumi.get(self, "ipv6_prefix")


@pulumi.output_type
class LaunchTemplateLicenseSpecification(dict):
    """
    Specifies a license configuration for an instance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "licenseConfigurationArn":
            suggest = "license_configuration_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateLicenseSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateLicenseSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateLicenseSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 license_configuration_arn: Optional[str] = None):
        """
        Specifies a license configuration for an instance.
        :param str license_configuration_arn: The Amazon Resource Name (ARN) of the license configuration.
        """
        if license_configuration_arn is not None:
            pulumi.set(__self__, "license_configuration_arn", license_configuration_arn)

    @property
    @pulumi.getter(name="licenseConfigurationArn")
    def license_configuration_arn(self) -> Optional[str]:
        """
        The Amazon Resource Name (ARN) of the license configuration.
        """
        return pulumi.get(self, "license_configuration_arn")


@pulumi.output_type
class LaunchTemplateMaintenanceOptions(dict):
    """
    The maintenance options of your instance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoRecovery":
            suggest = "auto_recovery"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateMaintenanceOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateMaintenanceOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateMaintenanceOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_recovery: Optional[str] = None):
        """
        The maintenance options of your instance.
        :param str auto_recovery: Disables the automatic recovery behavior of your instance or sets it to default.
        """
        if auto_recovery is not None:
            pulumi.set(__self__, "auto_recovery", auto_recovery)

    @property
    @pulumi.getter(name="autoRecovery")
    def auto_recovery(self) -> Optional[str]:
        """
        Disables the automatic recovery behavior of your instance or sets it to default.
        """
        return pulumi.get(self, "auto_recovery")


@pulumi.output_type
class LaunchTemplateMemoryGiBPerVCpu(dict):
    """
    The minimum and maximum amount of memory per vCPU, in GiB.
    """
    def __init__(__self__, *,
                 max: Optional[float] = None,
                 min: Optional[float] = None):
        """
        The minimum and maximum amount of memory per vCPU, in GiB.
        :param float max: The maximum amount of memory per vCPU, in GiB.
        :param float min: TThe minimum amount of memory per vCPU, in GiB.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        """
        The maximum amount of memory per vCPU, in GiB.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        """
        TThe minimum amount of memory per vCPU, in GiB.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateMemoryMiB(dict):
    """
    The minimum and maximum amount of memory, in MiB.
    """
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        The minimum and maximum amount of memory, in MiB.
        :param int max: The maximum amount of memory, in MiB.
        :param int min: The minimum amount of memory, in MiB.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        The maximum amount of memory, in MiB.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        The minimum amount of memory, in MiB.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateMetadataOptions(dict):
    """
    The metadata options for the instance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpEndpoint":
            suggest = "http_endpoint"
        elif key == "httpProtocolIpv6":
            suggest = "http_protocol_ipv6"
        elif key == "httpPutResponseHopLimit":
            suggest = "http_put_response_hop_limit"
        elif key == "httpTokens":
            suggest = "http_tokens"
        elif key == "instanceMetadataTags":
            suggest = "instance_metadata_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateMetadataOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateMetadataOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateMetadataOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_endpoint: Optional[str] = None,
                 http_protocol_ipv6: Optional[str] = None,
                 http_put_response_hop_limit: Optional[int] = None,
                 http_tokens: Optional[str] = None,
                 instance_metadata_tags: Optional[str] = None):
        """
        The metadata options for the instance.
        :param str http_endpoint: Enables or disables the HTTP metadata endpoint on your instances. If the parameter is not specified, the default state is enabled.
        :param str http_protocol_ipv6: Enables or disables the IPv6 endpoint for the instance metadata service.
        :param int http_put_response_hop_limit: The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel.
        :param str http_tokens: IMDSv2 uses token-backed sessions.
        :param str instance_metadata_tags: Set to enabled to allow access to instance tags from the instance metadata.
        """
        if http_endpoint is not None:
            pulumi.set(__self__, "http_endpoint", http_endpoint)
        if http_protocol_ipv6 is not None:
            pulumi.set(__self__, "http_protocol_ipv6", http_protocol_ipv6)
        if http_put_response_hop_limit is not None:
            pulumi.set(__self__, "http_put_response_hop_limit", http_put_response_hop_limit)
        if http_tokens is not None:
            pulumi.set(__self__, "http_tokens", http_tokens)
        if instance_metadata_tags is not None:
            pulumi.set(__self__, "instance_metadata_tags", instance_metadata_tags)

    @property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> Optional[str]:
        """
        Enables or disables the HTTP metadata endpoint on your instances. If the parameter is not specified, the default state is enabled.
        """
        return pulumi.get(self, "http_endpoint")

    @property
    @pulumi.getter(name="httpProtocolIpv6")
    def http_protocol_ipv6(self) -> Optional[str]:
        """
        Enables or disables the IPv6 endpoint for the instance metadata service.
        """
        return pulumi.get(self, "http_protocol_ipv6")

    @property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> Optional[int]:
        """
        The desired HTTP PUT response hop limit for instance metadata requests. The larger the number, the further instance metadata requests can travel.
        """
        return pulumi.get(self, "http_put_response_hop_limit")

    @property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> Optional[str]:
        """
        IMDSv2 uses token-backed sessions.
        """
        return pulumi.get(self, "http_tokens")

    @property
    @pulumi.getter(name="instanceMetadataTags")
    def instance_metadata_tags(self) -> Optional[str]:
        """
        Set to enabled to allow access to instance tags from the instance metadata.
        """
        return pulumi.get(self, "instance_metadata_tags")


@pulumi.output_type
class LaunchTemplateMonitoring(dict):
    """
    Specifies whether detailed monitoring is enabled for an instance.
    """
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        Specifies whether detailed monitoring is enabled for an instance.
        :param bool enabled: Specify true to enable detailed monitoring.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Specify true to enable detailed monitoring.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class LaunchTemplateNetworkBandwidthGbps(dict):
    """
    The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps).
    """
    def __init__(__self__, *,
                 max: Optional[float] = None,
                 min: Optional[float] = None):
        """
        The minimum and maximum amount of network bandwidth, in gigabits per second (Gbps).
        :param float max: The maximum amount of network bandwidth, in Gbps.
        :param float min: The minimum amount of network bandwidth, in Gbps.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        """
        The maximum amount of network bandwidth, in Gbps.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        """
        The minimum amount of network bandwidth, in Gbps.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateNetworkInterface(dict):
    """
    Specifies the parameters for a network interface.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "associateCarrierIpAddress":
            suggest = "associate_carrier_ip_address"
        elif key == "associatePublicIpAddress":
            suggest = "associate_public_ip_address"
        elif key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "deviceIndex":
            suggest = "device_index"
        elif key == "interfaceType":
            suggest = "interface_type"
        elif key == "ipv4PrefixCount":
            suggest = "ipv4_prefix_count"
        elif key == "ipv4Prefixes":
            suggest = "ipv4_prefixes"
        elif key == "ipv6AddressCount":
            suggest = "ipv6_address_count"
        elif key == "ipv6Addresses":
            suggest = "ipv6_addresses"
        elif key == "ipv6PrefixCount":
            suggest = "ipv6_prefix_count"
        elif key == "ipv6Prefixes":
            suggest = "ipv6_prefixes"
        elif key == "networkCardIndex":
            suggest = "network_card_index"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "primaryIpv6":
            suggest = "primary_ipv6"
        elif key == "privateIpAddress":
            suggest = "private_ip_address"
        elif key == "privateIpAddresses":
            suggest = "private_ip_addresses"
        elif key == "secondaryPrivateIpAddressCount":
            suggest = "secondary_private_ip_address_count"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 associate_carrier_ip_address: Optional[bool] = None,
                 associate_public_ip_address: Optional[bool] = None,
                 delete_on_termination: Optional[bool] = None,
                 description: Optional[str] = None,
                 device_index: Optional[int] = None,
                 groups: Optional[Sequence[str]] = None,
                 interface_type: Optional[str] = None,
                 ipv4_prefix_count: Optional[int] = None,
                 ipv4_prefixes: Optional[Sequence['outputs.LaunchTemplateIpv4PrefixSpecification']] = None,
                 ipv6_address_count: Optional[int] = None,
                 ipv6_addresses: Optional[Sequence['outputs.LaunchTemplateIpv6Add']] = None,
                 ipv6_prefix_count: Optional[int] = None,
                 ipv6_prefixes: Optional[Sequence['outputs.LaunchTemplateIpv6PrefixSpecification']] = None,
                 network_card_index: Optional[int] = None,
                 network_interface_id: Optional[str] = None,
                 primary_ipv6: Optional[bool] = None,
                 private_ip_address: Optional[str] = None,
                 private_ip_addresses: Optional[Sequence['outputs.LaunchTemplatePrivateIpAdd']] = None,
                 secondary_private_ip_address_count: Optional[int] = None,
                 subnet_id: Optional[str] = None):
        """
        Specifies the parameters for a network interface.
        :param bool associate_carrier_ip_address: Indicates whether to associate a Carrier IP address with eth0 for a new network interface.
        :param bool associate_public_ip_address: Associates a public IPv4 address with eth0 for a new network interface.
        :param bool delete_on_termination: Indicates whether the network interface is deleted when the instance is terminated.
        :param str description: A description for the network interface.
        :param int device_index: The device index for the network interface attachment.
        :param Sequence[str] groups: The IDs of one or more security groups.
        :param str interface_type: The type of network interface.
        :param int ipv4_prefix_count: The number of IPv4 prefixes to be automatically assigned to the network interface.
        :param Sequence['LaunchTemplateIpv4PrefixSpecification'] ipv4_prefixes: One or more IPv4 prefixes to be assigned to the network interface.
        :param int ipv6_address_count: The number of IPv6 addresses to assign to a network interface.
        :param Sequence['LaunchTemplateIpv6Add'] ipv6_addresses: One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet.
        :param int ipv6_prefix_count: The number of IPv6 prefixes to be automatically assigned to the network interface.
        :param Sequence['LaunchTemplateIpv6PrefixSpecification'] ipv6_prefixes: One or more IPv6 prefixes to be assigned to the network interface.
        :param int network_card_index: The index of the network card.
        :param str network_interface_id: The ID of the network interface.
        :param bool primary_ipv6: Enables the first IPv6 global unique address (GUA) on a dual stack or IPv6-only ENI immutable.
        :param str private_ip_address: The primary private IPv4 address of the network interface.
        :param Sequence['LaunchTemplatePrivateIpAdd'] private_ip_addresses: One or more private IPv4 addresses.
        :param int secondary_private_ip_address_count: The number of secondary private IPv4 addresses to assign to a network interface.
        :param str subnet_id: The ID of the subnet for the network interface.
        """
        if associate_carrier_ip_address is not None:
            pulumi.set(__self__, "associate_carrier_ip_address", associate_carrier_ip_address)
        if associate_public_ip_address is not None:
            pulumi.set(__self__, "associate_public_ip_address", associate_public_ip_address)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if device_index is not None:
            pulumi.set(__self__, "device_index", device_index)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if interface_type is not None:
            pulumi.set(__self__, "interface_type", interface_type)
        if ipv4_prefix_count is not None:
            pulumi.set(__self__, "ipv4_prefix_count", ipv4_prefix_count)
        if ipv4_prefixes is not None:
            pulumi.set(__self__, "ipv4_prefixes", ipv4_prefixes)
        if ipv6_address_count is not None:
            pulumi.set(__self__, "ipv6_address_count", ipv6_address_count)
        if ipv6_addresses is not None:
            pulumi.set(__self__, "ipv6_addresses", ipv6_addresses)
        if ipv6_prefix_count is not None:
            pulumi.set(__self__, "ipv6_prefix_count", ipv6_prefix_count)
        if ipv6_prefixes is not None:
            pulumi.set(__self__, "ipv6_prefixes", ipv6_prefixes)
        if network_card_index is not None:
            pulumi.set(__self__, "network_card_index", network_card_index)
        if network_interface_id is not None:
            pulumi.set(__self__, "network_interface_id", network_interface_id)
        if primary_ipv6 is not None:
            pulumi.set(__self__, "primary_ipv6", primary_ipv6)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)
        if private_ip_addresses is not None:
            pulumi.set(__self__, "private_ip_addresses", private_ip_addresses)
        if secondary_private_ip_address_count is not None:
            pulumi.set(__self__, "secondary_private_ip_address_count", secondary_private_ip_address_count)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="associateCarrierIpAddress")
    def associate_carrier_ip_address(self) -> Optional[bool]:
        """
        Indicates whether to associate a Carrier IP address with eth0 for a new network interface.
        """
        return pulumi.get(self, "associate_carrier_ip_address")

    @property
    @pulumi.getter(name="associatePublicIpAddress")
    def associate_public_ip_address(self) -> Optional[bool]:
        """
        Associates a public IPv4 address with eth0 for a new network interface.
        """
        return pulumi.get(self, "associate_public_ip_address")

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[bool]:
        """
        Indicates whether the network interface is deleted when the instance is terminated.
        """
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A description for the network interface.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> Optional[int]:
        """
        The device index for the network interface attachment.
        """
        return pulumi.get(self, "device_index")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[str]]:
        """
        The IDs of one or more security groups.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter(name="interfaceType")
    def interface_type(self) -> Optional[str]:
        """
        The type of network interface.
        """
        return pulumi.get(self, "interface_type")

    @property
    @pulumi.getter(name="ipv4PrefixCount")
    def ipv4_prefix_count(self) -> Optional[int]:
        """
        The number of IPv4 prefixes to be automatically assigned to the network interface.
        """
        return pulumi.get(self, "ipv4_prefix_count")

    @property
    @pulumi.getter(name="ipv4Prefixes")
    def ipv4_prefixes(self) -> Optional[Sequence['outputs.LaunchTemplateIpv4PrefixSpecification']]:
        """
        One or more IPv4 prefixes to be assigned to the network interface.
        """
        return pulumi.get(self, "ipv4_prefixes")

    @property
    @pulumi.getter(name="ipv6AddressCount")
    def ipv6_address_count(self) -> Optional[int]:
        """
        The number of IPv6 addresses to assign to a network interface.
        """
        return pulumi.get(self, "ipv6_address_count")

    @property
    @pulumi.getter(name="ipv6Addresses")
    def ipv6_addresses(self) -> Optional[Sequence['outputs.LaunchTemplateIpv6Add']]:
        """
        One or more specific IPv6 addresses from the IPv6 CIDR block range of your subnet.
        """
        return pulumi.get(self, "ipv6_addresses")

    @property
    @pulumi.getter(name="ipv6PrefixCount")
    def ipv6_prefix_count(self) -> Optional[int]:
        """
        The number of IPv6 prefixes to be automatically assigned to the network interface.
        """
        return pulumi.get(self, "ipv6_prefix_count")

    @property
    @pulumi.getter(name="ipv6Prefixes")
    def ipv6_prefixes(self) -> Optional[Sequence['outputs.LaunchTemplateIpv6PrefixSpecification']]:
        """
        One or more IPv6 prefixes to be assigned to the network interface.
        """
        return pulumi.get(self, "ipv6_prefixes")

    @property
    @pulumi.getter(name="networkCardIndex")
    def network_card_index(self) -> Optional[int]:
        """
        The index of the network card.
        """
        return pulumi.get(self, "network_card_index")

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[str]:
        """
        The ID of the network interface.
        """
        return pulumi.get(self, "network_interface_id")

    @property
    @pulumi.getter(name="primaryIpv6")
    def primary_ipv6(self) -> Optional[bool]:
        """
        Enables the first IPv6 global unique address (GUA) on a dual stack or IPv6-only ENI immutable.
        """
        return pulumi.get(self, "primary_ipv6")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[str]:
        """
        The primary private IPv4 address of the network interface.
        """
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter(name="privateIpAddresses")
    def private_ip_addresses(self) -> Optional[Sequence['outputs.LaunchTemplatePrivateIpAdd']]:
        """
        One or more private IPv4 addresses.
        """
        return pulumi.get(self, "private_ip_addresses")

    @property
    @pulumi.getter(name="secondaryPrivateIpAddressCount")
    def secondary_private_ip_address_count(self) -> Optional[int]:
        """
        The number of secondary private IPv4 addresses to assign to a network interface.
        """
        return pulumi.get(self, "secondary_private_ip_address_count")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        """
        The ID of the subnet for the network interface.
        """
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class LaunchTemplateNetworkInterfaceCount(dict):
    """
    TThe minimum and maximum number of network interfaces.
    """
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        TThe minimum and maximum number of network interfaces.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplatePlacement(dict):
    """
    Specifies the placement of an instance.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "groupId":
            suggest = "group_id"
        elif key == "groupName":
            suggest = "group_name"
        elif key == "hostId":
            suggest = "host_id"
        elif key == "hostResourceGroupArn":
            suggest = "host_resource_group_arn"
        elif key == "partitionNumber":
            suggest = "partition_number"
        elif key == "spreadDomain":
            suggest = "spread_domain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplatePlacement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplatePlacement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplatePlacement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 affinity: Optional[str] = None,
                 availability_zone: Optional[str] = None,
                 group_id: Optional[str] = None,
                 group_name: Optional[str] = None,
                 host_id: Optional[str] = None,
                 host_resource_group_arn: Optional[str] = None,
                 partition_number: Optional[int] = None,
                 spread_domain: Optional[str] = None,
                 tenancy: Optional[str] = None):
        """
        Specifies the placement of an instance.
        :param str affinity: The affinity setting for an instance on a Dedicated Host.
        :param str availability_zone: The Availability Zone for the instance.
        :param str group_id: The Group Id of a placement group. You must specify the Placement Group Group Id to launch an instance in a shared placement group.
        :param str group_name: The name of the placement group for the instance.
        :param str host_id: The ID of the Dedicated Host for the instance.
        :param str host_resource_group_arn: The ARN of the host resource group in which to launch the instances. If you specify a host resource group ARN, omit the Tenancy parameter or set it to host.
        :param int partition_number: The number of the partition the instance should launch in. Valid only if the placement group strategy is set to partition.
        :param str spread_domain: Reserved for future use.
        :param str tenancy: The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of dedicated runs on single-tenant hardware.
        """
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if group_id is not None:
            pulumi.set(__self__, "group_id", group_id)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if host_id is not None:
            pulumi.set(__self__, "host_id", host_id)
        if host_resource_group_arn is not None:
            pulumi.set(__self__, "host_resource_group_arn", host_resource_group_arn)
        if partition_number is not None:
            pulumi.set(__self__, "partition_number", partition_number)
        if spread_domain is not None:
            pulumi.set(__self__, "spread_domain", spread_domain)
        if tenancy is not None:
            pulumi.set(__self__, "tenancy", tenancy)

    @property
    @pulumi.getter
    def affinity(self) -> Optional[str]:
        """
        The affinity setting for an instance on a Dedicated Host.
        """
        return pulumi.get(self, "affinity")

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[str]:
        """
        The Availability Zone for the instance.
        """
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> Optional[str]:
        """
        The Group Id of a placement group. You must specify the Placement Group Group Id to launch an instance in a shared placement group.
        """
        return pulumi.get(self, "group_id")

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[str]:
        """
        The name of the placement group for the instance.
        """
        return pulumi.get(self, "group_name")

    @property
    @pulumi.getter(name="hostId")
    def host_id(self) -> Optional[str]:
        """
        The ID of the Dedicated Host for the instance.
        """
        return pulumi.get(self, "host_id")

    @property
    @pulumi.getter(name="hostResourceGroupArn")
    def host_resource_group_arn(self) -> Optional[str]:
        """
        The ARN of the host resource group in which to launch the instances. If you specify a host resource group ARN, omit the Tenancy parameter or set it to host.
        """
        return pulumi.get(self, "host_resource_group_arn")

    @property
    @pulumi.getter(name="partitionNumber")
    def partition_number(self) -> Optional[int]:
        """
        The number of the partition the instance should launch in. Valid only if the placement group strategy is set to partition.
        """
        return pulumi.get(self, "partition_number")

    @property
    @pulumi.getter(name="spreadDomain")
    def spread_domain(self) -> Optional[str]:
        """
        Reserved for future use.
        """
        return pulumi.get(self, "spread_domain")

    @property
    @pulumi.getter
    def tenancy(self) -> Optional[str]:
        """
        The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of dedicated runs on single-tenant hardware.
        """
        return pulumi.get(self, "tenancy")


@pulumi.output_type
class LaunchTemplatePrivateDnsNameOptions(dict):
    """
    Describes the options for instance hostnames.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableResourceNameDnsARecord":
            suggest = "enable_resource_name_dns_a_record"
        elif key == "enableResourceNameDnsAaaaRecord":
            suggest = "enable_resource_name_dns_aaaa_record"
        elif key == "hostnameType":
            suggest = "hostname_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplatePrivateDnsNameOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplatePrivateDnsNameOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplatePrivateDnsNameOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_resource_name_dns_a_record: Optional[bool] = None,
                 enable_resource_name_dns_aaaa_record: Optional[bool] = None,
                 hostname_type: Optional[str] = None):
        """
        Describes the options for instance hostnames.
        :param bool enable_resource_name_dns_a_record: Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
        :param bool enable_resource_name_dns_aaaa_record: Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
        :param str hostname_type: The type of hostname for EC2 instances.
        """
        if enable_resource_name_dns_a_record is not None:
            pulumi.set(__self__, "enable_resource_name_dns_a_record", enable_resource_name_dns_a_record)
        if enable_resource_name_dns_aaaa_record is not None:
            pulumi.set(__self__, "enable_resource_name_dns_aaaa_record", enable_resource_name_dns_aaaa_record)
        if hostname_type is not None:
            pulumi.set(__self__, "hostname_type", hostname_type)

    @property
    @pulumi.getter(name="enableResourceNameDnsARecord")
    def enable_resource_name_dns_a_record(self) -> Optional[bool]:
        """
        Indicates whether to respond to DNS queries for instance hostnames with DNS A records.
        """
        return pulumi.get(self, "enable_resource_name_dns_a_record")

    @property
    @pulumi.getter(name="enableResourceNameDnsAaaaRecord")
    def enable_resource_name_dns_aaaa_record(self) -> Optional[bool]:
        """
        Indicates whether to respond to DNS queries for instance hostnames with DNS AAAA records.
        """
        return pulumi.get(self, "enable_resource_name_dns_aaaa_record")

    @property
    @pulumi.getter(name="hostnameType")
    def hostname_type(self) -> Optional[str]:
        """
        The type of hostname for EC2 instances.
        """
        return pulumi.get(self, "hostname_type")


@pulumi.output_type
class LaunchTemplatePrivateIpAdd(dict):
    """
    Specifies a secondary private IPv4 address for a network interface.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIpAddress":
            suggest = "private_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplatePrivateIpAdd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplatePrivateIpAdd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplatePrivateIpAdd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 primary: Optional[bool] = None,
                 private_ip_address: Optional[str] = None):
        """
        Specifies a secondary private IPv4 address for a network interface.
        :param bool primary: Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.
        :param str private_ip_address: The private IPv4 address.
        """
        if primary is not None:
            pulumi.set(__self__, "primary", primary)
        if private_ip_address is not None:
            pulumi.set(__self__, "private_ip_address", private_ip_address)

    @property
    @pulumi.getter
    def primary(self) -> Optional[bool]:
        """
        Indicates whether the private IPv4 address is the primary private IPv4 address. Only one IPv4 address can be designated as primary.
        """
        return pulumi.get(self, "primary")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> Optional[str]:
        """
        The private IPv4 address.
        """
        return pulumi.get(self, "private_ip_address")


@pulumi.output_type
class LaunchTemplateSpotOptions(dict):
    """
    Specifies options for Spot Instances.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blockDurationMinutes":
            suggest = "block_duration_minutes"
        elif key == "instanceInterruptionBehavior":
            suggest = "instance_interruption_behavior"
        elif key == "maxPrice":
            suggest = "max_price"
        elif key == "spotInstanceType":
            suggest = "spot_instance_type"
        elif key == "validUntil":
            suggest = "valid_until"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateSpotOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateSpotOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateSpotOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 block_duration_minutes: Optional[int] = None,
                 instance_interruption_behavior: Optional[str] = None,
                 max_price: Optional[str] = None,
                 spot_instance_type: Optional[str] = None,
                 valid_until: Optional[str] = None):
        """
        Specifies options for Spot Instances.
        :param int block_duration_minutes: Deprecated
        :param str instance_interruption_behavior: The behavior when a Spot Instance is interrupted. The default is terminate.
        :param str max_price: The maximum hourly price you're willing to pay for the Spot Instances.
        :param str spot_instance_type: The Spot Instance request type.
        :param str valid_until: The end date of the request, in UTC format (YYYY-MM-DDTHH:MM:SSZ). Supported only for persistent requests.
        """
        if block_duration_minutes is not None:
            pulumi.set(__self__, "block_duration_minutes", block_duration_minutes)
        if instance_interruption_behavior is not None:
            pulumi.set(__self__, "instance_interruption_behavior", instance_interruption_behavior)
        if max_price is not None:
            pulumi.set(__self__, "max_price", max_price)
        if spot_instance_type is not None:
            pulumi.set(__self__, "spot_instance_type", spot_instance_type)
        if valid_until is not None:
            pulumi.set(__self__, "valid_until", valid_until)

    @property
    @pulumi.getter(name="blockDurationMinutes")
    def block_duration_minutes(self) -> Optional[int]:
        """
        Deprecated
        """
        return pulumi.get(self, "block_duration_minutes")

    @property
    @pulumi.getter(name="instanceInterruptionBehavior")
    def instance_interruption_behavior(self) -> Optional[str]:
        """
        The behavior when a Spot Instance is interrupted. The default is terminate.
        """
        return pulumi.get(self, "instance_interruption_behavior")

    @property
    @pulumi.getter(name="maxPrice")
    def max_price(self) -> Optional[str]:
        """
        The maximum hourly price you're willing to pay for the Spot Instances.
        """
        return pulumi.get(self, "max_price")

    @property
    @pulumi.getter(name="spotInstanceType")
    def spot_instance_type(self) -> Optional[str]:
        """
        The Spot Instance request type.
        """
        return pulumi.get(self, "spot_instance_type")

    @property
    @pulumi.getter(name="validUntil")
    def valid_until(self) -> Optional[str]:
        """
        The end date of the request, in UTC format (YYYY-MM-DDTHH:MM:SSZ). Supported only for persistent requests.
        """
        return pulumi.get(self, "valid_until")


@pulumi.output_type
class LaunchTemplateTag(dict):
    """
    The user data to make available to the instance.
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        The user data to make available to the instance.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class LaunchTemplateTagSpecification(dict):
    """
    Specifies the tags to apply to the launch template during creation.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchTemplateTagSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchTemplateTagSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchTemplateTagSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_type: Optional[str] = None,
                 tags: Optional[Sequence['outputs.LaunchTemplateTag']] = None):
        """
        Specifies the tags to apply to the launch template during creation.
        :param str resource_type: The type of resource to tag.
        :param Sequence['LaunchTemplateTag'] tags: The tags for the resource.
        """
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[str]:
        """
        The type of resource to tag.
        """
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.LaunchTemplateTag']]:
        """
        The tags for the resource.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class LaunchTemplateTotalLocalStorageGb(dict):
    """
    The minimum and maximum amount of total local storage, in GB.
    """
    def __init__(__self__, *,
                 max: Optional[float] = None,
                 min: Optional[float] = None):
        """
        The minimum and maximum amount of total local storage, in GB.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchTemplateVCpuCount(dict):
    """
    The minimum and maximum number of vCPUs.
    """
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        """
        The minimum and maximum number of vCPUs.
        :param int max: The maximum number of vCPUs.
        :param int min: The minimum number of vCPUs.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        The maximum number of vCPUs.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        The minimum number of vCPUs.
        """
        return pulumi.get(self, "min")


@pulumi.output_type
class LocalGatewayRouteTableTag(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class LocalGatewayRouteTableVirtualInterfaceGroupAssociationTag(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class LocalGatewayRouteTableVpcAssociationTag(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class NatGatewayTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class NetworkAclEntryIcmp(dict):
    def __init__(__self__, *,
                 code: Optional[int] = None,
                 type: Optional[int] = None):
        if code is not None:
            pulumi.set(__self__, "code", code)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def code(self) -> Optional[int]:
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def type(self) -> Optional[int]:
        return pulumi.get(self, "type")


@pulumi.output_type
class NetworkAclEntryPortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkAclEntryPortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkAclEntryPortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkAclEntryPortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[int] = None,
                 to: Optional[int] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[int]:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional[int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkAclTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class NetworkInsightsAccessScopeAccessScopePathRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "throughResources":
            suggest = "through_resources"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAccessScopeAccessScopePathRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAccessScopeAccessScopePathRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAccessScopeAccessScopePathRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: Optional['outputs.NetworkInsightsAccessScopePathStatementRequest'] = None,
                 source: Optional['outputs.NetworkInsightsAccessScopePathStatementRequest'] = None,
                 through_resources: Optional[Sequence['outputs.NetworkInsightsAccessScopeThroughResourcesStatementRequest']] = None):
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if through_resources is not None:
            pulumi.set(__self__, "through_resources", through_resources)

    @property
    @pulumi.getter
    def destination(self) -> Optional['outputs.NetworkInsightsAccessScopePathStatementRequest']:
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter
    def source(self) -> Optional['outputs.NetworkInsightsAccessScopePathStatementRequest']:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="throughResources")
    def through_resources(self) -> Optional[Sequence['outputs.NetworkInsightsAccessScopeThroughResourcesStatementRequest']]:
        return pulumi.get(self, "through_resources")


@pulumi.output_type
class NetworkInsightsAccessScopeAnalysisTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class NetworkInsightsAccessScopePacketHeaderStatementRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddresses":
            suggest = "destination_addresses"
        elif key == "destinationPorts":
            suggest = "destination_ports"
        elif key == "destinationPrefixLists":
            suggest = "destination_prefix_lists"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourcePorts":
            suggest = "source_ports"
        elif key == "sourcePrefixLists":
            suggest = "source_prefix_lists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAccessScopePacketHeaderStatementRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAccessScopePacketHeaderStatementRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAccessScopePacketHeaderStatementRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_addresses: Optional[Sequence[str]] = None,
                 destination_ports: Optional[Sequence[str]] = None,
                 destination_prefix_lists: Optional[Sequence[str]] = None,
                 protocols: Optional[Sequence['NetworkInsightsAccessScopeProtocol']] = None,
                 source_addresses: Optional[Sequence[str]] = None,
                 source_ports: Optional[Sequence[str]] = None,
                 source_prefix_lists: Optional[Sequence[str]] = None):
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if destination_ports is not None:
            pulumi.set(__self__, "destination_ports", destination_ports)
        if destination_prefix_lists is not None:
            pulumi.set(__self__, "destination_prefix_lists", destination_prefix_lists)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_ports is not None:
            pulumi.set(__self__, "source_ports", source_ports)
        if source_prefix_lists is not None:
            pulumi.set(__self__, "source_prefix_lists", source_prefix_lists)

    @property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "destination_addresses")

    @property
    @pulumi.getter(name="destinationPorts")
    def destination_ports(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "destination_ports")

    @property
    @pulumi.getter(name="destinationPrefixLists")
    def destination_prefix_lists(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "destination_prefix_lists")

    @property
    @pulumi.getter
    def protocols(self) -> Optional[Sequence['NetworkInsightsAccessScopeProtocol']]:
        return pulumi.get(self, "protocols")

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "source_addresses")

    @property
    @pulumi.getter(name="sourcePorts")
    def source_ports(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "source_ports")

    @property
    @pulumi.getter(name="sourcePrefixLists")
    def source_prefix_lists(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "source_prefix_lists")


@pulumi.output_type
class NetworkInsightsAccessScopePathStatementRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "packetHeaderStatement":
            suggest = "packet_header_statement"
        elif key == "resourceStatement":
            suggest = "resource_statement"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAccessScopePathStatementRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAccessScopePathStatementRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAccessScopePathStatementRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 packet_header_statement: Optional['outputs.NetworkInsightsAccessScopePacketHeaderStatementRequest'] = None,
                 resource_statement: Optional['outputs.NetworkInsightsAccessScopeResourceStatementRequest'] = None):
        if packet_header_statement is not None:
            pulumi.set(__self__, "packet_header_statement", packet_header_statement)
        if resource_statement is not None:
            pulumi.set(__self__, "resource_statement", resource_statement)

    @property
    @pulumi.getter(name="packetHeaderStatement")
    def packet_header_statement(self) -> Optional['outputs.NetworkInsightsAccessScopePacketHeaderStatementRequest']:
        return pulumi.get(self, "packet_header_statement")

    @property
    @pulumi.getter(name="resourceStatement")
    def resource_statement(self) -> Optional['outputs.NetworkInsightsAccessScopeResourceStatementRequest']:
        return pulumi.get(self, "resource_statement")


@pulumi.output_type
class NetworkInsightsAccessScopeResourceStatementRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceTypes":
            suggest = "resource_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAccessScopeResourceStatementRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAccessScopeResourceStatementRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAccessScopeResourceStatementRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_types: Optional[Sequence[str]] = None,
                 resources: Optional[Sequence[str]] = None):
        if resource_types is not None:
            pulumi.set(__self__, "resource_types", resource_types)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter(name="resourceTypes")
    def resource_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "resource_types")

    @property
    @pulumi.getter
    def resources(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "resources")


@pulumi.output_type
class NetworkInsightsAccessScopeTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class NetworkInsightsAccessScopeThroughResourcesStatementRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceStatement":
            suggest = "resource_statement"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAccessScopeThroughResourcesStatementRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAccessScopeThroughResourcesStatementRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAccessScopeThroughResourcesStatementRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_statement: Optional['outputs.NetworkInsightsAccessScopeResourceStatementRequest'] = None):
        if resource_statement is not None:
            pulumi.set(__self__, "resource_statement", resource_statement)

    @property
    @pulumi.getter(name="resourceStatement")
    def resource_statement(self) -> Optional['outputs.NetworkInsightsAccessScopeResourceStatementRequest']:
        return pulumi.get(self, "resource_statement")


@pulumi.output_type
class NetworkInsightsAnalysisAdditionalDetail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalDetailType":
            suggest = "additional_detail_type"
        elif key == "loadBalancers":
            suggest = "load_balancers"
        elif key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisAdditionalDetail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisAdditionalDetail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisAdditionalDetail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_detail_type: Optional[str] = None,
                 component: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 load_balancers: Optional[Sequence['outputs.NetworkInsightsAnalysisAnalysisComponent']] = None,
                 service_name: Optional[str] = None):
        if additional_detail_type is not None:
            pulumi.set(__self__, "additional_detail_type", additional_detail_type)
        if component is not None:
            pulumi.set(__self__, "component", component)
        if load_balancers is not None:
            pulumi.set(__self__, "load_balancers", load_balancers)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter(name="additionalDetailType")
    def additional_detail_type(self) -> Optional[str]:
        return pulumi.get(self, "additional_detail_type")

    @property
    @pulumi.getter
    def component(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter(name="loadBalancers")
    def load_balancers(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisAnalysisComponent']]:
        return pulumi.get(self, "load_balancers")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        return pulumi.get(self, "service_name")


@pulumi.output_type
class NetworkInsightsAnalysisAlternatePathHint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "componentArn":
            suggest = "component_arn"
        elif key == "componentId":
            suggest = "component_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisAlternatePathHint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisAlternatePathHint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisAlternatePathHint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component_arn: Optional[str] = None,
                 component_id: Optional[str] = None):
        if component_arn is not None:
            pulumi.set(__self__, "component_arn", component_arn)
        if component_id is not None:
            pulumi.set(__self__, "component_id", component_id)

    @property
    @pulumi.getter(name="componentArn")
    def component_arn(self) -> Optional[str]:
        return pulumi.get(self, "component_arn")

    @property
    @pulumi.getter(name="componentId")
    def component_id(self) -> Optional[str]:
        return pulumi.get(self, "component_id")


@pulumi.output_type
class NetworkInsightsAnalysisAnalysisAclRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portRange":
            suggest = "port_range"
        elif key == "ruleAction":
            suggest = "rule_action"
        elif key == "ruleNumber":
            suggest = "rule_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisAnalysisAclRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisAnalysisAclRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisAnalysisAclRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr: Optional[str] = None,
                 egress: Optional[bool] = None,
                 port_range: Optional['outputs.NetworkInsightsAnalysisPortRange'] = None,
                 protocol: Optional[str] = None,
                 rule_action: Optional[str] = None,
                 rule_number: Optional[int] = None):
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if egress is not None:
            pulumi.set(__self__, "egress", egress)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if rule_action is not None:
            pulumi.set(__self__, "rule_action", rule_action)
        if rule_number is not None:
            pulumi.set(__self__, "rule_number", rule_number)

    @property
    @pulumi.getter
    def cidr(self) -> Optional[str]:
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def egress(self) -> Optional[bool]:
        return pulumi.get(self, "egress")

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional['outputs.NetworkInsightsAnalysisPortRange']:
        return pulumi.get(self, "port_range")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="ruleAction")
    def rule_action(self) -> Optional[str]:
        return pulumi.get(self, "rule_action")

    @property
    @pulumi.getter(name="ruleNumber")
    def rule_number(self) -> Optional[int]:
        return pulumi.get(self, "rule_number")


@pulumi.output_type
class NetworkInsightsAnalysisAnalysisComponent(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 id: Optional[str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")


@pulumi.output_type
class NetworkInsightsAnalysisAnalysisLoadBalancerListener(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instancePort":
            suggest = "instance_port"
        elif key == "loadBalancerPort":
            suggest = "load_balancer_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisAnalysisLoadBalancerListener. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisAnalysisLoadBalancerListener.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisAnalysisLoadBalancerListener.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_port: Optional[int] = None,
                 load_balancer_port: Optional[int] = None):
        if instance_port is not None:
            pulumi.set(__self__, "instance_port", instance_port)
        if load_balancer_port is not None:
            pulumi.set(__self__, "load_balancer_port", load_balancer_port)

    @property
    @pulumi.getter(name="instancePort")
    def instance_port(self) -> Optional[int]:
        return pulumi.get(self, "instance_port")

    @property
    @pulumi.getter(name="loadBalancerPort")
    def load_balancer_port(self) -> Optional[int]:
        return pulumi.get(self, "load_balancer_port")


@pulumi.output_type
class NetworkInsightsAnalysisAnalysisLoadBalancerTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisAnalysisLoadBalancerTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisAnalysisLoadBalancerTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisAnalysisLoadBalancerTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[str] = None,
                 availability_zone: Optional[str] = None,
                 instance: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 port: Optional[int] = None):
        if address is not None:
            pulumi.set(__self__, "address", address)
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if instance is not None:
            pulumi.set(__self__, "instance", instance)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[str]:
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter
    def instance(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        return pulumi.get(self, "instance")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")


@pulumi.output_type
class NetworkInsightsAnalysisAnalysisPacketHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddresses":
            suggest = "destination_addresses"
        elif key == "destinationPortRanges":
            suggest = "destination_port_ranges"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourcePortRanges":
            suggest = "source_port_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisAnalysisPacketHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisAnalysisPacketHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisAnalysisPacketHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_addresses: Optional[Sequence[str]] = None,
                 destination_port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisPortRange']] = None,
                 protocol: Optional[str] = None,
                 source_addresses: Optional[Sequence[str]] = None,
                 source_port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisPortRange']] = None):
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if destination_port_ranges is not None:
            pulumi.set(__self__, "destination_port_ranges", destination_port_ranges)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_port_ranges is not None:
            pulumi.set(__self__, "source_port_ranges", source_port_ranges)

    @property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "destination_addresses")

    @property
    @pulumi.getter(name="destinationPortRanges")
    def destination_port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisPortRange']]:
        return pulumi.get(self, "destination_port_ranges")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "source_addresses")

    @property
    @pulumi.getter(name="sourcePortRanges")
    def source_port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisPortRange']]:
        return pulumi.get(self, "source_port_ranges")


@pulumi.output_type
class NetworkInsightsAnalysisAnalysisRouteTableRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationCidr":
            suggest = "destination_cidr"
        elif key == "destinationPrefixListId":
            suggest = "destination_prefix_list_id"
        elif key == "egressOnlyInternetGatewayId":
            suggest = "egress_only_internet_gateway_id"
        elif key == "gatewayId":
            suggest = "gateway_id"
        elif key == "instanceId":
            suggest = "instance_id"
        elif key == "natGatewayId":
            suggest = "nat_gateway_id"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "transitGatewayId":
            suggest = "transit_gateway_id"
        elif key == "vpcPeeringConnectionId":
            suggest = "vpc_peering_connection_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisAnalysisRouteTableRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisAnalysisRouteTableRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisAnalysisRouteTableRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_cidr: Optional[str] = None,
                 destination_prefix_list_id: Optional[str] = None,
                 egress_only_internet_gateway_id: Optional[str] = None,
                 gateway_id: Optional[str] = None,
                 instance_id: Optional[str] = None,
                 nat_gateway_id: Optional[str] = None,
                 network_interface_id: Optional[str] = None,
                 origin: Optional[str] = None,
                 state: Optional[str] = None,
                 transit_gateway_id: Optional[str] = None,
                 vpc_peering_connection_id: Optional[str] = None):
        if destination_cidr is not None:
            pulumi.set(__self__, "destination_cidr", destination_cidr)
        if destination_prefix_list_id is not None:
            pulumi.set(__self__, "destination_prefix_list_id", destination_prefix_list_id)
        if egress_only_internet_gateway_id is not None:
            pulumi.set(__self__, "egress_only_internet_gateway_id", egress_only_internet_gateway_id)
        if gateway_id is not None:
            pulumi.set(__self__, "gateway_id", gateway_id)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if nat_gateway_id is not None:
            pulumi.set(__self__, "nat_gateway_id", nat_gateway_id)
        if network_interface_id is not None:
            pulumi.set(__self__, "network_interface_id", network_interface_id)
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if transit_gateway_id is not None:
            pulumi.set(__self__, "transit_gateway_id", transit_gateway_id)
        if vpc_peering_connection_id is not None:
            pulumi.set(__self__, "vpc_peering_connection_id", vpc_peering_connection_id)

    @property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> Optional[str]:
        return pulumi.get(self, "destination_cidr")

    @property
    @pulumi.getter(name="destinationPrefixListId")
    def destination_prefix_list_id(self) -> Optional[str]:
        return pulumi.get(self, "destination_prefix_list_id")

    @property
    @pulumi.getter(name="egressOnlyInternetGatewayId")
    def egress_only_internet_gateway_id(self) -> Optional[str]:
        return pulumi.get(self, "egress_only_internet_gateway_id")

    @property
    @pulumi.getter(name="gatewayId")
    def gateway_id(self) -> Optional[str]:
        return pulumi.get(self, "gateway_id")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[str]:
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter(name="natGatewayId")
    def nat_gateway_id(self) -> Optional[str]:
        return pulumi.get(self, "nat_gateway_id")

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[str]:
        return pulumi.get(self, "network_interface_id")

    @property
    @pulumi.getter
    def origin(self) -> Optional[str]:
        return pulumi.get(self, "origin")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="transitGatewayId")
    def transit_gateway_id(self) -> Optional[str]:
        return pulumi.get(self, "transit_gateway_id")

    @property
    @pulumi.getter(name="vpcPeeringConnectionId")
    def vpc_peering_connection_id(self) -> Optional[str]:
        return pulumi.get(self, "vpc_peering_connection_id")


@pulumi.output_type
class NetworkInsightsAnalysisAnalysisSecurityGroupRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portRange":
            suggest = "port_range"
        elif key == "prefixListId":
            suggest = "prefix_list_id"
        elif key == "securityGroupId":
            suggest = "security_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisAnalysisSecurityGroupRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisAnalysisSecurityGroupRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisAnalysisSecurityGroupRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr: Optional[str] = None,
                 direction: Optional[str] = None,
                 port_range: Optional['outputs.NetworkInsightsAnalysisPortRange'] = None,
                 prefix_list_id: Optional[str] = None,
                 protocol: Optional[str] = None,
                 security_group_id: Optional[str] = None):
        if cidr is not None:
            pulumi.set(__self__, "cidr", cidr)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if prefix_list_id is not None:
            pulumi.set(__self__, "prefix_list_id", prefix_list_id)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if security_group_id is not None:
            pulumi.set(__self__, "security_group_id", security_group_id)

    @property
    @pulumi.getter
    def cidr(self) -> Optional[str]:
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional['outputs.NetworkInsightsAnalysisPortRange']:
        return pulumi.get(self, "port_range")

    @property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> Optional[str]:
        return pulumi.get(self, "prefix_list_id")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> Optional[str]:
        return pulumi.get(self, "security_group_id")


@pulumi.output_type
class NetworkInsightsAnalysisExplanation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aclRule":
            suggest = "acl_rule"
        elif key == "attachedTo":
            suggest = "attached_to"
        elif key == "availabilityZones":
            suggest = "availability_zones"
        elif key == "classicLoadBalancerListener":
            suggest = "classic_load_balancer_listener"
        elif key == "componentAccount":
            suggest = "component_account"
        elif key == "componentRegion":
            suggest = "component_region"
        elif key == "customerGateway":
            suggest = "customer_gateway"
        elif key == "destinationVpc":
            suggest = "destination_vpc"
        elif key == "elasticLoadBalancerListener":
            suggest = "elastic_load_balancer_listener"
        elif key == "explanationCode":
            suggest = "explanation_code"
        elif key == "ingressRouteTable":
            suggest = "ingress_route_table"
        elif key == "internetGateway":
            suggest = "internet_gateway"
        elif key == "loadBalancerArn":
            suggest = "load_balancer_arn"
        elif key == "loadBalancerListenerPort":
            suggest = "load_balancer_listener_port"
        elif key == "loadBalancerTarget":
            suggest = "load_balancer_target"
        elif key == "loadBalancerTargetGroup":
            suggest = "load_balancer_target_group"
        elif key == "loadBalancerTargetGroups":
            suggest = "load_balancer_target_groups"
        elif key == "loadBalancerTargetPort":
            suggest = "load_balancer_target_port"
        elif key == "missingComponent":
            suggest = "missing_component"
        elif key == "natGateway":
            suggest = "nat_gateway"
        elif key == "networkInterface":
            suggest = "network_interface"
        elif key == "packetField":
            suggest = "packet_field"
        elif key == "portRanges":
            suggest = "port_ranges"
        elif key == "prefixList":
            suggest = "prefix_list"
        elif key == "routeTable":
            suggest = "route_table"
        elif key == "routeTableRoute":
            suggest = "route_table_route"
        elif key == "securityGroup":
            suggest = "security_group"
        elif key == "securityGroupRule":
            suggest = "security_group_rule"
        elif key == "securityGroups":
            suggest = "security_groups"
        elif key == "sourceVpc":
            suggest = "source_vpc"
        elif key == "subnetRouteTable":
            suggest = "subnet_route_table"
        elif key == "transitGateway":
            suggest = "transit_gateway"
        elif key == "transitGatewayAttachment":
            suggest = "transit_gateway_attachment"
        elif key == "transitGatewayRouteTable":
            suggest = "transit_gateway_route_table"
        elif key == "transitGatewayRouteTableRoute":
            suggest = "transit_gateway_route_table_route"
        elif key == "vpcEndpoint":
            suggest = "vpc_endpoint"
        elif key == "vpcPeeringConnection":
            suggest = "vpc_peering_connection"
        elif key == "vpnConnection":
            suggest = "vpn_connection"
        elif key == "vpnGateway":
            suggest = "vpn_gateway"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisExplanation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisExplanation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisExplanation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acl: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 acl_rule: Optional['outputs.NetworkInsightsAnalysisAnalysisAclRule'] = None,
                 address: Optional[str] = None,
                 addresses: Optional[Sequence[str]] = None,
                 attached_to: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 availability_zones: Optional[Sequence[str]] = None,
                 cidrs: Optional[Sequence[str]] = None,
                 classic_load_balancer_listener: Optional['outputs.NetworkInsightsAnalysisAnalysisLoadBalancerListener'] = None,
                 component: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 component_account: Optional[str] = None,
                 component_region: Optional[str] = None,
                 customer_gateway: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 destination: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 destination_vpc: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 direction: Optional[str] = None,
                 elastic_load_balancer_listener: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 explanation_code: Optional[str] = None,
                 ingress_route_table: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 internet_gateway: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 load_balancer_arn: Optional[str] = None,
                 load_balancer_listener_port: Optional[int] = None,
                 load_balancer_target: Optional['outputs.NetworkInsightsAnalysisAnalysisLoadBalancerTarget'] = None,
                 load_balancer_target_group: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 load_balancer_target_groups: Optional[Sequence['outputs.NetworkInsightsAnalysisAnalysisComponent']] = None,
                 load_balancer_target_port: Optional[int] = None,
                 missing_component: Optional[str] = None,
                 nat_gateway: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 network_interface: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 packet_field: Optional[str] = None,
                 port: Optional[int] = None,
                 port_ranges: Optional[Sequence['outputs.NetworkInsightsAnalysisPortRange']] = None,
                 prefix_list: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 protocols: Optional[Sequence[str]] = None,
                 route_table: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 route_table_route: Optional['outputs.NetworkInsightsAnalysisAnalysisRouteTableRoute'] = None,
                 security_group: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 security_group_rule: Optional['outputs.NetworkInsightsAnalysisAnalysisSecurityGroupRule'] = None,
                 security_groups: Optional[Sequence['outputs.NetworkInsightsAnalysisAnalysisComponent']] = None,
                 source_vpc: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 state: Optional[str] = None,
                 subnet: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 subnet_route_table: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 transit_gateway: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 transit_gateway_attachment: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 transit_gateway_route_table: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 transit_gateway_route_table_route: Optional['outputs.NetworkInsightsAnalysisTransitGatewayRouteTableRoute'] = None,
                 vpc: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 vpc_endpoint: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 vpc_peering_connection: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 vpn_connection: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 vpn_gateway: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None):
        if acl is not None:
            pulumi.set(__self__, "acl", acl)
        if acl_rule is not None:
            pulumi.set(__self__, "acl_rule", acl_rule)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)
        if attached_to is not None:
            pulumi.set(__self__, "attached_to", attached_to)
        if availability_zones is not None:
            pulumi.set(__self__, "availability_zones", availability_zones)
        if cidrs is not None:
            pulumi.set(__self__, "cidrs", cidrs)
        if classic_load_balancer_listener is not None:
            pulumi.set(__self__, "classic_load_balancer_listener", classic_load_balancer_listener)
        if component is not None:
            pulumi.set(__self__, "component", component)
        if component_account is not None:
            pulumi.set(__self__, "component_account", component_account)
        if component_region is not None:
            pulumi.set(__self__, "component_region", component_region)
        if customer_gateway is not None:
            pulumi.set(__self__, "customer_gateway", customer_gateway)
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if destination_vpc is not None:
            pulumi.set(__self__, "destination_vpc", destination_vpc)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if elastic_load_balancer_listener is not None:
            pulumi.set(__self__, "elastic_load_balancer_listener", elastic_load_balancer_listener)
        if explanation_code is not None:
            pulumi.set(__self__, "explanation_code", explanation_code)
        if ingress_route_table is not None:
            pulumi.set(__self__, "ingress_route_table", ingress_route_table)
        if internet_gateway is not None:
            pulumi.set(__self__, "internet_gateway", internet_gateway)
        if load_balancer_arn is not None:
            pulumi.set(__self__, "load_balancer_arn", load_balancer_arn)
        if load_balancer_listener_port is not None:
            pulumi.set(__self__, "load_balancer_listener_port", load_balancer_listener_port)
        if load_balancer_target is not None:
            pulumi.set(__self__, "load_balancer_target", load_balancer_target)
        if load_balancer_target_group is not None:
            pulumi.set(__self__, "load_balancer_target_group", load_balancer_target_group)
        if load_balancer_target_groups is not None:
            pulumi.set(__self__, "load_balancer_target_groups", load_balancer_target_groups)
        if load_balancer_target_port is not None:
            pulumi.set(__self__, "load_balancer_target_port", load_balancer_target_port)
        if missing_component is not None:
            pulumi.set(__self__, "missing_component", missing_component)
        if nat_gateway is not None:
            pulumi.set(__self__, "nat_gateway", nat_gateway)
        if network_interface is not None:
            pulumi.set(__self__, "network_interface", network_interface)
        if packet_field is not None:
            pulumi.set(__self__, "packet_field", packet_field)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if prefix_list is not None:
            pulumi.set(__self__, "prefix_list", prefix_list)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if route_table is not None:
            pulumi.set(__self__, "route_table", route_table)
        if route_table_route is not None:
            pulumi.set(__self__, "route_table_route", route_table_route)
        if security_group is not None:
            pulumi.set(__self__, "security_group", security_group)
        if security_group_rule is not None:
            pulumi.set(__self__, "security_group_rule", security_group_rule)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if source_vpc is not None:
            pulumi.set(__self__, "source_vpc", source_vpc)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)
        if subnet_route_table is not None:
            pulumi.set(__self__, "subnet_route_table", subnet_route_table)
        if transit_gateway is not None:
            pulumi.set(__self__, "transit_gateway", transit_gateway)
        if transit_gateway_attachment is not None:
            pulumi.set(__self__, "transit_gateway_attachment", transit_gateway_attachment)
        if transit_gateway_route_table is not None:
            pulumi.set(__self__, "transit_gateway_route_table", transit_gateway_route_table)
        if transit_gateway_route_table_route is not None:
            pulumi.set(__self__, "transit_gateway_route_table_route", transit_gateway_route_table_route)
        if vpc is not None:
            pulumi.set(__self__, "vpc", vpc)
        if vpc_endpoint is not None:
            pulumi.set(__self__, "vpc_endpoint", vpc_endpoint)
        if vpc_peering_connection is not None:
            pulumi.set(__self__, "vpc_peering_connection", vpc_peering_connection)
        if vpn_connection is not None:
            pulumi.set(__self__, "vpn_connection", vpn_connection)
        if vpn_gateway is not None:
            pulumi.set(__self__, "vpn_gateway", vpn_gateway)

    @property
    @pulumi.getter
    def acl(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        return pulumi.get(self, "acl")

    @property
    @pulumi.getter(name="aclRule")
    def acl_rule(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisAclRule']:
        return pulumi.get(self, "acl_rule")

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def addresses(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "addresses")

    @property
    @pulumi.getter(name="attachedTo")
    def attached_to(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        return pulumi.get(self, "attached_to")

    @property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "availability_zones")

    @property
    @pulumi.getter
    def cidrs(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "cidrs")

    @property
    @pulumi.getter(name="classicLoadBalancerListener")
    def classic_load_balancer_listener(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisLoadBalancerListener']:
        return pulumi.get(self, "classic_load_balancer_listener")

    @property
    @pulumi.getter
    def component(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter(name="componentAccount")
    def component_account(self) -> Optional[str]:
        return pulumi.get(self, "component_account")

    @property
    @pulumi.getter(name="componentRegion")
    def component_region(self) -> Optional[str]:
        return pulumi.get(self, "component_region")

    @property
    @pulumi.getter(name="customerGateway")
    def customer_gateway(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        return pulumi.get(self, "customer_gateway")

    @property
    @pulumi.getter
    def destination(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter(name="destinationVpc")
    def destination_vpc(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        return pulumi.get(self, "destination_vpc")

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter(name="elasticLoadBalancerListener")
    def elastic_load_balancer_listener(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        return pulumi.get(self, "elastic_load_balancer_listener")

    @property
    @pulumi.getter(name="explanationCode")
    def explanation_code(self) -> Optional[str]:
        return pulumi.get(self, "explanation_code")

    @property
    @pulumi.getter(name="ingressRouteTable")
    def ingress_route_table(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        return pulumi.get(self, "ingress_route_table")

    @property
    @pulumi.getter(name="internetGateway")
    def internet_gateway(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        return pulumi.get(self, "internet_gateway")

    @property
    @pulumi.getter(name="loadBalancerArn")
    def load_balancer_arn(self) -> Optional[str]:
        return pulumi.get(self, "load_balancer_arn")

    @property
    @pulumi.getter(name="loadBalancerListenerPort")
    def load_balancer_listener_port(self) -> Optional[int]:
        return pulumi.get(self, "load_balancer_listener_port")

    @property
    @pulumi.getter(name="loadBalancerTarget")
    def load_balancer_target(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisLoadBalancerTarget']:
        return pulumi.get(self, "load_balancer_target")

    @property
    @pulumi.getter(name="loadBalancerTargetGroup")
    def load_balancer_target_group(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        return pulumi.get(self, "load_balancer_target_group")

    @property
    @pulumi.getter(name="loadBalancerTargetGroups")
    def load_balancer_target_groups(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisAnalysisComponent']]:
        return pulumi.get(self, "load_balancer_target_groups")

    @property
    @pulumi.getter(name="loadBalancerTargetPort")
    def load_balancer_target_port(self) -> Optional[int]:
        return pulumi.get(self, "load_balancer_target_port")

    @property
    @pulumi.getter(name="missingComponent")
    def missing_component(self) -> Optional[str]:
        return pulumi.get(self, "missing_component")

    @property
    @pulumi.getter(name="natGateway")
    def nat_gateway(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        return pulumi.get(self, "nat_gateway")

    @property
    @pulumi.getter(name="networkInterface")
    def network_interface(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        return pulumi.get(self, "network_interface")

    @property
    @pulumi.getter(name="packetField")
    def packet_field(self) -> Optional[str]:
        return pulumi.get(self, "packet_field")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisPortRange']]:
        return pulumi.get(self, "port_ranges")

    @property
    @pulumi.getter(name="prefixList")
    def prefix_list(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        return pulumi.get(self, "prefix_list")

    @property
    @pulumi.getter
    def protocols(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "protocols")

    @property
    @pulumi.getter(name="routeTable")
    def route_table(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        return pulumi.get(self, "route_table")

    @property
    @pulumi.getter(name="routeTableRoute")
    def route_table_route(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisRouteTableRoute']:
        return pulumi.get(self, "route_table_route")

    @property
    @pulumi.getter(name="securityGroup")
    def security_group(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        return pulumi.get(self, "security_group")

    @property
    @pulumi.getter(name="securityGroupRule")
    def security_group_rule(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisSecurityGroupRule']:
        return pulumi.get(self, "security_group_rule")

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisAnalysisComponent']]:
        return pulumi.get(self, "security_groups")

    @property
    @pulumi.getter(name="sourceVpc")
    def source_vpc(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        return pulumi.get(self, "source_vpc")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def subnet(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        return pulumi.get(self, "subnet")

    @property
    @pulumi.getter(name="subnetRouteTable")
    def subnet_route_table(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        return pulumi.get(self, "subnet_route_table")

    @property
    @pulumi.getter(name="transitGateway")
    def transit_gateway(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        return pulumi.get(self, "transit_gateway")

    @property
    @pulumi.getter(name="transitGatewayAttachment")
    def transit_gateway_attachment(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        return pulumi.get(self, "transit_gateway_attachment")

    @property
    @pulumi.getter(name="transitGatewayRouteTable")
    def transit_gateway_route_table(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        return pulumi.get(self, "transit_gateway_route_table")

    @property
    @pulumi.getter(name="transitGatewayRouteTableRoute")
    def transit_gateway_route_table_route(self) -> Optional['outputs.NetworkInsightsAnalysisTransitGatewayRouteTableRoute']:
        return pulumi.get(self, "transit_gateway_route_table_route")

    @property
    @pulumi.getter
    def vpc(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        return pulumi.get(self, "vpc")

    @property
    @pulumi.getter(name="vpcEndpoint")
    def vpc_endpoint(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        return pulumi.get(self, "vpc_endpoint")

    @property
    @pulumi.getter(name="vpcPeeringConnection")
    def vpc_peering_connection(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        return pulumi.get(self, "vpc_peering_connection")

    @property
    @pulumi.getter(name="vpnConnection")
    def vpn_connection(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        return pulumi.get(self, "vpn_connection")

    @property
    @pulumi.getter(name="vpnGateway")
    def vpn_gateway(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        return pulumi.get(self, "vpn_gateway")


@pulumi.output_type
class NetworkInsightsAnalysisPathComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aclRule":
            suggest = "acl_rule"
        elif key == "additionalDetails":
            suggest = "additional_details"
        elif key == "destinationVpc":
            suggest = "destination_vpc"
        elif key == "elasticLoadBalancerListener":
            suggest = "elastic_load_balancer_listener"
        elif key == "inboundHeader":
            suggest = "inbound_header"
        elif key == "outboundHeader":
            suggest = "outbound_header"
        elif key == "routeTableRoute":
            suggest = "route_table_route"
        elif key == "securityGroupRule":
            suggest = "security_group_rule"
        elif key == "sequenceNumber":
            suggest = "sequence_number"
        elif key == "serviceName":
            suggest = "service_name"
        elif key == "sourceVpc":
            suggest = "source_vpc"
        elif key == "transitGateway":
            suggest = "transit_gateway"
        elif key == "transitGatewayRouteTableRoute":
            suggest = "transit_gateway_route_table_route"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisPathComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisPathComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisPathComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acl_rule: Optional['outputs.NetworkInsightsAnalysisAnalysisAclRule'] = None,
                 additional_details: Optional[Sequence['outputs.NetworkInsightsAnalysisAdditionalDetail']] = None,
                 component: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 destination_vpc: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 elastic_load_balancer_listener: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 explanations: Optional[Sequence['outputs.NetworkInsightsAnalysisExplanation']] = None,
                 inbound_header: Optional['outputs.NetworkInsightsAnalysisAnalysisPacketHeader'] = None,
                 outbound_header: Optional['outputs.NetworkInsightsAnalysisAnalysisPacketHeader'] = None,
                 route_table_route: Optional['outputs.NetworkInsightsAnalysisAnalysisRouteTableRoute'] = None,
                 security_group_rule: Optional['outputs.NetworkInsightsAnalysisAnalysisSecurityGroupRule'] = None,
                 sequence_number: Optional[int] = None,
                 service_name: Optional[str] = None,
                 source_vpc: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 subnet: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 transit_gateway: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None,
                 transit_gateway_route_table_route: Optional['outputs.NetworkInsightsAnalysisTransitGatewayRouteTableRoute'] = None,
                 vpc: Optional['outputs.NetworkInsightsAnalysisAnalysisComponent'] = None):
        if acl_rule is not None:
            pulumi.set(__self__, "acl_rule", acl_rule)
        if additional_details is not None:
            pulumi.set(__self__, "additional_details", additional_details)
        if component is not None:
            pulumi.set(__self__, "component", component)
        if destination_vpc is not None:
            pulumi.set(__self__, "destination_vpc", destination_vpc)
        if elastic_load_balancer_listener is not None:
            pulumi.set(__self__, "elastic_load_balancer_listener", elastic_load_balancer_listener)
        if explanations is not None:
            pulumi.set(__self__, "explanations", explanations)
        if inbound_header is not None:
            pulumi.set(__self__, "inbound_header", inbound_header)
        if outbound_header is not None:
            pulumi.set(__self__, "outbound_header", outbound_header)
        if route_table_route is not None:
            pulumi.set(__self__, "route_table_route", route_table_route)
        if security_group_rule is not None:
            pulumi.set(__self__, "security_group_rule", security_group_rule)
        if sequence_number is not None:
            pulumi.set(__self__, "sequence_number", sequence_number)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)
        if source_vpc is not None:
            pulumi.set(__self__, "source_vpc", source_vpc)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)
        if transit_gateway is not None:
            pulumi.set(__self__, "transit_gateway", transit_gateway)
        if transit_gateway_route_table_route is not None:
            pulumi.set(__self__, "transit_gateway_route_table_route", transit_gateway_route_table_route)
        if vpc is not None:
            pulumi.set(__self__, "vpc", vpc)

    @property
    @pulumi.getter(name="aclRule")
    def acl_rule(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisAclRule']:
        return pulumi.get(self, "acl_rule")

    @property
    @pulumi.getter(name="additionalDetails")
    def additional_details(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisAdditionalDetail']]:
        return pulumi.get(self, "additional_details")

    @property
    @pulumi.getter
    def component(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        return pulumi.get(self, "component")

    @property
    @pulumi.getter(name="destinationVpc")
    def destination_vpc(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        return pulumi.get(self, "destination_vpc")

    @property
    @pulumi.getter(name="elasticLoadBalancerListener")
    def elastic_load_balancer_listener(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        return pulumi.get(self, "elastic_load_balancer_listener")

    @property
    @pulumi.getter
    def explanations(self) -> Optional[Sequence['outputs.NetworkInsightsAnalysisExplanation']]:
        return pulumi.get(self, "explanations")

    @property
    @pulumi.getter(name="inboundHeader")
    def inbound_header(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisPacketHeader']:
        return pulumi.get(self, "inbound_header")

    @property
    @pulumi.getter(name="outboundHeader")
    def outbound_header(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisPacketHeader']:
        return pulumi.get(self, "outbound_header")

    @property
    @pulumi.getter(name="routeTableRoute")
    def route_table_route(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisRouteTableRoute']:
        return pulumi.get(self, "route_table_route")

    @property
    @pulumi.getter(name="securityGroupRule")
    def security_group_rule(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisSecurityGroupRule']:
        return pulumi.get(self, "security_group_rule")

    @property
    @pulumi.getter(name="sequenceNumber")
    def sequence_number(self) -> Optional[int]:
        return pulumi.get(self, "sequence_number")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        return pulumi.get(self, "service_name")

    @property
    @pulumi.getter(name="sourceVpc")
    def source_vpc(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        return pulumi.get(self, "source_vpc")

    @property
    @pulumi.getter
    def subnet(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        return pulumi.get(self, "subnet")

    @property
    @pulumi.getter(name="transitGateway")
    def transit_gateway(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        return pulumi.get(self, "transit_gateway")

    @property
    @pulumi.getter(name="transitGatewayRouteTableRoute")
    def transit_gateway_route_table_route(self) -> Optional['outputs.NetworkInsightsAnalysisTransitGatewayRouteTableRoute']:
        return pulumi.get(self, "transit_gateway_route_table_route")

    @property
    @pulumi.getter
    def vpc(self) -> Optional['outputs.NetworkInsightsAnalysisAnalysisComponent']:
        return pulumi.get(self, "vpc")


@pulumi.output_type
class NetworkInsightsAnalysisPortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisPortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisPortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisPortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: Optional[int] = None,
                 to: Optional[int] = None):
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[int]:
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional[int]:
        return pulumi.get(self, "to")


@pulumi.output_type
class NetworkInsightsAnalysisTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class NetworkInsightsAnalysisTransitGatewayRouteTableRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attachmentId":
            suggest = "attachment_id"
        elif key == "destinationCidr":
            suggest = "destination_cidr"
        elif key == "prefixListId":
            suggest = "prefix_list_id"
        elif key == "resourceId":
            suggest = "resource_id"
        elif key == "resourceType":
            suggest = "resource_type"
        elif key == "routeOrigin":
            suggest = "route_origin"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsAnalysisTransitGatewayRouteTableRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsAnalysisTransitGatewayRouteTableRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsAnalysisTransitGatewayRouteTableRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attachment_id: Optional[str] = None,
                 destination_cidr: Optional[str] = None,
                 prefix_list_id: Optional[str] = None,
                 resource_id: Optional[str] = None,
                 resource_type: Optional[str] = None,
                 route_origin: Optional[str] = None,
                 state: Optional[str] = None):
        if attachment_id is not None:
            pulumi.set(__self__, "attachment_id", attachment_id)
        if destination_cidr is not None:
            pulumi.set(__self__, "destination_cidr", destination_cidr)
        if prefix_list_id is not None:
            pulumi.set(__self__, "prefix_list_id", prefix_list_id)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if route_origin is not None:
            pulumi.set(__self__, "route_origin", route_origin)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="attachmentId")
    def attachment_id(self) -> Optional[str]:
        return pulumi.get(self, "attachment_id")

    @property
    @pulumi.getter(name="destinationCidr")
    def destination_cidr(self) -> Optional[str]:
        return pulumi.get(self, "destination_cidr")

    @property
    @pulumi.getter(name="prefixListId")
    def prefix_list_id(self) -> Optional[str]:
        return pulumi.get(self, "prefix_list_id")

    @property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[str]:
        return pulumi.get(self, "resource_id")

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[str]:
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter(name="routeOrigin")
    def route_origin(self) -> Optional[str]:
        return pulumi.get(self, "route_origin")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        return pulumi.get(self, "state")


@pulumi.output_type
class NetworkInsightsPathFilterPortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "toPort":
            suggest = "to_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsPathFilterPortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsPathFilterPortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsPathFilterPortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_port: Optional[int] = None,
                 to_port: Optional[int] = None):
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[int]:
        return pulumi.get(self, "from_port")

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[int]:
        return pulumi.get(self, "to_port")


@pulumi.output_type
class NetworkInsightsPathPathFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddress":
            suggest = "destination_address"
        elif key == "destinationPortRange":
            suggest = "destination_port_range"
        elif key == "sourceAddress":
            suggest = "source_address"
        elif key == "sourcePortRange":
            suggest = "source_port_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInsightsPathPathFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInsightsPathPathFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInsightsPathPathFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_address: Optional[str] = None,
                 destination_port_range: Optional['outputs.NetworkInsightsPathFilterPortRange'] = None,
                 source_address: Optional[str] = None,
                 source_port_range: Optional['outputs.NetworkInsightsPathFilterPortRange'] = None):
        if destination_address is not None:
            pulumi.set(__self__, "destination_address", destination_address)
        if destination_port_range is not None:
            pulumi.set(__self__, "destination_port_range", destination_port_range)
        if source_address is not None:
            pulumi.set(__self__, "source_address", source_address)
        if source_port_range is not None:
            pulumi.set(__self__, "source_port_range", source_port_range)

    @property
    @pulumi.getter(name="destinationAddress")
    def destination_address(self) -> Optional[str]:
        return pulumi.get(self, "destination_address")

    @property
    @pulumi.getter(name="destinationPortRange")
    def destination_port_range(self) -> Optional['outputs.NetworkInsightsPathFilterPortRange']:
        return pulumi.get(self, "destination_port_range")

    @property
    @pulumi.getter(name="sourceAddress")
    def source_address(self) -> Optional[str]:
        return pulumi.get(self, "source_address")

    @property
    @pulumi.getter(name="sourcePortRange")
    def source_port_range(self) -> Optional['outputs.NetworkInsightsPathFilterPortRange']:
        return pulumi.get(self, "source_port_range")


@pulumi.output_type
class NetworkInsightsPathTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class NetworkInterfaceInstanceIpv6Address(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv6Address":
            suggest = "ipv6_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInterfaceInstanceIpv6Address. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInterfaceInstanceIpv6Address.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInterfaceInstanceIpv6Address.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv6_address: str):
        pulumi.set(__self__, "ipv6_address", ipv6_address)

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> str:
        return pulumi.get(self, "ipv6_address")


@pulumi.output_type
class NetworkInterfaceIpv4PrefixSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv4Prefix":
            suggest = "ipv4_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInterfaceIpv4PrefixSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInterfaceIpv4PrefixSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInterfaceIpv4PrefixSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv4_prefix: str):
        pulumi.set(__self__, "ipv4_prefix", ipv4_prefix)

    @property
    @pulumi.getter(name="ipv4Prefix")
    def ipv4_prefix(self) -> str:
        return pulumi.get(self, "ipv4_prefix")


@pulumi.output_type
class NetworkInterfaceIpv6PrefixSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv6Prefix":
            suggest = "ipv6_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInterfaceIpv6PrefixSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInterfaceIpv6PrefixSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInterfaceIpv6PrefixSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv6_prefix: str):
        pulumi.set(__self__, "ipv6_prefix", ipv6_prefix)

    @property
    @pulumi.getter(name="ipv6Prefix")
    def ipv6_prefix(self) -> str:
        return pulumi.get(self, "ipv6_prefix")


@pulumi.output_type
class NetworkInterfacePrivateIpAddressSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIpAddress":
            suggest = "private_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NetworkInterfacePrivateIpAddressSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NetworkInterfacePrivateIpAddressSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NetworkInterfacePrivateIpAddressSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 primary: bool,
                 private_ip_address: str):
        pulumi.set(__self__, "primary", primary)
        pulumi.set(__self__, "private_ip_address", private_ip_address)

    @property
    @pulumi.getter
    def primary(self) -> bool:
        return pulumi.get(self, "primary")

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> str:
        return pulumi.get(self, "private_ip_address")


@pulumi.output_type
class NetworkInterfaceTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class OptionsProperties(dict):
    """
    The options for the transit gateway vpc attachment.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applianceModeSupport":
            suggest = "appliance_mode_support"
        elif key == "dnsSupport":
            suggest = "dns_support"
        elif key == "ipv6Support":
            suggest = "ipv6_support"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OptionsProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OptionsProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OptionsProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 appliance_mode_support: Optional[str] = None,
                 dns_support: Optional[str] = None,
                 ipv6_support: Optional[str] = None):
        """
        The options for the transit gateway vpc attachment.
        :param str appliance_mode_support: Indicates whether to enable Ipv6 Support for Vpc Attachment. Valid Values: enable | disable
        :param str dns_support: Indicates whether to enable DNS Support for Vpc Attachment. Valid Values: enable | disable
        :param str ipv6_support: Indicates whether to enable Ipv6 Support for Vpc Attachment. Valid Values: enable | disable
        """
        if appliance_mode_support is not None:
            pulumi.set(__self__, "appliance_mode_support", appliance_mode_support)
        if dns_support is not None:
            pulumi.set(__self__, "dns_support", dns_support)
        if ipv6_support is not None:
            pulumi.set(__self__, "ipv6_support", ipv6_support)

    @property
    @pulumi.getter(name="applianceModeSupport")
    def appliance_mode_support(self) -> Optional[str]:
        """
        Indicates whether to enable Ipv6 Support for Vpc Attachment. Valid Values: enable | disable
        """
        return pulumi.get(self, "appliance_mode_support")

    @property
    @pulumi.getter(name="dnsSupport")
    def dns_support(self) -> Optional[str]:
        """
        Indicates whether to enable DNS Support for Vpc Attachment. Valid Values: enable | disable
        """
        return pulumi.get(self, "dns_support")

    @property
    @pulumi.getter(name="ipv6Support")
    def ipv6_support(self) -> Optional[str]:
        """
        Indicates whether to enable Ipv6 Support for Vpc Attachment. Valid Values: enable | disable
        """
        return pulumi.get(self, "ipv6_support")


@pulumi.output_type
class PlacementGroupTag(dict):
    """
    A key-value pair to associate with a resource.
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        A key-value pair to associate with a resource.
        :param str key: The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        :param str value: The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class PrefixListEntry(dict):
    def __init__(__self__, *,
                 cidr: str,
                 description: Optional[str] = None):
        pulumi.set(__self__, "cidr", cidr)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def cidr(self) -> str:
        return pulumi.get(self, "cidr")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class PrefixListTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: Optional[str] = None):
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class PrivateDnsNameOptionsOnLaunchProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableResourceNameDnsARecord":
            suggest = "enable_resource_name_dns_a_record"
        elif key == "enableResourceNameDnsAaaaRecord":
            suggest = "enable_resource_name_dns_aaaa_record"
        elif key == "hostnameType":
            suggest = "hostname_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateDnsNameOptionsOnLaunchProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateDnsNameOptionsOnLaunchProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateDnsNameOptionsOnLaunchProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_resource_name_dns_a_record: Optional[bool] = None,
                 enable_resource_name_dns_aaaa_record: Optional[bool] = None,
                 hostname_type: Optional[str] = None):
        if enable_resource_name_dns_a_record is not None:
            pulumi.set(__self__, "enable_resource_name_dns_a_record", enable_resource_name_dns_a_record)
        if enable_resource_name_dns_aaaa_record is not None:
            pulumi.set(__self__, "enable_resource_name_dns_aaaa_record", enable_resource_name_dns_aaaa_record)
        if hostname_type is not None:
            pulumi.set(__self__, "hostname_type", hostname_type)

    @property
    @pulumi.getter(name="enableResourceNameDnsARecord")
    def enable_resource_name_dns_a_record(self) -> Optional[bool]:
        return pulumi.get(self, "enable_resource_name_dns_a_record")

    @property
    @pulumi.getter(name="enableResourceNameDnsAaaaRecord")
    def enable_resource_name_dns_aaaa_record(self) -> Optional[bool]:
        return pulumi.get(self, "enable_resource_name_dns_aaaa_record")

    @property
    @pulumi.getter(name="hostnameType")
    def hostname_type(self) -> Optional[str]:
        return pulumi.get(self, "hostname_type")


@pulumi.output_type
class RouteTableTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class SecurityGroupEgress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipProtocol":
            suggest = "ip_protocol"
        elif key == "cidrIp":
            suggest = "cidr_ip"
        elif key == "cidrIpv6":
            suggest = "cidr_ipv6"
        elif key == "destinationPrefixListId":
            suggest = "destination_prefix_list_id"
        elif key == "destinationSecurityGroupId":
            suggest = "destination_security_group_id"
        elif key == "fromPort":
            suggest = "from_port"
        elif key == "toPort":
            suggest = "to_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityGroupEgress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityGroupEgress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityGroupEgress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_protocol: str,
                 cidr_ip: Optional[str] = None,
                 cidr_ipv6: Optional[str] = None,
                 description: Optional[str] = None,
                 destination_prefix_list_id: Optional[str] = None,
                 destination_security_group_id: Optional[str] = None,
                 from_port: Optional[int] = None,
                 to_port: Optional[int] = None):
        pulumi.set(__self__, "ip_protocol", ip_protocol)
        if cidr_ip is not None:
            pulumi.set(__self__, "cidr_ip", cidr_ip)
        if cidr_ipv6 is not None:
            pulumi.set(__self__, "cidr_ipv6", cidr_ipv6)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destination_prefix_list_id is not None:
            pulumi.set(__self__, "destination_prefix_list_id", destination_prefix_list_id)
        if destination_security_group_id is not None:
            pulumi.set(__self__, "destination_security_group_id", destination_security_group_id)
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)

    @property
    @pulumi.getter(name="ipProtocol")
    def ip_protocol(self) -> str:
        return pulumi.get(self, "ip_protocol")

    @property
    @pulumi.getter(name="cidrIp")
    def cidr_ip(self) -> Optional[str]:
        return pulumi.get(self, "cidr_ip")

    @property
    @pulumi.getter(name="cidrIpv6")
    def cidr_ipv6(self) -> Optional[str]:
        return pulumi.get(self, "cidr_ipv6")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="destinationPrefixListId")
    def destination_prefix_list_id(self) -> Optional[str]:
        return pulumi.get(self, "destination_prefix_list_id")

    @property
    @pulumi.getter(name="destinationSecurityGroupId")
    def destination_security_group_id(self) -> Optional[str]:
        return pulumi.get(self, "destination_security_group_id")

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[int]:
        return pulumi.get(self, "from_port")

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[int]:
        return pulumi.get(self, "to_port")


@pulumi.output_type
class SecurityGroupIngress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipProtocol":
            suggest = "ip_protocol"
        elif key == "cidrIp":
            suggest = "cidr_ip"
        elif key == "cidrIpv6":
            suggest = "cidr_ipv6"
        elif key == "fromPort":
            suggest = "from_port"
        elif key == "sourcePrefixListId":
            suggest = "source_prefix_list_id"
        elif key == "sourceSecurityGroupId":
            suggest = "source_security_group_id"
        elif key == "sourceSecurityGroupName":
            suggest = "source_security_group_name"
        elif key == "sourceSecurityGroupOwnerId":
            suggest = "source_security_group_owner_id"
        elif key == "toPort":
            suggest = "to_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityGroupIngress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityGroupIngress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityGroupIngress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_protocol: str,
                 cidr_ip: Optional[str] = None,
                 cidr_ipv6: Optional[str] = None,
                 description: Optional[str] = None,
                 from_port: Optional[int] = None,
                 source_prefix_list_id: Optional[str] = None,
                 source_security_group_id: Optional[str] = None,
                 source_security_group_name: Optional[str] = None,
                 source_security_group_owner_id: Optional[str] = None,
                 to_port: Optional[int] = None):
        pulumi.set(__self__, "ip_protocol", ip_protocol)
        if cidr_ip is not None:
            pulumi.set(__self__, "cidr_ip", cidr_ip)
        if cidr_ipv6 is not None:
            pulumi.set(__self__, "cidr_ipv6", cidr_ipv6)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if from_port is not None:
            pulumi.set(__self__, "from_port", from_port)
        if source_prefix_list_id is not None:
            pulumi.set(__self__, "source_prefix_list_id", source_prefix_list_id)
        if source_security_group_id is not None:
            pulumi.set(__self__, "source_security_group_id", source_security_group_id)
        if source_security_group_name is not None:
            pulumi.set(__self__, "source_security_group_name", source_security_group_name)
        if source_security_group_owner_id is not None:
            pulumi.set(__self__, "source_security_group_owner_id", source_security_group_owner_id)
        if to_port is not None:
            pulumi.set(__self__, "to_port", to_port)

    @property
    @pulumi.getter(name="ipProtocol")
    def ip_protocol(self) -> str:
        return pulumi.get(self, "ip_protocol")

    @property
    @pulumi.getter(name="cidrIp")
    def cidr_ip(self) -> Optional[str]:
        return pulumi.get(self, "cidr_ip")

    @property
    @pulumi.getter(name="cidrIpv6")
    def cidr_ipv6(self) -> Optional[str]:
        return pulumi.get(self, "cidr_ipv6")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> Optional[int]:
        return pulumi.get(self, "from_port")

    @property
    @pulumi.getter(name="sourcePrefixListId")
    def source_prefix_list_id(self) -> Optional[str]:
        return pulumi.get(self, "source_prefix_list_id")

    @property
    @pulumi.getter(name="sourceSecurityGroupId")
    def source_security_group_id(self) -> Optional[str]:
        return pulumi.get(self, "source_security_group_id")

    @property
    @pulumi.getter(name="sourceSecurityGroupName")
    def source_security_group_name(self) -> Optional[str]:
        return pulumi.get(self, "source_security_group_name")

    @property
    @pulumi.getter(name="sourceSecurityGroupOwnerId")
    def source_security_group_owner_id(self) -> Optional[str]:
        return pulumi.get(self, "source_security_group_owner_id")

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> Optional[int]:
        return pulumi.get(self, "to_port")


@pulumi.output_type
class SecurityGroupTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class SpotFleetAcceleratorCountRequest(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetAcceleratorTotalMemoryMiBRequest(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetBaselineEbsBandwidthMbpsRequest(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetBlockDeviceMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "noDevice":
            suggest = "no_device"
        elif key == "virtualName":
            suggest = "virtual_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetBlockDeviceMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetBlockDeviceMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetBlockDeviceMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: str,
                 ebs: Optional['outputs.SpotFleetEbsBlockDevice'] = None,
                 no_device: Optional[str] = None,
                 virtual_name: Optional[str] = None):
        pulumi.set(__self__, "device_name", device_name)
        if ebs is not None:
            pulumi.set(__self__, "ebs", ebs)
        if no_device is not None:
            pulumi.set(__self__, "no_device", no_device)
        if virtual_name is not None:
            pulumi.set(__self__, "virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter
    def ebs(self) -> Optional['outputs.SpotFleetEbsBlockDevice']:
        return pulumi.get(self, "ebs")

    @property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[str]:
        return pulumi.get(self, "no_device")

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[str]:
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class SpotFleetClassicLoadBalancer(dict):
    def __init__(__self__, *,
                 name: str):
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class SpotFleetClassicLoadBalancersConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "classicLoadBalancers":
            suggest = "classic_load_balancers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetClassicLoadBalancersConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetClassicLoadBalancersConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetClassicLoadBalancersConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 classic_load_balancers: Sequence['outputs.SpotFleetClassicLoadBalancer']):
        pulumi.set(__self__, "classic_load_balancers", classic_load_balancers)

    @property
    @pulumi.getter(name="classicLoadBalancers")
    def classic_load_balancers(self) -> Sequence['outputs.SpotFleetClassicLoadBalancer']:
        return pulumi.get(self, "classic_load_balancers")


@pulumi.output_type
class SpotFleetEbsBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetEbsBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetEbsBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetEbsBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_on_termination: Optional[bool] = None,
                 encrypted: Optional[bool] = None,
                 iops: Optional[int] = None,
                 snapshot_id: Optional[str] = None,
                 volume_size: Optional[int] = None,
                 volume_type: Optional['SpotFleetEbsBlockDeviceVolumeType'] = None):
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if encrypted is not None:
            pulumi.set(__self__, "encrypted", encrypted)
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if snapshot_id is not None:
            pulumi.set(__self__, "snapshot_id", snapshot_id)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)
        if volume_type is not None:
            pulumi.set(__self__, "volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[bool]:
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[bool]:
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[int]:
        return pulumi.get(self, "volume_size")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional['SpotFleetEbsBlockDeviceVolumeType']:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class SpotFleetFleetLaunchTemplateSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTemplateId":
            suggest = "launch_template_id"
        elif key == "launchTemplateName":
            suggest = "launch_template_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetFleetLaunchTemplateSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetFleetLaunchTemplateSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetFleetLaunchTemplateSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 version: str,
                 launch_template_id: Optional[str] = None,
                 launch_template_name: Optional[str] = None):
        pulumi.set(__self__, "version", version)
        if launch_template_id is not None:
            pulumi.set(__self__, "launch_template_id", launch_template_id)
        if launch_template_name is not None:
            pulumi.set(__self__, "launch_template_name", launch_template_name)

    @property
    @pulumi.getter
    def version(self) -> str:
        return pulumi.get(self, "version")

    @property
    @pulumi.getter(name="launchTemplateId")
    def launch_template_id(self) -> Optional[str]:
        return pulumi.get(self, "launch_template_id")

    @property
    @pulumi.getter(name="launchTemplateName")
    def launch_template_name(self) -> Optional[str]:
        return pulumi.get(self, "launch_template_name")


@pulumi.output_type
class SpotFleetGroupIdentifier(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupId":
            suggest = "group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetGroupIdentifier. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetGroupIdentifier.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetGroupIdentifier.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_id: str):
        pulumi.set(__self__, "group_id", group_id)

    @property
    @pulumi.getter(name="groupId")
    def group_id(self) -> str:
        return pulumi.get(self, "group_id")


@pulumi.output_type
class SpotFleetIamInstanceProfileSpecification(dict):
    def __init__(__self__, *,
                 arn: Optional[str] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        return pulumi.get(self, "arn")


@pulumi.output_type
class SpotFleetInstanceIpv6Address(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipv6Address":
            suggest = "ipv6_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetInstanceIpv6Address. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetInstanceIpv6Address.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetInstanceIpv6Address.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ipv6_address: str):
        pulumi.set(__self__, "ipv6_address", ipv6_address)

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> str:
        return pulumi.get(self, "ipv6_address")


@pulumi.output_type
class SpotFleetInstanceNetworkInterfaceSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "associatePublicIpAddress":
            suggest = "associate_public_ip_address"
        elif key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "deviceIndex":
            suggest = "device_index"
        elif key == "ipv6AddressCount":
            suggest = "ipv6_address_count"
        elif key == "ipv6Addresses":
            suggest = "ipv6_addresses"
        elif key == "networkInterfaceId":
            suggest = "network_interface_id"
        elif key == "privateIpAddresses":
            suggest = "private_ip_addresses"
        elif key == "secondaryPrivateIpAddressCount":
            suggest = "secondary_private_ip_address_count"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetInstanceNetworkInterfaceSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetInstanceNetworkInterfaceSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetInstanceNetworkInterfaceSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 associate_public_ip_address: Optional[bool] = None,
                 delete_on_termination: Optional[bool] = None,
                 description: Optional[str] = None,
                 device_index: Optional[int] = None,
                 groups: Optional[Sequence[str]] = None,
                 ipv6_address_count: Optional[int] = None,
                 ipv6_addresses: Optional[Sequence['outputs.SpotFleetInstanceIpv6Address']] = None,
                 network_interface_id: Optional[str] = None,
                 private_ip_addresses: Optional[Sequence['outputs.SpotFleetPrivateIpAddressSpecification']] = None,
                 secondary_private_ip_address_count: Optional[int] = None,
                 subnet_id: Optional[str] = None):
        if associate_public_ip_address is not None:
            pulumi.set(__self__, "associate_public_ip_address", associate_public_ip_address)
        if delete_on_termination is not None:
            pulumi.set(__self__, "delete_on_termination", delete_on_termination)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if device_index is not None:
            pulumi.set(__self__, "device_index", device_index)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if ipv6_address_count is not None:
            pulumi.set(__self__, "ipv6_address_count", ipv6_address_count)
        if ipv6_addresses is not None:
            pulumi.set(__self__, "ipv6_addresses", ipv6_addresses)
        if network_interface_id is not None:
            pulumi.set(__self__, "network_interface_id", network_interface_id)
        if private_ip_addresses is not None:
            pulumi.set(__self__, "private_ip_addresses", private_ip_addresses)
        if secondary_private_ip_address_count is not None:
            pulumi.set(__self__, "secondary_private_ip_address_count", secondary_private_ip_address_count)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="associatePublicIpAddress")
    def associate_public_ip_address(self) -> Optional[bool]:
        return pulumi.get(self, "associate_public_ip_address")

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[bool]:
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="deviceIndex")
    def device_index(self) -> Optional[int]:
        return pulumi.get(self, "device_index")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter(name="ipv6AddressCount")
    def ipv6_address_count(self) -> Optional[int]:
        return pulumi.get(self, "ipv6_address_count")

    @property
    @pulumi.getter(name="ipv6Addresses")
    def ipv6_addresses(self) -> Optional[Sequence['outputs.SpotFleetInstanceIpv6Address']]:
        return pulumi.get(self, "ipv6_addresses")

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[str]:
        return pulumi.get(self, "network_interface_id")

    @property
    @pulumi.getter(name="privateIpAddresses")
    def private_ip_addresses(self) -> Optional[Sequence['outputs.SpotFleetPrivateIpAddressSpecification']]:
        return pulumi.get(self, "private_ip_addresses")

    @property
    @pulumi.getter(name="secondaryPrivateIpAddressCount")
    def secondary_private_ip_address_count(self) -> Optional[int]:
        return pulumi.get(self, "secondary_private_ip_address_count")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class SpotFleetInstanceRequirementsRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceleratorCount":
            suggest = "accelerator_count"
        elif key == "acceleratorManufacturers":
            suggest = "accelerator_manufacturers"
        elif key == "acceleratorNames":
            suggest = "accelerator_names"
        elif key == "acceleratorTotalMemoryMiB":
            suggest = "accelerator_total_memory_mi_b"
        elif key == "acceleratorTypes":
            suggest = "accelerator_types"
        elif key == "allowedInstanceTypes":
            suggest = "allowed_instance_types"
        elif key == "bareMetal":
            suggest = "bare_metal"
        elif key == "baselineEbsBandwidthMbps":
            suggest = "baseline_ebs_bandwidth_mbps"
        elif key == "burstablePerformance":
            suggest = "burstable_performance"
        elif key == "cpuManufacturers":
            suggest = "cpu_manufacturers"
        elif key == "excludedInstanceTypes":
            suggest = "excluded_instance_types"
        elif key == "instanceGenerations":
            suggest = "instance_generations"
        elif key == "localStorage":
            suggest = "local_storage"
        elif key == "localStorageTypes":
            suggest = "local_storage_types"
        elif key == "memoryGiBPerVCpu":
            suggest = "memory_gi_b_per_v_cpu"
        elif key == "memoryMiB":
            suggest = "memory_mi_b"
        elif key == "networkBandwidthGbps":
            suggest = "network_bandwidth_gbps"
        elif key == "networkInterfaceCount":
            suggest = "network_interface_count"
        elif key == "onDemandMaxPricePercentageOverLowestPrice":
            suggest = "on_demand_max_price_percentage_over_lowest_price"
        elif key == "requireHibernateSupport":
            suggest = "require_hibernate_support"
        elif key == "spotMaxPricePercentageOverLowestPrice":
            suggest = "spot_max_price_percentage_over_lowest_price"
        elif key == "totalLocalStorageGb":
            suggest = "total_local_storage_gb"
        elif key == "vCpuCount":
            suggest = "v_cpu_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetInstanceRequirementsRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetInstanceRequirementsRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetInstanceRequirementsRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accelerator_count: Optional['outputs.SpotFleetAcceleratorCountRequest'] = None,
                 accelerator_manufacturers: Optional[Sequence['SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem']] = None,
                 accelerator_names: Optional[Sequence['SpotFleetInstanceRequirementsRequestAcceleratorNamesItem']] = None,
                 accelerator_total_memory_mi_b: Optional['outputs.SpotFleetAcceleratorTotalMemoryMiBRequest'] = None,
                 accelerator_types: Optional[Sequence['SpotFleetInstanceRequirementsRequestAcceleratorTypesItem']] = None,
                 allowed_instance_types: Optional[Sequence[str]] = None,
                 bare_metal: Optional['SpotFleetInstanceRequirementsRequestBareMetal'] = None,
                 baseline_ebs_bandwidth_mbps: Optional['outputs.SpotFleetBaselineEbsBandwidthMbpsRequest'] = None,
                 burstable_performance: Optional['SpotFleetInstanceRequirementsRequestBurstablePerformance'] = None,
                 cpu_manufacturers: Optional[Sequence['SpotFleetInstanceRequirementsRequestCpuManufacturersItem']] = None,
                 excluded_instance_types: Optional[Sequence[str]] = None,
                 instance_generations: Optional[Sequence['SpotFleetInstanceRequirementsRequestInstanceGenerationsItem']] = None,
                 local_storage: Optional['SpotFleetInstanceRequirementsRequestLocalStorage'] = None,
                 local_storage_types: Optional[Sequence['SpotFleetInstanceRequirementsRequestLocalStorageTypesItem']] = None,
                 memory_gi_b_per_v_cpu: Optional['outputs.SpotFleetMemoryGiBPerVCpuRequest'] = None,
                 memory_mi_b: Optional['outputs.SpotFleetMemoryMiBRequest'] = None,
                 network_bandwidth_gbps: Optional['outputs.SpotFleetNetworkBandwidthGbpsRequest'] = None,
                 network_interface_count: Optional['outputs.SpotFleetNetworkInterfaceCountRequest'] = None,
                 on_demand_max_price_percentage_over_lowest_price: Optional[int] = None,
                 require_hibernate_support: Optional[bool] = None,
                 spot_max_price_percentage_over_lowest_price: Optional[int] = None,
                 total_local_storage_gb: Optional['outputs.SpotFleetTotalLocalStorageGbRequest'] = None,
                 v_cpu_count: Optional['outputs.SpotFleetVCpuCountRangeRequest'] = None):
        if accelerator_count is not None:
            pulumi.set(__self__, "accelerator_count", accelerator_count)
        if accelerator_manufacturers is not None:
            pulumi.set(__self__, "accelerator_manufacturers", accelerator_manufacturers)
        if accelerator_names is not None:
            pulumi.set(__self__, "accelerator_names", accelerator_names)
        if accelerator_total_memory_mi_b is not None:
            pulumi.set(__self__, "accelerator_total_memory_mi_b", accelerator_total_memory_mi_b)
        if accelerator_types is not None:
            pulumi.set(__self__, "accelerator_types", accelerator_types)
        if allowed_instance_types is not None:
            pulumi.set(__self__, "allowed_instance_types", allowed_instance_types)
        if bare_metal is not None:
            pulumi.set(__self__, "bare_metal", bare_metal)
        if baseline_ebs_bandwidth_mbps is not None:
            pulumi.set(__self__, "baseline_ebs_bandwidth_mbps", baseline_ebs_bandwidth_mbps)
        if burstable_performance is not None:
            pulumi.set(__self__, "burstable_performance", burstable_performance)
        if cpu_manufacturers is not None:
            pulumi.set(__self__, "cpu_manufacturers", cpu_manufacturers)
        if excluded_instance_types is not None:
            pulumi.set(__self__, "excluded_instance_types", excluded_instance_types)
        if instance_generations is not None:
            pulumi.set(__self__, "instance_generations", instance_generations)
        if local_storage is not None:
            pulumi.set(__self__, "local_storage", local_storage)
        if local_storage_types is not None:
            pulumi.set(__self__, "local_storage_types", local_storage_types)
        if memory_gi_b_per_v_cpu is not None:
            pulumi.set(__self__, "memory_gi_b_per_v_cpu", memory_gi_b_per_v_cpu)
        if memory_mi_b is not None:
            pulumi.set(__self__, "memory_mi_b", memory_mi_b)
        if network_bandwidth_gbps is not None:
            pulumi.set(__self__, "network_bandwidth_gbps", network_bandwidth_gbps)
        if network_interface_count is not None:
            pulumi.set(__self__, "network_interface_count", network_interface_count)
        if on_demand_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "on_demand_max_price_percentage_over_lowest_price", on_demand_max_price_percentage_over_lowest_price)
        if require_hibernate_support is not None:
            pulumi.set(__self__, "require_hibernate_support", require_hibernate_support)
        if spot_max_price_percentage_over_lowest_price is not None:
            pulumi.set(__self__, "spot_max_price_percentage_over_lowest_price", spot_max_price_percentage_over_lowest_price)
        if total_local_storage_gb is not None:
            pulumi.set(__self__, "total_local_storage_gb", total_local_storage_gb)
        if v_cpu_count is not None:
            pulumi.set(__self__, "v_cpu_count", v_cpu_count)

    @property
    @pulumi.getter(name="acceleratorCount")
    def accelerator_count(self) -> Optional['outputs.SpotFleetAcceleratorCountRequest']:
        return pulumi.get(self, "accelerator_count")

    @property
    @pulumi.getter(name="acceleratorManufacturers")
    def accelerator_manufacturers(self) -> Optional[Sequence['SpotFleetInstanceRequirementsRequestAcceleratorManufacturersItem']]:
        return pulumi.get(self, "accelerator_manufacturers")

    @property
    @pulumi.getter(name="acceleratorNames")
    def accelerator_names(self) -> Optional[Sequence['SpotFleetInstanceRequirementsRequestAcceleratorNamesItem']]:
        return pulumi.get(self, "accelerator_names")

    @property
    @pulumi.getter(name="acceleratorTotalMemoryMiB")
    def accelerator_total_memory_mi_b(self) -> Optional['outputs.SpotFleetAcceleratorTotalMemoryMiBRequest']:
        return pulumi.get(self, "accelerator_total_memory_mi_b")

    @property
    @pulumi.getter(name="acceleratorTypes")
    def accelerator_types(self) -> Optional[Sequence['SpotFleetInstanceRequirementsRequestAcceleratorTypesItem']]:
        return pulumi.get(self, "accelerator_types")

    @property
    @pulumi.getter(name="allowedInstanceTypes")
    def allowed_instance_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allowed_instance_types")

    @property
    @pulumi.getter(name="bareMetal")
    def bare_metal(self) -> Optional['SpotFleetInstanceRequirementsRequestBareMetal']:
        return pulumi.get(self, "bare_metal")

    @property
    @pulumi.getter(name="baselineEbsBandwidthMbps")
    def baseline_ebs_bandwidth_mbps(self) -> Optional['outputs.SpotFleetBaselineEbsBandwidthMbpsRequest']:
        return pulumi.get(self, "baseline_ebs_bandwidth_mbps")

    @property
    @pulumi.getter(name="burstablePerformance")
    def burstable_performance(self) -> Optional['SpotFleetInstanceRequirementsRequestBurstablePerformance']:
        return pulumi.get(self, "burstable_performance")

    @property
    @pulumi.getter(name="cpuManufacturers")
    def cpu_manufacturers(self) -> Optional[Sequence['SpotFleetInstanceRequirementsRequestCpuManufacturersItem']]:
        return pulumi.get(self, "cpu_manufacturers")

    @property
    @pulumi.getter(name="excludedInstanceTypes")
    def excluded_instance_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_instance_types")

    @property
    @pulumi.getter(name="instanceGenerations")
    def instance_generations(self) -> Optional[Sequence['SpotFleetInstanceRequirementsRequestInstanceGenerationsItem']]:
        return pulumi.get(self, "instance_generations")

    @property
    @pulumi.getter(name="localStorage")
    def local_storage(self) -> Optional['SpotFleetInstanceRequirementsRequestLocalStorage']:
        return pulumi.get(self, "local_storage")

    @property
    @pulumi.getter(name="localStorageTypes")
    def local_storage_types(self) -> Optional[Sequence['SpotFleetInstanceRequirementsRequestLocalStorageTypesItem']]:
        return pulumi.get(self, "local_storage_types")

    @property
    @pulumi.getter(name="memoryGiBPerVCpu")
    def memory_gi_b_per_v_cpu(self) -> Optional['outputs.SpotFleetMemoryGiBPerVCpuRequest']:
        return pulumi.get(self, "memory_gi_b_per_v_cpu")

    @property
    @pulumi.getter(name="memoryMiB")
    def memory_mi_b(self) -> Optional['outputs.SpotFleetMemoryMiBRequest']:
        return pulumi.get(self, "memory_mi_b")

    @property
    @pulumi.getter(name="networkBandwidthGbps")
    def network_bandwidth_gbps(self) -> Optional['outputs.SpotFleetNetworkBandwidthGbpsRequest']:
        return pulumi.get(self, "network_bandwidth_gbps")

    @property
    @pulumi.getter(name="networkInterfaceCount")
    def network_interface_count(self) -> Optional['outputs.SpotFleetNetworkInterfaceCountRequest']:
        return pulumi.get(self, "network_interface_count")

    @property
    @pulumi.getter(name="onDemandMaxPricePercentageOverLowestPrice")
    def on_demand_max_price_percentage_over_lowest_price(self) -> Optional[int]:
        return pulumi.get(self, "on_demand_max_price_percentage_over_lowest_price")

    @property
    @pulumi.getter(name="requireHibernateSupport")
    def require_hibernate_support(self) -> Optional[bool]:
        return pulumi.get(self, "require_hibernate_support")

    @property
    @pulumi.getter(name="spotMaxPricePercentageOverLowestPrice")
    def spot_max_price_percentage_over_lowest_price(self) -> Optional[int]:
        return pulumi.get(self, "spot_max_price_percentage_over_lowest_price")

    @property
    @pulumi.getter(name="totalLocalStorageGb")
    def total_local_storage_gb(self) -> Optional['outputs.SpotFleetTotalLocalStorageGbRequest']:
        return pulumi.get(self, "total_local_storage_gb")

    @property
    @pulumi.getter(name="vCpuCount")
    def v_cpu_count(self) -> Optional['outputs.SpotFleetVCpuCountRangeRequest']:
        return pulumi.get(self, "v_cpu_count")


@pulumi.output_type
class SpotFleetLaunchSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageId":
            suggest = "image_id"
        elif key == "blockDeviceMappings":
            suggest = "block_device_mappings"
        elif key == "ebsOptimized":
            suggest = "ebs_optimized"
        elif key == "iamInstanceProfile":
            suggest = "iam_instance_profile"
        elif key == "instanceRequirements":
            suggest = "instance_requirements"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "kernelId":
            suggest = "kernel_id"
        elif key == "keyName":
            suggest = "key_name"
        elif key == "networkInterfaces":
            suggest = "network_interfaces"
        elif key == "ramdiskId":
            suggest = "ramdisk_id"
        elif key == "securityGroups":
            suggest = "security_groups"
        elif key == "spotPrice":
            suggest = "spot_price"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "tagSpecifications":
            suggest = "tag_specifications"
        elif key == "userData":
            suggest = "user_data"
        elif key == "weightedCapacity":
            suggest = "weighted_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetLaunchSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetLaunchSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetLaunchSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_id: str,
                 block_device_mappings: Optional[Sequence['outputs.SpotFleetBlockDeviceMapping']] = None,
                 ebs_optimized: Optional[bool] = None,
                 iam_instance_profile: Optional['outputs.SpotFleetIamInstanceProfileSpecification'] = None,
                 instance_requirements: Optional['outputs.SpotFleetInstanceRequirementsRequest'] = None,
                 instance_type: Optional[str] = None,
                 kernel_id: Optional[str] = None,
                 key_name: Optional[str] = None,
                 monitoring: Optional['outputs.SpotFleetMonitoring'] = None,
                 network_interfaces: Optional[Sequence['outputs.SpotFleetInstanceNetworkInterfaceSpecification']] = None,
                 placement: Optional['outputs.SpotFleetSpotPlacement'] = None,
                 ramdisk_id: Optional[str] = None,
                 security_groups: Optional[Sequence['outputs.SpotFleetGroupIdentifier']] = None,
                 spot_price: Optional[str] = None,
                 subnet_id: Optional[str] = None,
                 tag_specifications: Optional[Sequence['outputs.SpotFleetTagSpecification']] = None,
                 user_data: Optional[str] = None,
                 weighted_capacity: Optional[float] = None):
        pulumi.set(__self__, "image_id", image_id)
        if block_device_mappings is not None:
            pulumi.set(__self__, "block_device_mappings", block_device_mappings)
        if ebs_optimized is not None:
            pulumi.set(__self__, "ebs_optimized", ebs_optimized)
        if iam_instance_profile is not None:
            pulumi.set(__self__, "iam_instance_profile", iam_instance_profile)
        if instance_requirements is not None:
            pulumi.set(__self__, "instance_requirements", instance_requirements)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if kernel_id is not None:
            pulumi.set(__self__, "kernel_id", kernel_id)
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if monitoring is not None:
            pulumi.set(__self__, "monitoring", monitoring)
        if network_interfaces is not None:
            pulumi.set(__self__, "network_interfaces", network_interfaces)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if ramdisk_id is not None:
            pulumi.set(__self__, "ramdisk_id", ramdisk_id)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if spot_price is not None:
            pulumi.set(__self__, "spot_price", spot_price)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if tag_specifications is not None:
            pulumi.set(__self__, "tag_specifications", tag_specifications)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)
        if weighted_capacity is not None:
            pulumi.set(__self__, "weighted_capacity", weighted_capacity)

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> str:
        return pulumi.get(self, "image_id")

    @property
    @pulumi.getter(name="blockDeviceMappings")
    def block_device_mappings(self) -> Optional[Sequence['outputs.SpotFleetBlockDeviceMapping']]:
        return pulumi.get(self, "block_device_mappings")

    @property
    @pulumi.getter(name="ebsOptimized")
    def ebs_optimized(self) -> Optional[bool]:
        return pulumi.get(self, "ebs_optimized")

    @property
    @pulumi.getter(name="iamInstanceProfile")
    def iam_instance_profile(self) -> Optional['outputs.SpotFleetIamInstanceProfileSpecification']:
        return pulumi.get(self, "iam_instance_profile")

    @property
    @pulumi.getter(name="instanceRequirements")
    def instance_requirements(self) -> Optional['outputs.SpotFleetInstanceRequirementsRequest']:
        return pulumi.get(self, "instance_requirements")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[str]:
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="kernelId")
    def kernel_id(self) -> Optional[str]:
        return pulumi.get(self, "kernel_id")

    @property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[str]:
        return pulumi.get(self, "key_name")

    @property
    @pulumi.getter
    def monitoring(self) -> Optional['outputs.SpotFleetMonitoring']:
        return pulumi.get(self, "monitoring")

    @property
    @pulumi.getter(name="networkInterfaces")
    def network_interfaces(self) -> Optional[Sequence['outputs.SpotFleetInstanceNetworkInterfaceSpecification']]:
        return pulumi.get(self, "network_interfaces")

    @property
    @pulumi.getter
    def placement(self) -> Optional['outputs.SpotFleetSpotPlacement']:
        return pulumi.get(self, "placement")

    @property
    @pulumi.getter(name="ramdiskId")
    def ramdisk_id(self) -> Optional[str]:
        return pulumi.get(self, "ramdisk_id")

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence['outputs.SpotFleetGroupIdentifier']]:
        return pulumi.get(self, "security_groups")

    @property
    @pulumi.getter(name="spotPrice")
    def spot_price(self) -> Optional[str]:
        return pulumi.get(self, "spot_price")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="tagSpecifications")
    def tag_specifications(self) -> Optional[Sequence['outputs.SpotFleetTagSpecification']]:
        return pulumi.get(self, "tag_specifications")

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[str]:
        return pulumi.get(self, "user_data")

    @property
    @pulumi.getter(name="weightedCapacity")
    def weighted_capacity(self) -> Optional[float]:
        return pulumi.get(self, "weighted_capacity")


@pulumi.output_type
class SpotFleetLaunchTemplateConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTemplateSpecification":
            suggest = "launch_template_specification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetLaunchTemplateConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetLaunchTemplateConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetLaunchTemplateConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 launch_template_specification: Optional['outputs.SpotFleetFleetLaunchTemplateSpecification'] = None,
                 overrides: Optional[Sequence['outputs.SpotFleetLaunchTemplateOverrides']] = None):
        if launch_template_specification is not None:
            pulumi.set(__self__, "launch_template_specification", launch_template_specification)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)

    @property
    @pulumi.getter(name="launchTemplateSpecification")
    def launch_template_specification(self) -> Optional['outputs.SpotFleetFleetLaunchTemplateSpecification']:
        return pulumi.get(self, "launch_template_specification")

    @property
    @pulumi.getter
    def overrides(self) -> Optional[Sequence['outputs.SpotFleetLaunchTemplateOverrides']]:
        return pulumi.get(self, "overrides")


@pulumi.output_type
class SpotFleetLaunchTemplateOverrides(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "instanceRequirements":
            suggest = "instance_requirements"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "spotPrice":
            suggest = "spot_price"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "weightedCapacity":
            suggest = "weighted_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetLaunchTemplateOverrides. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetLaunchTemplateOverrides.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetLaunchTemplateOverrides.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone: Optional[str] = None,
                 instance_requirements: Optional['outputs.SpotFleetInstanceRequirementsRequest'] = None,
                 instance_type: Optional[str] = None,
                 priority: Optional[float] = None,
                 spot_price: Optional[str] = None,
                 subnet_id: Optional[str] = None,
                 weighted_capacity: Optional[float] = None):
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if instance_requirements is not None:
            pulumi.set(__self__, "instance_requirements", instance_requirements)
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if spot_price is not None:
            pulumi.set(__self__, "spot_price", spot_price)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if weighted_capacity is not None:
            pulumi.set(__self__, "weighted_capacity", weighted_capacity)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[str]:
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="instanceRequirements")
    def instance_requirements(self) -> Optional['outputs.SpotFleetInstanceRequirementsRequest']:
        return pulumi.get(self, "instance_requirements")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[str]:
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter
    def priority(self) -> Optional[float]:
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="spotPrice")
    def spot_price(self) -> Optional[str]:
        return pulumi.get(self, "spot_price")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="weightedCapacity")
    def weighted_capacity(self) -> Optional[float]:
        return pulumi.get(self, "weighted_capacity")


@pulumi.output_type
class SpotFleetLoadBalancersConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "classicLoadBalancersConfig":
            suggest = "classic_load_balancers_config"
        elif key == "targetGroupsConfig":
            suggest = "target_groups_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetLoadBalancersConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetLoadBalancersConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetLoadBalancersConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 classic_load_balancers_config: Optional['outputs.SpotFleetClassicLoadBalancersConfig'] = None,
                 target_groups_config: Optional['outputs.SpotFleetTargetGroupsConfig'] = None):
        if classic_load_balancers_config is not None:
            pulumi.set(__self__, "classic_load_balancers_config", classic_load_balancers_config)
        if target_groups_config is not None:
            pulumi.set(__self__, "target_groups_config", target_groups_config)

    @property
    @pulumi.getter(name="classicLoadBalancersConfig")
    def classic_load_balancers_config(self) -> Optional['outputs.SpotFleetClassicLoadBalancersConfig']:
        return pulumi.get(self, "classic_load_balancers_config")

    @property
    @pulumi.getter(name="targetGroupsConfig")
    def target_groups_config(self) -> Optional['outputs.SpotFleetTargetGroupsConfig']:
        return pulumi.get(self, "target_groups_config")


@pulumi.output_type
class SpotFleetMemoryGiBPerVCpuRequest(dict):
    def __init__(__self__, *,
                 max: Optional[float] = None,
                 min: Optional[float] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetMemoryMiBRequest(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetMonitoring(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class SpotFleetNetworkBandwidthGbpsRequest(dict):
    def __init__(__self__, *,
                 max: Optional[float] = None,
                 min: Optional[float] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetNetworkInterfaceCountRequest(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetPrivateIpAddressSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateIpAddress":
            suggest = "private_ip_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetPrivateIpAddressSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetPrivateIpAddressSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetPrivateIpAddressSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_ip_address: str,
                 primary: Optional[bool] = None):
        pulumi.set(__self__, "private_ip_address", private_ip_address)
        if primary is not None:
            pulumi.set(__self__, "primary", primary)

    @property
    @pulumi.getter(name="privateIpAddress")
    def private_ip_address(self) -> str:
        return pulumi.get(self, "private_ip_address")

    @property
    @pulumi.getter
    def primary(self) -> Optional[bool]:
        return pulumi.get(self, "primary")


@pulumi.output_type
class SpotFleetRequestConfigData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iamFleetRole":
            suggest = "iam_fleet_role"
        elif key == "targetCapacity":
            suggest = "target_capacity"
        elif key == "allocationStrategy":
            suggest = "allocation_strategy"
        elif key == "excessCapacityTerminationPolicy":
            suggest = "excess_capacity_termination_policy"
        elif key == "instanceInterruptionBehavior":
            suggest = "instance_interruption_behavior"
        elif key == "instancePoolsToUseCount":
            suggest = "instance_pools_to_use_count"
        elif key == "launchSpecifications":
            suggest = "launch_specifications"
        elif key == "launchTemplateConfigs":
            suggest = "launch_template_configs"
        elif key == "loadBalancersConfig":
            suggest = "load_balancers_config"
        elif key == "onDemandAllocationStrategy":
            suggest = "on_demand_allocation_strategy"
        elif key == "onDemandMaxTotalPrice":
            suggest = "on_demand_max_total_price"
        elif key == "onDemandTargetCapacity":
            suggest = "on_demand_target_capacity"
        elif key == "replaceUnhealthyInstances":
            suggest = "replace_unhealthy_instances"
        elif key == "spotMaintenanceStrategies":
            suggest = "spot_maintenance_strategies"
        elif key == "spotMaxTotalPrice":
            suggest = "spot_max_total_price"
        elif key == "spotPrice":
            suggest = "spot_price"
        elif key == "tagSpecifications":
            suggest = "tag_specifications"
        elif key == "targetCapacityUnitType":
            suggest = "target_capacity_unit_type"
        elif key == "terminateInstancesWithExpiration":
            suggest = "terminate_instances_with_expiration"
        elif key == "validFrom":
            suggest = "valid_from"
        elif key == "validUntil":
            suggest = "valid_until"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetRequestConfigData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetRequestConfigData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetRequestConfigData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iam_fleet_role: str,
                 target_capacity: int,
                 allocation_strategy: Optional['SpotFleetRequestConfigDataAllocationStrategy'] = None,
                 context: Optional[str] = None,
                 excess_capacity_termination_policy: Optional['SpotFleetRequestConfigDataExcessCapacityTerminationPolicy'] = None,
                 instance_interruption_behavior: Optional['SpotFleetRequestConfigDataInstanceInterruptionBehavior'] = None,
                 instance_pools_to_use_count: Optional[int] = None,
                 launch_specifications: Optional[Sequence['outputs.SpotFleetLaunchSpecification']] = None,
                 launch_template_configs: Optional[Sequence['outputs.SpotFleetLaunchTemplateConfig']] = None,
                 load_balancers_config: Optional['outputs.SpotFleetLoadBalancersConfig'] = None,
                 on_demand_allocation_strategy: Optional[str] = None,
                 on_demand_max_total_price: Optional[str] = None,
                 on_demand_target_capacity: Optional[int] = None,
                 replace_unhealthy_instances: Optional[bool] = None,
                 spot_maintenance_strategies: Optional['outputs.SpotFleetSpotMaintenanceStrategies'] = None,
                 spot_max_total_price: Optional[str] = None,
                 spot_price: Optional[str] = None,
                 tag_specifications: Optional[Sequence['outputs.SpotFleetTagSpecification']] = None,
                 target_capacity_unit_type: Optional['SpotFleetRequestConfigDataTargetCapacityUnitType'] = None,
                 terminate_instances_with_expiration: Optional[bool] = None,
                 type: Optional['SpotFleetRequestConfigDataType'] = None,
                 valid_from: Optional[str] = None,
                 valid_until: Optional[str] = None):
        pulumi.set(__self__, "iam_fleet_role", iam_fleet_role)
        pulumi.set(__self__, "target_capacity", target_capacity)
        if allocation_strategy is not None:
            pulumi.set(__self__, "allocation_strategy", allocation_strategy)
        if context is not None:
            pulumi.set(__self__, "context", context)
        if excess_capacity_termination_policy is not None:
            pulumi.set(__self__, "excess_capacity_termination_policy", excess_capacity_termination_policy)
        if instance_interruption_behavior is not None:
            pulumi.set(__self__, "instance_interruption_behavior", instance_interruption_behavior)
        if instance_pools_to_use_count is not None:
            pulumi.set(__self__, "instance_pools_to_use_count", instance_pools_to_use_count)
        if launch_specifications is not None:
            pulumi.set(__self__, "launch_specifications", launch_specifications)
        if launch_template_configs is not None:
            pulumi.set(__self__, "launch_template_configs", launch_template_configs)
        if load_balancers_config is not None:
            pulumi.set(__self__, "load_balancers_config", load_balancers_config)
        if on_demand_allocation_strategy is not None:
            pulumi.set(__self__, "on_demand_allocation_strategy", on_demand_allocation_strategy)
        if on_demand_max_total_price is not None:
            pulumi.set(__self__, "on_demand_max_total_price", on_demand_max_total_price)
        if on_demand_target_capacity is not None:
            pulumi.set(__self__, "on_demand_target_capacity", on_demand_target_capacity)
        if replace_unhealthy_instances is not None:
            pulumi.set(__self__, "replace_unhealthy_instances", replace_unhealthy_instances)
        if spot_maintenance_strategies is not None:
            pulumi.set(__self__, "spot_maintenance_strategies", spot_maintenance_strategies)
        if spot_max_total_price is not None:
            pulumi.set(__self__, "spot_max_total_price", spot_max_total_price)
        if spot_price is not None:
            pulumi.set(__self__, "spot_price", spot_price)
        if tag_specifications is not None:
            pulumi.set(__self__, "tag_specifications", tag_specifications)
        if target_capacity_unit_type is not None:
            pulumi.set(__self__, "target_capacity_unit_type", target_capacity_unit_type)
        if terminate_instances_with_expiration is not None:
            pulumi.set(__self__, "terminate_instances_with_expiration", terminate_instances_with_expiration)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if valid_from is not None:
            pulumi.set(__self__, "valid_from", valid_from)
        if valid_until is not None:
            pulumi.set(__self__, "valid_until", valid_until)

    @property
    @pulumi.getter(name="iamFleetRole")
    def iam_fleet_role(self) -> str:
        return pulumi.get(self, "iam_fleet_role")

    @property
    @pulumi.getter(name="targetCapacity")
    def target_capacity(self) -> int:
        return pulumi.get(self, "target_capacity")

    @property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> Optional['SpotFleetRequestConfigDataAllocationStrategy']:
        return pulumi.get(self, "allocation_strategy")

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter(name="excessCapacityTerminationPolicy")
    def excess_capacity_termination_policy(self) -> Optional['SpotFleetRequestConfigDataExcessCapacityTerminationPolicy']:
        return pulumi.get(self, "excess_capacity_termination_policy")

    @property
    @pulumi.getter(name="instanceInterruptionBehavior")
    def instance_interruption_behavior(self) -> Optional['SpotFleetRequestConfigDataInstanceInterruptionBehavior']:
        return pulumi.get(self, "instance_interruption_behavior")

    @property
    @pulumi.getter(name="instancePoolsToUseCount")
    def instance_pools_to_use_count(self) -> Optional[int]:
        return pulumi.get(self, "instance_pools_to_use_count")

    @property
    @pulumi.getter(name="launchSpecifications")
    def launch_specifications(self) -> Optional[Sequence['outputs.SpotFleetLaunchSpecification']]:
        return pulumi.get(self, "launch_specifications")

    @property
    @pulumi.getter(name="launchTemplateConfigs")
    def launch_template_configs(self) -> Optional[Sequence['outputs.SpotFleetLaunchTemplateConfig']]:
        return pulumi.get(self, "launch_template_configs")

    @property
    @pulumi.getter(name="loadBalancersConfig")
    def load_balancers_config(self) -> Optional['outputs.SpotFleetLoadBalancersConfig']:
        return pulumi.get(self, "load_balancers_config")

    @property
    @pulumi.getter(name="onDemandAllocationStrategy")
    def on_demand_allocation_strategy(self) -> Optional[str]:
        return pulumi.get(self, "on_demand_allocation_strategy")

    @property
    @pulumi.getter(name="onDemandMaxTotalPrice")
    def on_demand_max_total_price(self) -> Optional[str]:
        return pulumi.get(self, "on_demand_max_total_price")

    @property
    @pulumi.getter(name="onDemandTargetCapacity")
    def on_demand_target_capacity(self) -> Optional[int]:
        return pulumi.get(self, "on_demand_target_capacity")

    @property
    @pulumi.getter(name="replaceUnhealthyInstances")
    def replace_unhealthy_instances(self) -> Optional[bool]:
        return pulumi.get(self, "replace_unhealthy_instances")

    @property
    @pulumi.getter(name="spotMaintenanceStrategies")
    def spot_maintenance_strategies(self) -> Optional['outputs.SpotFleetSpotMaintenanceStrategies']:
        return pulumi.get(self, "spot_maintenance_strategies")

    @property
    @pulumi.getter(name="spotMaxTotalPrice")
    def spot_max_total_price(self) -> Optional[str]:
        return pulumi.get(self, "spot_max_total_price")

    @property
    @pulumi.getter(name="spotPrice")
    def spot_price(self) -> Optional[str]:
        return pulumi.get(self, "spot_price")

    @property
    @pulumi.getter(name="tagSpecifications")
    def tag_specifications(self) -> Optional[Sequence['outputs.SpotFleetTagSpecification']]:
        return pulumi.get(self, "tag_specifications")

    @property
    @pulumi.getter(name="targetCapacityUnitType")
    def target_capacity_unit_type(self) -> Optional['SpotFleetRequestConfigDataTargetCapacityUnitType']:
        return pulumi.get(self, "target_capacity_unit_type")

    @property
    @pulumi.getter(name="terminateInstancesWithExpiration")
    def terminate_instances_with_expiration(self) -> Optional[bool]:
        return pulumi.get(self, "terminate_instances_with_expiration")

    @property
    @pulumi.getter
    def type(self) -> Optional['SpotFleetRequestConfigDataType']:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="validFrom")
    def valid_from(self) -> Optional[str]:
        return pulumi.get(self, "valid_from")

    @property
    @pulumi.getter(name="validUntil")
    def valid_until(self) -> Optional[str]:
        return pulumi.get(self, "valid_until")


@pulumi.output_type
class SpotFleetSpotCapacityRebalance(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replacementStrategy":
            suggest = "replacement_strategy"
        elif key == "terminationDelay":
            suggest = "termination_delay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetSpotCapacityRebalance. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetSpotCapacityRebalance.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetSpotCapacityRebalance.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 replacement_strategy: Optional['SpotFleetSpotCapacityRebalanceReplacementStrategy'] = None,
                 termination_delay: Optional[int] = None):
        if replacement_strategy is not None:
            pulumi.set(__self__, "replacement_strategy", replacement_strategy)
        if termination_delay is not None:
            pulumi.set(__self__, "termination_delay", termination_delay)

    @property
    @pulumi.getter(name="replacementStrategy")
    def replacement_strategy(self) -> Optional['SpotFleetSpotCapacityRebalanceReplacementStrategy']:
        return pulumi.get(self, "replacement_strategy")

    @property
    @pulumi.getter(name="terminationDelay")
    def termination_delay(self) -> Optional[int]:
        return pulumi.get(self, "termination_delay")


@pulumi.output_type
class SpotFleetSpotMaintenanceStrategies(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityRebalance":
            suggest = "capacity_rebalance"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetSpotMaintenanceStrategies. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetSpotMaintenanceStrategies.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetSpotMaintenanceStrategies.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 capacity_rebalance: Optional['outputs.SpotFleetSpotCapacityRebalance'] = None):
        if capacity_rebalance is not None:
            pulumi.set(__self__, "capacity_rebalance", capacity_rebalance)

    @property
    @pulumi.getter(name="capacityRebalance")
    def capacity_rebalance(self) -> Optional['outputs.SpotFleetSpotCapacityRebalance']:
        return pulumi.get(self, "capacity_rebalance")


@pulumi.output_type
class SpotFleetSpotPlacement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "groupName":
            suggest = "group_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetSpotPlacement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetSpotPlacement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetSpotPlacement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone: Optional[str] = None,
                 group_name: Optional[str] = None,
                 tenancy: Optional['SpotFleetSpotPlacementTenancy'] = None):
        if availability_zone is not None:
            pulumi.set(__self__, "availability_zone", availability_zone)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if tenancy is not None:
            pulumi.set(__self__, "tenancy", tenancy)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[str]:
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[str]:
        return pulumi.get(self, "group_name")

    @property
    @pulumi.getter
    def tenancy(self) -> Optional['SpotFleetSpotPlacementTenancy']:
        return pulumi.get(self, "tenancy")


@pulumi.output_type
class SpotFleetTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class SpotFleetTagSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetTagSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetTagSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetTagSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_type: Optional['SpotFleetTagSpecificationResourceType'] = None,
                 tags: Optional[Sequence['outputs.SpotFleetTag']] = None):
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional['SpotFleetTagSpecificationResourceType']:
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.SpotFleetTag']]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class SpotFleetTargetGroup(dict):
    def __init__(__self__, *,
                 arn: str):
        pulumi.set(__self__, "arn", arn)

    @property
    @pulumi.getter
    def arn(self) -> str:
        return pulumi.get(self, "arn")


@pulumi.output_type
class SpotFleetTargetGroupsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetGroups":
            suggest = "target_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotFleetTargetGroupsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotFleetTargetGroupsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotFleetTargetGroupsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_groups: Sequence['outputs.SpotFleetTargetGroup']):
        pulumi.set(__self__, "target_groups", target_groups)

    @property
    @pulumi.getter(name="targetGroups")
    def target_groups(self) -> Sequence['outputs.SpotFleetTargetGroup']:
        return pulumi.get(self, "target_groups")


@pulumi.output_type
class SpotFleetTotalLocalStorageGbRequest(dict):
    def __init__(__self__, *,
                 max: Optional[float] = None,
                 min: Optional[float] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        return pulumi.get(self, "min")


@pulumi.output_type
class SpotFleetVCpuCountRangeRequest(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class SseSpecificationProperties(dict):
    """
    The configuration options for customer provided KMS encryption.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customerManagedKeyEnabled":
            suggest = "customer_managed_key_enabled"
        elif key == "kmsKeyArn":
            suggest = "kms_key_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SseSpecificationProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SseSpecificationProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SseSpecificationProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 customer_managed_key_enabled: Optional[bool] = None,
                 kms_key_arn: Optional[str] = None):
        """
        The configuration options for customer provided KMS encryption.
        :param bool customer_managed_key_enabled: Whether to encrypt the policy with the provided key or disable encryption
        :param str kms_key_arn: KMS Key Arn used to encrypt the group policy
        """
        if customer_managed_key_enabled is not None:
            pulumi.set(__self__, "customer_managed_key_enabled", customer_managed_key_enabled)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @property
    @pulumi.getter(name="customerManagedKeyEnabled")
    def customer_managed_key_enabled(self) -> Optional[bool]:
        """
        Whether to encrypt the policy with the provided key or disable encryption
        """
        return pulumi.get(self, "customer_managed_key_enabled")

    @property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[str]:
        """
        KMS Key Arn used to encrypt the group policy
        """
        return pulumi.get(self, "kms_key_arn")


@pulumi.output_type
class SubnetTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class TagSpecification(dict):
    """
    Specifies the tags to apply to a resource when the resource is created for the launch template.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceType":
            suggest = "resource_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TagSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TagSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TagSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_type: Optional[str] = None,
                 tags: Optional[Sequence['outputs.LaunchTemplateTag']] = None):
        """
        Specifies the tags to apply to a resource when the resource is created for the launch template.
        :param str resource_type: The type of resource to tag.
        :param Sequence['LaunchTemplateTag'] tags: The tags for the resource.
        """
        if resource_type is not None:
            pulumi.set(__self__, "resource_type", resource_type)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> Optional[str]:
        """
        The type of resource to tag.
        """
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.LaunchTemplateTag']]:
        """
        The tags for the resource.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class TrafficMirrorFilterRuleTrafficMirrorPortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromPort":
            suggest = "from_port"
        elif key == "toPort":
            suggest = "to_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TrafficMirrorFilterRuleTrafficMirrorPortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TrafficMirrorFilterRuleTrafficMirrorPortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TrafficMirrorFilterRuleTrafficMirrorPortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_port: int,
                 to_port: int):
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "to_port", to_port)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> int:
        return pulumi.get(self, "from_port")

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> int:
        return pulumi.get(self, "to_port")


@pulumi.output_type
class TrafficMirrorFilterTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class TrafficMirrorSessionTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class TrafficMirrorTargetTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class TransitGatewayAttachmentTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class TransitGatewayConnectOptions(dict):
    def __init__(__self__, *,
                 protocol: Optional[str] = None):
        """
        :param str protocol: The tunnel protocol.
        """
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The tunnel protocol.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class TransitGatewayConnectTag(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str key: The key of the tag. Constraints: Tag keys are case-sensitive and accept a maximum of 127 Unicode characters. May not begin with aws:.
        :param str value: The value of the tag. Constraints: Tag values are case-sensitive and accept a maximum of 255 Unicode characters.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key of the tag. Constraints: Tag keys are case-sensitive and accept a maximum of 127 Unicode characters. May not begin with aws:.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag. Constraints: Tag values are case-sensitive and accept a maximum of 255 Unicode characters.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class TransitGatewayMulticastDomainTag(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str key: The key of the tag. Constraints: Tag keys are case-sensitive and accept a maximum of 127 Unicode characters. May not begin with aws:.
        :param str value: The value of the tag. Constraints: Tag values are case-sensitive and accept a maximum of 255 Unicode characters.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key of the tag. Constraints: Tag keys are case-sensitive and accept a maximum of 127 Unicode characters. May not begin with aws:.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag. Constraints: Tag values are case-sensitive and accept a maximum of 255 Unicode characters.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class TransitGatewayPeeringAttachmentPeeringAttachmentStatus(dict):
    def __init__(__self__, *,
                 code: Optional[str] = None,
                 message: Optional[str] = None):
        """
        :param str code: The status code.
        :param str message: The status message, if applicable.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def code(self) -> Optional[str]:
        """
        The status code.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        The status message, if applicable.
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class TransitGatewayPeeringAttachmentTag(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str key: The key of the tag. Constraints: Tag keys are case-sensitive and accept a maximum of 127 Unicode characters. May not begin with aws:.
        :param str value: The value of the tag. Constraints: Tag values are case-sensitive and accept a maximum of 255 Unicode characters.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The key of the tag. Constraints: Tag keys are case-sensitive and accept a maximum of 127 Unicode characters. May not begin with aws:.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the tag. Constraints: Tag values are case-sensitive and accept a maximum of 255 Unicode characters.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class TransitGatewayRouteTableTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The key of the associated tag key-value pair
        :param str value: The value of the associated tag key-value pair
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the associated tag key-value pair
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the associated tag key-value pair
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class TransitGatewayTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class TransitGatewayVpcAttachmentTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class VerifiedAccessEndpointLoadBalancerOptions(dict):
    """
    The load balancer details if creating the AWS Verified Access endpoint as load-balancertype.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loadBalancerArn":
            suggest = "load_balancer_arn"
        elif key == "subnetIds":
            suggest = "subnet_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VerifiedAccessEndpointLoadBalancerOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VerifiedAccessEndpointLoadBalancerOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VerifiedAccessEndpointLoadBalancerOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 load_balancer_arn: Optional[str] = None,
                 port: Optional[int] = None,
                 protocol: Optional[str] = None,
                 subnet_ids: Optional[Sequence[str]] = None):
        """
        The load balancer details if creating the AWS Verified Access endpoint as load-balancertype.
        :param str load_balancer_arn: The ARN of the load balancer.
        :param int port: The IP port number.
        :param str protocol: The IP protocol.
        :param Sequence[str] subnet_ids: The IDs of the subnets.
        """
        if load_balancer_arn is not None:
            pulumi.set(__self__, "load_balancer_arn", load_balancer_arn)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if subnet_ids is not None:
            pulumi.set(__self__, "subnet_ids", subnet_ids)

    @property
    @pulumi.getter(name="loadBalancerArn")
    def load_balancer_arn(self) -> Optional[str]:
        """
        The ARN of the load balancer.
        """
        return pulumi.get(self, "load_balancer_arn")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The IP port number.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The IP protocol.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Optional[Sequence[str]]:
        """
        The IDs of the subnets.
        """
        return pulumi.get(self, "subnet_ids")


@pulumi.output_type
class VerifiedAccessEndpointNetworkInterfaceOptions(dict):
    """
    The options for network-interface type endpoint.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkInterfaceId":
            suggest = "network_interface_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VerifiedAccessEndpointNetworkInterfaceOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VerifiedAccessEndpointNetworkInterfaceOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VerifiedAccessEndpointNetworkInterfaceOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_interface_id: Optional[str] = None,
                 port: Optional[int] = None,
                 protocol: Optional[str] = None):
        """
        The options for network-interface type endpoint.
        :param str network_interface_id: The ID of the network interface.
        :param int port: The IP port number.
        :param str protocol: The IP protocol.
        """
        if network_interface_id is not None:
            pulumi.set(__self__, "network_interface_id", network_interface_id)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter(name="networkInterfaceId")
    def network_interface_id(self) -> Optional[str]:
        """
        The ID of the network interface.
        """
        return pulumi.get(self, "network_interface_id")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The IP port number.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The IP protocol.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class VerifiedAccessEndpointSseSpecification(dict):
    """
    The configuration options for customer provided KMS encryption.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customerManagedKeyEnabled":
            suggest = "customer_managed_key_enabled"
        elif key == "kmsKeyArn":
            suggest = "kms_key_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VerifiedAccessEndpointSseSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VerifiedAccessEndpointSseSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VerifiedAccessEndpointSseSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 customer_managed_key_enabled: Optional[bool] = None,
                 kms_key_arn: Optional[str] = None):
        """
        The configuration options for customer provided KMS encryption.
        :param bool customer_managed_key_enabled: Whether to encrypt the policy with the provided key or disable encryption
        :param str kms_key_arn: KMS Key Arn used to encrypt the group policy
        """
        if customer_managed_key_enabled is not None:
            pulumi.set(__self__, "customer_managed_key_enabled", customer_managed_key_enabled)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @property
    @pulumi.getter(name="customerManagedKeyEnabled")
    def customer_managed_key_enabled(self) -> Optional[bool]:
        """
        Whether to encrypt the policy with the provided key or disable encryption
        """
        return pulumi.get(self, "customer_managed_key_enabled")

    @property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[str]:
        """
        KMS Key Arn used to encrypt the group policy
        """
        return pulumi.get(self, "kms_key_arn")


@pulumi.output_type
class VerifiedAccessEndpointTag(dict):
    """
    A key-value pair to associate with a resource.
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        A key-value pair to associate with a resource.
        :param str key: The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        :param str value: The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class VerifiedAccessGroupSseSpecification(dict):
    """
    The configuration options for customer provided KMS encryption.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customerManagedKeyEnabled":
            suggest = "customer_managed_key_enabled"
        elif key == "kmsKeyArn":
            suggest = "kms_key_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VerifiedAccessGroupSseSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VerifiedAccessGroupSseSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VerifiedAccessGroupSseSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 customer_managed_key_enabled: Optional[bool] = None,
                 kms_key_arn: Optional[str] = None):
        """
        The configuration options for customer provided KMS encryption.
        :param bool customer_managed_key_enabled: Whether to encrypt the policy with the provided key or disable encryption
        :param str kms_key_arn: KMS Key Arn used to encrypt the group policy
        """
        if customer_managed_key_enabled is not None:
            pulumi.set(__self__, "customer_managed_key_enabled", customer_managed_key_enabled)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @property
    @pulumi.getter(name="customerManagedKeyEnabled")
    def customer_managed_key_enabled(self) -> Optional[bool]:
        """
        Whether to encrypt the policy with the provided key or disable encryption
        """
        return pulumi.get(self, "customer_managed_key_enabled")

    @property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[str]:
        """
        KMS Key Arn used to encrypt the group policy
        """
        return pulumi.get(self, "kms_key_arn")


@pulumi.output_type
class VerifiedAccessGroupTag(dict):
    """
    A key-value pair to associate with a resource.
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        A key-value pair to associate with a resource.
        :param str key: The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        :param str value: The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class VerifiedAccessInstanceTag(dict):
    """
    A key-value pair to associate with a resource.
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        A key-value pair to associate with a resource.
        :param str key: The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        :param str value: The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class VerifiedAccessInstanceVerifiedAccessLogs(dict):
    """
    The configuration options for AWS Verified Access instances.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudWatchLogs":
            suggest = "cloud_watch_logs"
        elif key == "includeTrustContext":
            suggest = "include_trust_context"
        elif key == "kinesisDataFirehose":
            suggest = "kinesis_data_firehose"
        elif key == "logVersion":
            suggest = "log_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VerifiedAccessInstanceVerifiedAccessLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VerifiedAccessInstanceVerifiedAccessLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VerifiedAccessInstanceVerifiedAccessLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_watch_logs: Optional['outputs.VerifiedAccessInstanceVerifiedAccessLogsCloudWatchLogsProperties'] = None,
                 include_trust_context: Optional[bool] = None,
                 kinesis_data_firehose: Optional['outputs.VerifiedAccessInstanceVerifiedAccessLogsKinesisDataFirehoseProperties'] = None,
                 log_version: Optional[str] = None,
                 s3: Optional['outputs.VerifiedAccessInstanceVerifiedAccessLogsS3Properties'] = None):
        """
        The configuration options for AWS Verified Access instances.
        :param 'VerifiedAccessInstanceVerifiedAccessLogsCloudWatchLogsProperties' cloud_watch_logs: Sends Verified Access logs to CloudWatch Logs.
        :param bool include_trust_context: Include claims from trust providers in Verified Access logs.
        :param 'VerifiedAccessInstanceVerifiedAccessLogsKinesisDataFirehoseProperties' kinesis_data_firehose: Sends Verified Access logs to Kinesis.
        :param str log_version: Select log version for Verified Access logs.
        :param 'VerifiedAccessInstanceVerifiedAccessLogsS3Properties' s3: Sends Verified Access logs to Amazon S3.
        """
        if cloud_watch_logs is not None:
            pulumi.set(__self__, "cloud_watch_logs", cloud_watch_logs)
        if include_trust_context is not None:
            pulumi.set(__self__, "include_trust_context", include_trust_context)
        if kinesis_data_firehose is not None:
            pulumi.set(__self__, "kinesis_data_firehose", kinesis_data_firehose)
        if log_version is not None:
            pulumi.set(__self__, "log_version", log_version)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @property
    @pulumi.getter(name="cloudWatchLogs")
    def cloud_watch_logs(self) -> Optional['outputs.VerifiedAccessInstanceVerifiedAccessLogsCloudWatchLogsProperties']:
        """
        Sends Verified Access logs to CloudWatch Logs.
        """
        return pulumi.get(self, "cloud_watch_logs")

    @property
    @pulumi.getter(name="includeTrustContext")
    def include_trust_context(self) -> Optional[bool]:
        """
        Include claims from trust providers in Verified Access logs.
        """
        return pulumi.get(self, "include_trust_context")

    @property
    @pulumi.getter(name="kinesisDataFirehose")
    def kinesis_data_firehose(self) -> Optional['outputs.VerifiedAccessInstanceVerifiedAccessLogsKinesisDataFirehoseProperties']:
        """
        Sends Verified Access logs to Kinesis.
        """
        return pulumi.get(self, "kinesis_data_firehose")

    @property
    @pulumi.getter(name="logVersion")
    def log_version(self) -> Optional[str]:
        """
        Select log version for Verified Access logs.
        """
        return pulumi.get(self, "log_version")

    @property
    @pulumi.getter
    def s3(self) -> Optional['outputs.VerifiedAccessInstanceVerifiedAccessLogsS3Properties']:
        """
        Sends Verified Access logs to Amazon S3.
        """
        return pulumi.get(self, "s3")


@pulumi.output_type
class VerifiedAccessInstanceVerifiedAccessLogsCloudWatchLogsProperties(dict):
    """
    Sends Verified Access logs to CloudWatch Logs.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logGroup":
            suggest = "log_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VerifiedAccessInstanceVerifiedAccessLogsCloudWatchLogsProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VerifiedAccessInstanceVerifiedAccessLogsCloudWatchLogsProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VerifiedAccessInstanceVerifiedAccessLogsCloudWatchLogsProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 log_group: Optional[str] = None):
        """
        Sends Verified Access logs to CloudWatch Logs.
        :param bool enabled: Indicates whether logging is enabled.
        :param str log_group: The ID of the CloudWatch Logs log group.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if log_group is not None:
            pulumi.set(__self__, "log_group", log_group)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Indicates whether logging is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="logGroup")
    def log_group(self) -> Optional[str]:
        """
        The ID of the CloudWatch Logs log group.
        """
        return pulumi.get(self, "log_group")


@pulumi.output_type
class VerifiedAccessInstanceVerifiedAccessLogsKinesisDataFirehoseProperties(dict):
    """
    Sends Verified Access logs to Kinesis.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deliveryStream":
            suggest = "delivery_stream"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VerifiedAccessInstanceVerifiedAccessLogsKinesisDataFirehoseProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VerifiedAccessInstanceVerifiedAccessLogsKinesisDataFirehoseProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VerifiedAccessInstanceVerifiedAccessLogsKinesisDataFirehoseProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delivery_stream: Optional[str] = None,
                 enabled: Optional[bool] = None):
        """
        Sends Verified Access logs to Kinesis.
        :param str delivery_stream: The ID of the delivery stream.
        :param bool enabled: Indicates whether logging is enabled.
        """
        if delivery_stream is not None:
            pulumi.set(__self__, "delivery_stream", delivery_stream)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="deliveryStream")
    def delivery_stream(self) -> Optional[str]:
        """
        The ID of the delivery stream.
        """
        return pulumi.get(self, "delivery_stream")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Indicates whether logging is enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class VerifiedAccessInstanceVerifiedAccessLogsS3Properties(dict):
    """
    Sends Verified Access logs to Amazon S3.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "bucketOwner":
            suggest = "bucket_owner"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VerifiedAccessInstanceVerifiedAccessLogsS3Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VerifiedAccessInstanceVerifiedAccessLogsS3Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VerifiedAccessInstanceVerifiedAccessLogsS3Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: Optional[str] = None,
                 bucket_owner: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 prefix: Optional[str] = None):
        """
        Sends Verified Access logs to Amazon S3.
        :param str bucket_name: The bucket name.
        :param str bucket_owner: The ID of the AWS account that owns the Amazon S3 bucket.
        :param bool enabled: Indicates whether logging is enabled.
        :param str prefix: The bucket prefix.
        """
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if bucket_owner is not None:
            pulumi.set(__self__, "bucket_owner", bucket_owner)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        """
        The bucket name.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="bucketOwner")
    def bucket_owner(self) -> Optional[str]:
        """
        The ID of the AWS account that owns the Amazon S3 bucket.
        """
        return pulumi.get(self, "bucket_owner")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Indicates whether logging is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        The bucket prefix.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class VerifiedAccessInstanceVerifiedAccessTrustProvider(dict):
    """
    A Verified Access Trust Provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceTrustProviderType":
            suggest = "device_trust_provider_type"
        elif key == "trustProviderType":
            suggest = "trust_provider_type"
        elif key == "userTrustProviderType":
            suggest = "user_trust_provider_type"
        elif key == "verifiedAccessTrustProviderId":
            suggest = "verified_access_trust_provider_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VerifiedAccessInstanceVerifiedAccessTrustProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VerifiedAccessInstanceVerifiedAccessTrustProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VerifiedAccessInstanceVerifiedAccessTrustProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 device_trust_provider_type: Optional[str] = None,
                 trust_provider_type: Optional[str] = None,
                 user_trust_provider_type: Optional[str] = None,
                 verified_access_trust_provider_id: Optional[str] = None):
        """
        A Verified Access Trust Provider.
        :param str description: The description of trust provider.
        :param str device_trust_provider_type: The type of device-based trust provider.
        :param str trust_provider_type: The type of trust provider (user- or device-based).
        :param str user_trust_provider_type: The type of user-based trust provider.
        :param str verified_access_trust_provider_id: The ID of the trust provider.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if device_trust_provider_type is not None:
            pulumi.set(__self__, "device_trust_provider_type", device_trust_provider_type)
        if trust_provider_type is not None:
            pulumi.set(__self__, "trust_provider_type", trust_provider_type)
        if user_trust_provider_type is not None:
            pulumi.set(__self__, "user_trust_provider_type", user_trust_provider_type)
        if verified_access_trust_provider_id is not None:
            pulumi.set(__self__, "verified_access_trust_provider_id", verified_access_trust_provider_id)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of trust provider.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="deviceTrustProviderType")
    def device_trust_provider_type(self) -> Optional[str]:
        """
        The type of device-based trust provider.
        """
        return pulumi.get(self, "device_trust_provider_type")

    @property
    @pulumi.getter(name="trustProviderType")
    def trust_provider_type(self) -> Optional[str]:
        """
        The type of trust provider (user- or device-based).
        """
        return pulumi.get(self, "trust_provider_type")

    @property
    @pulumi.getter(name="userTrustProviderType")
    def user_trust_provider_type(self) -> Optional[str]:
        """
        The type of user-based trust provider.
        """
        return pulumi.get(self, "user_trust_provider_type")

    @property
    @pulumi.getter(name="verifiedAccessTrustProviderId")
    def verified_access_trust_provider_id(self) -> Optional[str]:
        """
        The ID of the trust provider.
        """
        return pulumi.get(self, "verified_access_trust_provider_id")


@pulumi.output_type
class VerifiedAccessTrustProviderDeviceOptions(dict):
    """
    The options for device identity based trust providers.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VerifiedAccessTrustProviderDeviceOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VerifiedAccessTrustProviderDeviceOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VerifiedAccessTrustProviderDeviceOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tenant_id: Optional[str] = None):
        """
        The options for device identity based trust providers.
        :param str tenant_id: The ID of the tenant application with the device-identity provider.
        """
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The ID of the tenant application with the device-identity provider.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class VerifiedAccessTrustProviderOidcOptions(dict):
    """
    The OpenID Connect details for an oidc -type, user-identity based trust provider.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authorizationEndpoint":
            suggest = "authorization_endpoint"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "tokenEndpoint":
            suggest = "token_endpoint"
        elif key == "userInfoEndpoint":
            suggest = "user_info_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VerifiedAccessTrustProviderOidcOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VerifiedAccessTrustProviderOidcOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VerifiedAccessTrustProviderOidcOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authorization_endpoint: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 issuer: Optional[str] = None,
                 scope: Optional[str] = None,
                 token_endpoint: Optional[str] = None,
                 user_info_endpoint: Optional[str] = None):
        """
        The OpenID Connect details for an oidc -type, user-identity based trust provider.
        :param str authorization_endpoint: The OIDC authorization endpoint.
        :param str client_id: The client identifier.
        :param str client_secret: The client secret.
        :param str issuer: The OIDC issuer.
        :param str scope: OpenID Connect (OIDC) scopes are used by an application during authentication to authorize access to details of a user. Each scope returns a specific set of user attributes.
        :param str token_endpoint: The OIDC token endpoint.
        :param str user_info_endpoint: The OIDC user info endpoint.
        """
        if authorization_endpoint is not None:
            pulumi.set(__self__, "authorization_endpoint", authorization_endpoint)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)
        if user_info_endpoint is not None:
            pulumi.set(__self__, "user_info_endpoint", user_info_endpoint)

    @property
    @pulumi.getter(name="authorizationEndpoint")
    def authorization_endpoint(self) -> Optional[str]:
        """
        The OIDC authorization endpoint.
        """
        return pulumi.get(self, "authorization_endpoint")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        The client identifier.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        The client secret.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter
    def issuer(self) -> Optional[str]:
        """
        The OIDC issuer.
        """
        return pulumi.get(self, "issuer")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        OpenID Connect (OIDC) scopes are used by an application during authentication to authorize access to details of a user. Each scope returns a specific set of user attributes.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[str]:
        """
        The OIDC token endpoint.
        """
        return pulumi.get(self, "token_endpoint")

    @property
    @pulumi.getter(name="userInfoEndpoint")
    def user_info_endpoint(self) -> Optional[str]:
        """
        The OIDC user info endpoint.
        """
        return pulumi.get(self, "user_info_endpoint")


@pulumi.output_type
class VerifiedAccessTrustProviderTag(dict):
    """
    A key-value pair to associate with a resource.
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        A key-value pair to associate with a resource.
        :param str key: The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        :param str value: The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class VolumeTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        :param str value: The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class VpcPeeringConnectionTag(dict):
    """
    A key-value pair to associate with a resource.
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        A key-value pair to associate with a resource.
        :param str key: The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        :param str value: The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class VpcTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class VpnConnectionTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class VpnConnectionVpnTunnelOptionsSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preSharedKey":
            suggest = "pre_shared_key"
        elif key == "tunnelInsideCidr":
            suggest = "tunnel_inside_cidr"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpnConnectionVpnTunnelOptionsSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpnConnectionVpnTunnelOptionsSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpnConnectionVpnTunnelOptionsSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pre_shared_key: Optional[str] = None,
                 tunnel_inside_cidr: Optional[str] = None):
        if pre_shared_key is not None:
            pulumi.set(__self__, "pre_shared_key", pre_shared_key)
        if tunnel_inside_cidr is not None:
            pulumi.set(__self__, "tunnel_inside_cidr", tunnel_inside_cidr)

    @property
    @pulumi.getter(name="preSharedKey")
    def pre_shared_key(self) -> Optional[str]:
        return pulumi.get(self, "pre_shared_key")

    @property
    @pulumi.getter(name="tunnelInsideCidr")
    def tunnel_inside_cidr(self) -> Optional[str]:
        return pulumi.get(self, "tunnel_inside_cidr")


@pulumi.output_type
class VpnGatewayTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


