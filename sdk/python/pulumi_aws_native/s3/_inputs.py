# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from ._enums import *

__all__ = [
    'AccessPointPublicAccessBlockConfigurationArgs',
    'AccessPointVpcConfigurationArgs',
    'BucketAbortIncompleteMultipartUploadArgs',
    'BucketAccelerateConfigurationArgs',
    'BucketAccessControlTranslationArgs',
    'BucketAnalyticsConfigurationArgs',
    'BucketCorsConfigurationArgs',
    'BucketCorsRuleArgs',
    'BucketDataExportArgs',
    'BucketDefaultRetentionArgs',
    'BucketDeleteMarkerReplicationArgs',
    'BucketDestinationArgs',
    'BucketEncryptionConfigurationArgs',
    'BucketEncryptionArgs',
    'BucketEventBridgeConfigurationArgs',
    'BucketFilterRuleArgs',
    'BucketIntelligentTieringConfigurationArgs',
    'BucketInventoryConfigurationArgs',
    'BucketLambdaConfigurationArgs',
    'BucketLifecycleConfigurationArgs',
    'BucketLoggingConfigurationArgs',
    'BucketMetricsConfigurationArgs',
    'BucketMetricsArgs',
    'BucketNoncurrentVersionExpirationArgs',
    'BucketNoncurrentVersionTransitionArgs',
    'BucketNotificationConfigurationArgs',
    'BucketNotificationFilterArgs',
    'BucketObjectLockConfigurationArgs',
    'BucketObjectLockRuleArgs',
    'BucketOwnershipControlsRuleArgs',
    'BucketOwnershipControlsArgs',
    'BucketPublicAccessBlockConfigurationArgs',
    'BucketQueueConfigurationArgs',
    'BucketRedirectAllRequestsToArgs',
    'BucketRedirectRuleArgs',
    'BucketReplicaModificationsArgs',
    'BucketReplicationConfigurationArgs',
    'BucketReplicationDestinationArgs',
    'BucketReplicationRuleAndOperatorArgs',
    'BucketReplicationRuleFilterArgs',
    'BucketReplicationRuleArgs',
    'BucketReplicationTimeValueArgs',
    'BucketReplicationTimeArgs',
    'BucketRoutingRuleConditionArgs',
    'BucketRoutingRuleArgs',
    'BucketRuleArgs',
    'BucketS3KeyFilterArgs',
    'BucketServerSideEncryptionByDefaultArgs',
    'BucketServerSideEncryptionRuleArgs',
    'BucketSourceSelectionCriteriaArgs',
    'BucketSseKmsEncryptedObjectsArgs',
    'BucketStorageClassAnalysisArgs',
    'BucketTagFilterArgs',
    'BucketTagArgs',
    'BucketTieringArgs',
    'BucketTopicConfigurationArgs',
    'BucketTransitionArgs',
    'BucketVersioningConfigurationArgs',
    'BucketWebsiteConfigurationArgs',
    'MultiRegionAccessPointPublicAccessBlockConfigurationArgs',
    'MultiRegionAccessPointRegionArgs',
    'StorageLensAccountLevelArgs',
    'StorageLensActivityMetricsArgs',
    'StorageLensAdvancedCostOptimizationMetricsArgs',
    'StorageLensAdvancedDataProtectionMetricsArgs',
    'StorageLensAwsOrgArgs',
    'StorageLensBucketLevelArgs',
    'StorageLensBucketsAndRegionsArgs',
    'StorageLensCloudWatchMetricsArgs',
    'StorageLensConfigurationArgs',
    'StorageLensDataExportArgs',
    'StorageLensDetailedStatusCodesMetricsArgs',
    'StorageLensEncryptionArgs',
    'StorageLensPrefixLevelStorageMetricsArgs',
    'StorageLensPrefixLevelArgs',
    'StorageLensS3BucketDestinationArgs',
    'StorageLensSelectionCriteriaArgs',
    'StorageLensTagArgs',
]

@pulumi.input_type
class AccessPointPublicAccessBlockConfigurationArgs:
    def __init__(__self__, *,
                 block_public_acls: Optional[pulumi.Input[bool]] = None,
                 block_public_policy: Optional[pulumi.Input[bool]] = None,
                 ignore_public_acls: Optional[pulumi.Input[bool]] = None,
                 restrict_public_buckets: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] block_public_acls: Specifies whether Amazon S3 should block public access control lists (ACLs) for buckets in this account. Setting this element to TRUE causes the following behavior:
               - PUT Bucket acl and PUT Object acl calls fail if the specified ACL is public.
                - PUT Object calls fail if the request includes a public ACL.
               . - PUT Bucket calls fail if the request includes a public ACL.
               Enabling this setting doesn't affect existing policies or ACLs.
        :param pulumi.Input[bool] block_public_policy: Specifies whether Amazon S3 should block public bucket policies for buckets in this account. Setting this element to TRUE causes Amazon S3 to reject calls to PUT Bucket policy if the specified bucket policy allows public access. Enabling this setting doesn't affect existing bucket policies.
        :param pulumi.Input[bool] ignore_public_acls: Specifies whether Amazon S3 should ignore public ACLs for buckets in this account. Setting this element to TRUE causes Amazon S3 to ignore all public ACLs on buckets in this account and any objects that they contain. Enabling this setting doesn't affect the persistence of any existing ACLs and doesn't prevent new public ACLs from being set.
        :param pulumi.Input[bool] restrict_public_buckets: Specifies whether Amazon S3 should restrict public bucket policies for this bucket. Setting this element to TRUE restricts access to this bucket to only AWS services and authorized users within this account if the bucket has a public policy.
               Enabling this setting doesn't affect previously stored bucket policies, except that public and cross-account access within any public bucket policy, including non-public delegation to specific accounts, is blocked.
        """
        AccessPointPublicAccessBlockConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            block_public_acls=block_public_acls,
            block_public_policy=block_public_policy,
            ignore_public_acls=ignore_public_acls,
            restrict_public_buckets=restrict_public_buckets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             block_public_acls: Optional[pulumi.Input[bool]] = None,
             block_public_policy: Optional[pulumi.Input[bool]] = None,
             ignore_public_acls: Optional[pulumi.Input[bool]] = None,
             restrict_public_buckets: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if block_public_acls is not None:
            _setter("block_public_acls", block_public_acls)
        if block_public_policy is not None:
            _setter("block_public_policy", block_public_policy)
        if ignore_public_acls is not None:
            _setter("ignore_public_acls", ignore_public_acls)
        if restrict_public_buckets is not None:
            _setter("restrict_public_buckets", restrict_public_buckets)

    @property
    @pulumi.getter(name="blockPublicAcls")
    def block_public_acls(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether Amazon S3 should block public access control lists (ACLs) for buckets in this account. Setting this element to TRUE causes the following behavior:
        - PUT Bucket acl and PUT Object acl calls fail if the specified ACL is public.
         - PUT Object calls fail if the request includes a public ACL.
        . - PUT Bucket calls fail if the request includes a public ACL.
        Enabling this setting doesn't affect existing policies or ACLs.
        """
        return pulumi.get(self, "block_public_acls")

    @block_public_acls.setter
    def block_public_acls(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "block_public_acls", value)

    @property
    @pulumi.getter(name="blockPublicPolicy")
    def block_public_policy(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether Amazon S3 should block public bucket policies for buckets in this account. Setting this element to TRUE causes Amazon S3 to reject calls to PUT Bucket policy if the specified bucket policy allows public access. Enabling this setting doesn't affect existing bucket policies.
        """
        return pulumi.get(self, "block_public_policy")

    @block_public_policy.setter
    def block_public_policy(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "block_public_policy", value)

    @property
    @pulumi.getter(name="ignorePublicAcls")
    def ignore_public_acls(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether Amazon S3 should ignore public ACLs for buckets in this account. Setting this element to TRUE causes Amazon S3 to ignore all public ACLs on buckets in this account and any objects that they contain. Enabling this setting doesn't affect the persistence of any existing ACLs and doesn't prevent new public ACLs from being set.
        """
        return pulumi.get(self, "ignore_public_acls")

    @ignore_public_acls.setter
    def ignore_public_acls(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_public_acls", value)

    @property
    @pulumi.getter(name="restrictPublicBuckets")
    def restrict_public_buckets(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether Amazon S3 should restrict public bucket policies for this bucket. Setting this element to TRUE restricts access to this bucket to only AWS services and authorized users within this account if the bucket has a public policy.
        Enabling this setting doesn't affect previously stored bucket policies, except that public and cross-account access within any public bucket policy, including non-public delegation to specific accounts, is blocked.
        """
        return pulumi.get(self, "restrict_public_buckets")

    @restrict_public_buckets.setter
    def restrict_public_buckets(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "restrict_public_buckets", value)


@pulumi.input_type
class AccessPointVpcConfigurationArgs:
    def __init__(__self__, *,
                 vpc_id: Optional[pulumi.Input[str]] = None):
        """
        The Virtual Private Cloud (VPC) configuration for a bucket access point.
        :param pulumi.Input[str] vpc_id: If this field is specified, this access point will only allow connections from the specified VPC ID.
        """
        AccessPointVpcConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            vpc_id=vpc_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             vpc_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if vpc_id is not None:
            _setter("vpc_id", vpc_id)

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[pulumi.Input[str]]:
        """
        If this field is specified, this access point will only allow connections from the specified VPC ID.
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_id", value)


@pulumi.input_type
class BucketAbortIncompleteMultipartUploadArgs:
    def __init__(__self__, *,
                 days_after_initiation: pulumi.Input[int]):
        """
        Specifies the days since the initiation of an incomplete multipart upload that Amazon S3 will wait before permanently removing all parts of the upload.
        :param pulumi.Input[int] days_after_initiation: Specifies the number of days after which Amazon S3 aborts an incomplete multipart upload.
        """
        BucketAbortIncompleteMultipartUploadArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            days_after_initiation=days_after_initiation,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             days_after_initiation: pulumi.Input[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("days_after_initiation", days_after_initiation)

    @property
    @pulumi.getter(name="daysAfterInitiation")
    def days_after_initiation(self) -> pulumi.Input[int]:
        """
        Specifies the number of days after which Amazon S3 aborts an incomplete multipart upload.
        """
        return pulumi.get(self, "days_after_initiation")

    @days_after_initiation.setter
    def days_after_initiation(self, value: pulumi.Input[int]):
        pulumi.set(self, "days_after_initiation", value)


@pulumi.input_type
class BucketAccelerateConfigurationArgs:
    def __init__(__self__, *,
                 acceleration_status: pulumi.Input['BucketAccelerateConfigurationAccelerationStatus']):
        """
        :param pulumi.Input['BucketAccelerateConfigurationAccelerationStatus'] acceleration_status: Configures the transfer acceleration state for an Amazon S3 bucket.
        """
        BucketAccelerateConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            acceleration_status=acceleration_status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             acceleration_status: pulumi.Input['BucketAccelerateConfigurationAccelerationStatus'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("acceleration_status", acceleration_status)

    @property
    @pulumi.getter(name="accelerationStatus")
    def acceleration_status(self) -> pulumi.Input['BucketAccelerateConfigurationAccelerationStatus']:
        """
        Configures the transfer acceleration state for an Amazon S3 bucket.
        """
        return pulumi.get(self, "acceleration_status")

    @acceleration_status.setter
    def acceleration_status(self, value: pulumi.Input['BucketAccelerateConfigurationAccelerationStatus']):
        pulumi.set(self, "acceleration_status", value)


@pulumi.input_type
class BucketAccessControlTranslationArgs:
    def __init__(__self__, *,
                 owner: pulumi.Input[str]):
        """
        Specify this only in a cross-account scenario (where source and destination bucket owners are not the same), and you want to change replica ownership to the AWS account that owns the destination bucket. If this is not specified in the replication configuration, the replicas are owned by same AWS account that owns the source object.
        """
        BucketAccessControlTranslationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            owner=owner,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             owner: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("owner", owner)

    @property
    @pulumi.getter
    def owner(self) -> pulumi.Input[str]:
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: pulumi.Input[str]):
        pulumi.set(self, "owner", value)


@pulumi.input_type
class BucketAnalyticsConfigurationArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 storage_class_analysis: pulumi.Input['BucketStorageClassAnalysisArgs'],
                 prefix: Optional[pulumi.Input[str]] = None,
                 tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input['BucketTagFilterArgs']]]] = None):
        """
        Specifies the configuration and any analyses for the analytics filter of an Amazon S3 bucket.
        :param pulumi.Input[str] id: The ID that identifies the analytics configuration.
        :param pulumi.Input[str] prefix: The prefix that an object must have to be included in the analytics results.
        """
        BucketAnalyticsConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            storage_class_analysis=storage_class_analysis,
            prefix=prefix,
            tag_filters=tag_filters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: pulumi.Input[str],
             storage_class_analysis: pulumi.Input['BucketStorageClassAnalysisArgs'],
             prefix: Optional[pulumi.Input[str]] = None,
             tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input['BucketTagFilterArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        _setter("storage_class_analysis", storage_class_analysis)
        if prefix is not None:
            _setter("prefix", prefix)
        if tag_filters is not None:
            _setter("tag_filters", tag_filters)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID that identifies the analytics configuration.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="storageClassAnalysis")
    def storage_class_analysis(self) -> pulumi.Input['BucketStorageClassAnalysisArgs']:
        return pulumi.get(self, "storage_class_analysis")

    @storage_class_analysis.setter
    def storage_class_analysis(self, value: pulumi.Input['BucketStorageClassAnalysisArgs']):
        pulumi.set(self, "storage_class_analysis", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The prefix that an object must have to be included in the analytics results.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketTagFilterArgs']]]]:
        return pulumi.get(self, "tag_filters")

    @tag_filters.setter
    def tag_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketTagFilterArgs']]]]):
        pulumi.set(self, "tag_filters", value)


@pulumi.input_type
class BucketCorsConfigurationArgs:
    def __init__(__self__, *,
                 cors_rules: pulumi.Input[Sequence[pulumi.Input['BucketCorsRuleArgs']]]):
        BucketCorsConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cors_rules=cors_rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cors_rules: pulumi.Input[Sequence[pulumi.Input['BucketCorsRuleArgs']]],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cors_rules", cors_rules)

    @property
    @pulumi.getter(name="corsRules")
    def cors_rules(self) -> pulumi.Input[Sequence[pulumi.Input['BucketCorsRuleArgs']]]:
        return pulumi.get(self, "cors_rules")

    @cors_rules.setter
    def cors_rules(self, value: pulumi.Input[Sequence[pulumi.Input['BucketCorsRuleArgs']]]):
        pulumi.set(self, "cors_rules", value)


@pulumi.input_type
class BucketCorsRuleArgs:
    def __init__(__self__, *,
                 allowed_methods: pulumi.Input[Sequence[pulumi.Input['BucketCorsRuleAllowedMethodsItem']]],
                 allowed_origins: pulumi.Input[Sequence[pulumi.Input[str]]],
                 allowed_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 exposed_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 max_age: Optional[pulumi.Input[int]] = None):
        """
        A set of origins and methods (cross-origin access that you want to allow). You can add up to 100 rules to the configuration.
        :param pulumi.Input[Sequence[pulumi.Input['BucketCorsRuleAllowedMethodsItem']]] allowed_methods: An HTTP method that you allow the origin to execute.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_origins: One or more origins you want customers to be able to access the bucket from.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_headers: Headers that are specified in the Access-Control-Request-Headers header.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exposed_headers: One or more headers in the response that you want customers to be able to access from their applications (for example, from a JavaScript XMLHttpRequest object).
        :param pulumi.Input[str] id: A unique identifier for this rule.
        :param pulumi.Input[int] max_age: The time in seconds that your browser is to cache the preflight response for the specified resource.
        """
        BucketCorsRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allowed_methods=allowed_methods,
            allowed_origins=allowed_origins,
            allowed_headers=allowed_headers,
            exposed_headers=exposed_headers,
            id=id,
            max_age=max_age,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allowed_methods: pulumi.Input[Sequence[pulumi.Input['BucketCorsRuleAllowedMethodsItem']]],
             allowed_origins: pulumi.Input[Sequence[pulumi.Input[str]]],
             allowed_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             exposed_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             id: Optional[pulumi.Input[str]] = None,
             max_age: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("allowed_methods", allowed_methods)
        _setter("allowed_origins", allowed_origins)
        if allowed_headers is not None:
            _setter("allowed_headers", allowed_headers)
        if exposed_headers is not None:
            _setter("exposed_headers", exposed_headers)
        if id is not None:
            _setter("id", id)
        if max_age is not None:
            _setter("max_age", max_age)

    @property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> pulumi.Input[Sequence[pulumi.Input['BucketCorsRuleAllowedMethodsItem']]]:
        """
        An HTTP method that you allow the origin to execute.
        """
        return pulumi.get(self, "allowed_methods")

    @allowed_methods.setter
    def allowed_methods(self, value: pulumi.Input[Sequence[pulumi.Input['BucketCorsRuleAllowedMethodsItem']]]):
        pulumi.set(self, "allowed_methods", value)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        One or more origins you want customers to be able to access the bucket from.
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "allowed_origins", value)

    @property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Headers that are specified in the Access-Control-Request-Headers header.
        """
        return pulumi.get(self, "allowed_headers")

    @allowed_headers.setter
    def allowed_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_headers", value)

    @property
    @pulumi.getter(name="exposedHeaders")
    def exposed_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        One or more headers in the response that you want customers to be able to access from their applications (for example, from a JavaScript XMLHttpRequest object).
        """
        return pulumi.get(self, "exposed_headers")

    @exposed_headers.setter
    def exposed_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exposed_headers", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        A unique identifier for this rule.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[int]]:
        """
        The time in seconds that your browser is to cache the preflight response for the specified resource.
        """
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_age", value)


@pulumi.input_type
class BucketDataExportArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input['BucketDestinationArgs'],
                 output_schema_version: pulumi.Input[str]):
        """
        Specifies how data related to the storage class analysis for an Amazon S3 bucket should be exported.
        :param pulumi.Input[str] output_schema_version: The version of the output schema to use when exporting data.
        """
        BucketDataExportArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
            output_schema_version=output_schema_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: pulumi.Input['BucketDestinationArgs'],
             output_schema_version: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("destination", destination)
        _setter("output_schema_version", output_schema_version)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input['BucketDestinationArgs']:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input['BucketDestinationArgs']):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="outputSchemaVersion")
    def output_schema_version(self) -> pulumi.Input[str]:
        """
        The version of the output schema to use when exporting data.
        """
        return pulumi.get(self, "output_schema_version")

    @output_schema_version.setter
    def output_schema_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "output_schema_version", value)


@pulumi.input_type
class BucketDefaultRetentionArgs:
    def __init__(__self__, *,
                 days: Optional[pulumi.Input[int]] = None,
                 mode: Optional[pulumi.Input['BucketDefaultRetentionMode']] = None,
                 years: Optional[pulumi.Input[int]] = None):
        """
        The default retention period that you want to apply to new objects placed in the specified bucket.
        """
        BucketDefaultRetentionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            days=days,
            mode=mode,
            years=years,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             days: Optional[pulumi.Input[int]] = None,
             mode: Optional[pulumi.Input['BucketDefaultRetentionMode']] = None,
             years: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if days is not None:
            _setter("days", days)
        if mode is not None:
            _setter("mode", mode)
        if years is not None:
            _setter("years", years)

    @property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "days", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input['BucketDefaultRetentionMode']]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input['BucketDefaultRetentionMode']]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def years(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "years")

    @years.setter
    def years(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "years", value)


@pulumi.input_type
class BucketDeleteMarkerReplicationArgs:
    def __init__(__self__, *,
                 status: Optional[pulumi.Input['BucketDeleteMarkerReplicationStatus']] = None):
        BucketDeleteMarkerReplicationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             status: Optional[pulumi.Input['BucketDeleteMarkerReplicationStatus']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input['BucketDeleteMarkerReplicationStatus']]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input['BucketDeleteMarkerReplicationStatus']]):
        pulumi.set(self, "status", value)


@pulumi.input_type
class BucketDestinationArgs:
    def __init__(__self__, *,
                 bucket_arn: pulumi.Input[str],
                 format: pulumi.Input['BucketDestinationFormat'],
                 bucket_account_id: Optional[pulumi.Input[str]] = None,
                 prefix: Optional[pulumi.Input[str]] = None):
        """
        Specifies information about where to publish analysis or configuration results for an Amazon S3 bucket and S3 Replication Time Control (S3 RTC).
        :param pulumi.Input[str] bucket_arn: The Amazon Resource Name (ARN) of the bucket to which data is exported.
        :param pulumi.Input['BucketDestinationFormat'] format: Specifies the file format used when exporting data to Amazon S3.
        :param pulumi.Input[str] bucket_account_id: The account ID that owns the destination S3 bucket. 
        :param pulumi.Input[str] prefix: The prefix to use when exporting data. The prefix is prepended to all results.
        """
        BucketDestinationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket_arn=bucket_arn,
            format=format,
            bucket_account_id=bucket_account_id,
            prefix=prefix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket_arn: pulumi.Input[str],
             format: pulumi.Input['BucketDestinationFormat'],
             bucket_account_id: Optional[pulumi.Input[str]] = None,
             prefix: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("bucket_arn", bucket_arn)
        _setter("format", format)
        if bucket_account_id is not None:
            _setter("bucket_account_id", bucket_account_id)
        if prefix is not None:
            _setter("prefix", prefix)

    @property
    @pulumi.getter(name="bucketArn")
    def bucket_arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the bucket to which data is exported.
        """
        return pulumi.get(self, "bucket_arn")

    @bucket_arn.setter
    def bucket_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket_arn", value)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input['BucketDestinationFormat']:
        """
        Specifies the file format used when exporting data to Amazon S3.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input['BucketDestinationFormat']):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter(name="bucketAccountId")
    def bucket_account_id(self) -> Optional[pulumi.Input[str]]:
        """
        The account ID that owns the destination S3 bucket. 
        """
        return pulumi.get(self, "bucket_account_id")

    @bucket_account_id.setter
    def bucket_account_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket_account_id", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The prefix to use when exporting data. The prefix is prepended to all results.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)


@pulumi.input_type
class BucketEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 replica_kms_key_id: pulumi.Input[str]):
        """
        Specifies encryption-related information for an Amazon S3 bucket that is a destination for replicated objects.
        :param pulumi.Input[str] replica_kms_key_id: Specifies the ID (Key ARN or Alias ARN) of the customer managed customer master key (CMK) stored in AWS Key Management Service (KMS) for the destination bucket.
        """
        BucketEncryptionConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            replica_kms_key_id=replica_kms_key_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             replica_kms_key_id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("replica_kms_key_id", replica_kms_key_id)

    @property
    @pulumi.getter(name="replicaKmsKeyId")
    def replica_kms_key_id(self) -> pulumi.Input[str]:
        """
        Specifies the ID (Key ARN or Alias ARN) of the customer managed customer master key (CMK) stored in AWS Key Management Service (KMS) for the destination bucket.
        """
        return pulumi.get(self, "replica_kms_key_id")

    @replica_kms_key_id.setter
    def replica_kms_key_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "replica_kms_key_id", value)


@pulumi.input_type
class BucketEncryptionArgs:
    def __init__(__self__, *,
                 server_side_encryption_configuration: pulumi.Input[Sequence[pulumi.Input['BucketServerSideEncryptionRuleArgs']]]):
        """
        Specifies default encryption for a bucket using server-side encryption with either Amazon S3-managed keys (SSE-S3) or AWS KMS-managed keys (SSE-KMS).
        :param pulumi.Input[Sequence[pulumi.Input['BucketServerSideEncryptionRuleArgs']]] server_side_encryption_configuration: Specifies the default server-side-encryption configuration.
        """
        BucketEncryptionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            server_side_encryption_configuration=server_side_encryption_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             server_side_encryption_configuration: pulumi.Input[Sequence[pulumi.Input['BucketServerSideEncryptionRuleArgs']]],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("server_side_encryption_configuration", server_side_encryption_configuration)

    @property
    @pulumi.getter(name="serverSideEncryptionConfiguration")
    def server_side_encryption_configuration(self) -> pulumi.Input[Sequence[pulumi.Input['BucketServerSideEncryptionRuleArgs']]]:
        """
        Specifies the default server-side-encryption configuration.
        """
        return pulumi.get(self, "server_side_encryption_configuration")

    @server_side_encryption_configuration.setter
    def server_side_encryption_configuration(self, value: pulumi.Input[Sequence[pulumi.Input['BucketServerSideEncryptionRuleArgs']]]):
        pulumi.set(self, "server_side_encryption_configuration", value)


@pulumi.input_type
class BucketEventBridgeConfigurationArgs:
    def __init__(__self__, *,
                 event_bridge_enabled: pulumi.Input[bool]):
        """
        Describes the Amazon EventBridge notification configuration for an Amazon S3 bucket.
        :param pulumi.Input[bool] event_bridge_enabled: Specifies whether to send notifications to Amazon EventBridge when events occur in an Amazon S3 bucket.
        """
        BucketEventBridgeConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            event_bridge_enabled=event_bridge_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             event_bridge_enabled: pulumi.Input[bool],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("event_bridge_enabled", event_bridge_enabled)

    @property
    @pulumi.getter(name="eventBridgeEnabled")
    def event_bridge_enabled(self) -> pulumi.Input[bool]:
        """
        Specifies whether to send notifications to Amazon EventBridge when events occur in an Amazon S3 bucket.
        """
        return pulumi.get(self, "event_bridge_enabled")

    @event_bridge_enabled.setter
    def event_bridge_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "event_bridge_enabled", value)


@pulumi.input_type
class BucketFilterRuleArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        Specifies the Amazon S3 object key name to filter on and whether to filter on the suffix or prefix of the key name.
        """
        BucketFilterRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             value: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class BucketIntelligentTieringConfigurationArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 status: pulumi.Input['BucketIntelligentTieringConfigurationStatus'],
                 tierings: pulumi.Input[Sequence[pulumi.Input['BucketTieringArgs']]],
                 prefix: Optional[pulumi.Input[str]] = None,
                 tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input['BucketTagFilterArgs']]]] = None):
        """
        :param pulumi.Input[str] id: The ID used to identify the S3 Intelligent-Tiering configuration.
        :param pulumi.Input['BucketIntelligentTieringConfigurationStatus'] status: Specifies the status of the configuration.
        :param pulumi.Input[Sequence[pulumi.Input['BucketTieringArgs']]] tierings: Specifies a list of S3 Intelligent-Tiering storage class tiers in the configuration. At least one tier must be defined in the list. At most, you can specify two tiers in the list, one for each available AccessTier: ARCHIVE_ACCESS and DEEP_ARCHIVE_ACCESS.
        :param pulumi.Input[str] prefix: An object key name prefix that identifies the subset of objects to which the rule applies.
        :param pulumi.Input[Sequence[pulumi.Input['BucketTagFilterArgs']]] tag_filters: A container for a key-value pair.
        """
        BucketIntelligentTieringConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            status=status,
            tierings=tierings,
            prefix=prefix,
            tag_filters=tag_filters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: pulumi.Input[str],
             status: pulumi.Input['BucketIntelligentTieringConfigurationStatus'],
             tierings: pulumi.Input[Sequence[pulumi.Input['BucketTieringArgs']]],
             prefix: Optional[pulumi.Input[str]] = None,
             tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input['BucketTagFilterArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        _setter("status", status)
        _setter("tierings", tierings)
        if prefix is not None:
            _setter("prefix", prefix)
        if tag_filters is not None:
            _setter("tag_filters", tag_filters)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID used to identify the S3 Intelligent-Tiering configuration.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input['BucketIntelligentTieringConfigurationStatus']:
        """
        Specifies the status of the configuration.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input['BucketIntelligentTieringConfigurationStatus']):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def tierings(self) -> pulumi.Input[Sequence[pulumi.Input['BucketTieringArgs']]]:
        """
        Specifies a list of S3 Intelligent-Tiering storage class tiers in the configuration. At least one tier must be defined in the list. At most, you can specify two tiers in the list, one for each available AccessTier: ARCHIVE_ACCESS and DEEP_ARCHIVE_ACCESS.
        """
        return pulumi.get(self, "tierings")

    @tierings.setter
    def tierings(self, value: pulumi.Input[Sequence[pulumi.Input['BucketTieringArgs']]]):
        pulumi.set(self, "tierings", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        An object key name prefix that identifies the subset of objects to which the rule applies.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketTagFilterArgs']]]]:
        """
        A container for a key-value pair.
        """
        return pulumi.get(self, "tag_filters")

    @tag_filters.setter
    def tag_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketTagFilterArgs']]]]):
        pulumi.set(self, "tag_filters", value)


@pulumi.input_type
class BucketInventoryConfigurationArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input['BucketDestinationArgs'],
                 enabled: pulumi.Input[bool],
                 id: pulumi.Input[str],
                 included_object_versions: pulumi.Input['BucketInventoryConfigurationIncludedObjectVersions'],
                 schedule_frequency: pulumi.Input['BucketInventoryConfigurationScheduleFrequency'],
                 optional_fields: Optional[pulumi.Input[Sequence[pulumi.Input['BucketInventoryConfigurationOptionalFieldsItem']]]] = None,
                 prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Specifies whether the inventory is enabled or disabled.
        :param pulumi.Input[str] id: The ID used to identify the inventory configuration.
        :param pulumi.Input['BucketInventoryConfigurationIncludedObjectVersions'] included_object_versions: Object versions to include in the inventory list.
        :param pulumi.Input['BucketInventoryConfigurationScheduleFrequency'] schedule_frequency: Specifies the schedule for generating inventory results.
        :param pulumi.Input[Sequence[pulumi.Input['BucketInventoryConfigurationOptionalFieldsItem']]] optional_fields: Contains the optional fields that are included in the inventory results.
        :param pulumi.Input[str] prefix: The prefix that is prepended to all inventory results.
        """
        BucketInventoryConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
            enabled=enabled,
            id=id,
            included_object_versions=included_object_versions,
            schedule_frequency=schedule_frequency,
            optional_fields=optional_fields,
            prefix=prefix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: pulumi.Input['BucketDestinationArgs'],
             enabled: pulumi.Input[bool],
             id: pulumi.Input[str],
             included_object_versions: pulumi.Input['BucketInventoryConfigurationIncludedObjectVersions'],
             schedule_frequency: pulumi.Input['BucketInventoryConfigurationScheduleFrequency'],
             optional_fields: Optional[pulumi.Input[Sequence[pulumi.Input['BucketInventoryConfigurationOptionalFieldsItem']]]] = None,
             prefix: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("destination", destination)
        _setter("enabled", enabled)
        _setter("id", id)
        _setter("included_object_versions", included_object_versions)
        _setter("schedule_frequency", schedule_frequency)
        if optional_fields is not None:
            _setter("optional_fields", optional_fields)
        if prefix is not None:
            _setter("prefix", prefix)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input['BucketDestinationArgs']:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input['BucketDestinationArgs']):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Specifies whether the inventory is enabled or disabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID used to identify the inventory configuration.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="includedObjectVersions")
    def included_object_versions(self) -> pulumi.Input['BucketInventoryConfigurationIncludedObjectVersions']:
        """
        Object versions to include in the inventory list.
        """
        return pulumi.get(self, "included_object_versions")

    @included_object_versions.setter
    def included_object_versions(self, value: pulumi.Input['BucketInventoryConfigurationIncludedObjectVersions']):
        pulumi.set(self, "included_object_versions", value)

    @property
    @pulumi.getter(name="scheduleFrequency")
    def schedule_frequency(self) -> pulumi.Input['BucketInventoryConfigurationScheduleFrequency']:
        """
        Specifies the schedule for generating inventory results.
        """
        return pulumi.get(self, "schedule_frequency")

    @schedule_frequency.setter
    def schedule_frequency(self, value: pulumi.Input['BucketInventoryConfigurationScheduleFrequency']):
        pulumi.set(self, "schedule_frequency", value)

    @property
    @pulumi.getter(name="optionalFields")
    def optional_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketInventoryConfigurationOptionalFieldsItem']]]]:
        """
        Contains the optional fields that are included in the inventory results.
        """
        return pulumi.get(self, "optional_fields")

    @optional_fields.setter
    def optional_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketInventoryConfigurationOptionalFieldsItem']]]]):
        pulumi.set(self, "optional_fields", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The prefix that is prepended to all inventory results.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)


@pulumi.input_type
class BucketLambdaConfigurationArgs:
    def __init__(__self__, *,
                 event: pulumi.Input[str],
                 function: pulumi.Input[str],
                 filter: Optional[pulumi.Input['BucketNotificationFilterArgs']] = None):
        """
        Describes the AWS Lambda functions to invoke and the events for which to invoke them.
        :param pulumi.Input[str] event: The Amazon S3 bucket event for which to invoke the AWS Lambda function.
        :param pulumi.Input[str] function: The Amazon Resource Name (ARN) of the AWS Lambda function that Amazon S3 invokes when the specified event type occurs.
        :param pulumi.Input['BucketNotificationFilterArgs'] filter: The filtering rules that determine which objects invoke the AWS Lambda function.
        """
        BucketLambdaConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            event=event,
            function=function,
            filter=filter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             event: pulumi.Input[str],
             function: pulumi.Input[str],
             filter: Optional[pulumi.Input['BucketNotificationFilterArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("event", event)
        _setter("function", function)
        if filter is not None:
            _setter("filter", filter)

    @property
    @pulumi.getter
    def event(self) -> pulumi.Input[str]:
        """
        The Amazon S3 bucket event for which to invoke the AWS Lambda function.
        """
        return pulumi.get(self, "event")

    @event.setter
    def event(self, value: pulumi.Input[str]):
        pulumi.set(self, "event", value)

    @property
    @pulumi.getter
    def function(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the AWS Lambda function that Amazon S3 invokes when the specified event type occurs.
        """
        return pulumi.get(self, "function")

    @function.setter
    def function(self, value: pulumi.Input[str]):
        pulumi.set(self, "function", value)

    @property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input['BucketNotificationFilterArgs']]:
        """
        The filtering rules that determine which objects invoke the AWS Lambda function.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input['BucketNotificationFilterArgs']]):
        pulumi.set(self, "filter", value)


@pulumi.input_type
class BucketLifecycleConfigurationArgs:
    def __init__(__self__, *,
                 rules: pulumi.Input[Sequence[pulumi.Input['BucketRuleArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BucketRuleArgs']]] rules: A lifecycle rule for individual objects in an Amazon S3 bucket.
        """
        BucketLifecycleConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rules=rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rules: pulumi.Input[Sequence[pulumi.Input['BucketRuleArgs']]],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> pulumi.Input[Sequence[pulumi.Input['BucketRuleArgs']]]:
        """
        A lifecycle rule for individual objects in an Amazon S3 bucket.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: pulumi.Input[Sequence[pulumi.Input['BucketRuleArgs']]]):
        pulumi.set(self, "rules", value)


@pulumi.input_type
class BucketLoggingConfigurationArgs:
    def __init__(__self__, *,
                 destination_bucket_name: Optional[pulumi.Input[str]] = None,
                 log_file_prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] destination_bucket_name: The name of an Amazon S3 bucket where Amazon S3 store server access log files. You can store log files in any bucket that you own. By default, logs are stored in the bucket where the LoggingConfiguration property is defined.
        """
        BucketLoggingConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination_bucket_name=destination_bucket_name,
            log_file_prefix=log_file_prefix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination_bucket_name: Optional[pulumi.Input[str]] = None,
             log_file_prefix: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if destination_bucket_name is not None:
            _setter("destination_bucket_name", destination_bucket_name)
        if log_file_prefix is not None:
            _setter("log_file_prefix", log_file_prefix)

    @property
    @pulumi.getter(name="destinationBucketName")
    def destination_bucket_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of an Amazon S3 bucket where Amazon S3 store server access log files. You can store log files in any bucket that you own. By default, logs are stored in the bucket where the LoggingConfiguration property is defined.
        """
        return pulumi.get(self, "destination_bucket_name")

    @destination_bucket_name.setter
    def destination_bucket_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_bucket_name", value)

    @property
    @pulumi.getter(name="logFilePrefix")
    def log_file_prefix(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "log_file_prefix")

    @log_file_prefix.setter
    def log_file_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_file_prefix", value)


@pulumi.input_type
class BucketMetricsConfigurationArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 access_point_arn: Optional[pulumi.Input[str]] = None,
                 prefix: Optional[pulumi.Input[str]] = None,
                 tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input['BucketTagFilterArgs']]]] = None):
        BucketMetricsConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            access_point_arn=access_point_arn,
            prefix=prefix,
            tag_filters=tag_filters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: pulumi.Input[str],
             access_point_arn: Optional[pulumi.Input[str]] = None,
             prefix: Optional[pulumi.Input[str]] = None,
             tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input['BucketTagFilterArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        if access_point_arn is not None:
            _setter("access_point_arn", access_point_arn)
        if prefix is not None:
            _setter("prefix", prefix)
        if tag_filters is not None:
            _setter("tag_filters", tag_filters)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="accessPointArn")
    def access_point_arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "access_point_arn")

    @access_point_arn.setter
    def access_point_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_point_arn", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketTagFilterArgs']]]]:
        return pulumi.get(self, "tag_filters")

    @tag_filters.setter
    def tag_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketTagFilterArgs']]]]):
        pulumi.set(self, "tag_filters", value)


@pulumi.input_type
class BucketMetricsArgs:
    def __init__(__self__, *,
                 status: pulumi.Input['BucketMetricsStatus'],
                 event_threshold: Optional[pulumi.Input['BucketReplicationTimeValueArgs']] = None):
        BucketMetricsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            status=status,
            event_threshold=event_threshold,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             status: pulumi.Input['BucketMetricsStatus'],
             event_threshold: Optional[pulumi.Input['BucketReplicationTimeValueArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("status", status)
        if event_threshold is not None:
            _setter("event_threshold", event_threshold)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input['BucketMetricsStatus']:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input['BucketMetricsStatus']):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="eventThreshold")
    def event_threshold(self) -> Optional[pulumi.Input['BucketReplicationTimeValueArgs']]:
        return pulumi.get(self, "event_threshold")

    @event_threshold.setter
    def event_threshold(self, value: Optional[pulumi.Input['BucketReplicationTimeValueArgs']]):
        pulumi.set(self, "event_threshold", value)


@pulumi.input_type
class BucketNoncurrentVersionExpirationArgs:
    def __init__(__self__, *,
                 noncurrent_days: pulumi.Input[int],
                 newer_noncurrent_versions: Optional[pulumi.Input[int]] = None):
        """
        Container for the expiration rule that describes when noncurrent objects are expired. If your bucket is versioning-enabled (or versioning is suspended), you can set this action to request that Amazon S3 expire noncurrent object versions at a specific period in the object's lifetime
        :param pulumi.Input[int] noncurrent_days: Specified the number of days an object is noncurrent before Amazon S3 can perform the associated action
        :param pulumi.Input[int] newer_noncurrent_versions: Specified the number of newer noncurrent and current versions that must exists before performing the associated action
        """
        BucketNoncurrentVersionExpirationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            noncurrent_days=noncurrent_days,
            newer_noncurrent_versions=newer_noncurrent_versions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             noncurrent_days: pulumi.Input[int],
             newer_noncurrent_versions: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("noncurrent_days", noncurrent_days)
        if newer_noncurrent_versions is not None:
            _setter("newer_noncurrent_versions", newer_noncurrent_versions)

    @property
    @pulumi.getter(name="noncurrentDays")
    def noncurrent_days(self) -> pulumi.Input[int]:
        """
        Specified the number of days an object is noncurrent before Amazon S3 can perform the associated action
        """
        return pulumi.get(self, "noncurrent_days")

    @noncurrent_days.setter
    def noncurrent_days(self, value: pulumi.Input[int]):
        pulumi.set(self, "noncurrent_days", value)

    @property
    @pulumi.getter(name="newerNoncurrentVersions")
    def newer_noncurrent_versions(self) -> Optional[pulumi.Input[int]]:
        """
        Specified the number of newer noncurrent and current versions that must exists before performing the associated action
        """
        return pulumi.get(self, "newer_noncurrent_versions")

    @newer_noncurrent_versions.setter
    def newer_noncurrent_versions(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "newer_noncurrent_versions", value)


@pulumi.input_type
class BucketNoncurrentVersionTransitionArgs:
    def __init__(__self__, *,
                 storage_class: pulumi.Input['BucketNoncurrentVersionTransitionStorageClass'],
                 transition_in_days: pulumi.Input[int],
                 newer_noncurrent_versions: Optional[pulumi.Input[int]] = None):
        """
        Container for the transition rule that describes when noncurrent objects transition to the STANDARD_IA, ONEZONE_IA, INTELLIGENT_TIERING, GLACIER_IR, GLACIER, or DEEP_ARCHIVE storage class. If your bucket is versioning-enabled (or versioning is suspended), you can set this action to request that Amazon S3 transition noncurrent object versions to the STANDARD_IA, ONEZONE_IA, INTELLIGENT_TIERING, GLACIER_IR, GLACIER, or DEEP_ARCHIVE storage class at a specific period in the object's lifetime.
        :param pulumi.Input['BucketNoncurrentVersionTransitionStorageClass'] storage_class: The class of storage used to store the object.
        :param pulumi.Input[int] transition_in_days: Specifies the number of days an object is noncurrent before Amazon S3 can perform the associated action.
        :param pulumi.Input[int] newer_noncurrent_versions: Specified the number of newer noncurrent and current versions that must exists before performing the associated action
        """
        BucketNoncurrentVersionTransitionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            storage_class=storage_class,
            transition_in_days=transition_in_days,
            newer_noncurrent_versions=newer_noncurrent_versions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             storage_class: pulumi.Input['BucketNoncurrentVersionTransitionStorageClass'],
             transition_in_days: pulumi.Input[int],
             newer_noncurrent_versions: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("storage_class", storage_class)
        _setter("transition_in_days", transition_in_days)
        if newer_noncurrent_versions is not None:
            _setter("newer_noncurrent_versions", newer_noncurrent_versions)

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> pulumi.Input['BucketNoncurrentVersionTransitionStorageClass']:
        """
        The class of storage used to store the object.
        """
        return pulumi.get(self, "storage_class")

    @storage_class.setter
    def storage_class(self, value: pulumi.Input['BucketNoncurrentVersionTransitionStorageClass']):
        pulumi.set(self, "storage_class", value)

    @property
    @pulumi.getter(name="transitionInDays")
    def transition_in_days(self) -> pulumi.Input[int]:
        """
        Specifies the number of days an object is noncurrent before Amazon S3 can perform the associated action.
        """
        return pulumi.get(self, "transition_in_days")

    @transition_in_days.setter
    def transition_in_days(self, value: pulumi.Input[int]):
        pulumi.set(self, "transition_in_days", value)

    @property
    @pulumi.getter(name="newerNoncurrentVersions")
    def newer_noncurrent_versions(self) -> Optional[pulumi.Input[int]]:
        """
        Specified the number of newer noncurrent and current versions that must exists before performing the associated action
        """
        return pulumi.get(self, "newer_noncurrent_versions")

    @newer_noncurrent_versions.setter
    def newer_noncurrent_versions(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "newer_noncurrent_versions", value)


@pulumi.input_type
class BucketNotificationConfigurationArgs:
    def __init__(__self__, *,
                 event_bridge_configuration: Optional[pulumi.Input['BucketEventBridgeConfigurationArgs']] = None,
                 lambda_configurations: Optional[pulumi.Input[Sequence[pulumi.Input['BucketLambdaConfigurationArgs']]]] = None,
                 queue_configurations: Optional[pulumi.Input[Sequence[pulumi.Input['BucketQueueConfigurationArgs']]]] = None,
                 topic_configurations: Optional[pulumi.Input[Sequence[pulumi.Input['BucketTopicConfigurationArgs']]]] = None):
        """
        Describes the notification configuration for an Amazon S3 bucket.
        """
        BucketNotificationConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            event_bridge_configuration=event_bridge_configuration,
            lambda_configurations=lambda_configurations,
            queue_configurations=queue_configurations,
            topic_configurations=topic_configurations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             event_bridge_configuration: Optional[pulumi.Input['BucketEventBridgeConfigurationArgs']] = None,
             lambda_configurations: Optional[pulumi.Input[Sequence[pulumi.Input['BucketLambdaConfigurationArgs']]]] = None,
             queue_configurations: Optional[pulumi.Input[Sequence[pulumi.Input['BucketQueueConfigurationArgs']]]] = None,
             topic_configurations: Optional[pulumi.Input[Sequence[pulumi.Input['BucketTopicConfigurationArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if event_bridge_configuration is not None:
            _setter("event_bridge_configuration", event_bridge_configuration)
        if lambda_configurations is not None:
            _setter("lambda_configurations", lambda_configurations)
        if queue_configurations is not None:
            _setter("queue_configurations", queue_configurations)
        if topic_configurations is not None:
            _setter("topic_configurations", topic_configurations)

    @property
    @pulumi.getter(name="eventBridgeConfiguration")
    def event_bridge_configuration(self) -> Optional[pulumi.Input['BucketEventBridgeConfigurationArgs']]:
        return pulumi.get(self, "event_bridge_configuration")

    @event_bridge_configuration.setter
    def event_bridge_configuration(self, value: Optional[pulumi.Input['BucketEventBridgeConfigurationArgs']]):
        pulumi.set(self, "event_bridge_configuration", value)

    @property
    @pulumi.getter(name="lambdaConfigurations")
    def lambda_configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketLambdaConfigurationArgs']]]]:
        return pulumi.get(self, "lambda_configurations")

    @lambda_configurations.setter
    def lambda_configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketLambdaConfigurationArgs']]]]):
        pulumi.set(self, "lambda_configurations", value)

    @property
    @pulumi.getter(name="queueConfigurations")
    def queue_configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketQueueConfigurationArgs']]]]:
        return pulumi.get(self, "queue_configurations")

    @queue_configurations.setter
    def queue_configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketQueueConfigurationArgs']]]]):
        pulumi.set(self, "queue_configurations", value)

    @property
    @pulumi.getter(name="topicConfigurations")
    def topic_configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketTopicConfigurationArgs']]]]:
        return pulumi.get(self, "topic_configurations")

    @topic_configurations.setter
    def topic_configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketTopicConfigurationArgs']]]]):
        pulumi.set(self, "topic_configurations", value)


@pulumi.input_type
class BucketNotificationFilterArgs:
    def __init__(__self__, *,
                 s3_key: pulumi.Input['BucketS3KeyFilterArgs']):
        """
        Specifies object key name filtering rules.
        """
        BucketNotificationFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            s3_key=s3_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             s3_key: pulumi.Input['BucketS3KeyFilterArgs'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("s3_key", s3_key)

    @property
    @pulumi.getter(name="s3Key")
    def s3_key(self) -> pulumi.Input['BucketS3KeyFilterArgs']:
        return pulumi.get(self, "s3_key")

    @s3_key.setter
    def s3_key(self, value: pulumi.Input['BucketS3KeyFilterArgs']):
        pulumi.set(self, "s3_key", value)


@pulumi.input_type
class BucketObjectLockConfigurationArgs:
    def __init__(__self__, *,
                 object_lock_enabled: Optional[pulumi.Input[str]] = None,
                 rule: Optional[pulumi.Input['BucketObjectLockRuleArgs']] = None):
        BucketObjectLockConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            object_lock_enabled=object_lock_enabled,
            rule=rule,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             object_lock_enabled: Optional[pulumi.Input[str]] = None,
             rule: Optional[pulumi.Input['BucketObjectLockRuleArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if object_lock_enabled is not None:
            _setter("object_lock_enabled", object_lock_enabled)
        if rule is not None:
            _setter("rule", rule)

    @property
    @pulumi.getter(name="objectLockEnabled")
    def object_lock_enabled(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "object_lock_enabled")

    @object_lock_enabled.setter
    def object_lock_enabled(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object_lock_enabled", value)

    @property
    @pulumi.getter
    def rule(self) -> Optional[pulumi.Input['BucketObjectLockRuleArgs']]:
        return pulumi.get(self, "rule")

    @rule.setter
    def rule(self, value: Optional[pulumi.Input['BucketObjectLockRuleArgs']]):
        pulumi.set(self, "rule", value)


@pulumi.input_type
class BucketObjectLockRuleArgs:
    def __init__(__self__, *,
                 default_retention: Optional[pulumi.Input['BucketDefaultRetentionArgs']] = None):
        """
        The Object Lock rule in place for the specified object.
        """
        BucketObjectLockRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_retention=default_retention,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_retention: Optional[pulumi.Input['BucketDefaultRetentionArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if default_retention is not None:
            _setter("default_retention", default_retention)

    @property
    @pulumi.getter(name="defaultRetention")
    def default_retention(self) -> Optional[pulumi.Input['BucketDefaultRetentionArgs']]:
        return pulumi.get(self, "default_retention")

    @default_retention.setter
    def default_retention(self, value: Optional[pulumi.Input['BucketDefaultRetentionArgs']]):
        pulumi.set(self, "default_retention", value)


@pulumi.input_type
class BucketOwnershipControlsRuleArgs:
    def __init__(__self__, *,
                 object_ownership: Optional[pulumi.Input['BucketOwnershipControlsRuleObjectOwnership']] = None):
        """
        :param pulumi.Input['BucketOwnershipControlsRuleObjectOwnership'] object_ownership: Specifies an object ownership rule.
        """
        BucketOwnershipControlsRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            object_ownership=object_ownership,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             object_ownership: Optional[pulumi.Input['BucketOwnershipControlsRuleObjectOwnership']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if object_ownership is not None:
            _setter("object_ownership", object_ownership)

    @property
    @pulumi.getter(name="objectOwnership")
    def object_ownership(self) -> Optional[pulumi.Input['BucketOwnershipControlsRuleObjectOwnership']]:
        """
        Specifies an object ownership rule.
        """
        return pulumi.get(self, "object_ownership")

    @object_ownership.setter
    def object_ownership(self, value: Optional[pulumi.Input['BucketOwnershipControlsRuleObjectOwnership']]):
        pulumi.set(self, "object_ownership", value)


@pulumi.input_type
class BucketOwnershipControlsArgs:
    def __init__(__self__, *,
                 rules: pulumi.Input[Sequence[pulumi.Input['BucketOwnershipControlsRuleArgs']]]):
        BucketOwnershipControlsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rules=rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rules: pulumi.Input[Sequence[pulumi.Input['BucketOwnershipControlsRuleArgs']]],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> pulumi.Input[Sequence[pulumi.Input['BucketOwnershipControlsRuleArgs']]]:
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: pulumi.Input[Sequence[pulumi.Input['BucketOwnershipControlsRuleArgs']]]):
        pulumi.set(self, "rules", value)


@pulumi.input_type
class BucketPublicAccessBlockConfigurationArgs:
    def __init__(__self__, *,
                 block_public_acls: Optional[pulumi.Input[bool]] = None,
                 block_public_policy: Optional[pulumi.Input[bool]] = None,
                 ignore_public_acls: Optional[pulumi.Input[bool]] = None,
                 restrict_public_buckets: Optional[pulumi.Input[bool]] = None):
        """
        Configuration that defines how Amazon S3 handles public access.
        :param pulumi.Input[bool] block_public_acls: Specifies whether Amazon S3 should block public access control lists (ACLs) for this bucket and objects in this bucket. Setting this element to TRUE causes the following behavior:
               - PUT Bucket acl and PUT Object acl calls fail if the specified ACL is public.
                - PUT Object calls fail if the request includes a public ACL.
               Enabling this setting doesn't affect existing policies or ACLs.
        :param pulumi.Input[bool] block_public_policy: Specifies whether Amazon S3 should block public bucket policies for this bucket. Setting this element to TRUE causes Amazon S3 to reject calls to PUT Bucket policy if the specified bucket policy allows public access.
               Enabling this setting doesn't affect existing bucket policies.
        :param pulumi.Input[bool] ignore_public_acls: Specifies whether Amazon S3 should ignore public ACLs for this bucket and objects in this bucket. Setting this element to TRUE causes Amazon S3 to ignore all public ACLs on this bucket and objects in this bucket.
               Enabling this setting doesn't affect the persistence of any existing ACLs and doesn't prevent new public ACLs from being set.
        :param pulumi.Input[bool] restrict_public_buckets: Specifies whether Amazon S3 should restrict public bucket policies for this bucket. Setting this element to TRUE restricts access to this bucket to only AWS services and authorized users within this account if the bucket has a public policy.
               Enabling this setting doesn't affect previously stored bucket policies, except that public and cross-account access within any public bucket policy, including non-public delegation to specific accounts, is blocked.
        """
        BucketPublicAccessBlockConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            block_public_acls=block_public_acls,
            block_public_policy=block_public_policy,
            ignore_public_acls=ignore_public_acls,
            restrict_public_buckets=restrict_public_buckets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             block_public_acls: Optional[pulumi.Input[bool]] = None,
             block_public_policy: Optional[pulumi.Input[bool]] = None,
             ignore_public_acls: Optional[pulumi.Input[bool]] = None,
             restrict_public_buckets: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if block_public_acls is not None:
            _setter("block_public_acls", block_public_acls)
        if block_public_policy is not None:
            _setter("block_public_policy", block_public_policy)
        if ignore_public_acls is not None:
            _setter("ignore_public_acls", ignore_public_acls)
        if restrict_public_buckets is not None:
            _setter("restrict_public_buckets", restrict_public_buckets)

    @property
    @pulumi.getter(name="blockPublicAcls")
    def block_public_acls(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether Amazon S3 should block public access control lists (ACLs) for this bucket and objects in this bucket. Setting this element to TRUE causes the following behavior:
        - PUT Bucket acl and PUT Object acl calls fail if the specified ACL is public.
         - PUT Object calls fail if the request includes a public ACL.
        Enabling this setting doesn't affect existing policies or ACLs.
        """
        return pulumi.get(self, "block_public_acls")

    @block_public_acls.setter
    def block_public_acls(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "block_public_acls", value)

    @property
    @pulumi.getter(name="blockPublicPolicy")
    def block_public_policy(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether Amazon S3 should block public bucket policies for this bucket. Setting this element to TRUE causes Amazon S3 to reject calls to PUT Bucket policy if the specified bucket policy allows public access.
        Enabling this setting doesn't affect existing bucket policies.
        """
        return pulumi.get(self, "block_public_policy")

    @block_public_policy.setter
    def block_public_policy(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "block_public_policy", value)

    @property
    @pulumi.getter(name="ignorePublicAcls")
    def ignore_public_acls(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether Amazon S3 should ignore public ACLs for this bucket and objects in this bucket. Setting this element to TRUE causes Amazon S3 to ignore all public ACLs on this bucket and objects in this bucket.
        Enabling this setting doesn't affect the persistence of any existing ACLs and doesn't prevent new public ACLs from being set.
        """
        return pulumi.get(self, "ignore_public_acls")

    @ignore_public_acls.setter
    def ignore_public_acls(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_public_acls", value)

    @property
    @pulumi.getter(name="restrictPublicBuckets")
    def restrict_public_buckets(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether Amazon S3 should restrict public bucket policies for this bucket. Setting this element to TRUE restricts access to this bucket to only AWS services and authorized users within this account if the bucket has a public policy.
        Enabling this setting doesn't affect previously stored bucket policies, except that public and cross-account access within any public bucket policy, including non-public delegation to specific accounts, is blocked.
        """
        return pulumi.get(self, "restrict_public_buckets")

    @restrict_public_buckets.setter
    def restrict_public_buckets(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "restrict_public_buckets", value)


@pulumi.input_type
class BucketQueueConfigurationArgs:
    def __init__(__self__, *,
                 event: pulumi.Input[str],
                 queue: pulumi.Input[str],
                 filter: Optional[pulumi.Input['BucketNotificationFilterArgs']] = None):
        """
        The Amazon Simple Queue Service queues to publish messages to and the events for which to publish messages.
        :param pulumi.Input[str] event: The Amazon S3 bucket event about which you want to publish messages to Amazon SQS.
        :param pulumi.Input[str] queue: The Amazon Resource Name (ARN) of the Amazon SQS queue to which Amazon S3 publishes a message when it detects events of the specified type.
        :param pulumi.Input['BucketNotificationFilterArgs'] filter: The filtering rules that determine which objects trigger notifications.
        """
        BucketQueueConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            event=event,
            queue=queue,
            filter=filter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             event: pulumi.Input[str],
             queue: pulumi.Input[str],
             filter: Optional[pulumi.Input['BucketNotificationFilterArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("event", event)
        _setter("queue", queue)
        if filter is not None:
            _setter("filter", filter)

    @property
    @pulumi.getter
    def event(self) -> pulumi.Input[str]:
        """
        The Amazon S3 bucket event about which you want to publish messages to Amazon SQS.
        """
        return pulumi.get(self, "event")

    @event.setter
    def event(self, value: pulumi.Input[str]):
        pulumi.set(self, "event", value)

    @property
    @pulumi.getter
    def queue(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the Amazon SQS queue to which Amazon S3 publishes a message when it detects events of the specified type.
        """
        return pulumi.get(self, "queue")

    @queue.setter
    def queue(self, value: pulumi.Input[str]):
        pulumi.set(self, "queue", value)

    @property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input['BucketNotificationFilterArgs']]:
        """
        The filtering rules that determine which objects trigger notifications.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input['BucketNotificationFilterArgs']]):
        pulumi.set(self, "filter", value)


@pulumi.input_type
class BucketRedirectAllRequestsToArgs:
    def __init__(__self__, *,
                 host_name: pulumi.Input[str],
                 protocol: Optional[pulumi.Input['BucketRedirectAllRequestsToProtocol']] = None):
        """
        Specifies the redirect behavior of all requests to a website endpoint of an Amazon S3 bucket.
        :param pulumi.Input[str] host_name: Name of the host where requests are redirected.
        :param pulumi.Input['BucketRedirectAllRequestsToProtocol'] protocol: Protocol to use when redirecting requests. The default is the protocol that is used in the original request.
        """
        BucketRedirectAllRequestsToArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            host_name=host_name,
            protocol=protocol,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             host_name: pulumi.Input[str],
             protocol: Optional[pulumi.Input['BucketRedirectAllRequestsToProtocol']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("host_name", host_name)
        if protocol is not None:
            _setter("protocol", protocol)

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> pulumi.Input[str]:
        """
        Name of the host where requests are redirected.
        """
        return pulumi.get(self, "host_name")

    @host_name.setter
    def host_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "host_name", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input['BucketRedirectAllRequestsToProtocol']]:
        """
        Protocol to use when redirecting requests. The default is the protocol that is used in the original request.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input['BucketRedirectAllRequestsToProtocol']]):
        pulumi.set(self, "protocol", value)


@pulumi.input_type
class BucketRedirectRuleArgs:
    def __init__(__self__, *,
                 host_name: Optional[pulumi.Input[str]] = None,
                 http_redirect_code: Optional[pulumi.Input[str]] = None,
                 protocol: Optional[pulumi.Input['BucketRedirectRuleProtocol']] = None,
                 replace_key_prefix_with: Optional[pulumi.Input[str]] = None,
                 replace_key_with: Optional[pulumi.Input[str]] = None):
        """
        Specifies how requests are redirected. In the event of an error, you can specify a different error code to return.
        :param pulumi.Input[str] host_name: The host name to use in the redirect request.
        :param pulumi.Input[str] http_redirect_code: The HTTP redirect code to use on the response. Not required if one of the siblings is present.
        :param pulumi.Input['BucketRedirectRuleProtocol'] protocol: Protocol to use when redirecting requests. The default is the protocol that is used in the original request.
        :param pulumi.Input[str] replace_key_prefix_with: The object key prefix to use in the redirect request.
        :param pulumi.Input[str] replace_key_with: The specific object key to use in the redirect request.d
        """
        BucketRedirectRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            host_name=host_name,
            http_redirect_code=http_redirect_code,
            protocol=protocol,
            replace_key_prefix_with=replace_key_prefix_with,
            replace_key_with=replace_key_with,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             host_name: Optional[pulumi.Input[str]] = None,
             http_redirect_code: Optional[pulumi.Input[str]] = None,
             protocol: Optional[pulumi.Input['BucketRedirectRuleProtocol']] = None,
             replace_key_prefix_with: Optional[pulumi.Input[str]] = None,
             replace_key_with: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if host_name is not None:
            _setter("host_name", host_name)
        if http_redirect_code is not None:
            _setter("http_redirect_code", http_redirect_code)
        if protocol is not None:
            _setter("protocol", protocol)
        if replace_key_prefix_with is not None:
            _setter("replace_key_prefix_with", replace_key_prefix_with)
        if replace_key_with is not None:
            _setter("replace_key_with", replace_key_with)

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> Optional[pulumi.Input[str]]:
        """
        The host name to use in the redirect request.
        """
        return pulumi.get(self, "host_name")

    @host_name.setter
    def host_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_name", value)

    @property
    @pulumi.getter(name="httpRedirectCode")
    def http_redirect_code(self) -> Optional[pulumi.Input[str]]:
        """
        The HTTP redirect code to use on the response. Not required if one of the siblings is present.
        """
        return pulumi.get(self, "http_redirect_code")

    @http_redirect_code.setter
    def http_redirect_code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_redirect_code", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input['BucketRedirectRuleProtocol']]:
        """
        Protocol to use when redirecting requests. The default is the protocol that is used in the original request.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input['BucketRedirectRuleProtocol']]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="replaceKeyPrefixWith")
    def replace_key_prefix_with(self) -> Optional[pulumi.Input[str]]:
        """
        The object key prefix to use in the redirect request.
        """
        return pulumi.get(self, "replace_key_prefix_with")

    @replace_key_prefix_with.setter
    def replace_key_prefix_with(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replace_key_prefix_with", value)

    @property
    @pulumi.getter(name="replaceKeyWith")
    def replace_key_with(self) -> Optional[pulumi.Input[str]]:
        """
        The specific object key to use in the redirect request.d
        """
        return pulumi.get(self, "replace_key_with")

    @replace_key_with.setter
    def replace_key_with(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "replace_key_with", value)


@pulumi.input_type
class BucketReplicaModificationsArgs:
    def __init__(__self__, *,
                 status: pulumi.Input['BucketReplicaModificationsStatus']):
        """
        :param pulumi.Input['BucketReplicaModificationsStatus'] status: Specifies whether Amazon S3 replicates modifications on replicas.
        """
        BucketReplicaModificationsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             status: pulumi.Input['BucketReplicaModificationsStatus'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("status", status)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input['BucketReplicaModificationsStatus']:
        """
        Specifies whether Amazon S3 replicates modifications on replicas.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input['BucketReplicaModificationsStatus']):
        pulumi.set(self, "status", value)


@pulumi.input_type
class BucketReplicationConfigurationArgs:
    def __init__(__self__, *,
                 role: pulumi.Input[str],
                 rules: pulumi.Input[Sequence[pulumi.Input['BucketReplicationRuleArgs']]]):
        """
        A container for replication rules. You can add up to 1,000 rules. The maximum size of a replication configuration is 2 MB.
        :param pulumi.Input[str] role: The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that Amazon S3 assumes when replicating objects.
        :param pulumi.Input[Sequence[pulumi.Input['BucketReplicationRuleArgs']]] rules: A container for one or more replication rules.
        """
        BucketReplicationConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            role=role,
            rules=rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             role: pulumi.Input[str],
             rules: pulumi.Input[Sequence[pulumi.Input['BucketReplicationRuleArgs']]],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("role", role)
        _setter("rules", rules)

    @property
    @pulumi.getter
    def role(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that Amazon S3 assumes when replicating objects.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: pulumi.Input[str]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def rules(self) -> pulumi.Input[Sequence[pulumi.Input['BucketReplicationRuleArgs']]]:
        """
        A container for one or more replication rules.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: pulumi.Input[Sequence[pulumi.Input['BucketReplicationRuleArgs']]]):
        pulumi.set(self, "rules", value)


@pulumi.input_type
class BucketReplicationDestinationArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 access_control_translation: Optional[pulumi.Input['BucketAccessControlTranslationArgs']] = None,
                 account: Optional[pulumi.Input[str]] = None,
                 encryption_configuration: Optional[pulumi.Input['BucketEncryptionConfigurationArgs']] = None,
                 metrics: Optional[pulumi.Input['BucketMetricsArgs']] = None,
                 replication_time: Optional[pulumi.Input['BucketReplicationTimeArgs']] = None,
                 storage_class: Optional[pulumi.Input['BucketReplicationDestinationStorageClass']] = None):
        """
        Specifies which Amazon S3 bucket to store replicated objects in and their storage class.
        :param pulumi.Input['BucketReplicationDestinationStorageClass'] storage_class: The storage class to use when replicating objects, such as S3 Standard or reduced redundancy.
        """
        BucketReplicationDestinationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket=bucket,
            access_control_translation=access_control_translation,
            account=account,
            encryption_configuration=encryption_configuration,
            metrics=metrics,
            replication_time=replication_time,
            storage_class=storage_class,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket: pulumi.Input[str],
             access_control_translation: Optional[pulumi.Input['BucketAccessControlTranslationArgs']] = None,
             account: Optional[pulumi.Input[str]] = None,
             encryption_configuration: Optional[pulumi.Input['BucketEncryptionConfigurationArgs']] = None,
             metrics: Optional[pulumi.Input['BucketMetricsArgs']] = None,
             replication_time: Optional[pulumi.Input['BucketReplicationTimeArgs']] = None,
             storage_class: Optional[pulumi.Input['BucketReplicationDestinationStorageClass']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("bucket", bucket)
        if access_control_translation is not None:
            _setter("access_control_translation", access_control_translation)
        if account is not None:
            _setter("account", account)
        if encryption_configuration is not None:
            _setter("encryption_configuration", encryption_configuration)
        if metrics is not None:
            _setter("metrics", metrics)
        if replication_time is not None:
            _setter("replication_time", replication_time)
        if storage_class is not None:
            _setter("storage_class", storage_class)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter(name="accessControlTranslation")
    def access_control_translation(self) -> Optional[pulumi.Input['BucketAccessControlTranslationArgs']]:
        return pulumi.get(self, "access_control_translation")

    @access_control_translation.setter
    def access_control_translation(self, value: Optional[pulumi.Input['BucketAccessControlTranslationArgs']]):
        pulumi.set(self, "access_control_translation", value)

    @property
    @pulumi.getter
    def account(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "account")

    @account.setter
    def account(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "account", value)

    @property
    @pulumi.getter(name="encryptionConfiguration")
    def encryption_configuration(self) -> Optional[pulumi.Input['BucketEncryptionConfigurationArgs']]:
        return pulumi.get(self, "encryption_configuration")

    @encryption_configuration.setter
    def encryption_configuration(self, value: Optional[pulumi.Input['BucketEncryptionConfigurationArgs']]):
        pulumi.set(self, "encryption_configuration", value)

    @property
    @pulumi.getter
    def metrics(self) -> Optional[pulumi.Input['BucketMetricsArgs']]:
        return pulumi.get(self, "metrics")

    @metrics.setter
    def metrics(self, value: Optional[pulumi.Input['BucketMetricsArgs']]):
        pulumi.set(self, "metrics", value)

    @property
    @pulumi.getter(name="replicationTime")
    def replication_time(self) -> Optional[pulumi.Input['BucketReplicationTimeArgs']]:
        return pulumi.get(self, "replication_time")

    @replication_time.setter
    def replication_time(self, value: Optional[pulumi.Input['BucketReplicationTimeArgs']]):
        pulumi.set(self, "replication_time", value)

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> Optional[pulumi.Input['BucketReplicationDestinationStorageClass']]:
        """
        The storage class to use when replicating objects, such as S3 Standard or reduced redundancy.
        """
        return pulumi.get(self, "storage_class")

    @storage_class.setter
    def storage_class(self, value: Optional[pulumi.Input['BucketReplicationDestinationStorageClass']]):
        pulumi.set(self, "storage_class", value)


@pulumi.input_type
class BucketReplicationRuleAndOperatorArgs:
    def __init__(__self__, *,
                 prefix: Optional[pulumi.Input[str]] = None,
                 tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input['BucketTagFilterArgs']]]] = None):
        BucketReplicationRuleAndOperatorArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            prefix=prefix,
            tag_filters=tag_filters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             prefix: Optional[pulumi.Input[str]] = None,
             tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input['BucketTagFilterArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if prefix is not None:
            _setter("prefix", prefix)
        if tag_filters is not None:
            _setter("tag_filters", tag_filters)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketTagFilterArgs']]]]:
        return pulumi.get(self, "tag_filters")

    @tag_filters.setter
    def tag_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketTagFilterArgs']]]]):
        pulumi.set(self, "tag_filters", value)


@pulumi.input_type
class BucketReplicationRuleFilterArgs:
    def __init__(__self__, *,
                 and_: Optional[pulumi.Input['BucketReplicationRuleAndOperatorArgs']] = None,
                 prefix: Optional[pulumi.Input[str]] = None,
                 tag_filter: Optional[pulumi.Input['BucketTagFilterArgs']] = None):
        BucketReplicationRuleFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            and_=and_,
            prefix=prefix,
            tag_filter=tag_filter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             and_: Optional[pulumi.Input['BucketReplicationRuleAndOperatorArgs']] = None,
             prefix: Optional[pulumi.Input[str]] = None,
             tag_filter: Optional[pulumi.Input['BucketTagFilterArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if and_ is not None:
            _setter("and_", and_)
        if prefix is not None:
            _setter("prefix", prefix)
        if tag_filter is not None:
            _setter("tag_filter", tag_filter)

    @property
    @pulumi.getter(name="and")
    def and_(self) -> Optional[pulumi.Input['BucketReplicationRuleAndOperatorArgs']]:
        return pulumi.get(self, "and_")

    @and_.setter
    def and_(self, value: Optional[pulumi.Input['BucketReplicationRuleAndOperatorArgs']]):
        pulumi.set(self, "and_", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter(name="tagFilter")
    def tag_filter(self) -> Optional[pulumi.Input['BucketTagFilterArgs']]:
        return pulumi.get(self, "tag_filter")

    @tag_filter.setter
    def tag_filter(self, value: Optional[pulumi.Input['BucketTagFilterArgs']]):
        pulumi.set(self, "tag_filter", value)


@pulumi.input_type
class BucketReplicationRuleArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input['BucketReplicationDestinationArgs'],
                 status: pulumi.Input['BucketReplicationRuleStatus'],
                 delete_marker_replication: Optional[pulumi.Input['BucketDeleteMarkerReplicationArgs']] = None,
                 filter: Optional[pulumi.Input['BucketReplicationRuleFilterArgs']] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 prefix: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 source_selection_criteria: Optional[pulumi.Input['BucketSourceSelectionCriteriaArgs']] = None):
        """
        Specifies which Amazon S3 objects to replicate and where to store the replicas.
        :param pulumi.Input['BucketReplicationRuleStatus'] status: Specifies whether the rule is enabled.
        :param pulumi.Input[str] id: A unique identifier for the rule.
        :param pulumi.Input[str] prefix: An object key name prefix that identifies the object or objects to which the rule applies.
        """
        BucketReplicationRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            destination=destination,
            status=status,
            delete_marker_replication=delete_marker_replication,
            filter=filter,
            id=id,
            prefix=prefix,
            priority=priority,
            source_selection_criteria=source_selection_criteria,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             destination: pulumi.Input['BucketReplicationDestinationArgs'],
             status: pulumi.Input['BucketReplicationRuleStatus'],
             delete_marker_replication: Optional[pulumi.Input['BucketDeleteMarkerReplicationArgs']] = None,
             filter: Optional[pulumi.Input['BucketReplicationRuleFilterArgs']] = None,
             id: Optional[pulumi.Input[str]] = None,
             prefix: Optional[pulumi.Input[str]] = None,
             priority: Optional[pulumi.Input[int]] = None,
             source_selection_criteria: Optional[pulumi.Input['BucketSourceSelectionCriteriaArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("destination", destination)
        _setter("status", status)
        if delete_marker_replication is not None:
            _setter("delete_marker_replication", delete_marker_replication)
        if filter is not None:
            _setter("filter", filter)
        if id is not None:
            _setter("id", id)
        if prefix is not None:
            _setter("prefix", prefix)
        if priority is not None:
            _setter("priority", priority)
        if source_selection_criteria is not None:
            _setter("source_selection_criteria", source_selection_criteria)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input['BucketReplicationDestinationArgs']:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input['BucketReplicationDestinationArgs']):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input['BucketReplicationRuleStatus']:
        """
        Specifies whether the rule is enabled.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input['BucketReplicationRuleStatus']):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="deleteMarkerReplication")
    def delete_marker_replication(self) -> Optional[pulumi.Input['BucketDeleteMarkerReplicationArgs']]:
        return pulumi.get(self, "delete_marker_replication")

    @delete_marker_replication.setter
    def delete_marker_replication(self, value: Optional[pulumi.Input['BucketDeleteMarkerReplicationArgs']]):
        pulumi.set(self, "delete_marker_replication", value)

    @property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input['BucketReplicationRuleFilterArgs']]:
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input['BucketReplicationRuleFilterArgs']]):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        A unique identifier for the rule.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        An object key name prefix that identifies the object or objects to which the rule applies.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="sourceSelectionCriteria")
    def source_selection_criteria(self) -> Optional[pulumi.Input['BucketSourceSelectionCriteriaArgs']]:
        return pulumi.get(self, "source_selection_criteria")

    @source_selection_criteria.setter
    def source_selection_criteria(self, value: Optional[pulumi.Input['BucketSourceSelectionCriteriaArgs']]):
        pulumi.set(self, "source_selection_criteria", value)


@pulumi.input_type
class BucketReplicationTimeValueArgs:
    def __init__(__self__, *,
                 minutes: pulumi.Input[int]):
        BucketReplicationTimeValueArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            minutes=minutes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             minutes: pulumi.Input[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("minutes", minutes)

    @property
    @pulumi.getter
    def minutes(self) -> pulumi.Input[int]:
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: pulumi.Input[int]):
        pulumi.set(self, "minutes", value)


@pulumi.input_type
class BucketReplicationTimeArgs:
    def __init__(__self__, *,
                 status: pulumi.Input['BucketReplicationTimeStatus'],
                 time: pulumi.Input['BucketReplicationTimeValueArgs']):
        BucketReplicationTimeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            status=status,
            time=time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             status: pulumi.Input['BucketReplicationTimeStatus'],
             time: pulumi.Input['BucketReplicationTimeValueArgs'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("status", status)
        _setter("time", time)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input['BucketReplicationTimeStatus']:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input['BucketReplicationTimeStatus']):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def time(self) -> pulumi.Input['BucketReplicationTimeValueArgs']:
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: pulumi.Input['BucketReplicationTimeValueArgs']):
        pulumi.set(self, "time", value)


@pulumi.input_type
class BucketRoutingRuleConditionArgs:
    def __init__(__self__, *,
                 http_error_code_returned_equals: Optional[pulumi.Input[str]] = None,
                 key_prefix_equals: Optional[pulumi.Input[str]] = None):
        """
        A container for describing a condition that must be met for the specified redirect to apply.You must specify at least one of HttpErrorCodeReturnedEquals and KeyPrefixEquals
        :param pulumi.Input[str] http_error_code_returned_equals: The HTTP error code when the redirect is applied. 
        :param pulumi.Input[str] key_prefix_equals: The object key name prefix when the redirect is applied.
        """
        BucketRoutingRuleConditionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            http_error_code_returned_equals=http_error_code_returned_equals,
            key_prefix_equals=key_prefix_equals,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             http_error_code_returned_equals: Optional[pulumi.Input[str]] = None,
             key_prefix_equals: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if http_error_code_returned_equals is not None:
            _setter("http_error_code_returned_equals", http_error_code_returned_equals)
        if key_prefix_equals is not None:
            _setter("key_prefix_equals", key_prefix_equals)

    @property
    @pulumi.getter(name="httpErrorCodeReturnedEquals")
    def http_error_code_returned_equals(self) -> Optional[pulumi.Input[str]]:
        """
        The HTTP error code when the redirect is applied. 
        """
        return pulumi.get(self, "http_error_code_returned_equals")

    @http_error_code_returned_equals.setter
    def http_error_code_returned_equals(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_error_code_returned_equals", value)

    @property
    @pulumi.getter(name="keyPrefixEquals")
    def key_prefix_equals(self) -> Optional[pulumi.Input[str]]:
        """
        The object key name prefix when the redirect is applied.
        """
        return pulumi.get(self, "key_prefix_equals")

    @key_prefix_equals.setter
    def key_prefix_equals(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_prefix_equals", value)


@pulumi.input_type
class BucketRoutingRuleArgs:
    def __init__(__self__, *,
                 redirect_rule: pulumi.Input['BucketRedirectRuleArgs'],
                 routing_rule_condition: Optional[pulumi.Input['BucketRoutingRuleConditionArgs']] = None):
        """
        Specifies the redirect behavior and when a redirect is applied.
        :param pulumi.Input['BucketRedirectRuleArgs'] redirect_rule: Container for redirect information. You can redirect requests to another host, to another page, or with another protocol. In the event of an error, you can specify a different error code to return.
        """
        BucketRoutingRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            redirect_rule=redirect_rule,
            routing_rule_condition=routing_rule_condition,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             redirect_rule: pulumi.Input['BucketRedirectRuleArgs'],
             routing_rule_condition: Optional[pulumi.Input['BucketRoutingRuleConditionArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("redirect_rule", redirect_rule)
        if routing_rule_condition is not None:
            _setter("routing_rule_condition", routing_rule_condition)

    @property
    @pulumi.getter(name="redirectRule")
    def redirect_rule(self) -> pulumi.Input['BucketRedirectRuleArgs']:
        """
        Container for redirect information. You can redirect requests to another host, to another page, or with another protocol. In the event of an error, you can specify a different error code to return.
        """
        return pulumi.get(self, "redirect_rule")

    @redirect_rule.setter
    def redirect_rule(self, value: pulumi.Input['BucketRedirectRuleArgs']):
        pulumi.set(self, "redirect_rule", value)

    @property
    @pulumi.getter(name="routingRuleCondition")
    def routing_rule_condition(self) -> Optional[pulumi.Input['BucketRoutingRuleConditionArgs']]:
        return pulumi.get(self, "routing_rule_condition")

    @routing_rule_condition.setter
    def routing_rule_condition(self, value: Optional[pulumi.Input['BucketRoutingRuleConditionArgs']]):
        pulumi.set(self, "routing_rule_condition", value)


@pulumi.input_type
class BucketRuleArgs:
    def __init__(__self__, *,
                 status: pulumi.Input['BucketRuleStatus'],
                 abort_incomplete_multipart_upload: Optional[pulumi.Input['BucketAbortIncompleteMultipartUploadArgs']] = None,
                 expiration_date: Optional[pulumi.Input[str]] = None,
                 expiration_in_days: Optional[pulumi.Input[int]] = None,
                 expired_object_delete_marker: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 noncurrent_version_expiration: Optional[pulumi.Input['BucketNoncurrentVersionExpirationArgs']] = None,
                 noncurrent_version_expiration_in_days: Optional[pulumi.Input[int]] = None,
                 noncurrent_version_transition: Optional[pulumi.Input['BucketNoncurrentVersionTransitionArgs']] = None,
                 noncurrent_version_transitions: Optional[pulumi.Input[Sequence[pulumi.Input['BucketNoncurrentVersionTransitionArgs']]]] = None,
                 object_size_greater_than: Optional[pulumi.Input[str]] = None,
                 object_size_less_than: Optional[pulumi.Input[str]] = None,
                 prefix: Optional[pulumi.Input[str]] = None,
                 tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input['BucketTagFilterArgs']]]] = None,
                 transition: Optional[pulumi.Input['BucketTransitionArgs']] = None,
                 transitions: Optional[pulumi.Input[Sequence[pulumi.Input['BucketTransitionArgs']]]] = None):
        """
        You must specify at least one of the following properties: AbortIncompleteMultipartUpload, ExpirationDate, ExpirationInDays, NoncurrentVersionExpirationInDays, NoncurrentVersionTransition, NoncurrentVersionTransitions, Transition, or Transitions.
        """
        BucketRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            status=status,
            abort_incomplete_multipart_upload=abort_incomplete_multipart_upload,
            expiration_date=expiration_date,
            expiration_in_days=expiration_in_days,
            expired_object_delete_marker=expired_object_delete_marker,
            id=id,
            noncurrent_version_expiration=noncurrent_version_expiration,
            noncurrent_version_expiration_in_days=noncurrent_version_expiration_in_days,
            noncurrent_version_transition=noncurrent_version_transition,
            noncurrent_version_transitions=noncurrent_version_transitions,
            object_size_greater_than=object_size_greater_than,
            object_size_less_than=object_size_less_than,
            prefix=prefix,
            tag_filters=tag_filters,
            transition=transition,
            transitions=transitions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             status: pulumi.Input['BucketRuleStatus'],
             abort_incomplete_multipart_upload: Optional[pulumi.Input['BucketAbortIncompleteMultipartUploadArgs']] = None,
             expiration_date: Optional[pulumi.Input[str]] = None,
             expiration_in_days: Optional[pulumi.Input[int]] = None,
             expired_object_delete_marker: Optional[pulumi.Input[bool]] = None,
             id: Optional[pulumi.Input[str]] = None,
             noncurrent_version_expiration: Optional[pulumi.Input['BucketNoncurrentVersionExpirationArgs']] = None,
             noncurrent_version_expiration_in_days: Optional[pulumi.Input[int]] = None,
             noncurrent_version_transition: Optional[pulumi.Input['BucketNoncurrentVersionTransitionArgs']] = None,
             noncurrent_version_transitions: Optional[pulumi.Input[Sequence[pulumi.Input['BucketNoncurrentVersionTransitionArgs']]]] = None,
             object_size_greater_than: Optional[pulumi.Input[str]] = None,
             object_size_less_than: Optional[pulumi.Input[str]] = None,
             prefix: Optional[pulumi.Input[str]] = None,
             tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input['BucketTagFilterArgs']]]] = None,
             transition: Optional[pulumi.Input['BucketTransitionArgs']] = None,
             transitions: Optional[pulumi.Input[Sequence[pulumi.Input['BucketTransitionArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("status", status)
        if abort_incomplete_multipart_upload is not None:
            _setter("abort_incomplete_multipart_upload", abort_incomplete_multipart_upload)
        if expiration_date is not None:
            _setter("expiration_date", expiration_date)
        if expiration_in_days is not None:
            _setter("expiration_in_days", expiration_in_days)
        if expired_object_delete_marker is not None:
            _setter("expired_object_delete_marker", expired_object_delete_marker)
        if id is not None:
            _setter("id", id)
        if noncurrent_version_expiration is not None:
            _setter("noncurrent_version_expiration", noncurrent_version_expiration)
        if noncurrent_version_expiration_in_days is not None:
            _setter("noncurrent_version_expiration_in_days", noncurrent_version_expiration_in_days)
        if noncurrent_version_transition is not None:
            _setter("noncurrent_version_transition", noncurrent_version_transition)
        if noncurrent_version_transitions is not None:
            _setter("noncurrent_version_transitions", noncurrent_version_transitions)
        if object_size_greater_than is not None:
            _setter("object_size_greater_than", object_size_greater_than)
        if object_size_less_than is not None:
            _setter("object_size_less_than", object_size_less_than)
        if prefix is not None:
            _setter("prefix", prefix)
        if tag_filters is not None:
            _setter("tag_filters", tag_filters)
        if transition is not None:
            _setter("transition", transition)
        if transitions is not None:
            _setter("transitions", transitions)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input['BucketRuleStatus']:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input['BucketRuleStatus']):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="abortIncompleteMultipartUpload")
    def abort_incomplete_multipart_upload(self) -> Optional[pulumi.Input['BucketAbortIncompleteMultipartUploadArgs']]:
        return pulumi.get(self, "abort_incomplete_multipart_upload")

    @abort_incomplete_multipart_upload.setter
    def abort_incomplete_multipart_upload(self, value: Optional[pulumi.Input['BucketAbortIncompleteMultipartUploadArgs']]):
        pulumi.set(self, "abort_incomplete_multipart_upload", value)

    @property
    @pulumi.getter(name="expirationDate")
    def expiration_date(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "expiration_date")

    @expiration_date.setter
    def expiration_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expiration_date", value)

    @property
    @pulumi.getter(name="expirationInDays")
    def expiration_in_days(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "expiration_in_days")

    @expiration_in_days.setter
    def expiration_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "expiration_in_days", value)

    @property
    @pulumi.getter(name="expiredObjectDeleteMarker")
    def expired_object_delete_marker(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "expired_object_delete_marker")

    @expired_object_delete_marker.setter
    def expired_object_delete_marker(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "expired_object_delete_marker", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="noncurrentVersionExpiration")
    def noncurrent_version_expiration(self) -> Optional[pulumi.Input['BucketNoncurrentVersionExpirationArgs']]:
        return pulumi.get(self, "noncurrent_version_expiration")

    @noncurrent_version_expiration.setter
    def noncurrent_version_expiration(self, value: Optional[pulumi.Input['BucketNoncurrentVersionExpirationArgs']]):
        pulumi.set(self, "noncurrent_version_expiration", value)

    @property
    @pulumi.getter(name="noncurrentVersionExpirationInDays")
    def noncurrent_version_expiration_in_days(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "noncurrent_version_expiration_in_days")

    @noncurrent_version_expiration_in_days.setter
    def noncurrent_version_expiration_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "noncurrent_version_expiration_in_days", value)

    @property
    @pulumi.getter(name="noncurrentVersionTransition")
    def noncurrent_version_transition(self) -> Optional[pulumi.Input['BucketNoncurrentVersionTransitionArgs']]:
        return pulumi.get(self, "noncurrent_version_transition")

    @noncurrent_version_transition.setter
    def noncurrent_version_transition(self, value: Optional[pulumi.Input['BucketNoncurrentVersionTransitionArgs']]):
        pulumi.set(self, "noncurrent_version_transition", value)

    @property
    @pulumi.getter(name="noncurrentVersionTransitions")
    def noncurrent_version_transitions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketNoncurrentVersionTransitionArgs']]]]:
        return pulumi.get(self, "noncurrent_version_transitions")

    @noncurrent_version_transitions.setter
    def noncurrent_version_transitions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketNoncurrentVersionTransitionArgs']]]]):
        pulumi.set(self, "noncurrent_version_transitions", value)

    @property
    @pulumi.getter(name="objectSizeGreaterThan")
    def object_size_greater_than(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "object_size_greater_than")

    @object_size_greater_than.setter
    def object_size_greater_than(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object_size_greater_than", value)

    @property
    @pulumi.getter(name="objectSizeLessThan")
    def object_size_less_than(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "object_size_less_than")

    @object_size_less_than.setter
    def object_size_less_than(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object_size_less_than", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketTagFilterArgs']]]]:
        return pulumi.get(self, "tag_filters")

    @tag_filters.setter
    def tag_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketTagFilterArgs']]]]):
        pulumi.set(self, "tag_filters", value)

    @property
    @pulumi.getter
    def transition(self) -> Optional[pulumi.Input['BucketTransitionArgs']]:
        return pulumi.get(self, "transition")

    @transition.setter
    def transition(self, value: Optional[pulumi.Input['BucketTransitionArgs']]):
        pulumi.set(self, "transition", value)

    @property
    @pulumi.getter
    def transitions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketTransitionArgs']]]]:
        return pulumi.get(self, "transitions")

    @transitions.setter
    def transitions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketTransitionArgs']]]]):
        pulumi.set(self, "transitions", value)


@pulumi.input_type
class BucketS3KeyFilterArgs:
    def __init__(__self__, *,
                 rules: pulumi.Input[Sequence[pulumi.Input['BucketFilterRuleArgs']]]):
        """
        A container for object key name prefix and suffix filtering rules.
        """
        BucketS3KeyFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rules=rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rules: pulumi.Input[Sequence[pulumi.Input['BucketFilterRuleArgs']]],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> pulumi.Input[Sequence[pulumi.Input['BucketFilterRuleArgs']]]:
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: pulumi.Input[Sequence[pulumi.Input['BucketFilterRuleArgs']]]):
        pulumi.set(self, "rules", value)


@pulumi.input_type
class BucketServerSideEncryptionByDefaultArgs:
    def __init__(__self__, *,
                 sse_algorithm: pulumi.Input['BucketServerSideEncryptionByDefaultSseAlgorithm'],
                 kms_master_key_id: Optional[pulumi.Input[str]] = None):
        """
        Specifies the default server-side encryption to apply to new objects in the bucket. If a PUT Object request doesn't specify any server-side encryption, this default encryption will be applied.
        :param pulumi.Input[str] kms_master_key_id: "KMSMasterKeyID" can only be used when you set the value of SSEAlgorithm as aws:kms or aws:kms:dsse.
        """
        BucketServerSideEncryptionByDefaultArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sse_algorithm=sse_algorithm,
            kms_master_key_id=kms_master_key_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sse_algorithm: pulumi.Input['BucketServerSideEncryptionByDefaultSseAlgorithm'],
             kms_master_key_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("sse_algorithm", sse_algorithm)
        if kms_master_key_id is not None:
            _setter("kms_master_key_id", kms_master_key_id)

    @property
    @pulumi.getter(name="sseAlgorithm")
    def sse_algorithm(self) -> pulumi.Input['BucketServerSideEncryptionByDefaultSseAlgorithm']:
        return pulumi.get(self, "sse_algorithm")

    @sse_algorithm.setter
    def sse_algorithm(self, value: pulumi.Input['BucketServerSideEncryptionByDefaultSseAlgorithm']):
        pulumi.set(self, "sse_algorithm", value)

    @property
    @pulumi.getter(name="kmsMasterKeyId")
    def kms_master_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        "KMSMasterKeyID" can only be used when you set the value of SSEAlgorithm as aws:kms or aws:kms:dsse.
        """
        return pulumi.get(self, "kms_master_key_id")

    @kms_master_key_id.setter
    def kms_master_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_master_key_id", value)


@pulumi.input_type
class BucketServerSideEncryptionRuleArgs:
    def __init__(__self__, *,
                 bucket_key_enabled: Optional[pulumi.Input[bool]] = None,
                 server_side_encryption_by_default: Optional[pulumi.Input['BucketServerSideEncryptionByDefaultArgs']] = None):
        """
        Specifies the default server-side encryption configuration.
        :param pulumi.Input[bool] bucket_key_enabled: Specifies whether Amazon S3 should use an S3 Bucket Key with server-side encryption using KMS (SSE-KMS) for new objects in the bucket. Existing objects are not affected. Setting the BucketKeyEnabled element to true causes Amazon S3 to use an S3 Bucket Key. By default, S3 Bucket Key is not enabled.
        """
        BucketServerSideEncryptionRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket_key_enabled=bucket_key_enabled,
            server_side_encryption_by_default=server_side_encryption_by_default,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket_key_enabled: Optional[pulumi.Input[bool]] = None,
             server_side_encryption_by_default: Optional[pulumi.Input['BucketServerSideEncryptionByDefaultArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bucket_key_enabled is not None:
            _setter("bucket_key_enabled", bucket_key_enabled)
        if server_side_encryption_by_default is not None:
            _setter("server_side_encryption_by_default", server_side_encryption_by_default)

    @property
    @pulumi.getter(name="bucketKeyEnabled")
    def bucket_key_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether Amazon S3 should use an S3 Bucket Key with server-side encryption using KMS (SSE-KMS) for new objects in the bucket. Existing objects are not affected. Setting the BucketKeyEnabled element to true causes Amazon S3 to use an S3 Bucket Key. By default, S3 Bucket Key is not enabled.
        """
        return pulumi.get(self, "bucket_key_enabled")

    @bucket_key_enabled.setter
    def bucket_key_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "bucket_key_enabled", value)

    @property
    @pulumi.getter(name="serverSideEncryptionByDefault")
    def server_side_encryption_by_default(self) -> Optional[pulumi.Input['BucketServerSideEncryptionByDefaultArgs']]:
        return pulumi.get(self, "server_side_encryption_by_default")

    @server_side_encryption_by_default.setter
    def server_side_encryption_by_default(self, value: Optional[pulumi.Input['BucketServerSideEncryptionByDefaultArgs']]):
        pulumi.set(self, "server_side_encryption_by_default", value)


@pulumi.input_type
class BucketSourceSelectionCriteriaArgs:
    def __init__(__self__, *,
                 replica_modifications: Optional[pulumi.Input['BucketReplicaModificationsArgs']] = None,
                 sse_kms_encrypted_objects: Optional[pulumi.Input['BucketSseKmsEncryptedObjectsArgs']] = None):
        """
        A container that describes additional filters for identifying the source objects that you want to replicate.
        :param pulumi.Input['BucketReplicaModificationsArgs'] replica_modifications: A filter that you can specify for selection for modifications on replicas.
        :param pulumi.Input['BucketSseKmsEncryptedObjectsArgs'] sse_kms_encrypted_objects: A container for filter information for the selection of Amazon S3 objects encrypted with AWS KMS.
        """
        BucketSourceSelectionCriteriaArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            replica_modifications=replica_modifications,
            sse_kms_encrypted_objects=sse_kms_encrypted_objects,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             replica_modifications: Optional[pulumi.Input['BucketReplicaModificationsArgs']] = None,
             sse_kms_encrypted_objects: Optional[pulumi.Input['BucketSseKmsEncryptedObjectsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if replica_modifications is not None:
            _setter("replica_modifications", replica_modifications)
        if sse_kms_encrypted_objects is not None:
            _setter("sse_kms_encrypted_objects", sse_kms_encrypted_objects)

    @property
    @pulumi.getter(name="replicaModifications")
    def replica_modifications(self) -> Optional[pulumi.Input['BucketReplicaModificationsArgs']]:
        """
        A filter that you can specify for selection for modifications on replicas.
        """
        return pulumi.get(self, "replica_modifications")

    @replica_modifications.setter
    def replica_modifications(self, value: Optional[pulumi.Input['BucketReplicaModificationsArgs']]):
        pulumi.set(self, "replica_modifications", value)

    @property
    @pulumi.getter(name="sseKmsEncryptedObjects")
    def sse_kms_encrypted_objects(self) -> Optional[pulumi.Input['BucketSseKmsEncryptedObjectsArgs']]:
        """
        A container for filter information for the selection of Amazon S3 objects encrypted with AWS KMS.
        """
        return pulumi.get(self, "sse_kms_encrypted_objects")

    @sse_kms_encrypted_objects.setter
    def sse_kms_encrypted_objects(self, value: Optional[pulumi.Input['BucketSseKmsEncryptedObjectsArgs']]):
        pulumi.set(self, "sse_kms_encrypted_objects", value)


@pulumi.input_type
class BucketSseKmsEncryptedObjectsArgs:
    def __init__(__self__, *,
                 status: pulumi.Input['BucketSseKmsEncryptedObjectsStatus']):
        """
        A container for filter information for the selection of S3 objects encrypted with AWS KMS.
        :param pulumi.Input['BucketSseKmsEncryptedObjectsStatus'] status: Specifies whether Amazon S3 replicates objects created with server-side encryption using a customer master key (CMK) stored in AWS Key Management Service.
        """
        BucketSseKmsEncryptedObjectsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             status: pulumi.Input['BucketSseKmsEncryptedObjectsStatus'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("status", status)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input['BucketSseKmsEncryptedObjectsStatus']:
        """
        Specifies whether Amazon S3 replicates objects created with server-side encryption using a customer master key (CMK) stored in AWS Key Management Service.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input['BucketSseKmsEncryptedObjectsStatus']):
        pulumi.set(self, "status", value)


@pulumi.input_type
class BucketStorageClassAnalysisArgs:
    def __init__(__self__, *,
                 data_export: Optional[pulumi.Input['BucketDataExportArgs']] = None):
        """
        Specifies data related to access patterns to be collected and made available to analyze the tradeoffs between different storage classes for an Amazon S3 bucket.
        """
        BucketStorageClassAnalysisArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_export=data_export,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_export: Optional[pulumi.Input['BucketDataExportArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if data_export is not None:
            _setter("data_export", data_export)

    @property
    @pulumi.getter(name="dataExport")
    def data_export(self) -> Optional[pulumi.Input['BucketDataExportArgs']]:
        return pulumi.get(self, "data_export")

    @data_export.setter
    def data_export(self, value: Optional[pulumi.Input['BucketDataExportArgs']]):
        pulumi.set(self, "data_export", value)


@pulumi.input_type
class BucketTagFilterArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        Tags to use to identify a subset of objects for an Amazon S3 bucket.
        """
        BucketTagFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: pulumi.Input[str],
             value: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class BucketTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        BucketTagArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: pulumi.Input[str],
             value: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class BucketTieringArgs:
    def __init__(__self__, *,
                 access_tier: pulumi.Input['BucketTieringAccessTier'],
                 days: pulumi.Input[int]):
        """
        :param pulumi.Input['BucketTieringAccessTier'] access_tier: S3 Intelligent-Tiering access tier. See Storage class for automatically optimizing frequently and infrequently accessed objects for a list of access tiers in the S3 Intelligent-Tiering storage class.
        :param pulumi.Input[int] days: The number of consecutive days of no access after which an object will be eligible to be transitioned to the corresponding tier. The minimum number of days specified for Archive Access tier must be at least 90 days and Deep Archive Access tier must be at least 180 days. The maximum can be up to 2 years (730 days).
        """
        BucketTieringArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_tier=access_tier,
            days=days,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_tier: pulumi.Input['BucketTieringAccessTier'],
             days: pulumi.Input[int],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("access_tier", access_tier)
        _setter("days", days)

    @property
    @pulumi.getter(name="accessTier")
    def access_tier(self) -> pulumi.Input['BucketTieringAccessTier']:
        """
        S3 Intelligent-Tiering access tier. See Storage class for automatically optimizing frequently and infrequently accessed objects for a list of access tiers in the S3 Intelligent-Tiering storage class.
        """
        return pulumi.get(self, "access_tier")

    @access_tier.setter
    def access_tier(self, value: pulumi.Input['BucketTieringAccessTier']):
        pulumi.set(self, "access_tier", value)

    @property
    @pulumi.getter
    def days(self) -> pulumi.Input[int]:
        """
        The number of consecutive days of no access after which an object will be eligible to be transitioned to the corresponding tier. The minimum number of days specified for Archive Access tier must be at least 90 days and Deep Archive Access tier must be at least 180 days. The maximum can be up to 2 years (730 days).
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: pulumi.Input[int]):
        pulumi.set(self, "days", value)


@pulumi.input_type
class BucketTopicConfigurationArgs:
    def __init__(__self__, *,
                 event: pulumi.Input[str],
                 topic: pulumi.Input[str],
                 filter: Optional[pulumi.Input['BucketNotificationFilterArgs']] = None):
        """
        The topic to which notifications are sent and the events for which notifications are generated.
        :param pulumi.Input[str] event: The Amazon S3 bucket event about which to send notifications.
        :param pulumi.Input[str] topic: The Amazon Resource Name (ARN) of the Amazon SNS topic to which Amazon S3 publishes a message when it detects events of the specified type.
        :param pulumi.Input['BucketNotificationFilterArgs'] filter: The filtering rules that determine for which objects to send notifications.
        """
        BucketTopicConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            event=event,
            topic=topic,
            filter=filter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             event: pulumi.Input[str],
             topic: pulumi.Input[str],
             filter: Optional[pulumi.Input['BucketNotificationFilterArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("event", event)
        _setter("topic", topic)
        if filter is not None:
            _setter("filter", filter)

    @property
    @pulumi.getter
    def event(self) -> pulumi.Input[str]:
        """
        The Amazon S3 bucket event about which to send notifications.
        """
        return pulumi.get(self, "event")

    @event.setter
    def event(self, value: pulumi.Input[str]):
        pulumi.set(self, "event", value)

    @property
    @pulumi.getter
    def topic(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the Amazon SNS topic to which Amazon S3 publishes a message when it detects events of the specified type.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: pulumi.Input[str]):
        pulumi.set(self, "topic", value)

    @property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input['BucketNotificationFilterArgs']]:
        """
        The filtering rules that determine for which objects to send notifications.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input['BucketNotificationFilterArgs']]):
        pulumi.set(self, "filter", value)


@pulumi.input_type
class BucketTransitionArgs:
    def __init__(__self__, *,
                 storage_class: pulumi.Input['BucketTransitionStorageClass'],
                 transition_date: Optional[pulumi.Input[str]] = None,
                 transition_in_days: Optional[pulumi.Input[int]] = None):
        """
        You must specify at least one of "TransitionDate" and "TransitionInDays"
        """
        BucketTransitionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            storage_class=storage_class,
            transition_date=transition_date,
            transition_in_days=transition_in_days,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             storage_class: pulumi.Input['BucketTransitionStorageClass'],
             transition_date: Optional[pulumi.Input[str]] = None,
             transition_in_days: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("storage_class", storage_class)
        if transition_date is not None:
            _setter("transition_date", transition_date)
        if transition_in_days is not None:
            _setter("transition_in_days", transition_in_days)

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> pulumi.Input['BucketTransitionStorageClass']:
        return pulumi.get(self, "storage_class")

    @storage_class.setter
    def storage_class(self, value: pulumi.Input['BucketTransitionStorageClass']):
        pulumi.set(self, "storage_class", value)

    @property
    @pulumi.getter(name="transitionDate")
    def transition_date(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "transition_date")

    @transition_date.setter
    def transition_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "transition_date", value)

    @property
    @pulumi.getter(name="transitionInDays")
    def transition_in_days(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "transition_in_days")

    @transition_in_days.setter
    def transition_in_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "transition_in_days", value)


@pulumi.input_type
class BucketVersioningConfigurationArgs:
    def __init__(__self__, *,
                 status: pulumi.Input['BucketVersioningConfigurationStatus']):
        """
        Describes the versioning state of an Amazon S3 bucket.
        :param pulumi.Input['BucketVersioningConfigurationStatus'] status: The versioning state of the bucket.
        """
        BucketVersioningConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             status: pulumi.Input['BucketVersioningConfigurationStatus'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("status", status)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input['BucketVersioningConfigurationStatus']:
        """
        The versioning state of the bucket.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input['BucketVersioningConfigurationStatus']):
        pulumi.set(self, "status", value)


@pulumi.input_type
class BucketWebsiteConfigurationArgs:
    def __init__(__self__, *,
                 error_document: Optional[pulumi.Input[str]] = None,
                 index_document: Optional[pulumi.Input[str]] = None,
                 redirect_all_requests_to: Optional[pulumi.Input['BucketRedirectAllRequestsToArgs']] = None,
                 routing_rules: Optional[pulumi.Input[Sequence[pulumi.Input['BucketRoutingRuleArgs']]]] = None):
        """
        Specifies website configuration parameters for an Amazon S3 bucket.
        :param pulumi.Input[str] error_document: The name of the error document for the website.
        :param pulumi.Input[str] index_document: The name of the index document for the website.
        """
        BucketWebsiteConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            error_document=error_document,
            index_document=index_document,
            redirect_all_requests_to=redirect_all_requests_to,
            routing_rules=routing_rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             error_document: Optional[pulumi.Input[str]] = None,
             index_document: Optional[pulumi.Input[str]] = None,
             redirect_all_requests_to: Optional[pulumi.Input['BucketRedirectAllRequestsToArgs']] = None,
             routing_rules: Optional[pulumi.Input[Sequence[pulumi.Input['BucketRoutingRuleArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if error_document is not None:
            _setter("error_document", error_document)
        if index_document is not None:
            _setter("index_document", index_document)
        if redirect_all_requests_to is not None:
            _setter("redirect_all_requests_to", redirect_all_requests_to)
        if routing_rules is not None:
            _setter("routing_rules", routing_rules)

    @property
    @pulumi.getter(name="errorDocument")
    def error_document(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the error document for the website.
        """
        return pulumi.get(self, "error_document")

    @error_document.setter
    def error_document(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "error_document", value)

    @property
    @pulumi.getter(name="indexDocument")
    def index_document(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the index document for the website.
        """
        return pulumi.get(self, "index_document")

    @index_document.setter
    def index_document(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "index_document", value)

    @property
    @pulumi.getter(name="redirectAllRequestsTo")
    def redirect_all_requests_to(self) -> Optional[pulumi.Input['BucketRedirectAllRequestsToArgs']]:
        return pulumi.get(self, "redirect_all_requests_to")

    @redirect_all_requests_to.setter
    def redirect_all_requests_to(self, value: Optional[pulumi.Input['BucketRedirectAllRequestsToArgs']]):
        pulumi.set(self, "redirect_all_requests_to", value)

    @property
    @pulumi.getter(name="routingRules")
    def routing_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketRoutingRuleArgs']]]]:
        return pulumi.get(self, "routing_rules")

    @routing_rules.setter
    def routing_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketRoutingRuleArgs']]]]):
        pulumi.set(self, "routing_rules", value)


@pulumi.input_type
class MultiRegionAccessPointPublicAccessBlockConfigurationArgs:
    def __init__(__self__, *,
                 block_public_acls: Optional[pulumi.Input[bool]] = None,
                 block_public_policy: Optional[pulumi.Input[bool]] = None,
                 ignore_public_acls: Optional[pulumi.Input[bool]] = None,
                 restrict_public_buckets: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] block_public_acls: Specifies whether Amazon S3 should block public access control lists (ACLs) for buckets in this account. Setting this element to TRUE causes the following behavior:
               - PUT Bucket acl and PUT Object acl calls fail if the specified ACL is public.
                - PUT Object calls fail if the request includes a public ACL.
               . - PUT Bucket calls fail if the request includes a public ACL.
               Enabling this setting doesn't affect existing policies or ACLs.
        :param pulumi.Input[bool] block_public_policy: Specifies whether Amazon S3 should block public bucket policies for buckets in this account. Setting this element to TRUE causes Amazon S3 to reject calls to PUT Bucket policy if the specified bucket policy allows public access. Enabling this setting doesn't affect existing bucket policies.
        :param pulumi.Input[bool] ignore_public_acls: Specifies whether Amazon S3 should ignore public ACLs for buckets in this account. Setting this element to TRUE causes Amazon S3 to ignore all public ACLs on buckets in this account and any objects that they contain. Enabling this setting doesn't affect the persistence of any existing ACLs and doesn't prevent new public ACLs from being set.
        :param pulumi.Input[bool] restrict_public_buckets: Specifies whether Amazon S3 should restrict public bucket policies for this bucket. Setting this element to TRUE restricts access to this bucket to only AWS services and authorized users within this account if the bucket has a public policy.
               Enabling this setting doesn't affect previously stored bucket policies, except that public and cross-account access within any public bucket policy, including non-public delegation to specific accounts, is blocked.
        """
        MultiRegionAccessPointPublicAccessBlockConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            block_public_acls=block_public_acls,
            block_public_policy=block_public_policy,
            ignore_public_acls=ignore_public_acls,
            restrict_public_buckets=restrict_public_buckets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             block_public_acls: Optional[pulumi.Input[bool]] = None,
             block_public_policy: Optional[pulumi.Input[bool]] = None,
             ignore_public_acls: Optional[pulumi.Input[bool]] = None,
             restrict_public_buckets: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if block_public_acls is not None:
            _setter("block_public_acls", block_public_acls)
        if block_public_policy is not None:
            _setter("block_public_policy", block_public_policy)
        if ignore_public_acls is not None:
            _setter("ignore_public_acls", ignore_public_acls)
        if restrict_public_buckets is not None:
            _setter("restrict_public_buckets", restrict_public_buckets)

    @property
    @pulumi.getter(name="blockPublicAcls")
    def block_public_acls(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether Amazon S3 should block public access control lists (ACLs) for buckets in this account. Setting this element to TRUE causes the following behavior:
        - PUT Bucket acl and PUT Object acl calls fail if the specified ACL is public.
         - PUT Object calls fail if the request includes a public ACL.
        . - PUT Bucket calls fail if the request includes a public ACL.
        Enabling this setting doesn't affect existing policies or ACLs.
        """
        return pulumi.get(self, "block_public_acls")

    @block_public_acls.setter
    def block_public_acls(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "block_public_acls", value)

    @property
    @pulumi.getter(name="blockPublicPolicy")
    def block_public_policy(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether Amazon S3 should block public bucket policies for buckets in this account. Setting this element to TRUE causes Amazon S3 to reject calls to PUT Bucket policy if the specified bucket policy allows public access. Enabling this setting doesn't affect existing bucket policies.
        """
        return pulumi.get(self, "block_public_policy")

    @block_public_policy.setter
    def block_public_policy(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "block_public_policy", value)

    @property
    @pulumi.getter(name="ignorePublicAcls")
    def ignore_public_acls(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether Amazon S3 should ignore public ACLs for buckets in this account. Setting this element to TRUE causes Amazon S3 to ignore all public ACLs on buckets in this account and any objects that they contain. Enabling this setting doesn't affect the persistence of any existing ACLs and doesn't prevent new public ACLs from being set.
        """
        return pulumi.get(self, "ignore_public_acls")

    @ignore_public_acls.setter
    def ignore_public_acls(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_public_acls", value)

    @property
    @pulumi.getter(name="restrictPublicBuckets")
    def restrict_public_buckets(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether Amazon S3 should restrict public bucket policies for this bucket. Setting this element to TRUE restricts access to this bucket to only AWS services and authorized users within this account if the bucket has a public policy.
        Enabling this setting doesn't affect previously stored bucket policies, except that public and cross-account access within any public bucket policy, including non-public delegation to specific accounts, is blocked.
        """
        return pulumi.get(self, "restrict_public_buckets")

    @restrict_public_buckets.setter
    def restrict_public_buckets(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "restrict_public_buckets", value)


@pulumi.input_type
class MultiRegionAccessPointRegionArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 bucket_account_id: Optional[pulumi.Input[str]] = None):
        MultiRegionAccessPointRegionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket=bucket,
            bucket_account_id=bucket_account_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket: pulumi.Input[str],
             bucket_account_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("bucket", bucket)
        if bucket_account_id is not None:
            _setter("bucket_account_id", bucket_account_id)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter(name="bucketAccountId")
    def bucket_account_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "bucket_account_id")

    @bucket_account_id.setter
    def bucket_account_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket_account_id", value)


@pulumi.input_type
class StorageLensAccountLevelArgs:
    def __init__(__self__, *,
                 bucket_level: pulumi.Input['StorageLensBucketLevelArgs'],
                 activity_metrics: Optional[pulumi.Input['StorageLensActivityMetricsArgs']] = None,
                 advanced_cost_optimization_metrics: Optional[pulumi.Input['StorageLensAdvancedCostOptimizationMetricsArgs']] = None,
                 advanced_data_protection_metrics: Optional[pulumi.Input['StorageLensAdvancedDataProtectionMetricsArgs']] = None,
                 detailed_status_codes_metrics: Optional[pulumi.Input['StorageLensDetailedStatusCodesMetricsArgs']] = None):
        """
        Account-level metrics configurations.
        """
        StorageLensAccountLevelArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket_level=bucket_level,
            activity_metrics=activity_metrics,
            advanced_cost_optimization_metrics=advanced_cost_optimization_metrics,
            advanced_data_protection_metrics=advanced_data_protection_metrics,
            detailed_status_codes_metrics=detailed_status_codes_metrics,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket_level: pulumi.Input['StorageLensBucketLevelArgs'],
             activity_metrics: Optional[pulumi.Input['StorageLensActivityMetricsArgs']] = None,
             advanced_cost_optimization_metrics: Optional[pulumi.Input['StorageLensAdvancedCostOptimizationMetricsArgs']] = None,
             advanced_data_protection_metrics: Optional[pulumi.Input['StorageLensAdvancedDataProtectionMetricsArgs']] = None,
             detailed_status_codes_metrics: Optional[pulumi.Input['StorageLensDetailedStatusCodesMetricsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("bucket_level", bucket_level)
        if activity_metrics is not None:
            _setter("activity_metrics", activity_metrics)
        if advanced_cost_optimization_metrics is not None:
            _setter("advanced_cost_optimization_metrics", advanced_cost_optimization_metrics)
        if advanced_data_protection_metrics is not None:
            _setter("advanced_data_protection_metrics", advanced_data_protection_metrics)
        if detailed_status_codes_metrics is not None:
            _setter("detailed_status_codes_metrics", detailed_status_codes_metrics)

    @property
    @pulumi.getter(name="bucketLevel")
    def bucket_level(self) -> pulumi.Input['StorageLensBucketLevelArgs']:
        return pulumi.get(self, "bucket_level")

    @bucket_level.setter
    def bucket_level(self, value: pulumi.Input['StorageLensBucketLevelArgs']):
        pulumi.set(self, "bucket_level", value)

    @property
    @pulumi.getter(name="activityMetrics")
    def activity_metrics(self) -> Optional[pulumi.Input['StorageLensActivityMetricsArgs']]:
        return pulumi.get(self, "activity_metrics")

    @activity_metrics.setter
    def activity_metrics(self, value: Optional[pulumi.Input['StorageLensActivityMetricsArgs']]):
        pulumi.set(self, "activity_metrics", value)

    @property
    @pulumi.getter(name="advancedCostOptimizationMetrics")
    def advanced_cost_optimization_metrics(self) -> Optional[pulumi.Input['StorageLensAdvancedCostOptimizationMetricsArgs']]:
        return pulumi.get(self, "advanced_cost_optimization_metrics")

    @advanced_cost_optimization_metrics.setter
    def advanced_cost_optimization_metrics(self, value: Optional[pulumi.Input['StorageLensAdvancedCostOptimizationMetricsArgs']]):
        pulumi.set(self, "advanced_cost_optimization_metrics", value)

    @property
    @pulumi.getter(name="advancedDataProtectionMetrics")
    def advanced_data_protection_metrics(self) -> Optional[pulumi.Input['StorageLensAdvancedDataProtectionMetricsArgs']]:
        return pulumi.get(self, "advanced_data_protection_metrics")

    @advanced_data_protection_metrics.setter
    def advanced_data_protection_metrics(self, value: Optional[pulumi.Input['StorageLensAdvancedDataProtectionMetricsArgs']]):
        pulumi.set(self, "advanced_data_protection_metrics", value)

    @property
    @pulumi.getter(name="detailedStatusCodesMetrics")
    def detailed_status_codes_metrics(self) -> Optional[pulumi.Input['StorageLensDetailedStatusCodesMetricsArgs']]:
        return pulumi.get(self, "detailed_status_codes_metrics")

    @detailed_status_codes_metrics.setter
    def detailed_status_codes_metrics(self, value: Optional[pulumi.Input['StorageLensDetailedStatusCodesMetricsArgs']]):
        pulumi.set(self, "detailed_status_codes_metrics", value)


@pulumi.input_type
class StorageLensActivityMetricsArgs:
    def __init__(__self__, *,
                 is_enabled: Optional[pulumi.Input[bool]] = None):
        """
        Enables activity metrics.
        :param pulumi.Input[bool] is_enabled: Specifies whether activity metrics are enabled or disabled.
        """
        StorageLensActivityMetricsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_enabled=is_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_enabled: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether activity metrics are enabled or disabled.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)


@pulumi.input_type
class StorageLensAdvancedCostOptimizationMetricsArgs:
    def __init__(__self__, *,
                 is_enabled: Optional[pulumi.Input[bool]] = None):
        """
        Enables advanced cost optimization metrics.
        :param pulumi.Input[bool] is_enabled: Specifies whether advanced cost optimization metrics are enabled or disabled.
        """
        StorageLensAdvancedCostOptimizationMetricsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_enabled=is_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_enabled: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether advanced cost optimization metrics are enabled or disabled.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)


@pulumi.input_type
class StorageLensAdvancedDataProtectionMetricsArgs:
    def __init__(__self__, *,
                 is_enabled: Optional[pulumi.Input[bool]] = None):
        """
        Enables advanced data protection metrics.
        :param pulumi.Input[bool] is_enabled: Specifies whether advanced data protection metrics are enabled or disabled.
        """
        StorageLensAdvancedDataProtectionMetricsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_enabled=is_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_enabled: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether advanced data protection metrics are enabled or disabled.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)


@pulumi.input_type
class StorageLensAwsOrgArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str]):
        """
        The AWS Organizations ARN to use in the Amazon S3 Storage Lens configuration.
        """
        StorageLensAwsOrgArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("arn", arn)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)


@pulumi.input_type
class StorageLensBucketLevelArgs:
    def __init__(__self__, *,
                 activity_metrics: Optional[pulumi.Input['StorageLensActivityMetricsArgs']] = None,
                 advanced_cost_optimization_metrics: Optional[pulumi.Input['StorageLensAdvancedCostOptimizationMetricsArgs']] = None,
                 advanced_data_protection_metrics: Optional[pulumi.Input['StorageLensAdvancedDataProtectionMetricsArgs']] = None,
                 detailed_status_codes_metrics: Optional[pulumi.Input['StorageLensDetailedStatusCodesMetricsArgs']] = None,
                 prefix_level: Optional[pulumi.Input['StorageLensPrefixLevelArgs']] = None):
        """
        Bucket-level metrics configurations.
        """
        StorageLensBucketLevelArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            activity_metrics=activity_metrics,
            advanced_cost_optimization_metrics=advanced_cost_optimization_metrics,
            advanced_data_protection_metrics=advanced_data_protection_metrics,
            detailed_status_codes_metrics=detailed_status_codes_metrics,
            prefix_level=prefix_level,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             activity_metrics: Optional[pulumi.Input['StorageLensActivityMetricsArgs']] = None,
             advanced_cost_optimization_metrics: Optional[pulumi.Input['StorageLensAdvancedCostOptimizationMetricsArgs']] = None,
             advanced_data_protection_metrics: Optional[pulumi.Input['StorageLensAdvancedDataProtectionMetricsArgs']] = None,
             detailed_status_codes_metrics: Optional[pulumi.Input['StorageLensDetailedStatusCodesMetricsArgs']] = None,
             prefix_level: Optional[pulumi.Input['StorageLensPrefixLevelArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if activity_metrics is not None:
            _setter("activity_metrics", activity_metrics)
        if advanced_cost_optimization_metrics is not None:
            _setter("advanced_cost_optimization_metrics", advanced_cost_optimization_metrics)
        if advanced_data_protection_metrics is not None:
            _setter("advanced_data_protection_metrics", advanced_data_protection_metrics)
        if detailed_status_codes_metrics is not None:
            _setter("detailed_status_codes_metrics", detailed_status_codes_metrics)
        if prefix_level is not None:
            _setter("prefix_level", prefix_level)

    @property
    @pulumi.getter(name="activityMetrics")
    def activity_metrics(self) -> Optional[pulumi.Input['StorageLensActivityMetricsArgs']]:
        return pulumi.get(self, "activity_metrics")

    @activity_metrics.setter
    def activity_metrics(self, value: Optional[pulumi.Input['StorageLensActivityMetricsArgs']]):
        pulumi.set(self, "activity_metrics", value)

    @property
    @pulumi.getter(name="advancedCostOptimizationMetrics")
    def advanced_cost_optimization_metrics(self) -> Optional[pulumi.Input['StorageLensAdvancedCostOptimizationMetricsArgs']]:
        return pulumi.get(self, "advanced_cost_optimization_metrics")

    @advanced_cost_optimization_metrics.setter
    def advanced_cost_optimization_metrics(self, value: Optional[pulumi.Input['StorageLensAdvancedCostOptimizationMetricsArgs']]):
        pulumi.set(self, "advanced_cost_optimization_metrics", value)

    @property
    @pulumi.getter(name="advancedDataProtectionMetrics")
    def advanced_data_protection_metrics(self) -> Optional[pulumi.Input['StorageLensAdvancedDataProtectionMetricsArgs']]:
        return pulumi.get(self, "advanced_data_protection_metrics")

    @advanced_data_protection_metrics.setter
    def advanced_data_protection_metrics(self, value: Optional[pulumi.Input['StorageLensAdvancedDataProtectionMetricsArgs']]):
        pulumi.set(self, "advanced_data_protection_metrics", value)

    @property
    @pulumi.getter(name="detailedStatusCodesMetrics")
    def detailed_status_codes_metrics(self) -> Optional[pulumi.Input['StorageLensDetailedStatusCodesMetricsArgs']]:
        return pulumi.get(self, "detailed_status_codes_metrics")

    @detailed_status_codes_metrics.setter
    def detailed_status_codes_metrics(self, value: Optional[pulumi.Input['StorageLensDetailedStatusCodesMetricsArgs']]):
        pulumi.set(self, "detailed_status_codes_metrics", value)

    @property
    @pulumi.getter(name="prefixLevel")
    def prefix_level(self) -> Optional[pulumi.Input['StorageLensPrefixLevelArgs']]:
        return pulumi.get(self, "prefix_level")

    @prefix_level.setter
    def prefix_level(self, value: Optional[pulumi.Input['StorageLensPrefixLevelArgs']]):
        pulumi.set(self, "prefix_level", value)


@pulumi.input_type
class StorageLensBucketsAndRegionsArgs:
    def __init__(__self__, *,
                 buckets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        S3 buckets and Regions to include/exclude in the Amazon S3 Storage Lens configuration.
        """
        StorageLensBucketsAndRegionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            buckets=buckets,
            regions=regions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             buckets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if buckets is not None:
            _setter("buckets", buckets)
        if regions is not None:
            _setter("regions", regions)

    @property
    @pulumi.getter
    def buckets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "buckets")

    @buckets.setter
    def buckets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "buckets", value)

    @property
    @pulumi.getter
    def regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "regions")

    @regions.setter
    def regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "regions", value)


@pulumi.input_type
class StorageLensCloudWatchMetricsArgs:
    def __init__(__self__, *,
                 is_enabled: pulumi.Input[bool]):
        """
        CloudWatch metrics settings for the Amazon S3 Storage Lens metrics export.
        :param pulumi.Input[bool] is_enabled: Specifies whether CloudWatch metrics are enabled or disabled.
        """
        StorageLensCloudWatchMetricsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_enabled=is_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_enabled: pulumi.Input[bool],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("is_enabled", is_enabled)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> pulumi.Input[bool]:
        """
        Specifies whether CloudWatch metrics are enabled or disabled.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_enabled", value)


@pulumi.input_type
class StorageLensConfigurationArgs:
    def __init__(__self__, *,
                 account_level: pulumi.Input['StorageLensAccountLevelArgs'],
                 id: pulumi.Input[str],
                 is_enabled: pulumi.Input[bool],
                 aws_org: Optional[pulumi.Input['StorageLensAwsOrgArgs']] = None,
                 data_export: Optional[pulumi.Input['StorageLensDataExportArgs']] = None,
                 exclude: Optional[pulumi.Input['StorageLensBucketsAndRegionsArgs']] = None,
                 include: Optional[pulumi.Input['StorageLensBucketsAndRegionsArgs']] = None,
                 storage_lens_arn: Optional[pulumi.Input[str]] = None):
        """
        Specifies the details of Amazon S3 Storage Lens configuration.
        :param pulumi.Input[bool] is_enabled: Specifies whether the Amazon S3 Storage Lens configuration is enabled or disabled.
        :param pulumi.Input[str] storage_lens_arn: The ARN for the Amazon S3 Storage Lens configuration.
        """
        StorageLensConfigurationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            account_level=account_level,
            id=id,
            is_enabled=is_enabled,
            aws_org=aws_org,
            data_export=data_export,
            exclude=exclude,
            include=include,
            storage_lens_arn=storage_lens_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             account_level: pulumi.Input['StorageLensAccountLevelArgs'],
             id: pulumi.Input[str],
             is_enabled: pulumi.Input[bool],
             aws_org: Optional[pulumi.Input['StorageLensAwsOrgArgs']] = None,
             data_export: Optional[pulumi.Input['StorageLensDataExportArgs']] = None,
             exclude: Optional[pulumi.Input['StorageLensBucketsAndRegionsArgs']] = None,
             include: Optional[pulumi.Input['StorageLensBucketsAndRegionsArgs']] = None,
             storage_lens_arn: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("account_level", account_level)
        _setter("id", id)
        _setter("is_enabled", is_enabled)
        if aws_org is not None:
            _setter("aws_org", aws_org)
        if data_export is not None:
            _setter("data_export", data_export)
        if exclude is not None:
            _setter("exclude", exclude)
        if include is not None:
            _setter("include", include)
        if storage_lens_arn is not None:
            _setter("storage_lens_arn", storage_lens_arn)

    @property
    @pulumi.getter(name="accountLevel")
    def account_level(self) -> pulumi.Input['StorageLensAccountLevelArgs']:
        return pulumi.get(self, "account_level")

    @account_level.setter
    def account_level(self, value: pulumi.Input['StorageLensAccountLevelArgs']):
        pulumi.set(self, "account_level", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> pulumi.Input[bool]:
        """
        Specifies whether the Amazon S3 Storage Lens configuration is enabled or disabled.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="awsOrg")
    def aws_org(self) -> Optional[pulumi.Input['StorageLensAwsOrgArgs']]:
        return pulumi.get(self, "aws_org")

    @aws_org.setter
    def aws_org(self, value: Optional[pulumi.Input['StorageLensAwsOrgArgs']]):
        pulumi.set(self, "aws_org", value)

    @property
    @pulumi.getter(name="dataExport")
    def data_export(self) -> Optional[pulumi.Input['StorageLensDataExportArgs']]:
        return pulumi.get(self, "data_export")

    @data_export.setter
    def data_export(self, value: Optional[pulumi.Input['StorageLensDataExportArgs']]):
        pulumi.set(self, "data_export", value)

    @property
    @pulumi.getter
    def exclude(self) -> Optional[pulumi.Input['StorageLensBucketsAndRegionsArgs']]:
        return pulumi.get(self, "exclude")

    @exclude.setter
    def exclude(self, value: Optional[pulumi.Input['StorageLensBucketsAndRegionsArgs']]):
        pulumi.set(self, "exclude", value)

    @property
    @pulumi.getter
    def include(self) -> Optional[pulumi.Input['StorageLensBucketsAndRegionsArgs']]:
        return pulumi.get(self, "include")

    @include.setter
    def include(self, value: Optional[pulumi.Input['StorageLensBucketsAndRegionsArgs']]):
        pulumi.set(self, "include", value)

    @property
    @pulumi.getter(name="storageLensArn")
    def storage_lens_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The ARN for the Amazon S3 Storage Lens configuration.
        """
        return pulumi.get(self, "storage_lens_arn")

    @storage_lens_arn.setter
    def storage_lens_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_lens_arn", value)


@pulumi.input_type
class StorageLensDataExportArgs:
    def __init__(__self__, *,
                 cloud_watch_metrics: Optional[pulumi.Input['StorageLensCloudWatchMetricsArgs']] = None,
                 s3_bucket_destination: Optional[pulumi.Input['StorageLensS3BucketDestinationArgs']] = None):
        """
        Specifies how Amazon S3 Storage Lens metrics should be exported.
        """
        StorageLensDataExportArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_watch_metrics=cloud_watch_metrics,
            s3_bucket_destination=s3_bucket_destination,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_watch_metrics: Optional[pulumi.Input['StorageLensCloudWatchMetricsArgs']] = None,
             s3_bucket_destination: Optional[pulumi.Input['StorageLensS3BucketDestinationArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cloud_watch_metrics is not None:
            _setter("cloud_watch_metrics", cloud_watch_metrics)
        if s3_bucket_destination is not None:
            _setter("s3_bucket_destination", s3_bucket_destination)

    @property
    @pulumi.getter(name="cloudWatchMetrics")
    def cloud_watch_metrics(self) -> Optional[pulumi.Input['StorageLensCloudWatchMetricsArgs']]:
        return pulumi.get(self, "cloud_watch_metrics")

    @cloud_watch_metrics.setter
    def cloud_watch_metrics(self, value: Optional[pulumi.Input['StorageLensCloudWatchMetricsArgs']]):
        pulumi.set(self, "cloud_watch_metrics", value)

    @property
    @pulumi.getter(name="s3BucketDestination")
    def s3_bucket_destination(self) -> Optional[pulumi.Input['StorageLensS3BucketDestinationArgs']]:
        return pulumi.get(self, "s3_bucket_destination")

    @s3_bucket_destination.setter
    def s3_bucket_destination(self, value: Optional[pulumi.Input['StorageLensS3BucketDestinationArgs']]):
        pulumi.set(self, "s3_bucket_destination", value)


@pulumi.input_type
class StorageLensDetailedStatusCodesMetricsArgs:
    def __init__(__self__, *,
                 is_enabled: Optional[pulumi.Input[bool]] = None):
        """
        Enables detailed status codes metrics.
        :param pulumi.Input[bool] is_enabled: Specifies whether detailed status codes metrics are enabled or disabled.
        """
        StorageLensDetailedStatusCodesMetricsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_enabled=is_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_enabled: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether detailed status codes metrics are enabled or disabled.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)


@pulumi.input_type
class StorageLensEncryptionArgs:
    def __init__(__self__):
        """
        Configures the server-side encryption for Amazon S3 Storage Lens report files with either S3-managed keys (SSE-S3) or KMS-managed keys (SSE-KMS).
        """
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions]=None):
        pass


@pulumi.input_type
class StorageLensPrefixLevelStorageMetricsArgs:
    def __init__(__self__, *,
                 is_enabled: Optional[pulumi.Input[bool]] = None,
                 selection_criteria: Optional[pulumi.Input['StorageLensSelectionCriteriaArgs']] = None):
        """
        :param pulumi.Input[bool] is_enabled: Specifies whether prefix-level storage metrics are enabled or disabled.
        """
        StorageLensPrefixLevelStorageMetricsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_enabled=is_enabled,
            selection_criteria=selection_criteria,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_enabled: Optional[pulumi.Input[bool]] = None,
             selection_criteria: Optional[pulumi.Input['StorageLensSelectionCriteriaArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if selection_criteria is not None:
            _setter("selection_criteria", selection_criteria)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether prefix-level storage metrics are enabled or disabled.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)

    @property
    @pulumi.getter(name="selectionCriteria")
    def selection_criteria(self) -> Optional[pulumi.Input['StorageLensSelectionCriteriaArgs']]:
        return pulumi.get(self, "selection_criteria")

    @selection_criteria.setter
    def selection_criteria(self, value: Optional[pulumi.Input['StorageLensSelectionCriteriaArgs']]):
        pulumi.set(self, "selection_criteria", value)


@pulumi.input_type
class StorageLensPrefixLevelArgs:
    def __init__(__self__, *,
                 storage_metrics: pulumi.Input['StorageLensPrefixLevelStorageMetricsArgs']):
        """
        Prefix-level metrics configurations.
        """
        StorageLensPrefixLevelArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            storage_metrics=storage_metrics,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             storage_metrics: pulumi.Input['StorageLensPrefixLevelStorageMetricsArgs'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("storage_metrics", storage_metrics)

    @property
    @pulumi.getter(name="storageMetrics")
    def storage_metrics(self) -> pulumi.Input['StorageLensPrefixLevelStorageMetricsArgs']:
        return pulumi.get(self, "storage_metrics")

    @storage_metrics.setter
    def storage_metrics(self, value: pulumi.Input['StorageLensPrefixLevelStorageMetricsArgs']):
        pulumi.set(self, "storage_metrics", value)


@pulumi.input_type
class StorageLensS3BucketDestinationArgs:
    def __init__(__self__, *,
                 account_id: pulumi.Input[str],
                 arn: pulumi.Input[str],
                 format: pulumi.Input['StorageLensS3BucketDestinationFormat'],
                 output_schema_version: pulumi.Input['StorageLensS3BucketDestinationOutputSchemaVersion'],
                 encryption: Optional[pulumi.Input['StorageLensEncryptionArgs']] = None,
                 prefix: Optional[pulumi.Input[str]] = None):
        """
        S3 bucket destination settings for the Amazon S3 Storage Lens metrics export.
        :param pulumi.Input[str] account_id: The AWS account ID that owns the destination S3 bucket.
        :param pulumi.Input[str] arn: The ARN of the bucket to which Amazon S3 Storage Lens exports will be placed.
        :param pulumi.Input['StorageLensS3BucketDestinationFormat'] format: Specifies the file format to use when exporting Amazon S3 Storage Lens metrics export.
        :param pulumi.Input['StorageLensS3BucketDestinationOutputSchemaVersion'] output_schema_version: The version of the output schema to use when exporting Amazon S3 Storage Lens metrics.
        :param pulumi.Input[str] prefix: The prefix to use for Amazon S3 Storage Lens export.
        """
        StorageLensS3BucketDestinationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            account_id=account_id,
            arn=arn,
            format=format,
            output_schema_version=output_schema_version,
            encryption=encryption,
            prefix=prefix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             account_id: pulumi.Input[str],
             arn: pulumi.Input[str],
             format: pulumi.Input['StorageLensS3BucketDestinationFormat'],
             output_schema_version: pulumi.Input['StorageLensS3BucketDestinationOutputSchemaVersion'],
             encryption: Optional[pulumi.Input['StorageLensEncryptionArgs']] = None,
             prefix: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("account_id", account_id)
        _setter("arn", arn)
        _setter("format", format)
        _setter("output_schema_version", output_schema_version)
        if encryption is not None:
            _setter("encryption", encryption)
        if prefix is not None:
            _setter("prefix", prefix)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> pulumi.Input[str]:
        """
        The AWS account ID that owns the destination S3 bucket.
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "account_id", value)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        """
        The ARN of the bucket to which Amazon S3 Storage Lens exports will be placed.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input['StorageLensS3BucketDestinationFormat']:
        """
        Specifies the file format to use when exporting Amazon S3 Storage Lens metrics export.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input['StorageLensS3BucketDestinationFormat']):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter(name="outputSchemaVersion")
    def output_schema_version(self) -> pulumi.Input['StorageLensS3BucketDestinationOutputSchemaVersion']:
        """
        The version of the output schema to use when exporting Amazon S3 Storage Lens metrics.
        """
        return pulumi.get(self, "output_schema_version")

    @output_schema_version.setter
    def output_schema_version(self, value: pulumi.Input['StorageLensS3BucketDestinationOutputSchemaVersion']):
        pulumi.set(self, "output_schema_version", value)

    @property
    @pulumi.getter
    def encryption(self) -> Optional[pulumi.Input['StorageLensEncryptionArgs']]:
        return pulumi.get(self, "encryption")

    @encryption.setter
    def encryption(self, value: Optional[pulumi.Input['StorageLensEncryptionArgs']]):
        pulumi.set(self, "encryption", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The prefix to use for Amazon S3 Storage Lens export.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)


@pulumi.input_type
class StorageLensSelectionCriteriaArgs:
    def __init__(__self__, *,
                 delimiter: Optional[pulumi.Input[str]] = None,
                 max_depth: Optional[pulumi.Input[int]] = None,
                 min_storage_bytes_percentage: Optional[pulumi.Input[float]] = None):
        """
        Selection criteria for prefix-level metrics.
        :param pulumi.Input[str] delimiter: Delimiter to divide S3 key into hierarchy of prefixes.
        :param pulumi.Input[int] max_depth: Max depth of prefixes of S3 key that Amazon S3 Storage Lens will analyze.
        :param pulumi.Input[float] min_storage_bytes_percentage: The minimum storage bytes threshold for the prefixes to be included in the analysis.
        """
        StorageLensSelectionCriteriaArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            delimiter=delimiter,
            max_depth=max_depth,
            min_storage_bytes_percentage=min_storage_bytes_percentage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             delimiter: Optional[pulumi.Input[str]] = None,
             max_depth: Optional[pulumi.Input[int]] = None,
             min_storage_bytes_percentage: Optional[pulumi.Input[float]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if delimiter is not None:
            _setter("delimiter", delimiter)
        if max_depth is not None:
            _setter("max_depth", max_depth)
        if min_storage_bytes_percentage is not None:
            _setter("min_storage_bytes_percentage", min_storage_bytes_percentage)

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[pulumi.Input[str]]:
        """
        Delimiter to divide S3 key into hierarchy of prefixes.
        """
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delimiter", value)

    @property
    @pulumi.getter(name="maxDepth")
    def max_depth(self) -> Optional[pulumi.Input[int]]:
        """
        Max depth of prefixes of S3 key that Amazon S3 Storage Lens will analyze.
        """
        return pulumi.get(self, "max_depth")

    @max_depth.setter
    def max_depth(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_depth", value)

    @property
    @pulumi.getter(name="minStorageBytesPercentage")
    def min_storage_bytes_percentage(self) -> Optional[pulumi.Input[float]]:
        """
        The minimum storage bytes threshold for the prefixes to be included in the analysis.
        """
        return pulumi.get(self, "min_storage_bytes_percentage")

    @min_storage_bytes_percentage.setter
    def min_storage_bytes_percentage(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "min_storage_bytes_percentage", value)


@pulumi.input_type
class StorageLensTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        StorageLensTagArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: pulumi.Input[str],
             value: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


