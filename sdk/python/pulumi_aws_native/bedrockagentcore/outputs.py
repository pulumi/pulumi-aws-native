# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'BrowserCustomBrowserNetworkConfiguration',
    'BrowserCustomRecordingConfig',
    'BrowserCustomS3Location',
    'BrowserCustomVpcConfig',
    'CodeInterpreterCustomCodeInterpreterNetworkConfiguration',
    'CodeInterpreterCustomVpcConfig',
    'GatewayAuthorizerConfigurationProperties',
    'GatewayCustomJwtAuthorizerConfiguration',
    'GatewayMcpGatewayConfiguration',
    'GatewayProtocolConfigurationProperties',
    'GatewayTargetApiKeyCredentialProvider',
    'GatewayTargetApiSchemaConfiguration0Properties',
    'GatewayTargetApiSchemaConfiguration1Properties',
    'GatewayTargetCredentialProvider0Properties',
    'GatewayTargetCredentialProvider1Properties',
    'GatewayTargetCredentialProviderConfiguration',
    'GatewayTargetMcpLambdaTargetConfiguration',
    'GatewayTargetMcpTargetConfiguration0Properties',
    'GatewayTargetMcpTargetConfiguration1Properties',
    'GatewayTargetMcpTargetConfiguration2Properties',
    'GatewayTargetOAuthCredentialProvider',
    'GatewayTargetS3Configuration',
    'GatewayTargetSchemaDefinition',
    'GatewayTargetTargetConfigurationProperties',
    'GatewayTargetToolDefinition',
    'GatewayTargetToolSchema0Properties',
    'GatewayTargetToolSchema1Properties',
    'GatewayWorkloadIdentityDetails',
    'MemoryCustomConfigurationInput',
    'MemoryCustomMemoryStrategy',
    'MemoryInvocationConfigurationInput',
    'MemoryMessageBasedTriggerInput',
    'MemorySelfManagedConfiguration',
    'MemorySemanticMemoryStrategy',
    'MemorySemanticOverride',
    'MemorySemanticOverrideConsolidationConfigurationInput',
    'MemorySemanticOverrideExtractionConfigurationInput',
    'MemoryStrategy',
    'MemorySummaryMemoryStrategy',
    'MemorySummaryOverride',
    'MemorySummaryOverrideConsolidationConfigurationInput',
    'MemoryTimeBasedTriggerInput',
    'MemoryTokenBasedTriggerInput',
    'MemoryTriggerConditionInput',
    'MemoryUserPreferenceMemoryStrategy',
    'MemoryUserPreferenceOverride',
    'MemoryUserPreferenceOverrideConsolidationConfigurationInput',
    'MemoryUserPreferenceOverrideExtractionConfigurationInput',
    'RuntimeAgentRuntimeArtifact',
    'RuntimeAuthorizerConfiguration',
    'RuntimeContainerConfiguration',
    'RuntimeCustomJwtAuthorizerConfiguration',
    'RuntimeNetworkConfiguration',
    'RuntimeVpcConfig',
    'RuntimeWorkloadIdentityDetails',
]

@pulumi.output_type
class BrowserCustomBrowserNetworkConfiguration(dict):
    """
    Network configuration for browser
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkMode":
            suggest = "network_mode"
        elif key == "vpcConfig":
            suggest = "vpc_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserCustomBrowserNetworkConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserCustomBrowserNetworkConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserCustomBrowserNetworkConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_mode: 'BrowserCustomBrowserNetworkMode',
                 vpc_config: Optional['outputs.BrowserCustomVpcConfig'] = None):
        """
        Network configuration for browser
        :param 'BrowserCustomBrowserNetworkMode' network_mode: The network mode.
        """
        pulumi.set(__self__, "network_mode", network_mode)
        if vpc_config is not None:
            pulumi.set(__self__, "vpc_config", vpc_config)

    @_builtins.property
    @pulumi.getter(name="networkMode")
    def network_mode(self) -> 'BrowserCustomBrowserNetworkMode':
        """
        The network mode.
        """
        return pulumi.get(self, "network_mode")

    @_builtins.property
    @pulumi.getter(name="vpcConfig")
    def vpc_config(self) -> Optional['outputs.BrowserCustomVpcConfig']:
        return pulumi.get(self, "vpc_config")


@pulumi.output_type
class BrowserCustomRecordingConfig(dict):
    """
    Recording configuration for browser
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "s3Location":
            suggest = "s3_location"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserCustomRecordingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserCustomRecordingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserCustomRecordingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 s3_location: Optional['outputs.BrowserCustomS3Location'] = None):
        """
        Recording configuration for browser
        :param _builtins.bool enabled: The recording configuration for a browser. This structure defines how browser sessions are recorded.
        :param 'BrowserCustomS3Location' s3_location: The S3 location.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if s3_location is not None:
            pulumi.set(__self__, "s3_location", s3_location)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        The recording configuration for a browser. This structure defines how browser sessions are recorded.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="s3Location")
    def s3_location(self) -> Optional['outputs.BrowserCustomS3Location']:
        """
        The S3 location.
        """
        return pulumi.get(self, "s3_location")


@pulumi.output_type
class BrowserCustomS3Location(dict):
    """
    S3 Location Configuration
    """
    def __init__(__self__, *,
                 bucket: _builtins.str,
                 prefix: _builtins.str):
        """
        S3 Location Configuration
        :param _builtins.str bucket: The S3 location bucket name.
        :param _builtins.str prefix: The S3 location object prefix.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        The S3 location bucket name.
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> _builtins.str:
        """
        The S3 location object prefix.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class BrowserCustomVpcConfig(dict):
    """
    Network mode configuration for VPC
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityGroups":
            suggest = "security_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrowserCustomVpcConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrowserCustomVpcConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrowserCustomVpcConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 security_groups: Sequence[_builtins.str],
                 subnets: Sequence[_builtins.str]):
        """
        Network mode configuration for VPC
        """
        pulumi.set(__self__, "security_groups", security_groups)
        pulumi.set(__self__, "subnets", subnets)

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "subnets")


@pulumi.output_type
class CodeInterpreterCustomCodeInterpreterNetworkConfiguration(dict):
    """
    Network configuration for code interpreter
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkMode":
            suggest = "network_mode"
        elif key == "vpcConfig":
            suggest = "vpc_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CodeInterpreterCustomCodeInterpreterNetworkConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CodeInterpreterCustomCodeInterpreterNetworkConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CodeInterpreterCustomCodeInterpreterNetworkConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_mode: 'CodeInterpreterCustomCodeInterpreterNetworkMode',
                 vpc_config: Optional['outputs.CodeInterpreterCustomVpcConfig'] = None):
        """
        Network configuration for code interpreter
        :param 'CodeInterpreterCustomCodeInterpreterNetworkMode' network_mode: The network mode.
        """
        pulumi.set(__self__, "network_mode", network_mode)
        if vpc_config is not None:
            pulumi.set(__self__, "vpc_config", vpc_config)

    @_builtins.property
    @pulumi.getter(name="networkMode")
    def network_mode(self) -> 'CodeInterpreterCustomCodeInterpreterNetworkMode':
        """
        The network mode.
        """
        return pulumi.get(self, "network_mode")

    @_builtins.property
    @pulumi.getter(name="vpcConfig")
    def vpc_config(self) -> Optional['outputs.CodeInterpreterCustomVpcConfig']:
        return pulumi.get(self, "vpc_config")


@pulumi.output_type
class CodeInterpreterCustomVpcConfig(dict):
    """
    Network mode configuration for VPC
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityGroups":
            suggest = "security_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CodeInterpreterCustomVpcConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CodeInterpreterCustomVpcConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CodeInterpreterCustomVpcConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 security_groups: Sequence[_builtins.str],
                 subnets: Sequence[_builtins.str]):
        """
        Network mode configuration for VPC
        """
        pulumi.set(__self__, "security_groups", security_groups)
        pulumi.set(__self__, "subnets", subnets)

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "subnets")


@pulumi.output_type
class GatewayAuthorizerConfigurationProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customJwtAuthorizer":
            suggest = "custom_jwt_authorizer"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayAuthorizerConfigurationProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayAuthorizerConfigurationProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayAuthorizerConfigurationProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_jwt_authorizer: 'outputs.GatewayCustomJwtAuthorizerConfiguration'):
        pulumi.set(__self__, "custom_jwt_authorizer", custom_jwt_authorizer)

    @_builtins.property
    @pulumi.getter(name="customJwtAuthorizer")
    def custom_jwt_authorizer(self) -> 'outputs.GatewayCustomJwtAuthorizerConfiguration':
        return pulumi.get(self, "custom_jwt_authorizer")


@pulumi.output_type
class GatewayCustomJwtAuthorizerConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "discoveryUrl":
            suggest = "discovery_url"
        elif key == "allowedAudience":
            suggest = "allowed_audience"
        elif key == "allowedClients":
            suggest = "allowed_clients"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayCustomJwtAuthorizerConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayCustomJwtAuthorizerConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayCustomJwtAuthorizerConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 discovery_url: _builtins.str,
                 allowed_audience: Optional[Sequence[_builtins.str]] = None,
                 allowed_clients: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "discovery_url", discovery_url)
        if allowed_audience is not None:
            pulumi.set(__self__, "allowed_audience", allowed_audience)
        if allowed_clients is not None:
            pulumi.set(__self__, "allowed_clients", allowed_clients)

    @_builtins.property
    @pulumi.getter(name="discoveryUrl")
    def discovery_url(self) -> _builtins.str:
        return pulumi.get(self, "discovery_url")

    @_builtins.property
    @pulumi.getter(name="allowedAudience")
    def allowed_audience(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "allowed_audience")

    @_builtins.property
    @pulumi.getter(name="allowedClients")
    def allowed_clients(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "allowed_clients")


@pulumi.output_type
class GatewayMcpGatewayConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "searchType":
            suggest = "search_type"
        elif key == "supportedVersions":
            suggest = "supported_versions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayMcpGatewayConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayMcpGatewayConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayMcpGatewayConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instructions: Optional[_builtins.str] = None,
                 search_type: Optional['GatewaySearchType'] = None,
                 supported_versions: Optional[Sequence[_builtins.str]] = None):
        if instructions is not None:
            pulumi.set(__self__, "instructions", instructions)
        if search_type is not None:
            pulumi.set(__self__, "search_type", search_type)
        if supported_versions is not None:
            pulumi.set(__self__, "supported_versions", supported_versions)

    @_builtins.property
    @pulumi.getter
    def instructions(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "instructions")

    @_builtins.property
    @pulumi.getter(name="searchType")
    def search_type(self) -> Optional['GatewaySearchType']:
        return pulumi.get(self, "search_type")

    @_builtins.property
    @pulumi.getter(name="supportedVersions")
    def supported_versions(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "supported_versions")


@pulumi.output_type
class GatewayProtocolConfigurationProperties(dict):
    def __init__(__self__, *,
                 mcp: 'outputs.GatewayMcpGatewayConfiguration'):
        pulumi.set(__self__, "mcp", mcp)

    @_builtins.property
    @pulumi.getter
    def mcp(self) -> 'outputs.GatewayMcpGatewayConfiguration':
        return pulumi.get(self, "mcp")


@pulumi.output_type
class GatewayTargetApiKeyCredentialProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "providerArn":
            suggest = "provider_arn"
        elif key == "credentialLocation":
            suggest = "credential_location"
        elif key == "credentialParameterName":
            suggest = "credential_parameter_name"
        elif key == "credentialPrefix":
            suggest = "credential_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayTargetApiKeyCredentialProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayTargetApiKeyCredentialProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayTargetApiKeyCredentialProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provider_arn: _builtins.str,
                 credential_location: Optional['GatewayTargetApiKeyCredentialLocation'] = None,
                 credential_parameter_name: Optional[_builtins.str] = None,
                 credential_prefix: Optional[_builtins.str] = None):
        pulumi.set(__self__, "provider_arn", provider_arn)
        if credential_location is not None:
            pulumi.set(__self__, "credential_location", credential_location)
        if credential_parameter_name is not None:
            pulumi.set(__self__, "credential_parameter_name", credential_parameter_name)
        if credential_prefix is not None:
            pulumi.set(__self__, "credential_prefix", credential_prefix)

    @_builtins.property
    @pulumi.getter(name="providerArn")
    def provider_arn(self) -> _builtins.str:
        return pulumi.get(self, "provider_arn")

    @_builtins.property
    @pulumi.getter(name="credentialLocation")
    def credential_location(self) -> Optional['GatewayTargetApiKeyCredentialLocation']:
        return pulumi.get(self, "credential_location")

    @_builtins.property
    @pulumi.getter(name="credentialParameterName")
    def credential_parameter_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "credential_parameter_name")

    @_builtins.property
    @pulumi.getter(name="credentialPrefix")
    def credential_prefix(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "credential_prefix")


@pulumi.output_type
class GatewayTargetApiSchemaConfiguration0Properties(dict):
    def __init__(__self__, *,
                 s3: 'outputs.GatewayTargetS3Configuration'):
        pulumi.set(__self__, "s3", s3)

    @_builtins.property
    @pulumi.getter
    def s3(self) -> 'outputs.GatewayTargetS3Configuration':
        return pulumi.get(self, "s3")


@pulumi.output_type
class GatewayTargetApiSchemaConfiguration1Properties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inlinePayload":
            suggest = "inline_payload"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayTargetApiSchemaConfiguration1Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayTargetApiSchemaConfiguration1Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayTargetApiSchemaConfiguration1Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inline_payload: _builtins.str):
        pulumi.set(__self__, "inline_payload", inline_payload)

    @_builtins.property
    @pulumi.getter(name="inlinePayload")
    def inline_payload(self) -> _builtins.str:
        return pulumi.get(self, "inline_payload")


@pulumi.output_type
class GatewayTargetCredentialProvider0Properties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oauthCredentialProvider":
            suggest = "oauth_credential_provider"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayTargetCredentialProvider0Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayTargetCredentialProvider0Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayTargetCredentialProvider0Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oauth_credential_provider: 'outputs.GatewayTargetOAuthCredentialProvider'):
        pulumi.set(__self__, "oauth_credential_provider", oauth_credential_provider)

    @_builtins.property
    @pulumi.getter(name="oauthCredentialProvider")
    def oauth_credential_provider(self) -> 'outputs.GatewayTargetOAuthCredentialProvider':
        return pulumi.get(self, "oauth_credential_provider")


@pulumi.output_type
class GatewayTargetCredentialProvider1Properties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKeyCredentialProvider":
            suggest = "api_key_credential_provider"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayTargetCredentialProvider1Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayTargetCredentialProvider1Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayTargetCredentialProvider1Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key_credential_provider: 'outputs.GatewayTargetApiKeyCredentialProvider'):
        pulumi.set(__self__, "api_key_credential_provider", api_key_credential_provider)

    @_builtins.property
    @pulumi.getter(name="apiKeyCredentialProvider")
    def api_key_credential_provider(self) -> 'outputs.GatewayTargetApiKeyCredentialProvider':
        return pulumi.get(self, "api_key_credential_provider")


@pulumi.output_type
class GatewayTargetCredentialProviderConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "credentialProviderType":
            suggest = "credential_provider_type"
        elif key == "credentialProvider":
            suggest = "credential_provider"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayTargetCredentialProviderConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayTargetCredentialProviderConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayTargetCredentialProviderConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credential_provider_type: 'GatewayTargetCredentialProviderType',
                 credential_provider: Optional[Any] = None):
        """
        :param 'GatewayTargetCredentialProviderType' credential_provider_type: The credential provider type for the gateway target.
        :param Union['GatewayTargetCredentialProvider0Properties', 'GatewayTargetCredentialProvider1Properties'] credential_provider: The credential provider for the gateway target.
        """
        pulumi.set(__self__, "credential_provider_type", credential_provider_type)
        if credential_provider is not None:
            pulumi.set(__self__, "credential_provider", credential_provider)

    @_builtins.property
    @pulumi.getter(name="credentialProviderType")
    def credential_provider_type(self) -> 'GatewayTargetCredentialProviderType':
        """
        The credential provider type for the gateway target.
        """
        return pulumi.get(self, "credential_provider_type")

    @_builtins.property
    @pulumi.getter(name="credentialProvider")
    def credential_provider(self) -> Optional[Any]:
        """
        The credential provider for the gateway target.
        """
        return pulumi.get(self, "credential_provider")


@pulumi.output_type
class GatewayTargetMcpLambdaTargetConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lambdaArn":
            suggest = "lambda_arn"
        elif key == "toolSchema":
            suggest = "tool_schema"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayTargetMcpLambdaTargetConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayTargetMcpLambdaTargetConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayTargetMcpLambdaTargetConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lambda_arn: _builtins.str,
                 tool_schema: Any):
        pulumi.set(__self__, "lambda_arn", lambda_arn)
        pulumi.set(__self__, "tool_schema", tool_schema)

    @_builtins.property
    @pulumi.getter(name="lambdaArn")
    def lambda_arn(self) -> _builtins.str:
        return pulumi.get(self, "lambda_arn")

    @_builtins.property
    @pulumi.getter(name="toolSchema")
    def tool_schema(self) -> Any:
        return pulumi.get(self, "tool_schema")


@pulumi.output_type
class GatewayTargetMcpTargetConfiguration0Properties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "openApiSchema":
            suggest = "open_api_schema"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayTargetMcpTargetConfiguration0Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayTargetMcpTargetConfiguration0Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayTargetMcpTargetConfiguration0Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 open_api_schema: Any):
        pulumi.set(__self__, "open_api_schema", open_api_schema)

    @_builtins.property
    @pulumi.getter(name="openApiSchema")
    def open_api_schema(self) -> Any:
        return pulumi.get(self, "open_api_schema")


@pulumi.output_type
class GatewayTargetMcpTargetConfiguration1Properties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "smithyModel":
            suggest = "smithy_model"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayTargetMcpTargetConfiguration1Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayTargetMcpTargetConfiguration1Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayTargetMcpTargetConfiguration1Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 smithy_model: Any):
        pulumi.set(__self__, "smithy_model", smithy_model)

    @_builtins.property
    @pulumi.getter(name="smithyModel")
    def smithy_model(self) -> Any:
        return pulumi.get(self, "smithy_model")


@pulumi.output_type
class GatewayTargetMcpTargetConfiguration2Properties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lambda":
            suggest = "lambda_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayTargetMcpTargetConfiguration2Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayTargetMcpTargetConfiguration2Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayTargetMcpTargetConfiguration2Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lambda_: 'outputs.GatewayTargetMcpLambdaTargetConfiguration'):
        pulumi.set(__self__, "lambda_", lambda_)

    @_builtins.property
    @pulumi.getter(name="lambda")
    def lambda_(self) -> 'outputs.GatewayTargetMcpLambdaTargetConfiguration':
        return pulumi.get(self, "lambda_")


@pulumi.output_type
class GatewayTargetOAuthCredentialProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "providerArn":
            suggest = "provider_arn"
        elif key == "customParameters":
            suggest = "custom_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayTargetOAuthCredentialProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayTargetOAuthCredentialProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayTargetOAuthCredentialProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 provider_arn: _builtins.str,
                 scopes: Sequence[_builtins.str],
                 custom_parameters: Optional[Mapping[str, _builtins.str]] = None):
        pulumi.set(__self__, "provider_arn", provider_arn)
        pulumi.set(__self__, "scopes", scopes)
        if custom_parameters is not None:
            pulumi.set(__self__, "custom_parameters", custom_parameters)

    @_builtins.property
    @pulumi.getter(name="providerArn")
    def provider_arn(self) -> _builtins.str:
        return pulumi.get(self, "provider_arn")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter(name="customParameters")
    def custom_parameters(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "custom_parameters")


@pulumi.output_type
class GatewayTargetS3Configuration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketOwnerAccountId":
            suggest = "bucket_owner_account_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayTargetS3Configuration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayTargetS3Configuration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayTargetS3Configuration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_owner_account_id: Optional[_builtins.str] = None,
                 uri: Optional[_builtins.str] = None):
        if bucket_owner_account_id is not None:
            pulumi.set(__self__, "bucket_owner_account_id", bucket_owner_account_id)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter(name="bucketOwnerAccountId")
    def bucket_owner_account_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "bucket_owner_account_id")

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "uri")


@pulumi.output_type
class GatewayTargetSchemaDefinition(dict):
    def __init__(__self__, *,
                 type: 'GatewayTargetSchemaType',
                 description: Optional[_builtins.str] = None,
                 items: Optional['outputs.GatewayTargetSchemaDefinition'] = None,
                 properties: Optional[Mapping[str, 'outputs.GatewayTargetSchemaDefinition']] = None,
                 required: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'GatewayTargetSchemaType':
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional['outputs.GatewayTargetSchemaDefinition']:
        return pulumi.get(self, "items")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, 'outputs.GatewayTargetSchemaDefinition']]:
        return pulumi.get(self, "properties")

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "required")


@pulumi.output_type
class GatewayTargetTargetConfigurationProperties(dict):
    def __init__(__self__, *,
                 mcp: Any):
        pulumi.set(__self__, "mcp", mcp)

    @_builtins.property
    @pulumi.getter
    def mcp(self) -> Any:
        return pulumi.get(self, "mcp")


@pulumi.output_type
class GatewayTargetToolDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputSchema":
            suggest = "input_schema"
        elif key == "outputSchema":
            suggest = "output_schema"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayTargetToolDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayTargetToolDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayTargetToolDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: _builtins.str,
                 input_schema: 'outputs.GatewayTargetSchemaDefinition',
                 name: _builtins.str,
                 output_schema: Optional['outputs.GatewayTargetSchemaDefinition'] = None):
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "input_schema", input_schema)
        pulumi.set(__self__, "name", name)
        if output_schema is not None:
            pulumi.set(__self__, "output_schema", output_schema)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="inputSchema")
    def input_schema(self) -> 'outputs.GatewayTargetSchemaDefinition':
        return pulumi.get(self, "input_schema")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="outputSchema")
    def output_schema(self) -> Optional['outputs.GatewayTargetSchemaDefinition']:
        return pulumi.get(self, "output_schema")


@pulumi.output_type
class GatewayTargetToolSchema0Properties(dict):
    def __init__(__self__, *,
                 s3: 'outputs.GatewayTargetS3Configuration'):
        pulumi.set(__self__, "s3", s3)

    @_builtins.property
    @pulumi.getter
    def s3(self) -> 'outputs.GatewayTargetS3Configuration':
        return pulumi.get(self, "s3")


@pulumi.output_type
class GatewayTargetToolSchema1Properties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inlinePayload":
            suggest = "inline_payload"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayTargetToolSchema1Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayTargetToolSchema1Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayTargetToolSchema1Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inline_payload: Sequence['outputs.GatewayTargetToolDefinition']):
        pulumi.set(__self__, "inline_payload", inline_payload)

    @_builtins.property
    @pulumi.getter(name="inlinePayload")
    def inline_payload(self) -> Sequence['outputs.GatewayTargetToolDefinition']:
        return pulumi.get(self, "inline_payload")


@pulumi.output_type
class GatewayWorkloadIdentityDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workloadIdentityArn":
            suggest = "workload_identity_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewayWorkloadIdentityDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewayWorkloadIdentityDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewayWorkloadIdentityDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 workload_identity_arn: _builtins.str):
        pulumi.set(__self__, "workload_identity_arn", workload_identity_arn)

    @_builtins.property
    @pulumi.getter(name="workloadIdentityArn")
    def workload_identity_arn(self) -> _builtins.str:
        return pulumi.get(self, "workload_identity_arn")


@pulumi.output_type
class MemoryCustomConfigurationInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "selfManagedConfiguration":
            suggest = "self_managed_configuration"
        elif key == "semanticOverride":
            suggest = "semantic_override"
        elif key == "summaryOverride":
            suggest = "summary_override"
        elif key == "userPreferenceOverride":
            suggest = "user_preference_override"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MemoryCustomConfigurationInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MemoryCustomConfigurationInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MemoryCustomConfigurationInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 self_managed_configuration: Optional['outputs.MemorySelfManagedConfiguration'] = None,
                 semantic_override: Optional['outputs.MemorySemanticOverride'] = None,
                 summary_override: Optional['outputs.MemorySummaryOverride'] = None,
                 user_preference_override: Optional['outputs.MemoryUserPreferenceOverride'] = None):
        if self_managed_configuration is not None:
            pulumi.set(__self__, "self_managed_configuration", self_managed_configuration)
        if semantic_override is not None:
            pulumi.set(__self__, "semantic_override", semantic_override)
        if summary_override is not None:
            pulumi.set(__self__, "summary_override", summary_override)
        if user_preference_override is not None:
            pulumi.set(__self__, "user_preference_override", user_preference_override)

    @_builtins.property
    @pulumi.getter(name="selfManagedConfiguration")
    def self_managed_configuration(self) -> Optional['outputs.MemorySelfManagedConfiguration']:
        return pulumi.get(self, "self_managed_configuration")

    @_builtins.property
    @pulumi.getter(name="semanticOverride")
    def semantic_override(self) -> Optional['outputs.MemorySemanticOverride']:
        return pulumi.get(self, "semantic_override")

    @_builtins.property
    @pulumi.getter(name="summaryOverride")
    def summary_override(self) -> Optional['outputs.MemorySummaryOverride']:
        return pulumi.get(self, "summary_override")

    @_builtins.property
    @pulumi.getter(name="userPreferenceOverride")
    def user_preference_override(self) -> Optional['outputs.MemoryUserPreferenceOverride']:
        return pulumi.get(self, "user_preference_override")


@pulumi.output_type
class MemoryCustomMemoryStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "strategyId":
            suggest = "strategy_id"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MemoryCustomMemoryStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MemoryCustomMemoryStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MemoryCustomMemoryStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 configuration: Optional['outputs.MemoryCustomConfigurationInput'] = None,
                 created_at: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 namespaces: Optional[Sequence[_builtins.str]] = None,
                 status: Optional['MemoryCustomMemoryStrategyStatus'] = None,
                 strategy_id: Optional[_builtins.str] = None,
                 type: Optional['MemoryCustomMemoryStrategyType'] = None,
                 updated_at: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Creation timestamp of the memory strategy
        :param 'MemoryCustomMemoryStrategyStatus' status: Status of the memory strategy
        :param _builtins.str strategy_id: Unique identifier for the memory strategy
        :param 'MemoryCustomMemoryStrategyType' type: Type of memory strategy
        :param _builtins.str updated_at: Last update timestamp of the memory strategy
        """
        pulumi.set(__self__, "name", name)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if strategy_id is not None:
            pulumi.set(__self__, "strategy_id", strategy_id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> Optional['outputs.MemoryCustomConfigurationInput']:
        return pulumi.get(self, "configuration")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        Creation timestamp of the memory strategy
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "namespaces")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional['MemoryCustomMemoryStrategyStatus']:
        """
        Status of the memory strategy
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="strategyId")
    def strategy_id(self) -> Optional[_builtins.str]:
        """
        Unique identifier for the memory strategy
        """
        return pulumi.get(self, "strategy_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional['MemoryCustomMemoryStrategyType']:
        """
        Type of memory strategy
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.str]:
        """
        Last update timestamp of the memory strategy
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class MemoryInvocationConfigurationInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "payloadDeliveryBucketName":
            suggest = "payload_delivery_bucket_name"
        elif key == "topicArn":
            suggest = "topic_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MemoryInvocationConfigurationInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MemoryInvocationConfigurationInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MemoryInvocationConfigurationInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 payload_delivery_bucket_name: Optional[_builtins.str] = None,
                 topic_arn: Optional[_builtins.str] = None):
        if payload_delivery_bucket_name is not None:
            pulumi.set(__self__, "payload_delivery_bucket_name", payload_delivery_bucket_name)
        if topic_arn is not None:
            pulumi.set(__self__, "topic_arn", topic_arn)

    @_builtins.property
    @pulumi.getter(name="payloadDeliveryBucketName")
    def payload_delivery_bucket_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "payload_delivery_bucket_name")

    @_builtins.property
    @pulumi.getter(name="topicArn")
    def topic_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "topic_arn")


@pulumi.output_type
class MemoryMessageBasedTriggerInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "messageCount":
            suggest = "message_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MemoryMessageBasedTriggerInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MemoryMessageBasedTriggerInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MemoryMessageBasedTriggerInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 message_count: Optional[_builtins.int] = None):
        if message_count is not None:
            pulumi.set(__self__, "message_count", message_count)

    @_builtins.property
    @pulumi.getter(name="messageCount")
    def message_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "message_count")


@pulumi.output_type
class MemorySelfManagedConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "historicalContextWindowSize":
            suggest = "historical_context_window_size"
        elif key == "invocationConfiguration":
            suggest = "invocation_configuration"
        elif key == "triggerConditions":
            suggest = "trigger_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MemorySelfManagedConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MemorySelfManagedConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MemorySelfManagedConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 historical_context_window_size: Optional[_builtins.int] = None,
                 invocation_configuration: Optional['outputs.MemoryInvocationConfigurationInput'] = None,
                 trigger_conditions: Optional[Sequence['outputs.MemoryTriggerConditionInput']] = None):
        if historical_context_window_size is not None:
            pulumi.set(__self__, "historical_context_window_size", historical_context_window_size)
        if invocation_configuration is not None:
            pulumi.set(__self__, "invocation_configuration", invocation_configuration)
        if trigger_conditions is not None:
            pulumi.set(__self__, "trigger_conditions", trigger_conditions)

    @_builtins.property
    @pulumi.getter(name="historicalContextWindowSize")
    def historical_context_window_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "historical_context_window_size")

    @_builtins.property
    @pulumi.getter(name="invocationConfiguration")
    def invocation_configuration(self) -> Optional['outputs.MemoryInvocationConfigurationInput']:
        return pulumi.get(self, "invocation_configuration")

    @_builtins.property
    @pulumi.getter(name="triggerConditions")
    def trigger_conditions(self) -> Optional[Sequence['outputs.MemoryTriggerConditionInput']]:
        return pulumi.get(self, "trigger_conditions")


@pulumi.output_type
class MemorySemanticMemoryStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "strategyId":
            suggest = "strategy_id"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MemorySemanticMemoryStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MemorySemanticMemoryStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MemorySemanticMemoryStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 created_at: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 namespaces: Optional[Sequence[_builtins.str]] = None,
                 status: Optional['MemorySemanticMemoryStrategyStatus'] = None,
                 strategy_id: Optional[_builtins.str] = None,
                 type: Optional['MemorySemanticMemoryStrategyType'] = None,
                 updated_at: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Creation timestamp of the memory strategy
        :param 'MemorySemanticMemoryStrategyStatus' status: Status of the memory strategy
        :param _builtins.str strategy_id: Unique identifier for the memory strategy
        :param 'MemorySemanticMemoryStrategyType' type: Type of memory strategy
        :param _builtins.str updated_at: Last update timestamp of the memory strategy
        """
        pulumi.set(__self__, "name", name)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if strategy_id is not None:
            pulumi.set(__self__, "strategy_id", strategy_id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        Creation timestamp of the memory strategy
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "namespaces")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional['MemorySemanticMemoryStrategyStatus']:
        """
        Status of the memory strategy
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="strategyId")
    def strategy_id(self) -> Optional[_builtins.str]:
        """
        Unique identifier for the memory strategy
        """
        return pulumi.get(self, "strategy_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional['MemorySemanticMemoryStrategyType']:
        """
        Type of memory strategy
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.str]:
        """
        Last update timestamp of the memory strategy
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class MemorySemanticOverride(dict):
    def __init__(__self__, *,
                 consolidation: Optional['outputs.MemorySemanticOverrideConsolidationConfigurationInput'] = None,
                 extraction: Optional['outputs.MemorySemanticOverrideExtractionConfigurationInput'] = None):
        if consolidation is not None:
            pulumi.set(__self__, "consolidation", consolidation)
        if extraction is not None:
            pulumi.set(__self__, "extraction", extraction)

    @_builtins.property
    @pulumi.getter
    def consolidation(self) -> Optional['outputs.MemorySemanticOverrideConsolidationConfigurationInput']:
        return pulumi.get(self, "consolidation")

    @_builtins.property
    @pulumi.getter
    def extraction(self) -> Optional['outputs.MemorySemanticOverrideExtractionConfigurationInput']:
        return pulumi.get(self, "extraction")


@pulumi.output_type
class MemorySemanticOverrideConsolidationConfigurationInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appendToPrompt":
            suggest = "append_to_prompt"
        elif key == "modelId":
            suggest = "model_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MemorySemanticOverrideConsolidationConfigurationInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MemorySemanticOverrideConsolidationConfigurationInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MemorySemanticOverrideConsolidationConfigurationInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 append_to_prompt: _builtins.str,
                 model_id: _builtins.str):
        pulumi.set(__self__, "append_to_prompt", append_to_prompt)
        pulumi.set(__self__, "model_id", model_id)

    @_builtins.property
    @pulumi.getter(name="appendToPrompt")
    def append_to_prompt(self) -> _builtins.str:
        return pulumi.get(self, "append_to_prompt")

    @_builtins.property
    @pulumi.getter(name="modelId")
    def model_id(self) -> _builtins.str:
        return pulumi.get(self, "model_id")


@pulumi.output_type
class MemorySemanticOverrideExtractionConfigurationInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appendToPrompt":
            suggest = "append_to_prompt"
        elif key == "modelId":
            suggest = "model_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MemorySemanticOverrideExtractionConfigurationInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MemorySemanticOverrideExtractionConfigurationInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MemorySemanticOverrideExtractionConfigurationInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 append_to_prompt: _builtins.str,
                 model_id: _builtins.str):
        pulumi.set(__self__, "append_to_prompt", append_to_prompt)
        pulumi.set(__self__, "model_id", model_id)

    @_builtins.property
    @pulumi.getter(name="appendToPrompt")
    def append_to_prompt(self) -> _builtins.str:
        return pulumi.get(self, "append_to_prompt")

    @_builtins.property
    @pulumi.getter(name="modelId")
    def model_id(self) -> _builtins.str:
        return pulumi.get(self, "model_id")


@pulumi.output_type
class MemoryStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customMemoryStrategy":
            suggest = "custom_memory_strategy"
        elif key == "semanticMemoryStrategy":
            suggest = "semantic_memory_strategy"
        elif key == "summaryMemoryStrategy":
            suggest = "summary_memory_strategy"
        elif key == "userPreferenceMemoryStrategy":
            suggest = "user_preference_memory_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MemoryStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MemoryStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MemoryStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_memory_strategy: Optional['outputs.MemoryCustomMemoryStrategy'] = None,
                 semantic_memory_strategy: Optional['outputs.MemorySemanticMemoryStrategy'] = None,
                 summary_memory_strategy: Optional['outputs.MemorySummaryMemoryStrategy'] = None,
                 user_preference_memory_strategy: Optional['outputs.MemoryUserPreferenceMemoryStrategy'] = None):
        if custom_memory_strategy is not None:
            pulumi.set(__self__, "custom_memory_strategy", custom_memory_strategy)
        if semantic_memory_strategy is not None:
            pulumi.set(__self__, "semantic_memory_strategy", semantic_memory_strategy)
        if summary_memory_strategy is not None:
            pulumi.set(__self__, "summary_memory_strategy", summary_memory_strategy)
        if user_preference_memory_strategy is not None:
            pulumi.set(__self__, "user_preference_memory_strategy", user_preference_memory_strategy)

    @_builtins.property
    @pulumi.getter(name="customMemoryStrategy")
    def custom_memory_strategy(self) -> Optional['outputs.MemoryCustomMemoryStrategy']:
        return pulumi.get(self, "custom_memory_strategy")

    @_builtins.property
    @pulumi.getter(name="semanticMemoryStrategy")
    def semantic_memory_strategy(self) -> Optional['outputs.MemorySemanticMemoryStrategy']:
        return pulumi.get(self, "semantic_memory_strategy")

    @_builtins.property
    @pulumi.getter(name="summaryMemoryStrategy")
    def summary_memory_strategy(self) -> Optional['outputs.MemorySummaryMemoryStrategy']:
        return pulumi.get(self, "summary_memory_strategy")

    @_builtins.property
    @pulumi.getter(name="userPreferenceMemoryStrategy")
    def user_preference_memory_strategy(self) -> Optional['outputs.MemoryUserPreferenceMemoryStrategy']:
        return pulumi.get(self, "user_preference_memory_strategy")


@pulumi.output_type
class MemorySummaryMemoryStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "strategyId":
            suggest = "strategy_id"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MemorySummaryMemoryStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MemorySummaryMemoryStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MemorySummaryMemoryStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 created_at: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 namespaces: Optional[Sequence[_builtins.str]] = None,
                 status: Optional['MemorySummaryMemoryStrategyStatus'] = None,
                 strategy_id: Optional[_builtins.str] = None,
                 type: Optional['MemorySummaryMemoryStrategyType'] = None,
                 updated_at: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Creation timestamp of the memory strategy
        :param 'MemorySummaryMemoryStrategyStatus' status: Status of the memory strategy
        :param _builtins.str strategy_id: Unique identifier for the memory strategy
        :param 'MemorySummaryMemoryStrategyType' type: Type of memory strategy
        :param _builtins.str updated_at: Last update timestamp of the memory strategy
        """
        pulumi.set(__self__, "name", name)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if strategy_id is not None:
            pulumi.set(__self__, "strategy_id", strategy_id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        Creation timestamp of the memory strategy
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "namespaces")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional['MemorySummaryMemoryStrategyStatus']:
        """
        Status of the memory strategy
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="strategyId")
    def strategy_id(self) -> Optional[_builtins.str]:
        """
        Unique identifier for the memory strategy
        """
        return pulumi.get(self, "strategy_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional['MemorySummaryMemoryStrategyType']:
        """
        Type of memory strategy
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.str]:
        """
        Last update timestamp of the memory strategy
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class MemorySummaryOverride(dict):
    def __init__(__self__, *,
                 consolidation: Optional['outputs.MemorySummaryOverrideConsolidationConfigurationInput'] = None):
        if consolidation is not None:
            pulumi.set(__self__, "consolidation", consolidation)

    @_builtins.property
    @pulumi.getter
    def consolidation(self) -> Optional['outputs.MemorySummaryOverrideConsolidationConfigurationInput']:
        return pulumi.get(self, "consolidation")


@pulumi.output_type
class MemorySummaryOverrideConsolidationConfigurationInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appendToPrompt":
            suggest = "append_to_prompt"
        elif key == "modelId":
            suggest = "model_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MemorySummaryOverrideConsolidationConfigurationInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MemorySummaryOverrideConsolidationConfigurationInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MemorySummaryOverrideConsolidationConfigurationInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 append_to_prompt: _builtins.str,
                 model_id: _builtins.str):
        pulumi.set(__self__, "append_to_prompt", append_to_prompt)
        pulumi.set(__self__, "model_id", model_id)

    @_builtins.property
    @pulumi.getter(name="appendToPrompt")
    def append_to_prompt(self) -> _builtins.str:
        return pulumi.get(self, "append_to_prompt")

    @_builtins.property
    @pulumi.getter(name="modelId")
    def model_id(self) -> _builtins.str:
        return pulumi.get(self, "model_id")


@pulumi.output_type
class MemoryTimeBasedTriggerInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "idleSessionTimeout":
            suggest = "idle_session_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MemoryTimeBasedTriggerInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MemoryTimeBasedTriggerInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MemoryTimeBasedTriggerInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 idle_session_timeout: Optional[_builtins.int] = None):
        if idle_session_timeout is not None:
            pulumi.set(__self__, "idle_session_timeout", idle_session_timeout)

    @_builtins.property
    @pulumi.getter(name="idleSessionTimeout")
    def idle_session_timeout(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "idle_session_timeout")


@pulumi.output_type
class MemoryTokenBasedTriggerInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tokenCount":
            suggest = "token_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MemoryTokenBasedTriggerInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MemoryTokenBasedTriggerInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MemoryTokenBasedTriggerInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 token_count: Optional[_builtins.int] = None):
        if token_count is not None:
            pulumi.set(__self__, "token_count", token_count)

    @_builtins.property
    @pulumi.getter(name="tokenCount")
    def token_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "token_count")


@pulumi.output_type
class MemoryTriggerConditionInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "messageBasedTrigger":
            suggest = "message_based_trigger"
        elif key == "timeBasedTrigger":
            suggest = "time_based_trigger"
        elif key == "tokenBasedTrigger":
            suggest = "token_based_trigger"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MemoryTriggerConditionInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MemoryTriggerConditionInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MemoryTriggerConditionInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 message_based_trigger: Optional['outputs.MemoryMessageBasedTriggerInput'] = None,
                 time_based_trigger: Optional['outputs.MemoryTimeBasedTriggerInput'] = None,
                 token_based_trigger: Optional['outputs.MemoryTokenBasedTriggerInput'] = None):
        if message_based_trigger is not None:
            pulumi.set(__self__, "message_based_trigger", message_based_trigger)
        if time_based_trigger is not None:
            pulumi.set(__self__, "time_based_trigger", time_based_trigger)
        if token_based_trigger is not None:
            pulumi.set(__self__, "token_based_trigger", token_based_trigger)

    @_builtins.property
    @pulumi.getter(name="messageBasedTrigger")
    def message_based_trigger(self) -> Optional['outputs.MemoryMessageBasedTriggerInput']:
        return pulumi.get(self, "message_based_trigger")

    @_builtins.property
    @pulumi.getter(name="timeBasedTrigger")
    def time_based_trigger(self) -> Optional['outputs.MemoryTimeBasedTriggerInput']:
        return pulumi.get(self, "time_based_trigger")

    @_builtins.property
    @pulumi.getter(name="tokenBasedTrigger")
    def token_based_trigger(self) -> Optional['outputs.MemoryTokenBasedTriggerInput']:
        return pulumi.get(self, "token_based_trigger")


@pulumi.output_type
class MemoryUserPreferenceMemoryStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "strategyId":
            suggest = "strategy_id"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MemoryUserPreferenceMemoryStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MemoryUserPreferenceMemoryStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MemoryUserPreferenceMemoryStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 created_at: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 namespaces: Optional[Sequence[_builtins.str]] = None,
                 status: Optional['MemoryUserPreferenceMemoryStrategyStatus'] = None,
                 strategy_id: Optional[_builtins.str] = None,
                 type: Optional['MemoryUserPreferenceMemoryStrategyType'] = None,
                 updated_at: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Creation timestamp of the memory strategy
        :param 'MemoryUserPreferenceMemoryStrategyStatus' status: Status of the memory strategy
        :param _builtins.str strategy_id: Unique identifier for the memory strategy
        :param 'MemoryUserPreferenceMemoryStrategyType' type: Type of memory strategy
        :param _builtins.str updated_at: Last update timestamp of the memory strategy
        """
        pulumi.set(__self__, "name", name)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if strategy_id is not None:
            pulumi.set(__self__, "strategy_id", strategy_id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        Creation timestamp of the memory strategy
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "namespaces")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional['MemoryUserPreferenceMemoryStrategyStatus']:
        """
        Status of the memory strategy
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="strategyId")
    def strategy_id(self) -> Optional[_builtins.str]:
        """
        Unique identifier for the memory strategy
        """
        return pulumi.get(self, "strategy_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional['MemoryUserPreferenceMemoryStrategyType']:
        """
        Type of memory strategy
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.str]:
        """
        Last update timestamp of the memory strategy
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class MemoryUserPreferenceOverride(dict):
    def __init__(__self__, *,
                 consolidation: Optional['outputs.MemoryUserPreferenceOverrideConsolidationConfigurationInput'] = None,
                 extraction: Optional['outputs.MemoryUserPreferenceOverrideExtractionConfigurationInput'] = None):
        if consolidation is not None:
            pulumi.set(__self__, "consolidation", consolidation)
        if extraction is not None:
            pulumi.set(__self__, "extraction", extraction)

    @_builtins.property
    @pulumi.getter
    def consolidation(self) -> Optional['outputs.MemoryUserPreferenceOverrideConsolidationConfigurationInput']:
        return pulumi.get(self, "consolidation")

    @_builtins.property
    @pulumi.getter
    def extraction(self) -> Optional['outputs.MemoryUserPreferenceOverrideExtractionConfigurationInput']:
        return pulumi.get(self, "extraction")


@pulumi.output_type
class MemoryUserPreferenceOverrideConsolidationConfigurationInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appendToPrompt":
            suggest = "append_to_prompt"
        elif key == "modelId":
            suggest = "model_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MemoryUserPreferenceOverrideConsolidationConfigurationInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MemoryUserPreferenceOverrideConsolidationConfigurationInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MemoryUserPreferenceOverrideConsolidationConfigurationInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 append_to_prompt: _builtins.str,
                 model_id: _builtins.str):
        pulumi.set(__self__, "append_to_prompt", append_to_prompt)
        pulumi.set(__self__, "model_id", model_id)

    @_builtins.property
    @pulumi.getter(name="appendToPrompt")
    def append_to_prompt(self) -> _builtins.str:
        return pulumi.get(self, "append_to_prompt")

    @_builtins.property
    @pulumi.getter(name="modelId")
    def model_id(self) -> _builtins.str:
        return pulumi.get(self, "model_id")


@pulumi.output_type
class MemoryUserPreferenceOverrideExtractionConfigurationInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appendToPrompt":
            suggest = "append_to_prompt"
        elif key == "modelId":
            suggest = "model_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MemoryUserPreferenceOverrideExtractionConfigurationInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MemoryUserPreferenceOverrideExtractionConfigurationInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MemoryUserPreferenceOverrideExtractionConfigurationInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 append_to_prompt: _builtins.str,
                 model_id: _builtins.str):
        pulumi.set(__self__, "append_to_prompt", append_to_prompt)
        pulumi.set(__self__, "model_id", model_id)

    @_builtins.property
    @pulumi.getter(name="appendToPrompt")
    def append_to_prompt(self) -> _builtins.str:
        return pulumi.get(self, "append_to_prompt")

    @_builtins.property
    @pulumi.getter(name="modelId")
    def model_id(self) -> _builtins.str:
        return pulumi.get(self, "model_id")


@pulumi.output_type
class RuntimeAgentRuntimeArtifact(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerConfiguration":
            suggest = "container_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuntimeAgentRuntimeArtifact. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuntimeAgentRuntimeArtifact.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuntimeAgentRuntimeArtifact.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_configuration: Optional['outputs.RuntimeContainerConfiguration'] = None):
        """
        :param 'RuntimeContainerConfiguration' container_configuration: Representation of a container configuration.
        """
        if container_configuration is not None:
            pulumi.set(__self__, "container_configuration", container_configuration)

    @_builtins.property
    @pulumi.getter(name="containerConfiguration")
    def container_configuration(self) -> Optional['outputs.RuntimeContainerConfiguration']:
        """
        Representation of a container configuration.
        """
        return pulumi.get(self, "container_configuration")


@pulumi.output_type
class RuntimeAuthorizerConfiguration(dict):
    """
    Configuration for the authorizer
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customJwtAuthorizer":
            suggest = "custom_jwt_authorizer"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuntimeAuthorizerConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuntimeAuthorizerConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuntimeAuthorizerConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_jwt_authorizer: Optional['outputs.RuntimeCustomJwtAuthorizerConfiguration'] = None):
        """
        Configuration for the authorizer
        :param 'RuntimeCustomJwtAuthorizerConfiguration' custom_jwt_authorizer: Represents inbound authorization configuration options used to authenticate incoming requests.
        """
        if custom_jwt_authorizer is not None:
            pulumi.set(__self__, "custom_jwt_authorizer", custom_jwt_authorizer)

    @_builtins.property
    @pulumi.getter(name="customJwtAuthorizer")
    def custom_jwt_authorizer(self) -> Optional['outputs.RuntimeCustomJwtAuthorizerConfiguration']:
        """
        Represents inbound authorization configuration options used to authenticate incoming requests.
        """
        return pulumi.get(self, "custom_jwt_authorizer")


@pulumi.output_type
class RuntimeContainerConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerUri":
            suggest = "container_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuntimeContainerConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuntimeContainerConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuntimeContainerConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_uri: _builtins.str):
        """
        :param _builtins.str container_uri: The container Uri.
        """
        pulumi.set(__self__, "container_uri", container_uri)

    @_builtins.property
    @pulumi.getter(name="containerUri")
    def container_uri(self) -> _builtins.str:
        """
        The container Uri.
        """
        return pulumi.get(self, "container_uri")


@pulumi.output_type
class RuntimeCustomJwtAuthorizerConfiguration(dict):
    """
    Configuration for custom JWT authorizer
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "discoveryUrl":
            suggest = "discovery_url"
        elif key == "allowedAudience":
            suggest = "allowed_audience"
        elif key == "allowedClients":
            suggest = "allowed_clients"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuntimeCustomJwtAuthorizerConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuntimeCustomJwtAuthorizerConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuntimeCustomJwtAuthorizerConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 discovery_url: _builtins.str,
                 allowed_audience: Optional[Sequence[_builtins.str]] = None,
                 allowed_clients: Optional[Sequence[_builtins.str]] = None):
        """
        Configuration for custom JWT authorizer
        :param _builtins.str discovery_url: The configuration authorization.
        :param Sequence[_builtins.str] allowed_audience: Represents inbound authorization configuration options used to authenticate incoming requests.
        :param Sequence[_builtins.str] allowed_clients: Represents individual client IDs that are validated in the incoming JWT token validation process.
        """
        pulumi.set(__self__, "discovery_url", discovery_url)
        if allowed_audience is not None:
            pulumi.set(__self__, "allowed_audience", allowed_audience)
        if allowed_clients is not None:
            pulumi.set(__self__, "allowed_clients", allowed_clients)

    @_builtins.property
    @pulumi.getter(name="discoveryUrl")
    def discovery_url(self) -> _builtins.str:
        """
        The configuration authorization.
        """
        return pulumi.get(self, "discovery_url")

    @_builtins.property
    @pulumi.getter(name="allowedAudience")
    def allowed_audience(self) -> Optional[Sequence[_builtins.str]]:
        """
        Represents inbound authorization configuration options used to authenticate incoming requests.
        """
        return pulumi.get(self, "allowed_audience")

    @_builtins.property
    @pulumi.getter(name="allowedClients")
    def allowed_clients(self) -> Optional[Sequence[_builtins.str]]:
        """
        Represents individual client IDs that are validated in the incoming JWT token validation process.
        """
        return pulumi.get(self, "allowed_clients")


@pulumi.output_type
class RuntimeNetworkConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkMode":
            suggest = "network_mode"
        elif key == "networkModeConfig":
            suggest = "network_mode_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuntimeNetworkConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuntimeNetworkConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuntimeNetworkConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_mode: 'RuntimeNetworkMode',
                 network_mode_config: Optional['outputs.RuntimeVpcConfig'] = None):
        """
        :param 'RuntimeNetworkMode' network_mode: The network mode.
        """
        pulumi.set(__self__, "network_mode", network_mode)
        if network_mode_config is not None:
            pulumi.set(__self__, "network_mode_config", network_mode_config)

    @_builtins.property
    @pulumi.getter(name="networkMode")
    def network_mode(self) -> 'RuntimeNetworkMode':
        """
        The network mode.
        """
        return pulumi.get(self, "network_mode")

    @_builtins.property
    @pulumi.getter(name="networkModeConfig")
    def network_mode_config(self) -> Optional['outputs.RuntimeVpcConfig']:
        return pulumi.get(self, "network_mode_config")


@pulumi.output_type
class RuntimeVpcConfig(dict):
    """
    Network mode configuration for VPC
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityGroups":
            suggest = "security_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuntimeVpcConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuntimeVpcConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuntimeVpcConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 security_groups: Sequence[_builtins.str],
                 subnets: Sequence[_builtins.str]):
        """
        Network mode configuration for VPC
        """
        pulumi.set(__self__, "security_groups", security_groups)
        pulumi.set(__self__, "subnets", subnets)

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "security_groups")

    @_builtins.property
    @pulumi.getter
    def subnets(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "subnets")


@pulumi.output_type
class RuntimeWorkloadIdentityDetails(dict):
    """
    Configuration for workload identity
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workloadIdentityArn":
            suggest = "workload_identity_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuntimeWorkloadIdentityDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuntimeWorkloadIdentityDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuntimeWorkloadIdentityDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 workload_identity_arn: _builtins.str):
        """
        Configuration for workload identity
        :param _builtins.str workload_identity_arn: The Amazon Resource Name (ARN) for the workload identity.
        """
        pulumi.set(__self__, "workload_identity_arn", workload_identity_arn)

    @_builtins.property
    @pulumi.getter(name="workloadIdentityArn")
    def workload_identity_arn(self) -> _builtins.str:
        """
        The Amazon Resource Name (ARN) for the workload identity.
        """
        return pulumi.get(self, "workload_identity_arn")


