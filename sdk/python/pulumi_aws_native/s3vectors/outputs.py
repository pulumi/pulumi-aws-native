# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'IndexMetadataConfiguration',
    'VectorBucketEncryptionConfiguration',
    'VectorBucketPolicyPolicy',
]

@pulumi.output_type
class IndexMetadataConfiguration(dict):
    """
    The metadata configuration for the vector index.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nonFilterableMetadataKeys":
            suggest = "non_filterable_metadata_keys"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IndexMetadataConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IndexMetadataConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IndexMetadataConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 non_filterable_metadata_keys: Optional[Sequence[_builtins.str]] = None):
        """
        The metadata configuration for the vector index.
        :param Sequence[_builtins.str] non_filterable_metadata_keys: Non-filterable metadata keys allow you to enrich vectors with additional context during storage and retrieval. Unlike default metadata keys, these keys cannot be used as query filters. Non-filterable metadata keys can be retrieved but cannot be searched, queried, or filtered. You can access non-filterable metadata keys of your vectors after finding the vectors.
        """
        if non_filterable_metadata_keys is not None:
            pulumi.set(__self__, "non_filterable_metadata_keys", non_filterable_metadata_keys)

    @_builtins.property
    @pulumi.getter(name="nonFilterableMetadataKeys")
    def non_filterable_metadata_keys(self) -> Optional[Sequence[_builtins.str]]:
        """
        Non-filterable metadata keys allow you to enrich vectors with additional context during storage and retrieval. Unlike default metadata keys, these keys cannot be used as query filters. Non-filterable metadata keys can be retrieved but cannot be searched, queried, or filtered. You can access non-filterable metadata keys of your vectors after finding the vectors.
        """
        return pulumi.get(self, "non_filterable_metadata_keys")


@pulumi.output_type
class VectorBucketEncryptionConfiguration(dict):
    """
    The encryption configuration for the vector bucket.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeyArn":
            suggest = "kms_key_arn"
        elif key == "sseType":
            suggest = "sse_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VectorBucketEncryptionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VectorBucketEncryptionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VectorBucketEncryptionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_arn: Optional[_builtins.str] = None,
                 sse_type: Optional['VectorBucketEncryptionConfigurationSseType'] = None):
        """
        The encryption configuration for the vector bucket.
        :param _builtins.str kms_key_arn: AWS Key Management Service (KMS) customer managed key ID to use for the encryption configuration. This parameter is allowed if and only if sseType is set to aws:kms
        :param 'VectorBucketEncryptionConfigurationSseType' sse_type: The server-side encryption type to use for the encryption configuration of the vector bucket. By default, if you don't specify, all new vectors in Amazon S3 vector buckets use server-side encryption with Amazon S3 managed keys (SSE-S3), specifically AES256.
        """
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)
        if sse_type is not None:
            pulumi.set(__self__, "sse_type", sse_type)

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[_builtins.str]:
        """
        AWS Key Management Service (KMS) customer managed key ID to use for the encryption configuration. This parameter is allowed if and only if sseType is set to aws:kms
        """
        return pulumi.get(self, "kms_key_arn")

    @_builtins.property
    @pulumi.getter(name="sseType")
    def sse_type(self) -> Optional['VectorBucketEncryptionConfigurationSseType']:
        """
        The server-side encryption type to use for the encryption configuration of the vector bucket. By default, if you don't specify, all new vectors in Amazon S3 vector buckets use server-side encryption with Amazon S3 managed keys (SSE-S3), specifically AES256.
        """
        return pulumi.get(self, "sse_type")


@pulumi.output_type
class VectorBucketPolicyPolicy(dict):
    """
    A policy document containing permissions to add to the specified vector bucket. In IAM, you must provide policy documents in JSON format. However, in CloudFormation you can provide the policy in JSON or YAML format because CloudFormation converts YAML to JSON before submitting it to IAM.
    """
    def __init__(__self__):
        """
        A policy document containing permissions to add to the specified vector bucket. In IAM, you must provide policy documents in JSON format. However, in CloudFormation you can provide the policy in JSON or YAML format because CloudFormation converts YAML to JSON before submitting it to IAM.
        """
        pass


