# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'IndexMetadataConfigurationArgs',
    'IndexMetadataConfigurationArgsDict',
    'VectorBucketEncryptionConfigurationArgs',
    'VectorBucketEncryptionConfigurationArgsDict',
    'VectorBucketPolicyPolicyArgs',
    'VectorBucketPolicyPolicyArgsDict',
]

MYPY = False

if not MYPY:
    class IndexMetadataConfigurationArgsDict(TypedDict):
        """
        The metadata configuration for the vector index.
        """
        non_filterable_metadata_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Non-filterable metadata keys allow you to enrich vectors with additional context during storage and retrieval. Unlike default metadata keys, these keys cannot be used as query filters. Non-filterable metadata keys can be retrieved but cannot be searched, queried, or filtered. You can access non-filterable metadata keys of your vectors after finding the vectors.
        """
elif False:
    IndexMetadataConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IndexMetadataConfigurationArgs:
    def __init__(__self__, *,
                 non_filterable_metadata_keys: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        The metadata configuration for the vector index.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] non_filterable_metadata_keys: Non-filterable metadata keys allow you to enrich vectors with additional context during storage and retrieval. Unlike default metadata keys, these keys cannot be used as query filters. Non-filterable metadata keys can be retrieved but cannot be searched, queried, or filtered. You can access non-filterable metadata keys of your vectors after finding the vectors.
        """
        if non_filterable_metadata_keys is not None:
            pulumi.set(__self__, "non_filterable_metadata_keys", non_filterable_metadata_keys)

    @_builtins.property
    @pulumi.getter(name="nonFilterableMetadataKeys")
    def non_filterable_metadata_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Non-filterable metadata keys allow you to enrich vectors with additional context during storage and retrieval. Unlike default metadata keys, these keys cannot be used as query filters. Non-filterable metadata keys can be retrieved but cannot be searched, queried, or filtered. You can access non-filterable metadata keys of your vectors after finding the vectors.
        """
        return pulumi.get(self, "non_filterable_metadata_keys")

    @non_filterable_metadata_keys.setter
    def non_filterable_metadata_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "non_filterable_metadata_keys", value)


if not MYPY:
    class VectorBucketEncryptionConfigurationArgsDict(TypedDict):
        """
        The encryption configuration for the vector bucket.
        """
        kms_key_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        AWS Key Management Service (KMS) customer managed key ID to use for the encryption configuration. This parameter is allowed if and only if sseType is set to aws:kms
        """
        sse_type: NotRequired[pulumi.Input['VectorBucketEncryptionConfigurationSseType']]
        """
        The server-side encryption type to use for the encryption configuration of the vector bucket. By default, if you don't specify, all new vectors in Amazon S3 vector buckets use server-side encryption with Amazon S3 managed keys (SSE-S3), specifically AES256.
        """
elif False:
    VectorBucketEncryptionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VectorBucketEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 kms_key_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 sse_type: Optional[pulumi.Input['VectorBucketEncryptionConfigurationSseType']] = None):
        """
        The encryption configuration for the vector bucket.
        :param pulumi.Input[_builtins.str] kms_key_arn: AWS Key Management Service (KMS) customer managed key ID to use for the encryption configuration. This parameter is allowed if and only if sseType is set to aws:kms
        :param pulumi.Input['VectorBucketEncryptionConfigurationSseType'] sse_type: The server-side encryption type to use for the encryption configuration of the vector bucket. By default, if you don't specify, all new vectors in Amazon S3 vector buckets use server-side encryption with Amazon S3 managed keys (SSE-S3), specifically AES256.
        """
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)
        if sse_type is not None:
            pulumi.set(__self__, "sse_type", sse_type)

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        AWS Key Management Service (KMS) customer managed key ID to use for the encryption configuration. This parameter is allowed if and only if sseType is set to aws:kms
        """
        return pulumi.get(self, "kms_key_arn")

    @kms_key_arn.setter
    def kms_key_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_arn", value)

    @_builtins.property
    @pulumi.getter(name="sseType")
    def sse_type(self) -> Optional[pulumi.Input['VectorBucketEncryptionConfigurationSseType']]:
        """
        The server-side encryption type to use for the encryption configuration of the vector bucket. By default, if you don't specify, all new vectors in Amazon S3 vector buckets use server-side encryption with Amazon S3 managed keys (SSE-S3), specifically AES256.
        """
        return pulumi.get(self, "sse_type")

    @sse_type.setter
    def sse_type(self, value: Optional[pulumi.Input['VectorBucketEncryptionConfigurationSseType']]):
        pulumi.set(self, "sse_type", value)


if not MYPY:
    class VectorBucketPolicyPolicyArgsDict(TypedDict):
        """
        A policy document containing permissions to add to the specified vector bucket. In IAM, you must provide policy documents in JSON format. However, in CloudFormation you can provide the policy in JSON or YAML format because CloudFormation converts YAML to JSON before submitting it to IAM.
        """
        pass
elif False:
    VectorBucketPolicyPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VectorBucketPolicyPolicyArgs:
    def __init__(__self__):
        """
        A policy document containing permissions to add to the specified vector bucket. In IAM, you must provide policy documents in JSON format. However, in CloudFormation you can provide the policy in JSON or YAML format because CloudFormation converts YAML to JSON before submitting it to IAM.
        """
        pass


