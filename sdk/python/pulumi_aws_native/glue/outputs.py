# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'ClassifierCsvClassifier',
    'ClassifierGrokClassifier',
    'ClassifierJsonClassifier',
    'ClassifierXmlClassifier',
    'ConnectionInput',
    'ConnectionPhysicalConnectionRequirements',
    'CrawlerCatalogTarget',
    'CrawlerDeltaTarget',
    'CrawlerDynamoDbTarget',
    'CrawlerIcebergTarget',
    'CrawlerJdbcTarget',
    'CrawlerMongoDbTarget',
    'CrawlerRecrawlPolicy',
    'CrawlerS3Target',
    'CrawlerSchedule',
    'CrawlerSchemaChangePolicy',
    'CrawlerTargets',
    'DataCatalogEncryptionSettings',
    'DataCatalogEncryptionSettingsConnectionPasswordEncryption',
    'DataCatalogEncryptionSettingsEncryptionAtRest',
    'DataQualityRulesetDataQualityTargetTable',
    'DatabaseDataLakePrincipal',
    'DatabaseFederatedDatabase',
    'DatabaseIdentifier',
    'DatabaseInput',
    'DatabasePrincipalPrivileges',
    'JobCommand',
    'JobConnectionsList',
    'JobExecutionProperty',
    'JobNotificationProperty',
    'MlTransformFindMatchesParameters',
    'MlTransformGlueTables',
    'MlTransformInputRecordTables',
    'MlTransformMlUserDataEncryption',
    'MlTransformTransformEncryption',
    'MlTransformTransformParameters',
    'PartitionColumn',
    'PartitionInput',
    'PartitionOrder',
    'PartitionSchemaId',
    'PartitionSchemaReference',
    'PartitionSerdeInfo',
    'PartitionSkewedInfo',
    'PartitionStorageDescriptor',
    'RegistryTag',
    'SchemaRegistry',
    'SchemaTag',
    'SchemaVersion',
    'SchemaVersionSchema',
    'SecurityConfigurationCloudWatchEncryption',
    'SecurityConfigurationEncryptionConfiguration',
    'SecurityConfigurationJobBookmarksEncryption',
    'SecurityConfigurationS3Encryptions',
    'TableColumn',
    'TableIcebergInput',
    'TableIdentifier',
    'TableInput',
    'TableMetadataOperation',
    'TableOpenTableFormatInput',
    'TableOrder',
    'TableSchemaId',
    'TableSchemaReference',
    'TableSerdeInfo',
    'TableSkewedInfo',
    'TableStorageDescriptor',
    'TriggerAction',
    'TriggerCondition',
    'TriggerEventBatchingCondition',
    'TriggerNotificationProperty',
    'TriggerPredicate',
]

@pulumi.output_type
class ClassifierCsvClassifier(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowSingleColumn":
            suggest = "allow_single_column"
        elif key == "containsCustomDatatype":
            suggest = "contains_custom_datatype"
        elif key == "containsHeader":
            suggest = "contains_header"
        elif key == "customDatatypeConfigured":
            suggest = "custom_datatype_configured"
        elif key == "disableValueTrimming":
            suggest = "disable_value_trimming"
        elif key == "quoteSymbol":
            suggest = "quote_symbol"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClassifierCsvClassifier. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClassifierCsvClassifier.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClassifierCsvClassifier.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_single_column: Optional[bool] = None,
                 contains_custom_datatype: Optional[Sequence[str]] = None,
                 contains_header: Optional[str] = None,
                 custom_datatype_configured: Optional[bool] = None,
                 delimiter: Optional[str] = None,
                 disable_value_trimming: Optional[bool] = None,
                 header: Optional[Sequence[str]] = None,
                 name: Optional[str] = None,
                 quote_symbol: Optional[str] = None):
        ClassifierCsvClassifier._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow_single_column=allow_single_column,
            contains_custom_datatype=contains_custom_datatype,
            contains_header=contains_header,
            custom_datatype_configured=custom_datatype_configured,
            delimiter=delimiter,
            disable_value_trimming=disable_value_trimming,
            header=header,
            name=name,
            quote_symbol=quote_symbol,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow_single_column: Optional[bool] = None,
             contains_custom_datatype: Optional[Sequence[str]] = None,
             contains_header: Optional[str] = None,
             custom_datatype_configured: Optional[bool] = None,
             delimiter: Optional[str] = None,
             disable_value_trimming: Optional[bool] = None,
             header: Optional[Sequence[str]] = None,
             name: Optional[str] = None,
             quote_symbol: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if allow_single_column is not None:
            _setter("allow_single_column", allow_single_column)
        if contains_custom_datatype is not None:
            _setter("contains_custom_datatype", contains_custom_datatype)
        if contains_header is not None:
            _setter("contains_header", contains_header)
        if custom_datatype_configured is not None:
            _setter("custom_datatype_configured", custom_datatype_configured)
        if delimiter is not None:
            _setter("delimiter", delimiter)
        if disable_value_trimming is not None:
            _setter("disable_value_trimming", disable_value_trimming)
        if header is not None:
            _setter("header", header)
        if name is not None:
            _setter("name", name)
        if quote_symbol is not None:
            _setter("quote_symbol", quote_symbol)

    @property
    @pulumi.getter(name="allowSingleColumn")
    def allow_single_column(self) -> Optional[bool]:
        return pulumi.get(self, "allow_single_column")

    @property
    @pulumi.getter(name="containsCustomDatatype")
    def contains_custom_datatype(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "contains_custom_datatype")

    @property
    @pulumi.getter(name="containsHeader")
    def contains_header(self) -> Optional[str]:
        return pulumi.get(self, "contains_header")

    @property
    @pulumi.getter(name="customDatatypeConfigured")
    def custom_datatype_configured(self) -> Optional[bool]:
        return pulumi.get(self, "custom_datatype_configured")

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[str]:
        return pulumi.get(self, "delimiter")

    @property
    @pulumi.getter(name="disableValueTrimming")
    def disable_value_trimming(self) -> Optional[bool]:
        return pulumi.get(self, "disable_value_trimming")

    @property
    @pulumi.getter
    def header(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "header")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="quoteSymbol")
    def quote_symbol(self) -> Optional[str]:
        return pulumi.get(self, "quote_symbol")


@pulumi.output_type
class ClassifierGrokClassifier(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "grokPattern":
            suggest = "grok_pattern"
        elif key == "customPatterns":
            suggest = "custom_patterns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClassifierGrokClassifier. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClassifierGrokClassifier.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClassifierGrokClassifier.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 classification: str,
                 grok_pattern: str,
                 custom_patterns: Optional[str] = None,
                 name: Optional[str] = None):
        ClassifierGrokClassifier._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            classification=classification,
            grok_pattern=grok_pattern,
            custom_patterns=custom_patterns,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             classification: str,
             grok_pattern: str,
             custom_patterns: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("classification", classification)
        _setter("grok_pattern", grok_pattern)
        if custom_patterns is not None:
            _setter("custom_patterns", custom_patterns)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def classification(self) -> str:
        return pulumi.get(self, "classification")

    @property
    @pulumi.getter(name="grokPattern")
    def grok_pattern(self) -> str:
        return pulumi.get(self, "grok_pattern")

    @property
    @pulumi.getter(name="customPatterns")
    def custom_patterns(self) -> Optional[str]:
        return pulumi.get(self, "custom_patterns")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class ClassifierJsonClassifier(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jsonPath":
            suggest = "json_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClassifierJsonClassifier. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClassifierJsonClassifier.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClassifierJsonClassifier.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 json_path: str,
                 name: Optional[str] = None):
        ClassifierJsonClassifier._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            json_path=json_path,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             json_path: str,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("json_path", json_path)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter(name="jsonPath")
    def json_path(self) -> str:
        return pulumi.get(self, "json_path")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class ClassifierXmlClassifier(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rowTag":
            suggest = "row_tag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClassifierXmlClassifier. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClassifierXmlClassifier.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClassifierXmlClassifier.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 classification: str,
                 row_tag: str,
                 name: Optional[str] = None):
        ClassifierXmlClassifier._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            classification=classification,
            row_tag=row_tag,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             classification: str,
             row_tag: str,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("classification", classification)
        _setter("row_tag", row_tag)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def classification(self) -> str:
        return pulumi.get(self, "classification")

    @property
    @pulumi.getter(name="rowTag")
    def row_tag(self) -> str:
        return pulumi.get(self, "row_tag")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class ConnectionInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionType":
            suggest = "connection_type"
        elif key == "connectionProperties":
            suggest = "connection_properties"
        elif key == "matchCriteria":
            suggest = "match_criteria"
        elif key == "physicalConnectionRequirements":
            suggest = "physical_connection_requirements"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_type: str,
                 connection_properties: Optional[Any] = None,
                 description: Optional[str] = None,
                 match_criteria: Optional[Sequence[str]] = None,
                 name: Optional[str] = None,
                 physical_connection_requirements: Optional['outputs.ConnectionPhysicalConnectionRequirements'] = None):
        ConnectionInput._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_type=connection_type,
            connection_properties=connection_properties,
            description=description,
            match_criteria=match_criteria,
            name=name,
            physical_connection_requirements=physical_connection_requirements,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_type: str,
             connection_properties: Optional[Any] = None,
             description: Optional[str] = None,
             match_criteria: Optional[Sequence[str]] = None,
             name: Optional[str] = None,
             physical_connection_requirements: Optional['outputs.ConnectionPhysicalConnectionRequirements'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("connection_type", connection_type)
        if connection_properties is not None:
            _setter("connection_properties", connection_properties)
        if description is not None:
            _setter("description", description)
        if match_criteria is not None:
            _setter("match_criteria", match_criteria)
        if name is not None:
            _setter("name", name)
        if physical_connection_requirements is not None:
            _setter("physical_connection_requirements", physical_connection_requirements)

    @property
    @pulumi.getter(name="connectionType")
    def connection_type(self) -> str:
        return pulumi.get(self, "connection_type")

    @property
    @pulumi.getter(name="connectionProperties")
    def connection_properties(self) -> Optional[Any]:
        return pulumi.get(self, "connection_properties")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="matchCriteria")
    def match_criteria(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "match_criteria")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="physicalConnectionRequirements")
    def physical_connection_requirements(self) -> Optional['outputs.ConnectionPhysicalConnectionRequirements']:
        return pulumi.get(self, "physical_connection_requirements")


@pulumi.output_type
class ConnectionPhysicalConnectionRequirements(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"
        elif key == "securityGroupIdList":
            suggest = "security_group_id_list"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionPhysicalConnectionRequirements. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionPhysicalConnectionRequirements.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionPhysicalConnectionRequirements.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone: Optional[str] = None,
                 security_group_id_list: Optional[Sequence[str]] = None,
                 subnet_id: Optional[str] = None):
        ConnectionPhysicalConnectionRequirements._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_zone=availability_zone,
            security_group_id_list=security_group_id_list,
            subnet_id=subnet_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_zone: Optional[str] = None,
             security_group_id_list: Optional[Sequence[str]] = None,
             subnet_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if availability_zone is not None:
            _setter("availability_zone", availability_zone)
        if security_group_id_list is not None:
            _setter("security_group_id_list", security_group_id_list)
        if subnet_id is not None:
            _setter("subnet_id", subnet_id)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> Optional[str]:
        return pulumi.get(self, "availability_zone")

    @property
    @pulumi.getter(name="securityGroupIdList")
    def security_group_id_list(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "security_group_id_list")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class CrawlerCatalogTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionName":
            suggest = "connection_name"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "dlqEventQueueArn":
            suggest = "dlq_event_queue_arn"
        elif key == "eventQueueArn":
            suggest = "event_queue_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CrawlerCatalogTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CrawlerCatalogTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CrawlerCatalogTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_name: Optional[str] = None,
                 database_name: Optional[str] = None,
                 dlq_event_queue_arn: Optional[str] = None,
                 event_queue_arn: Optional[str] = None,
                 tables: Optional[Sequence[str]] = None):
        CrawlerCatalogTarget._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_name=connection_name,
            database_name=database_name,
            dlq_event_queue_arn=dlq_event_queue_arn,
            event_queue_arn=event_queue_arn,
            tables=tables,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_name: Optional[str] = None,
             database_name: Optional[str] = None,
             dlq_event_queue_arn: Optional[str] = None,
             event_queue_arn: Optional[str] = None,
             tables: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if connection_name is not None:
            _setter("connection_name", connection_name)
        if database_name is not None:
            _setter("database_name", database_name)
        if dlq_event_queue_arn is not None:
            _setter("dlq_event_queue_arn", dlq_event_queue_arn)
        if event_queue_arn is not None:
            _setter("event_queue_arn", event_queue_arn)
        if tables is not None:
            _setter("tables", tables)

    @property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> Optional[str]:
        return pulumi.get(self, "connection_name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="dlqEventQueueArn")
    def dlq_event_queue_arn(self) -> Optional[str]:
        return pulumi.get(self, "dlq_event_queue_arn")

    @property
    @pulumi.getter(name="eventQueueArn")
    def event_queue_arn(self) -> Optional[str]:
        return pulumi.get(self, "event_queue_arn")

    @property
    @pulumi.getter
    def tables(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tables")


@pulumi.output_type
class CrawlerDeltaTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionName":
            suggest = "connection_name"
        elif key == "createNativeDeltaTable":
            suggest = "create_native_delta_table"
        elif key == "deltaTables":
            suggest = "delta_tables"
        elif key == "writeManifest":
            suggest = "write_manifest"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CrawlerDeltaTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CrawlerDeltaTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CrawlerDeltaTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_name: Optional[str] = None,
                 create_native_delta_table: Optional[bool] = None,
                 delta_tables: Optional[Sequence[str]] = None,
                 write_manifest: Optional[bool] = None):
        CrawlerDeltaTarget._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_name=connection_name,
            create_native_delta_table=create_native_delta_table,
            delta_tables=delta_tables,
            write_manifest=write_manifest,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_name: Optional[str] = None,
             create_native_delta_table: Optional[bool] = None,
             delta_tables: Optional[Sequence[str]] = None,
             write_manifest: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if connection_name is not None:
            _setter("connection_name", connection_name)
        if create_native_delta_table is not None:
            _setter("create_native_delta_table", create_native_delta_table)
        if delta_tables is not None:
            _setter("delta_tables", delta_tables)
        if write_manifest is not None:
            _setter("write_manifest", write_manifest)

    @property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> Optional[str]:
        return pulumi.get(self, "connection_name")

    @property
    @pulumi.getter(name="createNativeDeltaTable")
    def create_native_delta_table(self) -> Optional[bool]:
        return pulumi.get(self, "create_native_delta_table")

    @property
    @pulumi.getter(name="deltaTables")
    def delta_tables(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "delta_tables")

    @property
    @pulumi.getter(name="writeManifest")
    def write_manifest(self) -> Optional[bool]:
        return pulumi.get(self, "write_manifest")


@pulumi.output_type
class CrawlerDynamoDbTarget(dict):
    def __init__(__self__, *,
                 path: Optional[str] = None):
        CrawlerDynamoDbTarget._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            path=path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if path is not None:
            _setter("path", path)

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")


@pulumi.output_type
class CrawlerIcebergTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionName":
            suggest = "connection_name"
        elif key == "maximumTraversalDepth":
            suggest = "maximum_traversal_depth"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CrawlerIcebergTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CrawlerIcebergTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CrawlerIcebergTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_name: Optional[str] = None,
                 exclusions: Optional[Sequence[str]] = None,
                 maximum_traversal_depth: Optional[int] = None,
                 paths: Optional[Sequence[str]] = None):
        CrawlerIcebergTarget._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_name=connection_name,
            exclusions=exclusions,
            maximum_traversal_depth=maximum_traversal_depth,
            paths=paths,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_name: Optional[str] = None,
             exclusions: Optional[Sequence[str]] = None,
             maximum_traversal_depth: Optional[int] = None,
             paths: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if connection_name is not None:
            _setter("connection_name", connection_name)
        if exclusions is not None:
            _setter("exclusions", exclusions)
        if maximum_traversal_depth is not None:
            _setter("maximum_traversal_depth", maximum_traversal_depth)
        if paths is not None:
            _setter("paths", paths)

    @property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> Optional[str]:
        return pulumi.get(self, "connection_name")

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "exclusions")

    @property
    @pulumi.getter(name="maximumTraversalDepth")
    def maximum_traversal_depth(self) -> Optional[int]:
        return pulumi.get(self, "maximum_traversal_depth")

    @property
    @pulumi.getter
    def paths(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "paths")


@pulumi.output_type
class CrawlerJdbcTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionName":
            suggest = "connection_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CrawlerJdbcTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CrawlerJdbcTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CrawlerJdbcTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_name: Optional[str] = None,
                 exclusions: Optional[Sequence[str]] = None,
                 path: Optional[str] = None):
        CrawlerJdbcTarget._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_name=connection_name,
            exclusions=exclusions,
            path=path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_name: Optional[str] = None,
             exclusions: Optional[Sequence[str]] = None,
             path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if connection_name is not None:
            _setter("connection_name", connection_name)
        if exclusions is not None:
            _setter("exclusions", exclusions)
        if path is not None:
            _setter("path", path)

    @property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> Optional[str]:
        return pulumi.get(self, "connection_name")

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "exclusions")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")


@pulumi.output_type
class CrawlerMongoDbTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionName":
            suggest = "connection_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CrawlerMongoDbTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CrawlerMongoDbTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CrawlerMongoDbTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_name: Optional[str] = None,
                 path: Optional[str] = None):
        CrawlerMongoDbTarget._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_name=connection_name,
            path=path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_name: Optional[str] = None,
             path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if connection_name is not None:
            _setter("connection_name", connection_name)
        if path is not None:
            _setter("path", path)

    @property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> Optional[str]:
        return pulumi.get(self, "connection_name")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")


@pulumi.output_type
class CrawlerRecrawlPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recrawlBehavior":
            suggest = "recrawl_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CrawlerRecrawlPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CrawlerRecrawlPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CrawlerRecrawlPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 recrawl_behavior: Optional[str] = None):
        CrawlerRecrawlPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            recrawl_behavior=recrawl_behavior,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             recrawl_behavior: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if recrawl_behavior is not None:
            _setter("recrawl_behavior", recrawl_behavior)

    @property
    @pulumi.getter(name="recrawlBehavior")
    def recrawl_behavior(self) -> Optional[str]:
        return pulumi.get(self, "recrawl_behavior")


@pulumi.output_type
class CrawlerS3Target(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionName":
            suggest = "connection_name"
        elif key == "dlqEventQueueArn":
            suggest = "dlq_event_queue_arn"
        elif key == "eventQueueArn":
            suggest = "event_queue_arn"
        elif key == "sampleSize":
            suggest = "sample_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CrawlerS3Target. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CrawlerS3Target.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CrawlerS3Target.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_name: Optional[str] = None,
                 dlq_event_queue_arn: Optional[str] = None,
                 event_queue_arn: Optional[str] = None,
                 exclusions: Optional[Sequence[str]] = None,
                 path: Optional[str] = None,
                 sample_size: Optional[int] = None):
        CrawlerS3Target._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_name=connection_name,
            dlq_event_queue_arn=dlq_event_queue_arn,
            event_queue_arn=event_queue_arn,
            exclusions=exclusions,
            path=path,
            sample_size=sample_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_name: Optional[str] = None,
             dlq_event_queue_arn: Optional[str] = None,
             event_queue_arn: Optional[str] = None,
             exclusions: Optional[Sequence[str]] = None,
             path: Optional[str] = None,
             sample_size: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if connection_name is not None:
            _setter("connection_name", connection_name)
        if dlq_event_queue_arn is not None:
            _setter("dlq_event_queue_arn", dlq_event_queue_arn)
        if event_queue_arn is not None:
            _setter("event_queue_arn", event_queue_arn)
        if exclusions is not None:
            _setter("exclusions", exclusions)
        if path is not None:
            _setter("path", path)
        if sample_size is not None:
            _setter("sample_size", sample_size)

    @property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> Optional[str]:
        return pulumi.get(self, "connection_name")

    @property
    @pulumi.getter(name="dlqEventQueueArn")
    def dlq_event_queue_arn(self) -> Optional[str]:
        return pulumi.get(self, "dlq_event_queue_arn")

    @property
    @pulumi.getter(name="eventQueueArn")
    def event_queue_arn(self) -> Optional[str]:
        return pulumi.get(self, "event_queue_arn")

    @property
    @pulumi.getter
    def exclusions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "exclusions")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="sampleSize")
    def sample_size(self) -> Optional[int]:
        return pulumi.get(self, "sample_size")


@pulumi.output_type
class CrawlerSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scheduleExpression":
            suggest = "schedule_expression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CrawlerSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CrawlerSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CrawlerSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 schedule_expression: Optional[str] = None):
        CrawlerSchedule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            schedule_expression=schedule_expression,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             schedule_expression: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if schedule_expression is not None:
            _setter("schedule_expression", schedule_expression)

    @property
    @pulumi.getter(name="scheduleExpression")
    def schedule_expression(self) -> Optional[str]:
        return pulumi.get(self, "schedule_expression")


@pulumi.output_type
class CrawlerSchemaChangePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteBehavior":
            suggest = "delete_behavior"
        elif key == "updateBehavior":
            suggest = "update_behavior"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CrawlerSchemaChangePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CrawlerSchemaChangePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CrawlerSchemaChangePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_behavior: Optional[str] = None,
                 update_behavior: Optional[str] = None):
        CrawlerSchemaChangePolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            delete_behavior=delete_behavior,
            update_behavior=update_behavior,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             delete_behavior: Optional[str] = None,
             update_behavior: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if delete_behavior is not None:
            _setter("delete_behavior", delete_behavior)
        if update_behavior is not None:
            _setter("update_behavior", update_behavior)

    @property
    @pulumi.getter(name="deleteBehavior")
    def delete_behavior(self) -> Optional[str]:
        return pulumi.get(self, "delete_behavior")

    @property
    @pulumi.getter(name="updateBehavior")
    def update_behavior(self) -> Optional[str]:
        return pulumi.get(self, "update_behavior")


@pulumi.output_type
class CrawlerTargets(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "catalogTargets":
            suggest = "catalog_targets"
        elif key == "deltaTargets":
            suggest = "delta_targets"
        elif key == "dynamoDbTargets":
            suggest = "dynamo_db_targets"
        elif key == "icebergTargets":
            suggest = "iceberg_targets"
        elif key == "jdbcTargets":
            suggest = "jdbc_targets"
        elif key == "mongoDbTargets":
            suggest = "mongo_db_targets"
        elif key == "s3Targets":
            suggest = "s3_targets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CrawlerTargets. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CrawlerTargets.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CrawlerTargets.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 catalog_targets: Optional[Sequence['outputs.CrawlerCatalogTarget']] = None,
                 delta_targets: Optional[Sequence['outputs.CrawlerDeltaTarget']] = None,
                 dynamo_db_targets: Optional[Sequence['outputs.CrawlerDynamoDbTarget']] = None,
                 iceberg_targets: Optional[Sequence['outputs.CrawlerIcebergTarget']] = None,
                 jdbc_targets: Optional[Sequence['outputs.CrawlerJdbcTarget']] = None,
                 mongo_db_targets: Optional[Sequence['outputs.CrawlerMongoDbTarget']] = None,
                 s3_targets: Optional[Sequence['outputs.CrawlerS3Target']] = None):
        CrawlerTargets._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            catalog_targets=catalog_targets,
            delta_targets=delta_targets,
            dynamo_db_targets=dynamo_db_targets,
            iceberg_targets=iceberg_targets,
            jdbc_targets=jdbc_targets,
            mongo_db_targets=mongo_db_targets,
            s3_targets=s3_targets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             catalog_targets: Optional[Sequence['outputs.CrawlerCatalogTarget']] = None,
             delta_targets: Optional[Sequence['outputs.CrawlerDeltaTarget']] = None,
             dynamo_db_targets: Optional[Sequence['outputs.CrawlerDynamoDbTarget']] = None,
             iceberg_targets: Optional[Sequence['outputs.CrawlerIcebergTarget']] = None,
             jdbc_targets: Optional[Sequence['outputs.CrawlerJdbcTarget']] = None,
             mongo_db_targets: Optional[Sequence['outputs.CrawlerMongoDbTarget']] = None,
             s3_targets: Optional[Sequence['outputs.CrawlerS3Target']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if catalog_targets is not None:
            _setter("catalog_targets", catalog_targets)
        if delta_targets is not None:
            _setter("delta_targets", delta_targets)
        if dynamo_db_targets is not None:
            _setter("dynamo_db_targets", dynamo_db_targets)
        if iceberg_targets is not None:
            _setter("iceberg_targets", iceberg_targets)
        if jdbc_targets is not None:
            _setter("jdbc_targets", jdbc_targets)
        if mongo_db_targets is not None:
            _setter("mongo_db_targets", mongo_db_targets)
        if s3_targets is not None:
            _setter("s3_targets", s3_targets)

    @property
    @pulumi.getter(name="catalogTargets")
    def catalog_targets(self) -> Optional[Sequence['outputs.CrawlerCatalogTarget']]:
        return pulumi.get(self, "catalog_targets")

    @property
    @pulumi.getter(name="deltaTargets")
    def delta_targets(self) -> Optional[Sequence['outputs.CrawlerDeltaTarget']]:
        return pulumi.get(self, "delta_targets")

    @property
    @pulumi.getter(name="dynamoDbTargets")
    def dynamo_db_targets(self) -> Optional[Sequence['outputs.CrawlerDynamoDbTarget']]:
        return pulumi.get(self, "dynamo_db_targets")

    @property
    @pulumi.getter(name="icebergTargets")
    def iceberg_targets(self) -> Optional[Sequence['outputs.CrawlerIcebergTarget']]:
        return pulumi.get(self, "iceberg_targets")

    @property
    @pulumi.getter(name="jdbcTargets")
    def jdbc_targets(self) -> Optional[Sequence['outputs.CrawlerJdbcTarget']]:
        return pulumi.get(self, "jdbc_targets")

    @property
    @pulumi.getter(name="mongoDbTargets")
    def mongo_db_targets(self) -> Optional[Sequence['outputs.CrawlerMongoDbTarget']]:
        return pulumi.get(self, "mongo_db_targets")

    @property
    @pulumi.getter(name="s3Targets")
    def s3_targets(self) -> Optional[Sequence['outputs.CrawlerS3Target']]:
        return pulumi.get(self, "s3_targets")


@pulumi.output_type
class DataCatalogEncryptionSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionPasswordEncryption":
            suggest = "connection_password_encryption"
        elif key == "encryptionAtRest":
            suggest = "encryption_at_rest"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCatalogEncryptionSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCatalogEncryptionSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCatalogEncryptionSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_password_encryption: Optional['outputs.DataCatalogEncryptionSettingsConnectionPasswordEncryption'] = None,
                 encryption_at_rest: Optional['outputs.DataCatalogEncryptionSettingsEncryptionAtRest'] = None):
        DataCatalogEncryptionSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_password_encryption=connection_password_encryption,
            encryption_at_rest=encryption_at_rest,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_password_encryption: Optional['outputs.DataCatalogEncryptionSettingsConnectionPasswordEncryption'] = None,
             encryption_at_rest: Optional['outputs.DataCatalogEncryptionSettingsEncryptionAtRest'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if connection_password_encryption is not None:
            _setter("connection_password_encryption", connection_password_encryption)
        if encryption_at_rest is not None:
            _setter("encryption_at_rest", encryption_at_rest)

    @property
    @pulumi.getter(name="connectionPasswordEncryption")
    def connection_password_encryption(self) -> Optional['outputs.DataCatalogEncryptionSettingsConnectionPasswordEncryption']:
        return pulumi.get(self, "connection_password_encryption")

    @property
    @pulumi.getter(name="encryptionAtRest")
    def encryption_at_rest(self) -> Optional['outputs.DataCatalogEncryptionSettingsEncryptionAtRest']:
        return pulumi.get(self, "encryption_at_rest")


@pulumi.output_type
class DataCatalogEncryptionSettingsConnectionPasswordEncryption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeyId":
            suggest = "kms_key_id"
        elif key == "returnConnectionPasswordEncrypted":
            suggest = "return_connection_password_encrypted"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCatalogEncryptionSettingsConnectionPasswordEncryption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCatalogEncryptionSettingsConnectionPasswordEncryption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCatalogEncryptionSettingsConnectionPasswordEncryption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_id: Optional[str] = None,
                 return_connection_password_encrypted: Optional[bool] = None):
        DataCatalogEncryptionSettingsConnectionPasswordEncryption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            kms_key_id=kms_key_id,
            return_connection_password_encrypted=return_connection_password_encrypted,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             kms_key_id: Optional[str] = None,
             return_connection_password_encrypted: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if kms_key_id is not None:
            _setter("kms_key_id", kms_key_id)
        if return_connection_password_encrypted is not None:
            _setter("return_connection_password_encrypted", return_connection_password_encrypted)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        return pulumi.get(self, "kms_key_id")

    @property
    @pulumi.getter(name="returnConnectionPasswordEncrypted")
    def return_connection_password_encrypted(self) -> Optional[bool]:
        return pulumi.get(self, "return_connection_password_encrypted")


@pulumi.output_type
class DataCatalogEncryptionSettingsEncryptionAtRest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "catalogEncryptionMode":
            suggest = "catalog_encryption_mode"
        elif key == "sseAwsKmsKeyId":
            suggest = "sse_aws_kms_key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataCatalogEncryptionSettingsEncryptionAtRest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataCatalogEncryptionSettingsEncryptionAtRest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataCatalogEncryptionSettingsEncryptionAtRest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 catalog_encryption_mode: Optional[str] = None,
                 sse_aws_kms_key_id: Optional[str] = None):
        DataCatalogEncryptionSettingsEncryptionAtRest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            catalog_encryption_mode=catalog_encryption_mode,
            sse_aws_kms_key_id=sse_aws_kms_key_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             catalog_encryption_mode: Optional[str] = None,
             sse_aws_kms_key_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if catalog_encryption_mode is not None:
            _setter("catalog_encryption_mode", catalog_encryption_mode)
        if sse_aws_kms_key_id is not None:
            _setter("sse_aws_kms_key_id", sse_aws_kms_key_id)

    @property
    @pulumi.getter(name="catalogEncryptionMode")
    def catalog_encryption_mode(self) -> Optional[str]:
        return pulumi.get(self, "catalog_encryption_mode")

    @property
    @pulumi.getter(name="sseAwsKmsKeyId")
    def sse_aws_kms_key_id(self) -> Optional[str]:
        return pulumi.get(self, "sse_aws_kms_key_id")


@pulumi.output_type
class DataQualityRulesetDataQualityTargetTable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "tableName":
            suggest = "table_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataQualityRulesetDataQualityTargetTable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataQualityRulesetDataQualityTargetTable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataQualityRulesetDataQualityTargetTable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: Optional[str] = None,
                 table_name: Optional[str] = None):
        DataQualityRulesetDataQualityTargetTable._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_name=database_name,
            table_name=table_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_name: Optional[str] = None,
             table_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if database_name is not None:
            _setter("database_name", database_name)
        if table_name is not None:
            _setter("table_name", table_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> Optional[str]:
        return pulumi.get(self, "table_name")


@pulumi.output_type
class DatabaseDataLakePrincipal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataLakePrincipalIdentifier":
            suggest = "data_lake_principal_identifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseDataLakePrincipal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseDataLakePrincipal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseDataLakePrincipal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_lake_principal_identifier: Optional[str] = None):
        DatabaseDataLakePrincipal._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_lake_principal_identifier=data_lake_principal_identifier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_lake_principal_identifier: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if data_lake_principal_identifier is not None:
            _setter("data_lake_principal_identifier", data_lake_principal_identifier)

    @property
    @pulumi.getter(name="dataLakePrincipalIdentifier")
    def data_lake_principal_identifier(self) -> Optional[str]:
        return pulumi.get(self, "data_lake_principal_identifier")


@pulumi.output_type
class DatabaseFederatedDatabase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionName":
            suggest = "connection_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseFederatedDatabase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseFederatedDatabase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseFederatedDatabase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_name: Optional[str] = None,
                 identifier: Optional[str] = None):
        DatabaseFederatedDatabase._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection_name=connection_name,
            identifier=identifier,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection_name: Optional[str] = None,
             identifier: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if connection_name is not None:
            _setter("connection_name", connection_name)
        if identifier is not None:
            _setter("identifier", identifier)

    @property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> Optional[str]:
        return pulumi.get(self, "connection_name")

    @property
    @pulumi.getter
    def identifier(self) -> Optional[str]:
        return pulumi.get(self, "identifier")


@pulumi.output_type
class DatabaseIdentifier(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "catalogId":
            suggest = "catalog_id"
        elif key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseIdentifier. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseIdentifier.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseIdentifier.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 catalog_id: Optional[str] = None,
                 database_name: Optional[str] = None,
                 region: Optional[str] = None):
        DatabaseIdentifier._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            catalog_id=catalog_id,
            database_name=database_name,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             catalog_id: Optional[str] = None,
             database_name: Optional[str] = None,
             region: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if catalog_id is not None:
            _setter("catalog_id", catalog_id)
        if database_name is not None:
            _setter("database_name", database_name)
        if region is not None:
            _setter("region", region)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[str]:
        return pulumi.get(self, "catalog_id")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class DatabaseInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createTableDefaultPermissions":
            suggest = "create_table_default_permissions"
        elif key == "federatedDatabase":
            suggest = "federated_database"
        elif key == "locationUri":
            suggest = "location_uri"
        elif key == "targetDatabase":
            suggest = "target_database"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 create_table_default_permissions: Optional[Sequence['outputs.DatabasePrincipalPrivileges']] = None,
                 description: Optional[str] = None,
                 federated_database: Optional['outputs.DatabaseFederatedDatabase'] = None,
                 location_uri: Optional[str] = None,
                 name: Optional[str] = None,
                 parameters: Optional[Any] = None,
                 target_database: Optional['outputs.DatabaseIdentifier'] = None):
        DatabaseInput._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            create_table_default_permissions=create_table_default_permissions,
            description=description,
            federated_database=federated_database,
            location_uri=location_uri,
            name=name,
            parameters=parameters,
            target_database=target_database,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             create_table_default_permissions: Optional[Sequence['outputs.DatabasePrincipalPrivileges']] = None,
             description: Optional[str] = None,
             federated_database: Optional['outputs.DatabaseFederatedDatabase'] = None,
             location_uri: Optional[str] = None,
             name: Optional[str] = None,
             parameters: Optional[Any] = None,
             target_database: Optional['outputs.DatabaseIdentifier'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if create_table_default_permissions is not None:
            _setter("create_table_default_permissions", create_table_default_permissions)
        if description is not None:
            _setter("description", description)
        if federated_database is not None:
            _setter("federated_database", federated_database)
        if location_uri is not None:
            _setter("location_uri", location_uri)
        if name is not None:
            _setter("name", name)
        if parameters is not None:
            _setter("parameters", parameters)
        if target_database is not None:
            _setter("target_database", target_database)

    @property
    @pulumi.getter(name="createTableDefaultPermissions")
    def create_table_default_permissions(self) -> Optional[Sequence['outputs.DatabasePrincipalPrivileges']]:
        return pulumi.get(self, "create_table_default_permissions")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="federatedDatabase")
    def federated_database(self) -> Optional['outputs.DatabaseFederatedDatabase']:
        return pulumi.get(self, "federated_database")

    @property
    @pulumi.getter(name="locationUri")
    def location_uri(self) -> Optional[str]:
        return pulumi.get(self, "location_uri")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Any]:
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="targetDatabase")
    def target_database(self) -> Optional['outputs.DatabaseIdentifier']:
        return pulumi.get(self, "target_database")


@pulumi.output_type
class DatabasePrincipalPrivileges(dict):
    def __init__(__self__, *,
                 permissions: Optional[Sequence[str]] = None,
                 principal: Optional['outputs.DatabaseDataLakePrincipal'] = None):
        DatabasePrincipalPrivileges._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            permissions=permissions,
            principal=principal,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             permissions: Optional[Sequence[str]] = None,
             principal: Optional['outputs.DatabaseDataLakePrincipal'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if permissions is not None:
            _setter("permissions", permissions)
        if principal is not None:
            _setter("principal", principal)

    @property
    @pulumi.getter
    def permissions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "permissions")

    @property
    @pulumi.getter
    def principal(self) -> Optional['outputs.DatabaseDataLakePrincipal']:
        return pulumi.get(self, "principal")


@pulumi.output_type
class JobCommand(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pythonVersion":
            suggest = "python_version"
        elif key == "scriptLocation":
            suggest = "script_location"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobCommand. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobCommand.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobCommand.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 python_version: Optional[str] = None,
                 runtime: Optional[str] = None,
                 script_location: Optional[str] = None):
        JobCommand._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            python_version=python_version,
            runtime=runtime,
            script_location=script_location,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             python_version: Optional[str] = None,
             runtime: Optional[str] = None,
             script_location: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)
        if python_version is not None:
            _setter("python_version", python_version)
        if runtime is not None:
            _setter("runtime", runtime)
        if script_location is not None:
            _setter("script_location", script_location)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="pythonVersion")
    def python_version(self) -> Optional[str]:
        return pulumi.get(self, "python_version")

    @property
    @pulumi.getter
    def runtime(self) -> Optional[str]:
        return pulumi.get(self, "runtime")

    @property
    @pulumi.getter(name="scriptLocation")
    def script_location(self) -> Optional[str]:
        return pulumi.get(self, "script_location")


@pulumi.output_type
class JobConnectionsList(dict):
    def __init__(__self__, *,
                 connections: Optional[Sequence[str]] = None):
        JobConnectionsList._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connections=connections,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connections: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if connections is not None:
            _setter("connections", connections)

    @property
    @pulumi.getter
    def connections(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "connections")


@pulumi.output_type
class JobExecutionProperty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConcurrentRuns":
            suggest = "max_concurrent_runs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobExecutionProperty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobExecutionProperty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobExecutionProperty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_concurrent_runs: Optional[float] = None):
        JobExecutionProperty._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_concurrent_runs=max_concurrent_runs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_concurrent_runs: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if max_concurrent_runs is not None:
            _setter("max_concurrent_runs", max_concurrent_runs)

    @property
    @pulumi.getter(name="maxConcurrentRuns")
    def max_concurrent_runs(self) -> Optional[float]:
        return pulumi.get(self, "max_concurrent_runs")


@pulumi.output_type
class JobNotificationProperty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notifyDelayAfter":
            suggest = "notify_delay_after"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobNotificationProperty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobNotificationProperty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobNotificationProperty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 notify_delay_after: Optional[int] = None):
        JobNotificationProperty._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            notify_delay_after=notify_delay_after,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             notify_delay_after: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if notify_delay_after is not None:
            _setter("notify_delay_after", notify_delay_after)

    @property
    @pulumi.getter(name="notifyDelayAfter")
    def notify_delay_after(self) -> Optional[int]:
        return pulumi.get(self, "notify_delay_after")


@pulumi.output_type
class MlTransformFindMatchesParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "primaryKeyColumnName":
            suggest = "primary_key_column_name"
        elif key == "accuracyCostTradeoff":
            suggest = "accuracy_cost_tradeoff"
        elif key == "enforceProvidedLabels":
            suggest = "enforce_provided_labels"
        elif key == "precisionRecallTradeoff":
            suggest = "precision_recall_tradeoff"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MlTransformFindMatchesParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MlTransformFindMatchesParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MlTransformFindMatchesParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 primary_key_column_name: str,
                 accuracy_cost_tradeoff: Optional[float] = None,
                 enforce_provided_labels: Optional[bool] = None,
                 precision_recall_tradeoff: Optional[float] = None):
        MlTransformFindMatchesParameters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            primary_key_column_name=primary_key_column_name,
            accuracy_cost_tradeoff=accuracy_cost_tradeoff,
            enforce_provided_labels=enforce_provided_labels,
            precision_recall_tradeoff=precision_recall_tradeoff,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             primary_key_column_name: str,
             accuracy_cost_tradeoff: Optional[float] = None,
             enforce_provided_labels: Optional[bool] = None,
             precision_recall_tradeoff: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("primary_key_column_name", primary_key_column_name)
        if accuracy_cost_tradeoff is not None:
            _setter("accuracy_cost_tradeoff", accuracy_cost_tradeoff)
        if enforce_provided_labels is not None:
            _setter("enforce_provided_labels", enforce_provided_labels)
        if precision_recall_tradeoff is not None:
            _setter("precision_recall_tradeoff", precision_recall_tradeoff)

    @property
    @pulumi.getter(name="primaryKeyColumnName")
    def primary_key_column_name(self) -> str:
        return pulumi.get(self, "primary_key_column_name")

    @property
    @pulumi.getter(name="accuracyCostTradeoff")
    def accuracy_cost_tradeoff(self) -> Optional[float]:
        return pulumi.get(self, "accuracy_cost_tradeoff")

    @property
    @pulumi.getter(name="enforceProvidedLabels")
    def enforce_provided_labels(self) -> Optional[bool]:
        return pulumi.get(self, "enforce_provided_labels")

    @property
    @pulumi.getter(name="precisionRecallTradeoff")
    def precision_recall_tradeoff(self) -> Optional[float]:
        return pulumi.get(self, "precision_recall_tradeoff")


@pulumi.output_type
class MlTransformGlueTables(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "tableName":
            suggest = "table_name"
        elif key == "catalogId":
            suggest = "catalog_id"
        elif key == "connectionName":
            suggest = "connection_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MlTransformGlueTables. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MlTransformGlueTables.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MlTransformGlueTables.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: str,
                 table_name: str,
                 catalog_id: Optional[str] = None,
                 connection_name: Optional[str] = None):
        MlTransformGlueTables._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_name=database_name,
            table_name=table_name,
            catalog_id=catalog_id,
            connection_name=connection_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_name: str,
             table_name: str,
             catalog_id: Optional[str] = None,
             connection_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("database_name", database_name)
        _setter("table_name", table_name)
        if catalog_id is not None:
            _setter("catalog_id", catalog_id)
        if connection_name is not None:
            _setter("connection_name", connection_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> str:
        return pulumi.get(self, "table_name")

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[str]:
        return pulumi.get(self, "catalog_id")

    @property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> Optional[str]:
        return pulumi.get(self, "connection_name")


@pulumi.output_type
class MlTransformInputRecordTables(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "glueTables":
            suggest = "glue_tables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MlTransformInputRecordTables. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MlTransformInputRecordTables.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MlTransformInputRecordTables.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 glue_tables: Optional[Sequence['outputs.MlTransformGlueTables']] = None):
        MlTransformInputRecordTables._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            glue_tables=glue_tables,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             glue_tables: Optional[Sequence['outputs.MlTransformGlueTables']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if glue_tables is not None:
            _setter("glue_tables", glue_tables)

    @property
    @pulumi.getter(name="glueTables")
    def glue_tables(self) -> Optional[Sequence['outputs.MlTransformGlueTables']]:
        return pulumi.get(self, "glue_tables")


@pulumi.output_type
class MlTransformMlUserDataEncryption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mlUserDataEncryptionMode":
            suggest = "ml_user_data_encryption_mode"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MlTransformMlUserDataEncryption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MlTransformMlUserDataEncryption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MlTransformMlUserDataEncryption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ml_user_data_encryption_mode: str,
                 kms_key_id: Optional[str] = None):
        MlTransformMlUserDataEncryption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ml_user_data_encryption_mode=ml_user_data_encryption_mode,
            kms_key_id=kms_key_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ml_user_data_encryption_mode: str,
             kms_key_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("ml_user_data_encryption_mode", ml_user_data_encryption_mode)
        if kms_key_id is not None:
            _setter("kms_key_id", kms_key_id)

    @property
    @pulumi.getter(name="mlUserDataEncryptionMode")
    def ml_user_data_encryption_mode(self) -> str:
        return pulumi.get(self, "ml_user_data_encryption_mode")

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[str]:
        return pulumi.get(self, "kms_key_id")


@pulumi.output_type
class MlTransformTransformEncryption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mlUserDataEncryption":
            suggest = "ml_user_data_encryption"
        elif key == "taskRunSecurityConfigurationName":
            suggest = "task_run_security_configuration_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MlTransformTransformEncryption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MlTransformTransformEncryption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MlTransformTransformEncryption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ml_user_data_encryption: Optional['outputs.MlTransformMlUserDataEncryption'] = None,
                 task_run_security_configuration_name: Optional[str] = None):
        MlTransformTransformEncryption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ml_user_data_encryption=ml_user_data_encryption,
            task_run_security_configuration_name=task_run_security_configuration_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ml_user_data_encryption: Optional['outputs.MlTransformMlUserDataEncryption'] = None,
             task_run_security_configuration_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if ml_user_data_encryption is not None:
            _setter("ml_user_data_encryption", ml_user_data_encryption)
        if task_run_security_configuration_name is not None:
            _setter("task_run_security_configuration_name", task_run_security_configuration_name)

    @property
    @pulumi.getter(name="mlUserDataEncryption")
    def ml_user_data_encryption(self) -> Optional['outputs.MlTransformMlUserDataEncryption']:
        return pulumi.get(self, "ml_user_data_encryption")

    @property
    @pulumi.getter(name="taskRunSecurityConfigurationName")
    def task_run_security_configuration_name(self) -> Optional[str]:
        return pulumi.get(self, "task_run_security_configuration_name")


@pulumi.output_type
class MlTransformTransformParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "transformType":
            suggest = "transform_type"
        elif key == "findMatchesParameters":
            suggest = "find_matches_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MlTransformTransformParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MlTransformTransformParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MlTransformTransformParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 transform_type: str,
                 find_matches_parameters: Optional['outputs.MlTransformFindMatchesParameters'] = None):
        MlTransformTransformParameters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            transform_type=transform_type,
            find_matches_parameters=find_matches_parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             transform_type: str,
             find_matches_parameters: Optional['outputs.MlTransformFindMatchesParameters'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("transform_type", transform_type)
        if find_matches_parameters is not None:
            _setter("find_matches_parameters", find_matches_parameters)

    @property
    @pulumi.getter(name="transformType")
    def transform_type(self) -> str:
        return pulumi.get(self, "transform_type")

    @property
    @pulumi.getter(name="findMatchesParameters")
    def find_matches_parameters(self) -> Optional['outputs.MlTransformFindMatchesParameters']:
        return pulumi.get(self, "find_matches_parameters")


@pulumi.output_type
class PartitionColumn(dict):
    def __init__(__self__, *,
                 name: str,
                 comment: Optional[str] = None,
                 type: Optional[str] = None):
        PartitionColumn._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            comment=comment,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             comment: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        if comment is not None:
            _setter("comment", comment)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def comment(self) -> Optional[str]:
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class PartitionInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageDescriptor":
            suggest = "storage_descriptor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PartitionInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PartitionInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PartitionInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 values: Sequence[str],
                 parameters: Optional[Any] = None,
                 storage_descriptor: Optional['outputs.PartitionStorageDescriptor'] = None):
        PartitionInput._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            values=values,
            parameters=parameters,
            storage_descriptor=storage_descriptor,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             values: Sequence[str],
             parameters: Optional[Any] = None,
             storage_descriptor: Optional['outputs.PartitionStorageDescriptor'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("values", values)
        if parameters is not None:
            _setter("parameters", parameters)
        if storage_descriptor is not None:
            _setter("storage_descriptor", storage_descriptor)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Any]:
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="storageDescriptor")
    def storage_descriptor(self) -> Optional['outputs.PartitionStorageDescriptor']:
        return pulumi.get(self, "storage_descriptor")


@pulumi.output_type
class PartitionOrder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortOrder":
            suggest = "sort_order"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PartitionOrder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PartitionOrder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PartitionOrder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: str,
                 sort_order: Optional[int] = None):
        PartitionOrder._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            sort_order=sort_order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: str,
             sort_order: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        if sort_order is not None:
            _setter("sort_order", sort_order)

    @property
    @pulumi.getter
    def column(self) -> str:
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="sortOrder")
    def sort_order(self) -> Optional[int]:
        return pulumi.get(self, "sort_order")


@pulumi.output_type
class PartitionSchemaId(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "registryName":
            suggest = "registry_name"
        elif key == "schemaArn":
            suggest = "schema_arn"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PartitionSchemaId. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PartitionSchemaId.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PartitionSchemaId.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 registry_name: Optional[str] = None,
                 schema_arn: Optional[str] = None,
                 schema_name: Optional[str] = None):
        PartitionSchemaId._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            registry_name=registry_name,
            schema_arn=schema_arn,
            schema_name=schema_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             registry_name: Optional[str] = None,
             schema_arn: Optional[str] = None,
             schema_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if registry_name is not None:
            _setter("registry_name", registry_name)
        if schema_arn is not None:
            _setter("schema_arn", schema_arn)
        if schema_name is not None:
            _setter("schema_name", schema_name)

    @property
    @pulumi.getter(name="registryName")
    def registry_name(self) -> Optional[str]:
        return pulumi.get(self, "registry_name")

    @property
    @pulumi.getter(name="schemaArn")
    def schema_arn(self) -> Optional[str]:
        return pulumi.get(self, "schema_arn")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class PartitionSchemaReference(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "schemaId":
            suggest = "schema_id"
        elif key == "schemaVersionId":
            suggest = "schema_version_id"
        elif key == "schemaVersionNumber":
            suggest = "schema_version_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PartitionSchemaReference. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PartitionSchemaReference.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PartitionSchemaReference.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 schema_id: Optional['outputs.PartitionSchemaId'] = None,
                 schema_version_id: Optional[str] = None,
                 schema_version_number: Optional[int] = None):
        PartitionSchemaReference._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            schema_id=schema_id,
            schema_version_id=schema_version_id,
            schema_version_number=schema_version_number,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             schema_id: Optional['outputs.PartitionSchemaId'] = None,
             schema_version_id: Optional[str] = None,
             schema_version_number: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if schema_id is not None:
            _setter("schema_id", schema_id)
        if schema_version_id is not None:
            _setter("schema_version_id", schema_version_id)
        if schema_version_number is not None:
            _setter("schema_version_number", schema_version_number)

    @property
    @pulumi.getter(name="schemaId")
    def schema_id(self) -> Optional['outputs.PartitionSchemaId']:
        return pulumi.get(self, "schema_id")

    @property
    @pulumi.getter(name="schemaVersionId")
    def schema_version_id(self) -> Optional[str]:
        return pulumi.get(self, "schema_version_id")

    @property
    @pulumi.getter(name="schemaVersionNumber")
    def schema_version_number(self) -> Optional[int]:
        return pulumi.get(self, "schema_version_number")


@pulumi.output_type
class PartitionSerdeInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serializationLibrary":
            suggest = "serialization_library"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PartitionSerdeInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PartitionSerdeInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PartitionSerdeInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 parameters: Optional[Any] = None,
                 serialization_library: Optional[str] = None):
        PartitionSerdeInfo._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameters=parameters,
            serialization_library=serialization_library,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             parameters: Optional[Any] = None,
             serialization_library: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)
        if parameters is not None:
            _setter("parameters", parameters)
        if serialization_library is not None:
            _setter("serialization_library", serialization_library)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Any]:
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="serializationLibrary")
    def serialization_library(self) -> Optional[str]:
        return pulumi.get(self, "serialization_library")


@pulumi.output_type
class PartitionSkewedInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "skewedColumnNames":
            suggest = "skewed_column_names"
        elif key == "skewedColumnValueLocationMaps":
            suggest = "skewed_column_value_location_maps"
        elif key == "skewedColumnValues":
            suggest = "skewed_column_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PartitionSkewedInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PartitionSkewedInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PartitionSkewedInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 skewed_column_names: Optional[Sequence[str]] = None,
                 skewed_column_value_location_maps: Optional[Any] = None,
                 skewed_column_values: Optional[Sequence[str]] = None):
        PartitionSkewedInfo._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            skewed_column_names=skewed_column_names,
            skewed_column_value_location_maps=skewed_column_value_location_maps,
            skewed_column_values=skewed_column_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             skewed_column_names: Optional[Sequence[str]] = None,
             skewed_column_value_location_maps: Optional[Any] = None,
             skewed_column_values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if skewed_column_names is not None:
            _setter("skewed_column_names", skewed_column_names)
        if skewed_column_value_location_maps is not None:
            _setter("skewed_column_value_location_maps", skewed_column_value_location_maps)
        if skewed_column_values is not None:
            _setter("skewed_column_values", skewed_column_values)

    @property
    @pulumi.getter(name="skewedColumnNames")
    def skewed_column_names(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "skewed_column_names")

    @property
    @pulumi.getter(name="skewedColumnValueLocationMaps")
    def skewed_column_value_location_maps(self) -> Optional[Any]:
        return pulumi.get(self, "skewed_column_value_location_maps")

    @property
    @pulumi.getter(name="skewedColumnValues")
    def skewed_column_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "skewed_column_values")


@pulumi.output_type
class PartitionStorageDescriptor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketColumns":
            suggest = "bucket_columns"
        elif key == "inputFormat":
            suggest = "input_format"
        elif key == "numberOfBuckets":
            suggest = "number_of_buckets"
        elif key == "outputFormat":
            suggest = "output_format"
        elif key == "schemaReference":
            suggest = "schema_reference"
        elif key == "serdeInfo":
            suggest = "serde_info"
        elif key == "skewedInfo":
            suggest = "skewed_info"
        elif key == "sortColumns":
            suggest = "sort_columns"
        elif key == "storedAsSubDirectories":
            suggest = "stored_as_sub_directories"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PartitionStorageDescriptor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PartitionStorageDescriptor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PartitionStorageDescriptor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_columns: Optional[Sequence[str]] = None,
                 columns: Optional[Sequence['outputs.PartitionColumn']] = None,
                 compressed: Optional[bool] = None,
                 input_format: Optional[str] = None,
                 location: Optional[str] = None,
                 number_of_buckets: Optional[int] = None,
                 output_format: Optional[str] = None,
                 parameters: Optional[Any] = None,
                 schema_reference: Optional['outputs.PartitionSchemaReference'] = None,
                 serde_info: Optional['outputs.PartitionSerdeInfo'] = None,
                 skewed_info: Optional['outputs.PartitionSkewedInfo'] = None,
                 sort_columns: Optional[Sequence['outputs.PartitionOrder']] = None,
                 stored_as_sub_directories: Optional[bool] = None):
        PartitionStorageDescriptor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket_columns=bucket_columns,
            columns=columns,
            compressed=compressed,
            input_format=input_format,
            location=location,
            number_of_buckets=number_of_buckets,
            output_format=output_format,
            parameters=parameters,
            schema_reference=schema_reference,
            serde_info=serde_info,
            skewed_info=skewed_info,
            sort_columns=sort_columns,
            stored_as_sub_directories=stored_as_sub_directories,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket_columns: Optional[Sequence[str]] = None,
             columns: Optional[Sequence['outputs.PartitionColumn']] = None,
             compressed: Optional[bool] = None,
             input_format: Optional[str] = None,
             location: Optional[str] = None,
             number_of_buckets: Optional[int] = None,
             output_format: Optional[str] = None,
             parameters: Optional[Any] = None,
             schema_reference: Optional['outputs.PartitionSchemaReference'] = None,
             serde_info: Optional['outputs.PartitionSerdeInfo'] = None,
             skewed_info: Optional['outputs.PartitionSkewedInfo'] = None,
             sort_columns: Optional[Sequence['outputs.PartitionOrder']] = None,
             stored_as_sub_directories: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bucket_columns is not None:
            _setter("bucket_columns", bucket_columns)
        if columns is not None:
            _setter("columns", columns)
        if compressed is not None:
            _setter("compressed", compressed)
        if input_format is not None:
            _setter("input_format", input_format)
        if location is not None:
            _setter("location", location)
        if number_of_buckets is not None:
            _setter("number_of_buckets", number_of_buckets)
        if output_format is not None:
            _setter("output_format", output_format)
        if parameters is not None:
            _setter("parameters", parameters)
        if schema_reference is not None:
            _setter("schema_reference", schema_reference)
        if serde_info is not None:
            _setter("serde_info", serde_info)
        if skewed_info is not None:
            _setter("skewed_info", skewed_info)
        if sort_columns is not None:
            _setter("sort_columns", sort_columns)
        if stored_as_sub_directories is not None:
            _setter("stored_as_sub_directories", stored_as_sub_directories)

    @property
    @pulumi.getter(name="bucketColumns")
    def bucket_columns(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "bucket_columns")

    @property
    @pulumi.getter
    def columns(self) -> Optional[Sequence['outputs.PartitionColumn']]:
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter
    def compressed(self) -> Optional[bool]:
        return pulumi.get(self, "compressed")

    @property
    @pulumi.getter(name="inputFormat")
    def input_format(self) -> Optional[str]:
        return pulumi.get(self, "input_format")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="numberOfBuckets")
    def number_of_buckets(self) -> Optional[int]:
        return pulumi.get(self, "number_of_buckets")

    @property
    @pulumi.getter(name="outputFormat")
    def output_format(self) -> Optional[str]:
        return pulumi.get(self, "output_format")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Any]:
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="schemaReference")
    def schema_reference(self) -> Optional['outputs.PartitionSchemaReference']:
        return pulumi.get(self, "schema_reference")

    @property
    @pulumi.getter(name="serdeInfo")
    def serde_info(self) -> Optional['outputs.PartitionSerdeInfo']:
        return pulumi.get(self, "serde_info")

    @property
    @pulumi.getter(name="skewedInfo")
    def skewed_info(self) -> Optional['outputs.PartitionSkewedInfo']:
        return pulumi.get(self, "skewed_info")

    @property
    @pulumi.getter(name="sortColumns")
    def sort_columns(self) -> Optional[Sequence['outputs.PartitionOrder']]:
        return pulumi.get(self, "sort_columns")

    @property
    @pulumi.getter(name="storedAsSubDirectories")
    def stored_as_sub_directories(self) -> Optional[bool]:
        return pulumi.get(self, "stored_as_sub_directories")


@pulumi.output_type
class RegistryTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: A key to identify the tag.
        :param str value: Corresponding tag value for the key.
        """
        RegistryTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        A key to identify the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Corresponding tag value for the key.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SchemaRegistry(dict):
    """
    Identifier for the registry which the schema is part of.
    """
    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 name: Optional[str] = None):
        """
        Identifier for the registry which the schema is part of.
        :param str arn: Amazon Resource Name for the Registry.
        :param str name: Name of the registry in which the schema will be created.
        """
        SchemaRegistry._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if arn is not None:
            _setter("arn", arn)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        """
        Amazon Resource Name for the Registry.
        """
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the registry in which the schema will be created.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SchemaTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: A key to identify the tag.
        :param str value: Corresponding tag value for the key.
        """
        SchemaTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        A key to identify the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Corresponding tag value for the key.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SchemaVersion(dict):
    """
    Specify checkpoint version for update. This is only required to update the Compatibility.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isLatest":
            suggest = "is_latest"
        elif key == "versionNumber":
            suggest = "version_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SchemaVersion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SchemaVersion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SchemaVersion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_latest: Optional[bool] = None,
                 version_number: Optional[int] = None):
        """
        Specify checkpoint version for update. This is only required to update the Compatibility.
        :param bool is_latest: Indicates if the latest version needs to be updated.
        :param int version_number: Indicates the version number in the schema to update.
        """
        SchemaVersion._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_latest=is_latest,
            version_number=version_number,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_latest: Optional[bool] = None,
             version_number: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_latest is not None:
            _setter("is_latest", is_latest)
        if version_number is not None:
            _setter("version_number", version_number)

    @property
    @pulumi.getter(name="isLatest")
    def is_latest(self) -> Optional[bool]:
        """
        Indicates if the latest version needs to be updated.
        """
        return pulumi.get(self, "is_latest")

    @property
    @pulumi.getter(name="versionNumber")
    def version_number(self) -> Optional[int]:
        """
        Indicates the version number in the schema to update.
        """
        return pulumi.get(self, "version_number")


@pulumi.output_type
class SchemaVersionSchema(dict):
    """
    Identifier for the schema where the schema version will be created.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "registryName":
            suggest = "registry_name"
        elif key == "schemaArn":
            suggest = "schema_arn"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SchemaVersionSchema. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SchemaVersionSchema.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SchemaVersionSchema.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 registry_name: Optional[str] = None,
                 schema_arn: Optional[str] = None,
                 schema_name: Optional[str] = None):
        """
        Identifier for the schema where the schema version will be created.
        :param str registry_name: Name of the registry to identify where the Schema is located.
        :param str schema_arn: Amazon Resource Name for the Schema. This attribute can be used to uniquely represent the Schema.
        :param str schema_name: Name of the schema. This parameter requires RegistryName to be provided.
        """
        SchemaVersionSchema._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            registry_name=registry_name,
            schema_arn=schema_arn,
            schema_name=schema_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             registry_name: Optional[str] = None,
             schema_arn: Optional[str] = None,
             schema_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if registry_name is not None:
            _setter("registry_name", registry_name)
        if schema_arn is not None:
            _setter("schema_arn", schema_arn)
        if schema_name is not None:
            _setter("schema_name", schema_name)

    @property
    @pulumi.getter(name="registryName")
    def registry_name(self) -> Optional[str]:
        """
        Name of the registry to identify where the Schema is located.
        """
        return pulumi.get(self, "registry_name")

    @property
    @pulumi.getter(name="schemaArn")
    def schema_arn(self) -> Optional[str]:
        """
        Amazon Resource Name for the Schema. This attribute can be used to uniquely represent the Schema.
        """
        return pulumi.get(self, "schema_arn")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        """
        Name of the schema. This parameter requires RegistryName to be provided.
        """
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class SecurityConfigurationCloudWatchEncryption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudWatchEncryptionMode":
            suggest = "cloud_watch_encryption_mode"
        elif key == "kmsKeyArn":
            suggest = "kms_key_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityConfigurationCloudWatchEncryption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityConfigurationCloudWatchEncryption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityConfigurationCloudWatchEncryption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_watch_encryption_mode: Optional[str] = None,
                 kms_key_arn: Optional[str] = None):
        SecurityConfigurationCloudWatchEncryption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_watch_encryption_mode=cloud_watch_encryption_mode,
            kms_key_arn=kms_key_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_watch_encryption_mode: Optional[str] = None,
             kms_key_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cloud_watch_encryption_mode is not None:
            _setter("cloud_watch_encryption_mode", cloud_watch_encryption_mode)
        if kms_key_arn is not None:
            _setter("kms_key_arn", kms_key_arn)

    @property
    @pulumi.getter(name="cloudWatchEncryptionMode")
    def cloud_watch_encryption_mode(self) -> Optional[str]:
        return pulumi.get(self, "cloud_watch_encryption_mode")

    @property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[str]:
        return pulumi.get(self, "kms_key_arn")


@pulumi.output_type
class SecurityConfigurationEncryptionConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudWatchEncryption":
            suggest = "cloud_watch_encryption"
        elif key == "jobBookmarksEncryption":
            suggest = "job_bookmarks_encryption"
        elif key == "s3Encryptions":
            suggest = "s3_encryptions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityConfigurationEncryptionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityConfigurationEncryptionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityConfigurationEncryptionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_watch_encryption: Optional['outputs.SecurityConfigurationCloudWatchEncryption'] = None,
                 job_bookmarks_encryption: Optional['outputs.SecurityConfigurationJobBookmarksEncryption'] = None,
                 s3_encryptions: Optional['outputs.SecurityConfigurationS3Encryptions'] = None):
        SecurityConfigurationEncryptionConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_watch_encryption=cloud_watch_encryption,
            job_bookmarks_encryption=job_bookmarks_encryption,
            s3_encryptions=s3_encryptions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_watch_encryption: Optional['outputs.SecurityConfigurationCloudWatchEncryption'] = None,
             job_bookmarks_encryption: Optional['outputs.SecurityConfigurationJobBookmarksEncryption'] = None,
             s3_encryptions: Optional['outputs.SecurityConfigurationS3Encryptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cloud_watch_encryption is not None:
            _setter("cloud_watch_encryption", cloud_watch_encryption)
        if job_bookmarks_encryption is not None:
            _setter("job_bookmarks_encryption", job_bookmarks_encryption)
        if s3_encryptions is not None:
            _setter("s3_encryptions", s3_encryptions)

    @property
    @pulumi.getter(name="cloudWatchEncryption")
    def cloud_watch_encryption(self) -> Optional['outputs.SecurityConfigurationCloudWatchEncryption']:
        return pulumi.get(self, "cloud_watch_encryption")

    @property
    @pulumi.getter(name="jobBookmarksEncryption")
    def job_bookmarks_encryption(self) -> Optional['outputs.SecurityConfigurationJobBookmarksEncryption']:
        return pulumi.get(self, "job_bookmarks_encryption")

    @property
    @pulumi.getter(name="s3Encryptions")
    def s3_encryptions(self) -> Optional['outputs.SecurityConfigurationS3Encryptions']:
        return pulumi.get(self, "s3_encryptions")


@pulumi.output_type
class SecurityConfigurationJobBookmarksEncryption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jobBookmarksEncryptionMode":
            suggest = "job_bookmarks_encryption_mode"
        elif key == "kmsKeyArn":
            suggest = "kms_key_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityConfigurationJobBookmarksEncryption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityConfigurationJobBookmarksEncryption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityConfigurationJobBookmarksEncryption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 job_bookmarks_encryption_mode: Optional[str] = None,
                 kms_key_arn: Optional[str] = None):
        SecurityConfigurationJobBookmarksEncryption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            job_bookmarks_encryption_mode=job_bookmarks_encryption_mode,
            kms_key_arn=kms_key_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             job_bookmarks_encryption_mode: Optional[str] = None,
             kms_key_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if job_bookmarks_encryption_mode is not None:
            _setter("job_bookmarks_encryption_mode", job_bookmarks_encryption_mode)
        if kms_key_arn is not None:
            _setter("kms_key_arn", kms_key_arn)

    @property
    @pulumi.getter(name="jobBookmarksEncryptionMode")
    def job_bookmarks_encryption_mode(self) -> Optional[str]:
        return pulumi.get(self, "job_bookmarks_encryption_mode")

    @property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[str]:
        return pulumi.get(self, "kms_key_arn")


@pulumi.output_type
class SecurityConfigurationS3Encryptions(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions]=None):
        pass


@pulumi.output_type
class TableColumn(dict):
    def __init__(__self__, *,
                 name: str,
                 comment: Optional[str] = None,
                 type: Optional[str] = None):
        TableColumn._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            comment=comment,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             comment: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        if comment is not None:
            _setter("comment", comment)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def comment(self) -> Optional[str]:
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class TableIcebergInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metadataOperation":
            suggest = "metadata_operation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TableIcebergInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TableIcebergInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TableIcebergInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metadata_operation: Optional['outputs.TableMetadataOperation'] = None,
                 version: Optional[str] = None):
        TableIcebergInput._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metadata_operation=metadata_operation,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metadata_operation: Optional['outputs.TableMetadataOperation'] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if metadata_operation is not None:
            _setter("metadata_operation", metadata_operation)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter(name="metadataOperation")
    def metadata_operation(self) -> Optional['outputs.TableMetadataOperation']:
        return pulumi.get(self, "metadata_operation")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class TableIdentifier(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "catalogId":
            suggest = "catalog_id"
        elif key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TableIdentifier. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TableIdentifier.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TableIdentifier.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 catalog_id: Optional[str] = None,
                 database_name: Optional[str] = None,
                 name: Optional[str] = None,
                 region: Optional[str] = None):
        TableIdentifier._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            catalog_id=catalog_id,
            database_name=database_name,
            name=name,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             catalog_id: Optional[str] = None,
             database_name: Optional[str] = None,
             name: Optional[str] = None,
             region: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if catalog_id is not None:
            _setter("catalog_id", catalog_id)
        if database_name is not None:
            _setter("database_name", database_name)
        if name is not None:
            _setter("name", name)
        if region is not None:
            _setter("region", region)

    @property
    @pulumi.getter(name="catalogId")
    def catalog_id(self) -> Optional[str]:
        return pulumi.get(self, "catalog_id")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class TableInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "partitionKeys":
            suggest = "partition_keys"
        elif key == "storageDescriptor":
            suggest = "storage_descriptor"
        elif key == "tableType":
            suggest = "table_type"
        elif key == "targetTable":
            suggest = "target_table"
        elif key == "viewExpandedText":
            suggest = "view_expanded_text"
        elif key == "viewOriginalText":
            suggest = "view_original_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TableInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TableInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TableInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 name: Optional[str] = None,
                 owner: Optional[str] = None,
                 parameters: Optional[Any] = None,
                 partition_keys: Optional[Sequence['outputs.TableColumn']] = None,
                 retention: Optional[int] = None,
                 storage_descriptor: Optional['outputs.TableStorageDescriptor'] = None,
                 table_type: Optional[str] = None,
                 target_table: Optional['outputs.TableIdentifier'] = None,
                 view_expanded_text: Optional[str] = None,
                 view_original_text: Optional[str] = None):
        TableInput._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            name=name,
            owner=owner,
            parameters=parameters,
            partition_keys=partition_keys,
            retention=retention,
            storage_descriptor=storage_descriptor,
            table_type=table_type,
            target_table=target_table,
            view_expanded_text=view_expanded_text,
            view_original_text=view_original_text,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[str] = None,
             name: Optional[str] = None,
             owner: Optional[str] = None,
             parameters: Optional[Any] = None,
             partition_keys: Optional[Sequence['outputs.TableColumn']] = None,
             retention: Optional[int] = None,
             storage_descriptor: Optional['outputs.TableStorageDescriptor'] = None,
             table_type: Optional[str] = None,
             target_table: Optional['outputs.TableIdentifier'] = None,
             view_expanded_text: Optional[str] = None,
             view_original_text: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if description is not None:
            _setter("description", description)
        if name is not None:
            _setter("name", name)
        if owner is not None:
            _setter("owner", owner)
        if parameters is not None:
            _setter("parameters", parameters)
        if partition_keys is not None:
            _setter("partition_keys", partition_keys)
        if retention is not None:
            _setter("retention", retention)
        if storage_descriptor is not None:
            _setter("storage_descriptor", storage_descriptor)
        if table_type is not None:
            _setter("table_type", table_type)
        if target_table is not None:
            _setter("target_table", target_table)
        if view_expanded_text is not None:
            _setter("view_expanded_text", view_expanded_text)
        if view_original_text is not None:
            _setter("view_original_text", view_original_text)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def owner(self) -> Optional[str]:
        return pulumi.get(self, "owner")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Any]:
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="partitionKeys")
    def partition_keys(self) -> Optional[Sequence['outputs.TableColumn']]:
        return pulumi.get(self, "partition_keys")

    @property
    @pulumi.getter
    def retention(self) -> Optional[int]:
        return pulumi.get(self, "retention")

    @property
    @pulumi.getter(name="storageDescriptor")
    def storage_descriptor(self) -> Optional['outputs.TableStorageDescriptor']:
        return pulumi.get(self, "storage_descriptor")

    @property
    @pulumi.getter(name="tableType")
    def table_type(self) -> Optional[str]:
        return pulumi.get(self, "table_type")

    @property
    @pulumi.getter(name="targetTable")
    def target_table(self) -> Optional['outputs.TableIdentifier']:
        return pulumi.get(self, "target_table")

    @property
    @pulumi.getter(name="viewExpandedText")
    def view_expanded_text(self) -> Optional[str]:
        return pulumi.get(self, "view_expanded_text")

    @property
    @pulumi.getter(name="viewOriginalText")
    def view_original_text(self) -> Optional[str]:
        return pulumi.get(self, "view_original_text")


@pulumi.output_type
class TableMetadataOperation(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions]=None):
        pass


@pulumi.output_type
class TableOpenTableFormatInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "icebergInput":
            suggest = "iceberg_input"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TableOpenTableFormatInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TableOpenTableFormatInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TableOpenTableFormatInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iceberg_input: Optional['outputs.TableIcebergInput'] = None):
        TableOpenTableFormatInput._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            iceberg_input=iceberg_input,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             iceberg_input: Optional['outputs.TableIcebergInput'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if iceberg_input is not None:
            _setter("iceberg_input", iceberg_input)

    @property
    @pulumi.getter(name="icebergInput")
    def iceberg_input(self) -> Optional['outputs.TableIcebergInput']:
        return pulumi.get(self, "iceberg_input")


@pulumi.output_type
class TableOrder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortOrder":
            suggest = "sort_order"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TableOrder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TableOrder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TableOrder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: str,
                 sort_order: int):
        TableOrder._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            sort_order=sort_order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: str,
             sort_order: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("sort_order", sort_order)

    @property
    @pulumi.getter
    def column(self) -> str:
        return pulumi.get(self, "column")

    @property
    @pulumi.getter(name="sortOrder")
    def sort_order(self) -> int:
        return pulumi.get(self, "sort_order")


@pulumi.output_type
class TableSchemaId(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "registryName":
            suggest = "registry_name"
        elif key == "schemaArn":
            suggest = "schema_arn"
        elif key == "schemaName":
            suggest = "schema_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TableSchemaId. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TableSchemaId.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TableSchemaId.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 registry_name: Optional[str] = None,
                 schema_arn: Optional[str] = None,
                 schema_name: Optional[str] = None):
        TableSchemaId._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            registry_name=registry_name,
            schema_arn=schema_arn,
            schema_name=schema_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             registry_name: Optional[str] = None,
             schema_arn: Optional[str] = None,
             schema_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if registry_name is not None:
            _setter("registry_name", registry_name)
        if schema_arn is not None:
            _setter("schema_arn", schema_arn)
        if schema_name is not None:
            _setter("schema_name", schema_name)

    @property
    @pulumi.getter(name="registryName")
    def registry_name(self) -> Optional[str]:
        return pulumi.get(self, "registry_name")

    @property
    @pulumi.getter(name="schemaArn")
    def schema_arn(self) -> Optional[str]:
        return pulumi.get(self, "schema_arn")

    @property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[str]:
        return pulumi.get(self, "schema_name")


@pulumi.output_type
class TableSchemaReference(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "schemaId":
            suggest = "schema_id"
        elif key == "schemaVersionId":
            suggest = "schema_version_id"
        elif key == "schemaVersionNumber":
            suggest = "schema_version_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TableSchemaReference. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TableSchemaReference.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TableSchemaReference.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 schema_id: Optional['outputs.TableSchemaId'] = None,
                 schema_version_id: Optional[str] = None,
                 schema_version_number: Optional[int] = None):
        TableSchemaReference._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            schema_id=schema_id,
            schema_version_id=schema_version_id,
            schema_version_number=schema_version_number,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             schema_id: Optional['outputs.TableSchemaId'] = None,
             schema_version_id: Optional[str] = None,
             schema_version_number: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if schema_id is not None:
            _setter("schema_id", schema_id)
        if schema_version_id is not None:
            _setter("schema_version_id", schema_version_id)
        if schema_version_number is not None:
            _setter("schema_version_number", schema_version_number)

    @property
    @pulumi.getter(name="schemaId")
    def schema_id(self) -> Optional['outputs.TableSchemaId']:
        return pulumi.get(self, "schema_id")

    @property
    @pulumi.getter(name="schemaVersionId")
    def schema_version_id(self) -> Optional[str]:
        return pulumi.get(self, "schema_version_id")

    @property
    @pulumi.getter(name="schemaVersionNumber")
    def schema_version_number(self) -> Optional[int]:
        return pulumi.get(self, "schema_version_number")


@pulumi.output_type
class TableSerdeInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serializationLibrary":
            suggest = "serialization_library"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TableSerdeInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TableSerdeInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TableSerdeInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 parameters: Optional[Any] = None,
                 serialization_library: Optional[str] = None):
        TableSerdeInfo._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameters=parameters,
            serialization_library=serialization_library,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             parameters: Optional[Any] = None,
             serialization_library: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)
        if parameters is not None:
            _setter("parameters", parameters)
        if serialization_library is not None:
            _setter("serialization_library", serialization_library)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Any]:
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="serializationLibrary")
    def serialization_library(self) -> Optional[str]:
        return pulumi.get(self, "serialization_library")


@pulumi.output_type
class TableSkewedInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "skewedColumnNames":
            suggest = "skewed_column_names"
        elif key == "skewedColumnValueLocationMaps":
            suggest = "skewed_column_value_location_maps"
        elif key == "skewedColumnValues":
            suggest = "skewed_column_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TableSkewedInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TableSkewedInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TableSkewedInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 skewed_column_names: Optional[Sequence[str]] = None,
                 skewed_column_value_location_maps: Optional[Any] = None,
                 skewed_column_values: Optional[Sequence[str]] = None):
        TableSkewedInfo._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            skewed_column_names=skewed_column_names,
            skewed_column_value_location_maps=skewed_column_value_location_maps,
            skewed_column_values=skewed_column_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             skewed_column_names: Optional[Sequence[str]] = None,
             skewed_column_value_location_maps: Optional[Any] = None,
             skewed_column_values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if skewed_column_names is not None:
            _setter("skewed_column_names", skewed_column_names)
        if skewed_column_value_location_maps is not None:
            _setter("skewed_column_value_location_maps", skewed_column_value_location_maps)
        if skewed_column_values is not None:
            _setter("skewed_column_values", skewed_column_values)

    @property
    @pulumi.getter(name="skewedColumnNames")
    def skewed_column_names(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "skewed_column_names")

    @property
    @pulumi.getter(name="skewedColumnValueLocationMaps")
    def skewed_column_value_location_maps(self) -> Optional[Any]:
        return pulumi.get(self, "skewed_column_value_location_maps")

    @property
    @pulumi.getter(name="skewedColumnValues")
    def skewed_column_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "skewed_column_values")


@pulumi.output_type
class TableStorageDescriptor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketColumns":
            suggest = "bucket_columns"
        elif key == "inputFormat":
            suggest = "input_format"
        elif key == "numberOfBuckets":
            suggest = "number_of_buckets"
        elif key == "outputFormat":
            suggest = "output_format"
        elif key == "schemaReference":
            suggest = "schema_reference"
        elif key == "serdeInfo":
            suggest = "serde_info"
        elif key == "skewedInfo":
            suggest = "skewed_info"
        elif key == "sortColumns":
            suggest = "sort_columns"
        elif key == "storedAsSubDirectories":
            suggest = "stored_as_sub_directories"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TableStorageDescriptor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TableStorageDescriptor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TableStorageDescriptor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_columns: Optional[Sequence[str]] = None,
                 columns: Optional[Sequence['outputs.TableColumn']] = None,
                 compressed: Optional[bool] = None,
                 input_format: Optional[str] = None,
                 location: Optional[str] = None,
                 number_of_buckets: Optional[int] = None,
                 output_format: Optional[str] = None,
                 parameters: Optional[Any] = None,
                 schema_reference: Optional['outputs.TableSchemaReference'] = None,
                 serde_info: Optional['outputs.TableSerdeInfo'] = None,
                 skewed_info: Optional['outputs.TableSkewedInfo'] = None,
                 sort_columns: Optional[Sequence['outputs.TableOrder']] = None,
                 stored_as_sub_directories: Optional[bool] = None):
        TableStorageDescriptor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket_columns=bucket_columns,
            columns=columns,
            compressed=compressed,
            input_format=input_format,
            location=location,
            number_of_buckets=number_of_buckets,
            output_format=output_format,
            parameters=parameters,
            schema_reference=schema_reference,
            serde_info=serde_info,
            skewed_info=skewed_info,
            sort_columns=sort_columns,
            stored_as_sub_directories=stored_as_sub_directories,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket_columns: Optional[Sequence[str]] = None,
             columns: Optional[Sequence['outputs.TableColumn']] = None,
             compressed: Optional[bool] = None,
             input_format: Optional[str] = None,
             location: Optional[str] = None,
             number_of_buckets: Optional[int] = None,
             output_format: Optional[str] = None,
             parameters: Optional[Any] = None,
             schema_reference: Optional['outputs.TableSchemaReference'] = None,
             serde_info: Optional['outputs.TableSerdeInfo'] = None,
             skewed_info: Optional['outputs.TableSkewedInfo'] = None,
             sort_columns: Optional[Sequence['outputs.TableOrder']] = None,
             stored_as_sub_directories: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if bucket_columns is not None:
            _setter("bucket_columns", bucket_columns)
        if columns is not None:
            _setter("columns", columns)
        if compressed is not None:
            _setter("compressed", compressed)
        if input_format is not None:
            _setter("input_format", input_format)
        if location is not None:
            _setter("location", location)
        if number_of_buckets is not None:
            _setter("number_of_buckets", number_of_buckets)
        if output_format is not None:
            _setter("output_format", output_format)
        if parameters is not None:
            _setter("parameters", parameters)
        if schema_reference is not None:
            _setter("schema_reference", schema_reference)
        if serde_info is not None:
            _setter("serde_info", serde_info)
        if skewed_info is not None:
            _setter("skewed_info", skewed_info)
        if sort_columns is not None:
            _setter("sort_columns", sort_columns)
        if stored_as_sub_directories is not None:
            _setter("stored_as_sub_directories", stored_as_sub_directories)

    @property
    @pulumi.getter(name="bucketColumns")
    def bucket_columns(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "bucket_columns")

    @property
    @pulumi.getter
    def columns(self) -> Optional[Sequence['outputs.TableColumn']]:
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter
    def compressed(self) -> Optional[bool]:
        return pulumi.get(self, "compressed")

    @property
    @pulumi.getter(name="inputFormat")
    def input_format(self) -> Optional[str]:
        return pulumi.get(self, "input_format")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="numberOfBuckets")
    def number_of_buckets(self) -> Optional[int]:
        return pulumi.get(self, "number_of_buckets")

    @property
    @pulumi.getter(name="outputFormat")
    def output_format(self) -> Optional[str]:
        return pulumi.get(self, "output_format")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Any]:
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="schemaReference")
    def schema_reference(self) -> Optional['outputs.TableSchemaReference']:
        return pulumi.get(self, "schema_reference")

    @property
    @pulumi.getter(name="serdeInfo")
    def serde_info(self) -> Optional['outputs.TableSerdeInfo']:
        return pulumi.get(self, "serde_info")

    @property
    @pulumi.getter(name="skewedInfo")
    def skewed_info(self) -> Optional['outputs.TableSkewedInfo']:
        return pulumi.get(self, "skewed_info")

    @property
    @pulumi.getter(name="sortColumns")
    def sort_columns(self) -> Optional[Sequence['outputs.TableOrder']]:
        return pulumi.get(self, "sort_columns")

    @property
    @pulumi.getter(name="storedAsSubDirectories")
    def stored_as_sub_directories(self) -> Optional[bool]:
        return pulumi.get(self, "stored_as_sub_directories")


@pulumi.output_type
class TriggerAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crawlerName":
            suggest = "crawler_name"
        elif key == "jobName":
            suggest = "job_name"
        elif key == "notificationProperty":
            suggest = "notification_property"
        elif key == "securityConfiguration":
            suggest = "security_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TriggerAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TriggerAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TriggerAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arguments: Optional[Any] = None,
                 crawler_name: Optional[str] = None,
                 job_name: Optional[str] = None,
                 notification_property: Optional['outputs.TriggerNotificationProperty'] = None,
                 security_configuration: Optional[str] = None,
                 timeout: Optional[int] = None):
        TriggerAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arguments=arguments,
            crawler_name=crawler_name,
            job_name=job_name,
            notification_property=notification_property,
            security_configuration=security_configuration,
            timeout=timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arguments: Optional[Any] = None,
             crawler_name: Optional[str] = None,
             job_name: Optional[str] = None,
             notification_property: Optional['outputs.TriggerNotificationProperty'] = None,
             security_configuration: Optional[str] = None,
             timeout: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if arguments is not None:
            _setter("arguments", arguments)
        if crawler_name is not None:
            _setter("crawler_name", crawler_name)
        if job_name is not None:
            _setter("job_name", job_name)
        if notification_property is not None:
            _setter("notification_property", notification_property)
        if security_configuration is not None:
            _setter("security_configuration", security_configuration)
        if timeout is not None:
            _setter("timeout", timeout)

    @property
    @pulumi.getter
    def arguments(self) -> Optional[Any]:
        return pulumi.get(self, "arguments")

    @property
    @pulumi.getter(name="crawlerName")
    def crawler_name(self) -> Optional[str]:
        return pulumi.get(self, "crawler_name")

    @property
    @pulumi.getter(name="jobName")
    def job_name(self) -> Optional[str]:
        return pulumi.get(self, "job_name")

    @property
    @pulumi.getter(name="notificationProperty")
    def notification_property(self) -> Optional['outputs.TriggerNotificationProperty']:
        return pulumi.get(self, "notification_property")

    @property
    @pulumi.getter(name="securityConfiguration")
    def security_configuration(self) -> Optional[str]:
        return pulumi.get(self, "security_configuration")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        return pulumi.get(self, "timeout")


@pulumi.output_type
class TriggerCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crawlState":
            suggest = "crawl_state"
        elif key == "crawlerName":
            suggest = "crawler_name"
        elif key == "jobName":
            suggest = "job_name"
        elif key == "logicalOperator":
            suggest = "logical_operator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TriggerCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TriggerCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TriggerCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 crawl_state: Optional[str] = None,
                 crawler_name: Optional[str] = None,
                 job_name: Optional[str] = None,
                 logical_operator: Optional[str] = None,
                 state: Optional[str] = None):
        TriggerCondition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            crawl_state=crawl_state,
            crawler_name=crawler_name,
            job_name=job_name,
            logical_operator=logical_operator,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             crawl_state: Optional[str] = None,
             crawler_name: Optional[str] = None,
             job_name: Optional[str] = None,
             logical_operator: Optional[str] = None,
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if crawl_state is not None:
            _setter("crawl_state", crawl_state)
        if crawler_name is not None:
            _setter("crawler_name", crawler_name)
        if job_name is not None:
            _setter("job_name", job_name)
        if logical_operator is not None:
            _setter("logical_operator", logical_operator)
        if state is not None:
            _setter("state", state)

    @property
    @pulumi.getter(name="crawlState")
    def crawl_state(self) -> Optional[str]:
        return pulumi.get(self, "crawl_state")

    @property
    @pulumi.getter(name="crawlerName")
    def crawler_name(self) -> Optional[str]:
        return pulumi.get(self, "crawler_name")

    @property
    @pulumi.getter(name="jobName")
    def job_name(self) -> Optional[str]:
        return pulumi.get(self, "job_name")

    @property
    @pulumi.getter(name="logicalOperator")
    def logical_operator(self) -> Optional[str]:
        return pulumi.get(self, "logical_operator")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        return pulumi.get(self, "state")


@pulumi.output_type
class TriggerEventBatchingCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "batchSize":
            suggest = "batch_size"
        elif key == "batchWindow":
            suggest = "batch_window"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TriggerEventBatchingCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TriggerEventBatchingCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TriggerEventBatchingCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 batch_size: int,
                 batch_window: Optional[int] = None):
        TriggerEventBatchingCondition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            batch_size=batch_size,
            batch_window=batch_window,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             batch_size: int,
             batch_window: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("batch_size", batch_size)
        if batch_window is not None:
            _setter("batch_window", batch_window)

    @property
    @pulumi.getter(name="batchSize")
    def batch_size(self) -> int:
        return pulumi.get(self, "batch_size")

    @property
    @pulumi.getter(name="batchWindow")
    def batch_window(self) -> Optional[int]:
        return pulumi.get(self, "batch_window")


@pulumi.output_type
class TriggerNotificationProperty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notifyDelayAfter":
            suggest = "notify_delay_after"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TriggerNotificationProperty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TriggerNotificationProperty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TriggerNotificationProperty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 notify_delay_after: Optional[int] = None):
        TriggerNotificationProperty._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            notify_delay_after=notify_delay_after,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             notify_delay_after: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if notify_delay_after is not None:
            _setter("notify_delay_after", notify_delay_after)

    @property
    @pulumi.getter(name="notifyDelayAfter")
    def notify_delay_after(self) -> Optional[int]:
        return pulumi.get(self, "notify_delay_after")


@pulumi.output_type
class TriggerPredicate(dict):
    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.TriggerCondition']] = None,
                 logical: Optional[str] = None):
        TriggerPredicate._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            conditions=conditions,
            logical=logical,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             conditions: Optional[Sequence['outputs.TriggerCondition']] = None,
             logical: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if conditions is not None:
            _setter("conditions", conditions)
        if logical is not None:
            _setter("logical", logical)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.TriggerCondition']]:
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def logical(self) -> Optional[str]:
        return pulumi.get(self, "logical")


