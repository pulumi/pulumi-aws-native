# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'ClusterApplication',
    'ClusterAutoScalingPolicy',
    'ClusterAutoTerminationPolicy',
    'ClusterBootstrapActionConfig',
    'ClusterCloudWatchAlarmDefinition',
    'ClusterComputeLimits',
    'ClusterConfiguration',
    'ClusterEbsBlockDeviceConfig',
    'ClusterEbsConfiguration',
    'ClusterHadoopJarStepConfig',
    'ClusterInstanceFleetConfig',
    'ClusterInstanceFleetProvisioningSpecifications',
    'ClusterInstanceGroupConfig',
    'ClusterInstanceTypeConfig',
    'ClusterJobFlowInstancesConfig',
    'ClusterKerberosAttributes',
    'ClusterKeyValue',
    'ClusterManagedScalingPolicy',
    'ClusterMetricDimension',
    'ClusterOnDemandProvisioningSpecification',
    'ClusterPlacementType',
    'ClusterScalingAction',
    'ClusterScalingConstraints',
    'ClusterScalingRule',
    'ClusterScalingTrigger',
    'ClusterScriptBootstrapActionConfig',
    'ClusterSimpleScalingPolicyConfiguration',
    'ClusterSpotProvisioningSpecification',
    'ClusterStepConfig',
    'ClusterTag',
    'ClusterVolumeSpecification',
    'InstanceFleetConfigConfiguration',
    'InstanceFleetConfigEbsBlockDeviceConfig',
    'InstanceFleetConfigEbsConfiguration',
    'InstanceFleetConfigInstanceFleetProvisioningSpecifications',
    'InstanceFleetConfigInstanceTypeConfig',
    'InstanceFleetConfigOnDemandProvisioningSpecification',
    'InstanceFleetConfigSpotProvisioningSpecification',
    'InstanceFleetConfigVolumeSpecification',
    'InstanceGroupConfigAutoScalingPolicy',
    'InstanceGroupConfigCloudWatchAlarmDefinition',
    'InstanceGroupConfigConfiguration',
    'InstanceGroupConfigEbsBlockDeviceConfig',
    'InstanceGroupConfigEbsConfiguration',
    'InstanceGroupConfigMetricDimension',
    'InstanceGroupConfigScalingAction',
    'InstanceGroupConfigScalingConstraints',
    'InstanceGroupConfigScalingRule',
    'InstanceGroupConfigScalingTrigger',
    'InstanceGroupConfigSimpleScalingPolicyConfiguration',
    'InstanceGroupConfigVolumeSpecification',
    'StepHadoopJarStepConfig',
    'StepKeyValue',
    'StudioTag',
    'WalWorkspaceTag',
]

@pulumi.output_type
class ClusterApplication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalInfo":
            suggest = "additional_info"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterApplication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterApplication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterApplication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_info: Optional[Any] = None,
                 args: Optional[Sequence[str]] = None,
                 name: Optional[str] = None,
                 version: Optional[str] = None):
        ClusterApplication._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            additional_info=additional_info,
            args=args,
            name=name,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             additional_info: Optional[Any] = None,
             args: Optional[Sequence[str]] = None,
             name: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if additional_info is not None:
            _setter("additional_info", additional_info)
        if args is not None:
            _setter("args", args)
        if name is not None:
            _setter("name", name)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter(name="additionalInfo")
    def additional_info(self) -> Optional[Any]:
        return pulumi.get(self, "additional_info")

    @property
    @pulumi.getter
    def args(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "args")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class ClusterAutoScalingPolicy(dict):
    def __init__(__self__, *,
                 constraints: 'outputs.ClusterScalingConstraints',
                 rules: Sequence['outputs.ClusterScalingRule']):
        ClusterAutoScalingPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            constraints=constraints,
            rules=rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             constraints: 'outputs.ClusterScalingConstraints',
             rules: Sequence['outputs.ClusterScalingRule'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("constraints", constraints)
        _setter("rules", rules)

    @property
    @pulumi.getter
    def constraints(self) -> 'outputs.ClusterScalingConstraints':
        return pulumi.get(self, "constraints")

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.ClusterScalingRule']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class ClusterAutoTerminationPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "idleTimeout":
            suggest = "idle_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterAutoTerminationPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterAutoTerminationPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterAutoTerminationPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 idle_timeout: Optional[int] = None):
        ClusterAutoTerminationPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            idle_timeout=idle_timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             idle_timeout: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if idle_timeout is not None:
            _setter("idle_timeout", idle_timeout)

    @property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> Optional[int]:
        return pulumi.get(self, "idle_timeout")


@pulumi.output_type
class ClusterBootstrapActionConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scriptBootstrapAction":
            suggest = "script_bootstrap_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterBootstrapActionConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterBootstrapActionConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterBootstrapActionConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 script_bootstrap_action: 'outputs.ClusterScriptBootstrapActionConfig'):
        ClusterBootstrapActionConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            script_bootstrap_action=script_bootstrap_action,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             script_bootstrap_action: 'outputs.ClusterScriptBootstrapActionConfig',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("script_bootstrap_action", script_bootstrap_action)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="scriptBootstrapAction")
    def script_bootstrap_action(self) -> 'outputs.ClusterScriptBootstrapActionConfig':
        return pulumi.get(self, "script_bootstrap_action")


@pulumi.output_type
class ClusterCloudWatchAlarmDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"
        elif key == "metricName":
            suggest = "metric_name"
        elif key == "evaluationPeriods":
            suggest = "evaluation_periods"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterCloudWatchAlarmDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterCloudWatchAlarmDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterCloudWatchAlarmDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: str,
                 metric_name: str,
                 period: int,
                 threshold: float,
                 dimensions: Optional[Sequence['outputs.ClusterMetricDimension']] = None,
                 evaluation_periods: Optional[int] = None,
                 namespace: Optional[str] = None,
                 statistic: Optional[str] = None,
                 unit: Optional[str] = None):
        ClusterCloudWatchAlarmDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparison_operator=comparison_operator,
            metric_name=metric_name,
            period=period,
            threshold=threshold,
            dimensions=dimensions,
            evaluation_periods=evaluation_periods,
            namespace=namespace,
            statistic=statistic,
            unit=unit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparison_operator: str,
             metric_name: str,
             period: int,
             threshold: float,
             dimensions: Optional[Sequence['outputs.ClusterMetricDimension']] = None,
             evaluation_periods: Optional[int] = None,
             namespace: Optional[str] = None,
             statistic: Optional[str] = None,
             unit: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("comparison_operator", comparison_operator)
        _setter("metric_name", metric_name)
        _setter("period", period)
        _setter("threshold", threshold)
        if dimensions is not None:
            _setter("dimensions", dimensions)
        if evaluation_periods is not None:
            _setter("evaluation_periods", evaluation_periods)
        if namespace is not None:
            _setter("namespace", namespace)
        if statistic is not None:
            _setter("statistic", statistic)
        if unit is not None:
            _setter("unit", unit)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> str:
        return pulumi.get(self, "comparison_operator")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def period(self) -> int:
        return pulumi.get(self, "period")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.ClusterMetricDimension']]:
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[int]:
        return pulumi.get(self, "evaluation_periods")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def statistic(self) -> Optional[str]:
        return pulumi.get(self, "statistic")

    @property
    @pulumi.getter
    def unit(self) -> Optional[str]:
        return pulumi.get(self, "unit")


@pulumi.output_type
class ClusterComputeLimits(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maximumCapacityUnits":
            suggest = "maximum_capacity_units"
        elif key == "minimumCapacityUnits":
            suggest = "minimum_capacity_units"
        elif key == "unitType":
            suggest = "unit_type"
        elif key == "maximumCoreCapacityUnits":
            suggest = "maximum_core_capacity_units"
        elif key == "maximumOnDemandCapacityUnits":
            suggest = "maximum_on_demand_capacity_units"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterComputeLimits. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterComputeLimits.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterComputeLimits.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 maximum_capacity_units: int,
                 minimum_capacity_units: int,
                 unit_type: str,
                 maximum_core_capacity_units: Optional[int] = None,
                 maximum_on_demand_capacity_units: Optional[int] = None):
        ClusterComputeLimits._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            maximum_capacity_units=maximum_capacity_units,
            minimum_capacity_units=minimum_capacity_units,
            unit_type=unit_type,
            maximum_core_capacity_units=maximum_core_capacity_units,
            maximum_on_demand_capacity_units=maximum_on_demand_capacity_units,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             maximum_capacity_units: int,
             minimum_capacity_units: int,
             unit_type: str,
             maximum_core_capacity_units: Optional[int] = None,
             maximum_on_demand_capacity_units: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("maximum_capacity_units", maximum_capacity_units)
        _setter("minimum_capacity_units", minimum_capacity_units)
        _setter("unit_type", unit_type)
        if maximum_core_capacity_units is not None:
            _setter("maximum_core_capacity_units", maximum_core_capacity_units)
        if maximum_on_demand_capacity_units is not None:
            _setter("maximum_on_demand_capacity_units", maximum_on_demand_capacity_units)

    @property
    @pulumi.getter(name="maximumCapacityUnits")
    def maximum_capacity_units(self) -> int:
        return pulumi.get(self, "maximum_capacity_units")

    @property
    @pulumi.getter(name="minimumCapacityUnits")
    def minimum_capacity_units(self) -> int:
        return pulumi.get(self, "minimum_capacity_units")

    @property
    @pulumi.getter(name="unitType")
    def unit_type(self) -> str:
        return pulumi.get(self, "unit_type")

    @property
    @pulumi.getter(name="maximumCoreCapacityUnits")
    def maximum_core_capacity_units(self) -> Optional[int]:
        return pulumi.get(self, "maximum_core_capacity_units")

    @property
    @pulumi.getter(name="maximumOnDemandCapacityUnits")
    def maximum_on_demand_capacity_units(self) -> Optional[int]:
        return pulumi.get(self, "maximum_on_demand_capacity_units")


@pulumi.output_type
class ClusterConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configurationProperties":
            suggest = "configuration_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 classification: Optional[str] = None,
                 configuration_properties: Optional[Any] = None,
                 configurations: Optional[Sequence['outputs.ClusterConfiguration']] = None):
        ClusterConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            classification=classification,
            configuration_properties=configuration_properties,
            configurations=configurations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             classification: Optional[str] = None,
             configuration_properties: Optional[Any] = None,
             configurations: Optional[Sequence['outputs.ClusterConfiguration']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if classification is not None:
            _setter("classification", classification)
        if configuration_properties is not None:
            _setter("configuration_properties", configuration_properties)
        if configurations is not None:
            _setter("configurations", configurations)

    @property
    @pulumi.getter
    def classification(self) -> Optional[str]:
        return pulumi.get(self, "classification")

    @property
    @pulumi.getter(name="configurationProperties")
    def configuration_properties(self) -> Optional[Any]:
        return pulumi.get(self, "configuration_properties")

    @property
    @pulumi.getter
    def configurations(self) -> Optional[Sequence['outputs.ClusterConfiguration']]:
        return pulumi.get(self, "configurations")


@pulumi.output_type
class ClusterEbsBlockDeviceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "volumeSpecification":
            suggest = "volume_specification"
        elif key == "volumesPerInstance":
            suggest = "volumes_per_instance"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterEbsBlockDeviceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterEbsBlockDeviceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterEbsBlockDeviceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 volume_specification: 'outputs.ClusterVolumeSpecification',
                 volumes_per_instance: Optional[int] = None):
        ClusterEbsBlockDeviceConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            volume_specification=volume_specification,
            volumes_per_instance=volumes_per_instance,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             volume_specification: 'outputs.ClusterVolumeSpecification',
             volumes_per_instance: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("volume_specification", volume_specification)
        if volumes_per_instance is not None:
            _setter("volumes_per_instance", volumes_per_instance)

    @property
    @pulumi.getter(name="volumeSpecification")
    def volume_specification(self) -> 'outputs.ClusterVolumeSpecification':
        return pulumi.get(self, "volume_specification")

    @property
    @pulumi.getter(name="volumesPerInstance")
    def volumes_per_instance(self) -> Optional[int]:
        return pulumi.get(self, "volumes_per_instance")


@pulumi.output_type
class ClusterEbsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ebsBlockDeviceConfigs":
            suggest = "ebs_block_device_configs"
        elif key == "ebsOptimized":
            suggest = "ebs_optimized"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterEbsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterEbsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterEbsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ebs_block_device_configs: Optional[Sequence['outputs.ClusterEbsBlockDeviceConfig']] = None,
                 ebs_optimized: Optional[bool] = None):
        ClusterEbsConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ebs_block_device_configs=ebs_block_device_configs,
            ebs_optimized=ebs_optimized,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ebs_block_device_configs: Optional[Sequence['outputs.ClusterEbsBlockDeviceConfig']] = None,
             ebs_optimized: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if ebs_block_device_configs is not None:
            _setter("ebs_block_device_configs", ebs_block_device_configs)
        if ebs_optimized is not None:
            _setter("ebs_optimized", ebs_optimized)

    @property
    @pulumi.getter(name="ebsBlockDeviceConfigs")
    def ebs_block_device_configs(self) -> Optional[Sequence['outputs.ClusterEbsBlockDeviceConfig']]:
        return pulumi.get(self, "ebs_block_device_configs")

    @property
    @pulumi.getter(name="ebsOptimized")
    def ebs_optimized(self) -> Optional[bool]:
        return pulumi.get(self, "ebs_optimized")


@pulumi.output_type
class ClusterHadoopJarStepConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mainClass":
            suggest = "main_class"
        elif key == "stepProperties":
            suggest = "step_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterHadoopJarStepConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterHadoopJarStepConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterHadoopJarStepConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 jar: str,
                 args: Optional[Sequence[str]] = None,
                 main_class: Optional[str] = None,
                 step_properties: Optional[Sequence['outputs.ClusterKeyValue']] = None):
        ClusterHadoopJarStepConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            jar=jar,
            args=args,
            main_class=main_class,
            step_properties=step_properties,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             jar: str,
             args: Optional[Sequence[str]] = None,
             main_class: Optional[str] = None,
             step_properties: Optional[Sequence['outputs.ClusterKeyValue']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("jar", jar)
        if args is not None:
            _setter("args", args)
        if main_class is not None:
            _setter("main_class", main_class)
        if step_properties is not None:
            _setter("step_properties", step_properties)

    @property
    @pulumi.getter
    def jar(self) -> str:
        return pulumi.get(self, "jar")

    @property
    @pulumi.getter
    def args(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "args")

    @property
    @pulumi.getter(name="mainClass")
    def main_class(self) -> Optional[str]:
        return pulumi.get(self, "main_class")

    @property
    @pulumi.getter(name="stepProperties")
    def step_properties(self) -> Optional[Sequence['outputs.ClusterKeyValue']]:
        return pulumi.get(self, "step_properties")


@pulumi.output_type
class ClusterInstanceFleetConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceTypeConfigs":
            suggest = "instance_type_configs"
        elif key == "launchSpecifications":
            suggest = "launch_specifications"
        elif key == "targetOnDemandCapacity":
            suggest = "target_on_demand_capacity"
        elif key == "targetSpotCapacity":
            suggest = "target_spot_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterInstanceFleetConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterInstanceFleetConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterInstanceFleetConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_type_configs: Optional[Sequence['outputs.ClusterInstanceTypeConfig']] = None,
                 launch_specifications: Optional['outputs.ClusterInstanceFleetProvisioningSpecifications'] = None,
                 name: Optional[str] = None,
                 target_on_demand_capacity: Optional[int] = None,
                 target_spot_capacity: Optional[int] = None):
        ClusterInstanceFleetConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_type_configs=instance_type_configs,
            launch_specifications=launch_specifications,
            name=name,
            target_on_demand_capacity=target_on_demand_capacity,
            target_spot_capacity=target_spot_capacity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_type_configs: Optional[Sequence['outputs.ClusterInstanceTypeConfig']] = None,
             launch_specifications: Optional['outputs.ClusterInstanceFleetProvisioningSpecifications'] = None,
             name: Optional[str] = None,
             target_on_demand_capacity: Optional[int] = None,
             target_spot_capacity: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if instance_type_configs is not None:
            _setter("instance_type_configs", instance_type_configs)
        if launch_specifications is not None:
            _setter("launch_specifications", launch_specifications)
        if name is not None:
            _setter("name", name)
        if target_on_demand_capacity is not None:
            _setter("target_on_demand_capacity", target_on_demand_capacity)
        if target_spot_capacity is not None:
            _setter("target_spot_capacity", target_spot_capacity)

    @property
    @pulumi.getter(name="instanceTypeConfigs")
    def instance_type_configs(self) -> Optional[Sequence['outputs.ClusterInstanceTypeConfig']]:
        return pulumi.get(self, "instance_type_configs")

    @property
    @pulumi.getter(name="launchSpecifications")
    def launch_specifications(self) -> Optional['outputs.ClusterInstanceFleetProvisioningSpecifications']:
        return pulumi.get(self, "launch_specifications")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="targetOnDemandCapacity")
    def target_on_demand_capacity(self) -> Optional[int]:
        return pulumi.get(self, "target_on_demand_capacity")

    @property
    @pulumi.getter(name="targetSpotCapacity")
    def target_spot_capacity(self) -> Optional[int]:
        return pulumi.get(self, "target_spot_capacity")


@pulumi.output_type
class ClusterInstanceFleetProvisioningSpecifications(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onDemandSpecification":
            suggest = "on_demand_specification"
        elif key == "spotSpecification":
            suggest = "spot_specification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterInstanceFleetProvisioningSpecifications. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterInstanceFleetProvisioningSpecifications.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterInstanceFleetProvisioningSpecifications.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 on_demand_specification: Optional['outputs.ClusterOnDemandProvisioningSpecification'] = None,
                 spot_specification: Optional['outputs.ClusterSpotProvisioningSpecification'] = None):
        ClusterInstanceFleetProvisioningSpecifications._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            on_demand_specification=on_demand_specification,
            spot_specification=spot_specification,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             on_demand_specification: Optional['outputs.ClusterOnDemandProvisioningSpecification'] = None,
             spot_specification: Optional['outputs.ClusterSpotProvisioningSpecification'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if on_demand_specification is not None:
            _setter("on_demand_specification", on_demand_specification)
        if spot_specification is not None:
            _setter("spot_specification", spot_specification)

    @property
    @pulumi.getter(name="onDemandSpecification")
    def on_demand_specification(self) -> Optional['outputs.ClusterOnDemandProvisioningSpecification']:
        return pulumi.get(self, "on_demand_specification")

    @property
    @pulumi.getter(name="spotSpecification")
    def spot_specification(self) -> Optional['outputs.ClusterSpotProvisioningSpecification']:
        return pulumi.get(self, "spot_specification")


@pulumi.output_type
class ClusterInstanceGroupConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceCount":
            suggest = "instance_count"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "autoScalingPolicy":
            suggest = "auto_scaling_policy"
        elif key == "bidPrice":
            suggest = "bid_price"
        elif key == "customAmiId":
            suggest = "custom_ami_id"
        elif key == "ebsConfiguration":
            suggest = "ebs_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterInstanceGroupConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterInstanceGroupConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterInstanceGroupConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_count: int,
                 instance_type: str,
                 auto_scaling_policy: Optional['outputs.ClusterAutoScalingPolicy'] = None,
                 bid_price: Optional[str] = None,
                 configurations: Optional[Sequence['outputs.ClusterConfiguration']] = None,
                 custom_ami_id: Optional[str] = None,
                 ebs_configuration: Optional['outputs.ClusterEbsConfiguration'] = None,
                 market: Optional[str] = None,
                 name: Optional[str] = None):
        ClusterInstanceGroupConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_count=instance_count,
            instance_type=instance_type,
            auto_scaling_policy=auto_scaling_policy,
            bid_price=bid_price,
            configurations=configurations,
            custom_ami_id=custom_ami_id,
            ebs_configuration=ebs_configuration,
            market=market,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_count: int,
             instance_type: str,
             auto_scaling_policy: Optional['outputs.ClusterAutoScalingPolicy'] = None,
             bid_price: Optional[str] = None,
             configurations: Optional[Sequence['outputs.ClusterConfiguration']] = None,
             custom_ami_id: Optional[str] = None,
             ebs_configuration: Optional['outputs.ClusterEbsConfiguration'] = None,
             market: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("instance_count", instance_count)
        _setter("instance_type", instance_type)
        if auto_scaling_policy is not None:
            _setter("auto_scaling_policy", auto_scaling_policy)
        if bid_price is not None:
            _setter("bid_price", bid_price)
        if configurations is not None:
            _setter("configurations", configurations)
        if custom_ami_id is not None:
            _setter("custom_ami_id", custom_ami_id)
        if ebs_configuration is not None:
            _setter("ebs_configuration", ebs_configuration)
        if market is not None:
            _setter("market", market)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> int:
        return pulumi.get(self, "instance_count")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> str:
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="autoScalingPolicy")
    def auto_scaling_policy(self) -> Optional['outputs.ClusterAutoScalingPolicy']:
        return pulumi.get(self, "auto_scaling_policy")

    @property
    @pulumi.getter(name="bidPrice")
    def bid_price(self) -> Optional[str]:
        return pulumi.get(self, "bid_price")

    @property
    @pulumi.getter
    def configurations(self) -> Optional[Sequence['outputs.ClusterConfiguration']]:
        return pulumi.get(self, "configurations")

    @property
    @pulumi.getter(name="customAmiId")
    def custom_ami_id(self) -> Optional[str]:
        return pulumi.get(self, "custom_ami_id")

    @property
    @pulumi.getter(name="ebsConfiguration")
    def ebs_configuration(self) -> Optional['outputs.ClusterEbsConfiguration']:
        return pulumi.get(self, "ebs_configuration")

    @property
    @pulumi.getter
    def market(self) -> Optional[str]:
        return pulumi.get(self, "market")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class ClusterInstanceTypeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceType":
            suggest = "instance_type"
        elif key == "bidPrice":
            suggest = "bid_price"
        elif key == "bidPriceAsPercentageOfOnDemandPrice":
            suggest = "bid_price_as_percentage_of_on_demand_price"
        elif key == "customAmiId":
            suggest = "custom_ami_id"
        elif key == "ebsConfiguration":
            suggest = "ebs_configuration"
        elif key == "weightedCapacity":
            suggest = "weighted_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterInstanceTypeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterInstanceTypeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterInstanceTypeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_type: str,
                 bid_price: Optional[str] = None,
                 bid_price_as_percentage_of_on_demand_price: Optional[float] = None,
                 configurations: Optional[Sequence['outputs.ClusterConfiguration']] = None,
                 custom_ami_id: Optional[str] = None,
                 ebs_configuration: Optional['outputs.ClusterEbsConfiguration'] = None,
                 weighted_capacity: Optional[int] = None):
        ClusterInstanceTypeConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_type=instance_type,
            bid_price=bid_price,
            bid_price_as_percentage_of_on_demand_price=bid_price_as_percentage_of_on_demand_price,
            configurations=configurations,
            custom_ami_id=custom_ami_id,
            ebs_configuration=ebs_configuration,
            weighted_capacity=weighted_capacity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_type: str,
             bid_price: Optional[str] = None,
             bid_price_as_percentage_of_on_demand_price: Optional[float] = None,
             configurations: Optional[Sequence['outputs.ClusterConfiguration']] = None,
             custom_ami_id: Optional[str] = None,
             ebs_configuration: Optional['outputs.ClusterEbsConfiguration'] = None,
             weighted_capacity: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("instance_type", instance_type)
        if bid_price is not None:
            _setter("bid_price", bid_price)
        if bid_price_as_percentage_of_on_demand_price is not None:
            _setter("bid_price_as_percentage_of_on_demand_price", bid_price_as_percentage_of_on_demand_price)
        if configurations is not None:
            _setter("configurations", configurations)
        if custom_ami_id is not None:
            _setter("custom_ami_id", custom_ami_id)
        if ebs_configuration is not None:
            _setter("ebs_configuration", ebs_configuration)
        if weighted_capacity is not None:
            _setter("weighted_capacity", weighted_capacity)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> str:
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="bidPrice")
    def bid_price(self) -> Optional[str]:
        return pulumi.get(self, "bid_price")

    @property
    @pulumi.getter(name="bidPriceAsPercentageOfOnDemandPrice")
    def bid_price_as_percentage_of_on_demand_price(self) -> Optional[float]:
        return pulumi.get(self, "bid_price_as_percentage_of_on_demand_price")

    @property
    @pulumi.getter
    def configurations(self) -> Optional[Sequence['outputs.ClusterConfiguration']]:
        return pulumi.get(self, "configurations")

    @property
    @pulumi.getter(name="customAmiId")
    def custom_ami_id(self) -> Optional[str]:
        return pulumi.get(self, "custom_ami_id")

    @property
    @pulumi.getter(name="ebsConfiguration")
    def ebs_configuration(self) -> Optional['outputs.ClusterEbsConfiguration']:
        return pulumi.get(self, "ebs_configuration")

    @property
    @pulumi.getter(name="weightedCapacity")
    def weighted_capacity(self) -> Optional[int]:
        return pulumi.get(self, "weighted_capacity")


@pulumi.output_type
class ClusterJobFlowInstancesConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalMasterSecurityGroups":
            suggest = "additional_master_security_groups"
        elif key == "additionalSlaveSecurityGroups":
            suggest = "additional_slave_security_groups"
        elif key == "coreInstanceFleet":
            suggest = "core_instance_fleet"
        elif key == "coreInstanceGroup":
            suggest = "core_instance_group"
        elif key == "ec2KeyName":
            suggest = "ec2_key_name"
        elif key == "ec2SubnetId":
            suggest = "ec2_subnet_id"
        elif key == "ec2SubnetIds":
            suggest = "ec2_subnet_ids"
        elif key == "emrManagedMasterSecurityGroup":
            suggest = "emr_managed_master_security_group"
        elif key == "emrManagedSlaveSecurityGroup":
            suggest = "emr_managed_slave_security_group"
        elif key == "hadoopVersion":
            suggest = "hadoop_version"
        elif key == "keepJobFlowAliveWhenNoSteps":
            suggest = "keep_job_flow_alive_when_no_steps"
        elif key == "masterInstanceFleet":
            suggest = "master_instance_fleet"
        elif key == "masterInstanceGroup":
            suggest = "master_instance_group"
        elif key == "serviceAccessSecurityGroup":
            suggest = "service_access_security_group"
        elif key == "taskInstanceFleets":
            suggest = "task_instance_fleets"
        elif key == "taskInstanceGroups":
            suggest = "task_instance_groups"
        elif key == "terminationProtected":
            suggest = "termination_protected"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterJobFlowInstancesConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterJobFlowInstancesConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterJobFlowInstancesConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_master_security_groups: Optional[Sequence[str]] = None,
                 additional_slave_security_groups: Optional[Sequence[str]] = None,
                 core_instance_fleet: Optional['outputs.ClusterInstanceFleetConfig'] = None,
                 core_instance_group: Optional['outputs.ClusterInstanceGroupConfig'] = None,
                 ec2_key_name: Optional[str] = None,
                 ec2_subnet_id: Optional[str] = None,
                 ec2_subnet_ids: Optional[Sequence[str]] = None,
                 emr_managed_master_security_group: Optional[str] = None,
                 emr_managed_slave_security_group: Optional[str] = None,
                 hadoop_version: Optional[str] = None,
                 keep_job_flow_alive_when_no_steps: Optional[bool] = None,
                 master_instance_fleet: Optional['outputs.ClusterInstanceFleetConfig'] = None,
                 master_instance_group: Optional['outputs.ClusterInstanceGroupConfig'] = None,
                 placement: Optional['outputs.ClusterPlacementType'] = None,
                 service_access_security_group: Optional[str] = None,
                 task_instance_fleets: Optional[Sequence['outputs.ClusterInstanceFleetConfig']] = None,
                 task_instance_groups: Optional[Sequence['outputs.ClusterInstanceGroupConfig']] = None,
                 termination_protected: Optional[bool] = None):
        ClusterJobFlowInstancesConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            additional_master_security_groups=additional_master_security_groups,
            additional_slave_security_groups=additional_slave_security_groups,
            core_instance_fleet=core_instance_fleet,
            core_instance_group=core_instance_group,
            ec2_key_name=ec2_key_name,
            ec2_subnet_id=ec2_subnet_id,
            ec2_subnet_ids=ec2_subnet_ids,
            emr_managed_master_security_group=emr_managed_master_security_group,
            emr_managed_slave_security_group=emr_managed_slave_security_group,
            hadoop_version=hadoop_version,
            keep_job_flow_alive_when_no_steps=keep_job_flow_alive_when_no_steps,
            master_instance_fleet=master_instance_fleet,
            master_instance_group=master_instance_group,
            placement=placement,
            service_access_security_group=service_access_security_group,
            task_instance_fleets=task_instance_fleets,
            task_instance_groups=task_instance_groups,
            termination_protected=termination_protected,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             additional_master_security_groups: Optional[Sequence[str]] = None,
             additional_slave_security_groups: Optional[Sequence[str]] = None,
             core_instance_fleet: Optional['outputs.ClusterInstanceFleetConfig'] = None,
             core_instance_group: Optional['outputs.ClusterInstanceGroupConfig'] = None,
             ec2_key_name: Optional[str] = None,
             ec2_subnet_id: Optional[str] = None,
             ec2_subnet_ids: Optional[Sequence[str]] = None,
             emr_managed_master_security_group: Optional[str] = None,
             emr_managed_slave_security_group: Optional[str] = None,
             hadoop_version: Optional[str] = None,
             keep_job_flow_alive_when_no_steps: Optional[bool] = None,
             master_instance_fleet: Optional['outputs.ClusterInstanceFleetConfig'] = None,
             master_instance_group: Optional['outputs.ClusterInstanceGroupConfig'] = None,
             placement: Optional['outputs.ClusterPlacementType'] = None,
             service_access_security_group: Optional[str] = None,
             task_instance_fleets: Optional[Sequence['outputs.ClusterInstanceFleetConfig']] = None,
             task_instance_groups: Optional[Sequence['outputs.ClusterInstanceGroupConfig']] = None,
             termination_protected: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if additional_master_security_groups is not None:
            _setter("additional_master_security_groups", additional_master_security_groups)
        if additional_slave_security_groups is not None:
            _setter("additional_slave_security_groups", additional_slave_security_groups)
        if core_instance_fleet is not None:
            _setter("core_instance_fleet", core_instance_fleet)
        if core_instance_group is not None:
            _setter("core_instance_group", core_instance_group)
        if ec2_key_name is not None:
            _setter("ec2_key_name", ec2_key_name)
        if ec2_subnet_id is not None:
            _setter("ec2_subnet_id", ec2_subnet_id)
        if ec2_subnet_ids is not None:
            _setter("ec2_subnet_ids", ec2_subnet_ids)
        if emr_managed_master_security_group is not None:
            _setter("emr_managed_master_security_group", emr_managed_master_security_group)
        if emr_managed_slave_security_group is not None:
            _setter("emr_managed_slave_security_group", emr_managed_slave_security_group)
        if hadoop_version is not None:
            _setter("hadoop_version", hadoop_version)
        if keep_job_flow_alive_when_no_steps is not None:
            _setter("keep_job_flow_alive_when_no_steps", keep_job_flow_alive_when_no_steps)
        if master_instance_fleet is not None:
            _setter("master_instance_fleet", master_instance_fleet)
        if master_instance_group is not None:
            _setter("master_instance_group", master_instance_group)
        if placement is not None:
            _setter("placement", placement)
        if service_access_security_group is not None:
            _setter("service_access_security_group", service_access_security_group)
        if task_instance_fleets is not None:
            _setter("task_instance_fleets", task_instance_fleets)
        if task_instance_groups is not None:
            _setter("task_instance_groups", task_instance_groups)
        if termination_protected is not None:
            _setter("termination_protected", termination_protected)

    @property
    @pulumi.getter(name="additionalMasterSecurityGroups")
    def additional_master_security_groups(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "additional_master_security_groups")

    @property
    @pulumi.getter(name="additionalSlaveSecurityGroups")
    def additional_slave_security_groups(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "additional_slave_security_groups")

    @property
    @pulumi.getter(name="coreInstanceFleet")
    def core_instance_fleet(self) -> Optional['outputs.ClusterInstanceFleetConfig']:
        return pulumi.get(self, "core_instance_fleet")

    @property
    @pulumi.getter(name="coreInstanceGroup")
    def core_instance_group(self) -> Optional['outputs.ClusterInstanceGroupConfig']:
        return pulumi.get(self, "core_instance_group")

    @property
    @pulumi.getter(name="ec2KeyName")
    def ec2_key_name(self) -> Optional[str]:
        return pulumi.get(self, "ec2_key_name")

    @property
    @pulumi.getter(name="ec2SubnetId")
    def ec2_subnet_id(self) -> Optional[str]:
        return pulumi.get(self, "ec2_subnet_id")

    @property
    @pulumi.getter(name="ec2SubnetIds")
    def ec2_subnet_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ec2_subnet_ids")

    @property
    @pulumi.getter(name="emrManagedMasterSecurityGroup")
    def emr_managed_master_security_group(self) -> Optional[str]:
        return pulumi.get(self, "emr_managed_master_security_group")

    @property
    @pulumi.getter(name="emrManagedSlaveSecurityGroup")
    def emr_managed_slave_security_group(self) -> Optional[str]:
        return pulumi.get(self, "emr_managed_slave_security_group")

    @property
    @pulumi.getter(name="hadoopVersion")
    def hadoop_version(self) -> Optional[str]:
        return pulumi.get(self, "hadoop_version")

    @property
    @pulumi.getter(name="keepJobFlowAliveWhenNoSteps")
    def keep_job_flow_alive_when_no_steps(self) -> Optional[bool]:
        return pulumi.get(self, "keep_job_flow_alive_when_no_steps")

    @property
    @pulumi.getter(name="masterInstanceFleet")
    def master_instance_fleet(self) -> Optional['outputs.ClusterInstanceFleetConfig']:
        return pulumi.get(self, "master_instance_fleet")

    @property
    @pulumi.getter(name="masterInstanceGroup")
    def master_instance_group(self) -> Optional['outputs.ClusterInstanceGroupConfig']:
        return pulumi.get(self, "master_instance_group")

    @property
    @pulumi.getter
    def placement(self) -> Optional['outputs.ClusterPlacementType']:
        return pulumi.get(self, "placement")

    @property
    @pulumi.getter(name="serviceAccessSecurityGroup")
    def service_access_security_group(self) -> Optional[str]:
        return pulumi.get(self, "service_access_security_group")

    @property
    @pulumi.getter(name="taskInstanceFleets")
    def task_instance_fleets(self) -> Optional[Sequence['outputs.ClusterInstanceFleetConfig']]:
        return pulumi.get(self, "task_instance_fleets")

    @property
    @pulumi.getter(name="taskInstanceGroups")
    def task_instance_groups(self) -> Optional[Sequence['outputs.ClusterInstanceGroupConfig']]:
        return pulumi.get(self, "task_instance_groups")

    @property
    @pulumi.getter(name="terminationProtected")
    def termination_protected(self) -> Optional[bool]:
        return pulumi.get(self, "termination_protected")


@pulumi.output_type
class ClusterKerberosAttributes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kdcAdminPassword":
            suggest = "kdc_admin_password"
        elif key == "adDomainJoinPassword":
            suggest = "ad_domain_join_password"
        elif key == "adDomainJoinUser":
            suggest = "ad_domain_join_user"
        elif key == "crossRealmTrustPrincipalPassword":
            suggest = "cross_realm_trust_principal_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterKerberosAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterKerberosAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterKerberosAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kdc_admin_password: str,
                 realm: str,
                 ad_domain_join_password: Optional[str] = None,
                 ad_domain_join_user: Optional[str] = None,
                 cross_realm_trust_principal_password: Optional[str] = None):
        ClusterKerberosAttributes._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            kdc_admin_password=kdc_admin_password,
            realm=realm,
            ad_domain_join_password=ad_domain_join_password,
            ad_domain_join_user=ad_domain_join_user,
            cross_realm_trust_principal_password=cross_realm_trust_principal_password,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             kdc_admin_password: str,
             realm: str,
             ad_domain_join_password: Optional[str] = None,
             ad_domain_join_user: Optional[str] = None,
             cross_realm_trust_principal_password: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("kdc_admin_password", kdc_admin_password)
        _setter("realm", realm)
        if ad_domain_join_password is not None:
            _setter("ad_domain_join_password", ad_domain_join_password)
        if ad_domain_join_user is not None:
            _setter("ad_domain_join_user", ad_domain_join_user)
        if cross_realm_trust_principal_password is not None:
            _setter("cross_realm_trust_principal_password", cross_realm_trust_principal_password)

    @property
    @pulumi.getter(name="kdcAdminPassword")
    def kdc_admin_password(self) -> str:
        return pulumi.get(self, "kdc_admin_password")

    @property
    @pulumi.getter
    def realm(self) -> str:
        return pulumi.get(self, "realm")

    @property
    @pulumi.getter(name="adDomainJoinPassword")
    def ad_domain_join_password(self) -> Optional[str]:
        return pulumi.get(self, "ad_domain_join_password")

    @property
    @pulumi.getter(name="adDomainJoinUser")
    def ad_domain_join_user(self) -> Optional[str]:
        return pulumi.get(self, "ad_domain_join_user")

    @property
    @pulumi.getter(name="crossRealmTrustPrincipalPassword")
    def cross_realm_trust_principal_password(self) -> Optional[str]:
        return pulumi.get(self, "cross_realm_trust_principal_password")


@pulumi.output_type
class ClusterKeyValue(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        ClusterKeyValue._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterManagedScalingPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeLimits":
            suggest = "compute_limits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterManagedScalingPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterManagedScalingPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterManagedScalingPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute_limits: Optional['outputs.ClusterComputeLimits'] = None):
        ClusterManagedScalingPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            compute_limits=compute_limits,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             compute_limits: Optional['outputs.ClusterComputeLimits'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if compute_limits is not None:
            _setter("compute_limits", compute_limits)

    @property
    @pulumi.getter(name="computeLimits")
    def compute_limits(self) -> Optional['outputs.ClusterComputeLimits']:
        return pulumi.get(self, "compute_limits")


@pulumi.output_type
class ClusterMetricDimension(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        ClusterMetricDimension._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterOnDemandProvisioningSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocationStrategy":
            suggest = "allocation_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterOnDemandProvisioningSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterOnDemandProvisioningSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterOnDemandProvisioningSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocation_strategy: str):
        ClusterOnDemandProvisioningSpecification._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allocation_strategy=allocation_strategy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allocation_strategy: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("allocation_strategy", allocation_strategy)

    @property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> str:
        return pulumi.get(self, "allocation_strategy")


@pulumi.output_type
class ClusterPlacementType(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availabilityZone":
            suggest = "availability_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterPlacementType. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterPlacementType.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterPlacementType.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 availability_zone: str):
        ClusterPlacementType._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            availability_zone=availability_zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             availability_zone: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("availability_zone", availability_zone)

    @property
    @pulumi.getter(name="availabilityZone")
    def availability_zone(self) -> str:
        return pulumi.get(self, "availability_zone")


@pulumi.output_type
class ClusterScalingAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "simpleScalingPolicyConfiguration":
            suggest = "simple_scaling_policy_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterScalingAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterScalingAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterScalingAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 simple_scaling_policy_configuration: 'outputs.ClusterSimpleScalingPolicyConfiguration',
                 market: Optional[str] = None):
        ClusterScalingAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            simple_scaling_policy_configuration=simple_scaling_policy_configuration,
            market=market,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             simple_scaling_policy_configuration: 'outputs.ClusterSimpleScalingPolicyConfiguration',
             market: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("simple_scaling_policy_configuration", simple_scaling_policy_configuration)
        if market is not None:
            _setter("market", market)

    @property
    @pulumi.getter(name="simpleScalingPolicyConfiguration")
    def simple_scaling_policy_configuration(self) -> 'outputs.ClusterSimpleScalingPolicyConfiguration':
        return pulumi.get(self, "simple_scaling_policy_configuration")

    @property
    @pulumi.getter
    def market(self) -> Optional[str]:
        return pulumi.get(self, "market")


@pulumi.output_type
class ClusterScalingConstraints(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxCapacity":
            suggest = "max_capacity"
        elif key == "minCapacity":
            suggest = "min_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterScalingConstraints. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterScalingConstraints.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterScalingConstraints.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_capacity: int,
                 min_capacity: int):
        ClusterScalingConstraints._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_capacity=max_capacity,
            min_capacity=min_capacity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_capacity: int,
             min_capacity: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("max_capacity", max_capacity)
        _setter("min_capacity", min_capacity)

    @property
    @pulumi.getter(name="maxCapacity")
    def max_capacity(self) -> int:
        return pulumi.get(self, "max_capacity")

    @property
    @pulumi.getter(name="minCapacity")
    def min_capacity(self) -> int:
        return pulumi.get(self, "min_capacity")


@pulumi.output_type
class ClusterScalingRule(dict):
    def __init__(__self__, *,
                 action: 'outputs.ClusterScalingAction',
                 name: str,
                 trigger: 'outputs.ClusterScalingTrigger',
                 description: Optional[str] = None):
        ClusterScalingRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            name=name,
            trigger=trigger,
            description=description,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: 'outputs.ClusterScalingAction',
             name: str,
             trigger: 'outputs.ClusterScalingTrigger',
             description: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("action", action)
        _setter("name", name)
        _setter("trigger", trigger)
        if description is not None:
            _setter("description", description)

    @property
    @pulumi.getter
    def action(self) -> 'outputs.ClusterScalingAction':
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def trigger(self) -> 'outputs.ClusterScalingTrigger':
        return pulumi.get(self, "trigger")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class ClusterScalingTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudWatchAlarmDefinition":
            suggest = "cloud_watch_alarm_definition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterScalingTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterScalingTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterScalingTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_watch_alarm_definition: 'outputs.ClusterCloudWatchAlarmDefinition'):
        ClusterScalingTrigger._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_watch_alarm_definition=cloud_watch_alarm_definition,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_watch_alarm_definition: 'outputs.ClusterCloudWatchAlarmDefinition',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cloud_watch_alarm_definition", cloud_watch_alarm_definition)

    @property
    @pulumi.getter(name="cloudWatchAlarmDefinition")
    def cloud_watch_alarm_definition(self) -> 'outputs.ClusterCloudWatchAlarmDefinition':
        return pulumi.get(self, "cloud_watch_alarm_definition")


@pulumi.output_type
class ClusterScriptBootstrapActionConfig(dict):
    def __init__(__self__, *,
                 path: str,
                 args: Optional[Sequence[str]] = None):
        ClusterScriptBootstrapActionConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            path=path,
            args=args,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             path: str,
             args: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("path", path)
        if args is not None:
            _setter("args", args)

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def args(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "args")


@pulumi.output_type
class ClusterSimpleScalingPolicyConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scalingAdjustment":
            suggest = "scaling_adjustment"
        elif key == "adjustmentType":
            suggest = "adjustment_type"
        elif key == "coolDown":
            suggest = "cool_down"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterSimpleScalingPolicyConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterSimpleScalingPolicyConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterSimpleScalingPolicyConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scaling_adjustment: int,
                 adjustment_type: Optional[str] = None,
                 cool_down: Optional[int] = None):
        ClusterSimpleScalingPolicyConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            scaling_adjustment=scaling_adjustment,
            adjustment_type=adjustment_type,
            cool_down=cool_down,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             scaling_adjustment: int,
             adjustment_type: Optional[str] = None,
             cool_down: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("scaling_adjustment", scaling_adjustment)
        if adjustment_type is not None:
            _setter("adjustment_type", adjustment_type)
        if cool_down is not None:
            _setter("cool_down", cool_down)

    @property
    @pulumi.getter(name="scalingAdjustment")
    def scaling_adjustment(self) -> int:
        return pulumi.get(self, "scaling_adjustment")

    @property
    @pulumi.getter(name="adjustmentType")
    def adjustment_type(self) -> Optional[str]:
        return pulumi.get(self, "adjustment_type")

    @property
    @pulumi.getter(name="coolDown")
    def cool_down(self) -> Optional[int]:
        return pulumi.get(self, "cool_down")


@pulumi.output_type
class ClusterSpotProvisioningSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeoutAction":
            suggest = "timeout_action"
        elif key == "timeoutDurationMinutes":
            suggest = "timeout_duration_minutes"
        elif key == "allocationStrategy":
            suggest = "allocation_strategy"
        elif key == "blockDurationMinutes":
            suggest = "block_duration_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterSpotProvisioningSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterSpotProvisioningSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterSpotProvisioningSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 timeout_action: str,
                 timeout_duration_minutes: int,
                 allocation_strategy: Optional[str] = None,
                 block_duration_minutes: Optional[int] = None):
        ClusterSpotProvisioningSpecification._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            timeout_action=timeout_action,
            timeout_duration_minutes=timeout_duration_minutes,
            allocation_strategy=allocation_strategy,
            block_duration_minutes=block_duration_minutes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             timeout_action: str,
             timeout_duration_minutes: int,
             allocation_strategy: Optional[str] = None,
             block_duration_minutes: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("timeout_action", timeout_action)
        _setter("timeout_duration_minutes", timeout_duration_minutes)
        if allocation_strategy is not None:
            _setter("allocation_strategy", allocation_strategy)
        if block_duration_minutes is not None:
            _setter("block_duration_minutes", block_duration_minutes)

    @property
    @pulumi.getter(name="timeoutAction")
    def timeout_action(self) -> str:
        return pulumi.get(self, "timeout_action")

    @property
    @pulumi.getter(name="timeoutDurationMinutes")
    def timeout_duration_minutes(self) -> int:
        return pulumi.get(self, "timeout_duration_minutes")

    @property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> Optional[str]:
        return pulumi.get(self, "allocation_strategy")

    @property
    @pulumi.getter(name="blockDurationMinutes")
    def block_duration_minutes(self) -> Optional[int]:
        return pulumi.get(self, "block_duration_minutes")


@pulumi.output_type
class ClusterStepConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hadoopJarStep":
            suggest = "hadoop_jar_step"
        elif key == "actionOnFailure":
            suggest = "action_on_failure"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterStepConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterStepConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterStepConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hadoop_jar_step: 'outputs.ClusterHadoopJarStepConfig',
                 name: str,
                 action_on_failure: Optional[str] = None):
        ClusterStepConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hadoop_jar_step=hadoop_jar_step,
            name=name,
            action_on_failure=action_on_failure,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hadoop_jar_step: 'outputs.ClusterHadoopJarStepConfig',
             name: str,
             action_on_failure: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("hadoop_jar_step", hadoop_jar_step)
        _setter("name", name)
        if action_on_failure is not None:
            _setter("action_on_failure", action_on_failure)

    @property
    @pulumi.getter(name="hadoopJarStep")
    def hadoop_jar_step(self) -> 'outputs.ClusterHadoopJarStepConfig':
        return pulumi.get(self, "hadoop_jar_step")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="actionOnFailure")
    def action_on_failure(self) -> Optional[str]:
        return pulumi.get(self, "action_on_failure")


@pulumi.output_type
class ClusterTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        ClusterTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class ClusterVolumeSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sizeInGb":
            suggest = "size_in_gb"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterVolumeSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterVolumeSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterVolumeSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size_in_gb: int,
                 volume_type: str,
                 iops: Optional[int] = None,
                 throughput: Optional[int] = None):
        ClusterVolumeSpecification._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            size_in_gb=size_in_gb,
            volume_type=volume_type,
            iops=iops,
            throughput=throughput,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             size_in_gb: int,
             volume_type: str,
             iops: Optional[int] = None,
             throughput: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("size_in_gb", size_in_gb)
        _setter("volume_type", volume_type)
        if iops is not None:
            _setter("iops", iops)
        if throughput is not None:
            _setter("throughput", throughput)

    @property
    @pulumi.getter(name="sizeInGb")
    def size_in_gb(self) -> int:
        return pulumi.get(self, "size_in_gb")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> str:
        return pulumi.get(self, "volume_type")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter
    def throughput(self) -> Optional[int]:
        return pulumi.get(self, "throughput")


@pulumi.output_type
class InstanceFleetConfigConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configurationProperties":
            suggest = "configuration_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFleetConfigConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFleetConfigConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFleetConfigConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 classification: Optional[str] = None,
                 configuration_properties: Optional[Any] = None,
                 configurations: Optional[Sequence['outputs.InstanceFleetConfigConfiguration']] = None):
        InstanceFleetConfigConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            classification=classification,
            configuration_properties=configuration_properties,
            configurations=configurations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             classification: Optional[str] = None,
             configuration_properties: Optional[Any] = None,
             configurations: Optional[Sequence['outputs.InstanceFleetConfigConfiguration']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if classification is not None:
            _setter("classification", classification)
        if configuration_properties is not None:
            _setter("configuration_properties", configuration_properties)
        if configurations is not None:
            _setter("configurations", configurations)

    @property
    @pulumi.getter
    def classification(self) -> Optional[str]:
        return pulumi.get(self, "classification")

    @property
    @pulumi.getter(name="configurationProperties")
    def configuration_properties(self) -> Optional[Any]:
        return pulumi.get(self, "configuration_properties")

    @property
    @pulumi.getter
    def configurations(self) -> Optional[Sequence['outputs.InstanceFleetConfigConfiguration']]:
        return pulumi.get(self, "configurations")


@pulumi.output_type
class InstanceFleetConfigEbsBlockDeviceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "volumeSpecification":
            suggest = "volume_specification"
        elif key == "volumesPerInstance":
            suggest = "volumes_per_instance"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFleetConfigEbsBlockDeviceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFleetConfigEbsBlockDeviceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFleetConfigEbsBlockDeviceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 volume_specification: 'outputs.InstanceFleetConfigVolumeSpecification',
                 volumes_per_instance: Optional[int] = None):
        InstanceFleetConfigEbsBlockDeviceConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            volume_specification=volume_specification,
            volumes_per_instance=volumes_per_instance,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             volume_specification: 'outputs.InstanceFleetConfigVolumeSpecification',
             volumes_per_instance: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("volume_specification", volume_specification)
        if volumes_per_instance is not None:
            _setter("volumes_per_instance", volumes_per_instance)

    @property
    @pulumi.getter(name="volumeSpecification")
    def volume_specification(self) -> 'outputs.InstanceFleetConfigVolumeSpecification':
        return pulumi.get(self, "volume_specification")

    @property
    @pulumi.getter(name="volumesPerInstance")
    def volumes_per_instance(self) -> Optional[int]:
        return pulumi.get(self, "volumes_per_instance")


@pulumi.output_type
class InstanceFleetConfigEbsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ebsBlockDeviceConfigs":
            suggest = "ebs_block_device_configs"
        elif key == "ebsOptimized":
            suggest = "ebs_optimized"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFleetConfigEbsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFleetConfigEbsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFleetConfigEbsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ebs_block_device_configs: Optional[Sequence['outputs.InstanceFleetConfigEbsBlockDeviceConfig']] = None,
                 ebs_optimized: Optional[bool] = None):
        InstanceFleetConfigEbsConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ebs_block_device_configs=ebs_block_device_configs,
            ebs_optimized=ebs_optimized,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ebs_block_device_configs: Optional[Sequence['outputs.InstanceFleetConfigEbsBlockDeviceConfig']] = None,
             ebs_optimized: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if ebs_block_device_configs is not None:
            _setter("ebs_block_device_configs", ebs_block_device_configs)
        if ebs_optimized is not None:
            _setter("ebs_optimized", ebs_optimized)

    @property
    @pulumi.getter(name="ebsBlockDeviceConfigs")
    def ebs_block_device_configs(self) -> Optional[Sequence['outputs.InstanceFleetConfigEbsBlockDeviceConfig']]:
        return pulumi.get(self, "ebs_block_device_configs")

    @property
    @pulumi.getter(name="ebsOptimized")
    def ebs_optimized(self) -> Optional[bool]:
        return pulumi.get(self, "ebs_optimized")


@pulumi.output_type
class InstanceFleetConfigInstanceFleetProvisioningSpecifications(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onDemandSpecification":
            suggest = "on_demand_specification"
        elif key == "spotSpecification":
            suggest = "spot_specification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFleetConfigInstanceFleetProvisioningSpecifications. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFleetConfigInstanceFleetProvisioningSpecifications.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFleetConfigInstanceFleetProvisioningSpecifications.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 on_demand_specification: Optional['outputs.InstanceFleetConfigOnDemandProvisioningSpecification'] = None,
                 spot_specification: Optional['outputs.InstanceFleetConfigSpotProvisioningSpecification'] = None):
        InstanceFleetConfigInstanceFleetProvisioningSpecifications._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            on_demand_specification=on_demand_specification,
            spot_specification=spot_specification,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             on_demand_specification: Optional['outputs.InstanceFleetConfigOnDemandProvisioningSpecification'] = None,
             spot_specification: Optional['outputs.InstanceFleetConfigSpotProvisioningSpecification'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if on_demand_specification is not None:
            _setter("on_demand_specification", on_demand_specification)
        if spot_specification is not None:
            _setter("spot_specification", spot_specification)

    @property
    @pulumi.getter(name="onDemandSpecification")
    def on_demand_specification(self) -> Optional['outputs.InstanceFleetConfigOnDemandProvisioningSpecification']:
        return pulumi.get(self, "on_demand_specification")

    @property
    @pulumi.getter(name="spotSpecification")
    def spot_specification(self) -> Optional['outputs.InstanceFleetConfigSpotProvisioningSpecification']:
        return pulumi.get(self, "spot_specification")


@pulumi.output_type
class InstanceFleetConfigInstanceTypeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceType":
            suggest = "instance_type"
        elif key == "bidPrice":
            suggest = "bid_price"
        elif key == "bidPriceAsPercentageOfOnDemandPrice":
            suggest = "bid_price_as_percentage_of_on_demand_price"
        elif key == "customAmiId":
            suggest = "custom_ami_id"
        elif key == "ebsConfiguration":
            suggest = "ebs_configuration"
        elif key == "weightedCapacity":
            suggest = "weighted_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFleetConfigInstanceTypeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFleetConfigInstanceTypeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFleetConfigInstanceTypeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_type: str,
                 bid_price: Optional[str] = None,
                 bid_price_as_percentage_of_on_demand_price: Optional[float] = None,
                 configurations: Optional[Sequence['outputs.InstanceFleetConfigConfiguration']] = None,
                 custom_ami_id: Optional[str] = None,
                 ebs_configuration: Optional['outputs.InstanceFleetConfigEbsConfiguration'] = None,
                 weighted_capacity: Optional[int] = None):
        InstanceFleetConfigInstanceTypeConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_type=instance_type,
            bid_price=bid_price,
            bid_price_as_percentage_of_on_demand_price=bid_price_as_percentage_of_on_demand_price,
            configurations=configurations,
            custom_ami_id=custom_ami_id,
            ebs_configuration=ebs_configuration,
            weighted_capacity=weighted_capacity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_type: str,
             bid_price: Optional[str] = None,
             bid_price_as_percentage_of_on_demand_price: Optional[float] = None,
             configurations: Optional[Sequence['outputs.InstanceFleetConfigConfiguration']] = None,
             custom_ami_id: Optional[str] = None,
             ebs_configuration: Optional['outputs.InstanceFleetConfigEbsConfiguration'] = None,
             weighted_capacity: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("instance_type", instance_type)
        if bid_price is not None:
            _setter("bid_price", bid_price)
        if bid_price_as_percentage_of_on_demand_price is not None:
            _setter("bid_price_as_percentage_of_on_demand_price", bid_price_as_percentage_of_on_demand_price)
        if configurations is not None:
            _setter("configurations", configurations)
        if custom_ami_id is not None:
            _setter("custom_ami_id", custom_ami_id)
        if ebs_configuration is not None:
            _setter("ebs_configuration", ebs_configuration)
        if weighted_capacity is not None:
            _setter("weighted_capacity", weighted_capacity)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> str:
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="bidPrice")
    def bid_price(self) -> Optional[str]:
        return pulumi.get(self, "bid_price")

    @property
    @pulumi.getter(name="bidPriceAsPercentageOfOnDemandPrice")
    def bid_price_as_percentage_of_on_demand_price(self) -> Optional[float]:
        return pulumi.get(self, "bid_price_as_percentage_of_on_demand_price")

    @property
    @pulumi.getter
    def configurations(self) -> Optional[Sequence['outputs.InstanceFleetConfigConfiguration']]:
        return pulumi.get(self, "configurations")

    @property
    @pulumi.getter(name="customAmiId")
    def custom_ami_id(self) -> Optional[str]:
        return pulumi.get(self, "custom_ami_id")

    @property
    @pulumi.getter(name="ebsConfiguration")
    def ebs_configuration(self) -> Optional['outputs.InstanceFleetConfigEbsConfiguration']:
        return pulumi.get(self, "ebs_configuration")

    @property
    @pulumi.getter(name="weightedCapacity")
    def weighted_capacity(self) -> Optional[int]:
        return pulumi.get(self, "weighted_capacity")


@pulumi.output_type
class InstanceFleetConfigOnDemandProvisioningSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allocationStrategy":
            suggest = "allocation_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFleetConfigOnDemandProvisioningSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFleetConfigOnDemandProvisioningSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFleetConfigOnDemandProvisioningSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocation_strategy: str):
        InstanceFleetConfigOnDemandProvisioningSpecification._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allocation_strategy=allocation_strategy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allocation_strategy: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("allocation_strategy", allocation_strategy)

    @property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> str:
        return pulumi.get(self, "allocation_strategy")


@pulumi.output_type
class InstanceFleetConfigSpotProvisioningSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeoutAction":
            suggest = "timeout_action"
        elif key == "timeoutDurationMinutes":
            suggest = "timeout_duration_minutes"
        elif key == "allocationStrategy":
            suggest = "allocation_strategy"
        elif key == "blockDurationMinutes":
            suggest = "block_duration_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFleetConfigSpotProvisioningSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFleetConfigSpotProvisioningSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFleetConfigSpotProvisioningSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 timeout_action: str,
                 timeout_duration_minutes: int,
                 allocation_strategy: Optional[str] = None,
                 block_duration_minutes: Optional[int] = None):
        InstanceFleetConfigSpotProvisioningSpecification._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            timeout_action=timeout_action,
            timeout_duration_minutes=timeout_duration_minutes,
            allocation_strategy=allocation_strategy,
            block_duration_minutes=block_duration_minutes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             timeout_action: str,
             timeout_duration_minutes: int,
             allocation_strategy: Optional[str] = None,
             block_duration_minutes: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("timeout_action", timeout_action)
        _setter("timeout_duration_minutes", timeout_duration_minutes)
        if allocation_strategy is not None:
            _setter("allocation_strategy", allocation_strategy)
        if block_duration_minutes is not None:
            _setter("block_duration_minutes", block_duration_minutes)

    @property
    @pulumi.getter(name="timeoutAction")
    def timeout_action(self) -> str:
        return pulumi.get(self, "timeout_action")

    @property
    @pulumi.getter(name="timeoutDurationMinutes")
    def timeout_duration_minutes(self) -> int:
        return pulumi.get(self, "timeout_duration_minutes")

    @property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> Optional[str]:
        return pulumi.get(self, "allocation_strategy")

    @property
    @pulumi.getter(name="blockDurationMinutes")
    def block_duration_minutes(self) -> Optional[int]:
        return pulumi.get(self, "block_duration_minutes")


@pulumi.output_type
class InstanceFleetConfigVolumeSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sizeInGb":
            suggest = "size_in_gb"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceFleetConfigVolumeSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceFleetConfigVolumeSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceFleetConfigVolumeSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size_in_gb: int,
                 volume_type: str,
                 iops: Optional[int] = None,
                 throughput: Optional[int] = None):
        InstanceFleetConfigVolumeSpecification._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            size_in_gb=size_in_gb,
            volume_type=volume_type,
            iops=iops,
            throughput=throughput,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             size_in_gb: int,
             volume_type: str,
             iops: Optional[int] = None,
             throughput: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("size_in_gb", size_in_gb)
        _setter("volume_type", volume_type)
        if iops is not None:
            _setter("iops", iops)
        if throughput is not None:
            _setter("throughput", throughput)

    @property
    @pulumi.getter(name="sizeInGb")
    def size_in_gb(self) -> int:
        return pulumi.get(self, "size_in_gb")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> str:
        return pulumi.get(self, "volume_type")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter
    def throughput(self) -> Optional[int]:
        return pulumi.get(self, "throughput")


@pulumi.output_type
class InstanceGroupConfigAutoScalingPolicy(dict):
    def __init__(__self__, *,
                 constraints: 'outputs.InstanceGroupConfigScalingConstraints',
                 rules: Sequence['outputs.InstanceGroupConfigScalingRule']):
        InstanceGroupConfigAutoScalingPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            constraints=constraints,
            rules=rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             constraints: 'outputs.InstanceGroupConfigScalingConstraints',
             rules: Sequence['outputs.InstanceGroupConfigScalingRule'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("constraints", constraints)
        _setter("rules", rules)

    @property
    @pulumi.getter
    def constraints(self) -> 'outputs.InstanceGroupConfigScalingConstraints':
        return pulumi.get(self, "constraints")

    @property
    @pulumi.getter
    def rules(self) -> Sequence['outputs.InstanceGroupConfigScalingRule']:
        return pulumi.get(self, "rules")


@pulumi.output_type
class InstanceGroupConfigCloudWatchAlarmDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"
        elif key == "metricName":
            suggest = "metric_name"
        elif key == "evaluationPeriods":
            suggest = "evaluation_periods"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceGroupConfigCloudWatchAlarmDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceGroupConfigCloudWatchAlarmDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceGroupConfigCloudWatchAlarmDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: str,
                 metric_name: str,
                 period: int,
                 threshold: float,
                 dimensions: Optional[Sequence['outputs.InstanceGroupConfigMetricDimension']] = None,
                 evaluation_periods: Optional[int] = None,
                 namespace: Optional[str] = None,
                 statistic: Optional[str] = None,
                 unit: Optional[str] = None):
        InstanceGroupConfigCloudWatchAlarmDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparison_operator=comparison_operator,
            metric_name=metric_name,
            period=period,
            threshold=threshold,
            dimensions=dimensions,
            evaluation_periods=evaluation_periods,
            namespace=namespace,
            statistic=statistic,
            unit=unit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparison_operator: str,
             metric_name: str,
             period: int,
             threshold: float,
             dimensions: Optional[Sequence['outputs.InstanceGroupConfigMetricDimension']] = None,
             evaluation_periods: Optional[int] = None,
             namespace: Optional[str] = None,
             statistic: Optional[str] = None,
             unit: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("comparison_operator", comparison_operator)
        _setter("metric_name", metric_name)
        _setter("period", period)
        _setter("threshold", threshold)
        if dimensions is not None:
            _setter("dimensions", dimensions)
        if evaluation_periods is not None:
            _setter("evaluation_periods", evaluation_periods)
        if namespace is not None:
            _setter("namespace", namespace)
        if statistic is not None:
            _setter("statistic", statistic)
        if unit is not None:
            _setter("unit", unit)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> str:
        return pulumi.get(self, "comparison_operator")

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def period(self) -> int:
        return pulumi.get(self, "period")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.InstanceGroupConfigMetricDimension']]:
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="evaluationPeriods")
    def evaluation_periods(self) -> Optional[int]:
        return pulumi.get(self, "evaluation_periods")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def statistic(self) -> Optional[str]:
        return pulumi.get(self, "statistic")

    @property
    @pulumi.getter
    def unit(self) -> Optional[str]:
        return pulumi.get(self, "unit")


@pulumi.output_type
class InstanceGroupConfigConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configurationProperties":
            suggest = "configuration_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceGroupConfigConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceGroupConfigConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceGroupConfigConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 classification: Optional[str] = None,
                 configuration_properties: Optional[Any] = None,
                 configurations: Optional[Sequence['outputs.InstanceGroupConfigConfiguration']] = None):
        InstanceGroupConfigConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            classification=classification,
            configuration_properties=configuration_properties,
            configurations=configurations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             classification: Optional[str] = None,
             configuration_properties: Optional[Any] = None,
             configurations: Optional[Sequence['outputs.InstanceGroupConfigConfiguration']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if classification is not None:
            _setter("classification", classification)
        if configuration_properties is not None:
            _setter("configuration_properties", configuration_properties)
        if configurations is not None:
            _setter("configurations", configurations)

    @property
    @pulumi.getter
    def classification(self) -> Optional[str]:
        return pulumi.get(self, "classification")

    @property
    @pulumi.getter(name="configurationProperties")
    def configuration_properties(self) -> Optional[Any]:
        return pulumi.get(self, "configuration_properties")

    @property
    @pulumi.getter
    def configurations(self) -> Optional[Sequence['outputs.InstanceGroupConfigConfiguration']]:
        return pulumi.get(self, "configurations")


@pulumi.output_type
class InstanceGroupConfigEbsBlockDeviceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "volumeSpecification":
            suggest = "volume_specification"
        elif key == "volumesPerInstance":
            suggest = "volumes_per_instance"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceGroupConfigEbsBlockDeviceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceGroupConfigEbsBlockDeviceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceGroupConfigEbsBlockDeviceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 volume_specification: 'outputs.InstanceGroupConfigVolumeSpecification',
                 volumes_per_instance: Optional[int] = None):
        InstanceGroupConfigEbsBlockDeviceConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            volume_specification=volume_specification,
            volumes_per_instance=volumes_per_instance,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             volume_specification: 'outputs.InstanceGroupConfigVolumeSpecification',
             volumes_per_instance: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("volume_specification", volume_specification)
        if volumes_per_instance is not None:
            _setter("volumes_per_instance", volumes_per_instance)

    @property
    @pulumi.getter(name="volumeSpecification")
    def volume_specification(self) -> 'outputs.InstanceGroupConfigVolumeSpecification':
        return pulumi.get(self, "volume_specification")

    @property
    @pulumi.getter(name="volumesPerInstance")
    def volumes_per_instance(self) -> Optional[int]:
        return pulumi.get(self, "volumes_per_instance")


@pulumi.output_type
class InstanceGroupConfigEbsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ebsBlockDeviceConfigs":
            suggest = "ebs_block_device_configs"
        elif key == "ebsOptimized":
            suggest = "ebs_optimized"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceGroupConfigEbsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceGroupConfigEbsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceGroupConfigEbsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ebs_block_device_configs: Optional[Sequence['outputs.InstanceGroupConfigEbsBlockDeviceConfig']] = None,
                 ebs_optimized: Optional[bool] = None):
        InstanceGroupConfigEbsConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ebs_block_device_configs=ebs_block_device_configs,
            ebs_optimized=ebs_optimized,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ebs_block_device_configs: Optional[Sequence['outputs.InstanceGroupConfigEbsBlockDeviceConfig']] = None,
             ebs_optimized: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if ebs_block_device_configs is not None:
            _setter("ebs_block_device_configs", ebs_block_device_configs)
        if ebs_optimized is not None:
            _setter("ebs_optimized", ebs_optimized)

    @property
    @pulumi.getter(name="ebsBlockDeviceConfigs")
    def ebs_block_device_configs(self) -> Optional[Sequence['outputs.InstanceGroupConfigEbsBlockDeviceConfig']]:
        return pulumi.get(self, "ebs_block_device_configs")

    @property
    @pulumi.getter(name="ebsOptimized")
    def ebs_optimized(self) -> Optional[bool]:
        return pulumi.get(self, "ebs_optimized")


@pulumi.output_type
class InstanceGroupConfigMetricDimension(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        InstanceGroupConfigMetricDimension._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class InstanceGroupConfigScalingAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "simpleScalingPolicyConfiguration":
            suggest = "simple_scaling_policy_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceGroupConfigScalingAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceGroupConfigScalingAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceGroupConfigScalingAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 simple_scaling_policy_configuration: 'outputs.InstanceGroupConfigSimpleScalingPolicyConfiguration',
                 market: Optional[str] = None):
        InstanceGroupConfigScalingAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            simple_scaling_policy_configuration=simple_scaling_policy_configuration,
            market=market,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             simple_scaling_policy_configuration: 'outputs.InstanceGroupConfigSimpleScalingPolicyConfiguration',
             market: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("simple_scaling_policy_configuration", simple_scaling_policy_configuration)
        if market is not None:
            _setter("market", market)

    @property
    @pulumi.getter(name="simpleScalingPolicyConfiguration")
    def simple_scaling_policy_configuration(self) -> 'outputs.InstanceGroupConfigSimpleScalingPolicyConfiguration':
        return pulumi.get(self, "simple_scaling_policy_configuration")

    @property
    @pulumi.getter
    def market(self) -> Optional[str]:
        return pulumi.get(self, "market")


@pulumi.output_type
class InstanceGroupConfigScalingConstraints(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxCapacity":
            suggest = "max_capacity"
        elif key == "minCapacity":
            suggest = "min_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceGroupConfigScalingConstraints. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceGroupConfigScalingConstraints.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceGroupConfigScalingConstraints.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_capacity: int,
                 min_capacity: int):
        InstanceGroupConfigScalingConstraints._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_capacity=max_capacity,
            min_capacity=min_capacity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_capacity: int,
             min_capacity: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("max_capacity", max_capacity)
        _setter("min_capacity", min_capacity)

    @property
    @pulumi.getter(name="maxCapacity")
    def max_capacity(self) -> int:
        return pulumi.get(self, "max_capacity")

    @property
    @pulumi.getter(name="minCapacity")
    def min_capacity(self) -> int:
        return pulumi.get(self, "min_capacity")


@pulumi.output_type
class InstanceGroupConfigScalingRule(dict):
    def __init__(__self__, *,
                 action: 'outputs.InstanceGroupConfigScalingAction',
                 name: str,
                 trigger: 'outputs.InstanceGroupConfigScalingTrigger',
                 description: Optional[str] = None):
        InstanceGroupConfigScalingRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            name=name,
            trigger=trigger,
            description=description,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: 'outputs.InstanceGroupConfigScalingAction',
             name: str,
             trigger: 'outputs.InstanceGroupConfigScalingTrigger',
             description: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("action", action)
        _setter("name", name)
        _setter("trigger", trigger)
        if description is not None:
            _setter("description", description)

    @property
    @pulumi.getter
    def action(self) -> 'outputs.InstanceGroupConfigScalingAction':
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def trigger(self) -> 'outputs.InstanceGroupConfigScalingTrigger':
        return pulumi.get(self, "trigger")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class InstanceGroupConfigScalingTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudWatchAlarmDefinition":
            suggest = "cloud_watch_alarm_definition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceGroupConfigScalingTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceGroupConfigScalingTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceGroupConfigScalingTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_watch_alarm_definition: 'outputs.InstanceGroupConfigCloudWatchAlarmDefinition'):
        InstanceGroupConfigScalingTrigger._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_watch_alarm_definition=cloud_watch_alarm_definition,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_watch_alarm_definition: 'outputs.InstanceGroupConfigCloudWatchAlarmDefinition',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cloud_watch_alarm_definition", cloud_watch_alarm_definition)

    @property
    @pulumi.getter(name="cloudWatchAlarmDefinition")
    def cloud_watch_alarm_definition(self) -> 'outputs.InstanceGroupConfigCloudWatchAlarmDefinition':
        return pulumi.get(self, "cloud_watch_alarm_definition")


@pulumi.output_type
class InstanceGroupConfigSimpleScalingPolicyConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scalingAdjustment":
            suggest = "scaling_adjustment"
        elif key == "adjustmentType":
            suggest = "adjustment_type"
        elif key == "coolDown":
            suggest = "cool_down"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceGroupConfigSimpleScalingPolicyConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceGroupConfigSimpleScalingPolicyConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceGroupConfigSimpleScalingPolicyConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scaling_adjustment: int,
                 adjustment_type: Optional[str] = None,
                 cool_down: Optional[int] = None):
        InstanceGroupConfigSimpleScalingPolicyConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            scaling_adjustment=scaling_adjustment,
            adjustment_type=adjustment_type,
            cool_down=cool_down,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             scaling_adjustment: int,
             adjustment_type: Optional[str] = None,
             cool_down: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("scaling_adjustment", scaling_adjustment)
        if adjustment_type is not None:
            _setter("adjustment_type", adjustment_type)
        if cool_down is not None:
            _setter("cool_down", cool_down)

    @property
    @pulumi.getter(name="scalingAdjustment")
    def scaling_adjustment(self) -> int:
        return pulumi.get(self, "scaling_adjustment")

    @property
    @pulumi.getter(name="adjustmentType")
    def adjustment_type(self) -> Optional[str]:
        return pulumi.get(self, "adjustment_type")

    @property
    @pulumi.getter(name="coolDown")
    def cool_down(self) -> Optional[int]:
        return pulumi.get(self, "cool_down")


@pulumi.output_type
class InstanceGroupConfigVolumeSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sizeInGb":
            suggest = "size_in_gb"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceGroupConfigVolumeSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceGroupConfigVolumeSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceGroupConfigVolumeSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size_in_gb: int,
                 volume_type: str,
                 iops: Optional[int] = None,
                 throughput: Optional[int] = None):
        InstanceGroupConfigVolumeSpecification._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            size_in_gb=size_in_gb,
            volume_type=volume_type,
            iops=iops,
            throughput=throughput,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             size_in_gb: int,
             volume_type: str,
             iops: Optional[int] = None,
             throughput: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("size_in_gb", size_in_gb)
        _setter("volume_type", volume_type)
        if iops is not None:
            _setter("iops", iops)
        if throughput is not None:
            _setter("throughput", throughput)

    @property
    @pulumi.getter(name="sizeInGb")
    def size_in_gb(self) -> int:
        return pulumi.get(self, "size_in_gb")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> str:
        return pulumi.get(self, "volume_type")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter
    def throughput(self) -> Optional[int]:
        return pulumi.get(self, "throughput")


@pulumi.output_type
class StepHadoopJarStepConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mainClass":
            suggest = "main_class"
        elif key == "stepProperties":
            suggest = "step_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StepHadoopJarStepConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StepHadoopJarStepConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StepHadoopJarStepConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 jar: str,
                 args: Optional[Sequence[str]] = None,
                 main_class: Optional[str] = None,
                 step_properties: Optional[Sequence['outputs.StepKeyValue']] = None):
        StepHadoopJarStepConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            jar=jar,
            args=args,
            main_class=main_class,
            step_properties=step_properties,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             jar: str,
             args: Optional[Sequence[str]] = None,
             main_class: Optional[str] = None,
             step_properties: Optional[Sequence['outputs.StepKeyValue']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("jar", jar)
        if args is not None:
            _setter("args", args)
        if main_class is not None:
            _setter("main_class", main_class)
        if step_properties is not None:
            _setter("step_properties", step_properties)

    @property
    @pulumi.getter
    def jar(self) -> str:
        return pulumi.get(self, "jar")

    @property
    @pulumi.getter
    def args(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "args")

    @property
    @pulumi.getter(name="mainClass")
    def main_class(self) -> Optional[str]:
        return pulumi.get(self, "main_class")

    @property
    @pulumi.getter(name="stepProperties")
    def step_properties(self) -> Optional[Sequence['outputs.StepKeyValue']]:
        return pulumi.get(self, "step_properties")


@pulumi.output_type
class StepKeyValue(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        StepKeyValue._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class StudioTag(dict):
    """
    An arbitrary set of tags (key-value pairs) for this EMR Studio.
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        An arbitrary set of tags (key-value pairs) for this EMR Studio.
        :param str key: The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
        :param str value: The value for the tag. You can specify a value that is 0 to 255 Unicode characters in length. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
        """
        StudioTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the tag. You can specify a value that is 0 to 255 Unicode characters in length. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class WalWorkspaceTag(dict):
    """
    A key-value pair to associate with a resource.
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        A key-value pair to associate with a resource.
        :param str key: The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        :param str value: The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        WalWorkspaceTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "value")


