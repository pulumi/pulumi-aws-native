# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from ._enums import *

__all__ = [
    'FirewallPolicyActionDefinitionArgs',
    'FirewallPolicyCustomActionArgs',
    'FirewallPolicyDimensionArgs',
    'FirewallPolicyIpSetArgs',
    'FirewallPolicyPolicyVariablesPropertiesArgs',
    'FirewallPolicyPublishMetricActionArgs',
    'FirewallPolicyStatefulEngineOptionsArgs',
    'FirewallPolicyStatefulRuleGroupOverrideArgs',
    'FirewallPolicyStatefulRuleGroupReferenceArgs',
    'FirewallPolicyStatelessRuleGroupReferenceArgs',
    'FirewallPolicyArgs',
    'FirewallSubnetMappingArgs',
    'LoggingConfigurationLogDestinationConfigArgs',
    'LoggingConfigurationArgs',
    'RuleGroupActionDefinitionArgs',
    'RuleGroupAddressArgs',
    'RuleGroupCustomActionArgs',
    'RuleGroupDimensionArgs',
    'RuleGroupHeaderArgs',
    'RuleGroupIpSetReferenceArgs',
    'RuleGroupIpSetArgs',
    'RuleGroupMatchAttributesArgs',
    'RuleGroupPortRangeArgs',
    'RuleGroupPortSetArgs',
    'RuleGroupPublishMetricActionArgs',
    'RuleGroupReferenceSetsArgs',
    'RuleGroupRuleDefinitionArgs',
    'RuleGroupRuleOptionArgs',
    'RuleGroupRuleVariablesArgs',
    'RuleGroupRulesSourceListArgs',
    'RuleGroupRulesSourceArgs',
    'RuleGroupStatefulRuleOptionsArgs',
    'RuleGroupStatefulRuleArgs',
    'RuleGroupStatelessRulesAndCustomActionsArgs',
    'RuleGroupStatelessRuleArgs',
    'RuleGroupTcpFlagFieldArgs',
    'RuleGroupArgs',
    'TlsInspectionConfigurationAddressArgs',
    'TlsInspectionConfigurationPortRangeArgs',
    'TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesArgs',
    'TlsInspectionConfigurationServerCertificateConfigurationArgs',
    'TlsInspectionConfigurationServerCertificateScopeArgs',
    'TlsInspectionConfigurationServerCertificateArgs',
    'TlsInspectionConfigurationTlsInspectionConfigurationArgs',
]

@pulumi.input_type
class FirewallPolicyActionDefinitionArgs:
    def __init__(__self__, *,
                 publish_metric_action: Optional[pulumi.Input['FirewallPolicyPublishMetricActionArgs']] = None):
        """
        :param pulumi.Input['FirewallPolicyPublishMetricActionArgs'] publish_metric_action: Stateless inspection criteria that publishes the specified metrics to Amazon CloudWatch for the matching packet. This setting defines a CloudWatch dimension value to be published.
               
               You can pair this custom action with any of the standard stateless rule actions. For example, you could pair this in a rule action with the standard action that forwards the packet for stateful inspection. Then, when a packet matches the rule, Network Firewall publishes metrics for the packet and forwards it.
        """
        if publish_metric_action is not None:
            pulumi.set(__self__, "publish_metric_action", publish_metric_action)

    @property
    @pulumi.getter(name="publishMetricAction")
    def publish_metric_action(self) -> Optional[pulumi.Input['FirewallPolicyPublishMetricActionArgs']]:
        """
        Stateless inspection criteria that publishes the specified metrics to Amazon CloudWatch for the matching packet. This setting defines a CloudWatch dimension value to be published.

        You can pair this custom action with any of the standard stateless rule actions. For example, you could pair this in a rule action with the standard action that forwards the packet for stateful inspection. Then, when a packet matches the rule, Network Firewall publishes metrics for the packet and forwards it.
        """
        return pulumi.get(self, "publish_metric_action")

    @publish_metric_action.setter
    def publish_metric_action(self, value: Optional[pulumi.Input['FirewallPolicyPublishMetricActionArgs']]):
        pulumi.set(self, "publish_metric_action", value)


@pulumi.input_type
class FirewallPolicyCustomActionArgs:
    def __init__(__self__, *,
                 action_definition: pulumi.Input['FirewallPolicyActionDefinitionArgs'],
                 action_name: pulumi.Input[str]):
        """
        :param pulumi.Input['FirewallPolicyActionDefinitionArgs'] action_definition: The custom action associated with the action name.
        :param pulumi.Input[str] action_name: The descriptive name of the custom action. You can't change the name of a custom action after you create it.
        """
        pulumi.set(__self__, "action_definition", action_definition)
        pulumi.set(__self__, "action_name", action_name)

    @property
    @pulumi.getter(name="actionDefinition")
    def action_definition(self) -> pulumi.Input['FirewallPolicyActionDefinitionArgs']:
        """
        The custom action associated with the action name.
        """
        return pulumi.get(self, "action_definition")

    @action_definition.setter
    def action_definition(self, value: pulumi.Input['FirewallPolicyActionDefinitionArgs']):
        pulumi.set(self, "action_definition", value)

    @property
    @pulumi.getter(name="actionName")
    def action_name(self) -> pulumi.Input[str]:
        """
        The descriptive name of the custom action. You can't change the name of a custom action after you create it.
        """
        return pulumi.get(self, "action_name")

    @action_name.setter
    def action_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "action_name", value)


@pulumi.input_type
class FirewallPolicyDimensionArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] value: The value to use in the custom metric dimension.
        """
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value to use in the custom metric dimension.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class FirewallPolicyIpSetArgs:
    def __init__(__self__, *,
                 definition: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] definition: The list of IP addresses and address ranges, in CIDR notation.
        """
        if definition is not None:
            pulumi.set(__self__, "definition", definition)

    @property
    @pulumi.getter
    def definition(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of IP addresses and address ranges, in CIDR notation.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "definition", value)


@pulumi.input_type
class FirewallPolicyPolicyVariablesPropertiesArgs:
    def __init__(__self__, *,
                 rule_variables: Optional[pulumi.Input[Mapping[str, pulumi.Input['FirewallPolicyIpSetArgs']]]] = None):
        """
        Contains variables that you can use to override default Suricata settings in your firewall policy.
        """
        if rule_variables is not None:
            pulumi.set(__self__, "rule_variables", rule_variables)

    @property
    @pulumi.getter(name="ruleVariables")
    def rule_variables(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['FirewallPolicyIpSetArgs']]]]:
        return pulumi.get(self, "rule_variables")

    @rule_variables.setter
    def rule_variables(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['FirewallPolicyIpSetArgs']]]]):
        pulumi.set(self, "rule_variables", value)


@pulumi.input_type
class FirewallPolicyPublishMetricActionArgs:
    def __init__(__self__, *,
                 dimensions: pulumi.Input[Sequence[pulumi.Input['FirewallPolicyDimensionArgs']]]):
        pulumi.set(__self__, "dimensions", dimensions)

    @property
    @pulumi.getter
    def dimensions(self) -> pulumi.Input[Sequence[pulumi.Input['FirewallPolicyDimensionArgs']]]:
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: pulumi.Input[Sequence[pulumi.Input['FirewallPolicyDimensionArgs']]]):
        pulumi.set(self, "dimensions", value)


@pulumi.input_type
class FirewallPolicyStatefulEngineOptionsArgs:
    def __init__(__self__, *,
                 rule_order: Optional[pulumi.Input['FirewallPolicyRuleOrder']] = None,
                 stream_exception_policy: Optional[pulumi.Input['FirewallPolicyStreamExceptionPolicy']] = None):
        """
        :param pulumi.Input['FirewallPolicyRuleOrder'] rule_order: Indicates how to manage the order of stateful rule evaluation for the policy. `DEFAULT_ACTION_ORDER` is the default behavior. Stateful rules are provided to the rule engine as Suricata compatible strings, and Suricata evaluates them based on certain settings. For more information, see [Evaluation order for stateful rules](https://docs.aws.amazon.com/network-firewall/latest/developerguide/suricata-rule-evaluation-order.html) in the *AWS Network Firewall Developer Guide* .
        :param pulumi.Input['FirewallPolicyStreamExceptionPolicy'] stream_exception_policy: Configures how Network Firewall processes traffic when a network connection breaks midstream. Network connections can break due to disruptions in external networks or within the firewall itself.
               
               - `DROP` - Network Firewall fails closed and drops all subsequent traffic going to the firewall. This is the default behavior.
               - `CONTINUE` - Network Firewall continues to apply rules to the subsequent traffic without context from traffic before the break. This impacts the behavior of rules that depend on this context. For example, if you have a stateful rule to `drop http` traffic, Network Firewall won't match the traffic for this rule because the service won't have the context from session initialization defining the application layer protocol as HTTP. However, this behavior is rule dependent—a TCP-layer rule using a `flow:stateless` rule would still match, as would the `aws:drop_strict` default action.
               - `REJECT` - Network Firewall fails closed and drops all subsequent traffic going to the firewall. Network Firewall also sends a TCP reject packet back to your client so that the client can immediately establish a new session. Network Firewall will have context about the new session and will apply rules to the subsequent traffic.
        """
        if rule_order is not None:
            pulumi.set(__self__, "rule_order", rule_order)
        if stream_exception_policy is not None:
            pulumi.set(__self__, "stream_exception_policy", stream_exception_policy)

    @property
    @pulumi.getter(name="ruleOrder")
    def rule_order(self) -> Optional[pulumi.Input['FirewallPolicyRuleOrder']]:
        """
        Indicates how to manage the order of stateful rule evaluation for the policy. `DEFAULT_ACTION_ORDER` is the default behavior. Stateful rules are provided to the rule engine as Suricata compatible strings, and Suricata evaluates them based on certain settings. For more information, see [Evaluation order for stateful rules](https://docs.aws.amazon.com/network-firewall/latest/developerguide/suricata-rule-evaluation-order.html) in the *AWS Network Firewall Developer Guide* .
        """
        return pulumi.get(self, "rule_order")

    @rule_order.setter
    def rule_order(self, value: Optional[pulumi.Input['FirewallPolicyRuleOrder']]):
        pulumi.set(self, "rule_order", value)

    @property
    @pulumi.getter(name="streamExceptionPolicy")
    def stream_exception_policy(self) -> Optional[pulumi.Input['FirewallPolicyStreamExceptionPolicy']]:
        """
        Configures how Network Firewall processes traffic when a network connection breaks midstream. Network connections can break due to disruptions in external networks or within the firewall itself.

        - `DROP` - Network Firewall fails closed and drops all subsequent traffic going to the firewall. This is the default behavior.
        - `CONTINUE` - Network Firewall continues to apply rules to the subsequent traffic without context from traffic before the break. This impacts the behavior of rules that depend on this context. For example, if you have a stateful rule to `drop http` traffic, Network Firewall won't match the traffic for this rule because the service won't have the context from session initialization defining the application layer protocol as HTTP. However, this behavior is rule dependent—a TCP-layer rule using a `flow:stateless` rule would still match, as would the `aws:drop_strict` default action.
        - `REJECT` - Network Firewall fails closed and drops all subsequent traffic going to the firewall. Network Firewall also sends a TCP reject packet back to your client so that the client can immediately establish a new session. Network Firewall will have context about the new session and will apply rules to the subsequent traffic.
        """
        return pulumi.get(self, "stream_exception_policy")

    @stream_exception_policy.setter
    def stream_exception_policy(self, value: Optional[pulumi.Input['FirewallPolicyStreamExceptionPolicy']]):
        pulumi.set(self, "stream_exception_policy", value)


@pulumi.input_type
class FirewallPolicyStatefulRuleGroupOverrideArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input['FirewallPolicyOverrideAction']] = None):
        """
        :param pulumi.Input['FirewallPolicyOverrideAction'] action: The action that changes the rule group from `DROP` to `ALERT` . This only applies to managed rule groups.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input['FirewallPolicyOverrideAction']]:
        """
        The action that changes the rule group from `DROP` to `ALERT` . This only applies to managed rule groups.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input['FirewallPolicyOverrideAction']]):
        pulumi.set(self, "action", value)


@pulumi.input_type
class FirewallPolicyStatefulRuleGroupReferenceArgs:
    def __init__(__self__, *,
                 resource_arn: pulumi.Input[str],
                 override: Optional[pulumi.Input['FirewallPolicyStatefulRuleGroupOverrideArgs']] = None,
                 priority: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] resource_arn: The Amazon Resource Name (ARN) of the stateful rule group.
        :param pulumi.Input['FirewallPolicyStatefulRuleGroupOverrideArgs'] override: The action that allows the policy owner to override the behavior of the rule group within a policy.
        :param pulumi.Input[int] priority: An integer setting that indicates the order in which to run the stateful rule groups in a single `FirewallPolicy` . This setting only applies to firewall policies that specify the `STRICT_ORDER` rule order in the stateful engine options settings.
               
               Network Firewall evalutes each stateful rule group against a packet starting with the group that has the lowest priority setting. You must ensure that the priority settings are unique within each policy.
               
               You can change the priority settings of your rule groups at any time. To make it easier to insert rule groups later, number them so there's a wide range in between, for example use 100, 200, and so on.
        """
        pulumi.set(__self__, "resource_arn", resource_arn)
        if override is not None:
            pulumi.set(__self__, "override", override)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the stateful rule group.
        """
        return pulumi.get(self, "resource_arn")

    @resource_arn.setter
    def resource_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_arn", value)

    @property
    @pulumi.getter
    def override(self) -> Optional[pulumi.Input['FirewallPolicyStatefulRuleGroupOverrideArgs']]:
        """
        The action that allows the policy owner to override the behavior of the rule group within a policy.
        """
        return pulumi.get(self, "override")

    @override.setter
    def override(self, value: Optional[pulumi.Input['FirewallPolicyStatefulRuleGroupOverrideArgs']]):
        pulumi.set(self, "override", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        An integer setting that indicates the order in which to run the stateful rule groups in a single `FirewallPolicy` . This setting only applies to firewall policies that specify the `STRICT_ORDER` rule order in the stateful engine options settings.

        Network Firewall evalutes each stateful rule group against a packet starting with the group that has the lowest priority setting. You must ensure that the priority settings are unique within each policy.

        You can change the priority settings of your rule groups at any time. To make it easier to insert rule groups later, number them so there's a wide range in between, for example use 100, 200, and so on.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)


@pulumi.input_type
class FirewallPolicyStatelessRuleGroupReferenceArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 resource_arn: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: An integer setting that indicates the order in which to run the stateless rule groups in a single `FirewallPolicy` . Network Firewall applies each stateless rule group to a packet starting with the group that has the lowest priority setting. You must ensure that the priority settings are unique within each policy.
        :param pulumi.Input[str] resource_arn: The Amazon Resource Name (ARN) of the stateless rule group.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "resource_arn", resource_arn)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        An integer setting that indicates the order in which to run the stateless rule groups in a single `FirewallPolicy` . Network Firewall applies each stateless rule group to a packet starting with the group that has the lowest priority setting. You must ensure that the priority settings are unique within each policy.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the stateless rule group.
        """
        return pulumi.get(self, "resource_arn")

    @resource_arn.setter
    def resource_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_arn", value)


@pulumi.input_type
class FirewallPolicyArgs:
    def __init__(__self__, *,
                 stateless_default_actions: pulumi.Input[Sequence[pulumi.Input[str]]],
                 stateless_fragment_default_actions: pulumi.Input[Sequence[pulumi.Input[str]]],
                 policy_variables: Optional[pulumi.Input['FirewallPolicyPolicyVariablesPropertiesArgs']] = None,
                 stateful_default_actions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 stateful_engine_options: Optional[pulumi.Input['FirewallPolicyStatefulEngineOptionsArgs']] = None,
                 stateful_rule_group_references: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyStatefulRuleGroupReferenceArgs']]]] = None,
                 stateless_custom_actions: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyCustomActionArgs']]]] = None,
                 stateless_rule_group_references: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyStatelessRuleGroupReferenceArgs']]]] = None,
                 tls_inspection_configuration_arn: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] stateless_default_actions: The actions to take on a packet if it doesn't match any of the stateless rules in the policy. If you want non-matching packets to be forwarded for stateful inspection, specify `aws:forward_to_sfe` .
               
               You must specify one of the standard actions: `aws:pass` , `aws:drop` , or `aws:forward_to_sfe` . In addition, you can specify custom actions that are compatible with your standard section choice.
               
               For example, you could specify `["aws:pass"]` or you could specify `["aws:pass", "customActionName"]` . For information about compatibility, see the custom action descriptions.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] stateless_fragment_default_actions: The actions to take on a fragmented packet if it doesn't match any of the stateless rules in the policy. If you want non-matching fragmented packets to be forwarded for stateful inspection, specify `aws:forward_to_sfe` .
               
               You must specify one of the standard actions: `aws:pass` , `aws:drop` , or `aws:forward_to_sfe` . In addition, you can specify custom actions that are compatible with your standard section choice.
               
               For example, you could specify `["aws:pass"]` or you could specify `["aws:pass", "customActionName"]` . For information about compatibility, see the custom action descriptions.
        :param pulumi.Input['FirewallPolicyPolicyVariablesPropertiesArgs'] policy_variables: Contains variables that you can use to override default Suricata settings in your firewall policy.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] stateful_default_actions: The default actions to take on a packet that doesn't match any stateful rules. The stateful default action is optional, and is only valid when using the strict rule order.
               
               Valid values of the stateful default action:
               
               - aws:drop_strict
               - aws:drop_established
               - aws:alert_strict
               - aws:alert_established
               
               For more information, see [Strict evaluation order](https://docs.aws.amazon.com/network-firewall/latest/developerguide/suricata-rule-evaluation-order.html#suricata-strict-rule-evaluation-order.html) in the *AWS Network Firewall Developer Guide* .
        :param pulumi.Input['FirewallPolicyStatefulEngineOptionsArgs'] stateful_engine_options: Additional options governing how Network Firewall handles stateful rules. The stateful rule groups that you use in your policy must have stateful rule options settings that are compatible with these settings.
        :param pulumi.Input[Sequence[pulumi.Input['FirewallPolicyStatefulRuleGroupReferenceArgs']]] stateful_rule_group_references: References to the stateful rule groups that are used in the policy. These define the inspection criteria in stateful rules.
        :param pulumi.Input[Sequence[pulumi.Input['FirewallPolicyCustomActionArgs']]] stateless_custom_actions: The custom action definitions that are available for use in the firewall policy's `StatelessDefaultActions` setting. You name each custom action that you define, and then you can use it by name in your default actions specifications.
        :param pulumi.Input[Sequence[pulumi.Input['FirewallPolicyStatelessRuleGroupReferenceArgs']]] stateless_rule_group_references: References to the stateless rule groups that are used in the policy. These define the matching criteria in stateless rules.
        :param pulumi.Input[str] tls_inspection_configuration_arn: The Amazon Resource Name (ARN) of the TLS inspection configuration.
        """
        pulumi.set(__self__, "stateless_default_actions", stateless_default_actions)
        pulumi.set(__self__, "stateless_fragment_default_actions", stateless_fragment_default_actions)
        if policy_variables is not None:
            pulumi.set(__self__, "policy_variables", policy_variables)
        if stateful_default_actions is not None:
            pulumi.set(__self__, "stateful_default_actions", stateful_default_actions)
        if stateful_engine_options is not None:
            pulumi.set(__self__, "stateful_engine_options", stateful_engine_options)
        if stateful_rule_group_references is not None:
            pulumi.set(__self__, "stateful_rule_group_references", stateful_rule_group_references)
        if stateless_custom_actions is not None:
            pulumi.set(__self__, "stateless_custom_actions", stateless_custom_actions)
        if stateless_rule_group_references is not None:
            pulumi.set(__self__, "stateless_rule_group_references", stateless_rule_group_references)
        if tls_inspection_configuration_arn is not None:
            pulumi.set(__self__, "tls_inspection_configuration_arn", tls_inspection_configuration_arn)

    @property
    @pulumi.getter(name="statelessDefaultActions")
    def stateless_default_actions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The actions to take on a packet if it doesn't match any of the stateless rules in the policy. If you want non-matching packets to be forwarded for stateful inspection, specify `aws:forward_to_sfe` .

        You must specify one of the standard actions: `aws:pass` , `aws:drop` , or `aws:forward_to_sfe` . In addition, you can specify custom actions that are compatible with your standard section choice.

        For example, you could specify `["aws:pass"]` or you could specify `["aws:pass", "customActionName"]` . For information about compatibility, see the custom action descriptions.
        """
        return pulumi.get(self, "stateless_default_actions")

    @stateless_default_actions.setter
    def stateless_default_actions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "stateless_default_actions", value)

    @property
    @pulumi.getter(name="statelessFragmentDefaultActions")
    def stateless_fragment_default_actions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The actions to take on a fragmented packet if it doesn't match any of the stateless rules in the policy. If you want non-matching fragmented packets to be forwarded for stateful inspection, specify `aws:forward_to_sfe` .

        You must specify one of the standard actions: `aws:pass` , `aws:drop` , or `aws:forward_to_sfe` . In addition, you can specify custom actions that are compatible with your standard section choice.

        For example, you could specify `["aws:pass"]` or you could specify `["aws:pass", "customActionName"]` . For information about compatibility, see the custom action descriptions.
        """
        return pulumi.get(self, "stateless_fragment_default_actions")

    @stateless_fragment_default_actions.setter
    def stateless_fragment_default_actions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "stateless_fragment_default_actions", value)

    @property
    @pulumi.getter(name="policyVariables")
    def policy_variables(self) -> Optional[pulumi.Input['FirewallPolicyPolicyVariablesPropertiesArgs']]:
        """
        Contains variables that you can use to override default Suricata settings in your firewall policy.
        """
        return pulumi.get(self, "policy_variables")

    @policy_variables.setter
    def policy_variables(self, value: Optional[pulumi.Input['FirewallPolicyPolicyVariablesPropertiesArgs']]):
        pulumi.set(self, "policy_variables", value)

    @property
    @pulumi.getter(name="statefulDefaultActions")
    def stateful_default_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The default actions to take on a packet that doesn't match any stateful rules. The stateful default action is optional, and is only valid when using the strict rule order.

        Valid values of the stateful default action:

        - aws:drop_strict
        - aws:drop_established
        - aws:alert_strict
        - aws:alert_established

        For more information, see [Strict evaluation order](https://docs.aws.amazon.com/network-firewall/latest/developerguide/suricata-rule-evaluation-order.html#suricata-strict-rule-evaluation-order.html) in the *AWS Network Firewall Developer Guide* .
        """
        return pulumi.get(self, "stateful_default_actions")

    @stateful_default_actions.setter
    def stateful_default_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "stateful_default_actions", value)

    @property
    @pulumi.getter(name="statefulEngineOptions")
    def stateful_engine_options(self) -> Optional[pulumi.Input['FirewallPolicyStatefulEngineOptionsArgs']]:
        """
        Additional options governing how Network Firewall handles stateful rules. The stateful rule groups that you use in your policy must have stateful rule options settings that are compatible with these settings.
        """
        return pulumi.get(self, "stateful_engine_options")

    @stateful_engine_options.setter
    def stateful_engine_options(self, value: Optional[pulumi.Input['FirewallPolicyStatefulEngineOptionsArgs']]):
        pulumi.set(self, "stateful_engine_options", value)

    @property
    @pulumi.getter(name="statefulRuleGroupReferences")
    def stateful_rule_group_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyStatefulRuleGroupReferenceArgs']]]]:
        """
        References to the stateful rule groups that are used in the policy. These define the inspection criteria in stateful rules.
        """
        return pulumi.get(self, "stateful_rule_group_references")

    @stateful_rule_group_references.setter
    def stateful_rule_group_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyStatefulRuleGroupReferenceArgs']]]]):
        pulumi.set(self, "stateful_rule_group_references", value)

    @property
    @pulumi.getter(name="statelessCustomActions")
    def stateless_custom_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyCustomActionArgs']]]]:
        """
        The custom action definitions that are available for use in the firewall policy's `StatelessDefaultActions` setting. You name each custom action that you define, and then you can use it by name in your default actions specifications.
        """
        return pulumi.get(self, "stateless_custom_actions")

    @stateless_custom_actions.setter
    def stateless_custom_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyCustomActionArgs']]]]):
        pulumi.set(self, "stateless_custom_actions", value)

    @property
    @pulumi.getter(name="statelessRuleGroupReferences")
    def stateless_rule_group_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyStatelessRuleGroupReferenceArgs']]]]:
        """
        References to the stateless rule groups that are used in the policy. These define the matching criteria in stateless rules.
        """
        return pulumi.get(self, "stateless_rule_group_references")

    @stateless_rule_group_references.setter
    def stateless_rule_group_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyStatelessRuleGroupReferenceArgs']]]]):
        pulumi.set(self, "stateless_rule_group_references", value)

    @property
    @pulumi.getter(name="tlsInspectionConfigurationArn")
    def tls_inspection_configuration_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon Resource Name (ARN) of the TLS inspection configuration.
        """
        return pulumi.get(self, "tls_inspection_configuration_arn")

    @tls_inspection_configuration_arn.setter
    def tls_inspection_configuration_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls_inspection_configuration_arn", value)


@pulumi.input_type
class FirewallSubnetMappingArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[str],
                 ip_address_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] subnet_id: A SubnetId.
        :param pulumi.Input[str] ip_address_type: A IPAddressType
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        if ip_address_type is not None:
            pulumi.set(__self__, "ip_address_type", ip_address_type)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        A SubnetId.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="ipAddressType")
    def ip_address_type(self) -> Optional[pulumi.Input[str]]:
        """
        A IPAddressType
        """
        return pulumi.get(self, "ip_address_type")

    @ip_address_type.setter
    def ip_address_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address_type", value)


@pulumi.input_type
class LoggingConfigurationLogDestinationConfigArgs:
    def __init__(__self__, *,
                 log_destination: pulumi.Input[Mapping[str, pulumi.Input[str]]],
                 log_destination_type: pulumi.Input['LoggingConfigurationLogDestinationConfigLogDestinationType'],
                 log_type: pulumi.Input['LoggingConfigurationLogDestinationConfigLogType']):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] log_destination: A key-value pair to configure the logDestinations.
        :param pulumi.Input['LoggingConfigurationLogDestinationConfigLogDestinationType'] log_destination_type: The type of storage destination to send these logs to. You can send logs to an Amazon S3 bucket, a CloudWatch log group, or a Firehose delivery stream.
        :param pulumi.Input['LoggingConfigurationLogDestinationConfigLogType'] log_type: The type of log to send. Alert logs report traffic that matches a stateful rule with an action setting that sends an alert log message. Flow logs are standard network traffic flow logs.
        """
        pulumi.set(__self__, "log_destination", log_destination)
        pulumi.set(__self__, "log_destination_type", log_destination_type)
        pulumi.set(__self__, "log_type", log_type)

    @property
    @pulumi.getter(name="logDestination")
    def log_destination(self) -> pulumi.Input[Mapping[str, pulumi.Input[str]]]:
        """
        A key-value pair to configure the logDestinations.
        """
        return pulumi.get(self, "log_destination")

    @log_destination.setter
    def log_destination(self, value: pulumi.Input[Mapping[str, pulumi.Input[str]]]):
        pulumi.set(self, "log_destination", value)

    @property
    @pulumi.getter(name="logDestinationType")
    def log_destination_type(self) -> pulumi.Input['LoggingConfigurationLogDestinationConfigLogDestinationType']:
        """
        The type of storage destination to send these logs to. You can send logs to an Amazon S3 bucket, a CloudWatch log group, or a Firehose delivery stream.
        """
        return pulumi.get(self, "log_destination_type")

    @log_destination_type.setter
    def log_destination_type(self, value: pulumi.Input['LoggingConfigurationLogDestinationConfigLogDestinationType']):
        pulumi.set(self, "log_destination_type", value)

    @property
    @pulumi.getter(name="logType")
    def log_type(self) -> pulumi.Input['LoggingConfigurationLogDestinationConfigLogType']:
        """
        The type of log to send. Alert logs report traffic that matches a stateful rule with an action setting that sends an alert log message. Flow logs are standard network traffic flow logs.
        """
        return pulumi.get(self, "log_type")

    @log_type.setter
    def log_type(self, value: pulumi.Input['LoggingConfigurationLogDestinationConfigLogType']):
        pulumi.set(self, "log_type", value)


@pulumi.input_type
class LoggingConfigurationArgs:
    def __init__(__self__, *,
                 log_destination_configs: pulumi.Input[Sequence[pulumi.Input['LoggingConfigurationLogDestinationConfigArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LoggingConfigurationLogDestinationConfigArgs']]] log_destination_configs: Defines the logging destinations for the logs for a firewall. Network Firewall generates logs for stateful rule groups.
        """
        pulumi.set(__self__, "log_destination_configs", log_destination_configs)

    @property
    @pulumi.getter(name="logDestinationConfigs")
    def log_destination_configs(self) -> pulumi.Input[Sequence[pulumi.Input['LoggingConfigurationLogDestinationConfigArgs']]]:
        """
        Defines the logging destinations for the logs for a firewall. Network Firewall generates logs for stateful rule groups.
        """
        return pulumi.get(self, "log_destination_configs")

    @log_destination_configs.setter
    def log_destination_configs(self, value: pulumi.Input[Sequence[pulumi.Input['LoggingConfigurationLogDestinationConfigArgs']]]):
        pulumi.set(self, "log_destination_configs", value)


@pulumi.input_type
class RuleGroupActionDefinitionArgs:
    def __init__(__self__, *,
                 publish_metric_action: Optional[pulumi.Input['RuleGroupPublishMetricActionArgs']] = None):
        """
        :param pulumi.Input['RuleGroupPublishMetricActionArgs'] publish_metric_action: Stateless inspection criteria that publishes the specified metrics to Amazon CloudWatch for the matching packet. This setting defines a CloudWatch dimension value to be published.
               
               You can pair this custom action with any of the standard stateless rule actions. For example, you could pair this in a rule action with the standard action that forwards the packet for stateful inspection. Then, when a packet matches the rule, Network Firewall publishes metrics for the packet and forwards it.
        """
        if publish_metric_action is not None:
            pulumi.set(__self__, "publish_metric_action", publish_metric_action)

    @property
    @pulumi.getter(name="publishMetricAction")
    def publish_metric_action(self) -> Optional[pulumi.Input['RuleGroupPublishMetricActionArgs']]:
        """
        Stateless inspection criteria that publishes the specified metrics to Amazon CloudWatch for the matching packet. This setting defines a CloudWatch dimension value to be published.

        You can pair this custom action with any of the standard stateless rule actions. For example, you could pair this in a rule action with the standard action that forwards the packet for stateful inspection. Then, when a packet matches the rule, Network Firewall publishes metrics for the packet and forwards it.
        """
        return pulumi.get(self, "publish_metric_action")

    @publish_metric_action.setter
    def publish_metric_action(self, value: Optional[pulumi.Input['RuleGroupPublishMetricActionArgs']]):
        pulumi.set(self, "publish_metric_action", value)


@pulumi.input_type
class RuleGroupAddressArgs:
    def __init__(__self__, *,
                 address_definition: pulumi.Input[str]):
        """
        :param pulumi.Input[str] address_definition: Specify an IP address or a block of IP addresses in Classless Inter-Domain Routing (CIDR) notation. Network Firewall supports all address ranges for IPv4 and IPv6.
               
               Examples:
               
               - To configure Network Firewall to inspect for the IP address 192.0.2.44, specify `192.0.2.44/32` .
               - To configure Network Firewall to inspect for IP addresses from 192.0.2.0 to 192.0.2.255, specify `192.0.2.0/24` .
               - To configure Network Firewall to inspect for the IP address 1111:0000:0000:0000:0000:0000:0000:0111, specify `1111:0000:0000:0000:0000:0000:0000:0111/128` .
               - To configure Network Firewall to inspect for IP addresses from 1111:0000:0000:0000:0000:0000:0000:0000 to 1111:0000:0000:0000:ffff:ffff:ffff:ffff, specify `1111:0000:0000:0000:0000:0000:0000:0000/64` .
               
               For more information about CIDR notation, see the Wikipedia entry [Classless Inter-Domain Routing](https://docs.aws.amazon.com/https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) .
        """
        pulumi.set(__self__, "address_definition", address_definition)

    @property
    @pulumi.getter(name="addressDefinition")
    def address_definition(self) -> pulumi.Input[str]:
        """
        Specify an IP address or a block of IP addresses in Classless Inter-Domain Routing (CIDR) notation. Network Firewall supports all address ranges for IPv4 and IPv6.

        Examples:

        - To configure Network Firewall to inspect for the IP address 192.0.2.44, specify `192.0.2.44/32` .
        - To configure Network Firewall to inspect for IP addresses from 192.0.2.0 to 192.0.2.255, specify `192.0.2.0/24` .
        - To configure Network Firewall to inspect for the IP address 1111:0000:0000:0000:0000:0000:0000:0111, specify `1111:0000:0000:0000:0000:0000:0000:0111/128` .
        - To configure Network Firewall to inspect for IP addresses from 1111:0000:0000:0000:0000:0000:0000:0000 to 1111:0000:0000:0000:ffff:ffff:ffff:ffff, specify `1111:0000:0000:0000:0000:0000:0000:0000/64` .

        For more information about CIDR notation, see the Wikipedia entry [Classless Inter-Domain Routing](https://docs.aws.amazon.com/https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) .
        """
        return pulumi.get(self, "address_definition")

    @address_definition.setter
    def address_definition(self, value: pulumi.Input[str]):
        pulumi.set(self, "address_definition", value)


@pulumi.input_type
class RuleGroupCustomActionArgs:
    def __init__(__self__, *,
                 action_definition: pulumi.Input['RuleGroupActionDefinitionArgs'],
                 action_name: pulumi.Input[str]):
        """
        :param pulumi.Input['RuleGroupActionDefinitionArgs'] action_definition: The custom action associated with the action name.
        :param pulumi.Input[str] action_name: The descriptive name of the custom action. You can't change the name of a custom action after you create it.
        """
        pulumi.set(__self__, "action_definition", action_definition)
        pulumi.set(__self__, "action_name", action_name)

    @property
    @pulumi.getter(name="actionDefinition")
    def action_definition(self) -> pulumi.Input['RuleGroupActionDefinitionArgs']:
        """
        The custom action associated with the action name.
        """
        return pulumi.get(self, "action_definition")

    @action_definition.setter
    def action_definition(self, value: pulumi.Input['RuleGroupActionDefinitionArgs']):
        pulumi.set(self, "action_definition", value)

    @property
    @pulumi.getter(name="actionName")
    def action_name(self) -> pulumi.Input[str]:
        """
        The descriptive name of the custom action. You can't change the name of a custom action after you create it.
        """
        return pulumi.get(self, "action_name")

    @action_name.setter
    def action_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "action_name", value)


@pulumi.input_type
class RuleGroupDimensionArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] value: The value to use in the custom metric dimension.
        """
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value to use in the custom metric dimension.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class RuleGroupHeaderArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str],
                 destination_port: pulumi.Input[str],
                 direction: pulumi.Input['RuleGroupHeaderDirection'],
                 protocol: pulumi.Input['RuleGroupHeaderProtocol'],
                 source: pulumi.Input[str],
                 source_port: pulumi.Input[str]):
        """
        :param pulumi.Input[str] destination: The destination IP address or address range to inspect for, in CIDR notation. To match with any address, specify `ANY` .
               
               Specify an IP address or a block of IP addresses in Classless Inter-Domain Routing (CIDR) notation. Network Firewall supports all address ranges for IPv4 and IPv6.
               
               Examples:
               
               - To configure Network Firewall to inspect for the IP address 192.0.2.44, specify `192.0.2.44/32` .
               - To configure Network Firewall to inspect for IP addresses from 192.0.2.0 to 192.0.2.255, specify `192.0.2.0/24` .
               - To configure Network Firewall to inspect for the IP address 1111:0000:0000:0000:0000:0000:0000:0111, specify `1111:0000:0000:0000:0000:0000:0000:0111/128` .
               - To configure Network Firewall to inspect for IP addresses from 1111:0000:0000:0000:0000:0000:0000:0000 to 1111:0000:0000:0000:ffff:ffff:ffff:ffff, specify `1111:0000:0000:0000:0000:0000:0000:0000/64` .
               
               For more information about CIDR notation, see the Wikipedia entry [Classless Inter-Domain Routing](https://docs.aws.amazon.com/https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) .
        :param pulumi.Input[str] destination_port: The destination port to inspect for. You can specify an individual port, for example `1994` and you can specify a port range, for example `1990:1994` . To match with any port, specify `ANY` .
        :param pulumi.Input['RuleGroupHeaderDirection'] direction: The direction of traffic flow to inspect. If set to `ANY` , the inspection matches bidirectional traffic, both from the source to the destination and from the destination to the source. If set to `FORWARD` , the inspection only matches traffic going from the source to the destination.
        :param pulumi.Input['RuleGroupHeaderProtocol'] protocol: The protocol to inspect for. To specify all, you can use `IP` , because all traffic on AWS and on the internet is IP.
        :param pulumi.Input[str] source: The source IP address or address range to inspect for, in CIDR notation. To match with any address, specify `ANY` .
               
               Specify an IP address or a block of IP addresses in Classless Inter-Domain Routing (CIDR) notation. Network Firewall supports all address ranges for IPv4 and IPv6.
               
               Examples:
               
               - To configure Network Firewall to inspect for the IP address 192.0.2.44, specify `192.0.2.44/32` .
               - To configure Network Firewall to inspect for IP addresses from 192.0.2.0 to 192.0.2.255, specify `192.0.2.0/24` .
               - To configure Network Firewall to inspect for the IP address 1111:0000:0000:0000:0000:0000:0000:0111, specify `1111:0000:0000:0000:0000:0000:0000:0111/128` .
               - To configure Network Firewall to inspect for IP addresses from 1111:0000:0000:0000:0000:0000:0000:0000 to 1111:0000:0000:0000:ffff:ffff:ffff:ffff, specify `1111:0000:0000:0000:0000:0000:0000:0000/64` .
               
               For more information about CIDR notation, see the Wikipedia entry [Classless Inter-Domain Routing](https://docs.aws.amazon.com/https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) .
        :param pulumi.Input[str] source_port: The source port to inspect for. You can specify an individual port, for example `1994` and you can specify a port range, for example `1990:1994` . To match with any port, specify `ANY` .
        """
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "destination_port", destination_port)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "source_port", source_port)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        """
        The destination IP address or address range to inspect for, in CIDR notation. To match with any address, specify `ANY` .

        Specify an IP address or a block of IP addresses in Classless Inter-Domain Routing (CIDR) notation. Network Firewall supports all address ranges for IPv4 and IPv6.

        Examples:

        - To configure Network Firewall to inspect for the IP address 192.0.2.44, specify `192.0.2.44/32` .
        - To configure Network Firewall to inspect for IP addresses from 192.0.2.0 to 192.0.2.255, specify `192.0.2.0/24` .
        - To configure Network Firewall to inspect for the IP address 1111:0000:0000:0000:0000:0000:0000:0111, specify `1111:0000:0000:0000:0000:0000:0000:0111/128` .
        - To configure Network Firewall to inspect for IP addresses from 1111:0000:0000:0000:0000:0000:0000:0000 to 1111:0000:0000:0000:ffff:ffff:ffff:ffff, specify `1111:0000:0000:0000:0000:0000:0000:0000/64` .

        For more information about CIDR notation, see the Wikipedia entry [Classless Inter-Domain Routing](https://docs.aws.amazon.com/https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) .
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="destinationPort")
    def destination_port(self) -> pulumi.Input[str]:
        """
        The destination port to inspect for. You can specify an individual port, for example `1994` and you can specify a port range, for example `1990:1994` . To match with any port, specify `ANY` .
        """
        return pulumi.get(self, "destination_port")

    @destination_port.setter
    def destination_port(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination_port", value)

    @property
    @pulumi.getter
    def direction(self) -> pulumi.Input['RuleGroupHeaderDirection']:
        """
        The direction of traffic flow to inspect. If set to `ANY` , the inspection matches bidirectional traffic, both from the source to the destination and from the destination to the source. If set to `FORWARD` , the inspection only matches traffic going from the source to the destination.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: pulumi.Input['RuleGroupHeaderDirection']):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input['RuleGroupHeaderProtocol']:
        """
        The protocol to inspect for. To specify all, you can use `IP` , because all traffic on AWS and on the internet is IP.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input['RuleGroupHeaderProtocol']):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[str]:
        """
        The source IP address or address range to inspect for, in CIDR notation. To match with any address, specify `ANY` .

        Specify an IP address or a block of IP addresses in Classless Inter-Domain Routing (CIDR) notation. Network Firewall supports all address ranges for IPv4 and IPv6.

        Examples:

        - To configure Network Firewall to inspect for the IP address 192.0.2.44, specify `192.0.2.44/32` .
        - To configure Network Firewall to inspect for IP addresses from 192.0.2.0 to 192.0.2.255, specify `192.0.2.0/24` .
        - To configure Network Firewall to inspect for the IP address 1111:0000:0000:0000:0000:0000:0000:0111, specify `1111:0000:0000:0000:0000:0000:0000:0111/128` .
        - To configure Network Firewall to inspect for IP addresses from 1111:0000:0000:0000:0000:0000:0000:0000 to 1111:0000:0000:0000:ffff:ffff:ffff:ffff, specify `1111:0000:0000:0000:0000:0000:0000:0000/64` .

        For more information about CIDR notation, see the Wikipedia entry [Classless Inter-Domain Routing](https://docs.aws.amazon.com/https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) .
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="sourcePort")
    def source_port(self) -> pulumi.Input[str]:
        """
        The source port to inspect for. You can specify an individual port, for example `1994` and you can specify a port range, for example `1990:1994` . To match with any port, specify `ANY` .
        """
        return pulumi.get(self, "source_port")

    @source_port.setter
    def source_port(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_port", value)


@pulumi.input_type
class RuleGroupIpSetReferenceArgs:
    def __init__(__self__, *,
                 reference_arn: Optional[pulumi.Input[str]] = None):
        if reference_arn is not None:
            pulumi.set(__self__, "reference_arn", reference_arn)

    @property
    @pulumi.getter(name="referenceArn")
    def reference_arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "reference_arn")

    @reference_arn.setter
    def reference_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reference_arn", value)


@pulumi.input_type
class RuleGroupIpSetArgs:
    def __init__(__self__, *,
                 definition: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if definition is not None:
            pulumi.set(__self__, "definition", definition)

    @property
    @pulumi.getter
    def definition(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "definition", value)


@pulumi.input_type
class RuleGroupMatchAttributesArgs:
    def __init__(__self__, *,
                 destination_ports: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupPortRangeArgs']]]] = None,
                 destinations: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupAddressArgs']]]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 source_ports: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupPortRangeArgs']]]] = None,
                 sources: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupAddressArgs']]]] = None,
                 tcp_flags: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupTcpFlagFieldArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupPortRangeArgs']]] destination_ports: The destination ports to inspect for. If not specified, this matches with any destination port. This setting is only used for protocols 6 (TCP) and 17 (UDP).
               
               You can specify individual ports, for example `1994` and you can specify port ranges, for example `1990:1994` .
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupAddressArgs']]] destinations: The destination IP addresses and address ranges to inspect for, in CIDR notation. If not specified, this matches with any destination address.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] protocols: The protocols to inspect for, specified using each protocol's assigned internet protocol number (IANA). If not specified, this matches with any protocol.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupPortRangeArgs']]] source_ports: The source ports to inspect for. If not specified, this matches with any source port. This setting is only used for protocols 6 (TCP) and 17 (UDP).
               
               You can specify individual ports, for example `1994` and you can specify port ranges, for example `1990:1994` .
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupAddressArgs']]] sources: The source IP addresses and address ranges to inspect for, in CIDR notation. If not specified, this matches with any source address.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupTcpFlagFieldArgs']]] tcp_flags: The TCP flags and masks to inspect for. If not specified, this matches with any settings. This setting is only used for protocol 6 (TCP).
        """
        if destination_ports is not None:
            pulumi.set(__self__, "destination_ports", destination_ports)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if source_ports is not None:
            pulumi.set(__self__, "source_ports", source_ports)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)
        if tcp_flags is not None:
            pulumi.set(__self__, "tcp_flags", tcp_flags)

    @property
    @pulumi.getter(name="destinationPorts")
    def destination_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupPortRangeArgs']]]]:
        """
        The destination ports to inspect for. If not specified, this matches with any destination port. This setting is only used for protocols 6 (TCP) and 17 (UDP).

        You can specify individual ports, for example `1994` and you can specify port ranges, for example `1990:1994` .
        """
        return pulumi.get(self, "destination_ports")

    @destination_ports.setter
    def destination_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupPortRangeArgs']]]]):
        pulumi.set(self, "destination_ports", value)

    @property
    @pulumi.getter
    def destinations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupAddressArgs']]]]:
        """
        The destination IP addresses and address ranges to inspect for, in CIDR notation. If not specified, this matches with any destination address.
        """
        return pulumi.get(self, "destinations")

    @destinations.setter
    def destinations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupAddressArgs']]]]):
        pulumi.set(self, "destinations", value)

    @property
    @pulumi.getter
    def protocols(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        The protocols to inspect for, specified using each protocol's assigned internet protocol number (IANA). If not specified, this matches with any protocol.
        """
        return pulumi.get(self, "protocols")

    @protocols.setter
    def protocols(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "protocols", value)

    @property
    @pulumi.getter(name="sourcePorts")
    def source_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupPortRangeArgs']]]]:
        """
        The source ports to inspect for. If not specified, this matches with any source port. This setting is only used for protocols 6 (TCP) and 17 (UDP).

        You can specify individual ports, for example `1994` and you can specify port ranges, for example `1990:1994` .
        """
        return pulumi.get(self, "source_ports")

    @source_ports.setter
    def source_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupPortRangeArgs']]]]):
        pulumi.set(self, "source_ports", value)

    @property
    @pulumi.getter
    def sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupAddressArgs']]]]:
        """
        The source IP addresses and address ranges to inspect for, in CIDR notation. If not specified, this matches with any source address.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupAddressArgs']]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter(name="tcpFlags")
    def tcp_flags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupTcpFlagFieldArgs']]]]:
        """
        The TCP flags and masks to inspect for. If not specified, this matches with any settings. This setting is only used for protocol 6 (TCP).
        """
        return pulumi.get(self, "tcp_flags")

    @tcp_flags.setter
    def tcp_flags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupTcpFlagFieldArgs']]]]):
        pulumi.set(self, "tcp_flags", value)


@pulumi.input_type
class RuleGroupPortRangeArgs:
    def __init__(__self__, *,
                 from_port: pulumi.Input[int],
                 to_port: pulumi.Input[int]):
        """
        :param pulumi.Input[int] from_port: The lower limit of the port range. This must be less than or equal to the `ToPort` specification.
        :param pulumi.Input[int] to_port: The upper limit of the port range. This must be greater than or equal to the `FromPort` specification.
        """
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "to_port", to_port)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> pulumi.Input[int]:
        """
        The lower limit of the port range. This must be less than or equal to the `ToPort` specification.
        """
        return pulumi.get(self, "from_port")

    @from_port.setter
    def from_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "from_port", value)

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> pulumi.Input[int]:
        """
        The upper limit of the port range. This must be greater than or equal to the `FromPort` specification.
        """
        return pulumi.get(self, "to_port")

    @to_port.setter
    def to_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "to_port", value)


@pulumi.input_type
class RuleGroupPortSetArgs:
    def __init__(__self__, *,
                 definition: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if definition is not None:
            pulumi.set(__self__, "definition", definition)

    @property
    @pulumi.getter
    def definition(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "definition", value)


@pulumi.input_type
class RuleGroupPublishMetricActionArgs:
    def __init__(__self__, *,
                 dimensions: pulumi.Input[Sequence[pulumi.Input['RuleGroupDimensionArgs']]]):
        pulumi.set(__self__, "dimensions", dimensions)

    @property
    @pulumi.getter
    def dimensions(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupDimensionArgs']]]:
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupDimensionArgs']]]):
        pulumi.set(self, "dimensions", value)


@pulumi.input_type
class RuleGroupReferenceSetsArgs:
    def __init__(__self__, *,
                 ip_set_references: Optional[pulumi.Input[Mapping[str, pulumi.Input['RuleGroupIpSetReferenceArgs']]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input['RuleGroupIpSetReferenceArgs']]] ip_set_references: The IP set references to use in the stateful rule group.
        """
        if ip_set_references is not None:
            pulumi.set(__self__, "ip_set_references", ip_set_references)

    @property
    @pulumi.getter(name="ipSetReferences")
    def ip_set_references(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['RuleGroupIpSetReferenceArgs']]]]:
        """
        The IP set references to use in the stateful rule group.
        """
        return pulumi.get(self, "ip_set_references")

    @ip_set_references.setter
    def ip_set_references(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['RuleGroupIpSetReferenceArgs']]]]):
        pulumi.set(self, "ip_set_references", value)


@pulumi.input_type
class RuleGroupRuleDefinitionArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input[Sequence[pulumi.Input[str]]],
                 match_attributes: pulumi.Input['RuleGroupMatchAttributesArgs']):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] actions: The actions to take on a packet that matches one of the stateless rule definition's match attributes. You must specify a standard action and you can add custom actions.
               
               > Network Firewall only forwards a packet for stateful rule inspection if you specify `aws:forward_to_sfe` for a rule that the packet matches, or if the packet doesn't match any stateless rule and you specify `aws:forward_to_sfe` for the `StatelessDefaultActions` setting for the `FirewallPolicy` . 
               
               For every rule, you must specify exactly one of the following standard actions.
               
               - *aws:pass* - Discontinues all inspection of the packet and permits it to go to its intended destination.
               - *aws:drop* - Discontinues all inspection of the packet and blocks it from going to its intended destination.
               - *aws:forward_to_sfe* - Discontinues stateless inspection of the packet and forwards it to the stateful rule engine for inspection.
               
               Additionally, you can specify a custom action. To do this, you define a custom action by name and type, then provide the name you've assigned to the action in this `Actions` setting.
               
               To provide more than one action in this setting, separate the settings with a comma. For example, if you have a publish metrics custom action that you've named `MyMetricsAction` , then you could specify the standard action `aws:pass` combined with the custom action using `["aws:pass", "MyMetricsAction"]` .
        :param pulumi.Input['RuleGroupMatchAttributesArgs'] match_attributes: Criteria for Network Firewall to use to inspect an individual packet in stateless rule inspection. Each match attributes set can include one or more items such as IP address, CIDR range, port number, protocol, and TCP flags.
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "match_attributes", match_attributes)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The actions to take on a packet that matches one of the stateless rule definition's match attributes. You must specify a standard action and you can add custom actions.

        > Network Firewall only forwards a packet for stateful rule inspection if you specify `aws:forward_to_sfe` for a rule that the packet matches, or if the packet doesn't match any stateless rule and you specify `aws:forward_to_sfe` for the `StatelessDefaultActions` setting for the `FirewallPolicy` . 

        For every rule, you must specify exactly one of the following standard actions.

        - *aws:pass* - Discontinues all inspection of the packet and permits it to go to its intended destination.
        - *aws:drop* - Discontinues all inspection of the packet and blocks it from going to its intended destination.
        - *aws:forward_to_sfe* - Discontinues stateless inspection of the packet and forwards it to the stateful rule engine for inspection.

        Additionally, you can specify a custom action. To do this, you define a custom action by name and type, then provide the name you've assigned to the action in this `Actions` setting.

        To provide more than one action in this setting, separate the settings with a comma. For example, if you have a publish metrics custom action that you've named `MyMetricsAction` , then you could specify the standard action `aws:pass` combined with the custom action using `["aws:pass", "MyMetricsAction"]` .
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="matchAttributes")
    def match_attributes(self) -> pulumi.Input['RuleGroupMatchAttributesArgs']:
        """
        Criteria for Network Firewall to use to inspect an individual packet in stateless rule inspection. Each match attributes set can include one or more items such as IP address, CIDR range, port number, protocol, and TCP flags.
        """
        return pulumi.get(self, "match_attributes")

    @match_attributes.setter
    def match_attributes(self, value: pulumi.Input['RuleGroupMatchAttributesArgs']):
        pulumi.set(self, "match_attributes", value)


@pulumi.input_type
class RuleGroupRuleOptionArgs:
    def __init__(__self__, *,
                 keyword: pulumi.Input[str],
                 settings: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] keyword: The Suricata rule option keywords. For Network Firewall , the keyword signature ID (sid) is required in the format `sid:112233` . The sid must be unique within the rule group. For information about Suricata rule option keywords, see [Rule options](https://docs.aws.amazon.com/https://suricata.readthedocs.io/en/suricata-6.0.9/rules/intro.html#rule-options) .
        :param pulumi.Input[Sequence[pulumi.Input[str]]] settings: The Suricata rule option settings. Settings have zero or more values, and the number of possible settings and required settings depends on the keyword. The format for Settings is `number` . For information about Suricata rule option settings, see [Rule options](https://docs.aws.amazon.com/https://suricata.readthedocs.io/en/suricata-6.0.9/rules/intro.html#rule-options) .
        """
        pulumi.set(__self__, "keyword", keyword)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @property
    @pulumi.getter
    def keyword(self) -> pulumi.Input[str]:
        """
        The Suricata rule option keywords. For Network Firewall , the keyword signature ID (sid) is required in the format `sid:112233` . The sid must be unique within the rule group. For information about Suricata rule option keywords, see [Rule options](https://docs.aws.amazon.com/https://suricata.readthedocs.io/en/suricata-6.0.9/rules/intro.html#rule-options) .
        """
        return pulumi.get(self, "keyword")

    @keyword.setter
    def keyword(self, value: pulumi.Input[str]):
        pulumi.set(self, "keyword", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The Suricata rule option settings. Settings have zero or more values, and the number of possible settings and required settings depends on the keyword. The format for Settings is `number` . For information about Suricata rule option settings, see [Rule options](https://docs.aws.amazon.com/https://suricata.readthedocs.io/en/suricata-6.0.9/rules/intro.html#rule-options) .
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)


@pulumi.input_type
class RuleGroupRuleVariablesArgs:
    def __init__(__self__, *,
                 ip_sets: Optional[pulumi.Input[Mapping[str, pulumi.Input['RuleGroupIpSetArgs']]]] = None,
                 port_sets: Optional[pulumi.Input[Mapping[str, pulumi.Input['RuleGroupPortSetArgs']]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input['RuleGroupIpSetArgs']]] ip_sets: A list of IP addresses and address ranges, in CIDR notation.
        :param pulumi.Input[Mapping[str, pulumi.Input['RuleGroupPortSetArgs']]] port_sets: A list of port ranges.
        """
        if ip_sets is not None:
            pulumi.set(__self__, "ip_sets", ip_sets)
        if port_sets is not None:
            pulumi.set(__self__, "port_sets", port_sets)

    @property
    @pulumi.getter(name="ipSets")
    def ip_sets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['RuleGroupIpSetArgs']]]]:
        """
        A list of IP addresses and address ranges, in CIDR notation.
        """
        return pulumi.get(self, "ip_sets")

    @ip_sets.setter
    def ip_sets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['RuleGroupIpSetArgs']]]]):
        pulumi.set(self, "ip_sets", value)

    @property
    @pulumi.getter(name="portSets")
    def port_sets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['RuleGroupPortSetArgs']]]]:
        """
        A list of port ranges.
        """
        return pulumi.get(self, "port_sets")

    @port_sets.setter
    def port_sets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['RuleGroupPortSetArgs']]]]):
        pulumi.set(self, "port_sets", value)


@pulumi.input_type
class RuleGroupRulesSourceListArgs:
    def __init__(__self__, *,
                 generated_rules_type: pulumi.Input['RuleGroupGeneratedRulesType'],
                 target_types: pulumi.Input[Sequence[pulumi.Input['RuleGroupTargetType']]],
                 targets: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input['RuleGroupGeneratedRulesType'] generated_rules_type: Whether you want to allow or deny access to the domains in your target list.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupTargetType']]] target_types: The types of targets to inspect for. Valid values are `TLS_SNI` and `HTTP_HOST` .
        :param pulumi.Input[Sequence[pulumi.Input[str]]] targets: The domains that you want to inspect for in your traffic flows. Valid domain specifications are the following:
               
               - Explicit names. For example, `abc.example.com` matches only the domain `abc.example.com` .
               - Names that use a domain wildcard, which you indicate with an initial ' `.` '. For example, `.example.com` matches `example.com` and matches all subdomains of `example.com` , such as `abc.example.com` and `www.example.com` .
        """
        pulumi.set(__self__, "generated_rules_type", generated_rules_type)
        pulumi.set(__self__, "target_types", target_types)
        pulumi.set(__self__, "targets", targets)

    @property
    @pulumi.getter(name="generatedRulesType")
    def generated_rules_type(self) -> pulumi.Input['RuleGroupGeneratedRulesType']:
        """
        Whether you want to allow or deny access to the domains in your target list.
        """
        return pulumi.get(self, "generated_rules_type")

    @generated_rules_type.setter
    def generated_rules_type(self, value: pulumi.Input['RuleGroupGeneratedRulesType']):
        pulumi.set(self, "generated_rules_type", value)

    @property
    @pulumi.getter(name="targetTypes")
    def target_types(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupTargetType']]]:
        """
        The types of targets to inspect for. Valid values are `TLS_SNI` and `HTTP_HOST` .
        """
        return pulumi.get(self, "target_types")

    @target_types.setter
    def target_types(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupTargetType']]]):
        pulumi.set(self, "target_types", value)

    @property
    @pulumi.getter
    def targets(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The domains that you want to inspect for in your traffic flows. Valid domain specifications are the following:

        - Explicit names. For example, `abc.example.com` matches only the domain `abc.example.com` .
        - Names that use a domain wildcard, which you indicate with an initial ' `.` '. For example, `.example.com` matches `example.com` and matches all subdomains of `example.com` , such as `abc.example.com` and `www.example.com` .
        """
        return pulumi.get(self, "targets")

    @targets.setter
    def targets(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "targets", value)


@pulumi.input_type
class RuleGroupRulesSourceArgs:
    def __init__(__self__, *,
                 rules_source_list: Optional[pulumi.Input['RuleGroupRulesSourceListArgs']] = None,
                 rules_string: Optional[pulumi.Input[str]] = None,
                 stateful_rules: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupStatefulRuleArgs']]]] = None,
                 stateless_rules_and_custom_actions: Optional[pulumi.Input['RuleGroupStatelessRulesAndCustomActionsArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRulesSourceListArgs'] rules_source_list: Stateful inspection criteria for a domain list rule group.
        :param pulumi.Input[str] rules_string: Stateful inspection criteria, provided in Suricata compatible rules. Suricata is an open-source threat detection framework that includes a standard rule-based language for network traffic inspection.
               
               These rules contain the inspection criteria and the action to take for traffic that matches the criteria, so this type of rule group doesn't have a separate action setting.
               
               > You can't use the `priority` keyword if the `RuleOrder` option in `StatefulRuleOptions` is set to `STRICT_ORDER` .
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupStatefulRuleArgs']]] stateful_rules: An array of individual stateful rules inspection criteria to be used together in a stateful rule group. Use this option to specify simple Suricata rules with protocol, source and destination, ports, direction, and rule options. For information about the Suricata `Rules` format, see [Rules Format](https://docs.aws.amazon.com/https://suricata.readthedocs.io/en/suricata-6.0.9/rules/intro.html) .
        :param pulumi.Input['RuleGroupStatelessRulesAndCustomActionsArgs'] stateless_rules_and_custom_actions: Stateless inspection criteria to be used in a stateless rule group.
        """
        if rules_source_list is not None:
            pulumi.set(__self__, "rules_source_list", rules_source_list)
        if rules_string is not None:
            pulumi.set(__self__, "rules_string", rules_string)
        if stateful_rules is not None:
            pulumi.set(__self__, "stateful_rules", stateful_rules)
        if stateless_rules_and_custom_actions is not None:
            pulumi.set(__self__, "stateless_rules_and_custom_actions", stateless_rules_and_custom_actions)

    @property
    @pulumi.getter(name="rulesSourceList")
    def rules_source_list(self) -> Optional[pulumi.Input['RuleGroupRulesSourceListArgs']]:
        """
        Stateful inspection criteria for a domain list rule group.
        """
        return pulumi.get(self, "rules_source_list")

    @rules_source_list.setter
    def rules_source_list(self, value: Optional[pulumi.Input['RuleGroupRulesSourceListArgs']]):
        pulumi.set(self, "rules_source_list", value)

    @property
    @pulumi.getter(name="rulesString")
    def rules_string(self) -> Optional[pulumi.Input[str]]:
        """
        Stateful inspection criteria, provided in Suricata compatible rules. Suricata is an open-source threat detection framework that includes a standard rule-based language for network traffic inspection.

        These rules contain the inspection criteria and the action to take for traffic that matches the criteria, so this type of rule group doesn't have a separate action setting.

        > You can't use the `priority` keyword if the `RuleOrder` option in `StatefulRuleOptions` is set to `STRICT_ORDER` .
        """
        return pulumi.get(self, "rules_string")

    @rules_string.setter
    def rules_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rules_string", value)

    @property
    @pulumi.getter(name="statefulRules")
    def stateful_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupStatefulRuleArgs']]]]:
        """
        An array of individual stateful rules inspection criteria to be used together in a stateful rule group. Use this option to specify simple Suricata rules with protocol, source and destination, ports, direction, and rule options. For information about the Suricata `Rules` format, see [Rules Format](https://docs.aws.amazon.com/https://suricata.readthedocs.io/en/suricata-6.0.9/rules/intro.html) .
        """
        return pulumi.get(self, "stateful_rules")

    @stateful_rules.setter
    def stateful_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupStatefulRuleArgs']]]]):
        pulumi.set(self, "stateful_rules", value)

    @property
    @pulumi.getter(name="statelessRulesAndCustomActions")
    def stateless_rules_and_custom_actions(self) -> Optional[pulumi.Input['RuleGroupStatelessRulesAndCustomActionsArgs']]:
        """
        Stateless inspection criteria to be used in a stateless rule group.
        """
        return pulumi.get(self, "stateless_rules_and_custom_actions")

    @stateless_rules_and_custom_actions.setter
    def stateless_rules_and_custom_actions(self, value: Optional[pulumi.Input['RuleGroupStatelessRulesAndCustomActionsArgs']]):
        pulumi.set(self, "stateless_rules_and_custom_actions", value)


@pulumi.input_type
class RuleGroupStatefulRuleOptionsArgs:
    def __init__(__self__, *,
                 rule_order: Optional[pulumi.Input['RuleGroupRuleOrder']] = None):
        """
        :param pulumi.Input['RuleGroupRuleOrder'] rule_order: Indicates how to manage the order of the rule evaluation for the rule group. `DEFAULT_ACTION_ORDER` is the default behavior. Stateful rules are provided to the rule engine as Suricata compatible strings, and Suricata evaluates them based on certain settings. For more information, see [Evaluation order for stateful rules](https://docs.aws.amazon.com/network-firewall/latest/developerguide/suricata-rule-evaluation-order.html) in the *AWS Network Firewall Developer Guide* .
        """
        if rule_order is not None:
            pulumi.set(__self__, "rule_order", rule_order)

    @property
    @pulumi.getter(name="ruleOrder")
    def rule_order(self) -> Optional[pulumi.Input['RuleGroupRuleOrder']]:
        """
        Indicates how to manage the order of the rule evaluation for the rule group. `DEFAULT_ACTION_ORDER` is the default behavior. Stateful rules are provided to the rule engine as Suricata compatible strings, and Suricata evaluates them based on certain settings. For more information, see [Evaluation order for stateful rules](https://docs.aws.amazon.com/network-firewall/latest/developerguide/suricata-rule-evaluation-order.html) in the *AWS Network Firewall Developer Guide* .
        """
        return pulumi.get(self, "rule_order")

    @rule_order.setter
    def rule_order(self, value: Optional[pulumi.Input['RuleGroupRuleOrder']]):
        pulumi.set(self, "rule_order", value)


@pulumi.input_type
class RuleGroupStatefulRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input['RuleGroupStatefulRuleAction'],
                 header: pulumi.Input['RuleGroupHeaderArgs'],
                 rule_options: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleOptionArgs']]]):
        """
        :param pulumi.Input['RuleGroupStatefulRuleAction'] action: Defines what Network Firewall should do with the packets in a traffic flow when the flow matches the stateful rule criteria. For all actions, Network Firewall performs the specified action and discontinues stateful inspection of the traffic flow.
               
               The actions for a stateful rule are defined as follows:
               
               - *PASS* - Permits the packets to go to the intended destination.
               - *DROP* - Blocks the packets from going to the intended destination and sends an alert log message, if alert logging is configured in the `Firewall` `LoggingConfiguration` .
               - *REJECT* - Drops traffic that matches the conditions of the stateful rule and sends a TCP reset packet back to sender of the packet. A TCP reset packet is a packet with no payload and a `RST` bit contained in the TCP header flags. `REJECT` is available only for TCP traffic.
               - *ALERT* - Permits the packets to go to the intended destination and sends an alert log message, if alert logging is configured in the `Firewall` `LoggingConfiguration` .
               
               You can use this action to test a rule that you intend to use to drop traffic. You can enable the rule with `ALERT` action, verify in the logs that the rule is filtering as you want, then change the action to `DROP` .
               - *REJECT* - Drops TCP traffic that matches the conditions of the stateful rule, and sends a TCP reset packet back to sender of the packet. A TCP reset packet is a packet with no payload and a `RST` bit contained in the TCP header flags. Also sends an alert log mesage if alert logging is configured in the `Firewall` `LoggingConfiguration` .
               
               `REJECT` isn't currently available for use with IMAP and FTP protocols.
        :param pulumi.Input['RuleGroupHeaderArgs'] header: The stateful inspection criteria for this rule, used to inspect traffic flows.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleOptionArgs']]] rule_options: Additional settings for a stateful rule, provided as keywords and settings.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "rule_options", rule_options)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input['RuleGroupStatefulRuleAction']:
        """
        Defines what Network Firewall should do with the packets in a traffic flow when the flow matches the stateful rule criteria. For all actions, Network Firewall performs the specified action and discontinues stateful inspection of the traffic flow.

        The actions for a stateful rule are defined as follows:

        - *PASS* - Permits the packets to go to the intended destination.
        - *DROP* - Blocks the packets from going to the intended destination and sends an alert log message, if alert logging is configured in the `Firewall` `LoggingConfiguration` .
        - *REJECT* - Drops traffic that matches the conditions of the stateful rule and sends a TCP reset packet back to sender of the packet. A TCP reset packet is a packet with no payload and a `RST` bit contained in the TCP header flags. `REJECT` is available only for TCP traffic.
        - *ALERT* - Permits the packets to go to the intended destination and sends an alert log message, if alert logging is configured in the `Firewall` `LoggingConfiguration` .

        You can use this action to test a rule that you intend to use to drop traffic. You can enable the rule with `ALERT` action, verify in the logs that the rule is filtering as you want, then change the action to `DROP` .
        - *REJECT* - Drops TCP traffic that matches the conditions of the stateful rule, and sends a TCP reset packet back to sender of the packet. A TCP reset packet is a packet with no payload and a `RST` bit contained in the TCP header flags. Also sends an alert log mesage if alert logging is configured in the `Firewall` `LoggingConfiguration` .

        `REJECT` isn't currently available for use with IMAP and FTP protocols.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input['RuleGroupStatefulRuleAction']):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def header(self) -> pulumi.Input['RuleGroupHeaderArgs']:
        """
        The stateful inspection criteria for this rule, used to inspect traffic flows.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: pulumi.Input['RuleGroupHeaderArgs']):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter(name="ruleOptions")
    def rule_options(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleOptionArgs']]]:
        """
        Additional settings for a stateful rule, provided as keywords and settings.
        """
        return pulumi.get(self, "rule_options")

    @rule_options.setter
    def rule_options(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleOptionArgs']]]):
        pulumi.set(self, "rule_options", value)


@pulumi.input_type
class RuleGroupStatelessRulesAndCustomActionsArgs:
    def __init__(__self__, *,
                 stateless_rules: pulumi.Input[Sequence[pulumi.Input['RuleGroupStatelessRuleArgs']]],
                 custom_actions: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupCustomActionArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupStatelessRuleArgs']]] stateless_rules: Defines the set of stateless rules for use in a stateless rule group.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupCustomActionArgs']]] custom_actions: Defines an array of individual custom action definitions that are available for use by the stateless rules in this `StatelessRulesAndCustomActions` specification. You name each custom action that you define, and then you can use it by name in your stateless rule `RuleGroup.RuleDefinition` `Actions` specification.
        """
        pulumi.set(__self__, "stateless_rules", stateless_rules)
        if custom_actions is not None:
            pulumi.set(__self__, "custom_actions", custom_actions)

    @property
    @pulumi.getter(name="statelessRules")
    def stateless_rules(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupStatelessRuleArgs']]]:
        """
        Defines the set of stateless rules for use in a stateless rule group.
        """
        return pulumi.get(self, "stateless_rules")

    @stateless_rules.setter
    def stateless_rules(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupStatelessRuleArgs']]]):
        pulumi.set(self, "stateless_rules", value)

    @property
    @pulumi.getter(name="customActions")
    def custom_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupCustomActionArgs']]]]:
        """
        Defines an array of individual custom action definitions that are available for use by the stateless rules in this `StatelessRulesAndCustomActions` specification. You name each custom action that you define, and then you can use it by name in your stateless rule `RuleGroup.RuleDefinition` `Actions` specification.
        """
        return pulumi.get(self, "custom_actions")

    @custom_actions.setter
    def custom_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupCustomActionArgs']]]]):
        pulumi.set(self, "custom_actions", value)


@pulumi.input_type
class RuleGroupStatelessRuleArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 rule_definition: pulumi.Input['RuleGroupRuleDefinitionArgs']):
        """
        :param pulumi.Input[int] priority: Indicates the order in which to run this rule relative to all of the rules that are defined for a stateless rule group. Network Firewall evaluates the rules in a rule group starting with the lowest priority setting. You must ensure that the priority settings are unique for the rule group.
               
               Each stateless rule group uses exactly one `StatelessRulesAndCustomActions` object, and each `StatelessRulesAndCustomActions` contains exactly one `StatelessRules` object. To ensure unique priority settings for your rule groups, set unique priorities for the stateless rules that you define inside any single `StatelessRules` object.
               
               You can change the priority settings of your rules at any time. To make it easier to insert rules later, number them so there's a wide range in between, for example use 100, 200, and so on.
        :param pulumi.Input['RuleGroupRuleDefinitionArgs'] rule_definition: Defines the stateless 5-tuple packet inspection criteria and the action to take on a packet that matches the criteria.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "rule_definition", rule_definition)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Indicates the order in which to run this rule relative to all of the rules that are defined for a stateless rule group. Network Firewall evaluates the rules in a rule group starting with the lowest priority setting. You must ensure that the priority settings are unique for the rule group.

        Each stateless rule group uses exactly one `StatelessRulesAndCustomActions` object, and each `StatelessRulesAndCustomActions` contains exactly one `StatelessRules` object. To ensure unique priority settings for your rule groups, set unique priorities for the stateless rules that you define inside any single `StatelessRules` object.

        You can change the priority settings of your rules at any time. To make it easier to insert rules later, number them so there's a wide range in between, for example use 100, 200, and so on.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="ruleDefinition")
    def rule_definition(self) -> pulumi.Input['RuleGroupRuleDefinitionArgs']:
        """
        Defines the stateless 5-tuple packet inspection criteria and the action to take on a packet that matches the criteria.
        """
        return pulumi.get(self, "rule_definition")

    @rule_definition.setter
    def rule_definition(self, value: pulumi.Input['RuleGroupRuleDefinitionArgs']):
        pulumi.set(self, "rule_definition", value)


@pulumi.input_type
class RuleGroupTcpFlagFieldArgs:
    def __init__(__self__, *,
                 flags: pulumi.Input[Sequence[pulumi.Input['RuleGroupTcpFlag']]],
                 masks: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupTcpFlag']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupTcpFlag']]] flags: Used in conjunction with the `Masks` setting to define the flags that must be set and flags that must not be set in order for the packet to match. This setting can only specify values that are also specified in the `Masks` setting.
               
               For the flags that are specified in the masks setting, the following must be true for the packet to match:
               
               - The ones that are set in this flags setting must be set in the packet.
               - The ones that are not set in this flags setting must also not be set in the packet.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupTcpFlag']]] masks: The set of flags to consider in the inspection. To inspect all flags in the valid values list, leave this with no setting.
        """
        pulumi.set(__self__, "flags", flags)
        if masks is not None:
            pulumi.set(__self__, "masks", masks)

    @property
    @pulumi.getter
    def flags(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupTcpFlag']]]:
        """
        Used in conjunction with the `Masks` setting to define the flags that must be set and flags that must not be set in order for the packet to match. This setting can only specify values that are also specified in the `Masks` setting.

        For the flags that are specified in the masks setting, the following must be true for the packet to match:

        - The ones that are set in this flags setting must be set in the packet.
        - The ones that are not set in this flags setting must also not be set in the packet.
        """
        return pulumi.get(self, "flags")

    @flags.setter
    def flags(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupTcpFlag']]]):
        pulumi.set(self, "flags", value)

    @property
    @pulumi.getter
    def masks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupTcpFlag']]]]:
        """
        The set of flags to consider in the inspection. To inspect all flags in the valid values list, leave this with no setting.
        """
        return pulumi.get(self, "masks")

    @masks.setter
    def masks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupTcpFlag']]]]):
        pulumi.set(self, "masks", value)


@pulumi.input_type
class RuleGroupArgs:
    def __init__(__self__, *,
                 rules_source: pulumi.Input['RuleGroupRulesSourceArgs'],
                 reference_sets: Optional[pulumi.Input['RuleGroupReferenceSetsArgs']] = None,
                 rule_variables: Optional[pulumi.Input['RuleGroupRuleVariablesArgs']] = None,
                 stateful_rule_options: Optional[pulumi.Input['RuleGroupStatefulRuleOptionsArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRulesSourceArgs'] rules_source: The stateful rules or stateless rules for the rule group.
        :param pulumi.Input['RuleGroupReferenceSetsArgs'] reference_sets: The reference sets for the stateful rule group.
        :param pulumi.Input['RuleGroupRuleVariablesArgs'] rule_variables: Settings that are available for use in the rules in the rule group. You can only use these for stateful rule groups.
        :param pulumi.Input['RuleGroupStatefulRuleOptionsArgs'] stateful_rule_options: Additional options governing how Network Firewall handles stateful rules. The policies where you use your stateful rule group must have stateful rule options settings that are compatible with these settings. Some limitations apply; for more information, see [Strict evaluation order](https://docs.aws.amazon.com/network-firewall/latest/developerguide/suricata-limitations-caveats.html) in the *AWS Network Firewall Developer Guide* .
        """
        pulumi.set(__self__, "rules_source", rules_source)
        if reference_sets is not None:
            pulumi.set(__self__, "reference_sets", reference_sets)
        if rule_variables is not None:
            pulumi.set(__self__, "rule_variables", rule_variables)
        if stateful_rule_options is not None:
            pulumi.set(__self__, "stateful_rule_options", stateful_rule_options)

    @property
    @pulumi.getter(name="rulesSource")
    def rules_source(self) -> pulumi.Input['RuleGroupRulesSourceArgs']:
        """
        The stateful rules or stateless rules for the rule group.
        """
        return pulumi.get(self, "rules_source")

    @rules_source.setter
    def rules_source(self, value: pulumi.Input['RuleGroupRulesSourceArgs']):
        pulumi.set(self, "rules_source", value)

    @property
    @pulumi.getter(name="referenceSets")
    def reference_sets(self) -> Optional[pulumi.Input['RuleGroupReferenceSetsArgs']]:
        """
        The reference sets for the stateful rule group.
        """
        return pulumi.get(self, "reference_sets")

    @reference_sets.setter
    def reference_sets(self, value: Optional[pulumi.Input['RuleGroupReferenceSetsArgs']]):
        pulumi.set(self, "reference_sets", value)

    @property
    @pulumi.getter(name="ruleVariables")
    def rule_variables(self) -> Optional[pulumi.Input['RuleGroupRuleVariablesArgs']]:
        """
        Settings that are available for use in the rules in the rule group. You can only use these for stateful rule groups.
        """
        return pulumi.get(self, "rule_variables")

    @rule_variables.setter
    def rule_variables(self, value: Optional[pulumi.Input['RuleGroupRuleVariablesArgs']]):
        pulumi.set(self, "rule_variables", value)

    @property
    @pulumi.getter(name="statefulRuleOptions")
    def stateful_rule_options(self) -> Optional[pulumi.Input['RuleGroupStatefulRuleOptionsArgs']]:
        """
        Additional options governing how Network Firewall handles stateful rules. The policies where you use your stateful rule group must have stateful rule options settings that are compatible with these settings. Some limitations apply; for more information, see [Strict evaluation order](https://docs.aws.amazon.com/network-firewall/latest/developerguide/suricata-limitations-caveats.html) in the *AWS Network Firewall Developer Guide* .
        """
        return pulumi.get(self, "stateful_rule_options")

    @stateful_rule_options.setter
    def stateful_rule_options(self, value: Optional[pulumi.Input['RuleGroupStatefulRuleOptionsArgs']]):
        pulumi.set(self, "stateful_rule_options", value)


@pulumi.input_type
class TlsInspectionConfigurationAddressArgs:
    def __init__(__self__, *,
                 address_definition: pulumi.Input[str]):
        """
        :param pulumi.Input[str] address_definition: Specify an IP address or a block of IP addresses in Classless Inter-Domain Routing (CIDR) notation. Network Firewall supports all address ranges for IPv4 and IPv6.
               
               Examples:
               
               - To configure Network Firewall to inspect for the IP address 192.0.2.44, specify `192.0.2.44/32` .
               - To configure Network Firewall to inspect for IP addresses from 192.0.2.0 to 192.0.2.255, specify `192.0.2.0/24` .
               - To configure Network Firewall to inspect for the IP address 1111:0000:0000:0000:0000:0000:0000:0111, specify `1111:0000:0000:0000:0000:0000:0000:0111/128` .
               - To configure Network Firewall to inspect for IP addresses from 1111:0000:0000:0000:0000:0000:0000:0000 to 1111:0000:0000:0000:ffff:ffff:ffff:ffff, specify `1111:0000:0000:0000:0000:0000:0000:0000/64` .
               
               For more information about CIDR notation, see the Wikipedia entry [Classless Inter-Domain Routing](https://docs.aws.amazon.com/https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) .
        """
        pulumi.set(__self__, "address_definition", address_definition)

    @property
    @pulumi.getter(name="addressDefinition")
    def address_definition(self) -> pulumi.Input[str]:
        """
        Specify an IP address or a block of IP addresses in Classless Inter-Domain Routing (CIDR) notation. Network Firewall supports all address ranges for IPv4 and IPv6.

        Examples:

        - To configure Network Firewall to inspect for the IP address 192.0.2.44, specify `192.0.2.44/32` .
        - To configure Network Firewall to inspect for IP addresses from 192.0.2.0 to 192.0.2.255, specify `192.0.2.0/24` .
        - To configure Network Firewall to inspect for the IP address 1111:0000:0000:0000:0000:0000:0000:0111, specify `1111:0000:0000:0000:0000:0000:0000:0111/128` .
        - To configure Network Firewall to inspect for IP addresses from 1111:0000:0000:0000:0000:0000:0000:0000 to 1111:0000:0000:0000:ffff:ffff:ffff:ffff, specify `1111:0000:0000:0000:0000:0000:0000:0000/64` .

        For more information about CIDR notation, see the Wikipedia entry [Classless Inter-Domain Routing](https://docs.aws.amazon.com/https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) .
        """
        return pulumi.get(self, "address_definition")

    @address_definition.setter
    def address_definition(self, value: pulumi.Input[str]):
        pulumi.set(self, "address_definition", value)


@pulumi.input_type
class TlsInspectionConfigurationPortRangeArgs:
    def __init__(__self__, *,
                 from_port: pulumi.Input[int],
                 to_port: pulumi.Input[int]):
        """
        :param pulumi.Input[int] from_port: The lower limit of the port range. This must be less than or equal to the `ToPort` specification.
        :param pulumi.Input[int] to_port: The upper limit of the port range. This must be greater than or equal to the `FromPort` specification.
        """
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "to_port", to_port)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> pulumi.Input[int]:
        """
        The lower limit of the port range. This must be less than or equal to the `ToPort` specification.
        """
        return pulumi.get(self, "from_port")

    @from_port.setter
    def from_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "from_port", value)

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> pulumi.Input[int]:
        """
        The upper limit of the port range. This must be greater than or equal to the `FromPort` specification.
        """
        return pulumi.get(self, "to_port")

    @to_port.setter
    def to_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "to_port", value)


@pulumi.input_type
class TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesArgs:
    def __init__(__self__, *,
                 revoked_status_action: Optional[pulumi.Input['TlsInspectionConfigurationRevokedStatusAction']] = None,
                 unknown_status_action: Optional[pulumi.Input['TlsInspectionConfigurationUnknownStatusAction']] = None):
        """
        When enabled, Network Firewall checks if the server certificate presented by the server in the SSL/TLS connection has a revoked or unkown status. If the certificate has an unknown or revoked status, you must specify the actions that Network Firewall takes on outbound traffic. To check the certificate revocation status, you must also specify a `CertificateAuthorityArn` in [ServerCertificateConfiguration](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-networkfirewall-servercertificateconfiguration.html) .
        """
        if revoked_status_action is not None:
            pulumi.set(__self__, "revoked_status_action", revoked_status_action)
        if unknown_status_action is not None:
            pulumi.set(__self__, "unknown_status_action", unknown_status_action)

    @property
    @pulumi.getter(name="revokedStatusAction")
    def revoked_status_action(self) -> Optional[pulumi.Input['TlsInspectionConfigurationRevokedStatusAction']]:
        return pulumi.get(self, "revoked_status_action")

    @revoked_status_action.setter
    def revoked_status_action(self, value: Optional[pulumi.Input['TlsInspectionConfigurationRevokedStatusAction']]):
        pulumi.set(self, "revoked_status_action", value)

    @property
    @pulumi.getter(name="unknownStatusAction")
    def unknown_status_action(self) -> Optional[pulumi.Input['TlsInspectionConfigurationUnknownStatusAction']]:
        return pulumi.get(self, "unknown_status_action")

    @unknown_status_action.setter
    def unknown_status_action(self, value: Optional[pulumi.Input['TlsInspectionConfigurationUnknownStatusAction']]):
        pulumi.set(self, "unknown_status_action", value)


@pulumi.input_type
class TlsInspectionConfigurationServerCertificateConfigurationArgs:
    def __init__(__self__, *,
                 certificate_authority_arn: Optional[pulumi.Input[str]] = None,
                 check_certificate_revocation_status: Optional[pulumi.Input['TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesArgs']] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationServerCertificateScopeArgs']]]] = None,
                 server_certificates: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationServerCertificateArgs']]]] = None):
        """
        :param pulumi.Input[str] certificate_authority_arn: The Amazon Resource Name (ARN) of the imported certificate authority (CA) certificate within AWS Certificate Manager (ACM) to use for outbound SSL/TLS inspection.
               
               The following limitations apply:
               
               - You can use CA certificates that you imported into ACM, but you can't generate CA certificates with ACM.
               - You can't use certificates issued by AWS Private Certificate Authority .
               
               For more information about configuring certificates for outbound inspection, see [Using SSL/TLS certificates with certificates with TLS inspection configurations](https://docs.aws.amazon.com/network-firewall/latest/developerguide/tls-inspection-certificate-requirements.html) in the *AWS Network Firewall Developer Guide* .
               
               For information about working with certificates in ACM, see [Importing certificates](https://docs.aws.amazon.com/acm/latest/userguide/import-certificate.html) in the *AWS Certificate Manager User Guide* .
        :param pulumi.Input['TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesArgs'] check_certificate_revocation_status: When enabled, Network Firewall checks if the server certificate presented by the server in the SSL/TLS connection has a revoked or unkown status. If the certificate has an unknown or revoked status, you must specify the actions that Network Firewall takes on outbound traffic. To check the certificate revocation status, you must also specify a `CertificateAuthorityArn` in [ServerCertificateConfiguration](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-networkfirewall-servercertificateconfiguration.html) .
        :param pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationServerCertificateScopeArgs']]] scopes: A list of scopes.
        :param pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationServerCertificateArgs']]] server_certificates: The list of server certificates to use for inbound SSL/TLS inspection.
        """
        if certificate_authority_arn is not None:
            pulumi.set(__self__, "certificate_authority_arn", certificate_authority_arn)
        if check_certificate_revocation_status is not None:
            pulumi.set(__self__, "check_certificate_revocation_status", check_certificate_revocation_status)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if server_certificates is not None:
            pulumi.set(__self__, "server_certificates", server_certificates)

    @property
    @pulumi.getter(name="certificateAuthorityArn")
    def certificate_authority_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon Resource Name (ARN) of the imported certificate authority (CA) certificate within AWS Certificate Manager (ACM) to use for outbound SSL/TLS inspection.

        The following limitations apply:

        - You can use CA certificates that you imported into ACM, but you can't generate CA certificates with ACM.
        - You can't use certificates issued by AWS Private Certificate Authority .

        For more information about configuring certificates for outbound inspection, see [Using SSL/TLS certificates with certificates with TLS inspection configurations](https://docs.aws.amazon.com/network-firewall/latest/developerguide/tls-inspection-certificate-requirements.html) in the *AWS Network Firewall Developer Guide* .

        For information about working with certificates in ACM, see [Importing certificates](https://docs.aws.amazon.com/acm/latest/userguide/import-certificate.html) in the *AWS Certificate Manager User Guide* .
        """
        return pulumi.get(self, "certificate_authority_arn")

    @certificate_authority_arn.setter
    def certificate_authority_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_authority_arn", value)

    @property
    @pulumi.getter(name="checkCertificateRevocationStatus")
    def check_certificate_revocation_status(self) -> Optional[pulumi.Input['TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesArgs']]:
        """
        When enabled, Network Firewall checks if the server certificate presented by the server in the SSL/TLS connection has a revoked or unkown status. If the certificate has an unknown or revoked status, you must specify the actions that Network Firewall takes on outbound traffic. To check the certificate revocation status, you must also specify a `CertificateAuthorityArn` in [ServerCertificateConfiguration](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-networkfirewall-servercertificateconfiguration.html) .
        """
        return pulumi.get(self, "check_certificate_revocation_status")

    @check_certificate_revocation_status.setter
    def check_certificate_revocation_status(self, value: Optional[pulumi.Input['TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesArgs']]):
        pulumi.set(self, "check_certificate_revocation_status", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationServerCertificateScopeArgs']]]]:
        """
        A list of scopes.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationServerCertificateScopeArgs']]]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter(name="serverCertificates")
    def server_certificates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationServerCertificateArgs']]]]:
        """
        The list of server certificates to use for inbound SSL/TLS inspection.
        """
        return pulumi.get(self, "server_certificates")

    @server_certificates.setter
    def server_certificates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationServerCertificateArgs']]]]):
        pulumi.set(self, "server_certificates", value)


@pulumi.input_type
class TlsInspectionConfigurationServerCertificateScopeArgs:
    def __init__(__self__, *,
                 destination_ports: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationPortRangeArgs']]]] = None,
                 destinations: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationAddressArgs']]]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 source_ports: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationPortRangeArgs']]]] = None,
                 sources: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationAddressArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationPortRangeArgs']]] destination_ports: The destination ports to decrypt for inspection, in Transmission Control Protocol (TCP) format. If not specified, this matches with any destination port.
               
               You can specify individual ports, for example `1994` , and you can specify port ranges, such as `1990:1994` .
        :param pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationAddressArgs']]] destinations: The destination IP addresses and address ranges to decrypt for inspection, in CIDR notation. If not specified, this
               matches with any destination address.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] protocols: The protocols to decrypt for inspection, specified using each protocol's assigned internet protocol number
               (IANA). Network Firewall currently supports only TCP.
        :param pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationPortRangeArgs']]] source_ports: The source ports to decrypt for inspection, in Transmission Control Protocol (TCP) format. If not specified, this matches with any source port.
               
               You can specify individual ports, for example `1994` , and you can specify port ranges, such as `1990:1994` .
        :param pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationAddressArgs']]] sources: The source IP addresses and address ranges to decrypt for inspection, in CIDR notation. If not specified, this
               matches with any source address.
        """
        if destination_ports is not None:
            pulumi.set(__self__, "destination_ports", destination_ports)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if source_ports is not None:
            pulumi.set(__self__, "source_ports", source_ports)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)

    @property
    @pulumi.getter(name="destinationPorts")
    def destination_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationPortRangeArgs']]]]:
        """
        The destination ports to decrypt for inspection, in Transmission Control Protocol (TCP) format. If not specified, this matches with any destination port.

        You can specify individual ports, for example `1994` , and you can specify port ranges, such as `1990:1994` .
        """
        return pulumi.get(self, "destination_ports")

    @destination_ports.setter
    def destination_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationPortRangeArgs']]]]):
        pulumi.set(self, "destination_ports", value)

    @property
    @pulumi.getter
    def destinations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationAddressArgs']]]]:
        """
        The destination IP addresses and address ranges to decrypt for inspection, in CIDR notation. If not specified, this
        matches with any destination address.
        """
        return pulumi.get(self, "destinations")

    @destinations.setter
    def destinations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationAddressArgs']]]]):
        pulumi.set(self, "destinations", value)

    @property
    @pulumi.getter
    def protocols(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        The protocols to decrypt for inspection, specified using each protocol's assigned internet protocol number
        (IANA). Network Firewall currently supports only TCP.
        """
        return pulumi.get(self, "protocols")

    @protocols.setter
    def protocols(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "protocols", value)

    @property
    @pulumi.getter(name="sourcePorts")
    def source_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationPortRangeArgs']]]]:
        """
        The source ports to decrypt for inspection, in Transmission Control Protocol (TCP) format. If not specified, this matches with any source port.

        You can specify individual ports, for example `1994` , and you can specify port ranges, such as `1990:1994` .
        """
        return pulumi.get(self, "source_ports")

    @source_ports.setter
    def source_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationPortRangeArgs']]]]):
        pulumi.set(self, "source_ports", value)

    @property
    @pulumi.getter
    def sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationAddressArgs']]]]:
        """
        The source IP addresses and address ranges to decrypt for inspection, in CIDR notation. If not specified, this
        matches with any source address.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationAddressArgs']]]]):
        pulumi.set(self, "sources", value)


@pulumi.input_type
class TlsInspectionConfigurationServerCertificateArgs:
    def __init__(__self__, *,
                 resource_arn: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] resource_arn: The Amazon Resource Name (ARN) of the AWS Certificate Manager SSL/TLS server certificate that's used for inbound SSL/TLS inspection.
        """
        if resource_arn is not None:
            pulumi.set(__self__, "resource_arn", resource_arn)

    @property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon Resource Name (ARN) of the AWS Certificate Manager SSL/TLS server certificate that's used for inbound SSL/TLS inspection.
        """
        return pulumi.get(self, "resource_arn")

    @resource_arn.setter
    def resource_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_arn", value)


@pulumi.input_type
class TlsInspectionConfigurationTlsInspectionConfigurationArgs:
    def __init__(__self__, *,
                 server_certificate_configurations: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationServerCertificateConfigurationArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationServerCertificateConfigurationArgs']]] server_certificate_configurations: Lists the server certificate configurations that are associated with the TLS configuration.
        """
        if server_certificate_configurations is not None:
            pulumi.set(__self__, "server_certificate_configurations", server_certificate_configurations)

    @property
    @pulumi.getter(name="serverCertificateConfigurations")
    def server_certificate_configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationServerCertificateConfigurationArgs']]]]:
        """
        Lists the server certificate configurations that are associated with the TLS configuration.
        """
        return pulumi.get(self, "server_certificate_configurations")

    @server_certificate_configurations.setter
    def server_certificate_configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationServerCertificateConfigurationArgs']]]]):
        pulumi.set(self, "server_certificate_configurations", value)


