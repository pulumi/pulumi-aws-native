# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from ._enums import *

__all__ = [
    'FirewallPolicyActionDefinitionArgs',
    'FirewallPolicyCustomActionArgs',
    'FirewallPolicyDimensionArgs',
    'FirewallPolicyIpSetArgs',
    'FirewallPolicyPolicyVariablesPropertiesArgs',
    'FirewallPolicyPublishMetricActionArgs',
    'FirewallPolicyStatefulEngineOptionsArgs',
    'FirewallPolicyStatefulRuleGroupOverrideArgs',
    'FirewallPolicyStatefulRuleGroupReferenceArgs',
    'FirewallPolicyStatelessRuleGroupReferenceArgs',
    'FirewallPolicyArgs',
    'FirewallSubnetMappingArgs',
    'LoggingConfigurationLogDestinationConfigArgs',
    'LoggingConfigurationArgs',
    'RuleGroupActionDefinitionArgs',
    'RuleGroupAddressArgs',
    'RuleGroupCustomActionArgs',
    'RuleGroupDimensionArgs',
    'RuleGroupHeaderArgs',
    'RuleGroupIpSetReferenceArgs',
    'RuleGroupIpSetArgs',
    'RuleGroupMatchAttributesArgs',
    'RuleGroupPortRangeArgs',
    'RuleGroupPortSetArgs',
    'RuleGroupPublishMetricActionArgs',
    'RuleGroupReferenceSetsArgs',
    'RuleGroupRuleDefinitionArgs',
    'RuleGroupRuleOptionArgs',
    'RuleGroupRuleVariablesArgs',
    'RuleGroupRulesSourceListArgs',
    'RuleGroupRulesSourceArgs',
    'RuleGroupStatefulRuleOptionsArgs',
    'RuleGroupStatefulRuleArgs',
    'RuleGroupStatelessRulesAndCustomActionsArgs',
    'RuleGroupStatelessRuleArgs',
    'RuleGroupTcpFlagFieldArgs',
    'RuleGroupArgs',
    'TlsInspectionConfigurationAddressArgs',
    'TlsInspectionConfigurationPortRangeArgs',
    'TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesArgs',
    'TlsInspectionConfigurationServerCertificateConfigurationArgs',
    'TlsInspectionConfigurationServerCertificateScopeArgs',
    'TlsInspectionConfigurationServerCertificateArgs',
    'TlsInspectionConfigurationTlsInspectionConfigurationArgs',
]

@pulumi.input_type
class FirewallPolicyActionDefinitionArgs:
    def __init__(__self__, *,
                 publish_metric_action: Optional[pulumi.Input['FirewallPolicyPublishMetricActionArgs']] = None):
        """
        :param pulumi.Input['FirewallPolicyPublishMetricActionArgs'] publish_metric_action: Stateless inspection criteria that publishes the specified metrics to Amazon CloudWatch for the matching packet. This setting defines a CloudWatch dimension value to be published.
        """
        if publish_metric_action is not None:
            pulumi.set(__self__, "publish_metric_action", publish_metric_action)

    @property
    @pulumi.getter(name="publishMetricAction")
    def publish_metric_action(self) -> Optional[pulumi.Input['FirewallPolicyPublishMetricActionArgs']]:
        """
        Stateless inspection criteria that publishes the specified metrics to Amazon CloudWatch for the matching packet. This setting defines a CloudWatch dimension value to be published.
        """
        return pulumi.get(self, "publish_metric_action")

    @publish_metric_action.setter
    def publish_metric_action(self, value: Optional[pulumi.Input['FirewallPolicyPublishMetricActionArgs']]):
        pulumi.set(self, "publish_metric_action", value)


@pulumi.input_type
class FirewallPolicyCustomActionArgs:
    def __init__(__self__, *,
                 action_definition: pulumi.Input['FirewallPolicyActionDefinitionArgs'],
                 action_name: pulumi.Input[str]):
        """
        :param pulumi.Input['FirewallPolicyActionDefinitionArgs'] action_definition: A custom action to use in stateless rule actions settings.
        :param pulumi.Input[str] action_name: The descriptive name of the custom action. You can't change the name of a custom action after you create it.
        """
        pulumi.set(__self__, "action_definition", action_definition)
        pulumi.set(__self__, "action_name", action_name)

    @property
    @pulumi.getter(name="actionDefinition")
    def action_definition(self) -> pulumi.Input['FirewallPolicyActionDefinitionArgs']:
        """
        A custom action to use in stateless rule actions settings.
        """
        return pulumi.get(self, "action_definition")

    @action_definition.setter
    def action_definition(self, value: pulumi.Input['FirewallPolicyActionDefinitionArgs']):
        pulumi.set(self, "action_definition", value)

    @property
    @pulumi.getter(name="actionName")
    def action_name(self) -> pulumi.Input[str]:
        """
        The descriptive name of the custom action. You can't change the name of a custom action after you create it.
        """
        return pulumi.get(self, "action_name")

    @action_name.setter
    def action_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "action_name", value)


@pulumi.input_type
class FirewallPolicyDimensionArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] value: The value to use in the custom metric dimension.
        """
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value to use in the custom metric dimension.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class FirewallPolicyIpSetArgs:
    def __init__(__self__, *,
                 definition: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] definition: The list of IP addresses and address ranges, in CIDR notation.
        """
        if definition is not None:
            pulumi.set(__self__, "definition", definition)

    @property
    @pulumi.getter
    def definition(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of IP addresses and address ranges, in CIDR notation.
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "definition", value)


@pulumi.input_type
class FirewallPolicyPolicyVariablesPropertiesArgs:
    def __init__(__self__, *,
                 rule_variables: Optional[pulumi.Input[Mapping[str, pulumi.Input['FirewallPolicyIpSetArgs']]]] = None):
        """
        Contains variables that you can use to override default Suricata settings in your firewall policy.
        """
        if rule_variables is not None:
            pulumi.set(__self__, "rule_variables", rule_variables)

    @property
    @pulumi.getter(name="ruleVariables")
    def rule_variables(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['FirewallPolicyIpSetArgs']]]]:
        return pulumi.get(self, "rule_variables")

    @rule_variables.setter
    def rule_variables(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['FirewallPolicyIpSetArgs']]]]):
        pulumi.set(self, "rule_variables", value)


@pulumi.input_type
class FirewallPolicyPublishMetricActionArgs:
    def __init__(__self__, *,
                 dimensions: pulumi.Input[Sequence[pulumi.Input['FirewallPolicyDimensionArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['FirewallPolicyDimensionArgs']]] dimensions: The value to use in an Amazon CloudWatch custom metric dimension. This is used in the `PublishMetrics` custom action. A CloudWatch custom metric dimension is a name/value pair that's part of the identity of a metric.
               
               AWS Network Firewall sets the dimension name to `CustomAction` and you provide the dimension value.
               
               For more information about CloudWatch custom metric dimensions, see [Publishing Custom Metrics](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/publishingMetrics.html#usingDimensions) in the [Amazon CloudWatch User Guide](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/WhatIsCloudWatch.html) .
        """
        pulumi.set(__self__, "dimensions", dimensions)

    @property
    @pulumi.getter
    def dimensions(self) -> pulumi.Input[Sequence[pulumi.Input['FirewallPolicyDimensionArgs']]]:
        """
        The value to use in an Amazon CloudWatch custom metric dimension. This is used in the `PublishMetrics` custom action. A CloudWatch custom metric dimension is a name/value pair that's part of the identity of a metric.

        AWS Network Firewall sets the dimension name to `CustomAction` and you provide the dimension value.

        For more information about CloudWatch custom metric dimensions, see [Publishing Custom Metrics](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/publishingMetrics.html#usingDimensions) in the [Amazon CloudWatch User Guide](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/WhatIsCloudWatch.html) .
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: pulumi.Input[Sequence[pulumi.Input['FirewallPolicyDimensionArgs']]]):
        pulumi.set(self, "dimensions", value)


@pulumi.input_type
class FirewallPolicyStatefulEngineOptionsArgs:
    def __init__(__self__, *,
                 rule_order: Optional[pulumi.Input['FirewallPolicyRuleOrder']] = None,
                 stream_exception_policy: Optional[pulumi.Input['FirewallPolicyStreamExceptionPolicy']] = None):
        """
        :param pulumi.Input['FirewallPolicyRuleOrder'] rule_order: Indicates how to manage the order of stateful rule evaluation for the policy. `DEFAULT_ACTION_ORDER` is the default behavior. Stateful rules are provided to the rule engine as Suricata compatible strings, and Suricata evaluates them based on certain settings. For more information, see [Evaluation order for stateful rules](https://docs.aws.amazon.com/network-firewall/latest/developerguide/suricata-rule-evaluation-order.html) in the *AWS Network Firewall Developer Guide* .
        :param pulumi.Input['FirewallPolicyStreamExceptionPolicy'] stream_exception_policy: Configures how Network Firewall processes traffic when a network connection breaks midstream. Network connections can break due to disruptions in external networks or within the firewall itself.
               
               - `DROP` - Network Firewall fails closed and drops all subsequent traffic going to the firewall. This is the default behavior.
               - `CONTINUE` - Network Firewall continues to apply rules to the subsequent traffic without context from traffic before the break. This impacts the behavior of rules that depend on this context. For example, if you have a stateful rule to `drop http` traffic, Network Firewall won't match the traffic for this rule because the service won't have the context from session initialization defining the application layer protocol as HTTP. However, this behavior is rule dependent—a TCP-layer rule using a `flow:stateless` rule would still match, as would the `aws:drop_strict` default action.
               - `REJECT` - Network Firewall fails closed and drops all subsequent traffic going to the firewall. Network Firewall also sends a TCP reject packet back to your client so that the client can immediately establish a new session. Network Firewall will have context about the new session and will apply rules to the subsequent traffic.
        """
        if rule_order is not None:
            pulumi.set(__self__, "rule_order", rule_order)
        if stream_exception_policy is not None:
            pulumi.set(__self__, "stream_exception_policy", stream_exception_policy)

    @property
    @pulumi.getter(name="ruleOrder")
    def rule_order(self) -> Optional[pulumi.Input['FirewallPolicyRuleOrder']]:
        """
        Indicates how to manage the order of stateful rule evaluation for the policy. `DEFAULT_ACTION_ORDER` is the default behavior. Stateful rules are provided to the rule engine as Suricata compatible strings, and Suricata evaluates them based on certain settings. For more information, see [Evaluation order for stateful rules](https://docs.aws.amazon.com/network-firewall/latest/developerguide/suricata-rule-evaluation-order.html) in the *AWS Network Firewall Developer Guide* .
        """
        return pulumi.get(self, "rule_order")

    @rule_order.setter
    def rule_order(self, value: Optional[pulumi.Input['FirewallPolicyRuleOrder']]):
        pulumi.set(self, "rule_order", value)

    @property
    @pulumi.getter(name="streamExceptionPolicy")
    def stream_exception_policy(self) -> Optional[pulumi.Input['FirewallPolicyStreamExceptionPolicy']]:
        """
        Configures how Network Firewall processes traffic when a network connection breaks midstream. Network connections can break due to disruptions in external networks or within the firewall itself.

        - `DROP` - Network Firewall fails closed and drops all subsequent traffic going to the firewall. This is the default behavior.
        - `CONTINUE` - Network Firewall continues to apply rules to the subsequent traffic without context from traffic before the break. This impacts the behavior of rules that depend on this context. For example, if you have a stateful rule to `drop http` traffic, Network Firewall won't match the traffic for this rule because the service won't have the context from session initialization defining the application layer protocol as HTTP. However, this behavior is rule dependent—a TCP-layer rule using a `flow:stateless` rule would still match, as would the `aws:drop_strict` default action.
        - `REJECT` - Network Firewall fails closed and drops all subsequent traffic going to the firewall. Network Firewall also sends a TCP reject packet back to your client so that the client can immediately establish a new session. Network Firewall will have context about the new session and will apply rules to the subsequent traffic.
        """
        return pulumi.get(self, "stream_exception_policy")

    @stream_exception_policy.setter
    def stream_exception_policy(self, value: Optional[pulumi.Input['FirewallPolicyStreamExceptionPolicy']]):
        pulumi.set(self, "stream_exception_policy", value)


@pulumi.input_type
class FirewallPolicyStatefulRuleGroupOverrideArgs:
    def __init__(__self__, *,
                 action: Optional[pulumi.Input['FirewallPolicyOverrideAction']] = None):
        """
        :param pulumi.Input['FirewallPolicyOverrideAction'] action: The action that changes the rule group from `DROP` to `ALERT` . This only applies to managed rule groups.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input['FirewallPolicyOverrideAction']]:
        """
        The action that changes the rule group from `DROP` to `ALERT` . This only applies to managed rule groups.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input['FirewallPolicyOverrideAction']]):
        pulumi.set(self, "action", value)


@pulumi.input_type
class FirewallPolicyStatefulRuleGroupReferenceArgs:
    def __init__(__self__, *,
                 resource_arn: pulumi.Input[str],
                 override: Optional[pulumi.Input['FirewallPolicyStatefulRuleGroupOverrideArgs']] = None,
                 priority: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] resource_arn: The Amazon Resource Name (ARN) of the stateful rule group.
        :param pulumi.Input['FirewallPolicyStatefulRuleGroupOverrideArgs'] override: The setting that allows the policy owner to change the behavior of the rule group within a policy.
        :param pulumi.Input[int] priority: An integer setting that indicates the order in which to run the stateful rule groups in a single `FirewallPolicy` . This setting only applies to firewall policies that specify the `STRICT_ORDER` rule order in the stateful engine options settings.
               
               Network Firewall evalutes each stateful rule group against a packet starting with the group that has the lowest priority setting. You must ensure that the priority settings are unique within each policy.
               
               You can change the priority settings of your rule groups at any time. To make it easier to insert rule groups later, number them so there's a wide range in between, for example use 100, 200, and so on.
        """
        pulumi.set(__self__, "resource_arn", resource_arn)
        if override is not None:
            pulumi.set(__self__, "override", override)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the stateful rule group.
        """
        return pulumi.get(self, "resource_arn")

    @resource_arn.setter
    def resource_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_arn", value)

    @property
    @pulumi.getter
    def override(self) -> Optional[pulumi.Input['FirewallPolicyStatefulRuleGroupOverrideArgs']]:
        """
        The setting that allows the policy owner to change the behavior of the rule group within a policy.
        """
        return pulumi.get(self, "override")

    @override.setter
    def override(self, value: Optional[pulumi.Input['FirewallPolicyStatefulRuleGroupOverrideArgs']]):
        pulumi.set(self, "override", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        An integer setting that indicates the order in which to run the stateful rule groups in a single `FirewallPolicy` . This setting only applies to firewall policies that specify the `STRICT_ORDER` rule order in the stateful engine options settings.

        Network Firewall evalutes each stateful rule group against a packet starting with the group that has the lowest priority setting. You must ensure that the priority settings are unique within each policy.

        You can change the priority settings of your rule groups at any time. To make it easier to insert rule groups later, number them so there's a wide range in between, for example use 100, 200, and so on.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)


@pulumi.input_type
class FirewallPolicyStatelessRuleGroupReferenceArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 resource_arn: pulumi.Input[str]):
        """
        :param pulumi.Input[int] priority: An integer setting that indicates the order in which to run the stateless rule groups in a single `FirewallPolicy` . Network Firewall applies each stateless rule group to a packet starting with the group that has the lowest priority setting. You must ensure that the priority settings are unique within each policy.
        :param pulumi.Input[str] resource_arn: The Amazon Resource Name (ARN) of the stateless rule group.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "resource_arn", resource_arn)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        An integer setting that indicates the order in which to run the stateless rule groups in a single `FirewallPolicy` . Network Firewall applies each stateless rule group to a packet starting with the group that has the lowest priority setting. You must ensure that the priority settings are unique within each policy.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the stateless rule group.
        """
        return pulumi.get(self, "resource_arn")

    @resource_arn.setter
    def resource_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_arn", value)


@pulumi.input_type
class FirewallPolicyArgs:
    def __init__(__self__, *,
                 stateless_default_actions: pulumi.Input[Sequence[pulumi.Input[str]]],
                 stateless_fragment_default_actions: pulumi.Input[Sequence[pulumi.Input[str]]],
                 policy_variables: Optional[pulumi.Input['FirewallPolicyPolicyVariablesPropertiesArgs']] = None,
                 stateful_default_actions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 stateful_engine_options: Optional[pulumi.Input['FirewallPolicyStatefulEngineOptionsArgs']] = None,
                 stateful_rule_group_references: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyStatefulRuleGroupReferenceArgs']]]] = None,
                 stateless_custom_actions: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyCustomActionArgs']]]] = None,
                 stateless_rule_group_references: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyStatelessRuleGroupReferenceArgs']]]] = None,
                 tls_inspection_configuration_arn: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] stateless_default_actions: The actions to take on a packet if it doesn't match any of the stateless rules in the policy. If you want non-matching packets to be forwarded for stateful inspection, specify `aws:forward_to_sfe` .
               
               You must specify one of the standard actions: `aws:pass` , `aws:drop` , or `aws:forward_to_sfe` . In addition, you can specify custom actions that are compatible with your standard section choice.
               
               For example, you could specify `["aws:pass"]` or you could specify `["aws:pass", "customActionName"]` . For information about compatibility, see the custom action descriptions.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] stateless_fragment_default_actions: The actions to take on a fragmented packet if it doesn't match any of the stateless rules in the policy. If you want non-matching fragmented packets to be forwarded for stateful inspection, specify `aws:forward_to_sfe` .
               
               You must specify one of the standard actions: `aws:pass` , `aws:drop` , or `aws:forward_to_sfe` . In addition, you can specify custom actions that are compatible with your standard section choice.
               
               For example, you could specify `["aws:pass"]` or you could specify `["aws:pass", "customActionName"]` . For information about compatibility, see the custom action descriptions.
        :param pulumi.Input['FirewallPolicyPolicyVariablesPropertiesArgs'] policy_variables: Contains variables that you can use to override default Suricata settings in your firewall policy.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] stateful_default_actions: The default actions to take on a packet that doesn't match any stateful rules. The stateful default action is optional, and is only valid when using the strict rule order.
               
               Valid values of the stateful default action:
               
               - aws:drop_strict
               - aws:drop_established
               - aws:alert_strict
               - aws:alert_established
               
               For more information, see [Strict evaluation order](https://docs.aws.amazon.com/network-firewall/latest/developerguide/suricata-rule-evaluation-order.html#suricata-strict-rule-evaluation-order.html) in the *AWS Network Firewall Developer Guide* .
        :param pulumi.Input['FirewallPolicyStatefulEngineOptionsArgs'] stateful_engine_options: Configuration settings for the handling of the stateful rule groups in a firewall policy.
        :param pulumi.Input[Sequence[pulumi.Input['FirewallPolicyStatefulRuleGroupReferenceArgs']]] stateful_rule_group_references: Identifier for a single stateful rule group, used in a firewall policy to refer to a rule group.
        :param pulumi.Input[Sequence[pulumi.Input['FirewallPolicyCustomActionArgs']]] stateless_custom_actions: An optional, non-standard action to use for stateless packet handling. You can define this in addition to the standard action that you must specify.
               
               You define and name the custom actions that you want to be able to use, and then you reference them by name in your actions settings.
               
               You can use custom actions in the following places:
               
               - In an `RuleGroup.StatelessRulesAndCustomActions` . The custom actions are available for use by name inside the `StatelessRulesAndCustomActions` where you define them. You can use them for your stateless rule actions to specify what to do with a packet that matches the rule's match attributes.
               - In an `FirewallPolicy` specification, in `StatelessCustomActions` . The custom actions are available for use inside the policy where you define them. You can use them for the policy's default stateless actions settings to specify what to do with packets that don't match any of the policy's stateless rules.
        :param pulumi.Input[Sequence[pulumi.Input['FirewallPolicyStatelessRuleGroupReferenceArgs']]] stateless_rule_group_references: Identifier for a single stateless rule group, used in a firewall policy to refer to the rule group.
        :param pulumi.Input[str] tls_inspection_configuration_arn: The Amazon Resource Name (ARN) of the TLS inspection configuration.
        """
        pulumi.set(__self__, "stateless_default_actions", stateless_default_actions)
        pulumi.set(__self__, "stateless_fragment_default_actions", stateless_fragment_default_actions)
        if policy_variables is not None:
            pulumi.set(__self__, "policy_variables", policy_variables)
        if stateful_default_actions is not None:
            pulumi.set(__self__, "stateful_default_actions", stateful_default_actions)
        if stateful_engine_options is not None:
            pulumi.set(__self__, "stateful_engine_options", stateful_engine_options)
        if stateful_rule_group_references is not None:
            pulumi.set(__self__, "stateful_rule_group_references", stateful_rule_group_references)
        if stateless_custom_actions is not None:
            pulumi.set(__self__, "stateless_custom_actions", stateless_custom_actions)
        if stateless_rule_group_references is not None:
            pulumi.set(__self__, "stateless_rule_group_references", stateless_rule_group_references)
        if tls_inspection_configuration_arn is not None:
            pulumi.set(__self__, "tls_inspection_configuration_arn", tls_inspection_configuration_arn)

    @property
    @pulumi.getter(name="statelessDefaultActions")
    def stateless_default_actions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The actions to take on a packet if it doesn't match any of the stateless rules in the policy. If you want non-matching packets to be forwarded for stateful inspection, specify `aws:forward_to_sfe` .

        You must specify one of the standard actions: `aws:pass` , `aws:drop` , or `aws:forward_to_sfe` . In addition, you can specify custom actions that are compatible with your standard section choice.

        For example, you could specify `["aws:pass"]` or you could specify `["aws:pass", "customActionName"]` . For information about compatibility, see the custom action descriptions.
        """
        return pulumi.get(self, "stateless_default_actions")

    @stateless_default_actions.setter
    def stateless_default_actions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "stateless_default_actions", value)

    @property
    @pulumi.getter(name="statelessFragmentDefaultActions")
    def stateless_fragment_default_actions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The actions to take on a fragmented packet if it doesn't match any of the stateless rules in the policy. If you want non-matching fragmented packets to be forwarded for stateful inspection, specify `aws:forward_to_sfe` .

        You must specify one of the standard actions: `aws:pass` , `aws:drop` , or `aws:forward_to_sfe` . In addition, you can specify custom actions that are compatible with your standard section choice.

        For example, you could specify `["aws:pass"]` or you could specify `["aws:pass", "customActionName"]` . For information about compatibility, see the custom action descriptions.
        """
        return pulumi.get(self, "stateless_fragment_default_actions")

    @stateless_fragment_default_actions.setter
    def stateless_fragment_default_actions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "stateless_fragment_default_actions", value)

    @property
    @pulumi.getter(name="policyVariables")
    def policy_variables(self) -> Optional[pulumi.Input['FirewallPolicyPolicyVariablesPropertiesArgs']]:
        """
        Contains variables that you can use to override default Suricata settings in your firewall policy.
        """
        return pulumi.get(self, "policy_variables")

    @policy_variables.setter
    def policy_variables(self, value: Optional[pulumi.Input['FirewallPolicyPolicyVariablesPropertiesArgs']]):
        pulumi.set(self, "policy_variables", value)

    @property
    @pulumi.getter(name="statefulDefaultActions")
    def stateful_default_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The default actions to take on a packet that doesn't match any stateful rules. The stateful default action is optional, and is only valid when using the strict rule order.

        Valid values of the stateful default action:

        - aws:drop_strict
        - aws:drop_established
        - aws:alert_strict
        - aws:alert_established

        For more information, see [Strict evaluation order](https://docs.aws.amazon.com/network-firewall/latest/developerguide/suricata-rule-evaluation-order.html#suricata-strict-rule-evaluation-order.html) in the *AWS Network Firewall Developer Guide* .
        """
        return pulumi.get(self, "stateful_default_actions")

    @stateful_default_actions.setter
    def stateful_default_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "stateful_default_actions", value)

    @property
    @pulumi.getter(name="statefulEngineOptions")
    def stateful_engine_options(self) -> Optional[pulumi.Input['FirewallPolicyStatefulEngineOptionsArgs']]:
        """
        Configuration settings for the handling of the stateful rule groups in a firewall policy.
        """
        return pulumi.get(self, "stateful_engine_options")

    @stateful_engine_options.setter
    def stateful_engine_options(self, value: Optional[pulumi.Input['FirewallPolicyStatefulEngineOptionsArgs']]):
        pulumi.set(self, "stateful_engine_options", value)

    @property
    @pulumi.getter(name="statefulRuleGroupReferences")
    def stateful_rule_group_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyStatefulRuleGroupReferenceArgs']]]]:
        """
        Identifier for a single stateful rule group, used in a firewall policy to refer to a rule group.
        """
        return pulumi.get(self, "stateful_rule_group_references")

    @stateful_rule_group_references.setter
    def stateful_rule_group_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyStatefulRuleGroupReferenceArgs']]]]):
        pulumi.set(self, "stateful_rule_group_references", value)

    @property
    @pulumi.getter(name="statelessCustomActions")
    def stateless_custom_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyCustomActionArgs']]]]:
        """
        An optional, non-standard action to use for stateless packet handling. You can define this in addition to the standard action that you must specify.

        You define and name the custom actions that you want to be able to use, and then you reference them by name in your actions settings.

        You can use custom actions in the following places:

        - In an `RuleGroup.StatelessRulesAndCustomActions` . The custom actions are available for use by name inside the `StatelessRulesAndCustomActions` where you define them. You can use them for your stateless rule actions to specify what to do with a packet that matches the rule's match attributes.
        - In an `FirewallPolicy` specification, in `StatelessCustomActions` . The custom actions are available for use inside the policy where you define them. You can use them for the policy's default stateless actions settings to specify what to do with packets that don't match any of the policy's stateless rules.
        """
        return pulumi.get(self, "stateless_custom_actions")

    @stateless_custom_actions.setter
    def stateless_custom_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyCustomActionArgs']]]]):
        pulumi.set(self, "stateless_custom_actions", value)

    @property
    @pulumi.getter(name="statelessRuleGroupReferences")
    def stateless_rule_group_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyStatelessRuleGroupReferenceArgs']]]]:
        """
        Identifier for a single stateless rule group, used in a firewall policy to refer to the rule group.
        """
        return pulumi.get(self, "stateless_rule_group_references")

    @stateless_rule_group_references.setter
    def stateless_rule_group_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FirewallPolicyStatelessRuleGroupReferenceArgs']]]]):
        pulumi.set(self, "stateless_rule_group_references", value)

    @property
    @pulumi.getter(name="tlsInspectionConfigurationArn")
    def tls_inspection_configuration_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon Resource Name (ARN) of the TLS inspection configuration.
        """
        return pulumi.get(self, "tls_inspection_configuration_arn")

    @tls_inspection_configuration_arn.setter
    def tls_inspection_configuration_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls_inspection_configuration_arn", value)


@pulumi.input_type
class FirewallSubnetMappingArgs:
    def __init__(__self__, *,
                 subnet_id: pulumi.Input[str],
                 ip_address_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] subnet_id: A SubnetId.
        :param pulumi.Input[str] ip_address_type: A IPAddressType
        """
        pulumi.set(__self__, "subnet_id", subnet_id)
        if ip_address_type is not None:
            pulumi.set(__self__, "ip_address_type", ip_address_type)

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[str]:
        """
        A SubnetId.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet_id", value)

    @property
    @pulumi.getter(name="ipAddressType")
    def ip_address_type(self) -> Optional[pulumi.Input[str]]:
        """
        A IPAddressType
        """
        return pulumi.get(self, "ip_address_type")

    @ip_address_type.setter
    def ip_address_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_address_type", value)


@pulumi.input_type
class LoggingConfigurationLogDestinationConfigArgs:
    def __init__(__self__, *,
                 log_destination: pulumi.Input[Mapping[str, pulumi.Input[str]]],
                 log_destination_type: pulumi.Input['LoggingConfigurationLogDestinationConfigLogDestinationType'],
                 log_type: pulumi.Input['LoggingConfigurationLogDestinationConfigLogType']):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] log_destination: A key-value pair to configure the logDestinations.
        :param pulumi.Input['LoggingConfigurationLogDestinationConfigLogDestinationType'] log_destination_type: The type of storage destination to send these logs to. You can send logs to an Amazon S3 bucket, a CloudWatch log group, or a Firehose delivery stream.
        :param pulumi.Input['LoggingConfigurationLogDestinationConfigLogType'] log_type: The type of log to send. Alert logs report traffic that matches a stateful rule with an action setting that sends an alert log message. Flow logs are standard network traffic flow logs.
        """
        pulumi.set(__self__, "log_destination", log_destination)
        pulumi.set(__self__, "log_destination_type", log_destination_type)
        pulumi.set(__self__, "log_type", log_type)

    @property
    @pulumi.getter(name="logDestination")
    def log_destination(self) -> pulumi.Input[Mapping[str, pulumi.Input[str]]]:
        """
        A key-value pair to configure the logDestinations.
        """
        return pulumi.get(self, "log_destination")

    @log_destination.setter
    def log_destination(self, value: pulumi.Input[Mapping[str, pulumi.Input[str]]]):
        pulumi.set(self, "log_destination", value)

    @property
    @pulumi.getter(name="logDestinationType")
    def log_destination_type(self) -> pulumi.Input['LoggingConfigurationLogDestinationConfigLogDestinationType']:
        """
        The type of storage destination to send these logs to. You can send logs to an Amazon S3 bucket, a CloudWatch log group, or a Firehose delivery stream.
        """
        return pulumi.get(self, "log_destination_type")

    @log_destination_type.setter
    def log_destination_type(self, value: pulumi.Input['LoggingConfigurationLogDestinationConfigLogDestinationType']):
        pulumi.set(self, "log_destination_type", value)

    @property
    @pulumi.getter(name="logType")
    def log_type(self) -> pulumi.Input['LoggingConfigurationLogDestinationConfigLogType']:
        """
        The type of log to send. Alert logs report traffic that matches a stateful rule with an action setting that sends an alert log message. Flow logs are standard network traffic flow logs.
        """
        return pulumi.get(self, "log_type")

    @log_type.setter
    def log_type(self, value: pulumi.Input['LoggingConfigurationLogDestinationConfigLogType']):
        pulumi.set(self, "log_type", value)


@pulumi.input_type
class LoggingConfigurationArgs:
    def __init__(__self__, *,
                 log_destination_configs: pulumi.Input[Sequence[pulumi.Input['LoggingConfigurationLogDestinationConfigArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['LoggingConfigurationLogDestinationConfigArgs']]] log_destination_configs: Defines where AWS Network Firewall sends logs for the firewall for one log type. This is used in `LoggingConfiguration` . You can send each type of log to an Amazon S3 bucket, a CloudWatch log group, or a Kinesis Data Firehose delivery stream.
               
               Network Firewall generates logs for stateful rule groups. You can save alert and flow log types. The stateful rules engine records flow logs for all network traffic that it receives. It records alert logs for traffic that matches stateful rules that have the rule action set to `DROP` or `ALERT` .
        """
        pulumi.set(__self__, "log_destination_configs", log_destination_configs)

    @property
    @pulumi.getter(name="logDestinationConfigs")
    def log_destination_configs(self) -> pulumi.Input[Sequence[pulumi.Input['LoggingConfigurationLogDestinationConfigArgs']]]:
        """
        Defines where AWS Network Firewall sends logs for the firewall for one log type. This is used in `LoggingConfiguration` . You can send each type of log to an Amazon S3 bucket, a CloudWatch log group, or a Kinesis Data Firehose delivery stream.

        Network Firewall generates logs for stateful rule groups. You can save alert and flow log types. The stateful rules engine records flow logs for all network traffic that it receives. It records alert logs for traffic that matches stateful rules that have the rule action set to `DROP` or `ALERT` .
        """
        return pulumi.get(self, "log_destination_configs")

    @log_destination_configs.setter
    def log_destination_configs(self, value: pulumi.Input[Sequence[pulumi.Input['LoggingConfigurationLogDestinationConfigArgs']]]):
        pulumi.set(self, "log_destination_configs", value)


@pulumi.input_type
class RuleGroupActionDefinitionArgs:
    def __init__(__self__, *,
                 publish_metric_action: Optional[pulumi.Input['RuleGroupPublishMetricActionArgs']] = None):
        """
        :param pulumi.Input['RuleGroupPublishMetricActionArgs'] publish_metric_action: Stateless inspection criteria that publishes the specified metrics to Amazon CloudWatch for the matching packet. This setting defines a CloudWatch dimension value to be published.
        """
        if publish_metric_action is not None:
            pulumi.set(__self__, "publish_metric_action", publish_metric_action)

    @property
    @pulumi.getter(name="publishMetricAction")
    def publish_metric_action(self) -> Optional[pulumi.Input['RuleGroupPublishMetricActionArgs']]:
        """
        Stateless inspection criteria that publishes the specified metrics to Amazon CloudWatch for the matching packet. This setting defines a CloudWatch dimension value to be published.
        """
        return pulumi.get(self, "publish_metric_action")

    @publish_metric_action.setter
    def publish_metric_action(self, value: Optional[pulumi.Input['RuleGroupPublishMetricActionArgs']]):
        pulumi.set(self, "publish_metric_action", value)


@pulumi.input_type
class RuleGroupAddressArgs:
    def __init__(__self__, *,
                 address_definition: pulumi.Input[str]):
        """
        :param pulumi.Input[str] address_definition: Specify an IP address or a block of IP addresses in Classless Inter-Domain Routing (CIDR) notation. Network Firewall supports all address ranges for IPv4 and IPv6.
               
               Examples:
               
               - To configure Network Firewall to inspect for the IP address 192.0.2.44, specify `192.0.2.44/32` .
               - To configure Network Firewall to inspect for IP addresses from 192.0.2.0 to 192.0.2.255, specify `192.0.2.0/24` .
               - To configure Network Firewall to inspect for the IP address 1111:0000:0000:0000:0000:0000:0000:0111, specify `1111:0000:0000:0000:0000:0000:0000:0111/128` .
               - To configure Network Firewall to inspect for IP addresses from 1111:0000:0000:0000:0000:0000:0000:0000 to 1111:0000:0000:0000:ffff:ffff:ffff:ffff, specify `1111:0000:0000:0000:0000:0000:0000:0000/64` .
               
               For more information about CIDR notation, see the Wikipedia entry [Classless Inter-Domain Routing](https://docs.aws.amazon.com/https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) .
        """
        pulumi.set(__self__, "address_definition", address_definition)

    @property
    @pulumi.getter(name="addressDefinition")
    def address_definition(self) -> pulumi.Input[str]:
        """
        Specify an IP address or a block of IP addresses in Classless Inter-Domain Routing (CIDR) notation. Network Firewall supports all address ranges for IPv4 and IPv6.

        Examples:

        - To configure Network Firewall to inspect for the IP address 192.0.2.44, specify `192.0.2.44/32` .
        - To configure Network Firewall to inspect for IP addresses from 192.0.2.0 to 192.0.2.255, specify `192.0.2.0/24` .
        - To configure Network Firewall to inspect for the IP address 1111:0000:0000:0000:0000:0000:0000:0111, specify `1111:0000:0000:0000:0000:0000:0000:0111/128` .
        - To configure Network Firewall to inspect for IP addresses from 1111:0000:0000:0000:0000:0000:0000:0000 to 1111:0000:0000:0000:ffff:ffff:ffff:ffff, specify `1111:0000:0000:0000:0000:0000:0000:0000/64` .

        For more information about CIDR notation, see the Wikipedia entry [Classless Inter-Domain Routing](https://docs.aws.amazon.com/https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) .
        """
        return pulumi.get(self, "address_definition")

    @address_definition.setter
    def address_definition(self, value: pulumi.Input[str]):
        pulumi.set(self, "address_definition", value)


@pulumi.input_type
class RuleGroupCustomActionArgs:
    def __init__(__self__, *,
                 action_definition: pulumi.Input['RuleGroupActionDefinitionArgs'],
                 action_name: pulumi.Input[str]):
        """
        :param pulumi.Input['RuleGroupActionDefinitionArgs'] action_definition: A custom action to use in stateless rule actions settings.
        :param pulumi.Input[str] action_name: The descriptive name of the custom action. You can't change the name of a custom action after you create it.
        """
        pulumi.set(__self__, "action_definition", action_definition)
        pulumi.set(__self__, "action_name", action_name)

    @property
    @pulumi.getter(name="actionDefinition")
    def action_definition(self) -> pulumi.Input['RuleGroupActionDefinitionArgs']:
        """
        A custom action to use in stateless rule actions settings.
        """
        return pulumi.get(self, "action_definition")

    @action_definition.setter
    def action_definition(self, value: pulumi.Input['RuleGroupActionDefinitionArgs']):
        pulumi.set(self, "action_definition", value)

    @property
    @pulumi.getter(name="actionName")
    def action_name(self) -> pulumi.Input[str]:
        """
        The descriptive name of the custom action. You can't change the name of a custom action after you create it.
        """
        return pulumi.get(self, "action_name")

    @action_name.setter
    def action_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "action_name", value)


@pulumi.input_type
class RuleGroupDimensionArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] value: The value to use in the custom metric dimension.
        """
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value to use in the custom metric dimension.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class RuleGroupHeaderArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str],
                 destination_port: pulumi.Input[str],
                 direction: pulumi.Input['RuleGroupHeaderDirection'],
                 protocol: pulumi.Input['RuleGroupHeaderProtocol'],
                 source: pulumi.Input[str],
                 source_port: pulumi.Input[str]):
        """
        :param pulumi.Input[str] destination: The destination IP address or address range to inspect for, in CIDR notation. To match with any address, specify `ANY` .
               
               Specify an IP address or a block of IP addresses in Classless Inter-Domain Routing (CIDR) notation. Network Firewall supports all address ranges for IPv4 and IPv6.
               
               Examples:
               
               - To configure Network Firewall to inspect for the IP address 192.0.2.44, specify `192.0.2.44/32` .
               - To configure Network Firewall to inspect for IP addresses from 192.0.2.0 to 192.0.2.255, specify `192.0.2.0/24` .
               - To configure Network Firewall to inspect for the IP address 1111:0000:0000:0000:0000:0000:0000:0111, specify `1111:0000:0000:0000:0000:0000:0000:0111/128` .
               - To configure Network Firewall to inspect for IP addresses from 1111:0000:0000:0000:0000:0000:0000:0000 to 1111:0000:0000:0000:ffff:ffff:ffff:ffff, specify `1111:0000:0000:0000:0000:0000:0000:0000/64` .
               
               For more information about CIDR notation, see the Wikipedia entry [Classless Inter-Domain Routing](https://docs.aws.amazon.com/https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) .
        :param pulumi.Input[str] destination_port: The destination port to inspect for. You can specify an individual port, for example `1994` and you can specify a port range, for example `1990:1994` . To match with any port, specify `ANY` .
        :param pulumi.Input['RuleGroupHeaderDirection'] direction: The direction of traffic flow to inspect. If set to `ANY` , the inspection matches bidirectional traffic, both from the source to the destination and from the destination to the source. If set to `FORWARD` , the inspection only matches traffic going from the source to the destination.
        :param pulumi.Input['RuleGroupHeaderProtocol'] protocol: The protocol to inspect for. To specify all, you can use `IP` , because all traffic on AWS and on the internet is IP.
        :param pulumi.Input[str] source: The source IP address or address range to inspect for, in CIDR notation. To match with any address, specify `ANY` .
               
               Specify an IP address or a block of IP addresses in Classless Inter-Domain Routing (CIDR) notation. Network Firewall supports all address ranges for IPv4 and IPv6.
               
               Examples:
               
               - To configure Network Firewall to inspect for the IP address 192.0.2.44, specify `192.0.2.44/32` .
               - To configure Network Firewall to inspect for IP addresses from 192.0.2.0 to 192.0.2.255, specify `192.0.2.0/24` .
               - To configure Network Firewall to inspect for the IP address 1111:0000:0000:0000:0000:0000:0000:0111, specify `1111:0000:0000:0000:0000:0000:0000:0111/128` .
               - To configure Network Firewall to inspect for IP addresses from 1111:0000:0000:0000:0000:0000:0000:0000 to 1111:0000:0000:0000:ffff:ffff:ffff:ffff, specify `1111:0000:0000:0000:0000:0000:0000:0000/64` .
               
               For more information about CIDR notation, see the Wikipedia entry [Classless Inter-Domain Routing](https://docs.aws.amazon.com/https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) .
        :param pulumi.Input[str] source_port: The source port to inspect for. You can specify an individual port, for example `1994` and you can specify a port range, for example `1990:1994` . To match with any port, specify `ANY` .
        """
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "destination_port", destination_port)
        pulumi.set(__self__, "direction", direction)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "source_port", source_port)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        """
        The destination IP address or address range to inspect for, in CIDR notation. To match with any address, specify `ANY` .

        Specify an IP address or a block of IP addresses in Classless Inter-Domain Routing (CIDR) notation. Network Firewall supports all address ranges for IPv4 and IPv6.

        Examples:

        - To configure Network Firewall to inspect for the IP address 192.0.2.44, specify `192.0.2.44/32` .
        - To configure Network Firewall to inspect for IP addresses from 192.0.2.0 to 192.0.2.255, specify `192.0.2.0/24` .
        - To configure Network Firewall to inspect for the IP address 1111:0000:0000:0000:0000:0000:0000:0111, specify `1111:0000:0000:0000:0000:0000:0000:0111/128` .
        - To configure Network Firewall to inspect for IP addresses from 1111:0000:0000:0000:0000:0000:0000:0000 to 1111:0000:0000:0000:ffff:ffff:ffff:ffff, specify `1111:0000:0000:0000:0000:0000:0000:0000/64` .

        For more information about CIDR notation, see the Wikipedia entry [Classless Inter-Domain Routing](https://docs.aws.amazon.com/https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) .
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="destinationPort")
    def destination_port(self) -> pulumi.Input[str]:
        """
        The destination port to inspect for. You can specify an individual port, for example `1994` and you can specify a port range, for example `1990:1994` . To match with any port, specify `ANY` .
        """
        return pulumi.get(self, "destination_port")

    @destination_port.setter
    def destination_port(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination_port", value)

    @property
    @pulumi.getter
    def direction(self) -> pulumi.Input['RuleGroupHeaderDirection']:
        """
        The direction of traffic flow to inspect. If set to `ANY` , the inspection matches bidirectional traffic, both from the source to the destination and from the destination to the source. If set to `FORWARD` , the inspection only matches traffic going from the source to the destination.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: pulumi.Input['RuleGroupHeaderDirection']):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input['RuleGroupHeaderProtocol']:
        """
        The protocol to inspect for. To specify all, you can use `IP` , because all traffic on AWS and on the internet is IP.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input['RuleGroupHeaderProtocol']):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[str]:
        """
        The source IP address or address range to inspect for, in CIDR notation. To match with any address, specify `ANY` .

        Specify an IP address or a block of IP addresses in Classless Inter-Domain Routing (CIDR) notation. Network Firewall supports all address ranges for IPv4 and IPv6.

        Examples:

        - To configure Network Firewall to inspect for the IP address 192.0.2.44, specify `192.0.2.44/32` .
        - To configure Network Firewall to inspect for IP addresses from 192.0.2.0 to 192.0.2.255, specify `192.0.2.0/24` .
        - To configure Network Firewall to inspect for the IP address 1111:0000:0000:0000:0000:0000:0000:0111, specify `1111:0000:0000:0000:0000:0000:0000:0111/128` .
        - To configure Network Firewall to inspect for IP addresses from 1111:0000:0000:0000:0000:0000:0000:0000 to 1111:0000:0000:0000:ffff:ffff:ffff:ffff, specify `1111:0000:0000:0000:0000:0000:0000:0000/64` .

        For more information about CIDR notation, see the Wikipedia entry [Classless Inter-Domain Routing](https://docs.aws.amazon.com/https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) .
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="sourcePort")
    def source_port(self) -> pulumi.Input[str]:
        """
        The source port to inspect for. You can specify an individual port, for example `1994` and you can specify a port range, for example `1990:1994` . To match with any port, specify `ANY` .
        """
        return pulumi.get(self, "source_port")

    @source_port.setter
    def source_port(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_port", value)


@pulumi.input_type
class RuleGroupIpSetReferenceArgs:
    def __init__(__self__, *,
                 reference_arn: Optional[pulumi.Input[str]] = None):
        if reference_arn is not None:
            pulumi.set(__self__, "reference_arn", reference_arn)

    @property
    @pulumi.getter(name="referenceArn")
    def reference_arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "reference_arn")

    @reference_arn.setter
    def reference_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reference_arn", value)


@pulumi.input_type
class RuleGroupIpSetArgs:
    def __init__(__self__, *,
                 definition: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if definition is not None:
            pulumi.set(__self__, "definition", definition)

    @property
    @pulumi.getter
    def definition(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "definition", value)


@pulumi.input_type
class RuleGroupMatchAttributesArgs:
    def __init__(__self__, *,
                 destination_ports: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupPortRangeArgs']]]] = None,
                 destinations: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupAddressArgs']]]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 source_ports: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupPortRangeArgs']]]] = None,
                 sources: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupAddressArgs']]]] = None,
                 tcp_flags: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupTcpFlagFieldArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupPortRangeArgs']]] destination_ports: A single port range specification. This is used for source and destination port ranges in the stateless `RuleGroup.MatchAttributes` .
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupAddressArgs']]] destinations: A single IP address specification. This is used in the `RuleGroup.MatchAttributes` source and destination specifications.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] protocols: The protocols to inspect for, specified using each protocol's assigned internet protocol number (IANA). If not specified, this matches with any protocol.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupPortRangeArgs']]] source_ports: The source ports to inspect for. If not specified, this matches with any source port. This setting is only used for protocols 6 (TCP) and 17 (UDP).
               
               You can specify individual ports, for example `1994` and you can specify port ranges, for example `1990:1994` .
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupAddressArgs']]] sources: The source IP addresses and address ranges to inspect for, in CIDR notation. If not specified, this matches with any source address.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupTcpFlagFieldArgs']]] tcp_flags: TCP flags and masks to inspect packets for. This is used in the `RuleGroup.MatchAttributes` specification.
               
               For example:
               
               `"TCPFlags": [ { "Flags": [ "ECE", "SYN" ], "Masks": [ "SYN", "ECE" ] } ]`
        """
        if destination_ports is not None:
            pulumi.set(__self__, "destination_ports", destination_ports)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if source_ports is not None:
            pulumi.set(__self__, "source_ports", source_ports)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)
        if tcp_flags is not None:
            pulumi.set(__self__, "tcp_flags", tcp_flags)

    @property
    @pulumi.getter(name="destinationPorts")
    def destination_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupPortRangeArgs']]]]:
        """
        A single port range specification. This is used for source and destination port ranges in the stateless `RuleGroup.MatchAttributes` .
        """
        return pulumi.get(self, "destination_ports")

    @destination_ports.setter
    def destination_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupPortRangeArgs']]]]):
        pulumi.set(self, "destination_ports", value)

    @property
    @pulumi.getter
    def destinations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupAddressArgs']]]]:
        """
        A single IP address specification. This is used in the `RuleGroup.MatchAttributes` source and destination specifications.
        """
        return pulumi.get(self, "destinations")

    @destinations.setter
    def destinations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupAddressArgs']]]]):
        pulumi.set(self, "destinations", value)

    @property
    @pulumi.getter
    def protocols(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        The protocols to inspect for, specified using each protocol's assigned internet protocol number (IANA). If not specified, this matches with any protocol.
        """
        return pulumi.get(self, "protocols")

    @protocols.setter
    def protocols(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "protocols", value)

    @property
    @pulumi.getter(name="sourcePorts")
    def source_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupPortRangeArgs']]]]:
        """
        The source ports to inspect for. If not specified, this matches with any source port. This setting is only used for protocols 6 (TCP) and 17 (UDP).

        You can specify individual ports, for example `1994` and you can specify port ranges, for example `1990:1994` .
        """
        return pulumi.get(self, "source_ports")

    @source_ports.setter
    def source_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupPortRangeArgs']]]]):
        pulumi.set(self, "source_ports", value)

    @property
    @pulumi.getter
    def sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupAddressArgs']]]]:
        """
        The source IP addresses and address ranges to inspect for, in CIDR notation. If not specified, this matches with any source address.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupAddressArgs']]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter(name="tcpFlags")
    def tcp_flags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupTcpFlagFieldArgs']]]]:
        """
        TCP flags and masks to inspect packets for. This is used in the `RuleGroup.MatchAttributes` specification.

        For example:

        `"TCPFlags": [ { "Flags": [ "ECE", "SYN" ], "Masks": [ "SYN", "ECE" ] } ]`
        """
        return pulumi.get(self, "tcp_flags")

    @tcp_flags.setter
    def tcp_flags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupTcpFlagFieldArgs']]]]):
        pulumi.set(self, "tcp_flags", value)


@pulumi.input_type
class RuleGroupPortRangeArgs:
    def __init__(__self__, *,
                 from_port: pulumi.Input[int],
                 to_port: pulumi.Input[int]):
        """
        :param pulumi.Input[int] from_port: The lower limit of the port range. This must be less than or equal to the `ToPort` specification.
        :param pulumi.Input[int] to_port: The upper limit of the port range. This must be greater than or equal to the `FromPort` specification.
        """
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "to_port", to_port)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> pulumi.Input[int]:
        """
        The lower limit of the port range. This must be less than or equal to the `ToPort` specification.
        """
        return pulumi.get(self, "from_port")

    @from_port.setter
    def from_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "from_port", value)

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> pulumi.Input[int]:
        """
        The upper limit of the port range. This must be greater than or equal to the `FromPort` specification.
        """
        return pulumi.get(self, "to_port")

    @to_port.setter
    def to_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "to_port", value)


@pulumi.input_type
class RuleGroupPortSetArgs:
    def __init__(__self__, *,
                 definition: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if definition is not None:
            pulumi.set(__self__, "definition", definition)

    @property
    @pulumi.getter
    def definition(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "definition", value)


@pulumi.input_type
class RuleGroupPublishMetricActionArgs:
    def __init__(__self__, *,
                 dimensions: pulumi.Input[Sequence[pulumi.Input['RuleGroupDimensionArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupDimensionArgs']]] dimensions: The value to use in an Amazon CloudWatch custom metric dimension. This is used in the `PublishMetrics` custom action. A CloudWatch custom metric dimension is a name/value pair that's part of the identity of a metric.
               
               AWS Network Firewall sets the dimension name to `CustomAction` and you provide the dimension value.
               
               For more information about CloudWatch custom metric dimensions, see [Publishing Custom Metrics](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/publishingMetrics.html#usingDimensions) in the [Amazon CloudWatch User Guide](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/WhatIsCloudWatch.html) .
        """
        pulumi.set(__self__, "dimensions", dimensions)

    @property
    @pulumi.getter
    def dimensions(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupDimensionArgs']]]:
        """
        The value to use in an Amazon CloudWatch custom metric dimension. This is used in the `PublishMetrics` custom action. A CloudWatch custom metric dimension is a name/value pair that's part of the identity of a metric.

        AWS Network Firewall sets the dimension name to `CustomAction` and you provide the dimension value.

        For more information about CloudWatch custom metric dimensions, see [Publishing Custom Metrics](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/publishingMetrics.html#usingDimensions) in the [Amazon CloudWatch User Guide](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/WhatIsCloudWatch.html) .
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupDimensionArgs']]]):
        pulumi.set(self, "dimensions", value)


@pulumi.input_type
class RuleGroupReferenceSetsArgs:
    def __init__(__self__, *,
                 ip_set_references: Optional[pulumi.Input[Mapping[str, pulumi.Input['RuleGroupIpSetReferenceArgs']]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input['RuleGroupIpSetReferenceArgs']]] ip_set_references: The IP set references to use in the stateful rule group.
        """
        if ip_set_references is not None:
            pulumi.set(__self__, "ip_set_references", ip_set_references)

    @property
    @pulumi.getter(name="ipSetReferences")
    def ip_set_references(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['RuleGroupIpSetReferenceArgs']]]]:
        """
        The IP set references to use in the stateful rule group.
        """
        return pulumi.get(self, "ip_set_references")

    @ip_set_references.setter
    def ip_set_references(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['RuleGroupIpSetReferenceArgs']]]]):
        pulumi.set(self, "ip_set_references", value)


@pulumi.input_type
class RuleGroupRuleDefinitionArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input[Sequence[pulumi.Input[str]]],
                 match_attributes: pulumi.Input['RuleGroupMatchAttributesArgs']):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] actions: The actions to take on a packet that matches one of the stateless rule definition's match attributes. You must specify a standard action and you can add custom actions.
               
               > Network Firewall only forwards a packet for stateful rule inspection if you specify `aws:forward_to_sfe` for a rule that the packet matches, or if the packet doesn't match any stateless rule and you specify `aws:forward_to_sfe` for the `StatelessDefaultActions` setting for the `FirewallPolicy` . 
               
               For every rule, you must specify exactly one of the following standard actions.
               
               - *aws:pass* - Discontinues all inspection of the packet and permits it to go to its intended destination.
               - *aws:drop* - Discontinues all inspection of the packet and blocks it from going to its intended destination.
               - *aws:forward_to_sfe* - Discontinues stateless inspection of the packet and forwards it to the stateful rule engine for inspection.
               
               Additionally, you can specify a custom action. To do this, you define a custom action by name and type, then provide the name you've assigned to the action in this `Actions` setting.
               
               To provide more than one action in this setting, separate the settings with a comma. For example, if you have a publish metrics custom action that you've named `MyMetricsAction` , then you could specify the standard action `aws:pass` combined with the custom action using `["aws:pass", "MyMetricsAction"]` .
        :param pulumi.Input['RuleGroupMatchAttributesArgs'] match_attributes: Criteria for Network Firewall to use to inspect an individual packet in stateless rule inspection. Each match attributes set can include one or more items such as IP address, CIDR range, port number, protocol, and TCP flags.
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "match_attributes", match_attributes)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The actions to take on a packet that matches one of the stateless rule definition's match attributes. You must specify a standard action and you can add custom actions.

        > Network Firewall only forwards a packet for stateful rule inspection if you specify `aws:forward_to_sfe` for a rule that the packet matches, or if the packet doesn't match any stateless rule and you specify `aws:forward_to_sfe` for the `StatelessDefaultActions` setting for the `FirewallPolicy` . 

        For every rule, you must specify exactly one of the following standard actions.

        - *aws:pass* - Discontinues all inspection of the packet and permits it to go to its intended destination.
        - *aws:drop* - Discontinues all inspection of the packet and blocks it from going to its intended destination.
        - *aws:forward_to_sfe* - Discontinues stateless inspection of the packet and forwards it to the stateful rule engine for inspection.

        Additionally, you can specify a custom action. To do this, you define a custom action by name and type, then provide the name you've assigned to the action in this `Actions` setting.

        To provide more than one action in this setting, separate the settings with a comma. For example, if you have a publish metrics custom action that you've named `MyMetricsAction` , then you could specify the standard action `aws:pass` combined with the custom action using `["aws:pass", "MyMetricsAction"]` .
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="matchAttributes")
    def match_attributes(self) -> pulumi.Input['RuleGroupMatchAttributesArgs']:
        """
        Criteria for Network Firewall to use to inspect an individual packet in stateless rule inspection. Each match attributes set can include one or more items such as IP address, CIDR range, port number, protocol, and TCP flags.
        """
        return pulumi.get(self, "match_attributes")

    @match_attributes.setter
    def match_attributes(self, value: pulumi.Input['RuleGroupMatchAttributesArgs']):
        pulumi.set(self, "match_attributes", value)


@pulumi.input_type
class RuleGroupRuleOptionArgs:
    def __init__(__self__, *,
                 keyword: pulumi.Input[str],
                 settings: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] keyword: The Suricata rule option keywords. For Network Firewall , the keyword signature ID (sid) is required in the format `sid:112233` . The sid must be unique within the rule group. For information about Suricata rule option keywords, see [Rule options](https://docs.aws.amazon.com/https://suricata.readthedocs.io/en/suricata-6.0.9/rules/intro.html#rule-options) .
        :param pulumi.Input[Sequence[pulumi.Input[str]]] settings: The Suricata rule option settings. Settings have zero or more values, and the number of possible settings and required settings depends on the keyword. The format for Settings is `number` . For information about Suricata rule option settings, see [Rule options](https://docs.aws.amazon.com/https://suricata.readthedocs.io/en/suricata-6.0.9/rules/intro.html#rule-options) .
        """
        pulumi.set(__self__, "keyword", keyword)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @property
    @pulumi.getter
    def keyword(self) -> pulumi.Input[str]:
        """
        The Suricata rule option keywords. For Network Firewall , the keyword signature ID (sid) is required in the format `sid:112233` . The sid must be unique within the rule group. For information about Suricata rule option keywords, see [Rule options](https://docs.aws.amazon.com/https://suricata.readthedocs.io/en/suricata-6.0.9/rules/intro.html#rule-options) .
        """
        return pulumi.get(self, "keyword")

    @keyword.setter
    def keyword(self, value: pulumi.Input[str]):
        pulumi.set(self, "keyword", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The Suricata rule option settings. Settings have zero or more values, and the number of possible settings and required settings depends on the keyword. The format for Settings is `number` . For information about Suricata rule option settings, see [Rule options](https://docs.aws.amazon.com/https://suricata.readthedocs.io/en/suricata-6.0.9/rules/intro.html#rule-options) .
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "settings", value)


@pulumi.input_type
class RuleGroupRuleVariablesArgs:
    def __init__(__self__, *,
                 ip_sets: Optional[pulumi.Input[Mapping[str, pulumi.Input['RuleGroupIpSetArgs']]]] = None,
                 port_sets: Optional[pulumi.Input[Mapping[str, pulumi.Input['RuleGroupPortSetArgs']]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input['RuleGroupIpSetArgs']]] ip_sets: A list of IP addresses and address ranges, in CIDR notation.
        :param pulumi.Input[Mapping[str, pulumi.Input['RuleGroupPortSetArgs']]] port_sets: A list of port ranges.
        """
        if ip_sets is not None:
            pulumi.set(__self__, "ip_sets", ip_sets)
        if port_sets is not None:
            pulumi.set(__self__, "port_sets", port_sets)

    @property
    @pulumi.getter(name="ipSets")
    def ip_sets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['RuleGroupIpSetArgs']]]]:
        """
        A list of IP addresses and address ranges, in CIDR notation.
        """
        return pulumi.get(self, "ip_sets")

    @ip_sets.setter
    def ip_sets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['RuleGroupIpSetArgs']]]]):
        pulumi.set(self, "ip_sets", value)

    @property
    @pulumi.getter(name="portSets")
    def port_sets(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['RuleGroupPortSetArgs']]]]:
        """
        A list of port ranges.
        """
        return pulumi.get(self, "port_sets")

    @port_sets.setter
    def port_sets(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['RuleGroupPortSetArgs']]]]):
        pulumi.set(self, "port_sets", value)


@pulumi.input_type
class RuleGroupRulesSourceListArgs:
    def __init__(__self__, *,
                 generated_rules_type: pulumi.Input['RuleGroupGeneratedRulesType'],
                 target_types: pulumi.Input[Sequence[pulumi.Input['RuleGroupTargetType']]],
                 targets: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input['RuleGroupGeneratedRulesType'] generated_rules_type: Whether you want to allow or deny access to the domains in your target list.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupTargetType']]] target_types: The types of targets to inspect for. Valid values are `TLS_SNI` and `HTTP_HOST` .
        :param pulumi.Input[Sequence[pulumi.Input[str]]] targets: The domains that you want to inspect for in your traffic flows. Valid domain specifications are the following:
               
               - Explicit names. For example, `abc.example.com` matches only the domain `abc.example.com` .
               - Names that use a domain wildcard, which you indicate with an initial ' `.` '. For example, `.example.com` matches `example.com` and matches all subdomains of `example.com` , such as `abc.example.com` and `www.example.com` .
        """
        pulumi.set(__self__, "generated_rules_type", generated_rules_type)
        pulumi.set(__self__, "target_types", target_types)
        pulumi.set(__self__, "targets", targets)

    @property
    @pulumi.getter(name="generatedRulesType")
    def generated_rules_type(self) -> pulumi.Input['RuleGroupGeneratedRulesType']:
        """
        Whether you want to allow or deny access to the domains in your target list.
        """
        return pulumi.get(self, "generated_rules_type")

    @generated_rules_type.setter
    def generated_rules_type(self, value: pulumi.Input['RuleGroupGeneratedRulesType']):
        pulumi.set(self, "generated_rules_type", value)

    @property
    @pulumi.getter(name="targetTypes")
    def target_types(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupTargetType']]]:
        """
        The types of targets to inspect for. Valid values are `TLS_SNI` and `HTTP_HOST` .
        """
        return pulumi.get(self, "target_types")

    @target_types.setter
    def target_types(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupTargetType']]]):
        pulumi.set(self, "target_types", value)

    @property
    @pulumi.getter
    def targets(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The domains that you want to inspect for in your traffic flows. Valid domain specifications are the following:

        - Explicit names. For example, `abc.example.com` matches only the domain `abc.example.com` .
        - Names that use a domain wildcard, which you indicate with an initial ' `.` '. For example, `.example.com` matches `example.com` and matches all subdomains of `example.com` , such as `abc.example.com` and `www.example.com` .
        """
        return pulumi.get(self, "targets")

    @targets.setter
    def targets(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "targets", value)


@pulumi.input_type
class RuleGroupRulesSourceArgs:
    def __init__(__self__, *,
                 rules_source_list: Optional[pulumi.Input['RuleGroupRulesSourceListArgs']] = None,
                 rules_string: Optional[pulumi.Input[str]] = None,
                 stateful_rules: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupStatefulRuleArgs']]]] = None,
                 stateless_rules_and_custom_actions: Optional[pulumi.Input['RuleGroupStatelessRulesAndCustomActionsArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRulesSourceListArgs'] rules_source_list: Stateful inspection criteria for a domain list rule group.
               
               For HTTPS traffic, domain filtering is SNI-based. It uses the server name indicator extension of the TLS handshake.
               
               By default, Network Firewall domain list inspection only includes traffic coming from the VPC where you deploy the firewall. To inspect traffic from IP addresses outside of the deployment VPC, you set the `HOME_NET` rule variable to include the CIDR range of the deployment VPC plus the other CIDR ranges. For more information, see `RuleGroup.RuleVariables` in this guide and [Stateful domain list rule groups in AWS Network Firewall](https://docs.aws.amazon.com/network-firewall/latest/developerguide/stateful-rule-groups-domain-names.html) in the *Network Firewall Developer Guide*
        :param pulumi.Input[str] rules_string: Stateful inspection criteria, provided in Suricata compatible rules. Suricata is an open-source threat detection framework that includes a standard rule-based language for network traffic inspection.
               
               These rules contain the inspection criteria and the action to take for traffic that matches the criteria, so this type of rule group doesn't have a separate action setting.
               
               > You can't use the `priority` keyword if the `RuleOrder` option in `StatefulRuleOptions` is set to `STRICT_ORDER` .
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupStatefulRuleArgs']]] stateful_rules: A single Suricata rules specification, for use in a stateful rule group. Use this option to specify a simple Suricata rule with protocol, source and destination, ports, direction, and rule options. For information about the Suricata `Rules` format, see [Rules Format](https://docs.aws.amazon.com/https://suricata.readthedocs.io/en/suricata-6.0.9/rules/intro.html) .
        :param pulumi.Input['RuleGroupStatelessRulesAndCustomActionsArgs'] stateless_rules_and_custom_actions: Stateless inspection criteria. Each stateless rule group uses exactly one of these data types to define its stateless rules.
        """
        if rules_source_list is not None:
            pulumi.set(__self__, "rules_source_list", rules_source_list)
        if rules_string is not None:
            pulumi.set(__self__, "rules_string", rules_string)
        if stateful_rules is not None:
            pulumi.set(__self__, "stateful_rules", stateful_rules)
        if stateless_rules_and_custom_actions is not None:
            pulumi.set(__self__, "stateless_rules_and_custom_actions", stateless_rules_and_custom_actions)

    @property
    @pulumi.getter(name="rulesSourceList")
    def rules_source_list(self) -> Optional[pulumi.Input['RuleGroupRulesSourceListArgs']]:
        """
        Stateful inspection criteria for a domain list rule group.

        For HTTPS traffic, domain filtering is SNI-based. It uses the server name indicator extension of the TLS handshake.

        By default, Network Firewall domain list inspection only includes traffic coming from the VPC where you deploy the firewall. To inspect traffic from IP addresses outside of the deployment VPC, you set the `HOME_NET` rule variable to include the CIDR range of the deployment VPC plus the other CIDR ranges. For more information, see `RuleGroup.RuleVariables` in this guide and [Stateful domain list rule groups in AWS Network Firewall](https://docs.aws.amazon.com/network-firewall/latest/developerguide/stateful-rule-groups-domain-names.html) in the *Network Firewall Developer Guide*
        """
        return pulumi.get(self, "rules_source_list")

    @rules_source_list.setter
    def rules_source_list(self, value: Optional[pulumi.Input['RuleGroupRulesSourceListArgs']]):
        pulumi.set(self, "rules_source_list", value)

    @property
    @pulumi.getter(name="rulesString")
    def rules_string(self) -> Optional[pulumi.Input[str]]:
        """
        Stateful inspection criteria, provided in Suricata compatible rules. Suricata is an open-source threat detection framework that includes a standard rule-based language for network traffic inspection.

        These rules contain the inspection criteria and the action to take for traffic that matches the criteria, so this type of rule group doesn't have a separate action setting.

        > You can't use the `priority` keyword if the `RuleOrder` option in `StatefulRuleOptions` is set to `STRICT_ORDER` .
        """
        return pulumi.get(self, "rules_string")

    @rules_string.setter
    def rules_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rules_string", value)

    @property
    @pulumi.getter(name="statefulRules")
    def stateful_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupStatefulRuleArgs']]]]:
        """
        A single Suricata rules specification, for use in a stateful rule group. Use this option to specify a simple Suricata rule with protocol, source and destination, ports, direction, and rule options. For information about the Suricata `Rules` format, see [Rules Format](https://docs.aws.amazon.com/https://suricata.readthedocs.io/en/suricata-6.0.9/rules/intro.html) .
        """
        return pulumi.get(self, "stateful_rules")

    @stateful_rules.setter
    def stateful_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupStatefulRuleArgs']]]]):
        pulumi.set(self, "stateful_rules", value)

    @property
    @pulumi.getter(name="statelessRulesAndCustomActions")
    def stateless_rules_and_custom_actions(self) -> Optional[pulumi.Input['RuleGroupStatelessRulesAndCustomActionsArgs']]:
        """
        Stateless inspection criteria. Each stateless rule group uses exactly one of these data types to define its stateless rules.
        """
        return pulumi.get(self, "stateless_rules_and_custom_actions")

    @stateless_rules_and_custom_actions.setter
    def stateless_rules_and_custom_actions(self, value: Optional[pulumi.Input['RuleGroupStatelessRulesAndCustomActionsArgs']]):
        pulumi.set(self, "stateless_rules_and_custom_actions", value)


@pulumi.input_type
class RuleGroupStatefulRuleOptionsArgs:
    def __init__(__self__, *,
                 rule_order: Optional[pulumi.Input['RuleGroupRuleOrder']] = None):
        """
        :param pulumi.Input['RuleGroupRuleOrder'] rule_order: Indicates how to manage the order of the rule evaluation for the rule group. `DEFAULT_ACTION_ORDER` is the default behavior. Stateful rules are provided to the rule engine as Suricata compatible strings, and Suricata evaluates them based on certain settings. For more information, see [Evaluation order for stateful rules](https://docs.aws.amazon.com/network-firewall/latest/developerguide/suricata-rule-evaluation-order.html) in the *AWS Network Firewall Developer Guide* .
        """
        if rule_order is not None:
            pulumi.set(__self__, "rule_order", rule_order)

    @property
    @pulumi.getter(name="ruleOrder")
    def rule_order(self) -> Optional[pulumi.Input['RuleGroupRuleOrder']]:
        """
        Indicates how to manage the order of the rule evaluation for the rule group. `DEFAULT_ACTION_ORDER` is the default behavior. Stateful rules are provided to the rule engine as Suricata compatible strings, and Suricata evaluates them based on certain settings. For more information, see [Evaluation order for stateful rules](https://docs.aws.amazon.com/network-firewall/latest/developerguide/suricata-rule-evaluation-order.html) in the *AWS Network Firewall Developer Guide* .
        """
        return pulumi.get(self, "rule_order")

    @rule_order.setter
    def rule_order(self, value: Optional[pulumi.Input['RuleGroupRuleOrder']]):
        pulumi.set(self, "rule_order", value)


@pulumi.input_type
class RuleGroupStatefulRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input['RuleGroupStatefulRuleAction'],
                 header: pulumi.Input['RuleGroupHeaderArgs'],
                 rule_options: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleOptionArgs']]]):
        """
        :param pulumi.Input['RuleGroupStatefulRuleAction'] action: Defines what Network Firewall should do with the packets in a traffic flow when the flow matches the stateful rule criteria. For all actions, Network Firewall performs the specified action and discontinues stateful inspection of the traffic flow.
               
               The actions for a stateful rule are defined as follows:
               
               - *PASS* - Permits the packets to go to the intended destination.
               - *DROP* - Blocks the packets from going to the intended destination and sends an alert log message, if alert logging is configured in the `Firewall` `LoggingConfiguration` .
               - *REJECT* - Drops traffic that matches the conditions of the stateful rule and sends a TCP reset packet back to sender of the packet. A TCP reset packet is a packet with no payload and a `RST` bit contained in the TCP header flags. `REJECT` is available only for TCP traffic.
               - *ALERT* - Permits the packets to go to the intended destination and sends an alert log message, if alert logging is configured in the `Firewall` `LoggingConfiguration` .
               
               You can use this action to test a rule that you intend to use to drop traffic. You can enable the rule with `ALERT` action, verify in the logs that the rule is filtering as you want, then change the action to `DROP` .
               - *REJECT* - Drops TCP traffic that matches the conditions of the stateful rule, and sends a TCP reset packet back to sender of the packet. A TCP reset packet is a packet with no payload and a `RST` bit contained in the TCP header flags. Also sends an alert log mesage if alert logging is configured in the `Firewall` `LoggingConfiguration` .
               
               `REJECT` isn't currently available for use with IMAP and FTP protocols.
        :param pulumi.Input['RuleGroupHeaderArgs'] header: The 5-tuple criteria for AWS Network Firewall to use to inspect packet headers in stateful traffic flow inspection. Traffic flows that match the criteria are a match for the corresponding stateful rule.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleOptionArgs']]] rule_options: Additional settings for a stateful rule.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "rule_options", rule_options)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input['RuleGroupStatefulRuleAction']:
        """
        Defines what Network Firewall should do with the packets in a traffic flow when the flow matches the stateful rule criteria. For all actions, Network Firewall performs the specified action and discontinues stateful inspection of the traffic flow.

        The actions for a stateful rule are defined as follows:

        - *PASS* - Permits the packets to go to the intended destination.
        - *DROP* - Blocks the packets from going to the intended destination and sends an alert log message, if alert logging is configured in the `Firewall` `LoggingConfiguration` .
        - *REJECT* - Drops traffic that matches the conditions of the stateful rule and sends a TCP reset packet back to sender of the packet. A TCP reset packet is a packet with no payload and a `RST` bit contained in the TCP header flags. `REJECT` is available only for TCP traffic.
        - *ALERT* - Permits the packets to go to the intended destination and sends an alert log message, if alert logging is configured in the `Firewall` `LoggingConfiguration` .

        You can use this action to test a rule that you intend to use to drop traffic. You can enable the rule with `ALERT` action, verify in the logs that the rule is filtering as you want, then change the action to `DROP` .
        - *REJECT* - Drops TCP traffic that matches the conditions of the stateful rule, and sends a TCP reset packet back to sender of the packet. A TCP reset packet is a packet with no payload and a `RST` bit contained in the TCP header flags. Also sends an alert log mesage if alert logging is configured in the `Firewall` `LoggingConfiguration` .

        `REJECT` isn't currently available for use with IMAP and FTP protocols.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input['RuleGroupStatefulRuleAction']):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def header(self) -> pulumi.Input['RuleGroupHeaderArgs']:
        """
        The 5-tuple criteria for AWS Network Firewall to use to inspect packet headers in stateful traffic flow inspection. Traffic flows that match the criteria are a match for the corresponding stateful rule.
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: pulumi.Input['RuleGroupHeaderArgs']):
        pulumi.set(self, "header", value)

    @property
    @pulumi.getter(name="ruleOptions")
    def rule_options(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleOptionArgs']]]:
        """
        Additional settings for a stateful rule.
        """
        return pulumi.get(self, "rule_options")

    @rule_options.setter
    def rule_options(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupRuleOptionArgs']]]):
        pulumi.set(self, "rule_options", value)


@pulumi.input_type
class RuleGroupStatelessRulesAndCustomActionsArgs:
    def __init__(__self__, *,
                 stateless_rules: pulumi.Input[Sequence[pulumi.Input['RuleGroupStatelessRuleArgs']]],
                 custom_actions: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupCustomActionArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupStatelessRuleArgs']]] stateless_rules: A single stateless rule. This is used in `RuleGroup.StatelessRulesAndCustomActions` .
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupCustomActionArgs']]] custom_actions: An optional, non-standard action to use for stateless packet handling. You can define this in addition to the standard action that you must specify.
               
               You define and name the custom actions that you want to be able to use, and then you reference them by name in your actions settings.
               
               You can use custom actions in the following places:
               
               - In an `RuleGroup.StatelessRulesAndCustomActions` . The custom actions are available for use by name inside the `StatelessRulesAndCustomActions` where you define them. You can use them for your stateless rule actions to specify what to do with a packet that matches the rule's match attributes.
               - In an `FirewallPolicy` specification, in `StatelessCustomActions` . The custom actions are available for use inside the policy where you define them. You can use them for the policy's default stateless actions settings to specify what to do with packets that don't match any of the policy's stateless rules.
        """
        pulumi.set(__self__, "stateless_rules", stateless_rules)
        if custom_actions is not None:
            pulumi.set(__self__, "custom_actions", custom_actions)

    @property
    @pulumi.getter(name="statelessRules")
    def stateless_rules(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupStatelessRuleArgs']]]:
        """
        A single stateless rule. This is used in `RuleGroup.StatelessRulesAndCustomActions` .
        """
        return pulumi.get(self, "stateless_rules")

    @stateless_rules.setter
    def stateless_rules(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupStatelessRuleArgs']]]):
        pulumi.set(self, "stateless_rules", value)

    @property
    @pulumi.getter(name="customActions")
    def custom_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupCustomActionArgs']]]]:
        """
        An optional, non-standard action to use for stateless packet handling. You can define this in addition to the standard action that you must specify.

        You define and name the custom actions that you want to be able to use, and then you reference them by name in your actions settings.

        You can use custom actions in the following places:

        - In an `RuleGroup.StatelessRulesAndCustomActions` . The custom actions are available for use by name inside the `StatelessRulesAndCustomActions` where you define them. You can use them for your stateless rule actions to specify what to do with a packet that matches the rule's match attributes.
        - In an `FirewallPolicy` specification, in `StatelessCustomActions` . The custom actions are available for use inside the policy where you define them. You can use them for the policy's default stateless actions settings to specify what to do with packets that don't match any of the policy's stateless rules.
        """
        return pulumi.get(self, "custom_actions")

    @custom_actions.setter
    def custom_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupCustomActionArgs']]]]):
        pulumi.set(self, "custom_actions", value)


@pulumi.input_type
class RuleGroupStatelessRuleArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 rule_definition: pulumi.Input['RuleGroupRuleDefinitionArgs']):
        """
        :param pulumi.Input[int] priority: Indicates the order in which to run this rule relative to all of the rules that are defined for a stateless rule group. Network Firewall evaluates the rules in a rule group starting with the lowest priority setting. You must ensure that the priority settings are unique for the rule group.
               
               Each stateless rule group uses exactly one `StatelessRulesAndCustomActions` object, and each `StatelessRulesAndCustomActions` contains exactly one `StatelessRules` object. To ensure unique priority settings for your rule groups, set unique priorities for the stateless rules that you define inside any single `StatelessRules` object.
               
               You can change the priority settings of your rules at any time. To make it easier to insert rules later, number them so there's a wide range in between, for example use 100, 200, and so on.
        :param pulumi.Input['RuleGroupRuleDefinitionArgs'] rule_definition: The inspection criteria and action for a single stateless rule. AWS Network Firewall inspects each packet for the specified matching criteria. When a packet matches the criteria, Network Firewall performs the rule's actions on the packet.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "rule_definition", rule_definition)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        """
        Indicates the order in which to run this rule relative to all of the rules that are defined for a stateless rule group. Network Firewall evaluates the rules in a rule group starting with the lowest priority setting. You must ensure that the priority settings are unique for the rule group.

        Each stateless rule group uses exactly one `StatelessRulesAndCustomActions` object, and each `StatelessRulesAndCustomActions` contains exactly one `StatelessRules` object. To ensure unique priority settings for your rule groups, set unique priorities for the stateless rules that you define inside any single `StatelessRules` object.

        You can change the priority settings of your rules at any time. To make it easier to insert rules later, number them so there's a wide range in between, for example use 100, 200, and so on.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="ruleDefinition")
    def rule_definition(self) -> pulumi.Input['RuleGroupRuleDefinitionArgs']:
        """
        The inspection criteria and action for a single stateless rule. AWS Network Firewall inspects each packet for the specified matching criteria. When a packet matches the criteria, Network Firewall performs the rule's actions on the packet.
        """
        return pulumi.get(self, "rule_definition")

    @rule_definition.setter
    def rule_definition(self, value: pulumi.Input['RuleGroupRuleDefinitionArgs']):
        pulumi.set(self, "rule_definition", value)


@pulumi.input_type
class RuleGroupTcpFlagFieldArgs:
    def __init__(__self__, *,
                 flags: pulumi.Input[Sequence[pulumi.Input['RuleGroupTcpFlag']]],
                 masks: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupTcpFlag']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupTcpFlag']]] flags: Used in conjunction with the `Masks` setting to define the flags that must be set and flags that must not be set in order for the packet to match. This setting can only specify values that are also specified in the `Masks` setting.
               
               For the flags that are specified in the masks setting, the following must be true for the packet to match:
               
               - The ones that are set in this flags setting must be set in the packet.
               - The ones that are not set in this flags setting must also not be set in the packet.
        :param pulumi.Input[Sequence[pulumi.Input['RuleGroupTcpFlag']]] masks: The set of flags to consider in the inspection. To inspect all flags in the valid values list, leave this with no setting.
        """
        pulumi.set(__self__, "flags", flags)
        if masks is not None:
            pulumi.set(__self__, "masks", masks)

    @property
    @pulumi.getter
    def flags(self) -> pulumi.Input[Sequence[pulumi.Input['RuleGroupTcpFlag']]]:
        """
        Used in conjunction with the `Masks` setting to define the flags that must be set and flags that must not be set in order for the packet to match. This setting can only specify values that are also specified in the `Masks` setting.

        For the flags that are specified in the masks setting, the following must be true for the packet to match:

        - The ones that are set in this flags setting must be set in the packet.
        - The ones that are not set in this flags setting must also not be set in the packet.
        """
        return pulumi.get(self, "flags")

    @flags.setter
    def flags(self, value: pulumi.Input[Sequence[pulumi.Input['RuleGroupTcpFlag']]]):
        pulumi.set(self, "flags", value)

    @property
    @pulumi.getter
    def masks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupTcpFlag']]]]:
        """
        The set of flags to consider in the inspection. To inspect all flags in the valid values list, leave this with no setting.
        """
        return pulumi.get(self, "masks")

    @masks.setter
    def masks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleGroupTcpFlag']]]]):
        pulumi.set(self, "masks", value)


@pulumi.input_type
class RuleGroupArgs:
    def __init__(__self__, *,
                 rules_source: pulumi.Input['RuleGroupRulesSourceArgs'],
                 reference_sets: Optional[pulumi.Input['RuleGroupReferenceSetsArgs']] = None,
                 rule_variables: Optional[pulumi.Input['RuleGroupRuleVariablesArgs']] = None,
                 stateful_rule_options: Optional[pulumi.Input['RuleGroupStatefulRuleOptionsArgs']] = None):
        """
        :param pulumi.Input['RuleGroupRulesSourceArgs'] rules_source: The stateless or stateful rules definitions for use in a single rule group. Each rule group requires a single `RulesSource` . You can use an instance of this for either stateless rules or stateful rules.
        :param pulumi.Input['RuleGroupReferenceSetsArgs'] reference_sets: Configures the `ReferenceSets` for a stateful rule group. For more information, see the [Using IP set references in Suricata compatible rule groups](https://docs.aws.amazon.com/network-firewall/latest/developerguide/rule-groups-ip-set-references.html) in the *Network Firewall User Guide* .
        :param pulumi.Input['RuleGroupRuleVariablesArgs'] rule_variables: Settings that are available for use in the rules in the `RuleGroup` where this is defined.
        :param pulumi.Input['RuleGroupStatefulRuleOptionsArgs'] stateful_rule_options: Additional options governing how Network Firewall handles the rule group. You can only use these for stateful rule groups.
        """
        pulumi.set(__self__, "rules_source", rules_source)
        if reference_sets is not None:
            pulumi.set(__self__, "reference_sets", reference_sets)
        if rule_variables is not None:
            pulumi.set(__self__, "rule_variables", rule_variables)
        if stateful_rule_options is not None:
            pulumi.set(__self__, "stateful_rule_options", stateful_rule_options)

    @property
    @pulumi.getter(name="rulesSource")
    def rules_source(self) -> pulumi.Input['RuleGroupRulesSourceArgs']:
        """
        The stateless or stateful rules definitions for use in a single rule group. Each rule group requires a single `RulesSource` . You can use an instance of this for either stateless rules or stateful rules.
        """
        return pulumi.get(self, "rules_source")

    @rules_source.setter
    def rules_source(self, value: pulumi.Input['RuleGroupRulesSourceArgs']):
        pulumi.set(self, "rules_source", value)

    @property
    @pulumi.getter(name="referenceSets")
    def reference_sets(self) -> Optional[pulumi.Input['RuleGroupReferenceSetsArgs']]:
        """
        Configures the `ReferenceSets` for a stateful rule group. For more information, see the [Using IP set references in Suricata compatible rule groups](https://docs.aws.amazon.com/network-firewall/latest/developerguide/rule-groups-ip-set-references.html) in the *Network Firewall User Guide* .
        """
        return pulumi.get(self, "reference_sets")

    @reference_sets.setter
    def reference_sets(self, value: Optional[pulumi.Input['RuleGroupReferenceSetsArgs']]):
        pulumi.set(self, "reference_sets", value)

    @property
    @pulumi.getter(name="ruleVariables")
    def rule_variables(self) -> Optional[pulumi.Input['RuleGroupRuleVariablesArgs']]:
        """
        Settings that are available for use in the rules in the `RuleGroup` where this is defined.
        """
        return pulumi.get(self, "rule_variables")

    @rule_variables.setter
    def rule_variables(self, value: Optional[pulumi.Input['RuleGroupRuleVariablesArgs']]):
        pulumi.set(self, "rule_variables", value)

    @property
    @pulumi.getter(name="statefulRuleOptions")
    def stateful_rule_options(self) -> Optional[pulumi.Input['RuleGroupStatefulRuleOptionsArgs']]:
        """
        Additional options governing how Network Firewall handles the rule group. You can only use these for stateful rule groups.
        """
        return pulumi.get(self, "stateful_rule_options")

    @stateful_rule_options.setter
    def stateful_rule_options(self, value: Optional[pulumi.Input['RuleGroupStatefulRuleOptionsArgs']]):
        pulumi.set(self, "stateful_rule_options", value)


@pulumi.input_type
class TlsInspectionConfigurationAddressArgs:
    def __init__(__self__, *,
                 address_definition: pulumi.Input[str]):
        """
        :param pulumi.Input[str] address_definition: Specify an IP address or a block of IP addresses in Classless Inter-Domain Routing (CIDR) notation. Network Firewall supports all address ranges for IPv4 and IPv6.
               
               Examples:
               
               - To configure Network Firewall to inspect for the IP address 192.0.2.44, specify `192.0.2.44/32` .
               - To configure Network Firewall to inspect for IP addresses from 192.0.2.0 to 192.0.2.255, specify `192.0.2.0/24` .
               - To configure Network Firewall to inspect for the IP address 1111:0000:0000:0000:0000:0000:0000:0111, specify `1111:0000:0000:0000:0000:0000:0000:0111/128` .
               - To configure Network Firewall to inspect for IP addresses from 1111:0000:0000:0000:0000:0000:0000:0000 to 1111:0000:0000:0000:ffff:ffff:ffff:ffff, specify `1111:0000:0000:0000:0000:0000:0000:0000/64` .
               
               For more information about CIDR notation, see the Wikipedia entry [Classless Inter-Domain Routing](https://docs.aws.amazon.com/https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) .
        """
        pulumi.set(__self__, "address_definition", address_definition)

    @property
    @pulumi.getter(name="addressDefinition")
    def address_definition(self) -> pulumi.Input[str]:
        """
        Specify an IP address or a block of IP addresses in Classless Inter-Domain Routing (CIDR) notation. Network Firewall supports all address ranges for IPv4 and IPv6.

        Examples:

        - To configure Network Firewall to inspect for the IP address 192.0.2.44, specify `192.0.2.44/32` .
        - To configure Network Firewall to inspect for IP addresses from 192.0.2.0 to 192.0.2.255, specify `192.0.2.0/24` .
        - To configure Network Firewall to inspect for the IP address 1111:0000:0000:0000:0000:0000:0000:0111, specify `1111:0000:0000:0000:0000:0000:0000:0111/128` .
        - To configure Network Firewall to inspect for IP addresses from 1111:0000:0000:0000:0000:0000:0000:0000 to 1111:0000:0000:0000:ffff:ffff:ffff:ffff, specify `1111:0000:0000:0000:0000:0000:0000:0000/64` .

        For more information about CIDR notation, see the Wikipedia entry [Classless Inter-Domain Routing](https://docs.aws.amazon.com/https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) .
        """
        return pulumi.get(self, "address_definition")

    @address_definition.setter
    def address_definition(self, value: pulumi.Input[str]):
        pulumi.set(self, "address_definition", value)


@pulumi.input_type
class TlsInspectionConfigurationPortRangeArgs:
    def __init__(__self__, *,
                 from_port: pulumi.Input[int],
                 to_port: pulumi.Input[int]):
        """
        :param pulumi.Input[int] from_port: The lower limit of the port range. This must be less than or equal to the `ToPort` specification.
        :param pulumi.Input[int] to_port: The upper limit of the port range. This must be greater than or equal to the `FromPort` specification.
        """
        pulumi.set(__self__, "from_port", from_port)
        pulumi.set(__self__, "to_port", to_port)

    @property
    @pulumi.getter(name="fromPort")
    def from_port(self) -> pulumi.Input[int]:
        """
        The lower limit of the port range. This must be less than or equal to the `ToPort` specification.
        """
        return pulumi.get(self, "from_port")

    @from_port.setter
    def from_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "from_port", value)

    @property
    @pulumi.getter(name="toPort")
    def to_port(self) -> pulumi.Input[int]:
        """
        The upper limit of the port range. This must be greater than or equal to the `FromPort` specification.
        """
        return pulumi.get(self, "to_port")

    @to_port.setter
    def to_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "to_port", value)


@pulumi.input_type
class TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesArgs:
    def __init__(__self__, *,
                 revoked_status_action: Optional[pulumi.Input['TlsInspectionConfigurationRevokedStatusAction']] = None,
                 unknown_status_action: Optional[pulumi.Input['TlsInspectionConfigurationUnknownStatusAction']] = None):
        """
        When enabled, Network Firewall checks if the server certificate presented by the server in the SSL/TLS connection has a revoked or unkown status. If the certificate has an unknown or revoked status, you must specify the actions that Network Firewall takes on outbound traffic. To check the certificate revocation status, you must also specify a `CertificateAuthorityArn` in [ServerCertificateConfiguration](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-networkfirewall-servercertificateconfiguration.html) .
        """
        if revoked_status_action is not None:
            pulumi.set(__self__, "revoked_status_action", revoked_status_action)
        if unknown_status_action is not None:
            pulumi.set(__self__, "unknown_status_action", unknown_status_action)

    @property
    @pulumi.getter(name="revokedStatusAction")
    def revoked_status_action(self) -> Optional[pulumi.Input['TlsInspectionConfigurationRevokedStatusAction']]:
        return pulumi.get(self, "revoked_status_action")

    @revoked_status_action.setter
    def revoked_status_action(self, value: Optional[pulumi.Input['TlsInspectionConfigurationRevokedStatusAction']]):
        pulumi.set(self, "revoked_status_action", value)

    @property
    @pulumi.getter(name="unknownStatusAction")
    def unknown_status_action(self) -> Optional[pulumi.Input['TlsInspectionConfigurationUnknownStatusAction']]:
        return pulumi.get(self, "unknown_status_action")

    @unknown_status_action.setter
    def unknown_status_action(self, value: Optional[pulumi.Input['TlsInspectionConfigurationUnknownStatusAction']]):
        pulumi.set(self, "unknown_status_action", value)


@pulumi.input_type
class TlsInspectionConfigurationServerCertificateConfigurationArgs:
    def __init__(__self__, *,
                 certificate_authority_arn: Optional[pulumi.Input[str]] = None,
                 check_certificate_revocation_status: Optional[pulumi.Input['TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesArgs']] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationServerCertificateScopeArgs']]]] = None,
                 server_certificates: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationServerCertificateArgs']]]] = None):
        """
        :param pulumi.Input[str] certificate_authority_arn: The Amazon Resource Name (ARN) of the imported certificate authority (CA) certificate within AWS Certificate Manager (ACM) to use for outbound SSL/TLS inspection.
               
               The following limitations apply:
               
               - You can use CA certificates that you imported into ACM, but you can't generate CA certificates with ACM.
               - You can't use certificates issued by AWS Private Certificate Authority .
               
               For more information about configuring certificates for outbound inspection, see [Using SSL/TLS certificates with certificates with TLS inspection configurations](https://docs.aws.amazon.com/network-firewall/latest/developerguide/tls-inspection-certificate-requirements.html) in the *AWS Network Firewall Developer Guide* .
               
               For information about working with certificates in ACM, see [Importing certificates](https://docs.aws.amazon.com/acm/latest/userguide/import-certificate.html) in the *AWS Certificate Manager User Guide* .
        :param pulumi.Input['TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesArgs'] check_certificate_revocation_status: When enabled, Network Firewall checks if the server certificate presented by the server in the SSL/TLS connection has a revoked or unkown status. If the certificate has an unknown or revoked status, you must specify the actions that Network Firewall takes on outbound traffic. To check the certificate revocation status, you must also specify a `CertificateAuthorityArn` in [ServerCertificateConfiguration](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-networkfirewall-servercertificateconfiguration.html) .
        :param pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationServerCertificateScopeArgs']]] scopes: Settings that define the Secure Sockets Layer/Transport Layer Security (SSL/TLS) traffic that Network Firewall should decrypt for inspection by the stateful rule engine.
        :param pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationServerCertificateArgs']]] server_certificates: Any AWS Certificate Manager (ACM) Secure Sockets Layer/Transport Layer Security (SSL/TLS) server certificate that's associated with a [ServerCertificateConfiguration](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-networkfirewall-tlsinspectionconfiguration-servercertificateconfiguration.html) . Used in a [TLSInspectionConfiguration](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-networkfirewall-tlsinspectionconfiguration.html) for inspection of inbound traffic to your firewall. You must request or import a SSL/TLS certificate into ACM for each domain Network Firewall needs to decrypt and inspect. AWS Network Firewall uses the SSL/TLS certificates to decrypt specified inbound SSL/TLS traffic going to your firewall. For information about working with certificates in AWS Certificate Manager , see [Request a public certificate](https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-public.html) or [Importing certificates](https://docs.aws.amazon.com/acm/latest/userguide/import-certificate.html) in the *AWS Certificate Manager User Guide* .
        """
        if certificate_authority_arn is not None:
            pulumi.set(__self__, "certificate_authority_arn", certificate_authority_arn)
        if check_certificate_revocation_status is not None:
            pulumi.set(__self__, "check_certificate_revocation_status", check_certificate_revocation_status)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if server_certificates is not None:
            pulumi.set(__self__, "server_certificates", server_certificates)

    @property
    @pulumi.getter(name="certificateAuthorityArn")
    def certificate_authority_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon Resource Name (ARN) of the imported certificate authority (CA) certificate within AWS Certificate Manager (ACM) to use for outbound SSL/TLS inspection.

        The following limitations apply:

        - You can use CA certificates that you imported into ACM, but you can't generate CA certificates with ACM.
        - You can't use certificates issued by AWS Private Certificate Authority .

        For more information about configuring certificates for outbound inspection, see [Using SSL/TLS certificates with certificates with TLS inspection configurations](https://docs.aws.amazon.com/network-firewall/latest/developerguide/tls-inspection-certificate-requirements.html) in the *AWS Network Firewall Developer Guide* .

        For information about working with certificates in ACM, see [Importing certificates](https://docs.aws.amazon.com/acm/latest/userguide/import-certificate.html) in the *AWS Certificate Manager User Guide* .
        """
        return pulumi.get(self, "certificate_authority_arn")

    @certificate_authority_arn.setter
    def certificate_authority_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_authority_arn", value)

    @property
    @pulumi.getter(name="checkCertificateRevocationStatus")
    def check_certificate_revocation_status(self) -> Optional[pulumi.Input['TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesArgs']]:
        """
        When enabled, Network Firewall checks if the server certificate presented by the server in the SSL/TLS connection has a revoked or unkown status. If the certificate has an unknown or revoked status, you must specify the actions that Network Firewall takes on outbound traffic. To check the certificate revocation status, you must also specify a `CertificateAuthorityArn` in [ServerCertificateConfiguration](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-networkfirewall-servercertificateconfiguration.html) .
        """
        return pulumi.get(self, "check_certificate_revocation_status")

    @check_certificate_revocation_status.setter
    def check_certificate_revocation_status(self, value: Optional[pulumi.Input['TlsInspectionConfigurationServerCertificateConfigurationCheckCertificateRevocationStatusPropertiesArgs']]):
        pulumi.set(self, "check_certificate_revocation_status", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationServerCertificateScopeArgs']]]]:
        """
        Settings that define the Secure Sockets Layer/Transport Layer Security (SSL/TLS) traffic that Network Firewall should decrypt for inspection by the stateful rule engine.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationServerCertificateScopeArgs']]]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter(name="serverCertificates")
    def server_certificates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationServerCertificateArgs']]]]:
        """
        Any AWS Certificate Manager (ACM) Secure Sockets Layer/Transport Layer Security (SSL/TLS) server certificate that's associated with a [ServerCertificateConfiguration](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-networkfirewall-tlsinspectionconfiguration-servercertificateconfiguration.html) . Used in a [TLSInspectionConfiguration](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-networkfirewall-tlsinspectionconfiguration.html) for inspection of inbound traffic to your firewall. You must request or import a SSL/TLS certificate into ACM for each domain Network Firewall needs to decrypt and inspect. AWS Network Firewall uses the SSL/TLS certificates to decrypt specified inbound SSL/TLS traffic going to your firewall. For information about working with certificates in AWS Certificate Manager , see [Request a public certificate](https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-public.html) or [Importing certificates](https://docs.aws.amazon.com/acm/latest/userguide/import-certificate.html) in the *AWS Certificate Manager User Guide* .
        """
        return pulumi.get(self, "server_certificates")

    @server_certificates.setter
    def server_certificates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationServerCertificateArgs']]]]):
        pulumi.set(self, "server_certificates", value)


@pulumi.input_type
class TlsInspectionConfigurationServerCertificateScopeArgs:
    def __init__(__self__, *,
                 destination_ports: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationPortRangeArgs']]]] = None,
                 destinations: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationAddressArgs']]]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 source_ports: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationPortRangeArgs']]]] = None,
                 sources: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationAddressArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationPortRangeArgs']]] destination_ports: A single port range specification. This is used for source and destination port ranges in the stateless rule [MatchAttributes](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-networkfirewall-rulegroup-matchattributes.html) , `SourcePorts` , and `DestinationPorts` settings.
        :param pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationAddressArgs']]] destinations: A single IP address specification. This is used in the [MatchAttributes](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-networkfirewall-rulegroup-matchattributes.html) source and destination settings.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] protocols: The protocols to decrypt for inspection, specified using each protocol's assigned internet protocol number
               (IANA). Network Firewall currently supports only TCP.
        :param pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationPortRangeArgs']]] source_ports: The source ports to decrypt for inspection, in Transmission Control Protocol (TCP) format. If not specified, this matches with any source port.
               
               You can specify individual ports, for example `1994` , and you can specify port ranges, such as `1990:1994` .
        :param pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationAddressArgs']]] sources: The source IP addresses and address ranges to decrypt for inspection, in CIDR notation. If not specified, this
               matches with any source address.
        """
        if destination_ports is not None:
            pulumi.set(__self__, "destination_ports", destination_ports)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if source_ports is not None:
            pulumi.set(__self__, "source_ports", source_ports)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)

    @property
    @pulumi.getter(name="destinationPorts")
    def destination_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationPortRangeArgs']]]]:
        """
        A single port range specification. This is used for source and destination port ranges in the stateless rule [MatchAttributes](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-networkfirewall-rulegroup-matchattributes.html) , `SourcePorts` , and `DestinationPorts` settings.
        """
        return pulumi.get(self, "destination_ports")

    @destination_ports.setter
    def destination_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationPortRangeArgs']]]]):
        pulumi.set(self, "destination_ports", value)

    @property
    @pulumi.getter
    def destinations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationAddressArgs']]]]:
        """
        A single IP address specification. This is used in the [MatchAttributes](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-networkfirewall-rulegroup-matchattributes.html) source and destination settings.
        """
        return pulumi.get(self, "destinations")

    @destinations.setter
    def destinations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationAddressArgs']]]]):
        pulumi.set(self, "destinations", value)

    @property
    @pulumi.getter
    def protocols(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        The protocols to decrypt for inspection, specified using each protocol's assigned internet protocol number
        (IANA). Network Firewall currently supports only TCP.
        """
        return pulumi.get(self, "protocols")

    @protocols.setter
    def protocols(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "protocols", value)

    @property
    @pulumi.getter(name="sourcePorts")
    def source_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationPortRangeArgs']]]]:
        """
        The source ports to decrypt for inspection, in Transmission Control Protocol (TCP) format. If not specified, this matches with any source port.

        You can specify individual ports, for example `1994` , and you can specify port ranges, such as `1990:1994` .
        """
        return pulumi.get(self, "source_ports")

    @source_ports.setter
    def source_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationPortRangeArgs']]]]):
        pulumi.set(self, "source_ports", value)

    @property
    @pulumi.getter
    def sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationAddressArgs']]]]:
        """
        The source IP addresses and address ranges to decrypt for inspection, in CIDR notation. If not specified, this
        matches with any source address.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationAddressArgs']]]]):
        pulumi.set(self, "sources", value)


@pulumi.input_type
class TlsInspectionConfigurationServerCertificateArgs:
    def __init__(__self__, *,
                 resource_arn: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] resource_arn: The Amazon Resource Name (ARN) of the AWS Certificate Manager SSL/TLS server certificate that's used for inbound SSL/TLS inspection.
        """
        if resource_arn is not None:
            pulumi.set(__self__, "resource_arn", resource_arn)

    @property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon Resource Name (ARN) of the AWS Certificate Manager SSL/TLS server certificate that's used for inbound SSL/TLS inspection.
        """
        return pulumi.get(self, "resource_arn")

    @resource_arn.setter
    def resource_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_arn", value)


@pulumi.input_type
class TlsInspectionConfigurationTlsInspectionConfigurationArgs:
    def __init__(__self__, *,
                 server_certificate_configurations: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationServerCertificateConfigurationArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationServerCertificateConfigurationArgs']]] server_certificate_configurations: Configures the AWS Certificate Manager certificates and scope that Network Firewall uses to decrypt and re-encrypt traffic using a [TLSInspectionConfiguration](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-networkfirewall-tlsinspectionconfiguration.html) . You can configure `ServerCertificates` for inbound SSL/TLS inspection, a `CertificateAuthorityArn` for outbound SSL/TLS inspection, or both. For information about working with certificates for TLS inspection, see [Using SSL/TLS server certficiates with TLS inspection configurations](https://docs.aws.amazon.com/network-firewall/latest/developerguide/tls-inspection-certificate-requirements.html) in the *AWS Network Firewall Developer Guide* .
               
               > If a server certificate that's associated with your [TLSInspectionConfiguration](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-networkfirewall-tlsinspectionconfiguration.html) is revoked, deleted, or expired it can result in client-side TLS errors.
        """
        if server_certificate_configurations is not None:
            pulumi.set(__self__, "server_certificate_configurations", server_certificate_configurations)

    @property
    @pulumi.getter(name="serverCertificateConfigurations")
    def server_certificate_configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationServerCertificateConfigurationArgs']]]]:
        """
        Configures the AWS Certificate Manager certificates and scope that Network Firewall uses to decrypt and re-encrypt traffic using a [TLSInspectionConfiguration](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-networkfirewall-tlsinspectionconfiguration.html) . You can configure `ServerCertificates` for inbound SSL/TLS inspection, a `CertificateAuthorityArn` for outbound SSL/TLS inspection, or both. For information about working with certificates for TLS inspection, see [Using SSL/TLS server certficiates with TLS inspection configurations](https://docs.aws.amazon.com/network-firewall/latest/developerguide/tls-inspection-certificate-requirements.html) in the *AWS Network Firewall Developer Guide* .

        > If a server certificate that's associated with your [TLSInspectionConfiguration](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-networkfirewall-tlsinspectionconfiguration.html) is revoked, deleted, or expired it can result in client-side TLS errors.
        """
        return pulumi.get(self, "server_certificate_configurations")

    @server_certificate_configurations.setter
    def server_certificate_configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TlsInspectionConfigurationServerCertificateConfigurationArgs']]]]):
        pulumi.set(self, "server_certificate_configurations", value)


