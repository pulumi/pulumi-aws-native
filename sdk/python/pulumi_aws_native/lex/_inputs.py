# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'BotAdvancedRecognitionSettingArgs',
    'BotAdvancedRecognitionSettingArgsDict',
    'BotAliasAudioLogDestinationArgs',
    'BotAliasAudioLogDestinationArgsDict',
    'BotAliasAudioLogSettingArgs',
    'BotAliasAudioLogSettingArgsDict',
    'BotAliasCloudWatchLogGroupLogDestinationArgs',
    'BotAliasCloudWatchLogGroupLogDestinationArgsDict',
    'BotAliasCodeHookSpecificationArgs',
    'BotAliasCodeHookSpecificationArgsDict',
    'BotAliasConversationLogSettingsArgs',
    'BotAliasConversationLogSettingsArgsDict',
    'BotAliasLambdaCodeHookArgs',
    'BotAliasLambdaCodeHookArgsDict',
    'BotAliasLocaleSettingsItemArgs',
    'BotAliasLocaleSettingsItemArgsDict',
    'BotAliasLocaleSettingsArgs',
    'BotAliasLocaleSettingsArgsDict',
    'BotAliasS3BucketLogDestinationArgs',
    'BotAliasS3BucketLogDestinationArgsDict',
    'BotAliasTagArgs',
    'BotAliasTagArgsDict',
    'BotAliasTextLogDestinationArgs',
    'BotAliasTextLogDestinationArgsDict',
    'BotAliasTextLogSettingArgs',
    'BotAliasTextLogSettingArgsDict',
    'BotAllowedInputTypesArgs',
    'BotAllowedInputTypesArgsDict',
    'BotAudioAndDtmfInputSpecificationArgs',
    'BotAudioAndDtmfInputSpecificationArgsDict',
    'BotAudioLogDestinationArgs',
    'BotAudioLogDestinationArgsDict',
    'BotAudioLogSettingArgs',
    'BotAudioLogSettingArgsDict',
    'BotAudioSpecificationArgs',
    'BotAudioSpecificationArgsDict',
    'BotBedrockAgentIntentConfigurationBedrockAgentConfigurationPropertiesArgs',
    'BotBedrockAgentIntentConfigurationBedrockAgentConfigurationPropertiesArgsDict',
    'BotBedrockAgentIntentConfigurationBedrockAgentIntentKnowledgeBaseConfigurationPropertiesArgs',
    'BotBedrockAgentIntentConfigurationBedrockAgentIntentKnowledgeBaseConfigurationPropertiesArgsDict',
    'BotBedrockAgentIntentConfigurationArgs',
    'BotBedrockAgentIntentConfigurationArgsDict',
    'BotBedrockModelSpecificationBedrockGuardrailConfigurationPropertiesArgs',
    'BotBedrockModelSpecificationBedrockGuardrailConfigurationPropertiesArgsDict',
    'BotBedrockModelSpecificationArgs',
    'BotBedrockModelSpecificationArgsDict',
    'BotButtonArgs',
    'BotButtonArgsDict',
    'BotCloudWatchLogGroupLogDestinationArgs',
    'BotCloudWatchLogGroupLogDestinationArgsDict',
    'BotCompositeSlotTypeSettingArgs',
    'BotCompositeSlotTypeSettingArgsDict',
    'BotConditionalBranchArgs',
    'BotConditionalBranchArgsDict',
    'BotConditionalSpecificationArgs',
    'BotConditionalSpecificationArgsDict',
    'BotConditionArgs',
    'BotConditionArgsDict',
    'BotConversationLogSettingsArgs',
    'BotConversationLogSettingsArgsDict',
    'BotCustomPayloadArgs',
    'BotCustomPayloadArgsDict',
    'BotCustomVocabularyItemArgs',
    'BotCustomVocabularyItemArgsDict',
    'BotCustomVocabularyArgs',
    'BotCustomVocabularyArgsDict',
    'BotDefaultConditionalBranchArgs',
    'BotDefaultConditionalBranchArgsDict',
    'BotDialogActionArgs',
    'BotDialogActionArgsDict',
    'BotDialogCodeHookInvocationSettingArgs',
    'BotDialogCodeHookInvocationSettingArgsDict',
    'BotDialogCodeHookSettingArgs',
    'BotDialogCodeHookSettingArgsDict',
    'BotDialogStateArgs',
    'BotDialogStateArgsDict',
    'BotDtmfSpecificationArgs',
    'BotDtmfSpecificationArgsDict',
    'BotElicitationCodeHookInvocationSettingArgs',
    'BotElicitationCodeHookInvocationSettingArgsDict',
    'BotExternalSourceSettingArgs',
    'BotExternalSourceSettingArgsDict',
    'BotFulfillmentCodeHookSettingArgs',
    'BotFulfillmentCodeHookSettingArgsDict',
    'BotFulfillmentStartResponseSpecificationArgs',
    'BotFulfillmentStartResponseSpecificationArgsDict',
    'BotFulfillmentUpdateResponseSpecificationArgs',
    'BotFulfillmentUpdateResponseSpecificationArgsDict',
    'BotFulfillmentUpdatesSpecificationArgs',
    'BotFulfillmentUpdatesSpecificationArgsDict',
    'BotGenerativeAiSettingsBuildtimeSettingsPropertiesDescriptiveBotBuilderSpecificationPropertiesArgs',
    'BotGenerativeAiSettingsBuildtimeSettingsPropertiesDescriptiveBotBuilderSpecificationPropertiesArgsDict',
    'BotGenerativeAiSettingsBuildtimeSettingsPropertiesSampleUtteranceGenerationSpecificationPropertiesArgs',
    'BotGenerativeAiSettingsBuildtimeSettingsPropertiesSampleUtteranceGenerationSpecificationPropertiesArgsDict',
    'BotGenerativeAiSettingsBuildtimeSettingsPropertiesArgs',
    'BotGenerativeAiSettingsBuildtimeSettingsPropertiesArgsDict',
    'BotGenerativeAiSettingsRuntimeSettingsPropertiesNluImprovementSpecificationPropertiesArgs',
    'BotGenerativeAiSettingsRuntimeSettingsPropertiesNluImprovementSpecificationPropertiesArgsDict',
    'BotGenerativeAiSettingsRuntimeSettingsPropertiesSlotResolutionImprovementSpecificationPropertiesArgs',
    'BotGenerativeAiSettingsRuntimeSettingsPropertiesSlotResolutionImprovementSpecificationPropertiesArgsDict',
    'BotGenerativeAiSettingsRuntimeSettingsPropertiesArgs',
    'BotGenerativeAiSettingsRuntimeSettingsPropertiesArgsDict',
    'BotGenerativeAiSettingsArgs',
    'BotGenerativeAiSettingsArgsDict',
    'BotGrammarSlotTypeSettingArgs',
    'BotGrammarSlotTypeSettingArgsDict',
    'BotGrammarSlotTypeSourceArgs',
    'BotGrammarSlotTypeSourceArgsDict',
    'BotImageResponseCardArgs',
    'BotImageResponseCardArgsDict',
    'BotInitialResponseSettingArgs',
    'BotInitialResponseSettingArgsDict',
    'BotInputContextArgs',
    'BotInputContextArgsDict',
    'BotIntentClosingSettingArgs',
    'BotIntentClosingSettingArgsDict',
    'BotIntentConfirmationSettingArgs',
    'BotIntentConfirmationSettingArgsDict',
    'BotIntentOverrideArgs',
    'BotIntentOverrideArgsDict',
    'BotIntentArgs',
    'BotIntentArgsDict',
    'BotKendraConfigurationArgs',
    'BotKendraConfigurationArgsDict',
    'BotLocaleArgs',
    'BotLocaleArgsDict',
    'BotMessageGroupArgs',
    'BotMessageGroupArgsDict',
    'BotMessageArgs',
    'BotMessageArgsDict',
    'BotMultipleValuesSettingArgs',
    'BotMultipleValuesSettingArgsDict',
    'BotObfuscationSettingArgs',
    'BotObfuscationSettingArgsDict',
    'BotOutputContextArgs',
    'BotOutputContextArgsDict',
    'BotPlainTextMessageArgs',
    'BotPlainTextMessageArgsDict',
    'BotPostDialogCodeHookInvocationSpecificationArgs',
    'BotPostDialogCodeHookInvocationSpecificationArgsDict',
    'BotPostFulfillmentStatusSpecificationArgs',
    'BotPostFulfillmentStatusSpecificationArgsDict',
    'BotPromptAttemptSpecificationArgs',
    'BotPromptAttemptSpecificationArgsDict',
    'BotPromptSpecificationArgs',
    'BotPromptSpecificationArgsDict',
    'BotQInConnectIntentConfigurationQInConnectAssistantConfigurationPropertiesArgs',
    'BotQInConnectIntentConfigurationQInConnectAssistantConfigurationPropertiesArgsDict',
    'BotQInConnectIntentConfigurationArgs',
    'BotQInConnectIntentConfigurationArgsDict',
    'BotQnAIntentConfigurationDataSourceConfigurationPropertiesBedrockKnowledgeStoreConfigurationPropertiesBkbExactResponseFieldsPropertiesArgs',
    'BotQnAIntentConfigurationDataSourceConfigurationPropertiesBedrockKnowledgeStoreConfigurationPropertiesBkbExactResponseFieldsPropertiesArgsDict',
    'BotQnAIntentConfigurationDataSourceConfigurationPropertiesBedrockKnowledgeStoreConfigurationPropertiesArgs',
    'BotQnAIntentConfigurationDataSourceConfigurationPropertiesBedrockKnowledgeStoreConfigurationPropertiesArgsDict',
    'BotQnAIntentConfigurationDataSourceConfigurationPropertiesOpensearchConfigurationPropertiesExactResponseFieldsPropertiesArgs',
    'BotQnAIntentConfigurationDataSourceConfigurationPropertiesOpensearchConfigurationPropertiesExactResponseFieldsPropertiesArgsDict',
    'BotQnAIntentConfigurationDataSourceConfigurationPropertiesOpensearchConfigurationPropertiesArgs',
    'BotQnAIntentConfigurationDataSourceConfigurationPropertiesOpensearchConfigurationPropertiesArgsDict',
    'BotQnAIntentConfigurationDataSourceConfigurationPropertiesArgs',
    'BotQnAIntentConfigurationDataSourceConfigurationPropertiesArgsDict',
    'BotQnAIntentConfigurationArgs',
    'BotQnAIntentConfigurationArgsDict',
    'BotQnAKendraConfigurationArgs',
    'BotQnAKendraConfigurationArgsDict',
    'BotReplicationArgs',
    'BotReplicationArgsDict',
    'BotResponseSpecificationArgs',
    'BotResponseSpecificationArgsDict',
    'BotS3BucketLogDestinationArgs',
    'BotS3BucketLogDestinationArgsDict',
    'BotS3LocationArgs',
    'BotS3LocationArgsDict',
    'BotSampleUtteranceArgs',
    'BotSampleUtteranceArgsDict',
    'BotSampleValueArgs',
    'BotSampleValueArgsDict',
    'BotSessionAttributeArgs',
    'BotSessionAttributeArgsDict',
    'BotSlotCaptureSettingArgs',
    'BotSlotCaptureSettingArgsDict',
    'BotSlotDefaultValueSpecificationArgs',
    'BotSlotDefaultValueSpecificationArgsDict',
    'BotSlotDefaultValueArgs',
    'BotSlotDefaultValueArgsDict',
    'BotSlotPriorityArgs',
    'BotSlotPriorityArgsDict',
    'BotSlotTypeValueArgs',
    'BotSlotTypeValueArgsDict',
    'BotSlotTypeArgs',
    'BotSlotTypeArgsDict',
    'BotSlotValueElicitationSettingArgs',
    'BotSlotValueElicitationSettingArgsDict',
    'BotSlotValueOverrideMapArgs',
    'BotSlotValueOverrideMapArgsDict',
    'BotSlotValueOverrideArgs',
    'BotSlotValueOverrideArgsDict',
    'BotSlotValueRegexFilterArgs',
    'BotSlotValueRegexFilterArgsDict',
    'BotSlotValueSelectionSettingArgs',
    'BotSlotValueSelectionSettingArgsDict',
    'BotSlotValueArgs',
    'BotSlotValueArgsDict',
    'BotSlotArgs',
    'BotSlotArgsDict',
    'BotSpecificationsArgs',
    'BotSpecificationsArgsDict',
    'BotSsmlMessageArgs',
    'BotSsmlMessageArgsDict',
    'BotStillWaitingResponseSpecificationArgs',
    'BotStillWaitingResponseSpecificationArgsDict',
    'BotSubSlotSettingArgs',
    'BotSubSlotSettingArgsDict',
    'BotSubSlotTypeCompositionArgs',
    'BotSubSlotTypeCompositionArgsDict',
    'BotSubSlotValueElicitationSettingArgs',
    'BotSubSlotValueElicitationSettingArgsDict',
    'BotTagArgs',
    'BotTagArgsDict',
    'BotTestBotAliasSettingsSentimentAnalysisSettingsPropertiesArgs',
    'BotTestBotAliasSettingsSentimentAnalysisSettingsPropertiesArgsDict',
    'BotTestBotAliasSettingsArgs',
    'BotTestBotAliasSettingsArgsDict',
    'BotTextInputSpecificationArgs',
    'BotTextInputSpecificationArgsDict',
    'BotTextLogDestinationArgs',
    'BotTextLogDestinationArgsDict',
    'BotTextLogSettingArgs',
    'BotTextLogSettingArgsDict',
    'BotVersionLocaleDetailsArgs',
    'BotVersionLocaleDetailsArgsDict',
    'BotVersionLocaleSpecificationArgs',
    'BotVersionLocaleSpecificationArgsDict',
    'BotVoiceSettingsArgs',
    'BotVoiceSettingsArgsDict',
    'BotWaitAndContinueSpecificationArgs',
    'BotWaitAndContinueSpecificationArgsDict',
    'DataPrivacyPropertiesArgs',
    'DataPrivacyPropertiesArgsDict',
    'ErrorLogSettingsPropertiesArgs',
    'ErrorLogSettingsPropertiesArgsDict',
    'ResourcePolicyPolicyArgs',
    'ResourcePolicyPolicyArgsDict',
    'SentimentAnalysisSettingsPropertiesArgs',
    'SentimentAnalysisSettingsPropertiesArgsDict',
]

MYPY = False

if not MYPY:
    class BotAdvancedRecognitionSettingArgsDict(TypedDict):
        audio_recognition_strategy: NotRequired[pulumi.Input['BotAudioRecognitionStrategy']]
        """
        Enables using the slot values as a custom vocabulary for recognizing user utterances.
        """
elif False:
    BotAdvancedRecognitionSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotAdvancedRecognitionSettingArgs:
    def __init__(__self__, *,
                 audio_recognition_strategy: Optional[pulumi.Input['BotAudioRecognitionStrategy']] = None):
        """
        :param pulumi.Input['BotAudioRecognitionStrategy'] audio_recognition_strategy: Enables using the slot values as a custom vocabulary for recognizing user utterances.
        """
        if audio_recognition_strategy is not None:
            pulumi.set(__self__, "audio_recognition_strategy", audio_recognition_strategy)

    @_builtins.property
    @pulumi.getter(name="audioRecognitionStrategy")
    def audio_recognition_strategy(self) -> Optional[pulumi.Input['BotAudioRecognitionStrategy']]:
        """
        Enables using the slot values as a custom vocabulary for recognizing user utterances.
        """
        return pulumi.get(self, "audio_recognition_strategy")

    @audio_recognition_strategy.setter
    def audio_recognition_strategy(self, value: Optional[pulumi.Input['BotAudioRecognitionStrategy']]):
        pulumi.set(self, "audio_recognition_strategy", value)


if not MYPY:
    class BotAliasAudioLogDestinationArgsDict(TypedDict):
        """
        The location of audio log files collected when conversation logging is enabled for a bot.
        """
        s3_bucket: pulumi.Input['BotAliasS3BucketLogDestinationArgsDict']
elif False:
    BotAliasAudioLogDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotAliasAudioLogDestinationArgs:
    def __init__(__self__, *,
                 s3_bucket: pulumi.Input['BotAliasS3BucketLogDestinationArgs']):
        """
        The location of audio log files collected when conversation logging is enabled for a bot.
        """
        pulumi.set(__self__, "s3_bucket", s3_bucket)

    @_builtins.property
    @pulumi.getter(name="s3Bucket")
    def s3_bucket(self) -> pulumi.Input['BotAliasS3BucketLogDestinationArgs']:
        return pulumi.get(self, "s3_bucket")

    @s3_bucket.setter
    def s3_bucket(self, value: pulumi.Input['BotAliasS3BucketLogDestinationArgs']):
        pulumi.set(self, "s3_bucket", value)


if not MYPY:
    class BotAliasAudioLogSettingArgsDict(TypedDict):
        """
        Settings for logging audio of conversations between Amazon Lex and a user. You specify whether to log audio and the Amazon S3 bucket where the audio file is stored.
        """
        destination: pulumi.Input['BotAliasAudioLogDestinationArgsDict']
        enabled: pulumi.Input[_builtins.bool]
elif False:
    BotAliasAudioLogSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotAliasAudioLogSettingArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input['BotAliasAudioLogDestinationArgs'],
                 enabled: pulumi.Input[_builtins.bool]):
        """
        Settings for logging audio of conversations between Amazon Lex and a user. You specify whether to log audio and the Amazon S3 bucket where the audio file is stored.
        """
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> pulumi.Input['BotAliasAudioLogDestinationArgs']:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input['BotAliasAudioLogDestinationArgs']):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class BotAliasCloudWatchLogGroupLogDestinationArgsDict(TypedDict):
        cloud_watch_log_group_arn: pulumi.Input[_builtins.str]
        """
        A string used to identify the groupArn for the Cloudwatch Log Group
        """
        log_prefix: pulumi.Input[_builtins.str]
        """
        A string containing the value for the Log Prefix
        """
elif False:
    BotAliasCloudWatchLogGroupLogDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotAliasCloudWatchLogGroupLogDestinationArgs:
    def __init__(__self__, *,
                 cloud_watch_log_group_arn: pulumi.Input[_builtins.str],
                 log_prefix: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] cloud_watch_log_group_arn: A string used to identify the groupArn for the Cloudwatch Log Group
        :param pulumi.Input[_builtins.str] log_prefix: A string containing the value for the Log Prefix
        """
        pulumi.set(__self__, "cloud_watch_log_group_arn", cloud_watch_log_group_arn)
        pulumi.set(__self__, "log_prefix", log_prefix)

    @_builtins.property
    @pulumi.getter(name="cloudWatchLogGroupArn")
    def cloud_watch_log_group_arn(self) -> pulumi.Input[_builtins.str]:
        """
        A string used to identify the groupArn for the Cloudwatch Log Group
        """
        return pulumi.get(self, "cloud_watch_log_group_arn")

    @cloud_watch_log_group_arn.setter
    def cloud_watch_log_group_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cloud_watch_log_group_arn", value)

    @_builtins.property
    @pulumi.getter(name="logPrefix")
    def log_prefix(self) -> pulumi.Input[_builtins.str]:
        """
        A string containing the value for the Log Prefix
        """
        return pulumi.get(self, "log_prefix")

    @log_prefix.setter
    def log_prefix(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_prefix", value)


if not MYPY:
    class BotAliasCodeHookSpecificationArgsDict(TypedDict):
        """
        Contains information about code hooks that Amazon Lex calls during a conversation.
        """
        lambda_code_hook: pulumi.Input['BotAliasLambdaCodeHookArgsDict']
elif False:
    BotAliasCodeHookSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotAliasCodeHookSpecificationArgs:
    def __init__(__self__, *,
                 lambda_code_hook: pulumi.Input['BotAliasLambdaCodeHookArgs']):
        """
        Contains information about code hooks that Amazon Lex calls during a conversation.
        """
        pulumi.set(__self__, "lambda_code_hook", lambda_code_hook)

    @_builtins.property
    @pulumi.getter(name="lambdaCodeHook")
    def lambda_code_hook(self) -> pulumi.Input['BotAliasLambdaCodeHookArgs']:
        return pulumi.get(self, "lambda_code_hook")

    @lambda_code_hook.setter
    def lambda_code_hook(self, value: pulumi.Input['BotAliasLambdaCodeHookArgs']):
        pulumi.set(self, "lambda_code_hook", value)


if not MYPY:
    class BotAliasConversationLogSettingsArgsDict(TypedDict):
        """
        Contains information about code hooks that Amazon Lex calls during a conversation.
        """
        audio_log_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['BotAliasAudioLogSettingArgsDict']]]]
        """
        The Amazon S3 settings for logging audio to an S3 bucket.
        """
        text_log_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['BotAliasTextLogSettingArgsDict']]]]
        """
        The Amazon CloudWatch Logs settings for logging text and metadata.
        """
elif False:
    BotAliasConversationLogSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotAliasConversationLogSettingsArgs:
    def __init__(__self__, *,
                 audio_log_settings: Optional[pulumi.Input[Sequence[pulumi.Input['BotAliasAudioLogSettingArgs']]]] = None,
                 text_log_settings: Optional[pulumi.Input[Sequence[pulumi.Input['BotAliasTextLogSettingArgs']]]] = None):
        """
        Contains information about code hooks that Amazon Lex calls during a conversation.
        :param pulumi.Input[Sequence[pulumi.Input['BotAliasAudioLogSettingArgs']]] audio_log_settings: The Amazon S3 settings for logging audio to an S3 bucket.
        :param pulumi.Input[Sequence[pulumi.Input['BotAliasTextLogSettingArgs']]] text_log_settings: The Amazon CloudWatch Logs settings for logging text and metadata.
        """
        if audio_log_settings is not None:
            pulumi.set(__self__, "audio_log_settings", audio_log_settings)
        if text_log_settings is not None:
            pulumi.set(__self__, "text_log_settings", text_log_settings)

    @_builtins.property
    @pulumi.getter(name="audioLogSettings")
    def audio_log_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotAliasAudioLogSettingArgs']]]]:
        """
        The Amazon S3 settings for logging audio to an S3 bucket.
        """
        return pulumi.get(self, "audio_log_settings")

    @audio_log_settings.setter
    def audio_log_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotAliasAudioLogSettingArgs']]]]):
        pulumi.set(self, "audio_log_settings", value)

    @_builtins.property
    @pulumi.getter(name="textLogSettings")
    def text_log_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotAliasTextLogSettingArgs']]]]:
        """
        The Amazon CloudWatch Logs settings for logging text and metadata.
        """
        return pulumi.get(self, "text_log_settings")

    @text_log_settings.setter
    def text_log_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotAliasTextLogSettingArgs']]]]):
        pulumi.set(self, "text_log_settings", value)


if not MYPY:
    class BotAliasLambdaCodeHookArgsDict(TypedDict):
        """
        Contains information about code hooks that Amazon Lex calls during a conversation.
        """
        code_hook_interface_version: pulumi.Input[_builtins.str]
        """
        The version of the request-response that you want Amazon Lex to use to invoke your Lambda function.
        """
        lambda_arn: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name (ARN) of the Lambda function.
        """
elif False:
    BotAliasLambdaCodeHookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotAliasLambdaCodeHookArgs:
    def __init__(__self__, *,
                 code_hook_interface_version: pulumi.Input[_builtins.str],
                 lambda_arn: pulumi.Input[_builtins.str]):
        """
        Contains information about code hooks that Amazon Lex calls during a conversation.
        :param pulumi.Input[_builtins.str] code_hook_interface_version: The version of the request-response that you want Amazon Lex to use to invoke your Lambda function.
        :param pulumi.Input[_builtins.str] lambda_arn: The Amazon Resource Name (ARN) of the Lambda function.
        """
        pulumi.set(__self__, "code_hook_interface_version", code_hook_interface_version)
        pulumi.set(__self__, "lambda_arn", lambda_arn)

    @_builtins.property
    @pulumi.getter(name="codeHookInterfaceVersion")
    def code_hook_interface_version(self) -> pulumi.Input[_builtins.str]:
        """
        The version of the request-response that you want Amazon Lex to use to invoke your Lambda function.
        """
        return pulumi.get(self, "code_hook_interface_version")

    @code_hook_interface_version.setter
    def code_hook_interface_version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "code_hook_interface_version", value)

    @_builtins.property
    @pulumi.getter(name="lambdaArn")
    def lambda_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the Lambda function.
        """
        return pulumi.get(self, "lambda_arn")

    @lambda_arn.setter
    def lambda_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "lambda_arn", value)


if not MYPY:
    class BotAliasLocaleSettingsItemArgsDict(TypedDict):
        """
        A locale setting in alias
        """
        bot_alias_locale_setting: pulumi.Input['BotAliasLocaleSettingsArgsDict']
        locale_id: pulumi.Input[_builtins.str]
        """
        A string used to identify the locale
        """
elif False:
    BotAliasLocaleSettingsItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotAliasLocaleSettingsItemArgs:
    def __init__(__self__, *,
                 bot_alias_locale_setting: pulumi.Input['BotAliasLocaleSettingsArgs'],
                 locale_id: pulumi.Input[_builtins.str]):
        """
        A locale setting in alias
        :param pulumi.Input[_builtins.str] locale_id: A string used to identify the locale
        """
        pulumi.set(__self__, "bot_alias_locale_setting", bot_alias_locale_setting)
        pulumi.set(__self__, "locale_id", locale_id)

    @_builtins.property
    @pulumi.getter(name="botAliasLocaleSetting")
    def bot_alias_locale_setting(self) -> pulumi.Input['BotAliasLocaleSettingsArgs']:
        return pulumi.get(self, "bot_alias_locale_setting")

    @bot_alias_locale_setting.setter
    def bot_alias_locale_setting(self, value: pulumi.Input['BotAliasLocaleSettingsArgs']):
        pulumi.set(self, "bot_alias_locale_setting", value)

    @_builtins.property
    @pulumi.getter(name="localeId")
    def locale_id(self) -> pulumi.Input[_builtins.str]:
        """
        A string used to identify the locale
        """
        return pulumi.get(self, "locale_id")

    @locale_id.setter
    def locale_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "locale_id", value)


if not MYPY:
    class BotAliasLocaleSettingsArgsDict(TypedDict):
        """
        You can use this parameter to specify a specific Lambda function to run different functions in different locales.
        """
        enabled: pulumi.Input[_builtins.bool]
        """
        Whether the Lambda code hook is enabled
        """
        code_hook_specification: NotRequired[pulumi.Input['BotAliasCodeHookSpecificationArgsDict']]
elif False:
    BotAliasLocaleSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotAliasLocaleSettingsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 code_hook_specification: Optional[pulumi.Input['BotAliasCodeHookSpecificationArgs']] = None):
        """
        You can use this parameter to specify a specific Lambda function to run different functions in different locales.
        :param pulumi.Input[_builtins.bool] enabled: Whether the Lambda code hook is enabled
        """
        pulumi.set(__self__, "enabled", enabled)
        if code_hook_specification is not None:
            pulumi.set(__self__, "code_hook_specification", code_hook_specification)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether the Lambda code hook is enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="codeHookSpecification")
    def code_hook_specification(self) -> Optional[pulumi.Input['BotAliasCodeHookSpecificationArgs']]:
        return pulumi.get(self, "code_hook_specification")

    @code_hook_specification.setter
    def code_hook_specification(self, value: Optional[pulumi.Input['BotAliasCodeHookSpecificationArgs']]):
        pulumi.set(self, "code_hook_specification", value)


if not MYPY:
    class BotAliasS3BucketLogDestinationArgsDict(TypedDict):
        """
        Specifies an Amazon S3 bucket for logging audio conversations
        """
        log_prefix: pulumi.Input[_builtins.str]
        """
        The Amazon S3 key of the deployment package.
        """
        s3_bucket_arn: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name (ARN) of an Amazon S3 bucket where audio log files are stored.
        """
        kms_key_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Amazon Resource Name (ARN) of an AWS Key Management Service (KMS) key for encrypting audio log files stored in an S3 bucket.
        """
elif False:
    BotAliasS3BucketLogDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotAliasS3BucketLogDestinationArgs:
    def __init__(__self__, *,
                 log_prefix: pulumi.Input[_builtins.str],
                 s3_bucket_arn: pulumi.Input[_builtins.str],
                 kms_key_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Specifies an Amazon S3 bucket for logging audio conversations
        :param pulumi.Input[_builtins.str] log_prefix: The Amazon S3 key of the deployment package.
        :param pulumi.Input[_builtins.str] s3_bucket_arn: The Amazon Resource Name (ARN) of an Amazon S3 bucket where audio log files are stored.
        :param pulumi.Input[_builtins.str] kms_key_arn: The Amazon Resource Name (ARN) of an AWS Key Management Service (KMS) key for encrypting audio log files stored in an S3 bucket.
        """
        pulumi.set(__self__, "log_prefix", log_prefix)
        pulumi.set(__self__, "s3_bucket_arn", s3_bucket_arn)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @_builtins.property
    @pulumi.getter(name="logPrefix")
    def log_prefix(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon S3 key of the deployment package.
        """
        return pulumi.get(self, "log_prefix")

    @log_prefix.setter
    def log_prefix(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_prefix", value)

    @_builtins.property
    @pulumi.getter(name="s3BucketArn")
    def s3_bucket_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of an Amazon S3 bucket where audio log files are stored.
        """
        return pulumi.get(self, "s3_bucket_arn")

    @s3_bucket_arn.setter
    def s3_bucket_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "s3_bucket_arn", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Amazon Resource Name (ARN) of an AWS Key Management Service (KMS) key for encrypting audio log files stored in an S3 bucket.
        """
        return pulumi.get(self, "kms_key_arn")

    @kms_key_arn.setter
    def kms_key_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_arn", value)


if not MYPY:
    class BotAliasTagArgsDict(TypedDict):
        """
        A label for tagging Lex resources
        """
        key: pulumi.Input[_builtins.str]
        """
        A string used to identify this tag
        """
        value: pulumi.Input[_builtins.str]
        """
        A string containing the value for the tag
        """
elif False:
    BotAliasTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotAliasTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        A label for tagging Lex resources
        :param pulumi.Input[_builtins.str] key: A string used to identify this tag
        :param pulumi.Input[_builtins.str] value: A string containing the value for the tag
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        A string used to identify this tag
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        A string containing the value for the tag
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class BotAliasTextLogDestinationArgsDict(TypedDict):
        """
        Defines the Amazon CloudWatch Logs destination log group for conversation text logs.
        """
        cloud_watch: pulumi.Input['BotAliasCloudWatchLogGroupLogDestinationArgsDict']
elif False:
    BotAliasTextLogDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotAliasTextLogDestinationArgs:
    def __init__(__self__, *,
                 cloud_watch: pulumi.Input['BotAliasCloudWatchLogGroupLogDestinationArgs']):
        """
        Defines the Amazon CloudWatch Logs destination log group for conversation text logs.
        """
        pulumi.set(__self__, "cloud_watch", cloud_watch)

    @_builtins.property
    @pulumi.getter(name="cloudWatch")
    def cloud_watch(self) -> pulumi.Input['BotAliasCloudWatchLogGroupLogDestinationArgs']:
        return pulumi.get(self, "cloud_watch")

    @cloud_watch.setter
    def cloud_watch(self, value: pulumi.Input['BotAliasCloudWatchLogGroupLogDestinationArgs']):
        pulumi.set(self, "cloud_watch", value)


if not MYPY:
    class BotAliasTextLogSettingArgsDict(TypedDict):
        """
        Contains information about code hooks that Amazon Lex calls during a conversation.
        """
        destination: pulumi.Input['BotAliasTextLogDestinationArgsDict']
        enabled: pulumi.Input[_builtins.bool]
elif False:
    BotAliasTextLogSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotAliasTextLogSettingArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input['BotAliasTextLogDestinationArgs'],
                 enabled: pulumi.Input[_builtins.bool]):
        """
        Contains information about code hooks that Amazon Lex calls during a conversation.
        """
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> pulumi.Input['BotAliasTextLogDestinationArgs']:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input['BotAliasTextLogDestinationArgs']):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class BotAllowedInputTypesArgsDict(TypedDict):
        allow_audio_input: pulumi.Input[_builtins.bool]
        allow_dtmf_input: pulumi.Input[_builtins.bool]
elif False:
    BotAllowedInputTypesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotAllowedInputTypesArgs:
    def __init__(__self__, *,
                 allow_audio_input: pulumi.Input[_builtins.bool],
                 allow_dtmf_input: pulumi.Input[_builtins.bool]):
        pulumi.set(__self__, "allow_audio_input", allow_audio_input)
        pulumi.set(__self__, "allow_dtmf_input", allow_dtmf_input)

    @_builtins.property
    @pulumi.getter(name="allowAudioInput")
    def allow_audio_input(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "allow_audio_input")

    @allow_audio_input.setter
    def allow_audio_input(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "allow_audio_input", value)

    @_builtins.property
    @pulumi.getter(name="allowDtmfInput")
    def allow_dtmf_input(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "allow_dtmf_input")

    @allow_dtmf_input.setter
    def allow_dtmf_input(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "allow_dtmf_input", value)


if not MYPY:
    class BotAudioAndDtmfInputSpecificationArgsDict(TypedDict):
        start_timeout_ms: pulumi.Input[_builtins.int]
        audio_specification: NotRequired[pulumi.Input['BotAudioSpecificationArgsDict']]
        dtmf_specification: NotRequired[pulumi.Input['BotDtmfSpecificationArgsDict']]
elif False:
    BotAudioAndDtmfInputSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotAudioAndDtmfInputSpecificationArgs:
    def __init__(__self__, *,
                 start_timeout_ms: pulumi.Input[_builtins.int],
                 audio_specification: Optional[pulumi.Input['BotAudioSpecificationArgs']] = None,
                 dtmf_specification: Optional[pulumi.Input['BotDtmfSpecificationArgs']] = None):
        pulumi.set(__self__, "start_timeout_ms", start_timeout_ms)
        if audio_specification is not None:
            pulumi.set(__self__, "audio_specification", audio_specification)
        if dtmf_specification is not None:
            pulumi.set(__self__, "dtmf_specification", dtmf_specification)

    @_builtins.property
    @pulumi.getter(name="startTimeoutMs")
    def start_timeout_ms(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "start_timeout_ms")

    @start_timeout_ms.setter
    def start_timeout_ms(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "start_timeout_ms", value)

    @_builtins.property
    @pulumi.getter(name="audioSpecification")
    def audio_specification(self) -> Optional[pulumi.Input['BotAudioSpecificationArgs']]:
        return pulumi.get(self, "audio_specification")

    @audio_specification.setter
    def audio_specification(self, value: Optional[pulumi.Input['BotAudioSpecificationArgs']]):
        pulumi.set(self, "audio_specification", value)

    @_builtins.property
    @pulumi.getter(name="dtmfSpecification")
    def dtmf_specification(self) -> Optional[pulumi.Input['BotDtmfSpecificationArgs']]:
        return pulumi.get(self, "dtmf_specification")

    @dtmf_specification.setter
    def dtmf_specification(self, value: Optional[pulumi.Input['BotDtmfSpecificationArgs']]):
        pulumi.set(self, "dtmf_specification", value)


if not MYPY:
    class BotAudioLogDestinationArgsDict(TypedDict):
        s3_bucket: pulumi.Input['BotS3BucketLogDestinationArgsDict']
elif False:
    BotAudioLogDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotAudioLogDestinationArgs:
    def __init__(__self__, *,
                 s3_bucket: pulumi.Input['BotS3BucketLogDestinationArgs']):
        pulumi.set(__self__, "s3_bucket", s3_bucket)

    @_builtins.property
    @pulumi.getter(name="s3Bucket")
    def s3_bucket(self) -> pulumi.Input['BotS3BucketLogDestinationArgs']:
        return pulumi.get(self, "s3_bucket")

    @s3_bucket.setter
    def s3_bucket(self, value: pulumi.Input['BotS3BucketLogDestinationArgs']):
        pulumi.set(self, "s3_bucket", value)


if not MYPY:
    class BotAudioLogSettingArgsDict(TypedDict):
        destination: pulumi.Input['BotAudioLogDestinationArgsDict']
        enabled: pulumi.Input[_builtins.bool]
elif False:
    BotAudioLogSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotAudioLogSettingArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input['BotAudioLogDestinationArgs'],
                 enabled: pulumi.Input[_builtins.bool]):
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> pulumi.Input['BotAudioLogDestinationArgs']:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input['BotAudioLogDestinationArgs']):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class BotAudioSpecificationArgsDict(TypedDict):
        end_timeout_ms: pulumi.Input[_builtins.int]
        max_length_ms: pulumi.Input[_builtins.int]
elif False:
    BotAudioSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotAudioSpecificationArgs:
    def __init__(__self__, *,
                 end_timeout_ms: pulumi.Input[_builtins.int],
                 max_length_ms: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "end_timeout_ms", end_timeout_ms)
        pulumi.set(__self__, "max_length_ms", max_length_ms)

    @_builtins.property
    @pulumi.getter(name="endTimeoutMs")
    def end_timeout_ms(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "end_timeout_ms")

    @end_timeout_ms.setter
    def end_timeout_ms(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "end_timeout_ms", value)

    @_builtins.property
    @pulumi.getter(name="maxLengthMs")
    def max_length_ms(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "max_length_ms")

    @max_length_ms.setter
    def max_length_ms(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max_length_ms", value)


if not MYPY:
    class BotBedrockAgentIntentConfigurationBedrockAgentConfigurationPropertiesArgsDict(TypedDict):
        bedrock_agent_alias_id: NotRequired[pulumi.Input[_builtins.str]]
        bedrock_agent_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    BotBedrockAgentIntentConfigurationBedrockAgentConfigurationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotBedrockAgentIntentConfigurationBedrockAgentConfigurationPropertiesArgs:
    def __init__(__self__, *,
                 bedrock_agent_alias_id: Optional[pulumi.Input[_builtins.str]] = None,
                 bedrock_agent_id: Optional[pulumi.Input[_builtins.str]] = None):
        if bedrock_agent_alias_id is not None:
            pulumi.set(__self__, "bedrock_agent_alias_id", bedrock_agent_alias_id)
        if bedrock_agent_id is not None:
            pulumi.set(__self__, "bedrock_agent_id", bedrock_agent_id)

    @_builtins.property
    @pulumi.getter(name="bedrockAgentAliasId")
    def bedrock_agent_alias_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "bedrock_agent_alias_id")

    @bedrock_agent_alias_id.setter
    def bedrock_agent_alias_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bedrock_agent_alias_id", value)

    @_builtins.property
    @pulumi.getter(name="bedrockAgentId")
    def bedrock_agent_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "bedrock_agent_id")

    @bedrock_agent_id.setter
    def bedrock_agent_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bedrock_agent_id", value)


if not MYPY:
    class BotBedrockAgentIntentConfigurationBedrockAgentIntentKnowledgeBaseConfigurationPropertiesArgsDict(TypedDict):
        bedrock_knowledge_base_arn: pulumi.Input[_builtins.str]
        bedrock_model_configuration: pulumi.Input['BotBedrockModelSpecificationArgsDict']
elif False:
    BotBedrockAgentIntentConfigurationBedrockAgentIntentKnowledgeBaseConfigurationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotBedrockAgentIntentConfigurationBedrockAgentIntentKnowledgeBaseConfigurationPropertiesArgs:
    def __init__(__self__, *,
                 bedrock_knowledge_base_arn: pulumi.Input[_builtins.str],
                 bedrock_model_configuration: pulumi.Input['BotBedrockModelSpecificationArgs']):
        pulumi.set(__self__, "bedrock_knowledge_base_arn", bedrock_knowledge_base_arn)
        pulumi.set(__self__, "bedrock_model_configuration", bedrock_model_configuration)

    @_builtins.property
    @pulumi.getter(name="bedrockKnowledgeBaseArn")
    def bedrock_knowledge_base_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "bedrock_knowledge_base_arn")

    @bedrock_knowledge_base_arn.setter
    def bedrock_knowledge_base_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bedrock_knowledge_base_arn", value)

    @_builtins.property
    @pulumi.getter(name="bedrockModelConfiguration")
    def bedrock_model_configuration(self) -> pulumi.Input['BotBedrockModelSpecificationArgs']:
        return pulumi.get(self, "bedrock_model_configuration")

    @bedrock_model_configuration.setter
    def bedrock_model_configuration(self, value: pulumi.Input['BotBedrockModelSpecificationArgs']):
        pulumi.set(self, "bedrock_model_configuration", value)


if not MYPY:
    class BotBedrockAgentIntentConfigurationArgsDict(TypedDict):
        bedrock_agent_configuration: NotRequired[pulumi.Input['BotBedrockAgentIntentConfigurationBedrockAgentConfigurationPropertiesArgsDict']]
        bedrock_agent_intent_knowledge_base_configuration: NotRequired[pulumi.Input['BotBedrockAgentIntentConfigurationBedrockAgentIntentKnowledgeBaseConfigurationPropertiesArgsDict']]
elif False:
    BotBedrockAgentIntentConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotBedrockAgentIntentConfigurationArgs:
    def __init__(__self__, *,
                 bedrock_agent_configuration: Optional[pulumi.Input['BotBedrockAgentIntentConfigurationBedrockAgentConfigurationPropertiesArgs']] = None,
                 bedrock_agent_intent_knowledge_base_configuration: Optional[pulumi.Input['BotBedrockAgentIntentConfigurationBedrockAgentIntentKnowledgeBaseConfigurationPropertiesArgs']] = None):
        if bedrock_agent_configuration is not None:
            pulumi.set(__self__, "bedrock_agent_configuration", bedrock_agent_configuration)
        if bedrock_agent_intent_knowledge_base_configuration is not None:
            pulumi.set(__self__, "bedrock_agent_intent_knowledge_base_configuration", bedrock_agent_intent_knowledge_base_configuration)

    @_builtins.property
    @pulumi.getter(name="bedrockAgentConfiguration")
    def bedrock_agent_configuration(self) -> Optional[pulumi.Input['BotBedrockAgentIntentConfigurationBedrockAgentConfigurationPropertiesArgs']]:
        return pulumi.get(self, "bedrock_agent_configuration")

    @bedrock_agent_configuration.setter
    def bedrock_agent_configuration(self, value: Optional[pulumi.Input['BotBedrockAgentIntentConfigurationBedrockAgentConfigurationPropertiesArgs']]):
        pulumi.set(self, "bedrock_agent_configuration", value)

    @_builtins.property
    @pulumi.getter(name="bedrockAgentIntentKnowledgeBaseConfiguration")
    def bedrock_agent_intent_knowledge_base_configuration(self) -> Optional[pulumi.Input['BotBedrockAgentIntentConfigurationBedrockAgentIntentKnowledgeBaseConfigurationPropertiesArgs']]:
        return pulumi.get(self, "bedrock_agent_intent_knowledge_base_configuration")

    @bedrock_agent_intent_knowledge_base_configuration.setter
    def bedrock_agent_intent_knowledge_base_configuration(self, value: Optional[pulumi.Input['BotBedrockAgentIntentConfigurationBedrockAgentIntentKnowledgeBaseConfigurationPropertiesArgs']]):
        pulumi.set(self, "bedrock_agent_intent_knowledge_base_configuration", value)


if not MYPY:
    class BotBedrockModelSpecificationBedrockGuardrailConfigurationPropertiesArgsDict(TypedDict):
        bedrock_guardrail_identifier: NotRequired[pulumi.Input[_builtins.str]]
        bedrock_guardrail_version: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    BotBedrockModelSpecificationBedrockGuardrailConfigurationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotBedrockModelSpecificationBedrockGuardrailConfigurationPropertiesArgs:
    def __init__(__self__, *,
                 bedrock_guardrail_identifier: Optional[pulumi.Input[_builtins.str]] = None,
                 bedrock_guardrail_version: Optional[pulumi.Input[_builtins.str]] = None):
        if bedrock_guardrail_identifier is not None:
            pulumi.set(__self__, "bedrock_guardrail_identifier", bedrock_guardrail_identifier)
        if bedrock_guardrail_version is not None:
            pulumi.set(__self__, "bedrock_guardrail_version", bedrock_guardrail_version)

    @_builtins.property
    @pulumi.getter(name="bedrockGuardrailIdentifier")
    def bedrock_guardrail_identifier(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "bedrock_guardrail_identifier")

    @bedrock_guardrail_identifier.setter
    def bedrock_guardrail_identifier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bedrock_guardrail_identifier", value)

    @_builtins.property
    @pulumi.getter(name="bedrockGuardrailVersion")
    def bedrock_guardrail_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "bedrock_guardrail_version")

    @bedrock_guardrail_version.setter
    def bedrock_guardrail_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bedrock_guardrail_version", value)


if not MYPY:
    class BotBedrockModelSpecificationArgsDict(TypedDict):
        model_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the foundation model used in descriptive bot building.
        """
        bedrock_guardrail_configuration: NotRequired[pulumi.Input['BotBedrockModelSpecificationBedrockGuardrailConfigurationPropertiesArgsDict']]
        bedrock_model_custom_prompt: NotRequired[pulumi.Input[_builtins.str]]
        bedrock_trace_status: NotRequired[pulumi.Input['BotBedrockModelSpecificationBedrockTraceStatus']]
elif False:
    BotBedrockModelSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotBedrockModelSpecificationArgs:
    def __init__(__self__, *,
                 model_arn: pulumi.Input[_builtins.str],
                 bedrock_guardrail_configuration: Optional[pulumi.Input['BotBedrockModelSpecificationBedrockGuardrailConfigurationPropertiesArgs']] = None,
                 bedrock_model_custom_prompt: Optional[pulumi.Input[_builtins.str]] = None,
                 bedrock_trace_status: Optional[pulumi.Input['BotBedrockModelSpecificationBedrockTraceStatus']] = None):
        """
        :param pulumi.Input[_builtins.str] model_arn: The ARN of the foundation model used in descriptive bot building.
        """
        pulumi.set(__self__, "model_arn", model_arn)
        if bedrock_guardrail_configuration is not None:
            pulumi.set(__self__, "bedrock_guardrail_configuration", bedrock_guardrail_configuration)
        if bedrock_model_custom_prompt is not None:
            pulumi.set(__self__, "bedrock_model_custom_prompt", bedrock_model_custom_prompt)
        if bedrock_trace_status is not None:
            pulumi.set(__self__, "bedrock_trace_status", bedrock_trace_status)

    @_builtins.property
    @pulumi.getter(name="modelArn")
    def model_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the foundation model used in descriptive bot building.
        """
        return pulumi.get(self, "model_arn")

    @model_arn.setter
    def model_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "model_arn", value)

    @_builtins.property
    @pulumi.getter(name="bedrockGuardrailConfiguration")
    def bedrock_guardrail_configuration(self) -> Optional[pulumi.Input['BotBedrockModelSpecificationBedrockGuardrailConfigurationPropertiesArgs']]:
        return pulumi.get(self, "bedrock_guardrail_configuration")

    @bedrock_guardrail_configuration.setter
    def bedrock_guardrail_configuration(self, value: Optional[pulumi.Input['BotBedrockModelSpecificationBedrockGuardrailConfigurationPropertiesArgs']]):
        pulumi.set(self, "bedrock_guardrail_configuration", value)

    @_builtins.property
    @pulumi.getter(name="bedrockModelCustomPrompt")
    def bedrock_model_custom_prompt(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "bedrock_model_custom_prompt")

    @bedrock_model_custom_prompt.setter
    def bedrock_model_custom_prompt(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bedrock_model_custom_prompt", value)

    @_builtins.property
    @pulumi.getter(name="bedrockTraceStatus")
    def bedrock_trace_status(self) -> Optional[pulumi.Input['BotBedrockModelSpecificationBedrockTraceStatus']]:
        return pulumi.get(self, "bedrock_trace_status")

    @bedrock_trace_status.setter
    def bedrock_trace_status(self, value: Optional[pulumi.Input['BotBedrockModelSpecificationBedrockTraceStatus']]):
        pulumi.set(self, "bedrock_trace_status", value)


if not MYPY:
    class BotButtonArgsDict(TypedDict):
        text: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    BotButtonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotButtonArgs:
    def __init__(__self__, *,
                 text: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "text", text)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "text", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class BotCloudWatchLogGroupLogDestinationArgsDict(TypedDict):
        cloud_watch_log_group_arn: pulumi.Input[_builtins.str]
        log_prefix: pulumi.Input[_builtins.str]
elif False:
    BotCloudWatchLogGroupLogDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotCloudWatchLogGroupLogDestinationArgs:
    def __init__(__self__, *,
                 cloud_watch_log_group_arn: pulumi.Input[_builtins.str],
                 log_prefix: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "cloud_watch_log_group_arn", cloud_watch_log_group_arn)
        pulumi.set(__self__, "log_prefix", log_prefix)

    @_builtins.property
    @pulumi.getter(name="cloudWatchLogGroupArn")
    def cloud_watch_log_group_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "cloud_watch_log_group_arn")

    @cloud_watch_log_group_arn.setter
    def cloud_watch_log_group_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cloud_watch_log_group_arn", value)

    @_builtins.property
    @pulumi.getter(name="logPrefix")
    def log_prefix(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "log_prefix")

    @log_prefix.setter
    def log_prefix(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_prefix", value)


if not MYPY:
    class BotCompositeSlotTypeSettingArgsDict(TypedDict):
        sub_slots: NotRequired[pulumi.Input[Sequence[pulumi.Input['BotSubSlotTypeCompositionArgsDict']]]]
        """
        Subslots in the composite slot.
        """
elif False:
    BotCompositeSlotTypeSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotCompositeSlotTypeSettingArgs:
    def __init__(__self__, *,
                 sub_slots: Optional[pulumi.Input[Sequence[pulumi.Input['BotSubSlotTypeCompositionArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BotSubSlotTypeCompositionArgs']]] sub_slots: Subslots in the composite slot.
        """
        if sub_slots is not None:
            pulumi.set(__self__, "sub_slots", sub_slots)

    @_builtins.property
    @pulumi.getter(name="subSlots")
    def sub_slots(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotSubSlotTypeCompositionArgs']]]]:
        """
        Subslots in the composite slot.
        """
        return pulumi.get(self, "sub_slots")

    @sub_slots.setter
    def sub_slots(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotSubSlotTypeCompositionArgs']]]]):
        pulumi.set(self, "sub_slots", value)


if not MYPY:
    class BotConditionalBranchArgsDict(TypedDict):
        condition: pulumi.Input['BotConditionArgsDict']
        name: pulumi.Input[_builtins.str]
        next_step: pulumi.Input['BotDialogStateArgsDict']
        response: NotRequired[pulumi.Input['BotResponseSpecificationArgsDict']]
elif False:
    BotConditionalBranchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotConditionalBranchArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input['BotConditionArgs'],
                 name: pulumi.Input[_builtins.str],
                 next_step: pulumi.Input['BotDialogStateArgs'],
                 response: Optional[pulumi.Input['BotResponseSpecificationArgs']] = None):
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "next_step", next_step)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> pulumi.Input['BotConditionArgs']:
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input['BotConditionArgs']):
        pulumi.set(self, "condition", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="nextStep")
    def next_step(self) -> pulumi.Input['BotDialogStateArgs']:
        return pulumi.get(self, "next_step")

    @next_step.setter
    def next_step(self, value: pulumi.Input['BotDialogStateArgs']):
        pulumi.set(self, "next_step", value)

    @_builtins.property
    @pulumi.getter
    def response(self) -> Optional[pulumi.Input['BotResponseSpecificationArgs']]:
        return pulumi.get(self, "response")

    @response.setter
    def response(self, value: Optional[pulumi.Input['BotResponseSpecificationArgs']]):
        pulumi.set(self, "response", value)


if not MYPY:
    class BotConditionalSpecificationArgsDict(TypedDict):
        conditional_branches: pulumi.Input[Sequence[pulumi.Input['BotConditionalBranchArgsDict']]]
        """
        A list of conditional branches. A conditional branch is made up of a condition, a response and a next step. The response and next step are executed when the condition is true.
        """
        default_branch: pulumi.Input['BotDefaultConditionalBranchArgsDict']
        """
        The conditional branch that should be followed when the conditions for other branches are not satisfied. A conditional branch is made up of a condition, a response and a next step.
        """
        is_active: pulumi.Input[_builtins.bool]
        """
        Determines whether a conditional branch is active. When `IsActive` is false, the conditions are not evaluated.
        """
elif False:
    BotConditionalSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotConditionalSpecificationArgs:
    def __init__(__self__, *,
                 conditional_branches: pulumi.Input[Sequence[pulumi.Input['BotConditionalBranchArgs']]],
                 default_branch: pulumi.Input['BotDefaultConditionalBranchArgs'],
                 is_active: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BotConditionalBranchArgs']]] conditional_branches: A list of conditional branches. A conditional branch is made up of a condition, a response and a next step. The response and next step are executed when the condition is true.
        :param pulumi.Input['BotDefaultConditionalBranchArgs'] default_branch: The conditional branch that should be followed when the conditions for other branches are not satisfied. A conditional branch is made up of a condition, a response and a next step.
        :param pulumi.Input[_builtins.bool] is_active: Determines whether a conditional branch is active. When `IsActive` is false, the conditions are not evaluated.
        """
        pulumi.set(__self__, "conditional_branches", conditional_branches)
        pulumi.set(__self__, "default_branch", default_branch)
        pulumi.set(__self__, "is_active", is_active)

    @_builtins.property
    @pulumi.getter(name="conditionalBranches")
    def conditional_branches(self) -> pulumi.Input[Sequence[pulumi.Input['BotConditionalBranchArgs']]]:
        """
        A list of conditional branches. A conditional branch is made up of a condition, a response and a next step. The response and next step are executed when the condition is true.
        """
        return pulumi.get(self, "conditional_branches")

    @conditional_branches.setter
    def conditional_branches(self, value: pulumi.Input[Sequence[pulumi.Input['BotConditionalBranchArgs']]]):
        pulumi.set(self, "conditional_branches", value)

    @_builtins.property
    @pulumi.getter(name="defaultBranch")
    def default_branch(self) -> pulumi.Input['BotDefaultConditionalBranchArgs']:
        """
        The conditional branch that should be followed when the conditions for other branches are not satisfied. A conditional branch is made up of a condition, a response and a next step.
        """
        return pulumi.get(self, "default_branch")

    @default_branch.setter
    def default_branch(self, value: pulumi.Input['BotDefaultConditionalBranchArgs']):
        pulumi.set(self, "default_branch", value)

    @_builtins.property
    @pulumi.getter(name="isActive")
    def is_active(self) -> pulumi.Input[_builtins.bool]:
        """
        Determines whether a conditional branch is active. When `IsActive` is false, the conditions are not evaluated.
        """
        return pulumi.get(self, "is_active")

    @is_active.setter
    def is_active(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "is_active", value)


if not MYPY:
    class BotConditionArgsDict(TypedDict):
        expression_string: pulumi.Input[_builtins.str]
elif False:
    BotConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotConditionArgs:
    def __init__(__self__, *,
                 expression_string: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "expression_string", expression_string)

    @_builtins.property
    @pulumi.getter(name="expressionString")
    def expression_string(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "expression_string")

    @expression_string.setter
    def expression_string(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "expression_string", value)


if not MYPY:
    class BotConversationLogSettingsArgsDict(TypedDict):
        audio_log_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['BotAudioLogSettingArgsDict']]]]
        """
        The Amazon S3 settings for logging audio to an S3 bucket.
        """
        text_log_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['BotTextLogSettingArgsDict']]]]
        """
        The Amazon CloudWatch Logs settings for logging text and metadata.
        """
elif False:
    BotConversationLogSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotConversationLogSettingsArgs:
    def __init__(__self__, *,
                 audio_log_settings: Optional[pulumi.Input[Sequence[pulumi.Input['BotAudioLogSettingArgs']]]] = None,
                 text_log_settings: Optional[pulumi.Input[Sequence[pulumi.Input['BotTextLogSettingArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BotAudioLogSettingArgs']]] audio_log_settings: The Amazon S3 settings for logging audio to an S3 bucket.
        :param pulumi.Input[Sequence[pulumi.Input['BotTextLogSettingArgs']]] text_log_settings: The Amazon CloudWatch Logs settings for logging text and metadata.
        """
        if audio_log_settings is not None:
            pulumi.set(__self__, "audio_log_settings", audio_log_settings)
        if text_log_settings is not None:
            pulumi.set(__self__, "text_log_settings", text_log_settings)

    @_builtins.property
    @pulumi.getter(name="audioLogSettings")
    def audio_log_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotAudioLogSettingArgs']]]]:
        """
        The Amazon S3 settings for logging audio to an S3 bucket.
        """
        return pulumi.get(self, "audio_log_settings")

    @audio_log_settings.setter
    def audio_log_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotAudioLogSettingArgs']]]]):
        pulumi.set(self, "audio_log_settings", value)

    @_builtins.property
    @pulumi.getter(name="textLogSettings")
    def text_log_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotTextLogSettingArgs']]]]:
        """
        The Amazon CloudWatch Logs settings for logging text and metadata.
        """
        return pulumi.get(self, "text_log_settings")

    @text_log_settings.setter
    def text_log_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotTextLogSettingArgs']]]]):
        pulumi.set(self, "text_log_settings", value)


if not MYPY:
    class BotCustomPayloadArgsDict(TypedDict):
        value: pulumi.Input[_builtins.str]
elif False:
    BotCustomPayloadArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotCustomPayloadArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class BotCustomVocabularyItemArgsDict(TypedDict):
        phrase: pulumi.Input[_builtins.str]
        display_as: NotRequired[pulumi.Input[_builtins.str]]
        weight: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    BotCustomVocabularyItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotCustomVocabularyItemArgs:
    def __init__(__self__, *,
                 phrase: pulumi.Input[_builtins.str],
                 display_as: Optional[pulumi.Input[_builtins.str]] = None,
                 weight: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "phrase", phrase)
        if display_as is not None:
            pulumi.set(__self__, "display_as", display_as)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def phrase(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "phrase")

    @phrase.setter
    def phrase(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "phrase", value)

    @_builtins.property
    @pulumi.getter(name="displayAs")
    def display_as(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "display_as")

    @display_as.setter
    def display_as(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_as", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class BotCustomVocabularyArgsDict(TypedDict):
        custom_vocabulary_items: pulumi.Input[Sequence[pulumi.Input['BotCustomVocabularyItemArgsDict']]]
        """
        Specifies a list of words that you expect to be used during a conversation with your bot.
        """
elif False:
    BotCustomVocabularyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotCustomVocabularyArgs:
    def __init__(__self__, *,
                 custom_vocabulary_items: pulumi.Input[Sequence[pulumi.Input['BotCustomVocabularyItemArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BotCustomVocabularyItemArgs']]] custom_vocabulary_items: Specifies a list of words that you expect to be used during a conversation with your bot.
        """
        pulumi.set(__self__, "custom_vocabulary_items", custom_vocabulary_items)

    @_builtins.property
    @pulumi.getter(name="customVocabularyItems")
    def custom_vocabulary_items(self) -> pulumi.Input[Sequence[pulumi.Input['BotCustomVocabularyItemArgs']]]:
        """
        Specifies a list of words that you expect to be used during a conversation with your bot.
        """
        return pulumi.get(self, "custom_vocabulary_items")

    @custom_vocabulary_items.setter
    def custom_vocabulary_items(self, value: pulumi.Input[Sequence[pulumi.Input['BotCustomVocabularyItemArgs']]]):
        pulumi.set(self, "custom_vocabulary_items", value)


if not MYPY:
    class BotDefaultConditionalBranchArgsDict(TypedDict):
        next_step: NotRequired[pulumi.Input['BotDialogStateArgsDict']]
        """
        The next step in the conversation.
        """
        response: NotRequired[pulumi.Input['BotResponseSpecificationArgsDict']]
        """
        Specifies a list of message groups that Amazon Lex uses to respond the user input.
        """
elif False:
    BotDefaultConditionalBranchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotDefaultConditionalBranchArgs:
    def __init__(__self__, *,
                 next_step: Optional[pulumi.Input['BotDialogStateArgs']] = None,
                 response: Optional[pulumi.Input['BotResponseSpecificationArgs']] = None):
        """
        :param pulumi.Input['BotDialogStateArgs'] next_step: The next step in the conversation.
        :param pulumi.Input['BotResponseSpecificationArgs'] response: Specifies a list of message groups that Amazon Lex uses to respond the user input.
        """
        if next_step is not None:
            pulumi.set(__self__, "next_step", next_step)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @_builtins.property
    @pulumi.getter(name="nextStep")
    def next_step(self) -> Optional[pulumi.Input['BotDialogStateArgs']]:
        """
        The next step in the conversation.
        """
        return pulumi.get(self, "next_step")

    @next_step.setter
    def next_step(self, value: Optional[pulumi.Input['BotDialogStateArgs']]):
        pulumi.set(self, "next_step", value)

    @_builtins.property
    @pulumi.getter
    def response(self) -> Optional[pulumi.Input['BotResponseSpecificationArgs']]:
        """
        Specifies a list of message groups that Amazon Lex uses to respond the user input.
        """
        return pulumi.get(self, "response")

    @response.setter
    def response(self, value: Optional[pulumi.Input['BotResponseSpecificationArgs']]):
        pulumi.set(self, "response", value)


if not MYPY:
    class BotDialogActionArgsDict(TypedDict):
        type: pulumi.Input['BotDialogActionType']
        """
        The action that the bot should execute.
        """
        slot_to_elicit: NotRequired[pulumi.Input[_builtins.str]]
        """
        If the dialog action is `ElicitSlot` , defines the slot to elicit from the user.
        """
        suppress_next_message: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When true the next message for the intent is not used.
        """
elif False:
    BotDialogActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotDialogActionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['BotDialogActionType'],
                 slot_to_elicit: Optional[pulumi.Input[_builtins.str]] = None,
                 suppress_next_message: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input['BotDialogActionType'] type: The action that the bot should execute.
        :param pulumi.Input[_builtins.str] slot_to_elicit: If the dialog action is `ElicitSlot` , defines the slot to elicit from the user.
        :param pulumi.Input[_builtins.bool] suppress_next_message: When true the next message for the intent is not used.
        """
        pulumi.set(__self__, "type", type)
        if slot_to_elicit is not None:
            pulumi.set(__self__, "slot_to_elicit", slot_to_elicit)
        if suppress_next_message is not None:
            pulumi.set(__self__, "suppress_next_message", suppress_next_message)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['BotDialogActionType']:
        """
        The action that the bot should execute.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['BotDialogActionType']):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="slotToElicit")
    def slot_to_elicit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If the dialog action is `ElicitSlot` , defines the slot to elicit from the user.
        """
        return pulumi.get(self, "slot_to_elicit")

    @slot_to_elicit.setter
    def slot_to_elicit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "slot_to_elicit", value)

    @_builtins.property
    @pulumi.getter(name="suppressNextMessage")
    def suppress_next_message(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When true the next message for the intent is not used.
        """
        return pulumi.get(self, "suppress_next_message")

    @suppress_next_message.setter
    def suppress_next_message(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "suppress_next_message", value)


if not MYPY:
    class BotDialogCodeHookInvocationSettingArgsDict(TypedDict):
        enable_code_hook_invocation: pulumi.Input[_builtins.bool]
        """
        Indicates whether a Lambda function should be invoked for the dialog.
        """
        is_active: pulumi.Input[_builtins.bool]
        """
        Determines whether a dialog code hook is used when the intent is activated.
        """
        post_code_hook_specification: pulumi.Input['BotPostDialogCodeHookInvocationSpecificationArgsDict']
        """
        Contains the responses and actions that Amazon Lex takes after the Lambda function is complete.
        """
        invocation_label: NotRequired[pulumi.Input[_builtins.str]]
        """
        A label that indicates the dialog step from which the dialog code hook is happening.
        """
elif False:
    BotDialogCodeHookInvocationSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotDialogCodeHookInvocationSettingArgs:
    def __init__(__self__, *,
                 enable_code_hook_invocation: pulumi.Input[_builtins.bool],
                 is_active: pulumi.Input[_builtins.bool],
                 post_code_hook_specification: pulumi.Input['BotPostDialogCodeHookInvocationSpecificationArgs'],
                 invocation_label: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable_code_hook_invocation: Indicates whether a Lambda function should be invoked for the dialog.
        :param pulumi.Input[_builtins.bool] is_active: Determines whether a dialog code hook is used when the intent is activated.
        :param pulumi.Input['BotPostDialogCodeHookInvocationSpecificationArgs'] post_code_hook_specification: Contains the responses and actions that Amazon Lex takes after the Lambda function is complete.
        :param pulumi.Input[_builtins.str] invocation_label: A label that indicates the dialog step from which the dialog code hook is happening.
        """
        pulumi.set(__self__, "enable_code_hook_invocation", enable_code_hook_invocation)
        pulumi.set(__self__, "is_active", is_active)
        pulumi.set(__self__, "post_code_hook_specification", post_code_hook_specification)
        if invocation_label is not None:
            pulumi.set(__self__, "invocation_label", invocation_label)

    @_builtins.property
    @pulumi.getter(name="enableCodeHookInvocation")
    def enable_code_hook_invocation(self) -> pulumi.Input[_builtins.bool]:
        """
        Indicates whether a Lambda function should be invoked for the dialog.
        """
        return pulumi.get(self, "enable_code_hook_invocation")

    @enable_code_hook_invocation.setter
    def enable_code_hook_invocation(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enable_code_hook_invocation", value)

    @_builtins.property
    @pulumi.getter(name="isActive")
    def is_active(self) -> pulumi.Input[_builtins.bool]:
        """
        Determines whether a dialog code hook is used when the intent is activated.
        """
        return pulumi.get(self, "is_active")

    @is_active.setter
    def is_active(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "is_active", value)

    @_builtins.property
    @pulumi.getter(name="postCodeHookSpecification")
    def post_code_hook_specification(self) -> pulumi.Input['BotPostDialogCodeHookInvocationSpecificationArgs']:
        """
        Contains the responses and actions that Amazon Lex takes after the Lambda function is complete.
        """
        return pulumi.get(self, "post_code_hook_specification")

    @post_code_hook_specification.setter
    def post_code_hook_specification(self, value: pulumi.Input['BotPostDialogCodeHookInvocationSpecificationArgs']):
        pulumi.set(self, "post_code_hook_specification", value)

    @_builtins.property
    @pulumi.getter(name="invocationLabel")
    def invocation_label(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A label that indicates the dialog step from which the dialog code hook is happening.
        """
        return pulumi.get(self, "invocation_label")

    @invocation_label.setter
    def invocation_label(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invocation_label", value)


if not MYPY:
    class BotDialogCodeHookSettingArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Enables the dialog code hook so that it processes user requests.
        """
elif False:
    BotDialogCodeHookSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotDialogCodeHookSettingArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enables the dialog code hook so that it processes user requests.
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Enables the dialog code hook so that it processes user requests.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class BotDialogStateArgsDict(TypedDict):
        dialog_action: NotRequired[pulumi.Input['BotDialogActionArgsDict']]
        """
        Defines the action that the bot executes at runtime when the conversation reaches this step.
        """
        intent: NotRequired[pulumi.Input['BotIntentOverrideArgsDict']]
        """
        Override settings to configure the intent state.
        """
        session_attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input['BotSessionAttributeArgsDict']]]]
        """
        Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
        """
elif False:
    BotDialogStateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotDialogStateArgs:
    def __init__(__self__, *,
                 dialog_action: Optional[pulumi.Input['BotDialogActionArgs']] = None,
                 intent: Optional[pulumi.Input['BotIntentOverrideArgs']] = None,
                 session_attributes: Optional[pulumi.Input[Sequence[pulumi.Input['BotSessionAttributeArgs']]]] = None):
        """
        :param pulumi.Input['BotDialogActionArgs'] dialog_action: Defines the action that the bot executes at runtime when the conversation reaches this step.
        :param pulumi.Input['BotIntentOverrideArgs'] intent: Override settings to configure the intent state.
        :param pulumi.Input[Sequence[pulumi.Input['BotSessionAttributeArgs']]] session_attributes: Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
        """
        if dialog_action is not None:
            pulumi.set(__self__, "dialog_action", dialog_action)
        if intent is not None:
            pulumi.set(__self__, "intent", intent)
        if session_attributes is not None:
            pulumi.set(__self__, "session_attributes", session_attributes)

    @_builtins.property
    @pulumi.getter(name="dialogAction")
    def dialog_action(self) -> Optional[pulumi.Input['BotDialogActionArgs']]:
        """
        Defines the action that the bot executes at runtime when the conversation reaches this step.
        """
        return pulumi.get(self, "dialog_action")

    @dialog_action.setter
    def dialog_action(self, value: Optional[pulumi.Input['BotDialogActionArgs']]):
        pulumi.set(self, "dialog_action", value)

    @_builtins.property
    @pulumi.getter
    def intent(self) -> Optional[pulumi.Input['BotIntentOverrideArgs']]:
        """
        Override settings to configure the intent state.
        """
        return pulumi.get(self, "intent")

    @intent.setter
    def intent(self, value: Optional[pulumi.Input['BotIntentOverrideArgs']]):
        pulumi.set(self, "intent", value)

    @_builtins.property
    @pulumi.getter(name="sessionAttributes")
    def session_attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotSessionAttributeArgs']]]]:
        """
        Map of key/value pairs representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
        """
        return pulumi.get(self, "session_attributes")

    @session_attributes.setter
    def session_attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotSessionAttributeArgs']]]]):
        pulumi.set(self, "session_attributes", value)


if not MYPY:
    class BotDtmfSpecificationArgsDict(TypedDict):
        deletion_character: pulumi.Input[_builtins.str]
        end_character: pulumi.Input[_builtins.str]
        end_timeout_ms: pulumi.Input[_builtins.int]
        max_length: pulumi.Input[_builtins.int]
elif False:
    BotDtmfSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotDtmfSpecificationArgs:
    def __init__(__self__, *,
                 deletion_character: pulumi.Input[_builtins.str],
                 end_character: pulumi.Input[_builtins.str],
                 end_timeout_ms: pulumi.Input[_builtins.int],
                 max_length: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "deletion_character", deletion_character)
        pulumi.set(__self__, "end_character", end_character)
        pulumi.set(__self__, "end_timeout_ms", end_timeout_ms)
        pulumi.set(__self__, "max_length", max_length)

    @_builtins.property
    @pulumi.getter(name="deletionCharacter")
    def deletion_character(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "deletion_character")

    @deletion_character.setter
    def deletion_character(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "deletion_character", value)

    @_builtins.property
    @pulumi.getter(name="endCharacter")
    def end_character(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "end_character")

    @end_character.setter
    def end_character(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "end_character", value)

    @_builtins.property
    @pulumi.getter(name="endTimeoutMs")
    def end_timeout_ms(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "end_timeout_ms")

    @end_timeout_ms.setter
    def end_timeout_ms(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "end_timeout_ms", value)

    @_builtins.property
    @pulumi.getter(name="maxLength")
    def max_length(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "max_length")

    @max_length.setter
    def max_length(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max_length", value)


if not MYPY:
    class BotElicitationCodeHookInvocationSettingArgsDict(TypedDict):
        enable_code_hook_invocation: pulumi.Input[_builtins.bool]
        """
        Indicates whether a Lambda function should be invoked for the dialog.
        """
        invocation_label: NotRequired[pulumi.Input[_builtins.str]]
        """
        A label that indicates the dialog step from which the dialog code hook is happening.
        """
elif False:
    BotElicitationCodeHookInvocationSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotElicitationCodeHookInvocationSettingArgs:
    def __init__(__self__, *,
                 enable_code_hook_invocation: pulumi.Input[_builtins.bool],
                 invocation_label: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable_code_hook_invocation: Indicates whether a Lambda function should be invoked for the dialog.
        :param pulumi.Input[_builtins.str] invocation_label: A label that indicates the dialog step from which the dialog code hook is happening.
        """
        pulumi.set(__self__, "enable_code_hook_invocation", enable_code_hook_invocation)
        if invocation_label is not None:
            pulumi.set(__self__, "invocation_label", invocation_label)

    @_builtins.property
    @pulumi.getter(name="enableCodeHookInvocation")
    def enable_code_hook_invocation(self) -> pulumi.Input[_builtins.bool]:
        """
        Indicates whether a Lambda function should be invoked for the dialog.
        """
        return pulumi.get(self, "enable_code_hook_invocation")

    @enable_code_hook_invocation.setter
    def enable_code_hook_invocation(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enable_code_hook_invocation", value)

    @_builtins.property
    @pulumi.getter(name="invocationLabel")
    def invocation_label(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A label that indicates the dialog step from which the dialog code hook is happening.
        """
        return pulumi.get(self, "invocation_label")

    @invocation_label.setter
    def invocation_label(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "invocation_label", value)


if not MYPY:
    class BotExternalSourceSettingArgsDict(TypedDict):
        grammar_slot_type_setting: NotRequired[pulumi.Input['BotGrammarSlotTypeSettingArgsDict']]
        """
        Settings required for a slot type based on a grammar that you provide.
        """
elif False:
    BotExternalSourceSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotExternalSourceSettingArgs:
    def __init__(__self__, *,
                 grammar_slot_type_setting: Optional[pulumi.Input['BotGrammarSlotTypeSettingArgs']] = None):
        """
        :param pulumi.Input['BotGrammarSlotTypeSettingArgs'] grammar_slot_type_setting: Settings required for a slot type based on a grammar that you provide.
        """
        if grammar_slot_type_setting is not None:
            pulumi.set(__self__, "grammar_slot_type_setting", grammar_slot_type_setting)

    @_builtins.property
    @pulumi.getter(name="grammarSlotTypeSetting")
    def grammar_slot_type_setting(self) -> Optional[pulumi.Input['BotGrammarSlotTypeSettingArgs']]:
        """
        Settings required for a slot type based on a grammar that you provide.
        """
        return pulumi.get(self, "grammar_slot_type_setting")

    @grammar_slot_type_setting.setter
    def grammar_slot_type_setting(self, value: Optional[pulumi.Input['BotGrammarSlotTypeSettingArgs']]):
        pulumi.set(self, "grammar_slot_type_setting", value)


if not MYPY:
    class BotFulfillmentCodeHookSettingArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Indicates whether a Lambda function should be invoked to fulfill a specific intent.
        """
        fulfillment_updates_specification: NotRequired[pulumi.Input['BotFulfillmentUpdatesSpecificationArgsDict']]
        """
        Provides settings for update messages sent to the user for long-running Lambda fulfillment functions. Fulfillment updates can be used only with streaming conversations.
        """
        is_active: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Determines whether the fulfillment code hook is used. When `active` is false, the code hook doesn't run.
        """
        post_fulfillment_status_specification: NotRequired[pulumi.Input['BotPostFulfillmentStatusSpecificationArgsDict']]
        """
        Provides settings for messages sent to the user for after the Lambda fulfillment function completes. Post-fulfillment messages can be sent for both streaming and non-streaming conversations.
        """
elif False:
    BotFulfillmentCodeHookSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotFulfillmentCodeHookSettingArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 fulfillment_updates_specification: Optional[pulumi.Input['BotFulfillmentUpdatesSpecificationArgs']] = None,
                 is_active: Optional[pulumi.Input[_builtins.bool]] = None,
                 post_fulfillment_status_specification: Optional[pulumi.Input['BotPostFulfillmentStatusSpecificationArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Indicates whether a Lambda function should be invoked to fulfill a specific intent.
        :param pulumi.Input['BotFulfillmentUpdatesSpecificationArgs'] fulfillment_updates_specification: Provides settings for update messages sent to the user for long-running Lambda fulfillment functions. Fulfillment updates can be used only with streaming conversations.
        :param pulumi.Input[_builtins.bool] is_active: Determines whether the fulfillment code hook is used. When `active` is false, the code hook doesn't run.
        :param pulumi.Input['BotPostFulfillmentStatusSpecificationArgs'] post_fulfillment_status_specification: Provides settings for messages sent to the user for after the Lambda fulfillment function completes. Post-fulfillment messages can be sent for both streaming and non-streaming conversations.
        """
        pulumi.set(__self__, "enabled", enabled)
        if fulfillment_updates_specification is not None:
            pulumi.set(__self__, "fulfillment_updates_specification", fulfillment_updates_specification)
        if is_active is not None:
            pulumi.set(__self__, "is_active", is_active)
        if post_fulfillment_status_specification is not None:
            pulumi.set(__self__, "post_fulfillment_status_specification", post_fulfillment_status_specification)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Indicates whether a Lambda function should be invoked to fulfill a specific intent.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="fulfillmentUpdatesSpecification")
    def fulfillment_updates_specification(self) -> Optional[pulumi.Input['BotFulfillmentUpdatesSpecificationArgs']]:
        """
        Provides settings for update messages sent to the user for long-running Lambda fulfillment functions. Fulfillment updates can be used only with streaming conversations.
        """
        return pulumi.get(self, "fulfillment_updates_specification")

    @fulfillment_updates_specification.setter
    def fulfillment_updates_specification(self, value: Optional[pulumi.Input['BotFulfillmentUpdatesSpecificationArgs']]):
        pulumi.set(self, "fulfillment_updates_specification", value)

    @_builtins.property
    @pulumi.getter(name="isActive")
    def is_active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether the fulfillment code hook is used. When `active` is false, the code hook doesn't run.
        """
        return pulumi.get(self, "is_active")

    @is_active.setter
    def is_active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_active", value)

    @_builtins.property
    @pulumi.getter(name="postFulfillmentStatusSpecification")
    def post_fulfillment_status_specification(self) -> Optional[pulumi.Input['BotPostFulfillmentStatusSpecificationArgs']]:
        """
        Provides settings for messages sent to the user for after the Lambda fulfillment function completes. Post-fulfillment messages can be sent for both streaming and non-streaming conversations.
        """
        return pulumi.get(self, "post_fulfillment_status_specification")

    @post_fulfillment_status_specification.setter
    def post_fulfillment_status_specification(self, value: Optional[pulumi.Input['BotPostFulfillmentStatusSpecificationArgs']]):
        pulumi.set(self, "post_fulfillment_status_specification", value)


if not MYPY:
    class BotFulfillmentStartResponseSpecificationArgsDict(TypedDict):
        delay_in_seconds: pulumi.Input[_builtins.int]
        """
        The delay between when the Lambda fulfillment function starts running and the start message is played. If the Lambda function returns before the delay is over, the start message isn't played.
        """
        message_groups: pulumi.Input[Sequence[pulumi.Input['BotMessageGroupArgsDict']]]
        """
        1 - 5 message groups that contain start messages. Amazon Lex chooses one of the messages to play to the user.
        """
        allow_interrupt: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Determines whether the user can interrupt the start message while it is playing.
        """
elif False:
    BotFulfillmentStartResponseSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotFulfillmentStartResponseSpecificationArgs:
    def __init__(__self__, *,
                 delay_in_seconds: pulumi.Input[_builtins.int],
                 message_groups: pulumi.Input[Sequence[pulumi.Input['BotMessageGroupArgs']]],
                 allow_interrupt: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.int] delay_in_seconds: The delay between when the Lambda fulfillment function starts running and the start message is played. If the Lambda function returns before the delay is over, the start message isn't played.
        :param pulumi.Input[Sequence[pulumi.Input['BotMessageGroupArgs']]] message_groups: 1 - 5 message groups that contain start messages. Amazon Lex chooses one of the messages to play to the user.
        :param pulumi.Input[_builtins.bool] allow_interrupt: Determines whether the user can interrupt the start message while it is playing.
        """
        pulumi.set(__self__, "delay_in_seconds", delay_in_seconds)
        pulumi.set(__self__, "message_groups", message_groups)
        if allow_interrupt is not None:
            pulumi.set(__self__, "allow_interrupt", allow_interrupt)

    @_builtins.property
    @pulumi.getter(name="delayInSeconds")
    def delay_in_seconds(self) -> pulumi.Input[_builtins.int]:
        """
        The delay between when the Lambda fulfillment function starts running and the start message is played. If the Lambda function returns before the delay is over, the start message isn't played.
        """
        return pulumi.get(self, "delay_in_seconds")

    @delay_in_seconds.setter
    def delay_in_seconds(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "delay_in_seconds", value)

    @_builtins.property
    @pulumi.getter(name="messageGroups")
    def message_groups(self) -> pulumi.Input[Sequence[pulumi.Input['BotMessageGroupArgs']]]:
        """
        1 - 5 message groups that contain start messages. Amazon Lex chooses one of the messages to play to the user.
        """
        return pulumi.get(self, "message_groups")

    @message_groups.setter
    def message_groups(self, value: pulumi.Input[Sequence[pulumi.Input['BotMessageGroupArgs']]]):
        pulumi.set(self, "message_groups", value)

    @_builtins.property
    @pulumi.getter(name="allowInterrupt")
    def allow_interrupt(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether the user can interrupt the start message while it is playing.
        """
        return pulumi.get(self, "allow_interrupt")

    @allow_interrupt.setter
    def allow_interrupt(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_interrupt", value)


if not MYPY:
    class BotFulfillmentUpdateResponseSpecificationArgsDict(TypedDict):
        frequency_in_seconds: pulumi.Input[_builtins.int]
        """
        The frequency that a message is sent to the user. When the period ends, Amazon Lex chooses a message from the message groups and plays it to the user. If the fulfillment Lambda returns before the first period ends, an update message is not played to the user.
        """
        message_groups: pulumi.Input[Sequence[pulumi.Input['BotMessageGroupArgsDict']]]
        """
        1 - 5 message groups that contain update messages. Amazon Lex chooses one of the messages to play to the user.
        """
        allow_interrupt: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Determines whether the user can interrupt an update message while it is playing.
        """
elif False:
    BotFulfillmentUpdateResponseSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotFulfillmentUpdateResponseSpecificationArgs:
    def __init__(__self__, *,
                 frequency_in_seconds: pulumi.Input[_builtins.int],
                 message_groups: pulumi.Input[Sequence[pulumi.Input['BotMessageGroupArgs']]],
                 allow_interrupt: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.int] frequency_in_seconds: The frequency that a message is sent to the user. When the period ends, Amazon Lex chooses a message from the message groups and plays it to the user. If the fulfillment Lambda returns before the first period ends, an update message is not played to the user.
        :param pulumi.Input[Sequence[pulumi.Input['BotMessageGroupArgs']]] message_groups: 1 - 5 message groups that contain update messages. Amazon Lex chooses one of the messages to play to the user.
        :param pulumi.Input[_builtins.bool] allow_interrupt: Determines whether the user can interrupt an update message while it is playing.
        """
        pulumi.set(__self__, "frequency_in_seconds", frequency_in_seconds)
        pulumi.set(__self__, "message_groups", message_groups)
        if allow_interrupt is not None:
            pulumi.set(__self__, "allow_interrupt", allow_interrupt)

    @_builtins.property
    @pulumi.getter(name="frequencyInSeconds")
    def frequency_in_seconds(self) -> pulumi.Input[_builtins.int]:
        """
        The frequency that a message is sent to the user. When the period ends, Amazon Lex chooses a message from the message groups and plays it to the user. If the fulfillment Lambda returns before the first period ends, an update message is not played to the user.
        """
        return pulumi.get(self, "frequency_in_seconds")

    @frequency_in_seconds.setter
    def frequency_in_seconds(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "frequency_in_seconds", value)

    @_builtins.property
    @pulumi.getter(name="messageGroups")
    def message_groups(self) -> pulumi.Input[Sequence[pulumi.Input['BotMessageGroupArgs']]]:
        """
        1 - 5 message groups that contain update messages. Amazon Lex chooses one of the messages to play to the user.
        """
        return pulumi.get(self, "message_groups")

    @message_groups.setter
    def message_groups(self, value: pulumi.Input[Sequence[pulumi.Input['BotMessageGroupArgs']]]):
        pulumi.set(self, "message_groups", value)

    @_builtins.property
    @pulumi.getter(name="allowInterrupt")
    def allow_interrupt(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether the user can interrupt an update message while it is playing.
        """
        return pulumi.get(self, "allow_interrupt")

    @allow_interrupt.setter
    def allow_interrupt(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_interrupt", value)


if not MYPY:
    class BotFulfillmentUpdatesSpecificationArgsDict(TypedDict):
        active: pulumi.Input[_builtins.bool]
        """
        Determines whether fulfillment updates are sent to the user. When this field is true, updates are sent.

        If the `active` field is set to true, the `startResponse` , `updateResponse` , and `timeoutInSeconds` fields are required.
        """
        start_response: NotRequired[pulumi.Input['BotFulfillmentStartResponseSpecificationArgsDict']]
        """
        Provides configuration information for the message sent to users when the fulfillment Lambda functions starts running.
        """
        timeout_in_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The length of time that the fulfillment Lambda function should run before it times out.
        """
        update_response: NotRequired[pulumi.Input['BotFulfillmentUpdateResponseSpecificationArgsDict']]
        """
        Provides configuration information for messages sent periodically to the user while the fulfillment Lambda function is running.
        """
elif False:
    BotFulfillmentUpdatesSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotFulfillmentUpdatesSpecificationArgs:
    def __init__(__self__, *,
                 active: pulumi.Input[_builtins.bool],
                 start_response: Optional[pulumi.Input['BotFulfillmentStartResponseSpecificationArgs']] = None,
                 timeout_in_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 update_response: Optional[pulumi.Input['BotFulfillmentUpdateResponseSpecificationArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] active: Determines whether fulfillment updates are sent to the user. When this field is true, updates are sent.
               
               If the `active` field is set to true, the `startResponse` , `updateResponse` , and `timeoutInSeconds` fields are required.
        :param pulumi.Input['BotFulfillmentStartResponseSpecificationArgs'] start_response: Provides configuration information for the message sent to users when the fulfillment Lambda functions starts running.
        :param pulumi.Input[_builtins.int] timeout_in_seconds: The length of time that the fulfillment Lambda function should run before it times out.
        :param pulumi.Input['BotFulfillmentUpdateResponseSpecificationArgs'] update_response: Provides configuration information for messages sent periodically to the user while the fulfillment Lambda function is running.
        """
        pulumi.set(__self__, "active", active)
        if start_response is not None:
            pulumi.set(__self__, "start_response", start_response)
        if timeout_in_seconds is not None:
            pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)
        if update_response is not None:
            pulumi.set(__self__, "update_response", update_response)

    @_builtins.property
    @pulumi.getter
    def active(self) -> pulumi.Input[_builtins.bool]:
        """
        Determines whether fulfillment updates are sent to the user. When this field is true, updates are sent.

        If the `active` field is set to true, the `startResponse` , `updateResponse` , and `timeoutInSeconds` fields are required.
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "active", value)

    @_builtins.property
    @pulumi.getter(name="startResponse")
    def start_response(self) -> Optional[pulumi.Input['BotFulfillmentStartResponseSpecificationArgs']]:
        """
        Provides configuration information for the message sent to users when the fulfillment Lambda functions starts running.
        """
        return pulumi.get(self, "start_response")

    @start_response.setter
    def start_response(self, value: Optional[pulumi.Input['BotFulfillmentStartResponseSpecificationArgs']]):
        pulumi.set(self, "start_response", value)

    @_builtins.property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The length of time that the fulfillment Lambda function should run before it times out.
        """
        return pulumi.get(self, "timeout_in_seconds")

    @timeout_in_seconds.setter
    def timeout_in_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_in_seconds", value)

    @_builtins.property
    @pulumi.getter(name="updateResponse")
    def update_response(self) -> Optional[pulumi.Input['BotFulfillmentUpdateResponseSpecificationArgs']]:
        """
        Provides configuration information for messages sent periodically to the user while the fulfillment Lambda function is running.
        """
        return pulumi.get(self, "update_response")

    @update_response.setter
    def update_response(self, value: Optional[pulumi.Input['BotFulfillmentUpdateResponseSpecificationArgs']]):
        pulumi.set(self, "update_response", value)


if not MYPY:
    class BotGenerativeAiSettingsBuildtimeSettingsPropertiesDescriptiveBotBuilderSpecificationPropertiesArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        bedrock_model_specification: NotRequired[pulumi.Input['BotBedrockModelSpecificationArgsDict']]
elif False:
    BotGenerativeAiSettingsBuildtimeSettingsPropertiesDescriptiveBotBuilderSpecificationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotGenerativeAiSettingsBuildtimeSettingsPropertiesDescriptiveBotBuilderSpecificationPropertiesArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 bedrock_model_specification: Optional[pulumi.Input['BotBedrockModelSpecificationArgs']] = None):
        pulumi.set(__self__, "enabled", enabled)
        if bedrock_model_specification is not None:
            pulumi.set(__self__, "bedrock_model_specification", bedrock_model_specification)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="bedrockModelSpecification")
    def bedrock_model_specification(self) -> Optional[pulumi.Input['BotBedrockModelSpecificationArgs']]:
        return pulumi.get(self, "bedrock_model_specification")

    @bedrock_model_specification.setter
    def bedrock_model_specification(self, value: Optional[pulumi.Input['BotBedrockModelSpecificationArgs']]):
        pulumi.set(self, "bedrock_model_specification", value)


if not MYPY:
    class BotGenerativeAiSettingsBuildtimeSettingsPropertiesSampleUtteranceGenerationSpecificationPropertiesArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        bedrock_model_specification: NotRequired[pulumi.Input['BotBedrockModelSpecificationArgsDict']]
elif False:
    BotGenerativeAiSettingsBuildtimeSettingsPropertiesSampleUtteranceGenerationSpecificationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotGenerativeAiSettingsBuildtimeSettingsPropertiesSampleUtteranceGenerationSpecificationPropertiesArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 bedrock_model_specification: Optional[pulumi.Input['BotBedrockModelSpecificationArgs']] = None):
        pulumi.set(__self__, "enabled", enabled)
        if bedrock_model_specification is not None:
            pulumi.set(__self__, "bedrock_model_specification", bedrock_model_specification)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="bedrockModelSpecification")
    def bedrock_model_specification(self) -> Optional[pulumi.Input['BotBedrockModelSpecificationArgs']]:
        return pulumi.get(self, "bedrock_model_specification")

    @bedrock_model_specification.setter
    def bedrock_model_specification(self, value: Optional[pulumi.Input['BotBedrockModelSpecificationArgs']]):
        pulumi.set(self, "bedrock_model_specification", value)


if not MYPY:
    class BotGenerativeAiSettingsBuildtimeSettingsPropertiesArgsDict(TypedDict):
        descriptive_bot_builder_specification: NotRequired[pulumi.Input['BotGenerativeAiSettingsBuildtimeSettingsPropertiesDescriptiveBotBuilderSpecificationPropertiesArgsDict']]
        sample_utterance_generation_specification: NotRequired[pulumi.Input['BotGenerativeAiSettingsBuildtimeSettingsPropertiesSampleUtteranceGenerationSpecificationPropertiesArgsDict']]
elif False:
    BotGenerativeAiSettingsBuildtimeSettingsPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotGenerativeAiSettingsBuildtimeSettingsPropertiesArgs:
    def __init__(__self__, *,
                 descriptive_bot_builder_specification: Optional[pulumi.Input['BotGenerativeAiSettingsBuildtimeSettingsPropertiesDescriptiveBotBuilderSpecificationPropertiesArgs']] = None,
                 sample_utterance_generation_specification: Optional[pulumi.Input['BotGenerativeAiSettingsBuildtimeSettingsPropertiesSampleUtteranceGenerationSpecificationPropertiesArgs']] = None):
        if descriptive_bot_builder_specification is not None:
            pulumi.set(__self__, "descriptive_bot_builder_specification", descriptive_bot_builder_specification)
        if sample_utterance_generation_specification is not None:
            pulumi.set(__self__, "sample_utterance_generation_specification", sample_utterance_generation_specification)

    @_builtins.property
    @pulumi.getter(name="descriptiveBotBuilderSpecification")
    def descriptive_bot_builder_specification(self) -> Optional[pulumi.Input['BotGenerativeAiSettingsBuildtimeSettingsPropertiesDescriptiveBotBuilderSpecificationPropertiesArgs']]:
        return pulumi.get(self, "descriptive_bot_builder_specification")

    @descriptive_bot_builder_specification.setter
    def descriptive_bot_builder_specification(self, value: Optional[pulumi.Input['BotGenerativeAiSettingsBuildtimeSettingsPropertiesDescriptiveBotBuilderSpecificationPropertiesArgs']]):
        pulumi.set(self, "descriptive_bot_builder_specification", value)

    @_builtins.property
    @pulumi.getter(name="sampleUtteranceGenerationSpecification")
    def sample_utterance_generation_specification(self) -> Optional[pulumi.Input['BotGenerativeAiSettingsBuildtimeSettingsPropertiesSampleUtteranceGenerationSpecificationPropertiesArgs']]:
        return pulumi.get(self, "sample_utterance_generation_specification")

    @sample_utterance_generation_specification.setter
    def sample_utterance_generation_specification(self, value: Optional[pulumi.Input['BotGenerativeAiSettingsBuildtimeSettingsPropertiesSampleUtteranceGenerationSpecificationPropertiesArgs']]):
        pulumi.set(self, "sample_utterance_generation_specification", value)


if not MYPY:
    class BotGenerativeAiSettingsRuntimeSettingsPropertiesNluImprovementSpecificationPropertiesArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
elif False:
    BotGenerativeAiSettingsRuntimeSettingsPropertiesNluImprovementSpecificationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotGenerativeAiSettingsRuntimeSettingsPropertiesNluImprovementSpecificationPropertiesArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool]):
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class BotGenerativeAiSettingsRuntimeSettingsPropertiesSlotResolutionImprovementSpecificationPropertiesArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        bedrock_model_specification: NotRequired[pulumi.Input['BotBedrockModelSpecificationArgsDict']]
elif False:
    BotGenerativeAiSettingsRuntimeSettingsPropertiesSlotResolutionImprovementSpecificationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotGenerativeAiSettingsRuntimeSettingsPropertiesSlotResolutionImprovementSpecificationPropertiesArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 bedrock_model_specification: Optional[pulumi.Input['BotBedrockModelSpecificationArgs']] = None):
        pulumi.set(__self__, "enabled", enabled)
        if bedrock_model_specification is not None:
            pulumi.set(__self__, "bedrock_model_specification", bedrock_model_specification)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="bedrockModelSpecification")
    def bedrock_model_specification(self) -> Optional[pulumi.Input['BotBedrockModelSpecificationArgs']]:
        return pulumi.get(self, "bedrock_model_specification")

    @bedrock_model_specification.setter
    def bedrock_model_specification(self, value: Optional[pulumi.Input['BotBedrockModelSpecificationArgs']]):
        pulumi.set(self, "bedrock_model_specification", value)


if not MYPY:
    class BotGenerativeAiSettingsRuntimeSettingsPropertiesArgsDict(TypedDict):
        nlu_improvement_specification: NotRequired[pulumi.Input['BotGenerativeAiSettingsRuntimeSettingsPropertiesNluImprovementSpecificationPropertiesArgsDict']]
        slot_resolution_improvement_specification: NotRequired[pulumi.Input['BotGenerativeAiSettingsRuntimeSettingsPropertiesSlotResolutionImprovementSpecificationPropertiesArgsDict']]
elif False:
    BotGenerativeAiSettingsRuntimeSettingsPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotGenerativeAiSettingsRuntimeSettingsPropertiesArgs:
    def __init__(__self__, *,
                 nlu_improvement_specification: Optional[pulumi.Input['BotGenerativeAiSettingsRuntimeSettingsPropertiesNluImprovementSpecificationPropertiesArgs']] = None,
                 slot_resolution_improvement_specification: Optional[pulumi.Input['BotGenerativeAiSettingsRuntimeSettingsPropertiesSlotResolutionImprovementSpecificationPropertiesArgs']] = None):
        if nlu_improvement_specification is not None:
            pulumi.set(__self__, "nlu_improvement_specification", nlu_improvement_specification)
        if slot_resolution_improvement_specification is not None:
            pulumi.set(__self__, "slot_resolution_improvement_specification", slot_resolution_improvement_specification)

    @_builtins.property
    @pulumi.getter(name="nluImprovementSpecification")
    def nlu_improvement_specification(self) -> Optional[pulumi.Input['BotGenerativeAiSettingsRuntimeSettingsPropertiesNluImprovementSpecificationPropertiesArgs']]:
        return pulumi.get(self, "nlu_improvement_specification")

    @nlu_improvement_specification.setter
    def nlu_improvement_specification(self, value: Optional[pulumi.Input['BotGenerativeAiSettingsRuntimeSettingsPropertiesNluImprovementSpecificationPropertiesArgs']]):
        pulumi.set(self, "nlu_improvement_specification", value)

    @_builtins.property
    @pulumi.getter(name="slotResolutionImprovementSpecification")
    def slot_resolution_improvement_specification(self) -> Optional[pulumi.Input['BotGenerativeAiSettingsRuntimeSettingsPropertiesSlotResolutionImprovementSpecificationPropertiesArgs']]:
        return pulumi.get(self, "slot_resolution_improvement_specification")

    @slot_resolution_improvement_specification.setter
    def slot_resolution_improvement_specification(self, value: Optional[pulumi.Input['BotGenerativeAiSettingsRuntimeSettingsPropertiesSlotResolutionImprovementSpecificationPropertiesArgs']]):
        pulumi.set(self, "slot_resolution_improvement_specification", value)


if not MYPY:
    class BotGenerativeAiSettingsArgsDict(TypedDict):
        buildtime_settings: NotRequired[pulumi.Input['BotGenerativeAiSettingsBuildtimeSettingsPropertiesArgsDict']]
        runtime_settings: NotRequired[pulumi.Input['BotGenerativeAiSettingsRuntimeSettingsPropertiesArgsDict']]
elif False:
    BotGenerativeAiSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotGenerativeAiSettingsArgs:
    def __init__(__self__, *,
                 buildtime_settings: Optional[pulumi.Input['BotGenerativeAiSettingsBuildtimeSettingsPropertiesArgs']] = None,
                 runtime_settings: Optional[pulumi.Input['BotGenerativeAiSettingsRuntimeSettingsPropertiesArgs']] = None):
        if buildtime_settings is not None:
            pulumi.set(__self__, "buildtime_settings", buildtime_settings)
        if runtime_settings is not None:
            pulumi.set(__self__, "runtime_settings", runtime_settings)

    @_builtins.property
    @pulumi.getter(name="buildtimeSettings")
    def buildtime_settings(self) -> Optional[pulumi.Input['BotGenerativeAiSettingsBuildtimeSettingsPropertiesArgs']]:
        return pulumi.get(self, "buildtime_settings")

    @buildtime_settings.setter
    def buildtime_settings(self, value: Optional[pulumi.Input['BotGenerativeAiSettingsBuildtimeSettingsPropertiesArgs']]):
        pulumi.set(self, "buildtime_settings", value)

    @_builtins.property
    @pulumi.getter(name="runtimeSettings")
    def runtime_settings(self) -> Optional[pulumi.Input['BotGenerativeAiSettingsRuntimeSettingsPropertiesArgs']]:
        return pulumi.get(self, "runtime_settings")

    @runtime_settings.setter
    def runtime_settings(self, value: Optional[pulumi.Input['BotGenerativeAiSettingsRuntimeSettingsPropertiesArgs']]):
        pulumi.set(self, "runtime_settings", value)


if not MYPY:
    class BotGrammarSlotTypeSettingArgsDict(TypedDict):
        source: NotRequired[pulumi.Input['BotGrammarSlotTypeSourceArgsDict']]
        """
        The source of the grammar used to create the slot type.
        """
elif False:
    BotGrammarSlotTypeSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotGrammarSlotTypeSettingArgs:
    def __init__(__self__, *,
                 source: Optional[pulumi.Input['BotGrammarSlotTypeSourceArgs']] = None):
        """
        :param pulumi.Input['BotGrammarSlotTypeSourceArgs'] source: The source of the grammar used to create the slot type.
        """
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input['BotGrammarSlotTypeSourceArgs']]:
        """
        The source of the grammar used to create the slot type.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input['BotGrammarSlotTypeSourceArgs']]):
        pulumi.set(self, "source", value)


if not MYPY:
    class BotGrammarSlotTypeSourceArgsDict(TypedDict):
        s3_bucket_name: pulumi.Input[_builtins.str]
        """
        The name of the Amazon S3 bucket that contains the grammar source.
        """
        s3_object_key: pulumi.Input[_builtins.str]
        """
        The path to the grammar in the Amazon S3 bucket.
        """
        kms_key_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The AWS KMS key required to decrypt the contents of the grammar, if any.
        """
elif False:
    BotGrammarSlotTypeSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotGrammarSlotTypeSourceArgs:
    def __init__(__self__, *,
                 s3_bucket_name: pulumi.Input[_builtins.str],
                 s3_object_key: pulumi.Input[_builtins.str],
                 kms_key_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] s3_bucket_name: The name of the Amazon S3 bucket that contains the grammar source.
        :param pulumi.Input[_builtins.str] s3_object_key: The path to the grammar in the Amazon S3 bucket.
        :param pulumi.Input[_builtins.str] kms_key_arn: The AWS KMS key required to decrypt the contents of the grammar, if any.
        """
        pulumi.set(__self__, "s3_bucket_name", s3_bucket_name)
        pulumi.set(__self__, "s3_object_key", s3_object_key)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @_builtins.property
    @pulumi.getter(name="s3BucketName")
    def s3_bucket_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the Amazon S3 bucket that contains the grammar source.
        """
        return pulumi.get(self, "s3_bucket_name")

    @s3_bucket_name.setter
    def s3_bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "s3_bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="s3ObjectKey")
    def s3_object_key(self) -> pulumi.Input[_builtins.str]:
        """
        The path to the grammar in the Amazon S3 bucket.
        """
        return pulumi.get(self, "s3_object_key")

    @s3_object_key.setter
    def s3_object_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "s3_object_key", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The AWS KMS key required to decrypt the contents of the grammar, if any.
        """
        return pulumi.get(self, "kms_key_arn")

    @kms_key_arn.setter
    def kms_key_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_arn", value)


if not MYPY:
    class BotImageResponseCardArgsDict(TypedDict):
        title: pulumi.Input[_builtins.str]
        buttons: NotRequired[pulumi.Input[Sequence[pulumi.Input['BotButtonArgsDict']]]]
        image_url: NotRequired[pulumi.Input[_builtins.str]]
        subtitle: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    BotImageResponseCardArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotImageResponseCardArgs:
    def __init__(__self__, *,
                 title: pulumi.Input[_builtins.str],
                 buttons: Optional[pulumi.Input[Sequence[pulumi.Input['BotButtonArgs']]]] = None,
                 image_url: Optional[pulumi.Input[_builtins.str]] = None,
                 subtitle: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "title", title)
        if buttons is not None:
            pulumi.set(__self__, "buttons", buttons)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if subtitle is not None:
            pulumi.set(__self__, "subtitle", subtitle)

    @_builtins.property
    @pulumi.getter
    def title(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "title", value)

    @_builtins.property
    @pulumi.getter
    def buttons(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotButtonArgs']]]]:
        return pulumi.get(self, "buttons")

    @buttons.setter
    def buttons(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotButtonArgs']]]]):
        pulumi.set(self, "buttons", value)

    @_builtins.property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image_url", value)

    @_builtins.property
    @pulumi.getter
    def subtitle(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "subtitle")

    @subtitle.setter
    def subtitle(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subtitle", value)


if not MYPY:
    class BotInitialResponseSettingArgsDict(TypedDict):
        code_hook: NotRequired[pulumi.Input['BotDialogCodeHookInvocationSettingArgsDict']]
        """
        Settings that specify the dialog code hook that is called by Amazon Lex at a step of the conversation.
        """
        conditional: NotRequired[pulumi.Input['BotConditionalSpecificationArgsDict']]
        """
        Provides a list of conditional branches. Branches are evaluated in the order that they are entered in the list. The first branch with a condition that evaluates to true is executed. The last branch in the list is the default branch. The default branch should not have any condition expression. The default branch is executed if no other branch has a matching condition.
        """
        initial_response: NotRequired[pulumi.Input['BotResponseSpecificationArgsDict']]
        """
        Specifies a list of message groups that Amazon Lex uses to respond the user input.
        """
        next_step: NotRequired[pulumi.Input['BotDialogStateArgsDict']]
        """
        The next step in the conversation.
        """
elif False:
    BotInitialResponseSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotInitialResponseSettingArgs:
    def __init__(__self__, *,
                 code_hook: Optional[pulumi.Input['BotDialogCodeHookInvocationSettingArgs']] = None,
                 conditional: Optional[pulumi.Input['BotConditionalSpecificationArgs']] = None,
                 initial_response: Optional[pulumi.Input['BotResponseSpecificationArgs']] = None,
                 next_step: Optional[pulumi.Input['BotDialogStateArgs']] = None):
        """
        :param pulumi.Input['BotDialogCodeHookInvocationSettingArgs'] code_hook: Settings that specify the dialog code hook that is called by Amazon Lex at a step of the conversation.
        :param pulumi.Input['BotConditionalSpecificationArgs'] conditional: Provides a list of conditional branches. Branches are evaluated in the order that they are entered in the list. The first branch with a condition that evaluates to true is executed. The last branch in the list is the default branch. The default branch should not have any condition expression. The default branch is executed if no other branch has a matching condition.
        :param pulumi.Input['BotResponseSpecificationArgs'] initial_response: Specifies a list of message groups that Amazon Lex uses to respond the user input.
        :param pulumi.Input['BotDialogStateArgs'] next_step: The next step in the conversation.
        """
        if code_hook is not None:
            pulumi.set(__self__, "code_hook", code_hook)
        if conditional is not None:
            pulumi.set(__self__, "conditional", conditional)
        if initial_response is not None:
            pulumi.set(__self__, "initial_response", initial_response)
        if next_step is not None:
            pulumi.set(__self__, "next_step", next_step)

    @_builtins.property
    @pulumi.getter(name="codeHook")
    def code_hook(self) -> Optional[pulumi.Input['BotDialogCodeHookInvocationSettingArgs']]:
        """
        Settings that specify the dialog code hook that is called by Amazon Lex at a step of the conversation.
        """
        return pulumi.get(self, "code_hook")

    @code_hook.setter
    def code_hook(self, value: Optional[pulumi.Input['BotDialogCodeHookInvocationSettingArgs']]):
        pulumi.set(self, "code_hook", value)

    @_builtins.property
    @pulumi.getter
    def conditional(self) -> Optional[pulumi.Input['BotConditionalSpecificationArgs']]:
        """
        Provides a list of conditional branches. Branches are evaluated in the order that they are entered in the list. The first branch with a condition that evaluates to true is executed. The last branch in the list is the default branch. The default branch should not have any condition expression. The default branch is executed if no other branch has a matching condition.
        """
        return pulumi.get(self, "conditional")

    @conditional.setter
    def conditional(self, value: Optional[pulumi.Input['BotConditionalSpecificationArgs']]):
        pulumi.set(self, "conditional", value)

    @_builtins.property
    @pulumi.getter(name="initialResponse")
    def initial_response(self) -> Optional[pulumi.Input['BotResponseSpecificationArgs']]:
        """
        Specifies a list of message groups that Amazon Lex uses to respond the user input.
        """
        return pulumi.get(self, "initial_response")

    @initial_response.setter
    def initial_response(self, value: Optional[pulumi.Input['BotResponseSpecificationArgs']]):
        pulumi.set(self, "initial_response", value)

    @_builtins.property
    @pulumi.getter(name="nextStep")
    def next_step(self) -> Optional[pulumi.Input['BotDialogStateArgs']]:
        """
        The next step in the conversation.
        """
        return pulumi.get(self, "next_step")

    @next_step.setter
    def next_step(self, value: Optional[pulumi.Input['BotDialogStateArgs']]):
        pulumi.set(self, "next_step", value)


if not MYPY:
    class BotInputContextArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
elif False:
    BotInputContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotInputContextArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class BotIntentClosingSettingArgsDict(TypedDict):
        closing_response: NotRequired[pulumi.Input['BotResponseSpecificationArgsDict']]
        """
        The response that Amazon Lex sends to the user when the intent is complete.
        """
        conditional: NotRequired[pulumi.Input['BotConditionalSpecificationArgsDict']]
        """
        A list of conditional branches associated with the intent's closing response. These branches are executed when the `nextStep` attribute is set to `EvalutateConditional` .
        """
        is_active: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether an intent's closing response is used. When this field is false, the closing response isn't sent to the user. If the `IsActive` field isn't specified, the default is true.
        """
        next_step: NotRequired[pulumi.Input['BotDialogStateArgsDict']]
        """
        Specifies the next step that the bot executes after playing the intent's closing response.
        """
elif False:
    BotIntentClosingSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotIntentClosingSettingArgs:
    def __init__(__self__, *,
                 closing_response: Optional[pulumi.Input['BotResponseSpecificationArgs']] = None,
                 conditional: Optional[pulumi.Input['BotConditionalSpecificationArgs']] = None,
                 is_active: Optional[pulumi.Input[_builtins.bool]] = None,
                 next_step: Optional[pulumi.Input['BotDialogStateArgs']] = None):
        """
        :param pulumi.Input['BotResponseSpecificationArgs'] closing_response: The response that Amazon Lex sends to the user when the intent is complete.
        :param pulumi.Input['BotConditionalSpecificationArgs'] conditional: A list of conditional branches associated with the intent's closing response. These branches are executed when the `nextStep` attribute is set to `EvalutateConditional` .
        :param pulumi.Input[_builtins.bool] is_active: Specifies whether an intent's closing response is used. When this field is false, the closing response isn't sent to the user. If the `IsActive` field isn't specified, the default is true.
        :param pulumi.Input['BotDialogStateArgs'] next_step: Specifies the next step that the bot executes after playing the intent's closing response.
        """
        if closing_response is not None:
            pulumi.set(__self__, "closing_response", closing_response)
        if conditional is not None:
            pulumi.set(__self__, "conditional", conditional)
        if is_active is not None:
            pulumi.set(__self__, "is_active", is_active)
        if next_step is not None:
            pulumi.set(__self__, "next_step", next_step)

    @_builtins.property
    @pulumi.getter(name="closingResponse")
    def closing_response(self) -> Optional[pulumi.Input['BotResponseSpecificationArgs']]:
        """
        The response that Amazon Lex sends to the user when the intent is complete.
        """
        return pulumi.get(self, "closing_response")

    @closing_response.setter
    def closing_response(self, value: Optional[pulumi.Input['BotResponseSpecificationArgs']]):
        pulumi.set(self, "closing_response", value)

    @_builtins.property
    @pulumi.getter
    def conditional(self) -> Optional[pulumi.Input['BotConditionalSpecificationArgs']]:
        """
        A list of conditional branches associated with the intent's closing response. These branches are executed when the `nextStep` attribute is set to `EvalutateConditional` .
        """
        return pulumi.get(self, "conditional")

    @conditional.setter
    def conditional(self, value: Optional[pulumi.Input['BotConditionalSpecificationArgs']]):
        pulumi.set(self, "conditional", value)

    @_builtins.property
    @pulumi.getter(name="isActive")
    def is_active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether an intent's closing response is used. When this field is false, the closing response isn't sent to the user. If the `IsActive` field isn't specified, the default is true.
        """
        return pulumi.get(self, "is_active")

    @is_active.setter
    def is_active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_active", value)

    @_builtins.property
    @pulumi.getter(name="nextStep")
    def next_step(self) -> Optional[pulumi.Input['BotDialogStateArgs']]:
        """
        Specifies the next step that the bot executes after playing the intent's closing response.
        """
        return pulumi.get(self, "next_step")

    @next_step.setter
    def next_step(self, value: Optional[pulumi.Input['BotDialogStateArgs']]):
        pulumi.set(self, "next_step", value)


if not MYPY:
    class BotIntentConfirmationSettingArgsDict(TypedDict):
        prompt_specification: pulumi.Input['BotPromptSpecificationArgsDict']
        """
        Prompts the user to confirm the intent. This question should have a yes or no answer.

        Amazon Lex uses this prompt to ensure that the user acknowledges that the intent is ready for fulfillment. For example, with the `OrderPizza` intent, you might want to confirm that the order is correct before placing it. For other intents, such as intents that simply respond to user questions, you might not need to ask the user for confirmation before providing the information.
        """
        code_hook: NotRequired[pulumi.Input['BotDialogCodeHookInvocationSettingArgsDict']]
        """
        The `DialogCodeHookInvocationSetting` object associated with intent's confirmation step. The dialog code hook is triggered based on these invocation settings when the confirmation next step or declination next step or failure next step is `InvokeDialogCodeHook` .
        """
        confirmation_conditional: NotRequired[pulumi.Input['BotConditionalSpecificationArgsDict']]
        """
        A list of conditional branches to evaluate after the intent is closed.
        """
        confirmation_next_step: NotRequired[pulumi.Input['BotDialogStateArgsDict']]
        """
        Specifies the next step that the bot executes when the customer confirms the intent.
        """
        confirmation_response: NotRequired[pulumi.Input['BotResponseSpecificationArgsDict']]
        """
        Specifies a list of message groups that Amazon Lex uses to respond the user input.
        """
        declination_conditional: NotRequired[pulumi.Input['BotConditionalSpecificationArgsDict']]
        """
        A list of conditional branches to evaluate after the intent is declined.
        """
        declination_next_step: NotRequired[pulumi.Input['BotDialogStateArgsDict']]
        """
        Specifies the next step that the bot executes when the customer declines the intent.
        """
        declination_response: NotRequired[pulumi.Input['BotResponseSpecificationArgsDict']]
        """
        When the user answers "no" to the question defined in `promptSpecification` , Amazon Lex responds with this response to acknowledge that the intent was canceled.
        """
        elicitation_code_hook: NotRequired[pulumi.Input['BotElicitationCodeHookInvocationSettingArgsDict']]
        """
        The `DialogCodeHookInvocationSetting` used when the code hook is invoked during confirmation prompt retries.
        """
        failure_conditional: NotRequired[pulumi.Input['BotConditionalSpecificationArgsDict']]
        """
        Provides a list of conditional branches. Branches are evaluated in the order that they are entered in the list. The first branch with a condition that evaluates to true is executed. The last branch in the list is the default branch. The default branch should not have any condition expression. The default branch is executed if no other branch has a matching condition.
        """
        failure_next_step: NotRequired[pulumi.Input['BotDialogStateArgsDict']]
        """
        The next step to take in the conversation if the confirmation step fails.
        """
        failure_response: NotRequired[pulumi.Input['BotResponseSpecificationArgsDict']]
        """
        Specifies a list of message groups that Amazon Lex uses to respond the user input when the intent confirmation fails.
        """
        is_active: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether the intent's confirmation is sent to the user. When this field is false, confirmation and declination responses aren't sent. If the `IsActive` field isn't specified, the default is true.
        """
elif False:
    BotIntentConfirmationSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotIntentConfirmationSettingArgs:
    def __init__(__self__, *,
                 prompt_specification: pulumi.Input['BotPromptSpecificationArgs'],
                 code_hook: Optional[pulumi.Input['BotDialogCodeHookInvocationSettingArgs']] = None,
                 confirmation_conditional: Optional[pulumi.Input['BotConditionalSpecificationArgs']] = None,
                 confirmation_next_step: Optional[pulumi.Input['BotDialogStateArgs']] = None,
                 confirmation_response: Optional[pulumi.Input['BotResponseSpecificationArgs']] = None,
                 declination_conditional: Optional[pulumi.Input['BotConditionalSpecificationArgs']] = None,
                 declination_next_step: Optional[pulumi.Input['BotDialogStateArgs']] = None,
                 declination_response: Optional[pulumi.Input['BotResponseSpecificationArgs']] = None,
                 elicitation_code_hook: Optional[pulumi.Input['BotElicitationCodeHookInvocationSettingArgs']] = None,
                 failure_conditional: Optional[pulumi.Input['BotConditionalSpecificationArgs']] = None,
                 failure_next_step: Optional[pulumi.Input['BotDialogStateArgs']] = None,
                 failure_response: Optional[pulumi.Input['BotResponseSpecificationArgs']] = None,
                 is_active: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input['BotPromptSpecificationArgs'] prompt_specification: Prompts the user to confirm the intent. This question should have a yes or no answer.
               
               Amazon Lex uses this prompt to ensure that the user acknowledges that the intent is ready for fulfillment. For example, with the `OrderPizza` intent, you might want to confirm that the order is correct before placing it. For other intents, such as intents that simply respond to user questions, you might not need to ask the user for confirmation before providing the information.
        :param pulumi.Input['BotDialogCodeHookInvocationSettingArgs'] code_hook: The `DialogCodeHookInvocationSetting` object associated with intent's confirmation step. The dialog code hook is triggered based on these invocation settings when the confirmation next step or declination next step or failure next step is `InvokeDialogCodeHook` .
        :param pulumi.Input['BotConditionalSpecificationArgs'] confirmation_conditional: A list of conditional branches to evaluate after the intent is closed.
        :param pulumi.Input['BotDialogStateArgs'] confirmation_next_step: Specifies the next step that the bot executes when the customer confirms the intent.
        :param pulumi.Input['BotResponseSpecificationArgs'] confirmation_response: Specifies a list of message groups that Amazon Lex uses to respond the user input.
        :param pulumi.Input['BotConditionalSpecificationArgs'] declination_conditional: A list of conditional branches to evaluate after the intent is declined.
        :param pulumi.Input['BotDialogStateArgs'] declination_next_step: Specifies the next step that the bot executes when the customer declines the intent.
        :param pulumi.Input['BotResponseSpecificationArgs'] declination_response: When the user answers "no" to the question defined in `promptSpecification` , Amazon Lex responds with this response to acknowledge that the intent was canceled.
        :param pulumi.Input['BotElicitationCodeHookInvocationSettingArgs'] elicitation_code_hook: The `DialogCodeHookInvocationSetting` used when the code hook is invoked during confirmation prompt retries.
        :param pulumi.Input['BotConditionalSpecificationArgs'] failure_conditional: Provides a list of conditional branches. Branches are evaluated in the order that they are entered in the list. The first branch with a condition that evaluates to true is executed. The last branch in the list is the default branch. The default branch should not have any condition expression. The default branch is executed if no other branch has a matching condition.
        :param pulumi.Input['BotDialogStateArgs'] failure_next_step: The next step to take in the conversation if the confirmation step fails.
        :param pulumi.Input['BotResponseSpecificationArgs'] failure_response: Specifies a list of message groups that Amazon Lex uses to respond the user input when the intent confirmation fails.
        :param pulumi.Input[_builtins.bool] is_active: Specifies whether the intent's confirmation is sent to the user. When this field is false, confirmation and declination responses aren't sent. If the `IsActive` field isn't specified, the default is true.
        """
        pulumi.set(__self__, "prompt_specification", prompt_specification)
        if code_hook is not None:
            pulumi.set(__self__, "code_hook", code_hook)
        if confirmation_conditional is not None:
            pulumi.set(__self__, "confirmation_conditional", confirmation_conditional)
        if confirmation_next_step is not None:
            pulumi.set(__self__, "confirmation_next_step", confirmation_next_step)
        if confirmation_response is not None:
            pulumi.set(__self__, "confirmation_response", confirmation_response)
        if declination_conditional is not None:
            pulumi.set(__self__, "declination_conditional", declination_conditional)
        if declination_next_step is not None:
            pulumi.set(__self__, "declination_next_step", declination_next_step)
        if declination_response is not None:
            pulumi.set(__self__, "declination_response", declination_response)
        if elicitation_code_hook is not None:
            pulumi.set(__self__, "elicitation_code_hook", elicitation_code_hook)
        if failure_conditional is not None:
            pulumi.set(__self__, "failure_conditional", failure_conditional)
        if failure_next_step is not None:
            pulumi.set(__self__, "failure_next_step", failure_next_step)
        if failure_response is not None:
            pulumi.set(__self__, "failure_response", failure_response)
        if is_active is not None:
            pulumi.set(__self__, "is_active", is_active)

    @_builtins.property
    @pulumi.getter(name="promptSpecification")
    def prompt_specification(self) -> pulumi.Input['BotPromptSpecificationArgs']:
        """
        Prompts the user to confirm the intent. This question should have a yes or no answer.

        Amazon Lex uses this prompt to ensure that the user acknowledges that the intent is ready for fulfillment. For example, with the `OrderPizza` intent, you might want to confirm that the order is correct before placing it. For other intents, such as intents that simply respond to user questions, you might not need to ask the user for confirmation before providing the information.
        """
        return pulumi.get(self, "prompt_specification")

    @prompt_specification.setter
    def prompt_specification(self, value: pulumi.Input['BotPromptSpecificationArgs']):
        pulumi.set(self, "prompt_specification", value)

    @_builtins.property
    @pulumi.getter(name="codeHook")
    def code_hook(self) -> Optional[pulumi.Input['BotDialogCodeHookInvocationSettingArgs']]:
        """
        The `DialogCodeHookInvocationSetting` object associated with intent's confirmation step. The dialog code hook is triggered based on these invocation settings when the confirmation next step or declination next step or failure next step is `InvokeDialogCodeHook` .
        """
        return pulumi.get(self, "code_hook")

    @code_hook.setter
    def code_hook(self, value: Optional[pulumi.Input['BotDialogCodeHookInvocationSettingArgs']]):
        pulumi.set(self, "code_hook", value)

    @_builtins.property
    @pulumi.getter(name="confirmationConditional")
    def confirmation_conditional(self) -> Optional[pulumi.Input['BotConditionalSpecificationArgs']]:
        """
        A list of conditional branches to evaluate after the intent is closed.
        """
        return pulumi.get(self, "confirmation_conditional")

    @confirmation_conditional.setter
    def confirmation_conditional(self, value: Optional[pulumi.Input['BotConditionalSpecificationArgs']]):
        pulumi.set(self, "confirmation_conditional", value)

    @_builtins.property
    @pulumi.getter(name="confirmationNextStep")
    def confirmation_next_step(self) -> Optional[pulumi.Input['BotDialogStateArgs']]:
        """
        Specifies the next step that the bot executes when the customer confirms the intent.
        """
        return pulumi.get(self, "confirmation_next_step")

    @confirmation_next_step.setter
    def confirmation_next_step(self, value: Optional[pulumi.Input['BotDialogStateArgs']]):
        pulumi.set(self, "confirmation_next_step", value)

    @_builtins.property
    @pulumi.getter(name="confirmationResponse")
    def confirmation_response(self) -> Optional[pulumi.Input['BotResponseSpecificationArgs']]:
        """
        Specifies a list of message groups that Amazon Lex uses to respond the user input.
        """
        return pulumi.get(self, "confirmation_response")

    @confirmation_response.setter
    def confirmation_response(self, value: Optional[pulumi.Input['BotResponseSpecificationArgs']]):
        pulumi.set(self, "confirmation_response", value)

    @_builtins.property
    @pulumi.getter(name="declinationConditional")
    def declination_conditional(self) -> Optional[pulumi.Input['BotConditionalSpecificationArgs']]:
        """
        A list of conditional branches to evaluate after the intent is declined.
        """
        return pulumi.get(self, "declination_conditional")

    @declination_conditional.setter
    def declination_conditional(self, value: Optional[pulumi.Input['BotConditionalSpecificationArgs']]):
        pulumi.set(self, "declination_conditional", value)

    @_builtins.property
    @pulumi.getter(name="declinationNextStep")
    def declination_next_step(self) -> Optional[pulumi.Input['BotDialogStateArgs']]:
        """
        Specifies the next step that the bot executes when the customer declines the intent.
        """
        return pulumi.get(self, "declination_next_step")

    @declination_next_step.setter
    def declination_next_step(self, value: Optional[pulumi.Input['BotDialogStateArgs']]):
        pulumi.set(self, "declination_next_step", value)

    @_builtins.property
    @pulumi.getter(name="declinationResponse")
    def declination_response(self) -> Optional[pulumi.Input['BotResponseSpecificationArgs']]:
        """
        When the user answers "no" to the question defined in `promptSpecification` , Amazon Lex responds with this response to acknowledge that the intent was canceled.
        """
        return pulumi.get(self, "declination_response")

    @declination_response.setter
    def declination_response(self, value: Optional[pulumi.Input['BotResponseSpecificationArgs']]):
        pulumi.set(self, "declination_response", value)

    @_builtins.property
    @pulumi.getter(name="elicitationCodeHook")
    def elicitation_code_hook(self) -> Optional[pulumi.Input['BotElicitationCodeHookInvocationSettingArgs']]:
        """
        The `DialogCodeHookInvocationSetting` used when the code hook is invoked during confirmation prompt retries.
        """
        return pulumi.get(self, "elicitation_code_hook")

    @elicitation_code_hook.setter
    def elicitation_code_hook(self, value: Optional[pulumi.Input['BotElicitationCodeHookInvocationSettingArgs']]):
        pulumi.set(self, "elicitation_code_hook", value)

    @_builtins.property
    @pulumi.getter(name="failureConditional")
    def failure_conditional(self) -> Optional[pulumi.Input['BotConditionalSpecificationArgs']]:
        """
        Provides a list of conditional branches. Branches are evaluated in the order that they are entered in the list. The first branch with a condition that evaluates to true is executed. The last branch in the list is the default branch. The default branch should not have any condition expression. The default branch is executed if no other branch has a matching condition.
        """
        return pulumi.get(self, "failure_conditional")

    @failure_conditional.setter
    def failure_conditional(self, value: Optional[pulumi.Input['BotConditionalSpecificationArgs']]):
        pulumi.set(self, "failure_conditional", value)

    @_builtins.property
    @pulumi.getter(name="failureNextStep")
    def failure_next_step(self) -> Optional[pulumi.Input['BotDialogStateArgs']]:
        """
        The next step to take in the conversation if the confirmation step fails.
        """
        return pulumi.get(self, "failure_next_step")

    @failure_next_step.setter
    def failure_next_step(self, value: Optional[pulumi.Input['BotDialogStateArgs']]):
        pulumi.set(self, "failure_next_step", value)

    @_builtins.property
    @pulumi.getter(name="failureResponse")
    def failure_response(self) -> Optional[pulumi.Input['BotResponseSpecificationArgs']]:
        """
        Specifies a list of message groups that Amazon Lex uses to respond the user input when the intent confirmation fails.
        """
        return pulumi.get(self, "failure_response")

    @failure_response.setter
    def failure_response(self, value: Optional[pulumi.Input['BotResponseSpecificationArgs']]):
        pulumi.set(self, "failure_response", value)

    @_builtins.property
    @pulumi.getter(name="isActive")
    def is_active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether the intent's confirmation is sent to the user. When this field is false, confirmation and declination responses aren't sent. If the `IsActive` field isn't specified, the default is true.
        """
        return pulumi.get(self, "is_active")

    @is_active.setter
    def is_active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_active", value)


if not MYPY:
    class BotIntentOverrideArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the intent. Only required when you're switching intents.
        """
        slots: NotRequired[pulumi.Input[Sequence[pulumi.Input['BotSlotValueOverrideMapArgsDict']]]]
        """
        A map of all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden.
        """
elif False:
    BotIntentOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotIntentOverrideArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 slots: Optional[pulumi.Input[Sequence[pulumi.Input['BotSlotValueOverrideMapArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the intent. Only required when you're switching intents.
        :param pulumi.Input[Sequence[pulumi.Input['BotSlotValueOverrideMapArgs']]] slots: A map of all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slots is not None:
            pulumi.set(__self__, "slots", slots)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the intent. Only required when you're switching intents.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def slots(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotSlotValueOverrideMapArgs']]]]:
        """
        A map of all of the slot value overrides for the intent. The name of the slot maps to the value of the slot. Slots that are not included in the map aren't overridden.
        """
        return pulumi.get(self, "slots")

    @slots.setter
    def slots(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotSlotValueOverrideMapArgs']]]]):
        pulumi.set(self, "slots", value)


if not MYPY:
    class BotIntentArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of the intent. Intent names must be unique within the locale that contains the intent and can't match the name of any built-in intent.
        """
        bedrock_agent_intent_configuration: NotRequired[pulumi.Input['BotBedrockAgentIntentConfigurationArgsDict']]
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of thr intent.
        """
        dialog_code_hook: NotRequired[pulumi.Input['BotDialogCodeHookSettingArgsDict']]
        """
        Specifies that Amazon Lex invokes the alias Lambda function for each user input. You can invoke this Lambda function to personalize user interaction.
        """
        fulfillment_code_hook: NotRequired[pulumi.Input['BotFulfillmentCodeHookSettingArgsDict']]
        """
        Specifies that Amazon Lex invokes the alias Lambda function when the intent is ready for fulfillment. You can invoke this function to complete the bot's transaction with the user.
        """
        initial_response_setting: NotRequired[pulumi.Input['BotInitialResponseSettingArgsDict']]
        """
        Configuration setting for a response sent to the user before Amazon Lex starts eliciting slots.
        """
        input_contexts: NotRequired[pulumi.Input[Sequence[pulumi.Input['BotInputContextArgsDict']]]]
        """
        A list of contexts that must be active for this intent to be considered by Amazon Lex .
        """
        intent_closing_setting: NotRequired[pulumi.Input['BotIntentClosingSettingArgsDict']]
        """
        Sets the response that Amazon Lex sends to the user when the intent is closed.
        """
        intent_confirmation_setting: NotRequired[pulumi.Input['BotIntentConfirmationSettingArgsDict']]
        """
        Provides prompts that Amazon Lex sends to the user to confirm the completion of an intent. If the user answers "no," the settings contain a statement that is sent to the user to end the intent.
        """
        kendra_configuration: NotRequired[pulumi.Input['BotKendraConfigurationArgsDict']]
        """
        Provides configuration information for the `AMAZON.KendraSearchIntent` intent. When you use this intent, Amazon Lex searches the specified Amazon Kendra index and returns documents from the index that match the user's utterance.
        """
        output_contexts: NotRequired[pulumi.Input[Sequence[pulumi.Input['BotOutputContextArgsDict']]]]
        """
        A list of contexts that the intent activates when it is fulfilled.
        """
        parent_intent_signature: NotRequired[pulumi.Input[_builtins.str]]
        """
        A unique identifier for the built-in intent to base this intent on.
        """
        q_in_connect_intent_configuration: NotRequired[pulumi.Input['BotQInConnectIntentConfigurationArgsDict']]
        qn_a_intent_configuration: NotRequired[pulumi.Input['BotQnAIntentConfigurationArgsDict']]
        sample_utterances: NotRequired[pulumi.Input[Sequence[pulumi.Input['BotSampleUtteranceArgsDict']]]]
        """
        A list of utterances that a user might say to signal the intent.
        """
        slot_priorities: NotRequired[pulumi.Input[Sequence[pulumi.Input['BotSlotPriorityArgsDict']]]]
        """
        Indicates the priority for slots. Amazon Lex prompts the user for slot values in priority order.
        """
        slots: NotRequired[pulumi.Input[Sequence[pulumi.Input['BotSlotArgsDict']]]]
        """
        A list of slots that the intent requires for fulfillment.
        """
elif False:
    BotIntentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotIntentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 bedrock_agent_intent_configuration: Optional[pulumi.Input['BotBedrockAgentIntentConfigurationArgs']] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 dialog_code_hook: Optional[pulumi.Input['BotDialogCodeHookSettingArgs']] = None,
                 fulfillment_code_hook: Optional[pulumi.Input['BotFulfillmentCodeHookSettingArgs']] = None,
                 initial_response_setting: Optional[pulumi.Input['BotInitialResponseSettingArgs']] = None,
                 input_contexts: Optional[pulumi.Input[Sequence[pulumi.Input['BotInputContextArgs']]]] = None,
                 intent_closing_setting: Optional[pulumi.Input['BotIntentClosingSettingArgs']] = None,
                 intent_confirmation_setting: Optional[pulumi.Input['BotIntentConfirmationSettingArgs']] = None,
                 kendra_configuration: Optional[pulumi.Input['BotKendraConfigurationArgs']] = None,
                 output_contexts: Optional[pulumi.Input[Sequence[pulumi.Input['BotOutputContextArgs']]]] = None,
                 parent_intent_signature: Optional[pulumi.Input[_builtins.str]] = None,
                 q_in_connect_intent_configuration: Optional[pulumi.Input['BotQInConnectIntentConfigurationArgs']] = None,
                 qn_a_intent_configuration: Optional[pulumi.Input['BotQnAIntentConfigurationArgs']] = None,
                 sample_utterances: Optional[pulumi.Input[Sequence[pulumi.Input['BotSampleUtteranceArgs']]]] = None,
                 slot_priorities: Optional[pulumi.Input[Sequence[pulumi.Input['BotSlotPriorityArgs']]]] = None,
                 slots: Optional[pulumi.Input[Sequence[pulumi.Input['BotSlotArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the intent. Intent names must be unique within the locale that contains the intent and can't match the name of any built-in intent.
        :param pulumi.Input[_builtins.str] description: Description of thr intent.
        :param pulumi.Input['BotDialogCodeHookSettingArgs'] dialog_code_hook: Specifies that Amazon Lex invokes the alias Lambda function for each user input. You can invoke this Lambda function to personalize user interaction.
        :param pulumi.Input['BotFulfillmentCodeHookSettingArgs'] fulfillment_code_hook: Specifies that Amazon Lex invokes the alias Lambda function when the intent is ready for fulfillment. You can invoke this function to complete the bot's transaction with the user.
        :param pulumi.Input['BotInitialResponseSettingArgs'] initial_response_setting: Configuration setting for a response sent to the user before Amazon Lex starts eliciting slots.
        :param pulumi.Input[Sequence[pulumi.Input['BotInputContextArgs']]] input_contexts: A list of contexts that must be active for this intent to be considered by Amazon Lex .
        :param pulumi.Input['BotIntentClosingSettingArgs'] intent_closing_setting: Sets the response that Amazon Lex sends to the user when the intent is closed.
        :param pulumi.Input['BotIntentConfirmationSettingArgs'] intent_confirmation_setting: Provides prompts that Amazon Lex sends to the user to confirm the completion of an intent. If the user answers "no," the settings contain a statement that is sent to the user to end the intent.
        :param pulumi.Input['BotKendraConfigurationArgs'] kendra_configuration: Provides configuration information for the `AMAZON.KendraSearchIntent` intent. When you use this intent, Amazon Lex searches the specified Amazon Kendra index and returns documents from the index that match the user's utterance.
        :param pulumi.Input[Sequence[pulumi.Input['BotOutputContextArgs']]] output_contexts: A list of contexts that the intent activates when it is fulfilled.
        :param pulumi.Input[_builtins.str] parent_intent_signature: A unique identifier for the built-in intent to base this intent on.
        :param pulumi.Input[Sequence[pulumi.Input['BotSampleUtteranceArgs']]] sample_utterances: A list of utterances that a user might say to signal the intent.
        :param pulumi.Input[Sequence[pulumi.Input['BotSlotPriorityArgs']]] slot_priorities: Indicates the priority for slots. Amazon Lex prompts the user for slot values in priority order.
        :param pulumi.Input[Sequence[pulumi.Input['BotSlotArgs']]] slots: A list of slots that the intent requires for fulfillment.
        """
        pulumi.set(__self__, "name", name)
        if bedrock_agent_intent_configuration is not None:
            pulumi.set(__self__, "bedrock_agent_intent_configuration", bedrock_agent_intent_configuration)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if dialog_code_hook is not None:
            pulumi.set(__self__, "dialog_code_hook", dialog_code_hook)
        if fulfillment_code_hook is not None:
            pulumi.set(__self__, "fulfillment_code_hook", fulfillment_code_hook)
        if initial_response_setting is not None:
            pulumi.set(__self__, "initial_response_setting", initial_response_setting)
        if input_contexts is not None:
            pulumi.set(__self__, "input_contexts", input_contexts)
        if intent_closing_setting is not None:
            pulumi.set(__self__, "intent_closing_setting", intent_closing_setting)
        if intent_confirmation_setting is not None:
            pulumi.set(__self__, "intent_confirmation_setting", intent_confirmation_setting)
        if kendra_configuration is not None:
            pulumi.set(__self__, "kendra_configuration", kendra_configuration)
        if output_contexts is not None:
            pulumi.set(__self__, "output_contexts", output_contexts)
        if parent_intent_signature is not None:
            pulumi.set(__self__, "parent_intent_signature", parent_intent_signature)
        if q_in_connect_intent_configuration is not None:
            pulumi.set(__self__, "q_in_connect_intent_configuration", q_in_connect_intent_configuration)
        if qn_a_intent_configuration is not None:
            pulumi.set(__self__, "qn_a_intent_configuration", qn_a_intent_configuration)
        if sample_utterances is not None:
            pulumi.set(__self__, "sample_utterances", sample_utterances)
        if slot_priorities is not None:
            pulumi.set(__self__, "slot_priorities", slot_priorities)
        if slots is not None:
            pulumi.set(__self__, "slots", slots)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the intent. Intent names must be unique within the locale that contains the intent and can't match the name of any built-in intent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="bedrockAgentIntentConfiguration")
    def bedrock_agent_intent_configuration(self) -> Optional[pulumi.Input['BotBedrockAgentIntentConfigurationArgs']]:
        return pulumi.get(self, "bedrock_agent_intent_configuration")

    @bedrock_agent_intent_configuration.setter
    def bedrock_agent_intent_configuration(self, value: Optional[pulumi.Input['BotBedrockAgentIntentConfigurationArgs']]):
        pulumi.set(self, "bedrock_agent_intent_configuration", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of thr intent.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="dialogCodeHook")
    def dialog_code_hook(self) -> Optional[pulumi.Input['BotDialogCodeHookSettingArgs']]:
        """
        Specifies that Amazon Lex invokes the alias Lambda function for each user input. You can invoke this Lambda function to personalize user interaction.
        """
        return pulumi.get(self, "dialog_code_hook")

    @dialog_code_hook.setter
    def dialog_code_hook(self, value: Optional[pulumi.Input['BotDialogCodeHookSettingArgs']]):
        pulumi.set(self, "dialog_code_hook", value)

    @_builtins.property
    @pulumi.getter(name="fulfillmentCodeHook")
    def fulfillment_code_hook(self) -> Optional[pulumi.Input['BotFulfillmentCodeHookSettingArgs']]:
        """
        Specifies that Amazon Lex invokes the alias Lambda function when the intent is ready for fulfillment. You can invoke this function to complete the bot's transaction with the user.
        """
        return pulumi.get(self, "fulfillment_code_hook")

    @fulfillment_code_hook.setter
    def fulfillment_code_hook(self, value: Optional[pulumi.Input['BotFulfillmentCodeHookSettingArgs']]):
        pulumi.set(self, "fulfillment_code_hook", value)

    @_builtins.property
    @pulumi.getter(name="initialResponseSetting")
    def initial_response_setting(self) -> Optional[pulumi.Input['BotInitialResponseSettingArgs']]:
        """
        Configuration setting for a response sent to the user before Amazon Lex starts eliciting slots.
        """
        return pulumi.get(self, "initial_response_setting")

    @initial_response_setting.setter
    def initial_response_setting(self, value: Optional[pulumi.Input['BotInitialResponseSettingArgs']]):
        pulumi.set(self, "initial_response_setting", value)

    @_builtins.property
    @pulumi.getter(name="inputContexts")
    def input_contexts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotInputContextArgs']]]]:
        """
        A list of contexts that must be active for this intent to be considered by Amazon Lex .
        """
        return pulumi.get(self, "input_contexts")

    @input_contexts.setter
    def input_contexts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotInputContextArgs']]]]):
        pulumi.set(self, "input_contexts", value)

    @_builtins.property
    @pulumi.getter(name="intentClosingSetting")
    def intent_closing_setting(self) -> Optional[pulumi.Input['BotIntentClosingSettingArgs']]:
        """
        Sets the response that Amazon Lex sends to the user when the intent is closed.
        """
        return pulumi.get(self, "intent_closing_setting")

    @intent_closing_setting.setter
    def intent_closing_setting(self, value: Optional[pulumi.Input['BotIntentClosingSettingArgs']]):
        pulumi.set(self, "intent_closing_setting", value)

    @_builtins.property
    @pulumi.getter(name="intentConfirmationSetting")
    def intent_confirmation_setting(self) -> Optional[pulumi.Input['BotIntentConfirmationSettingArgs']]:
        """
        Provides prompts that Amazon Lex sends to the user to confirm the completion of an intent. If the user answers "no," the settings contain a statement that is sent to the user to end the intent.
        """
        return pulumi.get(self, "intent_confirmation_setting")

    @intent_confirmation_setting.setter
    def intent_confirmation_setting(self, value: Optional[pulumi.Input['BotIntentConfirmationSettingArgs']]):
        pulumi.set(self, "intent_confirmation_setting", value)

    @_builtins.property
    @pulumi.getter(name="kendraConfiguration")
    def kendra_configuration(self) -> Optional[pulumi.Input['BotKendraConfigurationArgs']]:
        """
        Provides configuration information for the `AMAZON.KendraSearchIntent` intent. When you use this intent, Amazon Lex searches the specified Amazon Kendra index and returns documents from the index that match the user's utterance.
        """
        return pulumi.get(self, "kendra_configuration")

    @kendra_configuration.setter
    def kendra_configuration(self, value: Optional[pulumi.Input['BotKendraConfigurationArgs']]):
        pulumi.set(self, "kendra_configuration", value)

    @_builtins.property
    @pulumi.getter(name="outputContexts")
    def output_contexts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotOutputContextArgs']]]]:
        """
        A list of contexts that the intent activates when it is fulfilled.
        """
        return pulumi.get(self, "output_contexts")

    @output_contexts.setter
    def output_contexts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotOutputContextArgs']]]]):
        pulumi.set(self, "output_contexts", value)

    @_builtins.property
    @pulumi.getter(name="parentIntentSignature")
    def parent_intent_signature(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A unique identifier for the built-in intent to base this intent on.
        """
        return pulumi.get(self, "parent_intent_signature")

    @parent_intent_signature.setter
    def parent_intent_signature(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "parent_intent_signature", value)

    @_builtins.property
    @pulumi.getter(name="qInConnectIntentConfiguration")
    def q_in_connect_intent_configuration(self) -> Optional[pulumi.Input['BotQInConnectIntentConfigurationArgs']]:
        return pulumi.get(self, "q_in_connect_intent_configuration")

    @q_in_connect_intent_configuration.setter
    def q_in_connect_intent_configuration(self, value: Optional[pulumi.Input['BotQInConnectIntentConfigurationArgs']]):
        pulumi.set(self, "q_in_connect_intent_configuration", value)

    @_builtins.property
    @pulumi.getter(name="qnAIntentConfiguration")
    def qn_a_intent_configuration(self) -> Optional[pulumi.Input['BotQnAIntentConfigurationArgs']]:
        return pulumi.get(self, "qn_a_intent_configuration")

    @qn_a_intent_configuration.setter
    def qn_a_intent_configuration(self, value: Optional[pulumi.Input['BotQnAIntentConfigurationArgs']]):
        pulumi.set(self, "qn_a_intent_configuration", value)

    @_builtins.property
    @pulumi.getter(name="sampleUtterances")
    def sample_utterances(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotSampleUtteranceArgs']]]]:
        """
        A list of utterances that a user might say to signal the intent.
        """
        return pulumi.get(self, "sample_utterances")

    @sample_utterances.setter
    def sample_utterances(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotSampleUtteranceArgs']]]]):
        pulumi.set(self, "sample_utterances", value)

    @_builtins.property
    @pulumi.getter(name="slotPriorities")
    def slot_priorities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotSlotPriorityArgs']]]]:
        """
        Indicates the priority for slots. Amazon Lex prompts the user for slot values in priority order.
        """
        return pulumi.get(self, "slot_priorities")

    @slot_priorities.setter
    def slot_priorities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotSlotPriorityArgs']]]]):
        pulumi.set(self, "slot_priorities", value)

    @_builtins.property
    @pulumi.getter
    def slots(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotSlotArgs']]]]:
        """
        A list of slots that the intent requires for fulfillment.
        """
        return pulumi.get(self, "slots")

    @slots.setter
    def slots(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotSlotArgs']]]]):
        pulumi.set(self, "slots", value)


if not MYPY:
    class BotKendraConfigurationArgsDict(TypedDict):
        kendra_index: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name (ARN) of the Amazon Kendra index that you want the `AMAZON.KendraSearchIntent` intent to search. The index must be in the same account and Region as the Amazon Lex bot.
        """
        query_filter_string: NotRequired[pulumi.Input[_builtins.str]]
        """
        A query filter that Amazon Lex sends to Amazon Kendra to filter the response from a query. The filter is in the format defined by Amazon Kendra. For more information, see [Filtering queries](https://docs.aws.amazon.com/kendra/latest/dg/filtering.html) .
        """
        query_filter_string_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Determines whether the `AMAZON.KendraSearchIntent` intent uses a custom query string to query the Amazon Kendra index.
        """
elif False:
    BotKendraConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotKendraConfigurationArgs:
    def __init__(__self__, *,
                 kendra_index: pulumi.Input[_builtins.str],
                 query_filter_string: Optional[pulumi.Input[_builtins.str]] = None,
                 query_filter_string_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] kendra_index: The Amazon Resource Name (ARN) of the Amazon Kendra index that you want the `AMAZON.KendraSearchIntent` intent to search. The index must be in the same account and Region as the Amazon Lex bot.
        :param pulumi.Input[_builtins.str] query_filter_string: A query filter that Amazon Lex sends to Amazon Kendra to filter the response from a query. The filter is in the format defined by Amazon Kendra. For more information, see [Filtering queries](https://docs.aws.amazon.com/kendra/latest/dg/filtering.html) .
        :param pulumi.Input[_builtins.bool] query_filter_string_enabled: Determines whether the `AMAZON.KendraSearchIntent` intent uses a custom query string to query the Amazon Kendra index.
        """
        pulumi.set(__self__, "kendra_index", kendra_index)
        if query_filter_string is not None:
            pulumi.set(__self__, "query_filter_string", query_filter_string)
        if query_filter_string_enabled is not None:
            pulumi.set(__self__, "query_filter_string_enabled", query_filter_string_enabled)

    @_builtins.property
    @pulumi.getter(name="kendraIndex")
    def kendra_index(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the Amazon Kendra index that you want the `AMAZON.KendraSearchIntent` intent to search. The index must be in the same account and Region as the Amazon Lex bot.
        """
        return pulumi.get(self, "kendra_index")

    @kendra_index.setter
    def kendra_index(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "kendra_index", value)

    @_builtins.property
    @pulumi.getter(name="queryFilterString")
    def query_filter_string(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A query filter that Amazon Lex sends to Amazon Kendra to filter the response from a query. The filter is in the format defined by Amazon Kendra. For more information, see [Filtering queries](https://docs.aws.amazon.com/kendra/latest/dg/filtering.html) .
        """
        return pulumi.get(self, "query_filter_string")

    @query_filter_string.setter
    def query_filter_string(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "query_filter_string", value)

    @_builtins.property
    @pulumi.getter(name="queryFilterStringEnabled")
    def query_filter_string_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether the `AMAZON.KendraSearchIntent` intent uses a custom query string to query the Amazon Kendra index.
        """
        return pulumi.get(self, "query_filter_string_enabled")

    @query_filter_string_enabled.setter
    def query_filter_string_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "query_filter_string_enabled", value)


if not MYPY:
    class BotLocaleArgsDict(TypedDict):
        locale_id: pulumi.Input[_builtins.str]
        """
        The identifier of the language and locale that the bot will be used in. The string must match one of the supported locales.
        """
        nlu_confidence_threshold: pulumi.Input[_builtins.float]
        """
        Determines the threshold where Amazon Lex will insert the `AMAZON.FallbackIntent` , `AMAZON.KendraSearchIntent` , or both when returning alternative intents. You must configure an `AMAZON.FallbackIntent` . `AMAZON.KendraSearchIntent` is only inserted if it is configured for the bot.
        """
        custom_vocabulary: NotRequired[pulumi.Input['BotCustomVocabularyArgsDict']]
        """
        Specifies a custom vocabulary to use with a specific locale.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of the bot locale. Use this to help identify the bot locale in lists.
        """
        generative_ai_settings: NotRequired[pulumi.Input['BotGenerativeAiSettingsArgsDict']]
        intents: NotRequired[pulumi.Input[Sequence[pulumi.Input['BotIntentArgsDict']]]]
        """
        One or more intents defined for the locale.
        """
        slot_types: NotRequired[pulumi.Input[Sequence[pulumi.Input['BotSlotTypeArgsDict']]]]
        """
        One or more slot types defined for the locale.
        """
        voice_settings: NotRequired[pulumi.Input['BotVoiceSettingsArgsDict']]
        """
        Defines settings for using an Amazon Polly voice to communicate with a user.

        Valid values include:

        - `standard`
        - `neural`
        - `long-form`
        - `generative`
        """
elif False:
    BotLocaleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotLocaleArgs:
    def __init__(__self__, *,
                 locale_id: pulumi.Input[_builtins.str],
                 nlu_confidence_threshold: pulumi.Input[_builtins.float],
                 custom_vocabulary: Optional[pulumi.Input['BotCustomVocabularyArgs']] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 generative_ai_settings: Optional[pulumi.Input['BotGenerativeAiSettingsArgs']] = None,
                 intents: Optional[pulumi.Input[Sequence[pulumi.Input['BotIntentArgs']]]] = None,
                 slot_types: Optional[pulumi.Input[Sequence[pulumi.Input['BotSlotTypeArgs']]]] = None,
                 voice_settings: Optional[pulumi.Input['BotVoiceSettingsArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] locale_id: The identifier of the language and locale that the bot will be used in. The string must match one of the supported locales.
        :param pulumi.Input[_builtins.float] nlu_confidence_threshold: Determines the threshold where Amazon Lex will insert the `AMAZON.FallbackIntent` , `AMAZON.KendraSearchIntent` , or both when returning alternative intents. You must configure an `AMAZON.FallbackIntent` . `AMAZON.KendraSearchIntent` is only inserted if it is configured for the bot.
        :param pulumi.Input['BotCustomVocabularyArgs'] custom_vocabulary: Specifies a custom vocabulary to use with a specific locale.
        :param pulumi.Input[_builtins.str] description: A description of the bot locale. Use this to help identify the bot locale in lists.
        :param pulumi.Input[Sequence[pulumi.Input['BotIntentArgs']]] intents: One or more intents defined for the locale.
        :param pulumi.Input[Sequence[pulumi.Input['BotSlotTypeArgs']]] slot_types: One or more slot types defined for the locale.
        :param pulumi.Input['BotVoiceSettingsArgs'] voice_settings: Defines settings for using an Amazon Polly voice to communicate with a user.
               
               Valid values include:
               
               - `standard`
               - `neural`
               - `long-form`
               - `generative`
        """
        pulumi.set(__self__, "locale_id", locale_id)
        pulumi.set(__self__, "nlu_confidence_threshold", nlu_confidence_threshold)
        if custom_vocabulary is not None:
            pulumi.set(__self__, "custom_vocabulary", custom_vocabulary)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if generative_ai_settings is not None:
            pulumi.set(__self__, "generative_ai_settings", generative_ai_settings)
        if intents is not None:
            pulumi.set(__self__, "intents", intents)
        if slot_types is not None:
            pulumi.set(__self__, "slot_types", slot_types)
        if voice_settings is not None:
            pulumi.set(__self__, "voice_settings", voice_settings)

    @_builtins.property
    @pulumi.getter(name="localeId")
    def locale_id(self) -> pulumi.Input[_builtins.str]:
        """
        The identifier of the language and locale that the bot will be used in. The string must match one of the supported locales.
        """
        return pulumi.get(self, "locale_id")

    @locale_id.setter
    def locale_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "locale_id", value)

    @_builtins.property
    @pulumi.getter(name="nluConfidenceThreshold")
    def nlu_confidence_threshold(self) -> pulumi.Input[_builtins.float]:
        """
        Determines the threshold where Amazon Lex will insert the `AMAZON.FallbackIntent` , `AMAZON.KendraSearchIntent` , or both when returning alternative intents. You must configure an `AMAZON.FallbackIntent` . `AMAZON.KendraSearchIntent` is only inserted if it is configured for the bot.
        """
        return pulumi.get(self, "nlu_confidence_threshold")

    @nlu_confidence_threshold.setter
    def nlu_confidence_threshold(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "nlu_confidence_threshold", value)

    @_builtins.property
    @pulumi.getter(name="customVocabulary")
    def custom_vocabulary(self) -> Optional[pulumi.Input['BotCustomVocabularyArgs']]:
        """
        Specifies a custom vocabulary to use with a specific locale.
        """
        return pulumi.get(self, "custom_vocabulary")

    @custom_vocabulary.setter
    def custom_vocabulary(self, value: Optional[pulumi.Input['BotCustomVocabularyArgs']]):
        pulumi.set(self, "custom_vocabulary", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of the bot locale. Use this to help identify the bot locale in lists.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="generativeAiSettings")
    def generative_ai_settings(self) -> Optional[pulumi.Input['BotGenerativeAiSettingsArgs']]:
        return pulumi.get(self, "generative_ai_settings")

    @generative_ai_settings.setter
    def generative_ai_settings(self, value: Optional[pulumi.Input['BotGenerativeAiSettingsArgs']]):
        pulumi.set(self, "generative_ai_settings", value)

    @_builtins.property
    @pulumi.getter
    def intents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotIntentArgs']]]]:
        """
        One or more intents defined for the locale.
        """
        return pulumi.get(self, "intents")

    @intents.setter
    def intents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotIntentArgs']]]]):
        pulumi.set(self, "intents", value)

    @_builtins.property
    @pulumi.getter(name="slotTypes")
    def slot_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotSlotTypeArgs']]]]:
        """
        One or more slot types defined for the locale.
        """
        return pulumi.get(self, "slot_types")

    @slot_types.setter
    def slot_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotSlotTypeArgs']]]]):
        pulumi.set(self, "slot_types", value)

    @_builtins.property
    @pulumi.getter(name="voiceSettings")
    def voice_settings(self) -> Optional[pulumi.Input['BotVoiceSettingsArgs']]:
        """
        Defines settings for using an Amazon Polly voice to communicate with a user.

        Valid values include:

        - `standard`
        - `neural`
        - `long-form`
        - `generative`
        """
        return pulumi.get(self, "voice_settings")

    @voice_settings.setter
    def voice_settings(self, value: Optional[pulumi.Input['BotVoiceSettingsArgs']]):
        pulumi.set(self, "voice_settings", value)


if not MYPY:
    class BotMessageGroupArgsDict(TypedDict):
        message: pulumi.Input['BotMessageArgsDict']
        variations: NotRequired[pulumi.Input[Sequence[pulumi.Input['BotMessageArgsDict']]]]
elif False:
    BotMessageGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotMessageGroupArgs:
    def __init__(__self__, *,
                 message: pulumi.Input['BotMessageArgs'],
                 variations: Optional[pulumi.Input[Sequence[pulumi.Input['BotMessageArgs']]]] = None):
        pulumi.set(__self__, "message", message)
        if variations is not None:
            pulumi.set(__self__, "variations", variations)

    @_builtins.property
    @pulumi.getter
    def message(self) -> pulumi.Input['BotMessageArgs']:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: pulumi.Input['BotMessageArgs']):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter
    def variations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotMessageArgs']]]]:
        return pulumi.get(self, "variations")

    @variations.setter
    def variations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotMessageArgs']]]]):
        pulumi.set(self, "variations", value)


if not MYPY:
    class BotMessageArgsDict(TypedDict):
        custom_payload: NotRequired[pulumi.Input['BotCustomPayloadArgsDict']]
        image_response_card: NotRequired[pulumi.Input['BotImageResponseCardArgsDict']]
        plain_text_message: NotRequired[pulumi.Input['BotPlainTextMessageArgsDict']]
        ssml_message: NotRequired[pulumi.Input['BotSsmlMessageArgsDict']]
elif False:
    BotMessageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotMessageArgs:
    def __init__(__self__, *,
                 custom_payload: Optional[pulumi.Input['BotCustomPayloadArgs']] = None,
                 image_response_card: Optional[pulumi.Input['BotImageResponseCardArgs']] = None,
                 plain_text_message: Optional[pulumi.Input['BotPlainTextMessageArgs']] = None,
                 ssml_message: Optional[pulumi.Input['BotSsmlMessageArgs']] = None):
        if custom_payload is not None:
            pulumi.set(__self__, "custom_payload", custom_payload)
        if image_response_card is not None:
            pulumi.set(__self__, "image_response_card", image_response_card)
        if plain_text_message is not None:
            pulumi.set(__self__, "plain_text_message", plain_text_message)
        if ssml_message is not None:
            pulumi.set(__self__, "ssml_message", ssml_message)

    @_builtins.property
    @pulumi.getter(name="customPayload")
    def custom_payload(self) -> Optional[pulumi.Input['BotCustomPayloadArgs']]:
        return pulumi.get(self, "custom_payload")

    @custom_payload.setter
    def custom_payload(self, value: Optional[pulumi.Input['BotCustomPayloadArgs']]):
        pulumi.set(self, "custom_payload", value)

    @_builtins.property
    @pulumi.getter(name="imageResponseCard")
    def image_response_card(self) -> Optional[pulumi.Input['BotImageResponseCardArgs']]:
        return pulumi.get(self, "image_response_card")

    @image_response_card.setter
    def image_response_card(self, value: Optional[pulumi.Input['BotImageResponseCardArgs']]):
        pulumi.set(self, "image_response_card", value)

    @_builtins.property
    @pulumi.getter(name="plainTextMessage")
    def plain_text_message(self) -> Optional[pulumi.Input['BotPlainTextMessageArgs']]:
        return pulumi.get(self, "plain_text_message")

    @plain_text_message.setter
    def plain_text_message(self, value: Optional[pulumi.Input['BotPlainTextMessageArgs']]):
        pulumi.set(self, "plain_text_message", value)

    @_builtins.property
    @pulumi.getter(name="ssmlMessage")
    def ssml_message(self) -> Optional[pulumi.Input['BotSsmlMessageArgs']]:
        return pulumi.get(self, "ssml_message")

    @ssml_message.setter
    def ssml_message(self, value: Optional[pulumi.Input['BotSsmlMessageArgs']]):
        pulumi.set(self, "ssml_message", value)


if not MYPY:
    class BotMultipleValuesSettingArgsDict(TypedDict):
        allow_multiple_values: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether a slot can return multiple values. When `true` , the slot may return more than one value in a response. When `false` , the slot returns only a single value.

        Multi-value slots are only available in the en-US locale. If you set this value to `true` in any other locale, Amazon Lex throws a `ValidationException` .

        If the `allowMutlipleValues` is not set, the default value is `false` .
        """
elif False:
    BotMultipleValuesSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotMultipleValuesSettingArgs:
    def __init__(__self__, *,
                 allow_multiple_values: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_multiple_values: Indicates whether a slot can return multiple values. When `true` , the slot may return more than one value in a response. When `false` , the slot returns only a single value.
               
               Multi-value slots are only available in the en-US locale. If you set this value to `true` in any other locale, Amazon Lex throws a `ValidationException` .
               
               If the `allowMutlipleValues` is not set, the default value is `false` .
        """
        if allow_multiple_values is not None:
            pulumi.set(__self__, "allow_multiple_values", allow_multiple_values)

    @_builtins.property
    @pulumi.getter(name="allowMultipleValues")
    def allow_multiple_values(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether a slot can return multiple values. When `true` , the slot may return more than one value in a response. When `false` , the slot returns only a single value.

        Multi-value slots are only available in the en-US locale. If you set this value to `true` in any other locale, Amazon Lex throws a `ValidationException` .

        If the `allowMutlipleValues` is not set, the default value is `false` .
        """
        return pulumi.get(self, "allow_multiple_values")

    @allow_multiple_values.setter
    def allow_multiple_values(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_multiple_values", value)


if not MYPY:
    class BotObfuscationSettingArgsDict(TypedDict):
        obfuscation_setting_type: pulumi.Input['BotObfuscationSettingObfuscationSettingType']
        """
        Value that determines whether Amazon Lex obscures slot values in conversation logs. The default is to obscure the values.
        """
elif False:
    BotObfuscationSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotObfuscationSettingArgs:
    def __init__(__self__, *,
                 obfuscation_setting_type: pulumi.Input['BotObfuscationSettingObfuscationSettingType']):
        """
        :param pulumi.Input['BotObfuscationSettingObfuscationSettingType'] obfuscation_setting_type: Value that determines whether Amazon Lex obscures slot values in conversation logs. The default is to obscure the values.
        """
        pulumi.set(__self__, "obfuscation_setting_type", obfuscation_setting_type)

    @_builtins.property
    @pulumi.getter(name="obfuscationSettingType")
    def obfuscation_setting_type(self) -> pulumi.Input['BotObfuscationSettingObfuscationSettingType']:
        """
        Value that determines whether Amazon Lex obscures slot values in conversation logs. The default is to obscure the values.
        """
        return pulumi.get(self, "obfuscation_setting_type")

    @obfuscation_setting_type.setter
    def obfuscation_setting_type(self, value: pulumi.Input['BotObfuscationSettingObfuscationSettingType']):
        pulumi.set(self, "obfuscation_setting_type", value)


if not MYPY:
    class BotOutputContextArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        time_to_live_in_seconds: pulumi.Input[_builtins.int]
        turns_to_live: pulumi.Input[_builtins.int]
elif False:
    BotOutputContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotOutputContextArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 time_to_live_in_seconds: pulumi.Input[_builtins.int],
                 turns_to_live: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "time_to_live_in_seconds", time_to_live_in_seconds)
        pulumi.set(__self__, "turns_to_live", turns_to_live)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="timeToLiveInSeconds")
    def time_to_live_in_seconds(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "time_to_live_in_seconds")

    @time_to_live_in_seconds.setter
    def time_to_live_in_seconds(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "time_to_live_in_seconds", value)

    @_builtins.property
    @pulumi.getter(name="turnsToLive")
    def turns_to_live(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "turns_to_live")

    @turns_to_live.setter
    def turns_to_live(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "turns_to_live", value)


if not MYPY:
    class BotPlainTextMessageArgsDict(TypedDict):
        value: pulumi.Input[_builtins.str]
elif False:
    BotPlainTextMessageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotPlainTextMessageArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class BotPostDialogCodeHookInvocationSpecificationArgsDict(TypedDict):
        failure_conditional: NotRequired[pulumi.Input['BotConditionalSpecificationArgsDict']]
        """
        A list of conditional branches to evaluate after the dialog code hook throws an exception or returns with the `State` field of the `Intent` object set to `Failed` .
        """
        failure_next_step: NotRequired[pulumi.Input['BotDialogStateArgsDict']]
        """
        Specifies the next step the bot runs after the dialog code hook throws an exception or returns with the `State` field of the `Intent` object set to `Failed` .
        """
        failure_response: NotRequired[pulumi.Input['BotResponseSpecificationArgsDict']]
        """
        Specifies a list of message groups that Amazon Lex uses to respond the user input when the code hook fails.
        """
        success_conditional: NotRequired[pulumi.Input['BotConditionalSpecificationArgsDict']]
        """
        A list of conditional branches to evaluate after the dialog code hook finishes successfully.
        """
        success_next_step: NotRequired[pulumi.Input['BotDialogStateArgsDict']]
        """
        Specifics the next step the bot runs after the dialog code hook finishes successfully.
        """
        success_response: NotRequired[pulumi.Input['BotResponseSpecificationArgsDict']]
        """
        Specifies a list of message groups that Amazon Lex uses to respond when the code hook succeeds.
        """
        timeout_conditional: NotRequired[pulumi.Input['BotConditionalSpecificationArgsDict']]
        """
        A list of conditional branches to evaluate if the code hook times out.
        """
        timeout_next_step: NotRequired[pulumi.Input['BotDialogStateArgsDict']]
        """
        Specifies the next step that the bot runs when the code hook times out.
        """
        timeout_response: NotRequired[pulumi.Input['BotResponseSpecificationArgsDict']]
        """
        Specifies a list of message groups that Amazon Lex uses to respond to the user input when the code hook times out.
        """
elif False:
    BotPostDialogCodeHookInvocationSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotPostDialogCodeHookInvocationSpecificationArgs:
    def __init__(__self__, *,
                 failure_conditional: Optional[pulumi.Input['BotConditionalSpecificationArgs']] = None,
                 failure_next_step: Optional[pulumi.Input['BotDialogStateArgs']] = None,
                 failure_response: Optional[pulumi.Input['BotResponseSpecificationArgs']] = None,
                 success_conditional: Optional[pulumi.Input['BotConditionalSpecificationArgs']] = None,
                 success_next_step: Optional[pulumi.Input['BotDialogStateArgs']] = None,
                 success_response: Optional[pulumi.Input['BotResponseSpecificationArgs']] = None,
                 timeout_conditional: Optional[pulumi.Input['BotConditionalSpecificationArgs']] = None,
                 timeout_next_step: Optional[pulumi.Input['BotDialogStateArgs']] = None,
                 timeout_response: Optional[pulumi.Input['BotResponseSpecificationArgs']] = None):
        """
        :param pulumi.Input['BotConditionalSpecificationArgs'] failure_conditional: A list of conditional branches to evaluate after the dialog code hook throws an exception or returns with the `State` field of the `Intent` object set to `Failed` .
        :param pulumi.Input['BotDialogStateArgs'] failure_next_step: Specifies the next step the bot runs after the dialog code hook throws an exception or returns with the `State` field of the `Intent` object set to `Failed` .
        :param pulumi.Input['BotResponseSpecificationArgs'] failure_response: Specifies a list of message groups that Amazon Lex uses to respond the user input when the code hook fails.
        :param pulumi.Input['BotConditionalSpecificationArgs'] success_conditional: A list of conditional branches to evaluate after the dialog code hook finishes successfully.
        :param pulumi.Input['BotDialogStateArgs'] success_next_step: Specifics the next step the bot runs after the dialog code hook finishes successfully.
        :param pulumi.Input['BotResponseSpecificationArgs'] success_response: Specifies a list of message groups that Amazon Lex uses to respond when the code hook succeeds.
        :param pulumi.Input['BotConditionalSpecificationArgs'] timeout_conditional: A list of conditional branches to evaluate if the code hook times out.
        :param pulumi.Input['BotDialogStateArgs'] timeout_next_step: Specifies the next step that the bot runs when the code hook times out.
        :param pulumi.Input['BotResponseSpecificationArgs'] timeout_response: Specifies a list of message groups that Amazon Lex uses to respond to the user input when the code hook times out.
        """
        if failure_conditional is not None:
            pulumi.set(__self__, "failure_conditional", failure_conditional)
        if failure_next_step is not None:
            pulumi.set(__self__, "failure_next_step", failure_next_step)
        if failure_response is not None:
            pulumi.set(__self__, "failure_response", failure_response)
        if success_conditional is not None:
            pulumi.set(__self__, "success_conditional", success_conditional)
        if success_next_step is not None:
            pulumi.set(__self__, "success_next_step", success_next_step)
        if success_response is not None:
            pulumi.set(__self__, "success_response", success_response)
        if timeout_conditional is not None:
            pulumi.set(__self__, "timeout_conditional", timeout_conditional)
        if timeout_next_step is not None:
            pulumi.set(__self__, "timeout_next_step", timeout_next_step)
        if timeout_response is not None:
            pulumi.set(__self__, "timeout_response", timeout_response)

    @_builtins.property
    @pulumi.getter(name="failureConditional")
    def failure_conditional(self) -> Optional[pulumi.Input['BotConditionalSpecificationArgs']]:
        """
        A list of conditional branches to evaluate after the dialog code hook throws an exception or returns with the `State` field of the `Intent` object set to `Failed` .
        """
        return pulumi.get(self, "failure_conditional")

    @failure_conditional.setter
    def failure_conditional(self, value: Optional[pulumi.Input['BotConditionalSpecificationArgs']]):
        pulumi.set(self, "failure_conditional", value)

    @_builtins.property
    @pulumi.getter(name="failureNextStep")
    def failure_next_step(self) -> Optional[pulumi.Input['BotDialogStateArgs']]:
        """
        Specifies the next step the bot runs after the dialog code hook throws an exception or returns with the `State` field of the `Intent` object set to `Failed` .
        """
        return pulumi.get(self, "failure_next_step")

    @failure_next_step.setter
    def failure_next_step(self, value: Optional[pulumi.Input['BotDialogStateArgs']]):
        pulumi.set(self, "failure_next_step", value)

    @_builtins.property
    @pulumi.getter(name="failureResponse")
    def failure_response(self) -> Optional[pulumi.Input['BotResponseSpecificationArgs']]:
        """
        Specifies a list of message groups that Amazon Lex uses to respond the user input when the code hook fails.
        """
        return pulumi.get(self, "failure_response")

    @failure_response.setter
    def failure_response(self, value: Optional[pulumi.Input['BotResponseSpecificationArgs']]):
        pulumi.set(self, "failure_response", value)

    @_builtins.property
    @pulumi.getter(name="successConditional")
    def success_conditional(self) -> Optional[pulumi.Input['BotConditionalSpecificationArgs']]:
        """
        A list of conditional branches to evaluate after the dialog code hook finishes successfully.
        """
        return pulumi.get(self, "success_conditional")

    @success_conditional.setter
    def success_conditional(self, value: Optional[pulumi.Input['BotConditionalSpecificationArgs']]):
        pulumi.set(self, "success_conditional", value)

    @_builtins.property
    @pulumi.getter(name="successNextStep")
    def success_next_step(self) -> Optional[pulumi.Input['BotDialogStateArgs']]:
        """
        Specifics the next step the bot runs after the dialog code hook finishes successfully.
        """
        return pulumi.get(self, "success_next_step")

    @success_next_step.setter
    def success_next_step(self, value: Optional[pulumi.Input['BotDialogStateArgs']]):
        pulumi.set(self, "success_next_step", value)

    @_builtins.property
    @pulumi.getter(name="successResponse")
    def success_response(self) -> Optional[pulumi.Input['BotResponseSpecificationArgs']]:
        """
        Specifies a list of message groups that Amazon Lex uses to respond when the code hook succeeds.
        """
        return pulumi.get(self, "success_response")

    @success_response.setter
    def success_response(self, value: Optional[pulumi.Input['BotResponseSpecificationArgs']]):
        pulumi.set(self, "success_response", value)

    @_builtins.property
    @pulumi.getter(name="timeoutConditional")
    def timeout_conditional(self) -> Optional[pulumi.Input['BotConditionalSpecificationArgs']]:
        """
        A list of conditional branches to evaluate if the code hook times out.
        """
        return pulumi.get(self, "timeout_conditional")

    @timeout_conditional.setter
    def timeout_conditional(self, value: Optional[pulumi.Input['BotConditionalSpecificationArgs']]):
        pulumi.set(self, "timeout_conditional", value)

    @_builtins.property
    @pulumi.getter(name="timeoutNextStep")
    def timeout_next_step(self) -> Optional[pulumi.Input['BotDialogStateArgs']]:
        """
        Specifies the next step that the bot runs when the code hook times out.
        """
        return pulumi.get(self, "timeout_next_step")

    @timeout_next_step.setter
    def timeout_next_step(self, value: Optional[pulumi.Input['BotDialogStateArgs']]):
        pulumi.set(self, "timeout_next_step", value)

    @_builtins.property
    @pulumi.getter(name="timeoutResponse")
    def timeout_response(self) -> Optional[pulumi.Input['BotResponseSpecificationArgs']]:
        """
        Specifies a list of message groups that Amazon Lex uses to respond to the user input when the code hook times out.
        """
        return pulumi.get(self, "timeout_response")

    @timeout_response.setter
    def timeout_response(self, value: Optional[pulumi.Input['BotResponseSpecificationArgs']]):
        pulumi.set(self, "timeout_response", value)


if not MYPY:
    class BotPostFulfillmentStatusSpecificationArgsDict(TypedDict):
        failure_conditional: NotRequired[pulumi.Input['BotConditionalSpecificationArgsDict']]
        """
        A list of conditional branches to evaluate after the fulfillment code hook throws an exception or returns with the `State` field of the `Intent` object set to `Failed` .
        """
        failure_next_step: NotRequired[pulumi.Input['BotDialogStateArgsDict']]
        """
        Specifies the next step the bot runs after the fulfillment code hook throws an exception or returns with the `State` field of the `Intent` object set to `Failed` .
        """
        failure_response: NotRequired[pulumi.Input['BotResponseSpecificationArgsDict']]
        """
        Specifies a list of message groups that Amazon Lex uses to respond when fulfillment isn't successful.
        """
        success_conditional: NotRequired[pulumi.Input['BotConditionalSpecificationArgsDict']]
        """
        A list of conditional branches to evaluate after the fulfillment code hook finishes successfully.
        """
        success_next_step: NotRequired[pulumi.Input['BotDialogStateArgsDict']]
        """
        Specifies the next step in the conversation that Amazon Lex invokes when the fulfillment code hook completes successfully.
        """
        success_response: NotRequired[pulumi.Input['BotResponseSpecificationArgsDict']]
        """
        Specifies a list of message groups that Amazon Lex uses to respond when the fulfillment is successful.
        """
        timeout_conditional: NotRequired[pulumi.Input['BotConditionalSpecificationArgsDict']]
        """
        A list of conditional branches to evaluate if the fulfillment code hook times out.
        """
        timeout_next_step: NotRequired[pulumi.Input['BotDialogStateArgsDict']]
        """
        Specifies the next step that the bot runs when the fulfillment code hook times out.
        """
        timeout_response: NotRequired[pulumi.Input['BotResponseSpecificationArgsDict']]
        """
        Specifies a list of message groups that Amazon Lex uses to respond when fulfillment isn't completed within the timeout period.
        """
elif False:
    BotPostFulfillmentStatusSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotPostFulfillmentStatusSpecificationArgs:
    def __init__(__self__, *,
                 failure_conditional: Optional[pulumi.Input['BotConditionalSpecificationArgs']] = None,
                 failure_next_step: Optional[pulumi.Input['BotDialogStateArgs']] = None,
                 failure_response: Optional[pulumi.Input['BotResponseSpecificationArgs']] = None,
                 success_conditional: Optional[pulumi.Input['BotConditionalSpecificationArgs']] = None,
                 success_next_step: Optional[pulumi.Input['BotDialogStateArgs']] = None,
                 success_response: Optional[pulumi.Input['BotResponseSpecificationArgs']] = None,
                 timeout_conditional: Optional[pulumi.Input['BotConditionalSpecificationArgs']] = None,
                 timeout_next_step: Optional[pulumi.Input['BotDialogStateArgs']] = None,
                 timeout_response: Optional[pulumi.Input['BotResponseSpecificationArgs']] = None):
        """
        :param pulumi.Input['BotConditionalSpecificationArgs'] failure_conditional: A list of conditional branches to evaluate after the fulfillment code hook throws an exception or returns with the `State` field of the `Intent` object set to `Failed` .
        :param pulumi.Input['BotDialogStateArgs'] failure_next_step: Specifies the next step the bot runs after the fulfillment code hook throws an exception or returns with the `State` field of the `Intent` object set to `Failed` .
        :param pulumi.Input['BotResponseSpecificationArgs'] failure_response: Specifies a list of message groups that Amazon Lex uses to respond when fulfillment isn't successful.
        :param pulumi.Input['BotConditionalSpecificationArgs'] success_conditional: A list of conditional branches to evaluate after the fulfillment code hook finishes successfully.
        :param pulumi.Input['BotDialogStateArgs'] success_next_step: Specifies the next step in the conversation that Amazon Lex invokes when the fulfillment code hook completes successfully.
        :param pulumi.Input['BotResponseSpecificationArgs'] success_response: Specifies a list of message groups that Amazon Lex uses to respond when the fulfillment is successful.
        :param pulumi.Input['BotConditionalSpecificationArgs'] timeout_conditional: A list of conditional branches to evaluate if the fulfillment code hook times out.
        :param pulumi.Input['BotDialogStateArgs'] timeout_next_step: Specifies the next step that the bot runs when the fulfillment code hook times out.
        :param pulumi.Input['BotResponseSpecificationArgs'] timeout_response: Specifies a list of message groups that Amazon Lex uses to respond when fulfillment isn't completed within the timeout period.
        """
        if failure_conditional is not None:
            pulumi.set(__self__, "failure_conditional", failure_conditional)
        if failure_next_step is not None:
            pulumi.set(__self__, "failure_next_step", failure_next_step)
        if failure_response is not None:
            pulumi.set(__self__, "failure_response", failure_response)
        if success_conditional is not None:
            pulumi.set(__self__, "success_conditional", success_conditional)
        if success_next_step is not None:
            pulumi.set(__self__, "success_next_step", success_next_step)
        if success_response is not None:
            pulumi.set(__self__, "success_response", success_response)
        if timeout_conditional is not None:
            pulumi.set(__self__, "timeout_conditional", timeout_conditional)
        if timeout_next_step is not None:
            pulumi.set(__self__, "timeout_next_step", timeout_next_step)
        if timeout_response is not None:
            pulumi.set(__self__, "timeout_response", timeout_response)

    @_builtins.property
    @pulumi.getter(name="failureConditional")
    def failure_conditional(self) -> Optional[pulumi.Input['BotConditionalSpecificationArgs']]:
        """
        A list of conditional branches to evaluate after the fulfillment code hook throws an exception or returns with the `State` field of the `Intent` object set to `Failed` .
        """
        return pulumi.get(self, "failure_conditional")

    @failure_conditional.setter
    def failure_conditional(self, value: Optional[pulumi.Input['BotConditionalSpecificationArgs']]):
        pulumi.set(self, "failure_conditional", value)

    @_builtins.property
    @pulumi.getter(name="failureNextStep")
    def failure_next_step(self) -> Optional[pulumi.Input['BotDialogStateArgs']]:
        """
        Specifies the next step the bot runs after the fulfillment code hook throws an exception or returns with the `State` field of the `Intent` object set to `Failed` .
        """
        return pulumi.get(self, "failure_next_step")

    @failure_next_step.setter
    def failure_next_step(self, value: Optional[pulumi.Input['BotDialogStateArgs']]):
        pulumi.set(self, "failure_next_step", value)

    @_builtins.property
    @pulumi.getter(name="failureResponse")
    def failure_response(self) -> Optional[pulumi.Input['BotResponseSpecificationArgs']]:
        """
        Specifies a list of message groups that Amazon Lex uses to respond when fulfillment isn't successful.
        """
        return pulumi.get(self, "failure_response")

    @failure_response.setter
    def failure_response(self, value: Optional[pulumi.Input['BotResponseSpecificationArgs']]):
        pulumi.set(self, "failure_response", value)

    @_builtins.property
    @pulumi.getter(name="successConditional")
    def success_conditional(self) -> Optional[pulumi.Input['BotConditionalSpecificationArgs']]:
        """
        A list of conditional branches to evaluate after the fulfillment code hook finishes successfully.
        """
        return pulumi.get(self, "success_conditional")

    @success_conditional.setter
    def success_conditional(self, value: Optional[pulumi.Input['BotConditionalSpecificationArgs']]):
        pulumi.set(self, "success_conditional", value)

    @_builtins.property
    @pulumi.getter(name="successNextStep")
    def success_next_step(self) -> Optional[pulumi.Input['BotDialogStateArgs']]:
        """
        Specifies the next step in the conversation that Amazon Lex invokes when the fulfillment code hook completes successfully.
        """
        return pulumi.get(self, "success_next_step")

    @success_next_step.setter
    def success_next_step(self, value: Optional[pulumi.Input['BotDialogStateArgs']]):
        pulumi.set(self, "success_next_step", value)

    @_builtins.property
    @pulumi.getter(name="successResponse")
    def success_response(self) -> Optional[pulumi.Input['BotResponseSpecificationArgs']]:
        """
        Specifies a list of message groups that Amazon Lex uses to respond when the fulfillment is successful.
        """
        return pulumi.get(self, "success_response")

    @success_response.setter
    def success_response(self, value: Optional[pulumi.Input['BotResponseSpecificationArgs']]):
        pulumi.set(self, "success_response", value)

    @_builtins.property
    @pulumi.getter(name="timeoutConditional")
    def timeout_conditional(self) -> Optional[pulumi.Input['BotConditionalSpecificationArgs']]:
        """
        A list of conditional branches to evaluate if the fulfillment code hook times out.
        """
        return pulumi.get(self, "timeout_conditional")

    @timeout_conditional.setter
    def timeout_conditional(self, value: Optional[pulumi.Input['BotConditionalSpecificationArgs']]):
        pulumi.set(self, "timeout_conditional", value)

    @_builtins.property
    @pulumi.getter(name="timeoutNextStep")
    def timeout_next_step(self) -> Optional[pulumi.Input['BotDialogStateArgs']]:
        """
        Specifies the next step that the bot runs when the fulfillment code hook times out.
        """
        return pulumi.get(self, "timeout_next_step")

    @timeout_next_step.setter
    def timeout_next_step(self, value: Optional[pulumi.Input['BotDialogStateArgs']]):
        pulumi.set(self, "timeout_next_step", value)

    @_builtins.property
    @pulumi.getter(name="timeoutResponse")
    def timeout_response(self) -> Optional[pulumi.Input['BotResponseSpecificationArgs']]:
        """
        Specifies a list of message groups that Amazon Lex uses to respond when fulfillment isn't completed within the timeout period.
        """
        return pulumi.get(self, "timeout_response")

    @timeout_response.setter
    def timeout_response(self, value: Optional[pulumi.Input['BotResponseSpecificationArgs']]):
        pulumi.set(self, "timeout_response", value)


if not MYPY:
    class BotPromptAttemptSpecificationArgsDict(TypedDict):
        allowed_input_types: pulumi.Input['BotAllowedInputTypesArgsDict']
        allow_interrupt: NotRequired[pulumi.Input[_builtins.bool]]
        audio_and_dtmf_input_specification: NotRequired[pulumi.Input['BotAudioAndDtmfInputSpecificationArgsDict']]
        text_input_specification: NotRequired[pulumi.Input['BotTextInputSpecificationArgsDict']]
elif False:
    BotPromptAttemptSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotPromptAttemptSpecificationArgs:
    def __init__(__self__, *,
                 allowed_input_types: pulumi.Input['BotAllowedInputTypesArgs'],
                 allow_interrupt: Optional[pulumi.Input[_builtins.bool]] = None,
                 audio_and_dtmf_input_specification: Optional[pulumi.Input['BotAudioAndDtmfInputSpecificationArgs']] = None,
                 text_input_specification: Optional[pulumi.Input['BotTextInputSpecificationArgs']] = None):
        pulumi.set(__self__, "allowed_input_types", allowed_input_types)
        if allow_interrupt is not None:
            pulumi.set(__self__, "allow_interrupt", allow_interrupt)
        if audio_and_dtmf_input_specification is not None:
            pulumi.set(__self__, "audio_and_dtmf_input_specification", audio_and_dtmf_input_specification)
        if text_input_specification is not None:
            pulumi.set(__self__, "text_input_specification", text_input_specification)

    @_builtins.property
    @pulumi.getter(name="allowedInputTypes")
    def allowed_input_types(self) -> pulumi.Input['BotAllowedInputTypesArgs']:
        return pulumi.get(self, "allowed_input_types")

    @allowed_input_types.setter
    def allowed_input_types(self, value: pulumi.Input['BotAllowedInputTypesArgs']):
        pulumi.set(self, "allowed_input_types", value)

    @_builtins.property
    @pulumi.getter(name="allowInterrupt")
    def allow_interrupt(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "allow_interrupt")

    @allow_interrupt.setter
    def allow_interrupt(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_interrupt", value)

    @_builtins.property
    @pulumi.getter(name="audioAndDtmfInputSpecification")
    def audio_and_dtmf_input_specification(self) -> Optional[pulumi.Input['BotAudioAndDtmfInputSpecificationArgs']]:
        return pulumi.get(self, "audio_and_dtmf_input_specification")

    @audio_and_dtmf_input_specification.setter
    def audio_and_dtmf_input_specification(self, value: Optional[pulumi.Input['BotAudioAndDtmfInputSpecificationArgs']]):
        pulumi.set(self, "audio_and_dtmf_input_specification", value)

    @_builtins.property
    @pulumi.getter(name="textInputSpecification")
    def text_input_specification(self) -> Optional[pulumi.Input['BotTextInputSpecificationArgs']]:
        return pulumi.get(self, "text_input_specification")

    @text_input_specification.setter
    def text_input_specification(self, value: Optional[pulumi.Input['BotTextInputSpecificationArgs']]):
        pulumi.set(self, "text_input_specification", value)


if not MYPY:
    class BotPromptSpecificationArgsDict(TypedDict):
        max_retries: pulumi.Input[_builtins.int]
        """
        The maximum number of times the bot tries to elicit a response from the user using this prompt.
        """
        message_groups_list: pulumi.Input[Sequence[pulumi.Input['BotMessageGroupArgsDict']]]
        """
        A collection of messages that Amazon Lex can send to the user. Amazon Lex chooses the actual message to send at runtime.
        """
        allow_interrupt: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the user can interrupt a speech prompt from the bot.
        """
        message_selection_strategy: NotRequired[pulumi.Input['BotMessageSelectionStrategy']]
        """
        Indicates how a message is selected from a message group among retries.
        """
        prompt_attempts_specification: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['BotPromptAttemptSpecificationArgsDict']]]]
        """
        Specifies the advanced settings on each attempt of the prompt.
        """
elif False:
    BotPromptSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotPromptSpecificationArgs:
    def __init__(__self__, *,
                 max_retries: pulumi.Input[_builtins.int],
                 message_groups_list: pulumi.Input[Sequence[pulumi.Input['BotMessageGroupArgs']]],
                 allow_interrupt: Optional[pulumi.Input[_builtins.bool]] = None,
                 message_selection_strategy: Optional[pulumi.Input['BotMessageSelectionStrategy']] = None,
                 prompt_attempts_specification: Optional[pulumi.Input[Mapping[str, pulumi.Input['BotPromptAttemptSpecificationArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.int] max_retries: The maximum number of times the bot tries to elicit a response from the user using this prompt.
        :param pulumi.Input[Sequence[pulumi.Input['BotMessageGroupArgs']]] message_groups_list: A collection of messages that Amazon Lex can send to the user. Amazon Lex chooses the actual message to send at runtime.
        :param pulumi.Input[_builtins.bool] allow_interrupt: Indicates whether the user can interrupt a speech prompt from the bot.
        :param pulumi.Input['BotMessageSelectionStrategy'] message_selection_strategy: Indicates how a message is selected from a message group among retries.
        :param pulumi.Input[Mapping[str, pulumi.Input['BotPromptAttemptSpecificationArgs']]] prompt_attempts_specification: Specifies the advanced settings on each attempt of the prompt.
        """
        pulumi.set(__self__, "max_retries", max_retries)
        pulumi.set(__self__, "message_groups_list", message_groups_list)
        if allow_interrupt is not None:
            pulumi.set(__self__, "allow_interrupt", allow_interrupt)
        if message_selection_strategy is not None:
            pulumi.set(__self__, "message_selection_strategy", message_selection_strategy)
        if prompt_attempts_specification is not None:
            pulumi.set(__self__, "prompt_attempts_specification", prompt_attempts_specification)

    @_builtins.property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> pulumi.Input[_builtins.int]:
        """
        The maximum number of times the bot tries to elicit a response from the user using this prompt.
        """
        return pulumi.get(self, "max_retries")

    @max_retries.setter
    def max_retries(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max_retries", value)

    @_builtins.property
    @pulumi.getter(name="messageGroupsList")
    def message_groups_list(self) -> pulumi.Input[Sequence[pulumi.Input['BotMessageGroupArgs']]]:
        """
        A collection of messages that Amazon Lex can send to the user. Amazon Lex chooses the actual message to send at runtime.
        """
        return pulumi.get(self, "message_groups_list")

    @message_groups_list.setter
    def message_groups_list(self, value: pulumi.Input[Sequence[pulumi.Input['BotMessageGroupArgs']]]):
        pulumi.set(self, "message_groups_list", value)

    @_builtins.property
    @pulumi.getter(name="allowInterrupt")
    def allow_interrupt(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the user can interrupt a speech prompt from the bot.
        """
        return pulumi.get(self, "allow_interrupt")

    @allow_interrupt.setter
    def allow_interrupt(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_interrupt", value)

    @_builtins.property
    @pulumi.getter(name="messageSelectionStrategy")
    def message_selection_strategy(self) -> Optional[pulumi.Input['BotMessageSelectionStrategy']]:
        """
        Indicates how a message is selected from a message group among retries.
        """
        return pulumi.get(self, "message_selection_strategy")

    @message_selection_strategy.setter
    def message_selection_strategy(self, value: Optional[pulumi.Input['BotMessageSelectionStrategy']]):
        pulumi.set(self, "message_selection_strategy", value)

    @_builtins.property
    @pulumi.getter(name="promptAttemptsSpecification")
    def prompt_attempts_specification(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['BotPromptAttemptSpecificationArgs']]]]:
        """
        Specifies the advanced settings on each attempt of the prompt.
        """
        return pulumi.get(self, "prompt_attempts_specification")

    @prompt_attempts_specification.setter
    def prompt_attempts_specification(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['BotPromptAttemptSpecificationArgs']]]]):
        pulumi.set(self, "prompt_attempts_specification", value)


if not MYPY:
    class BotQInConnectIntentConfigurationQInConnectAssistantConfigurationPropertiesArgsDict(TypedDict):
        assistant_arn: pulumi.Input[_builtins.str]
elif False:
    BotQInConnectIntentConfigurationQInConnectAssistantConfigurationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotQInConnectIntentConfigurationQInConnectAssistantConfigurationPropertiesArgs:
    def __init__(__self__, *,
                 assistant_arn: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "assistant_arn", assistant_arn)

    @_builtins.property
    @pulumi.getter(name="assistantArn")
    def assistant_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "assistant_arn")

    @assistant_arn.setter
    def assistant_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "assistant_arn", value)


if not MYPY:
    class BotQInConnectIntentConfigurationArgsDict(TypedDict):
        q_in_connect_assistant_configuration: NotRequired[pulumi.Input['BotQInConnectIntentConfigurationQInConnectAssistantConfigurationPropertiesArgsDict']]
elif False:
    BotQInConnectIntentConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotQInConnectIntentConfigurationArgs:
    def __init__(__self__, *,
                 q_in_connect_assistant_configuration: Optional[pulumi.Input['BotQInConnectIntentConfigurationQInConnectAssistantConfigurationPropertiesArgs']] = None):
        if q_in_connect_assistant_configuration is not None:
            pulumi.set(__self__, "q_in_connect_assistant_configuration", q_in_connect_assistant_configuration)

    @_builtins.property
    @pulumi.getter(name="qInConnectAssistantConfiguration")
    def q_in_connect_assistant_configuration(self) -> Optional[pulumi.Input['BotQInConnectIntentConfigurationQInConnectAssistantConfigurationPropertiesArgs']]:
        return pulumi.get(self, "q_in_connect_assistant_configuration")

    @q_in_connect_assistant_configuration.setter
    def q_in_connect_assistant_configuration(self, value: Optional[pulumi.Input['BotQInConnectIntentConfigurationQInConnectAssistantConfigurationPropertiesArgs']]):
        pulumi.set(self, "q_in_connect_assistant_configuration", value)


if not MYPY:
    class BotQnAIntentConfigurationDataSourceConfigurationPropertiesBedrockKnowledgeStoreConfigurationPropertiesBkbExactResponseFieldsPropertiesArgsDict(TypedDict):
        answer_field: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    BotQnAIntentConfigurationDataSourceConfigurationPropertiesBedrockKnowledgeStoreConfigurationPropertiesBkbExactResponseFieldsPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotQnAIntentConfigurationDataSourceConfigurationPropertiesBedrockKnowledgeStoreConfigurationPropertiesBkbExactResponseFieldsPropertiesArgs:
    def __init__(__self__, *,
                 answer_field: Optional[pulumi.Input[_builtins.str]] = None):
        if answer_field is not None:
            pulumi.set(__self__, "answer_field", answer_field)

    @_builtins.property
    @pulumi.getter(name="answerField")
    def answer_field(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "answer_field")

    @answer_field.setter
    def answer_field(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "answer_field", value)


if not MYPY:
    class BotQnAIntentConfigurationDataSourceConfigurationPropertiesBedrockKnowledgeStoreConfigurationPropertiesArgsDict(TypedDict):
        bedrock_knowledge_base_arn: NotRequired[pulumi.Input[_builtins.str]]
        bkb_exact_response_fields: NotRequired[pulumi.Input['BotQnAIntentConfigurationDataSourceConfigurationPropertiesBedrockKnowledgeStoreConfigurationPropertiesBkbExactResponseFieldsPropertiesArgsDict']]
        exact_response: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    BotQnAIntentConfigurationDataSourceConfigurationPropertiesBedrockKnowledgeStoreConfigurationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotQnAIntentConfigurationDataSourceConfigurationPropertiesBedrockKnowledgeStoreConfigurationPropertiesArgs:
    def __init__(__self__, *,
                 bedrock_knowledge_base_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 bkb_exact_response_fields: Optional[pulumi.Input['BotQnAIntentConfigurationDataSourceConfigurationPropertiesBedrockKnowledgeStoreConfigurationPropertiesBkbExactResponseFieldsPropertiesArgs']] = None,
                 exact_response: Optional[pulumi.Input[_builtins.bool]] = None):
        if bedrock_knowledge_base_arn is not None:
            pulumi.set(__self__, "bedrock_knowledge_base_arn", bedrock_knowledge_base_arn)
        if bkb_exact_response_fields is not None:
            pulumi.set(__self__, "bkb_exact_response_fields", bkb_exact_response_fields)
        if exact_response is not None:
            pulumi.set(__self__, "exact_response", exact_response)

    @_builtins.property
    @pulumi.getter(name="bedrockKnowledgeBaseArn")
    def bedrock_knowledge_base_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "bedrock_knowledge_base_arn")

    @bedrock_knowledge_base_arn.setter
    def bedrock_knowledge_base_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bedrock_knowledge_base_arn", value)

    @_builtins.property
    @pulumi.getter(name="bkbExactResponseFields")
    def bkb_exact_response_fields(self) -> Optional[pulumi.Input['BotQnAIntentConfigurationDataSourceConfigurationPropertiesBedrockKnowledgeStoreConfigurationPropertiesBkbExactResponseFieldsPropertiesArgs']]:
        return pulumi.get(self, "bkb_exact_response_fields")

    @bkb_exact_response_fields.setter
    def bkb_exact_response_fields(self, value: Optional[pulumi.Input['BotQnAIntentConfigurationDataSourceConfigurationPropertiesBedrockKnowledgeStoreConfigurationPropertiesBkbExactResponseFieldsPropertiesArgs']]):
        pulumi.set(self, "bkb_exact_response_fields", value)

    @_builtins.property
    @pulumi.getter(name="exactResponse")
    def exact_response(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "exact_response")

    @exact_response.setter
    def exact_response(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "exact_response", value)


if not MYPY:
    class BotQnAIntentConfigurationDataSourceConfigurationPropertiesOpensearchConfigurationPropertiesExactResponseFieldsPropertiesArgsDict(TypedDict):
        answer_field: NotRequired[pulumi.Input[_builtins.str]]
        question_field: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    BotQnAIntentConfigurationDataSourceConfigurationPropertiesOpensearchConfigurationPropertiesExactResponseFieldsPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotQnAIntentConfigurationDataSourceConfigurationPropertiesOpensearchConfigurationPropertiesExactResponseFieldsPropertiesArgs:
    def __init__(__self__, *,
                 answer_field: Optional[pulumi.Input[_builtins.str]] = None,
                 question_field: Optional[pulumi.Input[_builtins.str]] = None):
        if answer_field is not None:
            pulumi.set(__self__, "answer_field", answer_field)
        if question_field is not None:
            pulumi.set(__self__, "question_field", question_field)

    @_builtins.property
    @pulumi.getter(name="answerField")
    def answer_field(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "answer_field")

    @answer_field.setter
    def answer_field(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "answer_field", value)

    @_builtins.property
    @pulumi.getter(name="questionField")
    def question_field(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "question_field")

    @question_field.setter
    def question_field(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "question_field", value)


if not MYPY:
    class BotQnAIntentConfigurationDataSourceConfigurationPropertiesOpensearchConfigurationPropertiesArgsDict(TypedDict):
        domain_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        exact_response: NotRequired[pulumi.Input[_builtins.bool]]
        exact_response_fields: NotRequired[pulumi.Input['BotQnAIntentConfigurationDataSourceConfigurationPropertiesOpensearchConfigurationPropertiesExactResponseFieldsPropertiesArgsDict']]
        include_fields: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        index_name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    BotQnAIntentConfigurationDataSourceConfigurationPropertiesOpensearchConfigurationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotQnAIntentConfigurationDataSourceConfigurationPropertiesOpensearchConfigurationPropertiesArgs:
    def __init__(__self__, *,
                 domain_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 exact_response: Optional[pulumi.Input[_builtins.bool]] = None,
                 exact_response_fields: Optional[pulumi.Input['BotQnAIntentConfigurationDataSourceConfigurationPropertiesOpensearchConfigurationPropertiesExactResponseFieldsPropertiesArgs']] = None,
                 include_fields: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 index_name: Optional[pulumi.Input[_builtins.str]] = None):
        if domain_endpoint is not None:
            pulumi.set(__self__, "domain_endpoint", domain_endpoint)
        if exact_response is not None:
            pulumi.set(__self__, "exact_response", exact_response)
        if exact_response_fields is not None:
            pulumi.set(__self__, "exact_response_fields", exact_response_fields)
        if include_fields is not None:
            pulumi.set(__self__, "include_fields", include_fields)
        if index_name is not None:
            pulumi.set(__self__, "index_name", index_name)

    @_builtins.property
    @pulumi.getter(name="domainEndpoint")
    def domain_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "domain_endpoint")

    @domain_endpoint.setter
    def domain_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "domain_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="exactResponse")
    def exact_response(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "exact_response")

    @exact_response.setter
    def exact_response(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "exact_response", value)

    @_builtins.property
    @pulumi.getter(name="exactResponseFields")
    def exact_response_fields(self) -> Optional[pulumi.Input['BotQnAIntentConfigurationDataSourceConfigurationPropertiesOpensearchConfigurationPropertiesExactResponseFieldsPropertiesArgs']]:
        return pulumi.get(self, "exact_response_fields")

    @exact_response_fields.setter
    def exact_response_fields(self, value: Optional[pulumi.Input['BotQnAIntentConfigurationDataSourceConfigurationPropertiesOpensearchConfigurationPropertiesExactResponseFieldsPropertiesArgs']]):
        pulumi.set(self, "exact_response_fields", value)

    @_builtins.property
    @pulumi.getter(name="includeFields")
    def include_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "include_fields")

    @include_fields.setter
    def include_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "include_fields", value)

    @_builtins.property
    @pulumi.getter(name="indexName")
    def index_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "index_name")

    @index_name.setter
    def index_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "index_name", value)


if not MYPY:
    class BotQnAIntentConfigurationDataSourceConfigurationPropertiesArgsDict(TypedDict):
        """
        Contains details about the configuration of the data source used for the `AMAZON.QnAIntent` .
        """
        bedrock_knowledge_store_configuration: NotRequired[pulumi.Input['BotQnAIntentConfigurationDataSourceConfigurationPropertiesBedrockKnowledgeStoreConfigurationPropertiesArgsDict']]
        kendra_configuration: NotRequired[pulumi.Input['BotQnAKendraConfigurationArgsDict']]
        opensearch_configuration: NotRequired[pulumi.Input['BotQnAIntentConfigurationDataSourceConfigurationPropertiesOpensearchConfigurationPropertiesArgsDict']]
elif False:
    BotQnAIntentConfigurationDataSourceConfigurationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotQnAIntentConfigurationDataSourceConfigurationPropertiesArgs:
    def __init__(__self__, *,
                 bedrock_knowledge_store_configuration: Optional[pulumi.Input['BotQnAIntentConfigurationDataSourceConfigurationPropertiesBedrockKnowledgeStoreConfigurationPropertiesArgs']] = None,
                 kendra_configuration: Optional[pulumi.Input['BotQnAKendraConfigurationArgs']] = None,
                 opensearch_configuration: Optional[pulumi.Input['BotQnAIntentConfigurationDataSourceConfigurationPropertiesOpensearchConfigurationPropertiesArgs']] = None):
        """
        Contains details about the configuration of the data source used for the `AMAZON.QnAIntent` .
        """
        if bedrock_knowledge_store_configuration is not None:
            pulumi.set(__self__, "bedrock_knowledge_store_configuration", bedrock_knowledge_store_configuration)
        if kendra_configuration is not None:
            pulumi.set(__self__, "kendra_configuration", kendra_configuration)
        if opensearch_configuration is not None:
            pulumi.set(__self__, "opensearch_configuration", opensearch_configuration)

    @_builtins.property
    @pulumi.getter(name="bedrockKnowledgeStoreConfiguration")
    def bedrock_knowledge_store_configuration(self) -> Optional[pulumi.Input['BotQnAIntentConfigurationDataSourceConfigurationPropertiesBedrockKnowledgeStoreConfigurationPropertiesArgs']]:
        return pulumi.get(self, "bedrock_knowledge_store_configuration")

    @bedrock_knowledge_store_configuration.setter
    def bedrock_knowledge_store_configuration(self, value: Optional[pulumi.Input['BotQnAIntentConfigurationDataSourceConfigurationPropertiesBedrockKnowledgeStoreConfigurationPropertiesArgs']]):
        pulumi.set(self, "bedrock_knowledge_store_configuration", value)

    @_builtins.property
    @pulumi.getter(name="kendraConfiguration")
    def kendra_configuration(self) -> Optional[pulumi.Input['BotQnAKendraConfigurationArgs']]:
        return pulumi.get(self, "kendra_configuration")

    @kendra_configuration.setter
    def kendra_configuration(self, value: Optional[pulumi.Input['BotQnAKendraConfigurationArgs']]):
        pulumi.set(self, "kendra_configuration", value)

    @_builtins.property
    @pulumi.getter(name="opensearchConfiguration")
    def opensearch_configuration(self) -> Optional[pulumi.Input['BotQnAIntentConfigurationDataSourceConfigurationPropertiesOpensearchConfigurationPropertiesArgs']]:
        return pulumi.get(self, "opensearch_configuration")

    @opensearch_configuration.setter
    def opensearch_configuration(self, value: Optional[pulumi.Input['BotQnAIntentConfigurationDataSourceConfigurationPropertiesOpensearchConfigurationPropertiesArgs']]):
        pulumi.set(self, "opensearch_configuration", value)


if not MYPY:
    class BotQnAIntentConfigurationArgsDict(TypedDict):
        bedrock_model_configuration: pulumi.Input['BotBedrockModelSpecificationArgsDict']
        data_source_configuration: pulumi.Input['BotQnAIntentConfigurationDataSourceConfigurationPropertiesArgsDict']
        """
        Contains details about the configuration of the data source used for the `AMAZON.QnAIntent` .
        """
elif False:
    BotQnAIntentConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotQnAIntentConfigurationArgs:
    def __init__(__self__, *,
                 bedrock_model_configuration: pulumi.Input['BotBedrockModelSpecificationArgs'],
                 data_source_configuration: pulumi.Input['BotQnAIntentConfigurationDataSourceConfigurationPropertiesArgs']):
        """
        :param pulumi.Input['BotQnAIntentConfigurationDataSourceConfigurationPropertiesArgs'] data_source_configuration: Contains details about the configuration of the data source used for the `AMAZON.QnAIntent` .
        """
        pulumi.set(__self__, "bedrock_model_configuration", bedrock_model_configuration)
        pulumi.set(__self__, "data_source_configuration", data_source_configuration)

    @_builtins.property
    @pulumi.getter(name="bedrockModelConfiguration")
    def bedrock_model_configuration(self) -> pulumi.Input['BotBedrockModelSpecificationArgs']:
        return pulumi.get(self, "bedrock_model_configuration")

    @bedrock_model_configuration.setter
    def bedrock_model_configuration(self, value: pulumi.Input['BotBedrockModelSpecificationArgs']):
        pulumi.set(self, "bedrock_model_configuration", value)

    @_builtins.property
    @pulumi.getter(name="dataSourceConfiguration")
    def data_source_configuration(self) -> pulumi.Input['BotQnAIntentConfigurationDataSourceConfigurationPropertiesArgs']:
        """
        Contains details about the configuration of the data source used for the `AMAZON.QnAIntent` .
        """
        return pulumi.get(self, "data_source_configuration")

    @data_source_configuration.setter
    def data_source_configuration(self, value: pulumi.Input['BotQnAIntentConfigurationDataSourceConfigurationPropertiesArgs']):
        pulumi.set(self, "data_source_configuration", value)


if not MYPY:
    class BotQnAKendraConfigurationArgsDict(TypedDict):
        exact_response: pulumi.Input[_builtins.bool]
        """
        Specifies whether to return an exact response from the Amazon Kendra index or to let the Amazon Bedrock model you select generate a response based on the results. To use this feature, you must first add FAQ questions to your index by following the steps at [Adding frequently asked questions (FAQs) to an index](https://docs.aws.amazon.com/kendra/latest/dg/in-creating-faq.html) .
        """
        kendra_index: pulumi.Input[_builtins.str]
        """
        The ARN of the Amazon Kendra index to use.
        """
        query_filter_string_enabled: pulumi.Input[_builtins.bool]
        """
        Specifies whether to enable an Amazon Kendra filter string or not.
        """
        query_filter_string: NotRequired[pulumi.Input[_builtins.str]]
        """
        Contains the Amazon Kendra filter string to use if enabled. For more information on the Amazon Kendra search filter JSON format, see [Using document attributes to filter search results](https://docs.aws.amazon.com/kendra/latest/dg/filtering.html#search-filtering) .
        """
elif False:
    BotQnAKendraConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotQnAKendraConfigurationArgs:
    def __init__(__self__, *,
                 exact_response: pulumi.Input[_builtins.bool],
                 kendra_index: pulumi.Input[_builtins.str],
                 query_filter_string_enabled: pulumi.Input[_builtins.bool],
                 query_filter_string: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] exact_response: Specifies whether to return an exact response from the Amazon Kendra index or to let the Amazon Bedrock model you select generate a response based on the results. To use this feature, you must first add FAQ questions to your index by following the steps at [Adding frequently asked questions (FAQs) to an index](https://docs.aws.amazon.com/kendra/latest/dg/in-creating-faq.html) .
        :param pulumi.Input[_builtins.str] kendra_index: The ARN of the Amazon Kendra index to use.
        :param pulumi.Input[_builtins.bool] query_filter_string_enabled: Specifies whether to enable an Amazon Kendra filter string or not.
        :param pulumi.Input[_builtins.str] query_filter_string: Contains the Amazon Kendra filter string to use if enabled. For more information on the Amazon Kendra search filter JSON format, see [Using document attributes to filter search results](https://docs.aws.amazon.com/kendra/latest/dg/filtering.html#search-filtering) .
        """
        pulumi.set(__self__, "exact_response", exact_response)
        pulumi.set(__self__, "kendra_index", kendra_index)
        pulumi.set(__self__, "query_filter_string_enabled", query_filter_string_enabled)
        if query_filter_string is not None:
            pulumi.set(__self__, "query_filter_string", query_filter_string)

    @_builtins.property
    @pulumi.getter(name="exactResponse")
    def exact_response(self) -> pulumi.Input[_builtins.bool]:
        """
        Specifies whether to return an exact response from the Amazon Kendra index or to let the Amazon Bedrock model you select generate a response based on the results. To use this feature, you must first add FAQ questions to your index by following the steps at [Adding frequently asked questions (FAQs) to an index](https://docs.aws.amazon.com/kendra/latest/dg/in-creating-faq.html) .
        """
        return pulumi.get(self, "exact_response")

    @exact_response.setter
    def exact_response(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "exact_response", value)

    @_builtins.property
    @pulumi.getter(name="kendraIndex")
    def kendra_index(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the Amazon Kendra index to use.
        """
        return pulumi.get(self, "kendra_index")

    @kendra_index.setter
    def kendra_index(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "kendra_index", value)

    @_builtins.property
    @pulumi.getter(name="queryFilterStringEnabled")
    def query_filter_string_enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Specifies whether to enable an Amazon Kendra filter string or not.
        """
        return pulumi.get(self, "query_filter_string_enabled")

    @query_filter_string_enabled.setter
    def query_filter_string_enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "query_filter_string_enabled", value)

    @_builtins.property
    @pulumi.getter(name="queryFilterString")
    def query_filter_string(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Contains the Amazon Kendra filter string to use if enabled. For more information on the Amazon Kendra search filter JSON format, see [Using document attributes to filter search results](https://docs.aws.amazon.com/kendra/latest/dg/filtering.html#search-filtering) .
        """
        return pulumi.get(self, "query_filter_string")

    @query_filter_string.setter
    def query_filter_string(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "query_filter_string", value)


if not MYPY:
    class BotReplicationArgsDict(TypedDict):
        replica_regions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    BotReplicationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotReplicationArgs:
    def __init__(__self__, *,
                 replica_regions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "replica_regions", replica_regions)

    @_builtins.property
    @pulumi.getter(name="replicaRegions")
    def replica_regions(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "replica_regions")

    @replica_regions.setter
    def replica_regions(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "replica_regions", value)


if not MYPY:
    class BotResponseSpecificationArgsDict(TypedDict):
        message_groups_list: pulumi.Input[Sequence[pulumi.Input['BotMessageGroupArgsDict']]]
        """
        A collection of responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime.
        """
        allow_interrupt: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the user can interrupt a speech response from Amazon Lex.
        """
elif False:
    BotResponseSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotResponseSpecificationArgs:
    def __init__(__self__, *,
                 message_groups_list: pulumi.Input[Sequence[pulumi.Input['BotMessageGroupArgs']]],
                 allow_interrupt: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BotMessageGroupArgs']]] message_groups_list: A collection of responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime.
        :param pulumi.Input[_builtins.bool] allow_interrupt: Indicates whether the user can interrupt a speech response from Amazon Lex.
        """
        pulumi.set(__self__, "message_groups_list", message_groups_list)
        if allow_interrupt is not None:
            pulumi.set(__self__, "allow_interrupt", allow_interrupt)

    @_builtins.property
    @pulumi.getter(name="messageGroupsList")
    def message_groups_list(self) -> pulumi.Input[Sequence[pulumi.Input['BotMessageGroupArgs']]]:
        """
        A collection of responses that Amazon Lex can send to the user. Amazon Lex chooses the actual response to send at runtime.
        """
        return pulumi.get(self, "message_groups_list")

    @message_groups_list.setter
    def message_groups_list(self, value: pulumi.Input[Sequence[pulumi.Input['BotMessageGroupArgs']]]):
        pulumi.set(self, "message_groups_list", value)

    @_builtins.property
    @pulumi.getter(name="allowInterrupt")
    def allow_interrupt(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the user can interrupt a speech response from Amazon Lex.
        """
        return pulumi.get(self, "allow_interrupt")

    @allow_interrupt.setter
    def allow_interrupt(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_interrupt", value)


if not MYPY:
    class BotS3BucketLogDestinationArgsDict(TypedDict):
        log_prefix: pulumi.Input[_builtins.str]
        s3_bucket_arn: pulumi.Input[_builtins.str]
        kms_key_arn: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    BotS3BucketLogDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotS3BucketLogDestinationArgs:
    def __init__(__self__, *,
                 log_prefix: pulumi.Input[_builtins.str],
                 s3_bucket_arn: pulumi.Input[_builtins.str],
                 kms_key_arn: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "log_prefix", log_prefix)
        pulumi.set(__self__, "s3_bucket_arn", s3_bucket_arn)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @_builtins.property
    @pulumi.getter(name="logPrefix")
    def log_prefix(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "log_prefix")

    @log_prefix.setter
    def log_prefix(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_prefix", value)

    @_builtins.property
    @pulumi.getter(name="s3BucketArn")
    def s3_bucket_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "s3_bucket_arn")

    @s3_bucket_arn.setter
    def s3_bucket_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "s3_bucket_arn", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "kms_key_arn")

    @kms_key_arn.setter
    def kms_key_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_arn", value)


if not MYPY:
    class BotS3LocationArgsDict(TypedDict):
        s3_bucket: pulumi.Input[_builtins.str]
        """
        The S3 bucket name.
        """
        s3_object_key: pulumi.Input[_builtins.str]
        """
        The path and file name to the object in the S3 bucket.
        """
        s3_object_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The version of the object in the S3 bucket.
        """
elif False:
    BotS3LocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotS3LocationArgs:
    def __init__(__self__, *,
                 s3_bucket: pulumi.Input[_builtins.str],
                 s3_object_key: pulumi.Input[_builtins.str],
                 s3_object_version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] s3_bucket: The S3 bucket name.
        :param pulumi.Input[_builtins.str] s3_object_key: The path and file name to the object in the S3 bucket.
        :param pulumi.Input[_builtins.str] s3_object_version: The version of the object in the S3 bucket.
        """
        pulumi.set(__self__, "s3_bucket", s3_bucket)
        pulumi.set(__self__, "s3_object_key", s3_object_key)
        if s3_object_version is not None:
            pulumi.set(__self__, "s3_object_version", s3_object_version)

    @_builtins.property
    @pulumi.getter(name="s3Bucket")
    def s3_bucket(self) -> pulumi.Input[_builtins.str]:
        """
        The S3 bucket name.
        """
        return pulumi.get(self, "s3_bucket")

    @s3_bucket.setter
    def s3_bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "s3_bucket", value)

    @_builtins.property
    @pulumi.getter(name="s3ObjectKey")
    def s3_object_key(self) -> pulumi.Input[_builtins.str]:
        """
        The path and file name to the object in the S3 bucket.
        """
        return pulumi.get(self, "s3_object_key")

    @s3_object_key.setter
    def s3_object_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "s3_object_key", value)

    @_builtins.property
    @pulumi.getter(name="s3ObjectVersion")
    def s3_object_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The version of the object in the S3 bucket.
        """
        return pulumi.get(self, "s3_object_version")

    @s3_object_version.setter
    def s3_object_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "s3_object_version", value)


if not MYPY:
    class BotSampleUtteranceArgsDict(TypedDict):
        utterance: pulumi.Input[_builtins.str]
elif False:
    BotSampleUtteranceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotSampleUtteranceArgs:
    def __init__(__self__, *,
                 utterance: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "utterance", utterance)

    @_builtins.property
    @pulumi.getter
    def utterance(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "utterance")

    @utterance.setter
    def utterance(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "utterance", value)


if not MYPY:
    class BotSampleValueArgsDict(TypedDict):
        value: pulumi.Input[_builtins.str]
elif False:
    BotSampleValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotSampleValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class BotSessionAttributeArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The name of the session attribute.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The session-specific context information for the session attribute.
        """
elif False:
    BotSessionAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotSessionAttributeArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The name of the session attribute.
        :param pulumi.Input[_builtins.str] value: The session-specific context information for the session attribute.
        """
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the session attribute.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The session-specific context information for the session attribute.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class BotSlotCaptureSettingArgsDict(TypedDict):
        capture_conditional: NotRequired[pulumi.Input['BotConditionalSpecificationArgsDict']]
        """
        A list of conditional branches to evaluate after the slot value is captured.
        """
        capture_next_step: NotRequired[pulumi.Input['BotDialogStateArgsDict']]
        """
        Specifies the next step that the bot runs when the slot value is captured before the code hook times out.
        """
        capture_response: NotRequired[pulumi.Input['BotResponseSpecificationArgsDict']]
        """
        Specifies a list of message groups that Amazon Lex uses to respond the user input.
        """
        code_hook: NotRequired[pulumi.Input['BotDialogCodeHookInvocationSettingArgsDict']]
        """
        Code hook called after Amazon Lex successfully captures a slot value.
        """
        elicitation_code_hook: NotRequired[pulumi.Input['BotElicitationCodeHookInvocationSettingArgsDict']]
        """
        Code hook called when Amazon Lex doesn't capture a slot value.
        """
        failure_conditional: NotRequired[pulumi.Input['BotConditionalSpecificationArgsDict']]
        """
        A list of conditional branches to evaluate when the slot value isn't captured.
        """
        failure_next_step: NotRequired[pulumi.Input['BotDialogStateArgsDict']]
        """
        Specifies the next step that the bot runs when the slot value code is not recognized.
        """
        failure_response: NotRequired[pulumi.Input['BotResponseSpecificationArgsDict']]
        """
        Specifies a list of message groups that Amazon Lex uses to respond the user input when the slot fails to be captured.
        """
elif False:
    BotSlotCaptureSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotSlotCaptureSettingArgs:
    def __init__(__self__, *,
                 capture_conditional: Optional[pulumi.Input['BotConditionalSpecificationArgs']] = None,
                 capture_next_step: Optional[pulumi.Input['BotDialogStateArgs']] = None,
                 capture_response: Optional[pulumi.Input['BotResponseSpecificationArgs']] = None,
                 code_hook: Optional[pulumi.Input['BotDialogCodeHookInvocationSettingArgs']] = None,
                 elicitation_code_hook: Optional[pulumi.Input['BotElicitationCodeHookInvocationSettingArgs']] = None,
                 failure_conditional: Optional[pulumi.Input['BotConditionalSpecificationArgs']] = None,
                 failure_next_step: Optional[pulumi.Input['BotDialogStateArgs']] = None,
                 failure_response: Optional[pulumi.Input['BotResponseSpecificationArgs']] = None):
        """
        :param pulumi.Input['BotConditionalSpecificationArgs'] capture_conditional: A list of conditional branches to evaluate after the slot value is captured.
        :param pulumi.Input['BotDialogStateArgs'] capture_next_step: Specifies the next step that the bot runs when the slot value is captured before the code hook times out.
        :param pulumi.Input['BotResponseSpecificationArgs'] capture_response: Specifies a list of message groups that Amazon Lex uses to respond the user input.
        :param pulumi.Input['BotDialogCodeHookInvocationSettingArgs'] code_hook: Code hook called after Amazon Lex successfully captures a slot value.
        :param pulumi.Input['BotElicitationCodeHookInvocationSettingArgs'] elicitation_code_hook: Code hook called when Amazon Lex doesn't capture a slot value.
        :param pulumi.Input['BotConditionalSpecificationArgs'] failure_conditional: A list of conditional branches to evaluate when the slot value isn't captured.
        :param pulumi.Input['BotDialogStateArgs'] failure_next_step: Specifies the next step that the bot runs when the slot value code is not recognized.
        :param pulumi.Input['BotResponseSpecificationArgs'] failure_response: Specifies a list of message groups that Amazon Lex uses to respond the user input when the slot fails to be captured.
        """
        if capture_conditional is not None:
            pulumi.set(__self__, "capture_conditional", capture_conditional)
        if capture_next_step is not None:
            pulumi.set(__self__, "capture_next_step", capture_next_step)
        if capture_response is not None:
            pulumi.set(__self__, "capture_response", capture_response)
        if code_hook is not None:
            pulumi.set(__self__, "code_hook", code_hook)
        if elicitation_code_hook is not None:
            pulumi.set(__self__, "elicitation_code_hook", elicitation_code_hook)
        if failure_conditional is not None:
            pulumi.set(__self__, "failure_conditional", failure_conditional)
        if failure_next_step is not None:
            pulumi.set(__self__, "failure_next_step", failure_next_step)
        if failure_response is not None:
            pulumi.set(__self__, "failure_response", failure_response)

    @_builtins.property
    @pulumi.getter(name="captureConditional")
    def capture_conditional(self) -> Optional[pulumi.Input['BotConditionalSpecificationArgs']]:
        """
        A list of conditional branches to evaluate after the slot value is captured.
        """
        return pulumi.get(self, "capture_conditional")

    @capture_conditional.setter
    def capture_conditional(self, value: Optional[pulumi.Input['BotConditionalSpecificationArgs']]):
        pulumi.set(self, "capture_conditional", value)

    @_builtins.property
    @pulumi.getter(name="captureNextStep")
    def capture_next_step(self) -> Optional[pulumi.Input['BotDialogStateArgs']]:
        """
        Specifies the next step that the bot runs when the slot value is captured before the code hook times out.
        """
        return pulumi.get(self, "capture_next_step")

    @capture_next_step.setter
    def capture_next_step(self, value: Optional[pulumi.Input['BotDialogStateArgs']]):
        pulumi.set(self, "capture_next_step", value)

    @_builtins.property
    @pulumi.getter(name="captureResponse")
    def capture_response(self) -> Optional[pulumi.Input['BotResponseSpecificationArgs']]:
        """
        Specifies a list of message groups that Amazon Lex uses to respond the user input.
        """
        return pulumi.get(self, "capture_response")

    @capture_response.setter
    def capture_response(self, value: Optional[pulumi.Input['BotResponseSpecificationArgs']]):
        pulumi.set(self, "capture_response", value)

    @_builtins.property
    @pulumi.getter(name="codeHook")
    def code_hook(self) -> Optional[pulumi.Input['BotDialogCodeHookInvocationSettingArgs']]:
        """
        Code hook called after Amazon Lex successfully captures a slot value.
        """
        return pulumi.get(self, "code_hook")

    @code_hook.setter
    def code_hook(self, value: Optional[pulumi.Input['BotDialogCodeHookInvocationSettingArgs']]):
        pulumi.set(self, "code_hook", value)

    @_builtins.property
    @pulumi.getter(name="elicitationCodeHook")
    def elicitation_code_hook(self) -> Optional[pulumi.Input['BotElicitationCodeHookInvocationSettingArgs']]:
        """
        Code hook called when Amazon Lex doesn't capture a slot value.
        """
        return pulumi.get(self, "elicitation_code_hook")

    @elicitation_code_hook.setter
    def elicitation_code_hook(self, value: Optional[pulumi.Input['BotElicitationCodeHookInvocationSettingArgs']]):
        pulumi.set(self, "elicitation_code_hook", value)

    @_builtins.property
    @pulumi.getter(name="failureConditional")
    def failure_conditional(self) -> Optional[pulumi.Input['BotConditionalSpecificationArgs']]:
        """
        A list of conditional branches to evaluate when the slot value isn't captured.
        """
        return pulumi.get(self, "failure_conditional")

    @failure_conditional.setter
    def failure_conditional(self, value: Optional[pulumi.Input['BotConditionalSpecificationArgs']]):
        pulumi.set(self, "failure_conditional", value)

    @_builtins.property
    @pulumi.getter(name="failureNextStep")
    def failure_next_step(self) -> Optional[pulumi.Input['BotDialogStateArgs']]:
        """
        Specifies the next step that the bot runs when the slot value code is not recognized.
        """
        return pulumi.get(self, "failure_next_step")

    @failure_next_step.setter
    def failure_next_step(self, value: Optional[pulumi.Input['BotDialogStateArgs']]):
        pulumi.set(self, "failure_next_step", value)

    @_builtins.property
    @pulumi.getter(name="failureResponse")
    def failure_response(self) -> Optional[pulumi.Input['BotResponseSpecificationArgs']]:
        """
        Specifies a list of message groups that Amazon Lex uses to respond the user input when the slot fails to be captured.
        """
        return pulumi.get(self, "failure_response")

    @failure_response.setter
    def failure_response(self, value: Optional[pulumi.Input['BotResponseSpecificationArgs']]):
        pulumi.set(self, "failure_response", value)


if not MYPY:
    class BotSlotDefaultValueSpecificationArgsDict(TypedDict):
        default_value_list: pulumi.Input[Sequence[pulumi.Input['BotSlotDefaultValueArgsDict']]]
        """
        A list of default values. Amazon Lex chooses the default value to use in the order that they are presented in the list.
        """
elif False:
    BotSlotDefaultValueSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotSlotDefaultValueSpecificationArgs:
    def __init__(__self__, *,
                 default_value_list: pulumi.Input[Sequence[pulumi.Input['BotSlotDefaultValueArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BotSlotDefaultValueArgs']]] default_value_list: A list of default values. Amazon Lex chooses the default value to use in the order that they are presented in the list.
        """
        pulumi.set(__self__, "default_value_list", default_value_list)

    @_builtins.property
    @pulumi.getter(name="defaultValueList")
    def default_value_list(self) -> pulumi.Input[Sequence[pulumi.Input['BotSlotDefaultValueArgs']]]:
        """
        A list of default values. Amazon Lex chooses the default value to use in the order that they are presented in the list.
        """
        return pulumi.get(self, "default_value_list")

    @default_value_list.setter
    def default_value_list(self, value: pulumi.Input[Sequence[pulumi.Input['BotSlotDefaultValueArgs']]]):
        pulumi.set(self, "default_value_list", value)


if not MYPY:
    class BotSlotDefaultValueArgsDict(TypedDict):
        default_value: pulumi.Input[_builtins.str]
        """
        The default value to use when a user doesn't provide a value for a slot.
        """
elif False:
    BotSlotDefaultValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotSlotDefaultValueArgs:
    def __init__(__self__, *,
                 default_value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] default_value: The default value to use when a user doesn't provide a value for a slot.
        """
        pulumi.set(__self__, "default_value", default_value)

    @_builtins.property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> pulumi.Input[_builtins.str]:
        """
        The default value to use when a user doesn't provide a value for a slot.
        """
        return pulumi.get(self, "default_value")

    @default_value.setter
    def default_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "default_value", value)


if not MYPY:
    class BotSlotPriorityArgsDict(TypedDict):
        priority: pulumi.Input[_builtins.int]
        slot_name: pulumi.Input[_builtins.str]
elif False:
    BotSlotPriorityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotSlotPriorityArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[_builtins.int],
                 slot_name: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "slot_name", slot_name)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter(name="slotName")
    def slot_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "slot_name")

    @slot_name.setter
    def slot_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "slot_name", value)


if not MYPY:
    class BotSlotTypeValueArgsDict(TypedDict):
        sample_value: pulumi.Input['BotSampleValueArgsDict']
        synonyms: NotRequired[pulumi.Input[Sequence[pulumi.Input['BotSampleValueArgsDict']]]]
elif False:
    BotSlotTypeValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotSlotTypeValueArgs:
    def __init__(__self__, *,
                 sample_value: pulumi.Input['BotSampleValueArgs'],
                 synonyms: Optional[pulumi.Input[Sequence[pulumi.Input['BotSampleValueArgs']]]] = None):
        pulumi.set(__self__, "sample_value", sample_value)
        if synonyms is not None:
            pulumi.set(__self__, "synonyms", synonyms)

    @_builtins.property
    @pulumi.getter(name="sampleValue")
    def sample_value(self) -> pulumi.Input['BotSampleValueArgs']:
        return pulumi.get(self, "sample_value")

    @sample_value.setter
    def sample_value(self, value: pulumi.Input['BotSampleValueArgs']):
        pulumi.set(self, "sample_value", value)

    @_builtins.property
    @pulumi.getter
    def synonyms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotSampleValueArgs']]]]:
        return pulumi.get(self, "synonyms")

    @synonyms.setter
    def synonyms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotSampleValueArgs']]]]):
        pulumi.set(self, "synonyms", value)


if not MYPY:
    class BotSlotTypeArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of the slot type. A slot type name must be unique withing the account.
        """
        composite_slot_type_setting: NotRequired[pulumi.Input['BotCompositeSlotTypeSettingArgsDict']]
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description of the slot type. Use the description to help identify the slot type in lists.
        """
        external_source_setting: NotRequired[pulumi.Input['BotExternalSourceSettingArgsDict']]
        """
        Sets the type of external information used to create the slot type.
        """
        parent_slot_type_signature: NotRequired[pulumi.Input[_builtins.str]]
        """
        The built-in slot type used as a parent of this slot type. When you define a parent slot type, the new slot type has the configuration of the parent lot type.

        Only `AMAZON.AlphaNumeric` is supported.
        """
        slot_type_values: NotRequired[pulumi.Input[Sequence[pulumi.Input['BotSlotTypeValueArgsDict']]]]
        """
        A list of SlotTypeValue objects that defines the values that the slot type can take. Each value can have a list of synonyms, additional values that help train the machine learning model about the values that it resolves for the slot.
        """
        value_selection_setting: NotRequired[pulumi.Input['BotSlotValueSelectionSettingArgsDict']]
        """
        Determines the slot resolution strategy that Amazon Lex uses to return slot type values. The field can be set to one of the following values:

        - `ORIGINAL_VALUE` - Returns the value entered by the user, if the user value is similar to the slot value.
        - `TOP_RESOLUTION` - If there is a resolution list for the slot, return the first value in the resolution list as the slot type value. If there is no resolution list, null is returned.

        If you don't specify the `valueSelectionStrategy` , the default is `ORIGINAL_VALUE` .
        """
elif False:
    BotSlotTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotSlotTypeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 composite_slot_type_setting: Optional[pulumi.Input['BotCompositeSlotTypeSettingArgs']] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 external_source_setting: Optional[pulumi.Input['BotExternalSourceSettingArgs']] = None,
                 parent_slot_type_signature: Optional[pulumi.Input[_builtins.str]] = None,
                 slot_type_values: Optional[pulumi.Input[Sequence[pulumi.Input['BotSlotTypeValueArgs']]]] = None,
                 value_selection_setting: Optional[pulumi.Input['BotSlotValueSelectionSettingArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the slot type. A slot type name must be unique withing the account.
        :param pulumi.Input[_builtins.str] description: A description of the slot type. Use the description to help identify the slot type in lists.
        :param pulumi.Input['BotExternalSourceSettingArgs'] external_source_setting: Sets the type of external information used to create the slot type.
        :param pulumi.Input[_builtins.str] parent_slot_type_signature: The built-in slot type used as a parent of this slot type. When you define a parent slot type, the new slot type has the configuration of the parent lot type.
               
               Only `AMAZON.AlphaNumeric` is supported.
        :param pulumi.Input[Sequence[pulumi.Input['BotSlotTypeValueArgs']]] slot_type_values: A list of SlotTypeValue objects that defines the values that the slot type can take. Each value can have a list of synonyms, additional values that help train the machine learning model about the values that it resolves for the slot.
        :param pulumi.Input['BotSlotValueSelectionSettingArgs'] value_selection_setting: Determines the slot resolution strategy that Amazon Lex uses to return slot type values. The field can be set to one of the following values:
               
               - `ORIGINAL_VALUE` - Returns the value entered by the user, if the user value is similar to the slot value.
               - `TOP_RESOLUTION` - If there is a resolution list for the slot, return the first value in the resolution list as the slot type value. If there is no resolution list, null is returned.
               
               If you don't specify the `valueSelectionStrategy` , the default is `ORIGINAL_VALUE` .
        """
        pulumi.set(__self__, "name", name)
        if composite_slot_type_setting is not None:
            pulumi.set(__self__, "composite_slot_type_setting", composite_slot_type_setting)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if external_source_setting is not None:
            pulumi.set(__self__, "external_source_setting", external_source_setting)
        if parent_slot_type_signature is not None:
            pulumi.set(__self__, "parent_slot_type_signature", parent_slot_type_signature)
        if slot_type_values is not None:
            pulumi.set(__self__, "slot_type_values", slot_type_values)
        if value_selection_setting is not None:
            pulumi.set(__self__, "value_selection_setting", value_selection_setting)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the slot type. A slot type name must be unique withing the account.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="compositeSlotTypeSetting")
    def composite_slot_type_setting(self) -> Optional[pulumi.Input['BotCompositeSlotTypeSettingArgs']]:
        return pulumi.get(self, "composite_slot_type_setting")

    @composite_slot_type_setting.setter
    def composite_slot_type_setting(self, value: Optional[pulumi.Input['BotCompositeSlotTypeSettingArgs']]):
        pulumi.set(self, "composite_slot_type_setting", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description of the slot type. Use the description to help identify the slot type in lists.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="externalSourceSetting")
    def external_source_setting(self) -> Optional[pulumi.Input['BotExternalSourceSettingArgs']]:
        """
        Sets the type of external information used to create the slot type.
        """
        return pulumi.get(self, "external_source_setting")

    @external_source_setting.setter
    def external_source_setting(self, value: Optional[pulumi.Input['BotExternalSourceSettingArgs']]):
        pulumi.set(self, "external_source_setting", value)

    @_builtins.property
    @pulumi.getter(name="parentSlotTypeSignature")
    def parent_slot_type_signature(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The built-in slot type used as a parent of this slot type. When you define a parent slot type, the new slot type has the configuration of the parent lot type.

        Only `AMAZON.AlphaNumeric` is supported.
        """
        return pulumi.get(self, "parent_slot_type_signature")

    @parent_slot_type_signature.setter
    def parent_slot_type_signature(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "parent_slot_type_signature", value)

    @_builtins.property
    @pulumi.getter(name="slotTypeValues")
    def slot_type_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotSlotTypeValueArgs']]]]:
        """
        A list of SlotTypeValue objects that defines the values that the slot type can take. Each value can have a list of synonyms, additional values that help train the machine learning model about the values that it resolves for the slot.
        """
        return pulumi.get(self, "slot_type_values")

    @slot_type_values.setter
    def slot_type_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotSlotTypeValueArgs']]]]):
        pulumi.set(self, "slot_type_values", value)

    @_builtins.property
    @pulumi.getter(name="valueSelectionSetting")
    def value_selection_setting(self) -> Optional[pulumi.Input['BotSlotValueSelectionSettingArgs']]:
        """
        Determines the slot resolution strategy that Amazon Lex uses to return slot type values. The field can be set to one of the following values:

        - `ORIGINAL_VALUE` - Returns the value entered by the user, if the user value is similar to the slot value.
        - `TOP_RESOLUTION` - If there is a resolution list for the slot, return the first value in the resolution list as the slot type value. If there is no resolution list, null is returned.

        If you don't specify the `valueSelectionStrategy` , the default is `ORIGINAL_VALUE` .
        """
        return pulumi.get(self, "value_selection_setting")

    @value_selection_setting.setter
    def value_selection_setting(self, value: Optional[pulumi.Input['BotSlotValueSelectionSettingArgs']]):
        pulumi.set(self, "value_selection_setting", value)


if not MYPY:
    class BotSlotValueElicitationSettingArgsDict(TypedDict):
        slot_constraint: pulumi.Input['BotSlotConstraint']
        """
        Specifies whether the slot is required or optional.
        """
        default_value_specification: NotRequired[pulumi.Input['BotSlotDefaultValueSpecificationArgsDict']]
        """
        A list of default values for a slot. Default values are used when Amazon Lex hasn't determined a value for a slot. You can specify default values from context variables, session attributes, and defined values.
        """
        prompt_specification: NotRequired[pulumi.Input['BotPromptSpecificationArgsDict']]
        """
        The prompt that Amazon Lex uses to elicit the slot value from the user.
        """
        sample_utterances: NotRequired[pulumi.Input[Sequence[pulumi.Input['BotSampleUtteranceArgsDict']]]]
        """
        If you know a specific pattern that users might respond to an Amazon Lex request for a slot value, you can provide those utterances to improve accuracy. This is optional. In most cases, Amazon Lex is capable of understanding user utterances.
        """
        slot_capture_setting: NotRequired[pulumi.Input['BotSlotCaptureSettingArgsDict']]
        """
        Specifies the settings that Amazon Lex uses when a slot value is successfully entered by a user.
        """
        wait_and_continue_specification: NotRequired[pulumi.Input['BotWaitAndContinueSpecificationArgsDict']]
        """
        Specifies the prompts that Amazon Lex uses while a bot is waiting for customer input.
        """
elif False:
    BotSlotValueElicitationSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotSlotValueElicitationSettingArgs:
    def __init__(__self__, *,
                 slot_constraint: pulumi.Input['BotSlotConstraint'],
                 default_value_specification: Optional[pulumi.Input['BotSlotDefaultValueSpecificationArgs']] = None,
                 prompt_specification: Optional[pulumi.Input['BotPromptSpecificationArgs']] = None,
                 sample_utterances: Optional[pulumi.Input[Sequence[pulumi.Input['BotSampleUtteranceArgs']]]] = None,
                 slot_capture_setting: Optional[pulumi.Input['BotSlotCaptureSettingArgs']] = None,
                 wait_and_continue_specification: Optional[pulumi.Input['BotWaitAndContinueSpecificationArgs']] = None):
        """
        :param pulumi.Input['BotSlotConstraint'] slot_constraint: Specifies whether the slot is required or optional.
        :param pulumi.Input['BotSlotDefaultValueSpecificationArgs'] default_value_specification: A list of default values for a slot. Default values are used when Amazon Lex hasn't determined a value for a slot. You can specify default values from context variables, session attributes, and defined values.
        :param pulumi.Input['BotPromptSpecificationArgs'] prompt_specification: The prompt that Amazon Lex uses to elicit the slot value from the user.
        :param pulumi.Input[Sequence[pulumi.Input['BotSampleUtteranceArgs']]] sample_utterances: If you know a specific pattern that users might respond to an Amazon Lex request for a slot value, you can provide those utterances to improve accuracy. This is optional. In most cases, Amazon Lex is capable of understanding user utterances.
        :param pulumi.Input['BotSlotCaptureSettingArgs'] slot_capture_setting: Specifies the settings that Amazon Lex uses when a slot value is successfully entered by a user.
        :param pulumi.Input['BotWaitAndContinueSpecificationArgs'] wait_and_continue_specification: Specifies the prompts that Amazon Lex uses while a bot is waiting for customer input.
        """
        pulumi.set(__self__, "slot_constraint", slot_constraint)
        if default_value_specification is not None:
            pulumi.set(__self__, "default_value_specification", default_value_specification)
        if prompt_specification is not None:
            pulumi.set(__self__, "prompt_specification", prompt_specification)
        if sample_utterances is not None:
            pulumi.set(__self__, "sample_utterances", sample_utterances)
        if slot_capture_setting is not None:
            pulumi.set(__self__, "slot_capture_setting", slot_capture_setting)
        if wait_and_continue_specification is not None:
            pulumi.set(__self__, "wait_and_continue_specification", wait_and_continue_specification)

    @_builtins.property
    @pulumi.getter(name="slotConstraint")
    def slot_constraint(self) -> pulumi.Input['BotSlotConstraint']:
        """
        Specifies whether the slot is required or optional.
        """
        return pulumi.get(self, "slot_constraint")

    @slot_constraint.setter
    def slot_constraint(self, value: pulumi.Input['BotSlotConstraint']):
        pulumi.set(self, "slot_constraint", value)

    @_builtins.property
    @pulumi.getter(name="defaultValueSpecification")
    def default_value_specification(self) -> Optional[pulumi.Input['BotSlotDefaultValueSpecificationArgs']]:
        """
        A list of default values for a slot. Default values are used when Amazon Lex hasn't determined a value for a slot. You can specify default values from context variables, session attributes, and defined values.
        """
        return pulumi.get(self, "default_value_specification")

    @default_value_specification.setter
    def default_value_specification(self, value: Optional[pulumi.Input['BotSlotDefaultValueSpecificationArgs']]):
        pulumi.set(self, "default_value_specification", value)

    @_builtins.property
    @pulumi.getter(name="promptSpecification")
    def prompt_specification(self) -> Optional[pulumi.Input['BotPromptSpecificationArgs']]:
        """
        The prompt that Amazon Lex uses to elicit the slot value from the user.
        """
        return pulumi.get(self, "prompt_specification")

    @prompt_specification.setter
    def prompt_specification(self, value: Optional[pulumi.Input['BotPromptSpecificationArgs']]):
        pulumi.set(self, "prompt_specification", value)

    @_builtins.property
    @pulumi.getter(name="sampleUtterances")
    def sample_utterances(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotSampleUtteranceArgs']]]]:
        """
        If you know a specific pattern that users might respond to an Amazon Lex request for a slot value, you can provide those utterances to improve accuracy. This is optional. In most cases, Amazon Lex is capable of understanding user utterances.
        """
        return pulumi.get(self, "sample_utterances")

    @sample_utterances.setter
    def sample_utterances(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotSampleUtteranceArgs']]]]):
        pulumi.set(self, "sample_utterances", value)

    @_builtins.property
    @pulumi.getter(name="slotCaptureSetting")
    def slot_capture_setting(self) -> Optional[pulumi.Input['BotSlotCaptureSettingArgs']]:
        """
        Specifies the settings that Amazon Lex uses when a slot value is successfully entered by a user.
        """
        return pulumi.get(self, "slot_capture_setting")

    @slot_capture_setting.setter
    def slot_capture_setting(self, value: Optional[pulumi.Input['BotSlotCaptureSettingArgs']]):
        pulumi.set(self, "slot_capture_setting", value)

    @_builtins.property
    @pulumi.getter(name="waitAndContinueSpecification")
    def wait_and_continue_specification(self) -> Optional[pulumi.Input['BotWaitAndContinueSpecificationArgs']]:
        """
        Specifies the prompts that Amazon Lex uses while a bot is waiting for customer input.
        """
        return pulumi.get(self, "wait_and_continue_specification")

    @wait_and_continue_specification.setter
    def wait_and_continue_specification(self, value: Optional[pulumi.Input['BotWaitAndContinueSpecificationArgs']]):
        pulumi.set(self, "wait_and_continue_specification", value)


if not MYPY:
    class BotSlotValueOverrideMapArgsDict(TypedDict):
        slot_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the slot.
        """
        slot_value_override: NotRequired[pulumi.Input['BotSlotValueOverrideArgsDict']]
        """
        The SlotValueOverride object to which the slot name will be mapped.
        """
elif False:
    BotSlotValueOverrideMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotSlotValueOverrideMapArgs:
    def __init__(__self__, *,
                 slot_name: Optional[pulumi.Input[_builtins.str]] = None,
                 slot_value_override: Optional[pulumi.Input['BotSlotValueOverrideArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] slot_name: The name of the slot.
        :param pulumi.Input['BotSlotValueOverrideArgs'] slot_value_override: The SlotValueOverride object to which the slot name will be mapped.
        """
        if slot_name is not None:
            pulumi.set(__self__, "slot_name", slot_name)
        if slot_value_override is not None:
            pulumi.set(__self__, "slot_value_override", slot_value_override)

    @_builtins.property
    @pulumi.getter(name="slotName")
    def slot_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the slot.
        """
        return pulumi.get(self, "slot_name")

    @slot_name.setter
    def slot_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "slot_name", value)

    @_builtins.property
    @pulumi.getter(name="slotValueOverride")
    def slot_value_override(self) -> Optional[pulumi.Input['BotSlotValueOverrideArgs']]:
        """
        The SlotValueOverride object to which the slot name will be mapped.
        """
        return pulumi.get(self, "slot_value_override")

    @slot_value_override.setter
    def slot_value_override(self, value: Optional[pulumi.Input['BotSlotValueOverrideArgs']]):
        pulumi.set(self, "slot_value_override", value)


if not MYPY:
    class BotSlotValueOverrideArgsDict(TypedDict):
        shape: NotRequired[pulumi.Input['BotSlotShape']]
        """
        When the shape value is `List` , it indicates that the `values` field contains a list of slot values. When the value is `Scalar` , it indicates that the `value` field contains a single value.
        """
        value: NotRequired[pulumi.Input['BotSlotValueArgsDict']]
        """
        The current value of the slot.
        """
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input['BotSlotValueOverrideArgsDict']]]]
        """
        A list of one or more values that the user provided for the slot. For example, for a slot that elicits pizza toppings, the values might be "pepperoni" and "pineapple."
        """
elif False:
    BotSlotValueOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotSlotValueOverrideArgs:
    def __init__(__self__, *,
                 shape: Optional[pulumi.Input['BotSlotShape']] = None,
                 value: Optional[pulumi.Input['BotSlotValueArgs']] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input['BotSlotValueOverrideArgs']]]] = None):
        """
        :param pulumi.Input['BotSlotShape'] shape: When the shape value is `List` , it indicates that the `values` field contains a list of slot values. When the value is `Scalar` , it indicates that the `value` field contains a single value.
        :param pulumi.Input['BotSlotValueArgs'] value: The current value of the slot.
        :param pulumi.Input[Sequence[pulumi.Input['BotSlotValueOverrideArgs']]] values: A list of one or more values that the user provided for the slot. For example, for a slot that elicits pizza toppings, the values might be "pepperoni" and "pineapple."
        """
        if shape is not None:
            pulumi.set(__self__, "shape", shape)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def shape(self) -> Optional[pulumi.Input['BotSlotShape']]:
        """
        When the shape value is `List` , it indicates that the `values` field contains a list of slot values. When the value is `Scalar` , it indicates that the `value` field contains a single value.
        """
        return pulumi.get(self, "shape")

    @shape.setter
    def shape(self, value: Optional[pulumi.Input['BotSlotShape']]):
        pulumi.set(self, "shape", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input['BotSlotValueArgs']]:
        """
        The current value of the slot.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input['BotSlotValueArgs']]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotSlotValueOverrideArgs']]]]:
        """
        A list of one or more values that the user provided for the slot. For example, for a slot that elicits pizza toppings, the values might be "pepperoni" and "pineapple."
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotSlotValueOverrideArgs']]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class BotSlotValueRegexFilterArgsDict(TypedDict):
        pattern: pulumi.Input[_builtins.str]
        """
        A regular expression used to validate the value of a slot.

        Use a standard regular expression. Amazon Lex supports the following characters in the regular expression:

        - A-Z, a-z
        - 0-9
        - Unicode characters ("\\u<Unicode>")

        Represent Unicode characters with four digits, for example "\\u0041" or "\\u005A".

        The following regular expression operators are not supported:

        - Infinite repeaters: *, +, or {x,} with no upper bound.
        - Wild card (.)
        """
elif False:
    BotSlotValueRegexFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotSlotValueRegexFilterArgs:
    def __init__(__self__, *,
                 pattern: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] pattern: A regular expression used to validate the value of a slot.
               
               Use a standard regular expression. Amazon Lex supports the following characters in the regular expression:
               
               - A-Z, a-z
               - 0-9
               - Unicode characters ("\\u<Unicode>")
               
               Represent Unicode characters with four digits, for example "\\u0041" or "\\u005A".
               
               The following regular expression operators are not supported:
               
               - Infinite repeaters: *, +, or {x,} with no upper bound.
               - Wild card (.)
        """
        pulumi.set(__self__, "pattern", pattern)

    @_builtins.property
    @pulumi.getter
    def pattern(self) -> pulumi.Input[_builtins.str]:
        """
        A regular expression used to validate the value of a slot.

        Use a standard regular expression. Amazon Lex supports the following characters in the regular expression:

        - A-Z, a-z
        - 0-9
        - Unicode characters ("\\u<Unicode>")

        Represent Unicode characters with four digits, for example "\\u0041" or "\\u005A".

        The following regular expression operators are not supported:

        - Infinite repeaters: *, +, or {x,} with no upper bound.
        - Wild card (.)
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "pattern", value)


if not MYPY:
    class BotSlotValueSelectionSettingArgsDict(TypedDict):
        resolution_strategy: pulumi.Input['BotSlotValueResolutionStrategy']
        """
        Determines the slot resolution strategy that Amazon Lex uses to return slot type values. The field can be set to one of the following values:

        - `ORIGINAL_VALUE` - Returns the value entered by the user, if the user value is similar to the slot value.
        - `TOP_RESOLUTION` - If there is a resolution list for the slot, return the first value in the resolution list as the slot type value. If there is no resolution list, null is returned.

        If you don't specify the `valueSelectionStrategy` , the default is `ORIGINAL_VALUE` .
        """
        advanced_recognition_setting: NotRequired[pulumi.Input['BotAdvancedRecognitionSettingArgsDict']]
        """
        Provides settings that enable advanced recognition settings for slot values. You can use this to enable using slot values as a custom vocabulary for recognizing user utterances.
        """
        regex_filter: NotRequired[pulumi.Input['BotSlotValueRegexFilterArgsDict']]
        """
        A regular expression used to validate the value of a slot.
        """
elif False:
    BotSlotValueSelectionSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotSlotValueSelectionSettingArgs:
    def __init__(__self__, *,
                 resolution_strategy: pulumi.Input['BotSlotValueResolutionStrategy'],
                 advanced_recognition_setting: Optional[pulumi.Input['BotAdvancedRecognitionSettingArgs']] = None,
                 regex_filter: Optional[pulumi.Input['BotSlotValueRegexFilterArgs']] = None):
        """
        :param pulumi.Input['BotSlotValueResolutionStrategy'] resolution_strategy: Determines the slot resolution strategy that Amazon Lex uses to return slot type values. The field can be set to one of the following values:
               
               - `ORIGINAL_VALUE` - Returns the value entered by the user, if the user value is similar to the slot value.
               - `TOP_RESOLUTION` - If there is a resolution list for the slot, return the first value in the resolution list as the slot type value. If there is no resolution list, null is returned.
               
               If you don't specify the `valueSelectionStrategy` , the default is `ORIGINAL_VALUE` .
        :param pulumi.Input['BotAdvancedRecognitionSettingArgs'] advanced_recognition_setting: Provides settings that enable advanced recognition settings for slot values. You can use this to enable using slot values as a custom vocabulary for recognizing user utterances.
        :param pulumi.Input['BotSlotValueRegexFilterArgs'] regex_filter: A regular expression used to validate the value of a slot.
        """
        pulumi.set(__self__, "resolution_strategy", resolution_strategy)
        if advanced_recognition_setting is not None:
            pulumi.set(__self__, "advanced_recognition_setting", advanced_recognition_setting)
        if regex_filter is not None:
            pulumi.set(__self__, "regex_filter", regex_filter)

    @_builtins.property
    @pulumi.getter(name="resolutionStrategy")
    def resolution_strategy(self) -> pulumi.Input['BotSlotValueResolutionStrategy']:
        """
        Determines the slot resolution strategy that Amazon Lex uses to return slot type values. The field can be set to one of the following values:

        - `ORIGINAL_VALUE` - Returns the value entered by the user, if the user value is similar to the slot value.
        - `TOP_RESOLUTION` - If there is a resolution list for the slot, return the first value in the resolution list as the slot type value. If there is no resolution list, null is returned.

        If you don't specify the `valueSelectionStrategy` , the default is `ORIGINAL_VALUE` .
        """
        return pulumi.get(self, "resolution_strategy")

    @resolution_strategy.setter
    def resolution_strategy(self, value: pulumi.Input['BotSlotValueResolutionStrategy']):
        pulumi.set(self, "resolution_strategy", value)

    @_builtins.property
    @pulumi.getter(name="advancedRecognitionSetting")
    def advanced_recognition_setting(self) -> Optional[pulumi.Input['BotAdvancedRecognitionSettingArgs']]:
        """
        Provides settings that enable advanced recognition settings for slot values. You can use this to enable using slot values as a custom vocabulary for recognizing user utterances.
        """
        return pulumi.get(self, "advanced_recognition_setting")

    @advanced_recognition_setting.setter
    def advanced_recognition_setting(self, value: Optional[pulumi.Input['BotAdvancedRecognitionSettingArgs']]):
        pulumi.set(self, "advanced_recognition_setting", value)

    @_builtins.property
    @pulumi.getter(name="regexFilter")
    def regex_filter(self) -> Optional[pulumi.Input['BotSlotValueRegexFilterArgs']]:
        """
        A regular expression used to validate the value of a slot.
        """
        return pulumi.get(self, "regex_filter")

    @regex_filter.setter
    def regex_filter(self, value: Optional[pulumi.Input['BotSlotValueRegexFilterArgs']]):
        pulumi.set(self, "regex_filter", value)


if not MYPY:
    class BotSlotValueArgsDict(TypedDict):
        interpreted_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value that Amazon Lex determines for the slot. The actual value depends on the setting of the value selection strategy for the bot. You can choose to use the value entered by the user, or you can have Amazon Lex choose the first value in the `resolvedValues` list.
        """
elif False:
    BotSlotValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotSlotValueArgs:
    def __init__(__self__, *,
                 interpreted_value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] interpreted_value: The value that Amazon Lex determines for the slot. The actual value depends on the setting of the value selection strategy for the bot. You can choose to use the value entered by the user, or you can have Amazon Lex choose the first value in the `resolvedValues` list.
        """
        if interpreted_value is not None:
            pulumi.set(__self__, "interpreted_value", interpreted_value)

    @_builtins.property
    @pulumi.getter(name="interpretedValue")
    def interpreted_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value that Amazon Lex determines for the slot. The actual value depends on the setting of the value selection strategy for the bot. You can choose to use the value entered by the user, or you can have Amazon Lex choose the first value in the `resolvedValues` list.
        """
        return pulumi.get(self, "interpreted_value")

    @interpreted_value.setter
    def interpreted_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interpreted_value", value)


if not MYPY:
    class BotSlotArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name given to the slot.
        """
        slot_type_name: pulumi.Input[_builtins.str]
        """
        The name of the slot type that this slot is based on. The slot type defines the acceptable values for the slot.
        """
        value_elicitation_setting: pulumi.Input['BotSlotValueElicitationSettingArgsDict']
        """
        Determines the slot resolution strategy that Amazon Lex uses to return slot type values. The field can be set to one of the following values:

        - ORIGINAL_VALUE - Returns the value entered by the user, if the user value is similar to a slot value.
        - TOP_RESOLUTION - If there is a resolution list for the slot, return the first value in the resolution list as the slot type value. If there is no resolution list, null is returned.

        If you don't specify the `valueSelectionStrategy` , the default is `ORIGINAL_VALUE` .
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the slot.
        """
        multiple_values_setting: NotRequired[pulumi.Input['BotMultipleValuesSettingArgsDict']]
        """
        Indicates whether a slot can return multiple values.
        """
        obfuscation_setting: NotRequired[pulumi.Input['BotObfuscationSettingArgsDict']]
        """
        Determines whether the contents of the slot are obfuscated in Amazon CloudWatch Logs logs. Use obfuscated slots to protect information such as personally identifiable information (PII) in logs.
        """
        sub_slot_setting: NotRequired[pulumi.Input['BotSubSlotSettingArgsDict']]
elif False:
    BotSlotArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotSlotArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 slot_type_name: pulumi.Input[_builtins.str],
                 value_elicitation_setting: pulumi.Input['BotSlotValueElicitationSettingArgs'],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 multiple_values_setting: Optional[pulumi.Input['BotMultipleValuesSettingArgs']] = None,
                 obfuscation_setting: Optional[pulumi.Input['BotObfuscationSettingArgs']] = None,
                 sub_slot_setting: Optional[pulumi.Input['BotSubSlotSettingArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name given to the slot.
        :param pulumi.Input[_builtins.str] slot_type_name: The name of the slot type that this slot is based on. The slot type defines the acceptable values for the slot.
        :param pulumi.Input['BotSlotValueElicitationSettingArgs'] value_elicitation_setting: Determines the slot resolution strategy that Amazon Lex uses to return slot type values. The field can be set to one of the following values:
               
               - ORIGINAL_VALUE - Returns the value entered by the user, if the user value is similar to a slot value.
               - TOP_RESOLUTION - If there is a resolution list for the slot, return the first value in the resolution list as the slot type value. If there is no resolution list, null is returned.
               
               If you don't specify the `valueSelectionStrategy` , the default is `ORIGINAL_VALUE` .
        :param pulumi.Input[_builtins.str] description: The description of the slot.
        :param pulumi.Input['BotMultipleValuesSettingArgs'] multiple_values_setting: Indicates whether a slot can return multiple values.
        :param pulumi.Input['BotObfuscationSettingArgs'] obfuscation_setting: Determines whether the contents of the slot are obfuscated in Amazon CloudWatch Logs logs. Use obfuscated slots to protect information such as personally identifiable information (PII) in logs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "slot_type_name", slot_type_name)
        pulumi.set(__self__, "value_elicitation_setting", value_elicitation_setting)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if multiple_values_setting is not None:
            pulumi.set(__self__, "multiple_values_setting", multiple_values_setting)
        if obfuscation_setting is not None:
            pulumi.set(__self__, "obfuscation_setting", obfuscation_setting)
        if sub_slot_setting is not None:
            pulumi.set(__self__, "sub_slot_setting", sub_slot_setting)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name given to the slot.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="slotTypeName")
    def slot_type_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the slot type that this slot is based on. The slot type defines the acceptable values for the slot.
        """
        return pulumi.get(self, "slot_type_name")

    @slot_type_name.setter
    def slot_type_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "slot_type_name", value)

    @_builtins.property
    @pulumi.getter(name="valueElicitationSetting")
    def value_elicitation_setting(self) -> pulumi.Input['BotSlotValueElicitationSettingArgs']:
        """
        Determines the slot resolution strategy that Amazon Lex uses to return slot type values. The field can be set to one of the following values:

        - ORIGINAL_VALUE - Returns the value entered by the user, if the user value is similar to a slot value.
        - TOP_RESOLUTION - If there is a resolution list for the slot, return the first value in the resolution list as the slot type value. If there is no resolution list, null is returned.

        If you don't specify the `valueSelectionStrategy` , the default is `ORIGINAL_VALUE` .
        """
        return pulumi.get(self, "value_elicitation_setting")

    @value_elicitation_setting.setter
    def value_elicitation_setting(self, value: pulumi.Input['BotSlotValueElicitationSettingArgs']):
        pulumi.set(self, "value_elicitation_setting", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the slot.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="multipleValuesSetting")
    def multiple_values_setting(self) -> Optional[pulumi.Input['BotMultipleValuesSettingArgs']]:
        """
        Indicates whether a slot can return multiple values.
        """
        return pulumi.get(self, "multiple_values_setting")

    @multiple_values_setting.setter
    def multiple_values_setting(self, value: Optional[pulumi.Input['BotMultipleValuesSettingArgs']]):
        pulumi.set(self, "multiple_values_setting", value)

    @_builtins.property
    @pulumi.getter(name="obfuscationSetting")
    def obfuscation_setting(self) -> Optional[pulumi.Input['BotObfuscationSettingArgs']]:
        """
        Determines whether the contents of the slot are obfuscated in Amazon CloudWatch Logs logs. Use obfuscated slots to protect information such as personally identifiable information (PII) in logs.
        """
        return pulumi.get(self, "obfuscation_setting")

    @obfuscation_setting.setter
    def obfuscation_setting(self, value: Optional[pulumi.Input['BotObfuscationSettingArgs']]):
        pulumi.set(self, "obfuscation_setting", value)

    @_builtins.property
    @pulumi.getter(name="subSlotSetting")
    def sub_slot_setting(self) -> Optional[pulumi.Input['BotSubSlotSettingArgs']]:
        return pulumi.get(self, "sub_slot_setting")

    @sub_slot_setting.setter
    def sub_slot_setting(self, value: Optional[pulumi.Input['BotSubSlotSettingArgs']]):
        pulumi.set(self, "sub_slot_setting", value)


if not MYPY:
    class BotSpecificationsArgsDict(TypedDict):
        slot_type_id: pulumi.Input[_builtins.str]
        value_elicitation_setting: pulumi.Input['BotSubSlotValueElicitationSettingArgsDict']
elif False:
    BotSpecificationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotSpecificationsArgs:
    def __init__(__self__, *,
                 slot_type_id: pulumi.Input[_builtins.str],
                 value_elicitation_setting: pulumi.Input['BotSubSlotValueElicitationSettingArgs']):
        pulumi.set(__self__, "slot_type_id", slot_type_id)
        pulumi.set(__self__, "value_elicitation_setting", value_elicitation_setting)

    @_builtins.property
    @pulumi.getter(name="slotTypeId")
    def slot_type_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "slot_type_id")

    @slot_type_id.setter
    def slot_type_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "slot_type_id", value)

    @_builtins.property
    @pulumi.getter(name="valueElicitationSetting")
    def value_elicitation_setting(self) -> pulumi.Input['BotSubSlotValueElicitationSettingArgs']:
        return pulumi.get(self, "value_elicitation_setting")

    @value_elicitation_setting.setter
    def value_elicitation_setting(self, value: pulumi.Input['BotSubSlotValueElicitationSettingArgs']):
        pulumi.set(self, "value_elicitation_setting", value)


if not MYPY:
    class BotSsmlMessageArgsDict(TypedDict):
        value: pulumi.Input[_builtins.str]
elif False:
    BotSsmlMessageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotSsmlMessageArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class BotStillWaitingResponseSpecificationArgsDict(TypedDict):
        frequency_in_seconds: pulumi.Input[_builtins.int]
        """
        How often a message should be sent to the user. Minimum of 1 second, maximum of 5 minutes.
        """
        message_groups_list: pulumi.Input[Sequence[pulumi.Input['BotMessageGroupArgsDict']]]
        """
        One or more message groups, each containing one or more messages, that define the prompts that Amazon Lex sends to the user.
        """
        timeout_in_seconds: pulumi.Input[_builtins.int]
        """
        If Amazon Lex waits longer than this length of time for a response, it will stop sending messages.
        """
        allow_interrupt: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates that the user can interrupt the response by speaking while the message is being played.
        """
elif False:
    BotStillWaitingResponseSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotStillWaitingResponseSpecificationArgs:
    def __init__(__self__, *,
                 frequency_in_seconds: pulumi.Input[_builtins.int],
                 message_groups_list: pulumi.Input[Sequence[pulumi.Input['BotMessageGroupArgs']]],
                 timeout_in_seconds: pulumi.Input[_builtins.int],
                 allow_interrupt: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.int] frequency_in_seconds: How often a message should be sent to the user. Minimum of 1 second, maximum of 5 minutes.
        :param pulumi.Input[Sequence[pulumi.Input['BotMessageGroupArgs']]] message_groups_list: One or more message groups, each containing one or more messages, that define the prompts that Amazon Lex sends to the user.
        :param pulumi.Input[_builtins.int] timeout_in_seconds: If Amazon Lex waits longer than this length of time for a response, it will stop sending messages.
        :param pulumi.Input[_builtins.bool] allow_interrupt: Indicates that the user can interrupt the response by speaking while the message is being played.
        """
        pulumi.set(__self__, "frequency_in_seconds", frequency_in_seconds)
        pulumi.set(__self__, "message_groups_list", message_groups_list)
        pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)
        if allow_interrupt is not None:
            pulumi.set(__self__, "allow_interrupt", allow_interrupt)

    @_builtins.property
    @pulumi.getter(name="frequencyInSeconds")
    def frequency_in_seconds(self) -> pulumi.Input[_builtins.int]:
        """
        How often a message should be sent to the user. Minimum of 1 second, maximum of 5 minutes.
        """
        return pulumi.get(self, "frequency_in_seconds")

    @frequency_in_seconds.setter
    def frequency_in_seconds(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "frequency_in_seconds", value)

    @_builtins.property
    @pulumi.getter(name="messageGroupsList")
    def message_groups_list(self) -> pulumi.Input[Sequence[pulumi.Input['BotMessageGroupArgs']]]:
        """
        One or more message groups, each containing one or more messages, that define the prompts that Amazon Lex sends to the user.
        """
        return pulumi.get(self, "message_groups_list")

    @message_groups_list.setter
    def message_groups_list(self, value: pulumi.Input[Sequence[pulumi.Input['BotMessageGroupArgs']]]):
        pulumi.set(self, "message_groups_list", value)

    @_builtins.property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> pulumi.Input[_builtins.int]:
        """
        If Amazon Lex waits longer than this length of time for a response, it will stop sending messages.
        """
        return pulumi.get(self, "timeout_in_seconds")

    @timeout_in_seconds.setter
    def timeout_in_seconds(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "timeout_in_seconds", value)

    @_builtins.property
    @pulumi.getter(name="allowInterrupt")
    def allow_interrupt(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates that the user can interrupt the response by speaking while the message is being played.
        """
        return pulumi.get(self, "allow_interrupt")

    @allow_interrupt.setter
    def allow_interrupt(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_interrupt", value)


if not MYPY:
    class BotSubSlotSettingArgsDict(TypedDict):
        expression: NotRequired[pulumi.Input[_builtins.str]]
        """
        The expression text for defining the constituent sub slots in the composite slot using logical AND and OR operators.
        """
        slot_specifications: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['BotSpecificationsArgsDict']]]]
        """
        Specifications for the constituent sub slots of a composite slot.
        """
elif False:
    BotSubSlotSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotSubSlotSettingArgs:
    def __init__(__self__, *,
                 expression: Optional[pulumi.Input[_builtins.str]] = None,
                 slot_specifications: Optional[pulumi.Input[Mapping[str, pulumi.Input['BotSpecificationsArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] expression: The expression text for defining the constituent sub slots in the composite slot using logical AND and OR operators.
        :param pulumi.Input[Mapping[str, pulumi.Input['BotSpecificationsArgs']]] slot_specifications: Specifications for the constituent sub slots of a composite slot.
        """
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if slot_specifications is not None:
            pulumi.set(__self__, "slot_specifications", slot_specifications)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The expression text for defining the constituent sub slots in the composite slot using logical AND and OR operators.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter(name="slotSpecifications")
    def slot_specifications(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['BotSpecificationsArgs']]]]:
        """
        Specifications for the constituent sub slots of a composite slot.
        """
        return pulumi.get(self, "slot_specifications")

    @slot_specifications.setter
    def slot_specifications(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['BotSpecificationsArgs']]]]):
        pulumi.set(self, "slot_specifications", value)


if not MYPY:
    class BotSubSlotTypeCompositionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of a constituent sub slot inside a composite slot.
        """
        slot_type_id: pulumi.Input[_builtins.str]
        """
        The unique identifier assigned to a slot type. This refers to either a built-in slot type or the unique slotTypeId of a custom slot type.
        """
elif False:
    BotSubSlotTypeCompositionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotSubSlotTypeCompositionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 slot_type_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: Name of a constituent sub slot inside a composite slot.
        :param pulumi.Input[_builtins.str] slot_type_id: The unique identifier assigned to a slot type. This refers to either a built-in slot type or the unique slotTypeId of a custom slot type.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "slot_type_id", slot_type_id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of a constituent sub slot inside a composite slot.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="slotTypeId")
    def slot_type_id(self) -> pulumi.Input[_builtins.str]:
        """
        The unique identifier assigned to a slot type. This refers to either a built-in slot type or the unique slotTypeId of a custom slot type.
        """
        return pulumi.get(self, "slot_type_id")

    @slot_type_id.setter
    def slot_type_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "slot_type_id", value)


if not MYPY:
    class BotSubSlotValueElicitationSettingArgsDict(TypedDict):
        default_value_specification: NotRequired[pulumi.Input['BotSlotDefaultValueSpecificationArgsDict']]
        prompt_specification: NotRequired[pulumi.Input['BotPromptSpecificationArgsDict']]
        sample_utterances: NotRequired[pulumi.Input[Sequence[pulumi.Input['BotSampleUtteranceArgsDict']]]]
        wait_and_continue_specification: NotRequired[pulumi.Input['BotWaitAndContinueSpecificationArgsDict']]
elif False:
    BotSubSlotValueElicitationSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotSubSlotValueElicitationSettingArgs:
    def __init__(__self__, *,
                 default_value_specification: Optional[pulumi.Input['BotSlotDefaultValueSpecificationArgs']] = None,
                 prompt_specification: Optional[pulumi.Input['BotPromptSpecificationArgs']] = None,
                 sample_utterances: Optional[pulumi.Input[Sequence[pulumi.Input['BotSampleUtteranceArgs']]]] = None,
                 wait_and_continue_specification: Optional[pulumi.Input['BotWaitAndContinueSpecificationArgs']] = None):
        if default_value_specification is not None:
            pulumi.set(__self__, "default_value_specification", default_value_specification)
        if prompt_specification is not None:
            pulumi.set(__self__, "prompt_specification", prompt_specification)
        if sample_utterances is not None:
            pulumi.set(__self__, "sample_utterances", sample_utterances)
        if wait_and_continue_specification is not None:
            pulumi.set(__self__, "wait_and_continue_specification", wait_and_continue_specification)

    @_builtins.property
    @pulumi.getter(name="defaultValueSpecification")
    def default_value_specification(self) -> Optional[pulumi.Input['BotSlotDefaultValueSpecificationArgs']]:
        return pulumi.get(self, "default_value_specification")

    @default_value_specification.setter
    def default_value_specification(self, value: Optional[pulumi.Input['BotSlotDefaultValueSpecificationArgs']]):
        pulumi.set(self, "default_value_specification", value)

    @_builtins.property
    @pulumi.getter(name="promptSpecification")
    def prompt_specification(self) -> Optional[pulumi.Input['BotPromptSpecificationArgs']]:
        return pulumi.get(self, "prompt_specification")

    @prompt_specification.setter
    def prompt_specification(self, value: Optional[pulumi.Input['BotPromptSpecificationArgs']]):
        pulumi.set(self, "prompt_specification", value)

    @_builtins.property
    @pulumi.getter(name="sampleUtterances")
    def sample_utterances(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotSampleUtteranceArgs']]]]:
        return pulumi.get(self, "sample_utterances")

    @sample_utterances.setter
    def sample_utterances(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotSampleUtteranceArgs']]]]):
        pulumi.set(self, "sample_utterances", value)

    @_builtins.property
    @pulumi.getter(name="waitAndContinueSpecification")
    def wait_and_continue_specification(self) -> Optional[pulumi.Input['BotWaitAndContinueSpecificationArgs']]:
        return pulumi.get(self, "wait_and_continue_specification")

    @wait_and_continue_specification.setter
    def wait_and_continue_specification(self, value: Optional[pulumi.Input['BotWaitAndContinueSpecificationArgs']]):
        pulumi.set(self, "wait_and_continue_specification", value)


if not MYPY:
    class BotTagArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    BotTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class BotTestBotAliasSettingsSentimentAnalysisSettingsPropertiesArgsDict(TypedDict):
        """
        Specifies whether Amazon Lex will use Amazon Comprehend to detect the sentiment of user utterances.
        """
        detect_sentiment: pulumi.Input[_builtins.bool]
elif False:
    BotTestBotAliasSettingsSentimentAnalysisSettingsPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotTestBotAliasSettingsSentimentAnalysisSettingsPropertiesArgs:
    def __init__(__self__, *,
                 detect_sentiment: pulumi.Input[_builtins.bool]):
        """
        Specifies whether Amazon Lex will use Amazon Comprehend to detect the sentiment of user utterances.
        """
        pulumi.set(__self__, "detect_sentiment", detect_sentiment)

    @_builtins.property
    @pulumi.getter(name="detectSentiment")
    def detect_sentiment(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "detect_sentiment")

    @detect_sentiment.setter
    def detect_sentiment(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "detect_sentiment", value)


if not MYPY:
    class BotTestBotAliasSettingsArgsDict(TypedDict):
        bot_alias_locale_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['BotAliasLocaleSettingsItemArgsDict']]]]
        """
        Specifies settings that are unique to a locale. For example, you can use a different Lambda function depending on the bot's locale.
        """
        conversation_log_settings: NotRequired[pulumi.Input['BotConversationLogSettingsArgsDict']]
        """
        Specifies settings for conversation logs that save audio, text, and metadata information for conversations with your users.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies a description for the test bot alias.
        """
        sentiment_analysis_settings: NotRequired[pulumi.Input['BotTestBotAliasSettingsSentimentAnalysisSettingsPropertiesArgsDict']]
        """
        Specifies whether Amazon Lex will use Amazon Comprehend to detect the sentiment of user utterances.
        """
elif False:
    BotTestBotAliasSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotTestBotAliasSettingsArgs:
    def __init__(__self__, *,
                 bot_alias_locale_settings: Optional[pulumi.Input[Sequence[pulumi.Input['BotAliasLocaleSettingsItemArgs']]]] = None,
                 conversation_log_settings: Optional[pulumi.Input['BotConversationLogSettingsArgs']] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 sentiment_analysis_settings: Optional[pulumi.Input['BotTestBotAliasSettingsSentimentAnalysisSettingsPropertiesArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BotAliasLocaleSettingsItemArgs']]] bot_alias_locale_settings: Specifies settings that are unique to a locale. For example, you can use a different Lambda function depending on the bot's locale.
        :param pulumi.Input['BotConversationLogSettingsArgs'] conversation_log_settings: Specifies settings for conversation logs that save audio, text, and metadata information for conversations with your users.
        :param pulumi.Input[_builtins.str] description: Specifies a description for the test bot alias.
        :param pulumi.Input['BotTestBotAliasSettingsSentimentAnalysisSettingsPropertiesArgs'] sentiment_analysis_settings: Specifies whether Amazon Lex will use Amazon Comprehend to detect the sentiment of user utterances.
        """
        if bot_alias_locale_settings is not None:
            pulumi.set(__self__, "bot_alias_locale_settings", bot_alias_locale_settings)
        if conversation_log_settings is not None:
            pulumi.set(__self__, "conversation_log_settings", conversation_log_settings)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if sentiment_analysis_settings is not None:
            pulumi.set(__self__, "sentiment_analysis_settings", sentiment_analysis_settings)

    @_builtins.property
    @pulumi.getter(name="botAliasLocaleSettings")
    def bot_alias_locale_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotAliasLocaleSettingsItemArgs']]]]:
        """
        Specifies settings that are unique to a locale. For example, you can use a different Lambda function depending on the bot's locale.
        """
        return pulumi.get(self, "bot_alias_locale_settings")

    @bot_alias_locale_settings.setter
    def bot_alias_locale_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotAliasLocaleSettingsItemArgs']]]]):
        pulumi.set(self, "bot_alias_locale_settings", value)

    @_builtins.property
    @pulumi.getter(name="conversationLogSettings")
    def conversation_log_settings(self) -> Optional[pulumi.Input['BotConversationLogSettingsArgs']]:
        """
        Specifies settings for conversation logs that save audio, text, and metadata information for conversations with your users.
        """
        return pulumi.get(self, "conversation_log_settings")

    @conversation_log_settings.setter
    def conversation_log_settings(self, value: Optional[pulumi.Input['BotConversationLogSettingsArgs']]):
        pulumi.set(self, "conversation_log_settings", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies a description for the test bot alias.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="sentimentAnalysisSettings")
    def sentiment_analysis_settings(self) -> Optional[pulumi.Input['BotTestBotAliasSettingsSentimentAnalysisSettingsPropertiesArgs']]:
        """
        Specifies whether Amazon Lex will use Amazon Comprehend to detect the sentiment of user utterances.
        """
        return pulumi.get(self, "sentiment_analysis_settings")

    @sentiment_analysis_settings.setter
    def sentiment_analysis_settings(self, value: Optional[pulumi.Input['BotTestBotAliasSettingsSentimentAnalysisSettingsPropertiesArgs']]):
        pulumi.set(self, "sentiment_analysis_settings", value)


if not MYPY:
    class BotTextInputSpecificationArgsDict(TypedDict):
        start_timeout_ms: pulumi.Input[_builtins.int]
elif False:
    BotTextInputSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotTextInputSpecificationArgs:
    def __init__(__self__, *,
                 start_timeout_ms: pulumi.Input[_builtins.int]):
        pulumi.set(__self__, "start_timeout_ms", start_timeout_ms)

    @_builtins.property
    @pulumi.getter(name="startTimeoutMs")
    def start_timeout_ms(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "start_timeout_ms")

    @start_timeout_ms.setter
    def start_timeout_ms(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "start_timeout_ms", value)


if not MYPY:
    class BotTextLogDestinationArgsDict(TypedDict):
        cloud_watch: pulumi.Input['BotCloudWatchLogGroupLogDestinationArgsDict']
elif False:
    BotTextLogDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotTextLogDestinationArgs:
    def __init__(__self__, *,
                 cloud_watch: pulumi.Input['BotCloudWatchLogGroupLogDestinationArgs']):
        pulumi.set(__self__, "cloud_watch", cloud_watch)

    @_builtins.property
    @pulumi.getter(name="cloudWatch")
    def cloud_watch(self) -> pulumi.Input['BotCloudWatchLogGroupLogDestinationArgs']:
        return pulumi.get(self, "cloud_watch")

    @cloud_watch.setter
    def cloud_watch(self, value: pulumi.Input['BotCloudWatchLogGroupLogDestinationArgs']):
        pulumi.set(self, "cloud_watch", value)


if not MYPY:
    class BotTextLogSettingArgsDict(TypedDict):
        destination: pulumi.Input['BotTextLogDestinationArgsDict']
        enabled: pulumi.Input[_builtins.bool]
elif False:
    BotTextLogSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotTextLogSettingArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input['BotTextLogDestinationArgs'],
                 enabled: pulumi.Input[_builtins.bool]):
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> pulumi.Input['BotTextLogDestinationArgs']:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input['BotTextLogDestinationArgs']):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class BotVersionLocaleDetailsArgsDict(TypedDict):
        """
        The version of a bot used for a bot locale.
        """
        source_bot_version: pulumi.Input[_builtins.str]
elif False:
    BotVersionLocaleDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotVersionLocaleDetailsArgs:
    def __init__(__self__, *,
                 source_bot_version: pulumi.Input[_builtins.str]):
        """
        The version of a bot used for a bot locale.
        """
        pulumi.set(__self__, "source_bot_version", source_bot_version)

    @_builtins.property
    @pulumi.getter(name="sourceBotVersion")
    def source_bot_version(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "source_bot_version")

    @source_bot_version.setter
    def source_bot_version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_bot_version", value)


if not MYPY:
    class BotVersionLocaleSpecificationArgsDict(TypedDict):
        bot_version_locale_details: pulumi.Input['BotVersionLocaleDetailsArgsDict']
        locale_id: pulumi.Input[_builtins.str]
elif False:
    BotVersionLocaleSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotVersionLocaleSpecificationArgs:
    def __init__(__self__, *,
                 bot_version_locale_details: pulumi.Input['BotVersionLocaleDetailsArgs'],
                 locale_id: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "bot_version_locale_details", bot_version_locale_details)
        pulumi.set(__self__, "locale_id", locale_id)

    @_builtins.property
    @pulumi.getter(name="botVersionLocaleDetails")
    def bot_version_locale_details(self) -> pulumi.Input['BotVersionLocaleDetailsArgs']:
        return pulumi.get(self, "bot_version_locale_details")

    @bot_version_locale_details.setter
    def bot_version_locale_details(self, value: pulumi.Input['BotVersionLocaleDetailsArgs']):
        pulumi.set(self, "bot_version_locale_details", value)

    @_builtins.property
    @pulumi.getter(name="localeId")
    def locale_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "locale_id")

    @locale_id.setter
    def locale_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "locale_id", value)


if not MYPY:
    class BotVoiceSettingsArgsDict(TypedDict):
        voice_id: pulumi.Input[_builtins.str]
        """
        The identifier of the Amazon Polly voice to use.
        """
        engine: NotRequired[pulumi.Input['BotVoiceSettingsEngine']]
        """
        Indicates the type of Amazon Polly voice that Amazon Lex should use for voice interaction with the user. For more information, see the [`engine` parameter of the `SynthesizeSpeech` operation](https://docs.aws.amazon.com/polly/latest/dg/API_SynthesizeSpeech.html#polly-SynthesizeSpeech-request-Engine) in the *Amazon Polly developer guide* .

        If you do not specify a value, the default is `standard` .
        """
elif False:
    BotVoiceSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotVoiceSettingsArgs:
    def __init__(__self__, *,
                 voice_id: pulumi.Input[_builtins.str],
                 engine: Optional[pulumi.Input['BotVoiceSettingsEngine']] = None):
        """
        :param pulumi.Input[_builtins.str] voice_id: The identifier of the Amazon Polly voice to use.
        :param pulumi.Input['BotVoiceSettingsEngine'] engine: Indicates the type of Amazon Polly voice that Amazon Lex should use for voice interaction with the user. For more information, see the [`engine` parameter of the `SynthesizeSpeech` operation](https://docs.aws.amazon.com/polly/latest/dg/API_SynthesizeSpeech.html#polly-SynthesizeSpeech-request-Engine) in the *Amazon Polly developer guide* .
               
               If you do not specify a value, the default is `standard` .
        """
        pulumi.set(__self__, "voice_id", voice_id)
        if engine is not None:
            pulumi.set(__self__, "engine", engine)

    @_builtins.property
    @pulumi.getter(name="voiceId")
    def voice_id(self) -> pulumi.Input[_builtins.str]:
        """
        The identifier of the Amazon Polly voice to use.
        """
        return pulumi.get(self, "voice_id")

    @voice_id.setter
    def voice_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "voice_id", value)

    @_builtins.property
    @pulumi.getter
    def engine(self) -> Optional[pulumi.Input['BotVoiceSettingsEngine']]:
        """
        Indicates the type of Amazon Polly voice that Amazon Lex should use for voice interaction with the user. For more information, see the [`engine` parameter of the `SynthesizeSpeech` operation](https://docs.aws.amazon.com/polly/latest/dg/API_SynthesizeSpeech.html#polly-SynthesizeSpeech-request-Engine) in the *Amazon Polly developer guide* .

        If you do not specify a value, the default is `standard` .
        """
        return pulumi.get(self, "engine")

    @engine.setter
    def engine(self, value: Optional[pulumi.Input['BotVoiceSettingsEngine']]):
        pulumi.set(self, "engine", value)


if not MYPY:
    class BotWaitAndContinueSpecificationArgsDict(TypedDict):
        continue_response: pulumi.Input['BotResponseSpecificationArgsDict']
        """
        The response that Amazon Lex sends to indicate that the bot is ready to continue the conversation.
        """
        waiting_response: pulumi.Input['BotResponseSpecificationArgsDict']
        """
        The response that Amazon Lex sends to indicate that the bot is waiting for the conversation to continue.
        """
        is_active: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether the bot will wait for a user to respond. When this field is false, wait and continue responses for a slot aren't used. If the `IsActive` field isn't specified, the default is true.
        """
        still_waiting_response: NotRequired[pulumi.Input['BotStillWaitingResponseSpecificationArgsDict']]
        """
        A response that Amazon Lex sends periodically to the user to indicate that the bot is still waiting for input from the user.
        """
elif False:
    BotWaitAndContinueSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BotWaitAndContinueSpecificationArgs:
    def __init__(__self__, *,
                 continue_response: pulumi.Input['BotResponseSpecificationArgs'],
                 waiting_response: pulumi.Input['BotResponseSpecificationArgs'],
                 is_active: Optional[pulumi.Input[_builtins.bool]] = None,
                 still_waiting_response: Optional[pulumi.Input['BotStillWaitingResponseSpecificationArgs']] = None):
        """
        :param pulumi.Input['BotResponseSpecificationArgs'] continue_response: The response that Amazon Lex sends to indicate that the bot is ready to continue the conversation.
        :param pulumi.Input['BotResponseSpecificationArgs'] waiting_response: The response that Amazon Lex sends to indicate that the bot is waiting for the conversation to continue.
        :param pulumi.Input[_builtins.bool] is_active: Specifies whether the bot will wait for a user to respond. When this field is false, wait and continue responses for a slot aren't used. If the `IsActive` field isn't specified, the default is true.
        :param pulumi.Input['BotStillWaitingResponseSpecificationArgs'] still_waiting_response: A response that Amazon Lex sends periodically to the user to indicate that the bot is still waiting for input from the user.
        """
        pulumi.set(__self__, "continue_response", continue_response)
        pulumi.set(__self__, "waiting_response", waiting_response)
        if is_active is not None:
            pulumi.set(__self__, "is_active", is_active)
        if still_waiting_response is not None:
            pulumi.set(__self__, "still_waiting_response", still_waiting_response)

    @_builtins.property
    @pulumi.getter(name="continueResponse")
    def continue_response(self) -> pulumi.Input['BotResponseSpecificationArgs']:
        """
        The response that Amazon Lex sends to indicate that the bot is ready to continue the conversation.
        """
        return pulumi.get(self, "continue_response")

    @continue_response.setter
    def continue_response(self, value: pulumi.Input['BotResponseSpecificationArgs']):
        pulumi.set(self, "continue_response", value)

    @_builtins.property
    @pulumi.getter(name="waitingResponse")
    def waiting_response(self) -> pulumi.Input['BotResponseSpecificationArgs']:
        """
        The response that Amazon Lex sends to indicate that the bot is waiting for the conversation to continue.
        """
        return pulumi.get(self, "waiting_response")

    @waiting_response.setter
    def waiting_response(self, value: pulumi.Input['BotResponseSpecificationArgs']):
        pulumi.set(self, "waiting_response", value)

    @_builtins.property
    @pulumi.getter(name="isActive")
    def is_active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether the bot will wait for a user to respond. When this field is false, wait and continue responses for a slot aren't used. If the `IsActive` field isn't specified, the default is true.
        """
        return pulumi.get(self, "is_active")

    @is_active.setter
    def is_active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_active", value)

    @_builtins.property
    @pulumi.getter(name="stillWaitingResponse")
    def still_waiting_response(self) -> Optional[pulumi.Input['BotStillWaitingResponseSpecificationArgs']]:
        """
        A response that Amazon Lex sends periodically to the user to indicate that the bot is still waiting for input from the user.
        """
        return pulumi.get(self, "still_waiting_response")

    @still_waiting_response.setter
    def still_waiting_response(self, value: Optional[pulumi.Input['BotStillWaitingResponseSpecificationArgs']]):
        pulumi.set(self, "still_waiting_response", value)


if not MYPY:
    class DataPrivacyPropertiesArgsDict(TypedDict):
        """
        By default, data stored by Amazon Lex is encrypted. The `DataPrivacy` structure provides settings that determine how Amazon Lex handles special cases of securing the data for your bot.
        """
        child_directed: pulumi.Input[_builtins.bool]
        """
        For each Amazon Lex bot created with the Amazon Lex Model Building Service, you must specify whether your use of Amazon Lex is related to a website, program, or other application that is directed or targeted, in whole or in part, to children under age 13 and subject to the Children's Online Privacy Protection Act (COPPA) by specifying `true` or `false` in the `childDirected` field. By specifying `true` in the `childDirected` field, you confirm that your use of Amazon Lex *is* related to a website, program, or other application that is directed or targeted, in whole or in part, to children under age 13 and subject to COPPA. By specifying `false` in the `childDirected` field, you confirm that your use of Amazon Lex *is not* related to a website, program, or other application that is directed or targeted, in whole or in part, to children under age 13 and subject to COPPA. You may not specify a default value for the `childDirected` field that does not accurately reflect whether your use of Amazon Lex is related to a website, program, or other application that is directed or targeted, in whole or in part, to children under age 13 and subject to COPPA. If your use of Amazon Lex relates to a website, program, or other application that is directed in whole or in part, to children under age 13, you must obtain any required verifiable parental consent under COPPA. For information regarding the use of Amazon Lex in connection with websites, programs, or other applications that are directed or targeted, in whole or in part, to children under age 13, see the [Amazon Lex FAQ](https://docs.aws.amazon.com/lex/faqs#data-security) .
        """
elif False:
    DataPrivacyPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataPrivacyPropertiesArgs:
    def __init__(__self__, *,
                 child_directed: pulumi.Input[_builtins.bool]):
        """
        By default, data stored by Amazon Lex is encrypted. The `DataPrivacy` structure provides settings that determine how Amazon Lex handles special cases of securing the data for your bot.
        :param pulumi.Input[_builtins.bool] child_directed: For each Amazon Lex bot created with the Amazon Lex Model Building Service, you must specify whether your use of Amazon Lex is related to a website, program, or other application that is directed or targeted, in whole or in part, to children under age 13 and subject to the Children's Online Privacy Protection Act (COPPA) by specifying `true` or `false` in the `childDirected` field. By specifying `true` in the `childDirected` field, you confirm that your use of Amazon Lex *is* related to a website, program, or other application that is directed or targeted, in whole or in part, to children under age 13 and subject to COPPA. By specifying `false` in the `childDirected` field, you confirm that your use of Amazon Lex *is not* related to a website, program, or other application that is directed or targeted, in whole or in part, to children under age 13 and subject to COPPA. You may not specify a default value for the `childDirected` field that does not accurately reflect whether your use of Amazon Lex is related to a website, program, or other application that is directed or targeted, in whole or in part, to children under age 13 and subject to COPPA. If your use of Amazon Lex relates to a website, program, or other application that is directed in whole or in part, to children under age 13, you must obtain any required verifiable parental consent under COPPA. For information regarding the use of Amazon Lex in connection with websites, programs, or other applications that are directed or targeted, in whole or in part, to children under age 13, see the [Amazon Lex FAQ](https://docs.aws.amazon.com/lex/faqs#data-security) .
        """
        pulumi.set(__self__, "child_directed", child_directed)

    @_builtins.property
    @pulumi.getter(name="childDirected")
    def child_directed(self) -> pulumi.Input[_builtins.bool]:
        """
        For each Amazon Lex bot created with the Amazon Lex Model Building Service, you must specify whether your use of Amazon Lex is related to a website, program, or other application that is directed or targeted, in whole or in part, to children under age 13 and subject to the Children's Online Privacy Protection Act (COPPA) by specifying `true` or `false` in the `childDirected` field. By specifying `true` in the `childDirected` field, you confirm that your use of Amazon Lex *is* related to a website, program, or other application that is directed or targeted, in whole or in part, to children under age 13 and subject to COPPA. By specifying `false` in the `childDirected` field, you confirm that your use of Amazon Lex *is not* related to a website, program, or other application that is directed or targeted, in whole or in part, to children under age 13 and subject to COPPA. You may not specify a default value for the `childDirected` field that does not accurately reflect whether your use of Amazon Lex is related to a website, program, or other application that is directed or targeted, in whole or in part, to children under age 13 and subject to COPPA. If your use of Amazon Lex relates to a website, program, or other application that is directed in whole or in part, to children under age 13, you must obtain any required verifiable parental consent under COPPA. For information regarding the use of Amazon Lex in connection with websites, programs, or other applications that are directed or targeted, in whole or in part, to children under age 13, see the [Amazon Lex FAQ](https://docs.aws.amazon.com/lex/faqs#data-security) .
        """
        return pulumi.get(self, "child_directed")

    @child_directed.setter
    def child_directed(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "child_directed", value)


if not MYPY:
    class ErrorLogSettingsPropertiesArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
elif False:
    ErrorLogSettingsPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ErrorLogSettingsPropertiesArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool]):
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ResourcePolicyPolicyArgsDict(TypedDict):
        """
        A resource policy to add to the resource. The policy is a JSON structure following the IAM syntax that contains one or more statements that define the policy.
        """
        pass
elif False:
    ResourcePolicyPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourcePolicyPolicyArgs:
    def __init__(__self__):
        """
        A resource policy to add to the resource. The policy is a JSON structure following the IAM syntax that contains one or more statements that define the policy.
        """
        pass


if not MYPY:
    class SentimentAnalysisSettingsPropertiesArgsDict(TypedDict):
        """
        Determines whether Amazon Lex will use Amazon Comprehend to detect the sentiment of user utterances.
        """
        detect_sentiment: pulumi.Input[_builtins.bool]
        """
        Enable to call Amazon Comprehend for Sentiment natively within Lex
        """
elif False:
    SentimentAnalysisSettingsPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SentimentAnalysisSettingsPropertiesArgs:
    def __init__(__self__, *,
                 detect_sentiment: pulumi.Input[_builtins.bool]):
        """
        Determines whether Amazon Lex will use Amazon Comprehend to detect the sentiment of user utterances.
        :param pulumi.Input[_builtins.bool] detect_sentiment: Enable to call Amazon Comprehend for Sentiment natively within Lex
        """
        pulumi.set(__self__, "detect_sentiment", detect_sentiment)

    @_builtins.property
    @pulumi.getter(name="detectSentiment")
    def detect_sentiment(self) -> pulumi.Input[_builtins.bool]:
        """
        Enable to call Amazon Comprehend for Sentiment natively within Lex
        """
        return pulumi.get(self, "detect_sentiment")

    @detect_sentiment.setter
    def detect_sentiment(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "detect_sentiment", value)


