# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from ._enums import *

__all__ = [
    'BotAdvancedRecognitionSettingArgs',
    'BotAliasAudioLogDestinationArgs',
    'BotAliasAudioLogSettingArgs',
    'BotAliasCloudWatchLogGroupLogDestinationArgs',
    'BotAliasCodeHookSpecificationArgs',
    'BotAliasConversationLogSettingsArgs',
    'BotAliasLambdaCodeHookArgs',
    'BotAliasLocaleSettingsItemArgs',
    'BotAliasLocaleSettingsArgs',
    'BotAliasS3BucketLogDestinationArgs',
    'BotAliasTagArgs',
    'BotAliasTextLogDestinationArgs',
    'BotAliasTextLogSettingArgs',
    'BotAudioLogDestinationArgs',
    'BotAudioLogSettingArgs',
    'BotButtonArgs',
    'BotCloudWatchLogGroupLogDestinationArgs',
    'BotConditionalBranchArgs',
    'BotConditionalSpecificationArgs',
    'BotConditionArgs',
    'BotConversationLogSettingsArgs',
    'BotCustomPayloadArgs',
    'BotCustomVocabularyItemArgs',
    'BotCustomVocabularyArgs',
    'BotDefaultConditionalBranchArgs',
    'BotDialogActionArgs',
    'BotDialogCodeHookInvocationSettingArgs',
    'BotDialogCodeHookSettingArgs',
    'BotDialogStateArgs',
    'BotElicitationCodeHookInvocationSettingArgs',
    'BotExternalSourceSettingArgs',
    'BotFulfillmentCodeHookSettingArgs',
    'BotFulfillmentStartResponseSpecificationArgs',
    'BotFulfillmentUpdateResponseSpecificationArgs',
    'BotFulfillmentUpdatesSpecificationArgs',
    'BotGrammarSlotTypeSettingArgs',
    'BotGrammarSlotTypeSourceArgs',
    'BotImageResponseCardArgs',
    'BotInitialResponseSettingArgs',
    'BotInputContextArgs',
    'BotIntentClosingSettingArgs',
    'BotIntentConfirmationSettingArgs',
    'BotIntentOverrideArgs',
    'BotIntentArgs',
    'BotKendraConfigurationArgs',
    'BotLocaleArgs',
    'BotMessageGroupArgs',
    'BotMessageArgs',
    'BotMultipleValuesSettingArgs',
    'BotObfuscationSettingArgs',
    'BotOutputContextArgs',
    'BotPlainTextMessageArgs',
    'BotPostDialogCodeHookInvocationSpecificationArgs',
    'BotPostFulfillmentStatusSpecificationArgs',
    'BotPromptSpecificationArgs',
    'BotResponseSpecificationArgs',
    'BotS3BucketLogDestinationArgs',
    'BotS3LocationArgs',
    'BotSampleUtteranceArgs',
    'BotSampleValueArgs',
    'BotSessionAttributeArgs',
    'BotSlotCaptureSettingArgs',
    'BotSlotDefaultValueSpecificationArgs',
    'BotSlotDefaultValueArgs',
    'BotSlotPriorityArgs',
    'BotSlotTypeValueArgs',
    'BotSlotTypeArgs',
    'BotSlotValueElicitationSettingArgs',
    'BotSlotValueOverrideMapArgs',
    'BotSlotValueOverrideArgs',
    'BotSlotValueRegexFilterArgs',
    'BotSlotValueSelectionSettingArgs',
    'BotSlotValueArgs',
    'BotSlotArgs',
    'BotSsmlMessageArgs',
    'BotStillWaitingResponseSpecificationArgs',
    'BotTagArgs',
    'BotTestBotAliasSettingsSentimentAnalysisSettingsPropertiesArgs',
    'BotTestBotAliasSettingsArgs',
    'BotTextLogDestinationArgs',
    'BotTextLogSettingArgs',
    'BotVersionLocaleDetailsArgs',
    'BotVersionLocaleSpecificationArgs',
    'BotVoiceSettingsArgs',
    'BotWaitAndContinueSpecificationArgs',
    'DataPrivacyPropertiesArgs',
    'ResourcePolicyPolicyArgs',
    'SentimentAnalysisSettingsPropertiesArgs',
]

@pulumi.input_type
class BotAdvancedRecognitionSettingArgs:
    def __init__(__self__, *,
                 audio_recognition_strategy: Optional[pulumi.Input['BotAudioRecognitionStrategy']] = None):
        """
        Provides settings that enable advanced recognition settings for slot values.
        """
        if audio_recognition_strategy is not None:
            pulumi.set(__self__, "audio_recognition_strategy", audio_recognition_strategy)

    @property
    @pulumi.getter(name="audioRecognitionStrategy")
    def audio_recognition_strategy(self) -> Optional[pulumi.Input['BotAudioRecognitionStrategy']]:
        return pulumi.get(self, "audio_recognition_strategy")

    @audio_recognition_strategy.setter
    def audio_recognition_strategy(self, value: Optional[pulumi.Input['BotAudioRecognitionStrategy']]):
        pulumi.set(self, "audio_recognition_strategy", value)


@pulumi.input_type
class BotAliasAudioLogDestinationArgs:
    def __init__(__self__, *,
                 s3_bucket: pulumi.Input['BotAliasS3BucketLogDestinationArgs']):
        """
        The location of audio log files collected when conversation logging is enabled for a bot.
        """
        pulumi.set(__self__, "s3_bucket", s3_bucket)

    @property
    @pulumi.getter(name="s3Bucket")
    def s3_bucket(self) -> pulumi.Input['BotAliasS3BucketLogDestinationArgs']:
        return pulumi.get(self, "s3_bucket")

    @s3_bucket.setter
    def s3_bucket(self, value: pulumi.Input['BotAliasS3BucketLogDestinationArgs']):
        pulumi.set(self, "s3_bucket", value)


@pulumi.input_type
class BotAliasAudioLogSettingArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input['BotAliasAudioLogDestinationArgs'],
                 enabled: pulumi.Input[bool]):
        """
        Settings for logging audio of conversations between Amazon Lex and a user. You specify whether to log audio and the Amazon S3 bucket where the audio file is stored.
        """
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input['BotAliasAudioLogDestinationArgs']:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input['BotAliasAudioLogDestinationArgs']):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class BotAliasCloudWatchLogGroupLogDestinationArgs:
    def __init__(__self__, *,
                 cloud_watch_log_group_arn: pulumi.Input[str],
                 log_prefix: pulumi.Input[str]):
        """
        :param pulumi.Input[str] cloud_watch_log_group_arn: A string used to identify the groupArn for the Cloudwatch Log Group
        :param pulumi.Input[str] log_prefix: A string containing the value for the Log Prefix
        """
        pulumi.set(__self__, "cloud_watch_log_group_arn", cloud_watch_log_group_arn)
        pulumi.set(__self__, "log_prefix", log_prefix)

    @property
    @pulumi.getter(name="cloudWatchLogGroupArn")
    def cloud_watch_log_group_arn(self) -> pulumi.Input[str]:
        """
        A string used to identify the groupArn for the Cloudwatch Log Group
        """
        return pulumi.get(self, "cloud_watch_log_group_arn")

    @cloud_watch_log_group_arn.setter
    def cloud_watch_log_group_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "cloud_watch_log_group_arn", value)

    @property
    @pulumi.getter(name="logPrefix")
    def log_prefix(self) -> pulumi.Input[str]:
        """
        A string containing the value for the Log Prefix
        """
        return pulumi.get(self, "log_prefix")

    @log_prefix.setter
    def log_prefix(self, value: pulumi.Input[str]):
        pulumi.set(self, "log_prefix", value)


@pulumi.input_type
class BotAliasCodeHookSpecificationArgs:
    def __init__(__self__, *,
                 lambda_code_hook: pulumi.Input['BotAliasLambdaCodeHookArgs']):
        """
        Contains information about code hooks that Amazon Lex calls during a conversation.
        """
        pulumi.set(__self__, "lambda_code_hook", lambda_code_hook)

    @property
    @pulumi.getter(name="lambdaCodeHook")
    def lambda_code_hook(self) -> pulumi.Input['BotAliasLambdaCodeHookArgs']:
        return pulumi.get(self, "lambda_code_hook")

    @lambda_code_hook.setter
    def lambda_code_hook(self, value: pulumi.Input['BotAliasLambdaCodeHookArgs']):
        pulumi.set(self, "lambda_code_hook", value)


@pulumi.input_type
class BotAliasConversationLogSettingsArgs:
    def __init__(__self__, *,
                 audio_log_settings: Optional[pulumi.Input[Sequence[pulumi.Input['BotAliasAudioLogSettingArgs']]]] = None,
                 text_log_settings: Optional[pulumi.Input[Sequence[pulumi.Input['BotAliasTextLogSettingArgs']]]] = None):
        """
        Contains information about code hooks that Amazon Lex calls during a conversation.
        """
        if audio_log_settings is not None:
            pulumi.set(__self__, "audio_log_settings", audio_log_settings)
        if text_log_settings is not None:
            pulumi.set(__self__, "text_log_settings", text_log_settings)

    @property
    @pulumi.getter(name="audioLogSettings")
    def audio_log_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotAliasAudioLogSettingArgs']]]]:
        return pulumi.get(self, "audio_log_settings")

    @audio_log_settings.setter
    def audio_log_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotAliasAudioLogSettingArgs']]]]):
        pulumi.set(self, "audio_log_settings", value)

    @property
    @pulumi.getter(name="textLogSettings")
    def text_log_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotAliasTextLogSettingArgs']]]]:
        return pulumi.get(self, "text_log_settings")

    @text_log_settings.setter
    def text_log_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotAliasTextLogSettingArgs']]]]):
        pulumi.set(self, "text_log_settings", value)


@pulumi.input_type
class BotAliasLambdaCodeHookArgs:
    def __init__(__self__, *,
                 code_hook_interface_version: pulumi.Input[str],
                 lambda_arn: pulumi.Input[str]):
        """
        Contains information about code hooks that Amazon Lex calls during a conversation.
        :param pulumi.Input[str] code_hook_interface_version: The version of the request-response that you want Amazon Lex to use to invoke your Lambda function.
        :param pulumi.Input[str] lambda_arn: The Amazon Resource Name (ARN) of the Lambda function.
        """
        pulumi.set(__self__, "code_hook_interface_version", code_hook_interface_version)
        pulumi.set(__self__, "lambda_arn", lambda_arn)

    @property
    @pulumi.getter(name="codeHookInterfaceVersion")
    def code_hook_interface_version(self) -> pulumi.Input[str]:
        """
        The version of the request-response that you want Amazon Lex to use to invoke your Lambda function.
        """
        return pulumi.get(self, "code_hook_interface_version")

    @code_hook_interface_version.setter
    def code_hook_interface_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "code_hook_interface_version", value)

    @property
    @pulumi.getter(name="lambdaArn")
    def lambda_arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the Lambda function.
        """
        return pulumi.get(self, "lambda_arn")

    @lambda_arn.setter
    def lambda_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "lambda_arn", value)


@pulumi.input_type
class BotAliasLocaleSettingsItemArgs:
    def __init__(__self__, *,
                 bot_alias_locale_setting: pulumi.Input['BotAliasLocaleSettingsArgs'],
                 locale_id: pulumi.Input[str]):
        """
        A locale setting in alias
        :param pulumi.Input[str] locale_id: A string used to identify the locale
        """
        pulumi.set(__self__, "bot_alias_locale_setting", bot_alias_locale_setting)
        pulumi.set(__self__, "locale_id", locale_id)

    @property
    @pulumi.getter(name="botAliasLocaleSetting")
    def bot_alias_locale_setting(self) -> pulumi.Input['BotAliasLocaleSettingsArgs']:
        return pulumi.get(self, "bot_alias_locale_setting")

    @bot_alias_locale_setting.setter
    def bot_alias_locale_setting(self, value: pulumi.Input['BotAliasLocaleSettingsArgs']):
        pulumi.set(self, "bot_alias_locale_setting", value)

    @property
    @pulumi.getter(name="localeId")
    def locale_id(self) -> pulumi.Input[str]:
        """
        A string used to identify the locale
        """
        return pulumi.get(self, "locale_id")

    @locale_id.setter
    def locale_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "locale_id", value)


@pulumi.input_type
class BotAliasLocaleSettingsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 code_hook_specification: Optional[pulumi.Input['BotAliasCodeHookSpecificationArgs']] = None):
        """
        You can use this parameter to specify a specific Lambda function to run different functions in different locales.
        :param pulumi.Input[bool] enabled: Whether the Lambda code hook is enabled
        """
        pulumi.set(__self__, "enabled", enabled)
        if code_hook_specification is not None:
            pulumi.set(__self__, "code_hook_specification", code_hook_specification)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether the Lambda code hook is enabled
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="codeHookSpecification")
    def code_hook_specification(self) -> Optional[pulumi.Input['BotAliasCodeHookSpecificationArgs']]:
        return pulumi.get(self, "code_hook_specification")

    @code_hook_specification.setter
    def code_hook_specification(self, value: Optional[pulumi.Input['BotAliasCodeHookSpecificationArgs']]):
        pulumi.set(self, "code_hook_specification", value)


@pulumi.input_type
class BotAliasS3BucketLogDestinationArgs:
    def __init__(__self__, *,
                 log_prefix: pulumi.Input[str],
                 s3_bucket_arn: pulumi.Input[str],
                 kms_key_arn: Optional[pulumi.Input[str]] = None):
        """
        Specifies an Amazon S3 bucket for logging audio conversations
        :param pulumi.Input[str] log_prefix: The Amazon S3 key of the deployment package.
        :param pulumi.Input[str] s3_bucket_arn: The Amazon Resource Name (ARN) of an Amazon S3 bucket where audio log files are stored.
        :param pulumi.Input[str] kms_key_arn: The Amazon Resource Name (ARN) of an AWS Key Management Service (KMS) key for encrypting audio log files stored in an S3 bucket.
        """
        pulumi.set(__self__, "log_prefix", log_prefix)
        pulumi.set(__self__, "s3_bucket_arn", s3_bucket_arn)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @property
    @pulumi.getter(name="logPrefix")
    def log_prefix(self) -> pulumi.Input[str]:
        """
        The Amazon S3 key of the deployment package.
        """
        return pulumi.get(self, "log_prefix")

    @log_prefix.setter
    def log_prefix(self, value: pulumi.Input[str]):
        pulumi.set(self, "log_prefix", value)

    @property
    @pulumi.getter(name="s3BucketArn")
    def s3_bucket_arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of an Amazon S3 bucket where audio log files are stored.
        """
        return pulumi.get(self, "s3_bucket_arn")

    @s3_bucket_arn.setter
    def s3_bucket_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_bucket_arn", value)

    @property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon Resource Name (ARN) of an AWS Key Management Service (KMS) key for encrypting audio log files stored in an S3 bucket.
        """
        return pulumi.get(self, "kms_key_arn")

    @kms_key_arn.setter
    def kms_key_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_arn", value)


@pulumi.input_type
class BotAliasTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        A label for tagging Lex resources
        :param pulumi.Input[str] key: A string used to identify this tag
        :param pulumi.Input[str] value: A string containing the value for the tag
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        A string used to identify this tag
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        A string containing the value for the tag
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class BotAliasTextLogDestinationArgs:
    def __init__(__self__, *,
                 cloud_watch: pulumi.Input['BotAliasCloudWatchLogGroupLogDestinationArgs']):
        """
        Defines the Amazon CloudWatch Logs destination log group for conversation text logs.
        """
        pulumi.set(__self__, "cloud_watch", cloud_watch)

    @property
    @pulumi.getter(name="cloudWatch")
    def cloud_watch(self) -> pulumi.Input['BotAliasCloudWatchLogGroupLogDestinationArgs']:
        return pulumi.get(self, "cloud_watch")

    @cloud_watch.setter
    def cloud_watch(self, value: pulumi.Input['BotAliasCloudWatchLogGroupLogDestinationArgs']):
        pulumi.set(self, "cloud_watch", value)


@pulumi.input_type
class BotAliasTextLogSettingArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input['BotAliasTextLogDestinationArgs'],
                 enabled: pulumi.Input[bool]):
        """
        Contains information about code hooks that Amazon Lex calls during a conversation.
        """
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input['BotAliasTextLogDestinationArgs']:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input['BotAliasTextLogDestinationArgs']):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class BotAudioLogDestinationArgs:
    def __init__(__self__, *,
                 s3_bucket: pulumi.Input['BotS3BucketLogDestinationArgs']):
        """
        The location of audio log files collected when conversation logging is enabled for a bot.
        """
        pulumi.set(__self__, "s3_bucket", s3_bucket)

    @property
    @pulumi.getter(name="s3Bucket")
    def s3_bucket(self) -> pulumi.Input['BotS3BucketLogDestinationArgs']:
        return pulumi.get(self, "s3_bucket")

    @s3_bucket.setter
    def s3_bucket(self, value: pulumi.Input['BotS3BucketLogDestinationArgs']):
        pulumi.set(self, "s3_bucket", value)


@pulumi.input_type
class BotAudioLogSettingArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input['BotAudioLogDestinationArgs'],
                 enabled: pulumi.Input[bool]):
        """
        Settings for logging audio of conversations between Amazon Lex and a user. You specify whether to log audio and the Amazon S3 bucket where the audio file is stored.
        """
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input['BotAudioLogDestinationArgs']:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input['BotAudioLogDestinationArgs']):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class BotButtonArgs:
    def __init__(__self__, *,
                 text: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        A button to use on a response card used to gather slot values from a user.
        :param pulumi.Input[str] text: The text that appears on the button.
        :param pulumi.Input[str] value: The value returned to Amazon Lex when the user chooses this button.
        """
        pulumi.set(__self__, "text", text)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def text(self) -> pulumi.Input[str]:
        """
        The text that appears on the button.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input[str]):
        pulumi.set(self, "text", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value returned to Amazon Lex when the user chooses this button.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class BotCloudWatchLogGroupLogDestinationArgs:
    def __init__(__self__, *,
                 cloud_watch_log_group_arn: pulumi.Input[str],
                 log_prefix: pulumi.Input[str]):
        """
        :param pulumi.Input[str] cloud_watch_log_group_arn: A string used to identify the groupArn for the Cloudwatch Log Group
        :param pulumi.Input[str] log_prefix: A string containing the value for the Log Prefix
        """
        pulumi.set(__self__, "cloud_watch_log_group_arn", cloud_watch_log_group_arn)
        pulumi.set(__self__, "log_prefix", log_prefix)

    @property
    @pulumi.getter(name="cloudWatchLogGroupArn")
    def cloud_watch_log_group_arn(self) -> pulumi.Input[str]:
        """
        A string used to identify the groupArn for the Cloudwatch Log Group
        """
        return pulumi.get(self, "cloud_watch_log_group_arn")

    @cloud_watch_log_group_arn.setter
    def cloud_watch_log_group_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "cloud_watch_log_group_arn", value)

    @property
    @pulumi.getter(name="logPrefix")
    def log_prefix(self) -> pulumi.Input[str]:
        """
        A string containing the value for the Log Prefix
        """
        return pulumi.get(self, "log_prefix")

    @log_prefix.setter
    def log_prefix(self, value: pulumi.Input[str]):
        pulumi.set(self, "log_prefix", value)


@pulumi.input_type
class BotConditionalBranchArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input['BotConditionArgs'],
                 name: pulumi.Input[str],
                 next_step: pulumi.Input['BotDialogStateArgs'],
                 response: Optional[pulumi.Input['BotResponseSpecificationArgs']] = None):
        """
        A set of actions that Amazon Lex should run if the condition is matched.
        :param pulumi.Input['BotConditionArgs'] condition: Contains the expression to evaluate. If the condition is true, the branch's actions are taken.
        :param pulumi.Input[str] name: The name of the branch.
        :param pulumi.Input['BotDialogStateArgs'] next_step: The next step in the conversation.
        :param pulumi.Input['BotResponseSpecificationArgs'] response: Specifies a list of message groups that Amazon Lex uses to respond the user input.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "next_step", next_step)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input['BotConditionArgs']:
        """
        Contains the expression to evaluate. If the condition is true, the branch's actions are taken.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input['BotConditionArgs']):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the branch.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="nextStep")
    def next_step(self) -> pulumi.Input['BotDialogStateArgs']:
        """
        The next step in the conversation.
        """
        return pulumi.get(self, "next_step")

    @next_step.setter
    def next_step(self, value: pulumi.Input['BotDialogStateArgs']):
        pulumi.set(self, "next_step", value)

    @property
    @pulumi.getter
    def response(self) -> Optional[pulumi.Input['BotResponseSpecificationArgs']]:
        """
        Specifies a list of message groups that Amazon Lex uses to respond the user input.
        """
        return pulumi.get(self, "response")

    @response.setter
    def response(self, value: Optional[pulumi.Input['BotResponseSpecificationArgs']]):
        pulumi.set(self, "response", value)


@pulumi.input_type
class BotConditionalSpecificationArgs:
    def __init__(__self__, *,
                 conditional_branches: pulumi.Input[Sequence[pulumi.Input['BotConditionalBranchArgs']]],
                 default_branch: pulumi.Input['BotDefaultConditionalBranchArgs'],
                 is_active: pulumi.Input[bool]):
        """
        Provides a list of conditional branches. Branches are evaluated in the order that they are entered in the list. The first branch with a condition that evaluates to true is executed. The last branch in the list is the default branch. The default branch should not have any condition expression. The default branch is executed if no other branch has a matching condition.
        :param pulumi.Input[Sequence[pulumi.Input['BotConditionalBranchArgs']]] conditional_branches: A list of conditional branches. A conditional branch is made up of a condition, a response and a next step. The response and next step are executed when the condition is true.
        :param pulumi.Input['BotDefaultConditionalBranchArgs'] default_branch: The conditional branch that should be followed when the conditions for other branches are not satisfied. A conditional branch is made up of a condition, a response and a next step.
        :param pulumi.Input[bool] is_active: Determines whether a conditional branch is active. When active is false, the conditions are not evaluated.
        """
        pulumi.set(__self__, "conditional_branches", conditional_branches)
        pulumi.set(__self__, "default_branch", default_branch)
        pulumi.set(__self__, "is_active", is_active)

    @property
    @pulumi.getter(name="conditionalBranches")
    def conditional_branches(self) -> pulumi.Input[Sequence[pulumi.Input['BotConditionalBranchArgs']]]:
        """
        A list of conditional branches. A conditional branch is made up of a condition, a response and a next step. The response and next step are executed when the condition is true.
        """
        return pulumi.get(self, "conditional_branches")

    @conditional_branches.setter
    def conditional_branches(self, value: pulumi.Input[Sequence[pulumi.Input['BotConditionalBranchArgs']]]):
        pulumi.set(self, "conditional_branches", value)

    @property
    @pulumi.getter(name="defaultBranch")
    def default_branch(self) -> pulumi.Input['BotDefaultConditionalBranchArgs']:
        """
        The conditional branch that should be followed when the conditions for other branches are not satisfied. A conditional branch is made up of a condition, a response and a next step.
        """
        return pulumi.get(self, "default_branch")

    @default_branch.setter
    def default_branch(self, value: pulumi.Input['BotDefaultConditionalBranchArgs']):
        pulumi.set(self, "default_branch", value)

    @property
    @pulumi.getter(name="isActive")
    def is_active(self) -> pulumi.Input[bool]:
        """
        Determines whether a conditional branch is active. When active is false, the conditions are not evaluated.
        """
        return pulumi.get(self, "is_active")

    @is_active.setter
    def is_active(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_active", value)


@pulumi.input_type
class BotConditionArgs:
    def __init__(__self__, *,
                 expression_string: pulumi.Input[str]):
        """
        Provides an expression that evaluates to true or false.
        :param pulumi.Input[str] expression_string: The expression string that is evaluated.
        """
        pulumi.set(__self__, "expression_string", expression_string)

    @property
    @pulumi.getter(name="expressionString")
    def expression_string(self) -> pulumi.Input[str]:
        """
        The expression string that is evaluated.
        """
        return pulumi.get(self, "expression_string")

    @expression_string.setter
    def expression_string(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression_string", value)


@pulumi.input_type
class BotConversationLogSettingsArgs:
    def __init__(__self__, *,
                 audio_log_settings: Optional[pulumi.Input[Sequence[pulumi.Input['BotAudioLogSettingArgs']]]] = None,
                 text_log_settings: Optional[pulumi.Input[Sequence[pulumi.Input['BotTextLogSettingArgs']]]] = None):
        """
        Contains information about code hooks that Amazon Lex calls during a conversation.
        """
        if audio_log_settings is not None:
            pulumi.set(__self__, "audio_log_settings", audio_log_settings)
        if text_log_settings is not None:
            pulumi.set(__self__, "text_log_settings", text_log_settings)

    @property
    @pulumi.getter(name="audioLogSettings")
    def audio_log_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotAudioLogSettingArgs']]]]:
        return pulumi.get(self, "audio_log_settings")

    @audio_log_settings.setter
    def audio_log_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotAudioLogSettingArgs']]]]):
        pulumi.set(self, "audio_log_settings", value)

    @property
    @pulumi.getter(name="textLogSettings")
    def text_log_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotTextLogSettingArgs']]]]:
        return pulumi.get(self, "text_log_settings")

    @text_log_settings.setter
    def text_log_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotTextLogSettingArgs']]]]):
        pulumi.set(self, "text_log_settings", value)


@pulumi.input_type
class BotCustomPayloadArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        """
        A message in a custom format defined by the client application.
        :param pulumi.Input[str] value: The string that is sent to your application.
        """
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The string that is sent to your application.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class BotCustomVocabularyItemArgs:
    def __init__(__self__, *,
                 phrase: pulumi.Input[str],
                 display_as: Optional[pulumi.Input[str]] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        """
        A custom vocabulary item that contains the phrase to recognize and a weight to give the boost.
        :param pulumi.Input[str] phrase: Phrase that should be recognized.
        :param pulumi.Input[str] display_as: Defines how you want your phrase to look in your transcription output.
        :param pulumi.Input[int] weight: The degree to which the phrase recognition is boosted. The weight 0 means that no boosting will be applied and the entry will only be used for performing replacements using the displayAs field.
        """
        pulumi.set(__self__, "phrase", phrase)
        if display_as is not None:
            pulumi.set(__self__, "display_as", display_as)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def phrase(self) -> pulumi.Input[str]:
        """
        Phrase that should be recognized.
        """
        return pulumi.get(self, "phrase")

    @phrase.setter
    def phrase(self, value: pulumi.Input[str]):
        pulumi.set(self, "phrase", value)

    @property
    @pulumi.getter(name="displayAs")
    def display_as(self) -> Optional[pulumi.Input[str]]:
        """
        Defines how you want your phrase to look in your transcription output.
        """
        return pulumi.get(self, "display_as")

    @display_as.setter
    def display_as(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_as", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        """
        The degree to which the phrase recognition is boosted. The weight 0 means that no boosting will be applied and the entry will only be used for performing replacements using the displayAs field.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class BotCustomVocabularyArgs:
    def __init__(__self__, *,
                 custom_vocabulary_items: pulumi.Input[Sequence[pulumi.Input['BotCustomVocabularyItemArgs']]]):
        """
        A custom vocabulary is a list of specific phrases that you want Amazon Lex V2 to recognize in the audio input.
        """
        pulumi.set(__self__, "custom_vocabulary_items", custom_vocabulary_items)

    @property
    @pulumi.getter(name="customVocabularyItems")
    def custom_vocabulary_items(self) -> pulumi.Input[Sequence[pulumi.Input['BotCustomVocabularyItemArgs']]]:
        return pulumi.get(self, "custom_vocabulary_items")

    @custom_vocabulary_items.setter
    def custom_vocabulary_items(self, value: pulumi.Input[Sequence[pulumi.Input['BotCustomVocabularyItemArgs']]]):
        pulumi.set(self, "custom_vocabulary_items", value)


@pulumi.input_type
class BotDefaultConditionalBranchArgs:
    def __init__(__self__, *,
                 next_step: Optional[pulumi.Input['BotDialogStateArgs']] = None,
                 response: Optional[pulumi.Input['BotResponseSpecificationArgs']] = None):
        """
        A set of actions that Amazon Lex should run if none of the other conditions are met.
        :param pulumi.Input['BotDialogStateArgs'] next_step: The next step in the conversation.
        :param pulumi.Input['BotResponseSpecificationArgs'] response: Specifies a list of message groups that Amazon Lex uses to respond the user input.
        """
        if next_step is not None:
            pulumi.set(__self__, "next_step", next_step)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @property
    @pulumi.getter(name="nextStep")
    def next_step(self) -> Optional[pulumi.Input['BotDialogStateArgs']]:
        """
        The next step in the conversation.
        """
        return pulumi.get(self, "next_step")

    @next_step.setter
    def next_step(self, value: Optional[pulumi.Input['BotDialogStateArgs']]):
        pulumi.set(self, "next_step", value)

    @property
    @pulumi.getter
    def response(self) -> Optional[pulumi.Input['BotResponseSpecificationArgs']]:
        """
        Specifies a list of message groups that Amazon Lex uses to respond the user input.
        """
        return pulumi.get(self, "response")

    @response.setter
    def response(self, value: Optional[pulumi.Input['BotResponseSpecificationArgs']]):
        pulumi.set(self, "response", value)


@pulumi.input_type
class BotDialogActionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['BotDialogActionType'],
                 slot_to_elicit: Optional[pulumi.Input[str]] = None,
                 suppress_next_message: Optional[pulumi.Input[bool]] = None):
        """
        Defines the action that the bot executes at runtime when the conversation reaches this step.
        :param pulumi.Input['BotDialogActionType'] type: The action that the bot should execute.
        :param pulumi.Input[str] slot_to_elicit: If the dialog action is ElicitSlot, defines the slot to elicit from the user.
        :param pulumi.Input[bool] suppress_next_message: When true the next message for the intent is not used.
        """
        pulumi.set(__self__, "type", type)
        if slot_to_elicit is not None:
            pulumi.set(__self__, "slot_to_elicit", slot_to_elicit)
        if suppress_next_message is not None:
            pulumi.set(__self__, "suppress_next_message", suppress_next_message)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input['BotDialogActionType']:
        """
        The action that the bot should execute.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['BotDialogActionType']):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="slotToElicit")
    def slot_to_elicit(self) -> Optional[pulumi.Input[str]]:
        """
        If the dialog action is ElicitSlot, defines the slot to elicit from the user.
        """
        return pulumi.get(self, "slot_to_elicit")

    @slot_to_elicit.setter
    def slot_to_elicit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "slot_to_elicit", value)

    @property
    @pulumi.getter(name="suppressNextMessage")
    def suppress_next_message(self) -> Optional[pulumi.Input[bool]]:
        """
        When true the next message for the intent is not used.
        """
        return pulumi.get(self, "suppress_next_message")

    @suppress_next_message.setter
    def suppress_next_message(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "suppress_next_message", value)


@pulumi.input_type
class BotDialogCodeHookInvocationSettingArgs:
    def __init__(__self__, *,
                 enable_code_hook_invocation: pulumi.Input[bool],
                 is_active: pulumi.Input[bool],
                 post_code_hook_specification: pulumi.Input['BotPostDialogCodeHookInvocationSpecificationArgs'],
                 invocation_label: Optional[pulumi.Input[str]] = None):
        """
        Settings that specify the dialog code hook that is called by Amazon Lex at a step of the conversation.
        :param pulumi.Input[bool] enable_code_hook_invocation: Indicates whether a Lambda function should be invoked for the dialog.
        :param pulumi.Input[bool] is_active: Determines whether a dialog code hook is used when the intent is activated.
        :param pulumi.Input['BotPostDialogCodeHookInvocationSpecificationArgs'] post_code_hook_specification: Contains the responses and actions that Amazon Lex takes after the Lambda function is complete.
        :param pulumi.Input[str] invocation_label: A label that indicates the dialog step from which the dialog code hook is happening.
        """
        pulumi.set(__self__, "enable_code_hook_invocation", enable_code_hook_invocation)
        pulumi.set(__self__, "is_active", is_active)
        pulumi.set(__self__, "post_code_hook_specification", post_code_hook_specification)
        if invocation_label is not None:
            pulumi.set(__self__, "invocation_label", invocation_label)

    @property
    @pulumi.getter(name="enableCodeHookInvocation")
    def enable_code_hook_invocation(self) -> pulumi.Input[bool]:
        """
        Indicates whether a Lambda function should be invoked for the dialog.
        """
        return pulumi.get(self, "enable_code_hook_invocation")

    @enable_code_hook_invocation.setter
    def enable_code_hook_invocation(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enable_code_hook_invocation", value)

    @property
    @pulumi.getter(name="isActive")
    def is_active(self) -> pulumi.Input[bool]:
        """
        Determines whether a dialog code hook is used when the intent is activated.
        """
        return pulumi.get(self, "is_active")

    @is_active.setter
    def is_active(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_active", value)

    @property
    @pulumi.getter(name="postCodeHookSpecification")
    def post_code_hook_specification(self) -> pulumi.Input['BotPostDialogCodeHookInvocationSpecificationArgs']:
        """
        Contains the responses and actions that Amazon Lex takes after the Lambda function is complete.
        """
        return pulumi.get(self, "post_code_hook_specification")

    @post_code_hook_specification.setter
    def post_code_hook_specification(self, value: pulumi.Input['BotPostDialogCodeHookInvocationSpecificationArgs']):
        pulumi.set(self, "post_code_hook_specification", value)

    @property
    @pulumi.getter(name="invocationLabel")
    def invocation_label(self) -> Optional[pulumi.Input[str]]:
        """
        A label that indicates the dialog step from which the dialog code hook is happening.
        """
        return pulumi.get(self, "invocation_label")

    @invocation_label.setter
    def invocation_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invocation_label", value)


@pulumi.input_type
class BotDialogCodeHookSettingArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool]):
        """
        Settings that determine the Lambda function that Amazon Lex uses for processing user responses.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class BotDialogStateArgs:
    def __init__(__self__, *,
                 dialog_action: Optional[pulumi.Input['BotDialogActionArgs']] = None,
                 intent: Optional[pulumi.Input['BotIntentOverrideArgs']] = None,
                 session_attributes: Optional[pulumi.Input[Sequence[pulumi.Input['BotSessionAttributeArgs']]]] = None):
        """
        The current state of the conversation with the user.
        :param pulumi.Input['BotDialogActionArgs'] dialog_action: Defines the action that the bot executes at runtime when the conversation reaches this step.
        :param pulumi.Input['BotIntentOverrideArgs'] intent: Override settings to configure the intent state.
        :param pulumi.Input[Sequence[pulumi.Input['BotSessionAttributeArgs']]] session_attributes: List of session attributes to be applied when the conversation reaches this step.
        """
        if dialog_action is not None:
            pulumi.set(__self__, "dialog_action", dialog_action)
        if intent is not None:
            pulumi.set(__self__, "intent", intent)
        if session_attributes is not None:
            pulumi.set(__self__, "session_attributes", session_attributes)

    @property
    @pulumi.getter(name="dialogAction")
    def dialog_action(self) -> Optional[pulumi.Input['BotDialogActionArgs']]:
        """
        Defines the action that the bot executes at runtime when the conversation reaches this step.
        """
        return pulumi.get(self, "dialog_action")

    @dialog_action.setter
    def dialog_action(self, value: Optional[pulumi.Input['BotDialogActionArgs']]):
        pulumi.set(self, "dialog_action", value)

    @property
    @pulumi.getter
    def intent(self) -> Optional[pulumi.Input['BotIntentOverrideArgs']]:
        """
        Override settings to configure the intent state.
        """
        return pulumi.get(self, "intent")

    @intent.setter
    def intent(self, value: Optional[pulumi.Input['BotIntentOverrideArgs']]):
        pulumi.set(self, "intent", value)

    @property
    @pulumi.getter(name="sessionAttributes")
    def session_attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotSessionAttributeArgs']]]]:
        """
        List of session attributes to be applied when the conversation reaches this step.
        """
        return pulumi.get(self, "session_attributes")

    @session_attributes.setter
    def session_attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotSessionAttributeArgs']]]]):
        pulumi.set(self, "session_attributes", value)


@pulumi.input_type
class BotElicitationCodeHookInvocationSettingArgs:
    def __init__(__self__, *,
                 enable_code_hook_invocation: pulumi.Input[bool],
                 invocation_label: Optional[pulumi.Input[str]] = None):
        """
        Settings that specify the dialog code hook that is called by Amazon Lex between eliciting slot values.
        :param pulumi.Input[bool] enable_code_hook_invocation: Indicates whether a Lambda function should be invoked for the dialog.
        :param pulumi.Input[str] invocation_label: A label that indicates the dialog step from which the dialog code hook is happening.
        """
        pulumi.set(__self__, "enable_code_hook_invocation", enable_code_hook_invocation)
        if invocation_label is not None:
            pulumi.set(__self__, "invocation_label", invocation_label)

    @property
    @pulumi.getter(name="enableCodeHookInvocation")
    def enable_code_hook_invocation(self) -> pulumi.Input[bool]:
        """
        Indicates whether a Lambda function should be invoked for the dialog.
        """
        return pulumi.get(self, "enable_code_hook_invocation")

    @enable_code_hook_invocation.setter
    def enable_code_hook_invocation(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enable_code_hook_invocation", value)

    @property
    @pulumi.getter(name="invocationLabel")
    def invocation_label(self) -> Optional[pulumi.Input[str]]:
        """
        A label that indicates the dialog step from which the dialog code hook is happening.
        """
        return pulumi.get(self, "invocation_label")

    @invocation_label.setter
    def invocation_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invocation_label", value)


@pulumi.input_type
class BotExternalSourceSettingArgs:
    def __init__(__self__, *,
                 grammar_slot_type_setting: Optional[pulumi.Input['BotGrammarSlotTypeSettingArgs']] = None):
        """
        Provides information about the external source of the slot type's definition.
        """
        if grammar_slot_type_setting is not None:
            pulumi.set(__self__, "grammar_slot_type_setting", grammar_slot_type_setting)

    @property
    @pulumi.getter(name="grammarSlotTypeSetting")
    def grammar_slot_type_setting(self) -> Optional[pulumi.Input['BotGrammarSlotTypeSettingArgs']]:
        return pulumi.get(self, "grammar_slot_type_setting")

    @grammar_slot_type_setting.setter
    def grammar_slot_type_setting(self, value: Optional[pulumi.Input['BotGrammarSlotTypeSettingArgs']]):
        pulumi.set(self, "grammar_slot_type_setting", value)


@pulumi.input_type
class BotFulfillmentCodeHookSettingArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 fulfillment_updates_specification: Optional[pulumi.Input['BotFulfillmentUpdatesSpecificationArgs']] = None,
                 is_active: Optional[pulumi.Input[bool]] = None,
                 post_fulfillment_status_specification: Optional[pulumi.Input['BotPostFulfillmentStatusSpecificationArgs']] = None):
        """
        Settings that determine if a Lambda function should be invoked to fulfill a specific intent.
        :param pulumi.Input[bool] is_active: Determines whether the fulfillment code hook is used. When active is false, the code hook doesn't run.
        """
        pulumi.set(__self__, "enabled", enabled)
        if fulfillment_updates_specification is not None:
            pulumi.set(__self__, "fulfillment_updates_specification", fulfillment_updates_specification)
        if is_active is not None:
            pulumi.set(__self__, "is_active", is_active)
        if post_fulfillment_status_specification is not None:
            pulumi.set(__self__, "post_fulfillment_status_specification", post_fulfillment_status_specification)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="fulfillmentUpdatesSpecification")
    def fulfillment_updates_specification(self) -> Optional[pulumi.Input['BotFulfillmentUpdatesSpecificationArgs']]:
        return pulumi.get(self, "fulfillment_updates_specification")

    @fulfillment_updates_specification.setter
    def fulfillment_updates_specification(self, value: Optional[pulumi.Input['BotFulfillmentUpdatesSpecificationArgs']]):
        pulumi.set(self, "fulfillment_updates_specification", value)

    @property
    @pulumi.getter(name="isActive")
    def is_active(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether the fulfillment code hook is used. When active is false, the code hook doesn't run.
        """
        return pulumi.get(self, "is_active")

    @is_active.setter
    def is_active(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_active", value)

    @property
    @pulumi.getter(name="postFulfillmentStatusSpecification")
    def post_fulfillment_status_specification(self) -> Optional[pulumi.Input['BotPostFulfillmentStatusSpecificationArgs']]:
        return pulumi.get(self, "post_fulfillment_status_specification")

    @post_fulfillment_status_specification.setter
    def post_fulfillment_status_specification(self, value: Optional[pulumi.Input['BotPostFulfillmentStatusSpecificationArgs']]):
        pulumi.set(self, "post_fulfillment_status_specification", value)


@pulumi.input_type
class BotFulfillmentStartResponseSpecificationArgs:
    def __init__(__self__, *,
                 delay_in_seconds: pulumi.Input[int],
                 message_groups: pulumi.Input[Sequence[pulumi.Input['BotMessageGroupArgs']]],
                 allow_interrupt: Optional[pulumi.Input[bool]] = None):
        """
        Provides settings for a message that is sent to the user when a fulfillment Lambda function starts running.
        :param pulumi.Input[int] delay_in_seconds: The delay between when the Lambda fulfillment function starts running and the start message is played. If the Lambda function returns before the delay is over, the start message isn't played.
        :param pulumi.Input[bool] allow_interrupt: Determines whether the user can interrupt the start message while it is playing.
        """
        pulumi.set(__self__, "delay_in_seconds", delay_in_seconds)
        pulumi.set(__self__, "message_groups", message_groups)
        if allow_interrupt is not None:
            pulumi.set(__self__, "allow_interrupt", allow_interrupt)

    @property
    @pulumi.getter(name="delayInSeconds")
    def delay_in_seconds(self) -> pulumi.Input[int]:
        """
        The delay between when the Lambda fulfillment function starts running and the start message is played. If the Lambda function returns before the delay is over, the start message isn't played.
        """
        return pulumi.get(self, "delay_in_seconds")

    @delay_in_seconds.setter
    def delay_in_seconds(self, value: pulumi.Input[int]):
        pulumi.set(self, "delay_in_seconds", value)

    @property
    @pulumi.getter(name="messageGroups")
    def message_groups(self) -> pulumi.Input[Sequence[pulumi.Input['BotMessageGroupArgs']]]:
        return pulumi.get(self, "message_groups")

    @message_groups.setter
    def message_groups(self, value: pulumi.Input[Sequence[pulumi.Input['BotMessageGroupArgs']]]):
        pulumi.set(self, "message_groups", value)

    @property
    @pulumi.getter(name="allowInterrupt")
    def allow_interrupt(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether the user can interrupt the start message while it is playing.
        """
        return pulumi.get(self, "allow_interrupt")

    @allow_interrupt.setter
    def allow_interrupt(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_interrupt", value)


@pulumi.input_type
class BotFulfillmentUpdateResponseSpecificationArgs:
    def __init__(__self__, *,
                 frequency_in_seconds: pulumi.Input[int],
                 message_groups: pulumi.Input[Sequence[pulumi.Input['BotMessageGroupArgs']]],
                 allow_interrupt: Optional[pulumi.Input[bool]] = None):
        """
        Provides settings for a message that is sent periodically to the user while a fulfillment Lambda function is running.
        :param pulumi.Input[int] frequency_in_seconds: The frequency that a message is sent to the user. When the period ends, Amazon Lex chooses a message from the message groups and plays it to the user. If the fulfillment Lambda returns before the first period ends, an update message is not played to the user.
        :param pulumi.Input[bool] allow_interrupt: Determines whether the user can interrupt an update message while it is playing.
        """
        pulumi.set(__self__, "frequency_in_seconds", frequency_in_seconds)
        pulumi.set(__self__, "message_groups", message_groups)
        if allow_interrupt is not None:
            pulumi.set(__self__, "allow_interrupt", allow_interrupt)

    @property
    @pulumi.getter(name="frequencyInSeconds")
    def frequency_in_seconds(self) -> pulumi.Input[int]:
        """
        The frequency that a message is sent to the user. When the period ends, Amazon Lex chooses a message from the message groups and plays it to the user. If the fulfillment Lambda returns before the first period ends, an update message is not played to the user.
        """
        return pulumi.get(self, "frequency_in_seconds")

    @frequency_in_seconds.setter
    def frequency_in_seconds(self, value: pulumi.Input[int]):
        pulumi.set(self, "frequency_in_seconds", value)

    @property
    @pulumi.getter(name="messageGroups")
    def message_groups(self) -> pulumi.Input[Sequence[pulumi.Input['BotMessageGroupArgs']]]:
        return pulumi.get(self, "message_groups")

    @message_groups.setter
    def message_groups(self, value: pulumi.Input[Sequence[pulumi.Input['BotMessageGroupArgs']]]):
        pulumi.set(self, "message_groups", value)

    @property
    @pulumi.getter(name="allowInterrupt")
    def allow_interrupt(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether the user can interrupt an update message while it is playing.
        """
        return pulumi.get(self, "allow_interrupt")

    @allow_interrupt.setter
    def allow_interrupt(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_interrupt", value)


@pulumi.input_type
class BotFulfillmentUpdatesSpecificationArgs:
    def __init__(__self__, *,
                 active: pulumi.Input[bool],
                 start_response: Optional[pulumi.Input['BotFulfillmentStartResponseSpecificationArgs']] = None,
                 timeout_in_seconds: Optional[pulumi.Input[int]] = None,
                 update_response: Optional[pulumi.Input['BotFulfillmentUpdateResponseSpecificationArgs']] = None):
        """
        Provides information for updating the user on the progress of fulfilling an intent.
        :param pulumi.Input[bool] active: Determines whether fulfillment updates are sent to the user. When this field is true, updates are sent.
        :param pulumi.Input[int] timeout_in_seconds: The length of time that the fulfillment Lambda function should run before it times out.
        """
        pulumi.set(__self__, "active", active)
        if start_response is not None:
            pulumi.set(__self__, "start_response", start_response)
        if timeout_in_seconds is not None:
            pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)
        if update_response is not None:
            pulumi.set(__self__, "update_response", update_response)

    @property
    @pulumi.getter
    def active(self) -> pulumi.Input[bool]:
        """
        Determines whether fulfillment updates are sent to the user. When this field is true, updates are sent.
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: pulumi.Input[bool]):
        pulumi.set(self, "active", value)

    @property
    @pulumi.getter(name="startResponse")
    def start_response(self) -> Optional[pulumi.Input['BotFulfillmentStartResponseSpecificationArgs']]:
        return pulumi.get(self, "start_response")

    @start_response.setter
    def start_response(self, value: Optional[pulumi.Input['BotFulfillmentStartResponseSpecificationArgs']]):
        pulumi.set(self, "start_response", value)

    @property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The length of time that the fulfillment Lambda function should run before it times out.
        """
        return pulumi.get(self, "timeout_in_seconds")

    @timeout_in_seconds.setter
    def timeout_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_in_seconds", value)

    @property
    @pulumi.getter(name="updateResponse")
    def update_response(self) -> Optional[pulumi.Input['BotFulfillmentUpdateResponseSpecificationArgs']]:
        return pulumi.get(self, "update_response")

    @update_response.setter
    def update_response(self, value: Optional[pulumi.Input['BotFulfillmentUpdateResponseSpecificationArgs']]):
        pulumi.set(self, "update_response", value)


@pulumi.input_type
class BotGrammarSlotTypeSettingArgs:
    def __init__(__self__, *,
                 source: Optional[pulumi.Input['BotGrammarSlotTypeSourceArgs']] = None):
        """
        Settings required for a slot type based on a grammar that you provide.
        """
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input['BotGrammarSlotTypeSourceArgs']]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input['BotGrammarSlotTypeSourceArgs']]):
        pulumi.set(self, "source", value)


@pulumi.input_type
class BotGrammarSlotTypeSourceArgs:
    def __init__(__self__, *,
                 s3_bucket_name: pulumi.Input[str],
                 s3_object_key: pulumi.Input[str],
                 kms_key_arn: Optional[pulumi.Input[str]] = None):
        """
        Describes the Amazon S3 bucket name and location for the grammar that is the source for the slot type.
        :param pulumi.Input[str] s3_bucket_name: The name of the S3 bucket that contains the grammar source.
        :param pulumi.Input[str] s3_object_key: The path to the grammar in the S3 bucket.
        :param pulumi.Input[str] kms_key_arn: The Amazon KMS key required to decrypt the contents of the grammar, if any.
        """
        pulumi.set(__self__, "s3_bucket_name", s3_bucket_name)
        pulumi.set(__self__, "s3_object_key", s3_object_key)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @property
    @pulumi.getter(name="s3BucketName")
    def s3_bucket_name(self) -> pulumi.Input[str]:
        """
        The name of the S3 bucket that contains the grammar source.
        """
        return pulumi.get(self, "s3_bucket_name")

    @s3_bucket_name.setter
    def s3_bucket_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_bucket_name", value)

    @property
    @pulumi.getter(name="s3ObjectKey")
    def s3_object_key(self) -> pulumi.Input[str]:
        """
        The path to the grammar in the S3 bucket.
        """
        return pulumi.get(self, "s3_object_key")

    @s3_object_key.setter
    def s3_object_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_object_key", value)

    @property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon KMS key required to decrypt the contents of the grammar, if any.
        """
        return pulumi.get(self, "kms_key_arn")

    @kms_key_arn.setter
    def kms_key_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_arn", value)


@pulumi.input_type
class BotImageResponseCardArgs:
    def __init__(__self__, *,
                 title: pulumi.Input[str],
                 buttons: Optional[pulumi.Input[Sequence[pulumi.Input['BotButtonArgs']]]] = None,
                 image_url: Optional[pulumi.Input[str]] = None,
                 subtitle: Optional[pulumi.Input[str]] = None):
        """
        A message that defines a response card that the client application can show to the user.
        :param pulumi.Input[str] title: The title to display on the response card.
        :param pulumi.Input[Sequence[pulumi.Input['BotButtonArgs']]] buttons: A list of buttons that should be displayed on the response card.
        :param pulumi.Input[str] image_url: The URL of an image to display on the response card.
        :param pulumi.Input[str] subtitle: The subtitle to display on the response card.
        """
        pulumi.set(__self__, "title", title)
        if buttons is not None:
            pulumi.set(__self__, "buttons", buttons)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if subtitle is not None:
            pulumi.set(__self__, "subtitle", subtitle)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        """
        The title to display on the response card.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def buttons(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotButtonArgs']]]]:
        """
        A list of buttons that should be displayed on the response card.
        """
        return pulumi.get(self, "buttons")

    @buttons.setter
    def buttons(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotButtonArgs']]]]):
        pulumi.set(self, "buttons", value)

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of an image to display on the response card.
        """
        return pulumi.get(self, "image_url")

    @image_url.setter
    def image_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_url", value)

    @property
    @pulumi.getter
    def subtitle(self) -> Optional[pulumi.Input[str]]:
        """
        The subtitle to display on the response card.
        """
        return pulumi.get(self, "subtitle")

    @subtitle.setter
    def subtitle(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subtitle", value)


@pulumi.input_type
class BotInitialResponseSettingArgs:
    def __init__(__self__, *,
                 code_hook: Optional[pulumi.Input['BotDialogCodeHookInvocationSettingArgs']] = None,
                 conditional: Optional[pulumi.Input['BotConditionalSpecificationArgs']] = None,
                 initial_response: Optional[pulumi.Input['BotResponseSpecificationArgs']] = None,
                 next_step: Optional[pulumi.Input['BotDialogStateArgs']] = None):
        """
        Configuration setting for a response sent to the user before Amazon Lex starts eliciting slots.
        :param pulumi.Input['BotDialogCodeHookInvocationSettingArgs'] code_hook: Settings that specify the dialog code hook that is called by Amazon Lex at a step of the conversation.
        :param pulumi.Input['BotConditionalSpecificationArgs'] conditional: Provides a list of conditional branches. Branches are evaluated in the order that they are entered in the list. The first branch with a condition that evaluates to true is executed. The last branch in the list is the default branch. The default branch should not have any condition expression. The default branch is executed if no other branch has a matching condition.
        :param pulumi.Input['BotResponseSpecificationArgs'] initial_response: Specifies a list of message groups that Amazon Lex uses to respond the user input.
        :param pulumi.Input['BotDialogStateArgs'] next_step: The next step in the conversation.
        """
        if code_hook is not None:
            pulumi.set(__self__, "code_hook", code_hook)
        if conditional is not None:
            pulumi.set(__self__, "conditional", conditional)
        if initial_response is not None:
            pulumi.set(__self__, "initial_response", initial_response)
        if next_step is not None:
            pulumi.set(__self__, "next_step", next_step)

    @property
    @pulumi.getter(name="codeHook")
    def code_hook(self) -> Optional[pulumi.Input['BotDialogCodeHookInvocationSettingArgs']]:
        """
        Settings that specify the dialog code hook that is called by Amazon Lex at a step of the conversation.
        """
        return pulumi.get(self, "code_hook")

    @code_hook.setter
    def code_hook(self, value: Optional[pulumi.Input['BotDialogCodeHookInvocationSettingArgs']]):
        pulumi.set(self, "code_hook", value)

    @property
    @pulumi.getter
    def conditional(self) -> Optional[pulumi.Input['BotConditionalSpecificationArgs']]:
        """
        Provides a list of conditional branches. Branches are evaluated in the order that they are entered in the list. The first branch with a condition that evaluates to true is executed. The last branch in the list is the default branch. The default branch should not have any condition expression. The default branch is executed if no other branch has a matching condition.
        """
        return pulumi.get(self, "conditional")

    @conditional.setter
    def conditional(self, value: Optional[pulumi.Input['BotConditionalSpecificationArgs']]):
        pulumi.set(self, "conditional", value)

    @property
    @pulumi.getter(name="initialResponse")
    def initial_response(self) -> Optional[pulumi.Input['BotResponseSpecificationArgs']]:
        """
        Specifies a list of message groups that Amazon Lex uses to respond the user input.
        """
        return pulumi.get(self, "initial_response")

    @initial_response.setter
    def initial_response(self, value: Optional[pulumi.Input['BotResponseSpecificationArgs']]):
        pulumi.set(self, "initial_response", value)

    @property
    @pulumi.getter(name="nextStep")
    def next_step(self) -> Optional[pulumi.Input['BotDialogStateArgs']]:
        """
        The next step in the conversation.
        """
        return pulumi.get(self, "next_step")

    @next_step.setter
    def next_step(self, value: Optional[pulumi.Input['BotDialogStateArgs']]):
        pulumi.set(self, "next_step", value)


@pulumi.input_type
class BotInputContextArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        InputContext specified for the intent.
        :param pulumi.Input[str] name: The name of the context.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the context.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class BotIntentClosingSettingArgs:
    def __init__(__self__, *,
                 closing_response: Optional[pulumi.Input['BotResponseSpecificationArgs']] = None,
                 conditional: Optional[pulumi.Input['BotConditionalSpecificationArgs']] = None,
                 is_active: Optional[pulumi.Input[bool]] = None,
                 next_step: Optional[pulumi.Input['BotDialogStateArgs']] = None):
        """
        Provides a statement the Amazon Lex conveys to the user when the intent is successfully fulfilled.
        :param pulumi.Input['BotResponseSpecificationArgs'] closing_response: The response that Amazon Lex sends to the user when the intent is complete.
        :param pulumi.Input['BotConditionalSpecificationArgs'] conditional: A list of conditional branches associated with the intent's closing response. These branches are executed when the nextStep attribute is set to EvalutateConditional.
        :param pulumi.Input[bool] is_active: Specifies whether an intent's closing response is used. When this field is false, the closing response isn't sent to the user. If the active field isn't specified, the default is true.
        :param pulumi.Input['BotDialogStateArgs'] next_step: Specifies the next step that the bot executes after playing the intent's closing response.
        """
        if closing_response is not None:
            pulumi.set(__self__, "closing_response", closing_response)
        if conditional is not None:
            pulumi.set(__self__, "conditional", conditional)
        if is_active is not None:
            pulumi.set(__self__, "is_active", is_active)
        if next_step is not None:
            pulumi.set(__self__, "next_step", next_step)

    @property
    @pulumi.getter(name="closingResponse")
    def closing_response(self) -> Optional[pulumi.Input['BotResponseSpecificationArgs']]:
        """
        The response that Amazon Lex sends to the user when the intent is complete.
        """
        return pulumi.get(self, "closing_response")

    @closing_response.setter
    def closing_response(self, value: Optional[pulumi.Input['BotResponseSpecificationArgs']]):
        pulumi.set(self, "closing_response", value)

    @property
    @pulumi.getter
    def conditional(self) -> Optional[pulumi.Input['BotConditionalSpecificationArgs']]:
        """
        A list of conditional branches associated with the intent's closing response. These branches are executed when the nextStep attribute is set to EvalutateConditional.
        """
        return pulumi.get(self, "conditional")

    @conditional.setter
    def conditional(self, value: Optional[pulumi.Input['BotConditionalSpecificationArgs']]):
        pulumi.set(self, "conditional", value)

    @property
    @pulumi.getter(name="isActive")
    def is_active(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether an intent's closing response is used. When this field is false, the closing response isn't sent to the user. If the active field isn't specified, the default is true.
        """
        return pulumi.get(self, "is_active")

    @is_active.setter
    def is_active(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_active", value)

    @property
    @pulumi.getter(name="nextStep")
    def next_step(self) -> Optional[pulumi.Input['BotDialogStateArgs']]:
        """
        Specifies the next step that the bot executes after playing the intent's closing response.
        """
        return pulumi.get(self, "next_step")

    @next_step.setter
    def next_step(self, value: Optional[pulumi.Input['BotDialogStateArgs']]):
        pulumi.set(self, "next_step", value)


@pulumi.input_type
class BotIntentConfirmationSettingArgs:
    def __init__(__self__, *,
                 prompt_specification: pulumi.Input['BotPromptSpecificationArgs'],
                 code_hook: Optional[pulumi.Input['BotDialogCodeHookInvocationSettingArgs']] = None,
                 confirmation_conditional: Optional[pulumi.Input['BotConditionalSpecificationArgs']] = None,
                 confirmation_next_step: Optional[pulumi.Input['BotDialogStateArgs']] = None,
                 confirmation_response: Optional[pulumi.Input['BotResponseSpecificationArgs']] = None,
                 declination_conditional: Optional[pulumi.Input['BotConditionalSpecificationArgs']] = None,
                 declination_next_step: Optional[pulumi.Input['BotDialogStateArgs']] = None,
                 declination_response: Optional[pulumi.Input['BotResponseSpecificationArgs']] = None,
                 elicitation_code_hook: Optional[pulumi.Input['BotElicitationCodeHookInvocationSettingArgs']] = None,
                 failure_conditional: Optional[pulumi.Input['BotConditionalSpecificationArgs']] = None,
                 failure_next_step: Optional[pulumi.Input['BotDialogStateArgs']] = None,
                 failure_response: Optional[pulumi.Input['BotResponseSpecificationArgs']] = None,
                 is_active: Optional[pulumi.Input[bool]] = None):
        """
        Provides a prompt for making sure that the user is ready for the intent to be fulfilled.
        :param pulumi.Input['BotPromptSpecificationArgs'] prompt_specification: Prompts the user to confirm the intent. This question should have a yes or no answer.
        :param pulumi.Input['BotDialogCodeHookInvocationSettingArgs'] code_hook: The DialogCodeHookInvocationSetting object associated with intent's confirmation step. The dialog code hook is triggered based on these invocation settings when the confirmation next step or declination next step or failure next step is InvokeDialogCodeHook.
        :param pulumi.Input['BotConditionalSpecificationArgs'] confirmation_conditional: A list of conditional branches to evaluate after the intent is closed.
        :param pulumi.Input['BotDialogStateArgs'] confirmation_next_step: Specifies the next step that the bot executes when the customer confirms the intent.
        :param pulumi.Input['BotResponseSpecificationArgs'] confirmation_response: Specifies a list of message groups that Amazon Lex uses to respond the user input.
        :param pulumi.Input['BotConditionalSpecificationArgs'] declination_conditional: A list of conditional branches to evaluate after the intent is declined.
        :param pulumi.Input['BotDialogStateArgs'] declination_next_step: Specifies the next step that the bot executes when the customer declines the intent.
        :param pulumi.Input['BotResponseSpecificationArgs'] declination_response: When the user answers "no" to the question defined in promptSpecification, Amazon Lex responds with this response to acknowledge that the intent was canceled.
        :param pulumi.Input['BotElicitationCodeHookInvocationSettingArgs'] elicitation_code_hook: The DialogCodeHookInvocationSetting used when the code hook is invoked during confirmation prompt retries.
        :param pulumi.Input['BotConditionalSpecificationArgs'] failure_conditional: Provides a list of conditional branches. Branches are evaluated in the order that they are entered in the list. The first branch with a condition that evaluates to true is executed. The last branch in the list is the default branch. The default branch should not have any condition expression. The default branch is executed if no other branch has a matching condition.
        :param pulumi.Input['BotDialogStateArgs'] failure_next_step: The next step to take in the conversation if the confirmation step fails.
        :param pulumi.Input['BotResponseSpecificationArgs'] failure_response: Specifies a list of message groups that Amazon Lex uses to respond the user input.
        :param pulumi.Input[bool] is_active: Specifies whether the intent's confirmation is sent to the user. When this field is false, confirmation and declination responses aren't sent. If the active field isn't specified, the default is true.
        """
        pulumi.set(__self__, "prompt_specification", prompt_specification)
        if code_hook is not None:
            pulumi.set(__self__, "code_hook", code_hook)
        if confirmation_conditional is not None:
            pulumi.set(__self__, "confirmation_conditional", confirmation_conditional)
        if confirmation_next_step is not None:
            pulumi.set(__self__, "confirmation_next_step", confirmation_next_step)
        if confirmation_response is not None:
            pulumi.set(__self__, "confirmation_response", confirmation_response)
        if declination_conditional is not None:
            pulumi.set(__self__, "declination_conditional", declination_conditional)
        if declination_next_step is not None:
            pulumi.set(__self__, "declination_next_step", declination_next_step)
        if declination_response is not None:
            pulumi.set(__self__, "declination_response", declination_response)
        if elicitation_code_hook is not None:
            pulumi.set(__self__, "elicitation_code_hook", elicitation_code_hook)
        if failure_conditional is not None:
            pulumi.set(__self__, "failure_conditional", failure_conditional)
        if failure_next_step is not None:
            pulumi.set(__self__, "failure_next_step", failure_next_step)
        if failure_response is not None:
            pulumi.set(__self__, "failure_response", failure_response)
        if is_active is not None:
            pulumi.set(__self__, "is_active", is_active)

    @property
    @pulumi.getter(name="promptSpecification")
    def prompt_specification(self) -> pulumi.Input['BotPromptSpecificationArgs']:
        """
        Prompts the user to confirm the intent. This question should have a yes or no answer.
        """
        return pulumi.get(self, "prompt_specification")

    @prompt_specification.setter
    def prompt_specification(self, value: pulumi.Input['BotPromptSpecificationArgs']):
        pulumi.set(self, "prompt_specification", value)

    @property
    @pulumi.getter(name="codeHook")
    def code_hook(self) -> Optional[pulumi.Input['BotDialogCodeHookInvocationSettingArgs']]:
        """
        The DialogCodeHookInvocationSetting object associated with intent's confirmation step. The dialog code hook is triggered based on these invocation settings when the confirmation next step or declination next step or failure next step is InvokeDialogCodeHook.
        """
        return pulumi.get(self, "code_hook")

    @code_hook.setter
    def code_hook(self, value: Optional[pulumi.Input['BotDialogCodeHookInvocationSettingArgs']]):
        pulumi.set(self, "code_hook", value)

    @property
    @pulumi.getter(name="confirmationConditional")
    def confirmation_conditional(self) -> Optional[pulumi.Input['BotConditionalSpecificationArgs']]:
        """
        A list of conditional branches to evaluate after the intent is closed.
        """
        return pulumi.get(self, "confirmation_conditional")

    @confirmation_conditional.setter
    def confirmation_conditional(self, value: Optional[pulumi.Input['BotConditionalSpecificationArgs']]):
        pulumi.set(self, "confirmation_conditional", value)

    @property
    @pulumi.getter(name="confirmationNextStep")
    def confirmation_next_step(self) -> Optional[pulumi.Input['BotDialogStateArgs']]:
        """
        Specifies the next step that the bot executes when the customer confirms the intent.
        """
        return pulumi.get(self, "confirmation_next_step")

    @confirmation_next_step.setter
    def confirmation_next_step(self, value: Optional[pulumi.Input['BotDialogStateArgs']]):
        pulumi.set(self, "confirmation_next_step", value)

    @property
    @pulumi.getter(name="confirmationResponse")
    def confirmation_response(self) -> Optional[pulumi.Input['BotResponseSpecificationArgs']]:
        """
        Specifies a list of message groups that Amazon Lex uses to respond the user input.
        """
        return pulumi.get(self, "confirmation_response")

    @confirmation_response.setter
    def confirmation_response(self, value: Optional[pulumi.Input['BotResponseSpecificationArgs']]):
        pulumi.set(self, "confirmation_response", value)

    @property
    @pulumi.getter(name="declinationConditional")
    def declination_conditional(self) -> Optional[pulumi.Input['BotConditionalSpecificationArgs']]:
        """
        A list of conditional branches to evaluate after the intent is declined.
        """
        return pulumi.get(self, "declination_conditional")

    @declination_conditional.setter
    def declination_conditional(self, value: Optional[pulumi.Input['BotConditionalSpecificationArgs']]):
        pulumi.set(self, "declination_conditional", value)

    @property
    @pulumi.getter(name="declinationNextStep")
    def declination_next_step(self) -> Optional[pulumi.Input['BotDialogStateArgs']]:
        """
        Specifies the next step that the bot executes when the customer declines the intent.
        """
        return pulumi.get(self, "declination_next_step")

    @declination_next_step.setter
    def declination_next_step(self, value: Optional[pulumi.Input['BotDialogStateArgs']]):
        pulumi.set(self, "declination_next_step", value)

    @property
    @pulumi.getter(name="declinationResponse")
    def declination_response(self) -> Optional[pulumi.Input['BotResponseSpecificationArgs']]:
        """
        When the user answers "no" to the question defined in promptSpecification, Amazon Lex responds with this response to acknowledge that the intent was canceled.
        """
        return pulumi.get(self, "declination_response")

    @declination_response.setter
    def declination_response(self, value: Optional[pulumi.Input['BotResponseSpecificationArgs']]):
        pulumi.set(self, "declination_response", value)

    @property
    @pulumi.getter(name="elicitationCodeHook")
    def elicitation_code_hook(self) -> Optional[pulumi.Input['BotElicitationCodeHookInvocationSettingArgs']]:
        """
        The DialogCodeHookInvocationSetting used when the code hook is invoked during confirmation prompt retries.
        """
        return pulumi.get(self, "elicitation_code_hook")

    @elicitation_code_hook.setter
    def elicitation_code_hook(self, value: Optional[pulumi.Input['BotElicitationCodeHookInvocationSettingArgs']]):
        pulumi.set(self, "elicitation_code_hook", value)

    @property
    @pulumi.getter(name="failureConditional")
    def failure_conditional(self) -> Optional[pulumi.Input['BotConditionalSpecificationArgs']]:
        """
        Provides a list of conditional branches. Branches are evaluated in the order that they are entered in the list. The first branch with a condition that evaluates to true is executed. The last branch in the list is the default branch. The default branch should not have any condition expression. The default branch is executed if no other branch has a matching condition.
        """
        return pulumi.get(self, "failure_conditional")

    @failure_conditional.setter
    def failure_conditional(self, value: Optional[pulumi.Input['BotConditionalSpecificationArgs']]):
        pulumi.set(self, "failure_conditional", value)

    @property
    @pulumi.getter(name="failureNextStep")
    def failure_next_step(self) -> Optional[pulumi.Input['BotDialogStateArgs']]:
        """
        The next step to take in the conversation if the confirmation step fails.
        """
        return pulumi.get(self, "failure_next_step")

    @failure_next_step.setter
    def failure_next_step(self, value: Optional[pulumi.Input['BotDialogStateArgs']]):
        pulumi.set(self, "failure_next_step", value)

    @property
    @pulumi.getter(name="failureResponse")
    def failure_response(self) -> Optional[pulumi.Input['BotResponseSpecificationArgs']]:
        """
        Specifies a list of message groups that Amazon Lex uses to respond the user input.
        """
        return pulumi.get(self, "failure_response")

    @failure_response.setter
    def failure_response(self, value: Optional[pulumi.Input['BotResponseSpecificationArgs']]):
        pulumi.set(self, "failure_response", value)

    @property
    @pulumi.getter(name="isActive")
    def is_active(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether the intent's confirmation is sent to the user. When this field is false, confirmation and declination responses aren't sent. If the active field isn't specified, the default is true.
        """
        return pulumi.get(self, "is_active")

    @is_active.setter
    def is_active(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_active", value)


@pulumi.input_type
class BotIntentOverrideArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 slots: Optional[pulumi.Input[Sequence[pulumi.Input['BotSlotValueOverrideMapArgs']]]] = None):
        """
        Override settings to configure the intent state.
        :param pulumi.Input[str] name: The name of the intent. Only required when you're switching intents.
        :param pulumi.Input[Sequence[pulumi.Input['BotSlotValueOverrideMapArgs']]] slots: A map of all of the slot value overrides for the intent.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slots is not None:
            pulumi.set(__self__, "slots", slots)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the intent. Only required when you're switching intents.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def slots(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotSlotValueOverrideMapArgs']]]]:
        """
        A map of all of the slot value overrides for the intent.
        """
        return pulumi.get(self, "slots")

    @slots.setter
    def slots(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotSlotValueOverrideMapArgs']]]]):
        pulumi.set(self, "slots", value)


@pulumi.input_type
class BotIntentArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 dialog_code_hook: Optional[pulumi.Input['BotDialogCodeHookSettingArgs']] = None,
                 fulfillment_code_hook: Optional[pulumi.Input['BotFulfillmentCodeHookSettingArgs']] = None,
                 initial_response_setting: Optional[pulumi.Input['BotInitialResponseSettingArgs']] = None,
                 input_contexts: Optional[pulumi.Input[Sequence[pulumi.Input['BotInputContextArgs']]]] = None,
                 intent_closing_setting: Optional[pulumi.Input['BotIntentClosingSettingArgs']] = None,
                 intent_confirmation_setting: Optional[pulumi.Input['BotIntentConfirmationSettingArgs']] = None,
                 kendra_configuration: Optional[pulumi.Input['BotKendraConfigurationArgs']] = None,
                 output_contexts: Optional[pulumi.Input[Sequence[pulumi.Input['BotOutputContextArgs']]]] = None,
                 parent_intent_signature: Optional[pulumi.Input[str]] = None,
                 sample_utterances: Optional[pulumi.Input[Sequence[pulumi.Input['BotSampleUtteranceArgs']]]] = None,
                 slot_priorities: Optional[pulumi.Input[Sequence[pulumi.Input['BotSlotPriorityArgs']]]] = None,
                 slots: Optional[pulumi.Input[Sequence[pulumi.Input['BotSlotArgs']]]] = None):
        """
        Represents an action that the user wants to perform.
        :param pulumi.Input[str] name: The name of the intent.
        :param pulumi.Input[str] description: Description of thr intent.
        :param pulumi.Input['BotInitialResponseSettingArgs'] initial_response_setting: Configuration setting for a response sent to the user before Amazon Lex starts eliciting slots.
        :param pulumi.Input[Sequence[pulumi.Input['BotSampleUtteranceArgs']]] sample_utterances: A sample utterance that invokes an intent or respond to a slot elicitation prompt.
        :param pulumi.Input[Sequence[pulumi.Input['BotSlotArgs']]] slots: List of slots
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if dialog_code_hook is not None:
            pulumi.set(__self__, "dialog_code_hook", dialog_code_hook)
        if fulfillment_code_hook is not None:
            pulumi.set(__self__, "fulfillment_code_hook", fulfillment_code_hook)
        if initial_response_setting is not None:
            pulumi.set(__self__, "initial_response_setting", initial_response_setting)
        if input_contexts is not None:
            pulumi.set(__self__, "input_contexts", input_contexts)
        if intent_closing_setting is not None:
            pulumi.set(__self__, "intent_closing_setting", intent_closing_setting)
        if intent_confirmation_setting is not None:
            pulumi.set(__self__, "intent_confirmation_setting", intent_confirmation_setting)
        if kendra_configuration is not None:
            pulumi.set(__self__, "kendra_configuration", kendra_configuration)
        if output_contexts is not None:
            pulumi.set(__self__, "output_contexts", output_contexts)
        if parent_intent_signature is not None:
            pulumi.set(__self__, "parent_intent_signature", parent_intent_signature)
        if sample_utterances is not None:
            pulumi.set(__self__, "sample_utterances", sample_utterances)
        if slot_priorities is not None:
            pulumi.set(__self__, "slot_priorities", slot_priorities)
        if slots is not None:
            pulumi.set(__self__, "slots", slots)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the intent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of thr intent.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="dialogCodeHook")
    def dialog_code_hook(self) -> Optional[pulumi.Input['BotDialogCodeHookSettingArgs']]:
        return pulumi.get(self, "dialog_code_hook")

    @dialog_code_hook.setter
    def dialog_code_hook(self, value: Optional[pulumi.Input['BotDialogCodeHookSettingArgs']]):
        pulumi.set(self, "dialog_code_hook", value)

    @property
    @pulumi.getter(name="fulfillmentCodeHook")
    def fulfillment_code_hook(self) -> Optional[pulumi.Input['BotFulfillmentCodeHookSettingArgs']]:
        return pulumi.get(self, "fulfillment_code_hook")

    @fulfillment_code_hook.setter
    def fulfillment_code_hook(self, value: Optional[pulumi.Input['BotFulfillmentCodeHookSettingArgs']]):
        pulumi.set(self, "fulfillment_code_hook", value)

    @property
    @pulumi.getter(name="initialResponseSetting")
    def initial_response_setting(self) -> Optional[pulumi.Input['BotInitialResponseSettingArgs']]:
        """
        Configuration setting for a response sent to the user before Amazon Lex starts eliciting slots.
        """
        return pulumi.get(self, "initial_response_setting")

    @initial_response_setting.setter
    def initial_response_setting(self, value: Optional[pulumi.Input['BotInitialResponseSettingArgs']]):
        pulumi.set(self, "initial_response_setting", value)

    @property
    @pulumi.getter(name="inputContexts")
    def input_contexts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotInputContextArgs']]]]:
        return pulumi.get(self, "input_contexts")

    @input_contexts.setter
    def input_contexts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotInputContextArgs']]]]):
        pulumi.set(self, "input_contexts", value)

    @property
    @pulumi.getter(name="intentClosingSetting")
    def intent_closing_setting(self) -> Optional[pulumi.Input['BotIntentClosingSettingArgs']]:
        return pulumi.get(self, "intent_closing_setting")

    @intent_closing_setting.setter
    def intent_closing_setting(self, value: Optional[pulumi.Input['BotIntentClosingSettingArgs']]):
        pulumi.set(self, "intent_closing_setting", value)

    @property
    @pulumi.getter(name="intentConfirmationSetting")
    def intent_confirmation_setting(self) -> Optional[pulumi.Input['BotIntentConfirmationSettingArgs']]:
        return pulumi.get(self, "intent_confirmation_setting")

    @intent_confirmation_setting.setter
    def intent_confirmation_setting(self, value: Optional[pulumi.Input['BotIntentConfirmationSettingArgs']]):
        pulumi.set(self, "intent_confirmation_setting", value)

    @property
    @pulumi.getter(name="kendraConfiguration")
    def kendra_configuration(self) -> Optional[pulumi.Input['BotKendraConfigurationArgs']]:
        return pulumi.get(self, "kendra_configuration")

    @kendra_configuration.setter
    def kendra_configuration(self, value: Optional[pulumi.Input['BotKendraConfigurationArgs']]):
        pulumi.set(self, "kendra_configuration", value)

    @property
    @pulumi.getter(name="outputContexts")
    def output_contexts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotOutputContextArgs']]]]:
        return pulumi.get(self, "output_contexts")

    @output_contexts.setter
    def output_contexts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotOutputContextArgs']]]]):
        pulumi.set(self, "output_contexts", value)

    @property
    @pulumi.getter(name="parentIntentSignature")
    def parent_intent_signature(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "parent_intent_signature")

    @parent_intent_signature.setter
    def parent_intent_signature(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parent_intent_signature", value)

    @property
    @pulumi.getter(name="sampleUtterances")
    def sample_utterances(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotSampleUtteranceArgs']]]]:
        """
        A sample utterance that invokes an intent or respond to a slot elicitation prompt.
        """
        return pulumi.get(self, "sample_utterances")

    @sample_utterances.setter
    def sample_utterances(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotSampleUtteranceArgs']]]]):
        pulumi.set(self, "sample_utterances", value)

    @property
    @pulumi.getter(name="slotPriorities")
    def slot_priorities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotSlotPriorityArgs']]]]:
        return pulumi.get(self, "slot_priorities")

    @slot_priorities.setter
    def slot_priorities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotSlotPriorityArgs']]]]):
        pulumi.set(self, "slot_priorities", value)

    @property
    @pulumi.getter
    def slots(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotSlotArgs']]]]:
        """
        List of slots
        """
        return pulumi.get(self, "slots")

    @slots.setter
    def slots(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotSlotArgs']]]]):
        pulumi.set(self, "slots", value)


@pulumi.input_type
class BotKendraConfigurationArgs:
    def __init__(__self__, *,
                 kendra_index: pulumi.Input[str],
                 query_filter_string: Optional[pulumi.Input[str]] = None,
                 query_filter_string_enabled: Optional[pulumi.Input[bool]] = None):
        """
        Configuration for searching a Amazon Kendra index specified for the intent.
        :param pulumi.Input[bool] query_filter_string_enabled: Determines whether the AMAZON.KendraSearchIntent intent uses a custom query string to query the Amazon Kendra index.
        """
        pulumi.set(__self__, "kendra_index", kendra_index)
        if query_filter_string is not None:
            pulumi.set(__self__, "query_filter_string", query_filter_string)
        if query_filter_string_enabled is not None:
            pulumi.set(__self__, "query_filter_string_enabled", query_filter_string_enabled)

    @property
    @pulumi.getter(name="kendraIndex")
    def kendra_index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "kendra_index")

    @kendra_index.setter
    def kendra_index(self, value: pulumi.Input[str]):
        pulumi.set(self, "kendra_index", value)

    @property
    @pulumi.getter(name="queryFilterString")
    def query_filter_string(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "query_filter_string")

    @query_filter_string.setter
    def query_filter_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query_filter_string", value)

    @property
    @pulumi.getter(name="queryFilterStringEnabled")
    def query_filter_string_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether the AMAZON.KendraSearchIntent intent uses a custom query string to query the Amazon Kendra index.
        """
        return pulumi.get(self, "query_filter_string_enabled")

    @query_filter_string_enabled.setter
    def query_filter_string_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "query_filter_string_enabled", value)


@pulumi.input_type
class BotLocaleArgs:
    def __init__(__self__, *,
                 locale_id: pulumi.Input[str],
                 nlu_confidence_threshold: pulumi.Input[float],
                 custom_vocabulary: Optional[pulumi.Input['BotCustomVocabularyArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 intents: Optional[pulumi.Input[Sequence[pulumi.Input['BotIntentArgs']]]] = None,
                 slot_types: Optional[pulumi.Input[Sequence[pulumi.Input['BotSlotTypeArgs']]]] = None,
                 voice_settings: Optional[pulumi.Input['BotVoiceSettingsArgs']] = None):
        """
        A locale in the bot, which contains the intents and slot types that the bot uses in conversations with users in the specified language and locale.
        :param pulumi.Input[Sequence[pulumi.Input['BotIntentArgs']]] intents: List of intents
        :param pulumi.Input[Sequence[pulumi.Input['BotSlotTypeArgs']]] slot_types: List of SlotTypes
        """
        pulumi.set(__self__, "locale_id", locale_id)
        pulumi.set(__self__, "nlu_confidence_threshold", nlu_confidence_threshold)
        if custom_vocabulary is not None:
            pulumi.set(__self__, "custom_vocabulary", custom_vocabulary)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if intents is not None:
            pulumi.set(__self__, "intents", intents)
        if slot_types is not None:
            pulumi.set(__self__, "slot_types", slot_types)
        if voice_settings is not None:
            pulumi.set(__self__, "voice_settings", voice_settings)

    @property
    @pulumi.getter(name="localeId")
    def locale_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "locale_id")

    @locale_id.setter
    def locale_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "locale_id", value)

    @property
    @pulumi.getter(name="nluConfidenceThreshold")
    def nlu_confidence_threshold(self) -> pulumi.Input[float]:
        return pulumi.get(self, "nlu_confidence_threshold")

    @nlu_confidence_threshold.setter
    def nlu_confidence_threshold(self, value: pulumi.Input[float]):
        pulumi.set(self, "nlu_confidence_threshold", value)

    @property
    @pulumi.getter(name="customVocabulary")
    def custom_vocabulary(self) -> Optional[pulumi.Input['BotCustomVocabularyArgs']]:
        return pulumi.get(self, "custom_vocabulary")

    @custom_vocabulary.setter
    def custom_vocabulary(self, value: Optional[pulumi.Input['BotCustomVocabularyArgs']]):
        pulumi.set(self, "custom_vocabulary", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def intents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotIntentArgs']]]]:
        """
        List of intents
        """
        return pulumi.get(self, "intents")

    @intents.setter
    def intents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotIntentArgs']]]]):
        pulumi.set(self, "intents", value)

    @property
    @pulumi.getter(name="slotTypes")
    def slot_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotSlotTypeArgs']]]]:
        """
        List of SlotTypes
        """
        return pulumi.get(self, "slot_types")

    @slot_types.setter
    def slot_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotSlotTypeArgs']]]]):
        pulumi.set(self, "slot_types", value)

    @property
    @pulumi.getter(name="voiceSettings")
    def voice_settings(self) -> Optional[pulumi.Input['BotVoiceSettingsArgs']]:
        return pulumi.get(self, "voice_settings")

    @voice_settings.setter
    def voice_settings(self, value: Optional[pulumi.Input['BotVoiceSettingsArgs']]):
        pulumi.set(self, "voice_settings", value)


@pulumi.input_type
class BotMessageGroupArgs:
    def __init__(__self__, *,
                 message: pulumi.Input['BotMessageArgs'],
                 variations: Optional[pulumi.Input[Sequence[pulumi.Input['BotMessageArgs']]]] = None):
        """
        One or more messages that Amazon Lex can send to the user.
        :param pulumi.Input[Sequence[pulumi.Input['BotMessageArgs']]] variations: Message variations to send to the user.
        """
        pulumi.set(__self__, "message", message)
        if variations is not None:
            pulumi.set(__self__, "variations", variations)

    @property
    @pulumi.getter
    def message(self) -> pulumi.Input['BotMessageArgs']:
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: pulumi.Input['BotMessageArgs']):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def variations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotMessageArgs']]]]:
        """
        Message variations to send to the user.
        """
        return pulumi.get(self, "variations")

    @variations.setter
    def variations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotMessageArgs']]]]):
        pulumi.set(self, "variations", value)


@pulumi.input_type
class BotMessageArgs:
    def __init__(__self__, *,
                 custom_payload: Optional[pulumi.Input['BotCustomPayloadArgs']] = None,
                 image_response_card: Optional[pulumi.Input['BotImageResponseCardArgs']] = None,
                 plain_text_message: Optional[pulumi.Input['BotPlainTextMessageArgs']] = None,
                 ssml_message: Optional[pulumi.Input['BotSsmlMessageArgs']] = None):
        """
        The primary message that Amazon Lex should send to the user.
        """
        if custom_payload is not None:
            pulumi.set(__self__, "custom_payload", custom_payload)
        if image_response_card is not None:
            pulumi.set(__self__, "image_response_card", image_response_card)
        if plain_text_message is not None:
            pulumi.set(__self__, "plain_text_message", plain_text_message)
        if ssml_message is not None:
            pulumi.set(__self__, "ssml_message", ssml_message)

    @property
    @pulumi.getter(name="customPayload")
    def custom_payload(self) -> Optional[pulumi.Input['BotCustomPayloadArgs']]:
        return pulumi.get(self, "custom_payload")

    @custom_payload.setter
    def custom_payload(self, value: Optional[pulumi.Input['BotCustomPayloadArgs']]):
        pulumi.set(self, "custom_payload", value)

    @property
    @pulumi.getter(name="imageResponseCard")
    def image_response_card(self) -> Optional[pulumi.Input['BotImageResponseCardArgs']]:
        return pulumi.get(self, "image_response_card")

    @image_response_card.setter
    def image_response_card(self, value: Optional[pulumi.Input['BotImageResponseCardArgs']]):
        pulumi.set(self, "image_response_card", value)

    @property
    @pulumi.getter(name="plainTextMessage")
    def plain_text_message(self) -> Optional[pulumi.Input['BotPlainTextMessageArgs']]:
        return pulumi.get(self, "plain_text_message")

    @plain_text_message.setter
    def plain_text_message(self, value: Optional[pulumi.Input['BotPlainTextMessageArgs']]):
        pulumi.set(self, "plain_text_message", value)

    @property
    @pulumi.getter(name="ssmlMessage")
    def ssml_message(self) -> Optional[pulumi.Input['BotSsmlMessageArgs']]:
        return pulumi.get(self, "ssml_message")

    @ssml_message.setter
    def ssml_message(self, value: Optional[pulumi.Input['BotSsmlMessageArgs']]):
        pulumi.set(self, "ssml_message", value)


@pulumi.input_type
class BotMultipleValuesSettingArgs:
    def __init__(__self__, *,
                 allow_multiple_values: Optional[pulumi.Input[bool]] = None):
        """
        Indicates whether a slot can return multiple values.
        """
        if allow_multiple_values is not None:
            pulumi.set(__self__, "allow_multiple_values", allow_multiple_values)

    @property
    @pulumi.getter(name="allowMultipleValues")
    def allow_multiple_values(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "allow_multiple_values")

    @allow_multiple_values.setter
    def allow_multiple_values(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_multiple_values", value)


@pulumi.input_type
class BotObfuscationSettingArgs:
    def __init__(__self__, *,
                 obfuscation_setting_type: pulumi.Input['BotObfuscationSettingObfuscationSettingType']):
        """
        Determines whether Amazon Lex obscures slot values in conversation logs.
        :param pulumi.Input['BotObfuscationSettingObfuscationSettingType'] obfuscation_setting_type: Value that determines whether Amazon Lex obscures slot values in conversation logs. The default is to obscure the values.
        """
        pulumi.set(__self__, "obfuscation_setting_type", obfuscation_setting_type)

    @property
    @pulumi.getter(name="obfuscationSettingType")
    def obfuscation_setting_type(self) -> pulumi.Input['BotObfuscationSettingObfuscationSettingType']:
        """
        Value that determines whether Amazon Lex obscures slot values in conversation logs. The default is to obscure the values.
        """
        return pulumi.get(self, "obfuscation_setting_type")

    @obfuscation_setting_type.setter
    def obfuscation_setting_type(self, value: pulumi.Input['BotObfuscationSettingObfuscationSettingType']):
        pulumi.set(self, "obfuscation_setting_type", value)


@pulumi.input_type
class BotOutputContextArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 time_to_live_in_seconds: pulumi.Input[int],
                 turns_to_live: pulumi.Input[int]):
        """
        A session context that is activated when an intent is fulfilled.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "time_to_live_in_seconds", time_to_live_in_seconds)
        pulumi.set(__self__, "turns_to_live", turns_to_live)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="timeToLiveInSeconds")
    def time_to_live_in_seconds(self) -> pulumi.Input[int]:
        return pulumi.get(self, "time_to_live_in_seconds")

    @time_to_live_in_seconds.setter
    def time_to_live_in_seconds(self, value: pulumi.Input[int]):
        pulumi.set(self, "time_to_live_in_seconds", value)

    @property
    @pulumi.getter(name="turnsToLive")
    def turns_to_live(self) -> pulumi.Input[int]:
        return pulumi.get(self, "turns_to_live")

    @turns_to_live.setter
    def turns_to_live(self, value: pulumi.Input[int]):
        pulumi.set(self, "turns_to_live", value)


@pulumi.input_type
class BotPlainTextMessageArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        """
        A message in plain text format.
        :param pulumi.Input[str] value: The message to send to the user.
        """
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The message to send to the user.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class BotPostDialogCodeHookInvocationSpecificationArgs:
    def __init__(__self__, *,
                 failure_conditional: Optional[pulumi.Input['BotConditionalSpecificationArgs']] = None,
                 failure_next_step: Optional[pulumi.Input['BotDialogStateArgs']] = None,
                 failure_response: Optional[pulumi.Input['BotResponseSpecificationArgs']] = None,
                 success_conditional: Optional[pulumi.Input['BotConditionalSpecificationArgs']] = None,
                 success_next_step: Optional[pulumi.Input['BotDialogStateArgs']] = None,
                 success_response: Optional[pulumi.Input['BotResponseSpecificationArgs']] = None,
                 timeout_conditional: Optional[pulumi.Input['BotConditionalSpecificationArgs']] = None,
                 timeout_next_step: Optional[pulumi.Input['BotDialogStateArgs']] = None,
                 timeout_response: Optional[pulumi.Input['BotResponseSpecificationArgs']] = None):
        """
        Specifies next steps to run after the dialog code hook finishes.
        :param pulumi.Input['BotConditionalSpecificationArgs'] failure_conditional: A list of conditional branches to evaluate after the dialog code hook throws an exception or returns with the State field of the Intent object set to Failed.
        :param pulumi.Input['BotDialogStateArgs'] failure_next_step: Specifies the next step the bot runs after the dialog code hook throws an exception or returns with the State field of the Intent object set to Failed.
        :param pulumi.Input['BotResponseSpecificationArgs'] failure_response: Specifies a list of message groups that Amazon Lex uses to respond the user input.
        :param pulumi.Input['BotConditionalSpecificationArgs'] success_conditional: A list of conditional branches to evaluate after the dialog code hook finishes successfully.
        :param pulumi.Input['BotDialogStateArgs'] success_next_step: Specifics the next step the bot runs after the dialog code hook finishes successfully.
        :param pulumi.Input['BotResponseSpecificationArgs'] success_response: Specifies a list of message groups that Amazon Lex uses to respond the user input.
        :param pulumi.Input['BotConditionalSpecificationArgs'] timeout_conditional: A list of conditional branches to evaluate if the code hook times out.
        :param pulumi.Input['BotDialogStateArgs'] timeout_next_step: Specifies the next step that the bot runs when the code hook times out.
        :param pulumi.Input['BotResponseSpecificationArgs'] timeout_response: Specifies a list of message groups that Amazon Lex uses to respond the user input.
        """
        if failure_conditional is not None:
            pulumi.set(__self__, "failure_conditional", failure_conditional)
        if failure_next_step is not None:
            pulumi.set(__self__, "failure_next_step", failure_next_step)
        if failure_response is not None:
            pulumi.set(__self__, "failure_response", failure_response)
        if success_conditional is not None:
            pulumi.set(__self__, "success_conditional", success_conditional)
        if success_next_step is not None:
            pulumi.set(__self__, "success_next_step", success_next_step)
        if success_response is not None:
            pulumi.set(__self__, "success_response", success_response)
        if timeout_conditional is not None:
            pulumi.set(__self__, "timeout_conditional", timeout_conditional)
        if timeout_next_step is not None:
            pulumi.set(__self__, "timeout_next_step", timeout_next_step)
        if timeout_response is not None:
            pulumi.set(__self__, "timeout_response", timeout_response)

    @property
    @pulumi.getter(name="failureConditional")
    def failure_conditional(self) -> Optional[pulumi.Input['BotConditionalSpecificationArgs']]:
        """
        A list of conditional branches to evaluate after the dialog code hook throws an exception or returns with the State field of the Intent object set to Failed.
        """
        return pulumi.get(self, "failure_conditional")

    @failure_conditional.setter
    def failure_conditional(self, value: Optional[pulumi.Input['BotConditionalSpecificationArgs']]):
        pulumi.set(self, "failure_conditional", value)

    @property
    @pulumi.getter(name="failureNextStep")
    def failure_next_step(self) -> Optional[pulumi.Input['BotDialogStateArgs']]:
        """
        Specifies the next step the bot runs after the dialog code hook throws an exception or returns with the State field of the Intent object set to Failed.
        """
        return pulumi.get(self, "failure_next_step")

    @failure_next_step.setter
    def failure_next_step(self, value: Optional[pulumi.Input['BotDialogStateArgs']]):
        pulumi.set(self, "failure_next_step", value)

    @property
    @pulumi.getter(name="failureResponse")
    def failure_response(self) -> Optional[pulumi.Input['BotResponseSpecificationArgs']]:
        """
        Specifies a list of message groups that Amazon Lex uses to respond the user input.
        """
        return pulumi.get(self, "failure_response")

    @failure_response.setter
    def failure_response(self, value: Optional[pulumi.Input['BotResponseSpecificationArgs']]):
        pulumi.set(self, "failure_response", value)

    @property
    @pulumi.getter(name="successConditional")
    def success_conditional(self) -> Optional[pulumi.Input['BotConditionalSpecificationArgs']]:
        """
        A list of conditional branches to evaluate after the dialog code hook finishes successfully.
        """
        return pulumi.get(self, "success_conditional")

    @success_conditional.setter
    def success_conditional(self, value: Optional[pulumi.Input['BotConditionalSpecificationArgs']]):
        pulumi.set(self, "success_conditional", value)

    @property
    @pulumi.getter(name="successNextStep")
    def success_next_step(self) -> Optional[pulumi.Input['BotDialogStateArgs']]:
        """
        Specifics the next step the bot runs after the dialog code hook finishes successfully.
        """
        return pulumi.get(self, "success_next_step")

    @success_next_step.setter
    def success_next_step(self, value: Optional[pulumi.Input['BotDialogStateArgs']]):
        pulumi.set(self, "success_next_step", value)

    @property
    @pulumi.getter(name="successResponse")
    def success_response(self) -> Optional[pulumi.Input['BotResponseSpecificationArgs']]:
        """
        Specifies a list of message groups that Amazon Lex uses to respond the user input.
        """
        return pulumi.get(self, "success_response")

    @success_response.setter
    def success_response(self, value: Optional[pulumi.Input['BotResponseSpecificationArgs']]):
        pulumi.set(self, "success_response", value)

    @property
    @pulumi.getter(name="timeoutConditional")
    def timeout_conditional(self) -> Optional[pulumi.Input['BotConditionalSpecificationArgs']]:
        """
        A list of conditional branches to evaluate if the code hook times out.
        """
        return pulumi.get(self, "timeout_conditional")

    @timeout_conditional.setter
    def timeout_conditional(self, value: Optional[pulumi.Input['BotConditionalSpecificationArgs']]):
        pulumi.set(self, "timeout_conditional", value)

    @property
    @pulumi.getter(name="timeoutNextStep")
    def timeout_next_step(self) -> Optional[pulumi.Input['BotDialogStateArgs']]:
        """
        Specifies the next step that the bot runs when the code hook times out.
        """
        return pulumi.get(self, "timeout_next_step")

    @timeout_next_step.setter
    def timeout_next_step(self, value: Optional[pulumi.Input['BotDialogStateArgs']]):
        pulumi.set(self, "timeout_next_step", value)

    @property
    @pulumi.getter(name="timeoutResponse")
    def timeout_response(self) -> Optional[pulumi.Input['BotResponseSpecificationArgs']]:
        """
        Specifies a list of message groups that Amazon Lex uses to respond the user input.
        """
        return pulumi.get(self, "timeout_response")

    @timeout_response.setter
    def timeout_response(self, value: Optional[pulumi.Input['BotResponseSpecificationArgs']]):
        pulumi.set(self, "timeout_response", value)


@pulumi.input_type
class BotPostFulfillmentStatusSpecificationArgs:
    def __init__(__self__, *,
                 failure_conditional: Optional[pulumi.Input['BotConditionalSpecificationArgs']] = None,
                 failure_next_step: Optional[pulumi.Input['BotDialogStateArgs']] = None,
                 failure_response: Optional[pulumi.Input['BotResponseSpecificationArgs']] = None,
                 success_conditional: Optional[pulumi.Input['BotConditionalSpecificationArgs']] = None,
                 success_next_step: Optional[pulumi.Input['BotDialogStateArgs']] = None,
                 success_response: Optional[pulumi.Input['BotResponseSpecificationArgs']] = None,
                 timeout_conditional: Optional[pulumi.Input['BotConditionalSpecificationArgs']] = None,
                 timeout_next_step: Optional[pulumi.Input['BotDialogStateArgs']] = None,
                 timeout_response: Optional[pulumi.Input['BotResponseSpecificationArgs']] = None):
        """
        Provides a setting that determines whether the post-fulfillment response is sent to the user.
        :param pulumi.Input['BotConditionalSpecificationArgs'] failure_conditional: A list of conditional branches to evaluate after the fulfillment code hook throws an exception or returns with the State field of the Intent object set to Failed.
        :param pulumi.Input['BotDialogStateArgs'] failure_next_step: Specifies the next step the bot runs after the fulfillment code hook throws an exception or returns with the State field of the Intent object set to Failed.
        :param pulumi.Input['BotResponseSpecificationArgs'] failure_response: Specifies a list of message groups that Amazon Lex uses to respond the user input.
        :param pulumi.Input['BotConditionalSpecificationArgs'] success_conditional: A list of conditional branches to evaluate after the fulfillment code hook finishes successfully.
        :param pulumi.Input['BotDialogStateArgs'] success_next_step: Specifies the next step in the conversation that Amazon Lex invokes when the fulfillment code hook completes successfully.
        :param pulumi.Input['BotResponseSpecificationArgs'] success_response: Specifies a list of message groups that Amazon Lex uses to respond the user input.
        :param pulumi.Input['BotConditionalSpecificationArgs'] timeout_conditional: A list of conditional branches to evaluate if the fulfillment code hook times out.
        :param pulumi.Input['BotDialogStateArgs'] timeout_next_step: Specifies the next step that the bot runs when the fulfillment code hook times out.
        :param pulumi.Input['BotResponseSpecificationArgs'] timeout_response: Specifies a list of message groups that Amazon Lex uses to respond the user input.
        """
        if failure_conditional is not None:
            pulumi.set(__self__, "failure_conditional", failure_conditional)
        if failure_next_step is not None:
            pulumi.set(__self__, "failure_next_step", failure_next_step)
        if failure_response is not None:
            pulumi.set(__self__, "failure_response", failure_response)
        if success_conditional is not None:
            pulumi.set(__self__, "success_conditional", success_conditional)
        if success_next_step is not None:
            pulumi.set(__self__, "success_next_step", success_next_step)
        if success_response is not None:
            pulumi.set(__self__, "success_response", success_response)
        if timeout_conditional is not None:
            pulumi.set(__self__, "timeout_conditional", timeout_conditional)
        if timeout_next_step is not None:
            pulumi.set(__self__, "timeout_next_step", timeout_next_step)
        if timeout_response is not None:
            pulumi.set(__self__, "timeout_response", timeout_response)

    @property
    @pulumi.getter(name="failureConditional")
    def failure_conditional(self) -> Optional[pulumi.Input['BotConditionalSpecificationArgs']]:
        """
        A list of conditional branches to evaluate after the fulfillment code hook throws an exception or returns with the State field of the Intent object set to Failed.
        """
        return pulumi.get(self, "failure_conditional")

    @failure_conditional.setter
    def failure_conditional(self, value: Optional[pulumi.Input['BotConditionalSpecificationArgs']]):
        pulumi.set(self, "failure_conditional", value)

    @property
    @pulumi.getter(name="failureNextStep")
    def failure_next_step(self) -> Optional[pulumi.Input['BotDialogStateArgs']]:
        """
        Specifies the next step the bot runs after the fulfillment code hook throws an exception or returns with the State field of the Intent object set to Failed.
        """
        return pulumi.get(self, "failure_next_step")

    @failure_next_step.setter
    def failure_next_step(self, value: Optional[pulumi.Input['BotDialogStateArgs']]):
        pulumi.set(self, "failure_next_step", value)

    @property
    @pulumi.getter(name="failureResponse")
    def failure_response(self) -> Optional[pulumi.Input['BotResponseSpecificationArgs']]:
        """
        Specifies a list of message groups that Amazon Lex uses to respond the user input.
        """
        return pulumi.get(self, "failure_response")

    @failure_response.setter
    def failure_response(self, value: Optional[pulumi.Input['BotResponseSpecificationArgs']]):
        pulumi.set(self, "failure_response", value)

    @property
    @pulumi.getter(name="successConditional")
    def success_conditional(self) -> Optional[pulumi.Input['BotConditionalSpecificationArgs']]:
        """
        A list of conditional branches to evaluate after the fulfillment code hook finishes successfully.
        """
        return pulumi.get(self, "success_conditional")

    @success_conditional.setter
    def success_conditional(self, value: Optional[pulumi.Input['BotConditionalSpecificationArgs']]):
        pulumi.set(self, "success_conditional", value)

    @property
    @pulumi.getter(name="successNextStep")
    def success_next_step(self) -> Optional[pulumi.Input['BotDialogStateArgs']]:
        """
        Specifies the next step in the conversation that Amazon Lex invokes when the fulfillment code hook completes successfully.
        """
        return pulumi.get(self, "success_next_step")

    @success_next_step.setter
    def success_next_step(self, value: Optional[pulumi.Input['BotDialogStateArgs']]):
        pulumi.set(self, "success_next_step", value)

    @property
    @pulumi.getter(name="successResponse")
    def success_response(self) -> Optional[pulumi.Input['BotResponseSpecificationArgs']]:
        """
        Specifies a list of message groups that Amazon Lex uses to respond the user input.
        """
        return pulumi.get(self, "success_response")

    @success_response.setter
    def success_response(self, value: Optional[pulumi.Input['BotResponseSpecificationArgs']]):
        pulumi.set(self, "success_response", value)

    @property
    @pulumi.getter(name="timeoutConditional")
    def timeout_conditional(self) -> Optional[pulumi.Input['BotConditionalSpecificationArgs']]:
        """
        A list of conditional branches to evaluate if the fulfillment code hook times out.
        """
        return pulumi.get(self, "timeout_conditional")

    @timeout_conditional.setter
    def timeout_conditional(self, value: Optional[pulumi.Input['BotConditionalSpecificationArgs']]):
        pulumi.set(self, "timeout_conditional", value)

    @property
    @pulumi.getter(name="timeoutNextStep")
    def timeout_next_step(self) -> Optional[pulumi.Input['BotDialogStateArgs']]:
        """
        Specifies the next step that the bot runs when the fulfillment code hook times out.
        """
        return pulumi.get(self, "timeout_next_step")

    @timeout_next_step.setter
    def timeout_next_step(self, value: Optional[pulumi.Input['BotDialogStateArgs']]):
        pulumi.set(self, "timeout_next_step", value)

    @property
    @pulumi.getter(name="timeoutResponse")
    def timeout_response(self) -> Optional[pulumi.Input['BotResponseSpecificationArgs']]:
        """
        Specifies a list of message groups that Amazon Lex uses to respond the user input.
        """
        return pulumi.get(self, "timeout_response")

    @timeout_response.setter
    def timeout_response(self, value: Optional[pulumi.Input['BotResponseSpecificationArgs']]):
        pulumi.set(self, "timeout_response", value)


@pulumi.input_type
class BotPromptSpecificationArgs:
    def __init__(__self__, *,
                 max_retries: pulumi.Input[int],
                 message_groups_list: pulumi.Input[Sequence[pulumi.Input['BotMessageGroupArgs']]],
                 allow_interrupt: Optional[pulumi.Input[bool]] = None,
                 message_selection_strategy: Optional[pulumi.Input['BotMessageSelectionStrategy']] = None,
                 prompt_attempts_specification: Optional[Any] = None):
        """
        Prompts the user to confirm the intent.
        :param pulumi.Input[bool] allow_interrupt: Indicates whether the user can interrupt a speech prompt from the bot.
        :param Any prompt_attempts_specification: Specifies the advanced settings on each attempt of the prompt.
        """
        pulumi.set(__self__, "max_retries", max_retries)
        pulumi.set(__self__, "message_groups_list", message_groups_list)
        if allow_interrupt is not None:
            pulumi.set(__self__, "allow_interrupt", allow_interrupt)
        if message_selection_strategy is not None:
            pulumi.set(__self__, "message_selection_strategy", message_selection_strategy)
        if prompt_attempts_specification is not None:
            pulumi.set(__self__, "prompt_attempts_specification", prompt_attempts_specification)

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> pulumi.Input[int]:
        return pulumi.get(self, "max_retries")

    @max_retries.setter
    def max_retries(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_retries", value)

    @property
    @pulumi.getter(name="messageGroupsList")
    def message_groups_list(self) -> pulumi.Input[Sequence[pulumi.Input['BotMessageGroupArgs']]]:
        return pulumi.get(self, "message_groups_list")

    @message_groups_list.setter
    def message_groups_list(self, value: pulumi.Input[Sequence[pulumi.Input['BotMessageGroupArgs']]]):
        pulumi.set(self, "message_groups_list", value)

    @property
    @pulumi.getter(name="allowInterrupt")
    def allow_interrupt(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the user can interrupt a speech prompt from the bot.
        """
        return pulumi.get(self, "allow_interrupt")

    @allow_interrupt.setter
    def allow_interrupt(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_interrupt", value)

    @property
    @pulumi.getter(name="messageSelectionStrategy")
    def message_selection_strategy(self) -> Optional[pulumi.Input['BotMessageSelectionStrategy']]:
        return pulumi.get(self, "message_selection_strategy")

    @message_selection_strategy.setter
    def message_selection_strategy(self, value: Optional[pulumi.Input['BotMessageSelectionStrategy']]):
        pulumi.set(self, "message_selection_strategy", value)

    @property
    @pulumi.getter(name="promptAttemptsSpecification")
    def prompt_attempts_specification(self) -> Optional[Any]:
        """
        Specifies the advanced settings on each attempt of the prompt.
        """
        return pulumi.get(self, "prompt_attempts_specification")

    @prompt_attempts_specification.setter
    def prompt_attempts_specification(self, value: Optional[Any]):
        pulumi.set(self, "prompt_attempts_specification", value)


@pulumi.input_type
class BotResponseSpecificationArgs:
    def __init__(__self__, *,
                 message_groups_list: pulumi.Input[Sequence[pulumi.Input['BotMessageGroupArgs']]],
                 allow_interrupt: Optional[pulumi.Input[bool]] = None):
        """
        A list of message groups that Amazon Lex uses to respond the user input.
        :param pulumi.Input[bool] allow_interrupt: Indicates whether the user can interrupt a speech prompt from the bot.
        """
        pulumi.set(__self__, "message_groups_list", message_groups_list)
        if allow_interrupt is not None:
            pulumi.set(__self__, "allow_interrupt", allow_interrupt)

    @property
    @pulumi.getter(name="messageGroupsList")
    def message_groups_list(self) -> pulumi.Input[Sequence[pulumi.Input['BotMessageGroupArgs']]]:
        return pulumi.get(self, "message_groups_list")

    @message_groups_list.setter
    def message_groups_list(self, value: pulumi.Input[Sequence[pulumi.Input['BotMessageGroupArgs']]]):
        pulumi.set(self, "message_groups_list", value)

    @property
    @pulumi.getter(name="allowInterrupt")
    def allow_interrupt(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the user can interrupt a speech prompt from the bot.
        """
        return pulumi.get(self, "allow_interrupt")

    @allow_interrupt.setter
    def allow_interrupt(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_interrupt", value)


@pulumi.input_type
class BotS3BucketLogDestinationArgs:
    def __init__(__self__, *,
                 log_prefix: pulumi.Input[str],
                 s3_bucket_arn: pulumi.Input[str],
                 kms_key_arn: Optional[pulumi.Input[str]] = None):
        """
        Specifies an Amazon S3 bucket for logging audio conversations
        :param pulumi.Input[str] log_prefix: The Amazon S3 key of the deployment package.
        :param pulumi.Input[str] s3_bucket_arn: The Amazon Resource Name (ARN) of an Amazon S3 bucket where audio log files are stored.
        :param pulumi.Input[str] kms_key_arn: The Amazon Resource Name (ARN) of an AWS Key Management Service (KMS) key for encrypting audio log files stored in an S3 bucket.
        """
        pulumi.set(__self__, "log_prefix", log_prefix)
        pulumi.set(__self__, "s3_bucket_arn", s3_bucket_arn)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @property
    @pulumi.getter(name="logPrefix")
    def log_prefix(self) -> pulumi.Input[str]:
        """
        The Amazon S3 key of the deployment package.
        """
        return pulumi.get(self, "log_prefix")

    @log_prefix.setter
    def log_prefix(self, value: pulumi.Input[str]):
        pulumi.set(self, "log_prefix", value)

    @property
    @pulumi.getter(name="s3BucketArn")
    def s3_bucket_arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of an Amazon S3 bucket where audio log files are stored.
        """
        return pulumi.get(self, "s3_bucket_arn")

    @s3_bucket_arn.setter
    def s3_bucket_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_bucket_arn", value)

    @property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon Resource Name (ARN) of an AWS Key Management Service (KMS) key for encrypting audio log files stored in an S3 bucket.
        """
        return pulumi.get(self, "kms_key_arn")

    @kms_key_arn.setter
    def kms_key_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_arn", value)


@pulumi.input_type
class BotS3LocationArgs:
    def __init__(__self__, *,
                 s3_bucket: pulumi.Input[str],
                 s3_object_key: pulumi.Input[str],
                 s3_object_version: Optional[pulumi.Input[str]] = None):
        """
        S3 location of bot definitions zip file, if it's not defined inline in CloudFormation.
        :param pulumi.Input[str] s3_bucket: An Amazon S3 bucket in the same AWS Region as your function. The bucket can be in a different AWS account.
        :param pulumi.Input[str] s3_object_key: The Amazon S3 key of the deployment package.
        :param pulumi.Input[str] s3_object_version: For versioned objects, the version of the deployment package object to use. If not specified, the current object version will be used.
        """
        pulumi.set(__self__, "s3_bucket", s3_bucket)
        pulumi.set(__self__, "s3_object_key", s3_object_key)
        if s3_object_version is not None:
            pulumi.set(__self__, "s3_object_version", s3_object_version)

    @property
    @pulumi.getter(name="s3Bucket")
    def s3_bucket(self) -> pulumi.Input[str]:
        """
        An Amazon S3 bucket in the same AWS Region as your function. The bucket can be in a different AWS account.
        """
        return pulumi.get(self, "s3_bucket")

    @s3_bucket.setter
    def s3_bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_bucket", value)

    @property
    @pulumi.getter(name="s3ObjectKey")
    def s3_object_key(self) -> pulumi.Input[str]:
        """
        The Amazon S3 key of the deployment package.
        """
        return pulumi.get(self, "s3_object_key")

    @s3_object_key.setter
    def s3_object_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_object_key", value)

    @property
    @pulumi.getter(name="s3ObjectVersion")
    def s3_object_version(self) -> Optional[pulumi.Input[str]]:
        """
        For versioned objects, the version of the deployment package object to use. If not specified, the current object version will be used.
        """
        return pulumi.get(self, "s3_object_version")

    @s3_object_version.setter
    def s3_object_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_object_version", value)


@pulumi.input_type
class BotSampleUtteranceArgs:
    def __init__(__self__, *,
                 utterance: pulumi.Input[str]):
        """
        A sample utterance that invokes an intent or respond to a slot elicitation prompt.
        """
        pulumi.set(__self__, "utterance", utterance)

    @property
    @pulumi.getter
    def utterance(self) -> pulumi.Input[str]:
        return pulumi.get(self, "utterance")

    @utterance.setter
    def utterance(self, value: pulumi.Input[str]):
        pulumi.set(self, "utterance", value)


@pulumi.input_type
class BotSampleValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        """
        Defines one of the values for a slot type.
        :param pulumi.Input[str] value: The value that can be used for a slot type.
        """
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value that can be used for a slot type.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class BotSessionAttributeArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: Optional[pulumi.Input[str]] = None):
        """
        Key/value pair representing session-specific context information. It contains application information passed between Amazon Lex and a client application.
        """
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class BotSlotCaptureSettingArgs:
    def __init__(__self__, *,
                 capture_conditional: Optional[pulumi.Input['BotConditionalSpecificationArgs']] = None,
                 capture_next_step: Optional[pulumi.Input['BotDialogStateArgs']] = None,
                 capture_response: Optional[pulumi.Input['BotResponseSpecificationArgs']] = None,
                 code_hook: Optional[pulumi.Input['BotDialogCodeHookInvocationSettingArgs']] = None,
                 elicitation_code_hook: Optional[pulumi.Input['BotElicitationCodeHookInvocationSettingArgs']] = None,
                 failure_conditional: Optional[pulumi.Input['BotConditionalSpecificationArgs']] = None,
                 failure_next_step: Optional[pulumi.Input['BotDialogStateArgs']] = None,
                 failure_response: Optional[pulumi.Input['BotResponseSpecificationArgs']] = None):
        """
        Settings used when Amazon Lex successfully captures a slot value from a user.
        :param pulumi.Input['BotConditionalSpecificationArgs'] capture_conditional: A list of conditional branches to evaluate after the slot value is captured.
        :param pulumi.Input['BotDialogStateArgs'] capture_next_step: Specifies the next step that the bot runs when the slot value is captured before the code hook times out.
        :param pulumi.Input['BotResponseSpecificationArgs'] capture_response: Specifies a list of message groups that Amazon Lex uses to respond the user input.
        :param pulumi.Input['BotDialogCodeHookInvocationSettingArgs'] code_hook: Code hook called after Amazon Lex successfully captures a slot value.
        :param pulumi.Input['BotElicitationCodeHookInvocationSettingArgs'] elicitation_code_hook: Code hook called when Amazon Lex doesn't capture a slot value.
        :param pulumi.Input['BotConditionalSpecificationArgs'] failure_conditional: A list of conditional branches to evaluate when the slot value isn't captured.
        :param pulumi.Input['BotDialogStateArgs'] failure_next_step: Specifies the next step that the bot runs when the slot value code is not recognized.
        :param pulumi.Input['BotResponseSpecificationArgs'] failure_response: Specifies a list of message groups that Amazon Lex uses to respond the user input.
        """
        if capture_conditional is not None:
            pulumi.set(__self__, "capture_conditional", capture_conditional)
        if capture_next_step is not None:
            pulumi.set(__self__, "capture_next_step", capture_next_step)
        if capture_response is not None:
            pulumi.set(__self__, "capture_response", capture_response)
        if code_hook is not None:
            pulumi.set(__self__, "code_hook", code_hook)
        if elicitation_code_hook is not None:
            pulumi.set(__self__, "elicitation_code_hook", elicitation_code_hook)
        if failure_conditional is not None:
            pulumi.set(__self__, "failure_conditional", failure_conditional)
        if failure_next_step is not None:
            pulumi.set(__self__, "failure_next_step", failure_next_step)
        if failure_response is not None:
            pulumi.set(__self__, "failure_response", failure_response)

    @property
    @pulumi.getter(name="captureConditional")
    def capture_conditional(self) -> Optional[pulumi.Input['BotConditionalSpecificationArgs']]:
        """
        A list of conditional branches to evaluate after the slot value is captured.
        """
        return pulumi.get(self, "capture_conditional")

    @capture_conditional.setter
    def capture_conditional(self, value: Optional[pulumi.Input['BotConditionalSpecificationArgs']]):
        pulumi.set(self, "capture_conditional", value)

    @property
    @pulumi.getter(name="captureNextStep")
    def capture_next_step(self) -> Optional[pulumi.Input['BotDialogStateArgs']]:
        """
        Specifies the next step that the bot runs when the slot value is captured before the code hook times out.
        """
        return pulumi.get(self, "capture_next_step")

    @capture_next_step.setter
    def capture_next_step(self, value: Optional[pulumi.Input['BotDialogStateArgs']]):
        pulumi.set(self, "capture_next_step", value)

    @property
    @pulumi.getter(name="captureResponse")
    def capture_response(self) -> Optional[pulumi.Input['BotResponseSpecificationArgs']]:
        """
        Specifies a list of message groups that Amazon Lex uses to respond the user input.
        """
        return pulumi.get(self, "capture_response")

    @capture_response.setter
    def capture_response(self, value: Optional[pulumi.Input['BotResponseSpecificationArgs']]):
        pulumi.set(self, "capture_response", value)

    @property
    @pulumi.getter(name="codeHook")
    def code_hook(self) -> Optional[pulumi.Input['BotDialogCodeHookInvocationSettingArgs']]:
        """
        Code hook called after Amazon Lex successfully captures a slot value.
        """
        return pulumi.get(self, "code_hook")

    @code_hook.setter
    def code_hook(self, value: Optional[pulumi.Input['BotDialogCodeHookInvocationSettingArgs']]):
        pulumi.set(self, "code_hook", value)

    @property
    @pulumi.getter(name="elicitationCodeHook")
    def elicitation_code_hook(self) -> Optional[pulumi.Input['BotElicitationCodeHookInvocationSettingArgs']]:
        """
        Code hook called when Amazon Lex doesn't capture a slot value.
        """
        return pulumi.get(self, "elicitation_code_hook")

    @elicitation_code_hook.setter
    def elicitation_code_hook(self, value: Optional[pulumi.Input['BotElicitationCodeHookInvocationSettingArgs']]):
        pulumi.set(self, "elicitation_code_hook", value)

    @property
    @pulumi.getter(name="failureConditional")
    def failure_conditional(self) -> Optional[pulumi.Input['BotConditionalSpecificationArgs']]:
        """
        A list of conditional branches to evaluate when the slot value isn't captured.
        """
        return pulumi.get(self, "failure_conditional")

    @failure_conditional.setter
    def failure_conditional(self, value: Optional[pulumi.Input['BotConditionalSpecificationArgs']]):
        pulumi.set(self, "failure_conditional", value)

    @property
    @pulumi.getter(name="failureNextStep")
    def failure_next_step(self) -> Optional[pulumi.Input['BotDialogStateArgs']]:
        """
        Specifies the next step that the bot runs when the slot value code is not recognized.
        """
        return pulumi.get(self, "failure_next_step")

    @failure_next_step.setter
    def failure_next_step(self, value: Optional[pulumi.Input['BotDialogStateArgs']]):
        pulumi.set(self, "failure_next_step", value)

    @property
    @pulumi.getter(name="failureResponse")
    def failure_response(self) -> Optional[pulumi.Input['BotResponseSpecificationArgs']]:
        """
        Specifies a list of message groups that Amazon Lex uses to respond the user input.
        """
        return pulumi.get(self, "failure_response")

    @failure_response.setter
    def failure_response(self, value: Optional[pulumi.Input['BotResponseSpecificationArgs']]):
        pulumi.set(self, "failure_response", value)


@pulumi.input_type
class BotSlotDefaultValueSpecificationArgs:
    def __init__(__self__, *,
                 default_value_list: pulumi.Input[Sequence[pulumi.Input['BotSlotDefaultValueArgs']]]):
        """
        A list of values that Amazon Lex should use as the default value for a slot.
        :param pulumi.Input[Sequence[pulumi.Input['BotSlotDefaultValueArgs']]] default_value_list: A list of slot default values
        """
        pulumi.set(__self__, "default_value_list", default_value_list)

    @property
    @pulumi.getter(name="defaultValueList")
    def default_value_list(self) -> pulumi.Input[Sequence[pulumi.Input['BotSlotDefaultValueArgs']]]:
        """
        A list of slot default values
        """
        return pulumi.get(self, "default_value_list")

    @default_value_list.setter
    def default_value_list(self, value: pulumi.Input[Sequence[pulumi.Input['BotSlotDefaultValueArgs']]]):
        pulumi.set(self, "default_value_list", value)


@pulumi.input_type
class BotSlotDefaultValueArgs:
    def __init__(__self__, *,
                 default_value: pulumi.Input[str]):
        """
        The default value to use when a user doesn't provide a value for a slot.
        :param pulumi.Input[str] default_value: The default value to use when a user doesn't provide a value for a slot.
        """
        pulumi.set(__self__, "default_value", default_value)

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> pulumi.Input[str]:
        """
        The default value to use when a user doesn't provide a value for a slot.
        """
        return pulumi.get(self, "default_value")

    @default_value.setter
    def default_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "default_value", value)


@pulumi.input_type
class BotSlotPriorityArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int],
                 slot_name: pulumi.Input[str]):
        """
        The priority that Amazon Lex should use when eliciting slot values from a user.
        :param pulumi.Input[str] slot_name: The name of the slot.
        """
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "slot_name", slot_name)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="slotName")
    def slot_name(self) -> pulumi.Input[str]:
        """
        The name of the slot.
        """
        return pulumi.get(self, "slot_name")

    @slot_name.setter
    def slot_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "slot_name", value)


@pulumi.input_type
class BotSlotTypeValueArgs:
    def __init__(__self__, *,
                 sample_value: pulumi.Input['BotSampleValueArgs'],
                 synonyms: Optional[pulumi.Input[Sequence[pulumi.Input['BotSampleValueArgs']]]] = None):
        """
        Value that the slot type can take.
        """
        pulumi.set(__self__, "sample_value", sample_value)
        if synonyms is not None:
            pulumi.set(__self__, "synonyms", synonyms)

    @property
    @pulumi.getter(name="sampleValue")
    def sample_value(self) -> pulumi.Input['BotSampleValueArgs']:
        return pulumi.get(self, "sample_value")

    @sample_value.setter
    def sample_value(self, value: pulumi.Input['BotSampleValueArgs']):
        pulumi.set(self, "sample_value", value)

    @property
    @pulumi.getter
    def synonyms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotSampleValueArgs']]]]:
        return pulumi.get(self, "synonyms")

    @synonyms.setter
    def synonyms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotSampleValueArgs']]]]):
        pulumi.set(self, "synonyms", value)


@pulumi.input_type
class BotSlotTypeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 external_source_setting: Optional[pulumi.Input['BotExternalSourceSettingArgs']] = None,
                 parent_slot_type_signature: Optional[pulumi.Input[str]] = None,
                 slot_type_values: Optional[pulumi.Input[Sequence[pulumi.Input['BotSlotTypeValueArgs']]]] = None,
                 value_selection_setting: Optional[pulumi.Input['BotSlotValueSelectionSettingArgs']] = None):
        """
        A custom, extended built-in or a grammar slot type.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if external_source_setting is not None:
            pulumi.set(__self__, "external_source_setting", external_source_setting)
        if parent_slot_type_signature is not None:
            pulumi.set(__self__, "parent_slot_type_signature", parent_slot_type_signature)
        if slot_type_values is not None:
            pulumi.set(__self__, "slot_type_values", slot_type_values)
        if value_selection_setting is not None:
            pulumi.set(__self__, "value_selection_setting", value_selection_setting)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="externalSourceSetting")
    def external_source_setting(self) -> Optional[pulumi.Input['BotExternalSourceSettingArgs']]:
        return pulumi.get(self, "external_source_setting")

    @external_source_setting.setter
    def external_source_setting(self, value: Optional[pulumi.Input['BotExternalSourceSettingArgs']]):
        pulumi.set(self, "external_source_setting", value)

    @property
    @pulumi.getter(name="parentSlotTypeSignature")
    def parent_slot_type_signature(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "parent_slot_type_signature")

    @parent_slot_type_signature.setter
    def parent_slot_type_signature(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parent_slot_type_signature", value)

    @property
    @pulumi.getter(name="slotTypeValues")
    def slot_type_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotSlotTypeValueArgs']]]]:
        return pulumi.get(self, "slot_type_values")

    @slot_type_values.setter
    def slot_type_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotSlotTypeValueArgs']]]]):
        pulumi.set(self, "slot_type_values", value)

    @property
    @pulumi.getter(name="valueSelectionSetting")
    def value_selection_setting(self) -> Optional[pulumi.Input['BotSlotValueSelectionSettingArgs']]:
        return pulumi.get(self, "value_selection_setting")

    @value_selection_setting.setter
    def value_selection_setting(self, value: Optional[pulumi.Input['BotSlotValueSelectionSettingArgs']]):
        pulumi.set(self, "value_selection_setting", value)


@pulumi.input_type
class BotSlotValueElicitationSettingArgs:
    def __init__(__self__, *,
                 slot_constraint: pulumi.Input['BotSlotConstraint'],
                 default_value_specification: Optional[pulumi.Input['BotSlotDefaultValueSpecificationArgs']] = None,
                 prompt_specification: Optional[pulumi.Input['BotPromptSpecificationArgs']] = None,
                 sample_utterances: Optional[pulumi.Input[Sequence[pulumi.Input['BotSampleUtteranceArgs']]]] = None,
                 slot_capture_setting: Optional[pulumi.Input['BotSlotCaptureSettingArgs']] = None,
                 wait_and_continue_specification: Optional[pulumi.Input['BotWaitAndContinueSpecificationArgs']] = None):
        """
        Settings that you can use for eliciting a slot value.
        :param pulumi.Input['BotSlotConstraint'] slot_constraint: Specifies whether the slot is required or optional.
        :param pulumi.Input['BotSlotDefaultValueSpecificationArgs'] default_value_specification: A list of default values for a slot.
        :param pulumi.Input['BotPromptSpecificationArgs'] prompt_specification: The prompt that Amazon Lex uses to elicit the slot value from the user.
        :param pulumi.Input[Sequence[pulumi.Input['BotSampleUtteranceArgs']]] sample_utterances: If you know a specific pattern that users might respond to an Amazon Lex request for a slot value, you can provide those utterances to improve accuracy.
        :param pulumi.Input['BotSlotCaptureSettingArgs'] slot_capture_setting: Specifies the next stage in the conversation after capturing the slot.
        :param pulumi.Input['BotWaitAndContinueSpecificationArgs'] wait_and_continue_specification: Specifies the prompts that Amazon Lex uses while a bot is waiting for customer input.
        """
        pulumi.set(__self__, "slot_constraint", slot_constraint)
        if default_value_specification is not None:
            pulumi.set(__self__, "default_value_specification", default_value_specification)
        if prompt_specification is not None:
            pulumi.set(__self__, "prompt_specification", prompt_specification)
        if sample_utterances is not None:
            pulumi.set(__self__, "sample_utterances", sample_utterances)
        if slot_capture_setting is not None:
            pulumi.set(__self__, "slot_capture_setting", slot_capture_setting)
        if wait_and_continue_specification is not None:
            pulumi.set(__self__, "wait_and_continue_specification", wait_and_continue_specification)

    @property
    @pulumi.getter(name="slotConstraint")
    def slot_constraint(self) -> pulumi.Input['BotSlotConstraint']:
        """
        Specifies whether the slot is required or optional.
        """
        return pulumi.get(self, "slot_constraint")

    @slot_constraint.setter
    def slot_constraint(self, value: pulumi.Input['BotSlotConstraint']):
        pulumi.set(self, "slot_constraint", value)

    @property
    @pulumi.getter(name="defaultValueSpecification")
    def default_value_specification(self) -> Optional[pulumi.Input['BotSlotDefaultValueSpecificationArgs']]:
        """
        A list of default values for a slot.
        """
        return pulumi.get(self, "default_value_specification")

    @default_value_specification.setter
    def default_value_specification(self, value: Optional[pulumi.Input['BotSlotDefaultValueSpecificationArgs']]):
        pulumi.set(self, "default_value_specification", value)

    @property
    @pulumi.getter(name="promptSpecification")
    def prompt_specification(self) -> Optional[pulumi.Input['BotPromptSpecificationArgs']]:
        """
        The prompt that Amazon Lex uses to elicit the slot value from the user.
        """
        return pulumi.get(self, "prompt_specification")

    @prompt_specification.setter
    def prompt_specification(self, value: Optional[pulumi.Input['BotPromptSpecificationArgs']]):
        pulumi.set(self, "prompt_specification", value)

    @property
    @pulumi.getter(name="sampleUtterances")
    def sample_utterances(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotSampleUtteranceArgs']]]]:
        """
        If you know a specific pattern that users might respond to an Amazon Lex request for a slot value, you can provide those utterances to improve accuracy.
        """
        return pulumi.get(self, "sample_utterances")

    @sample_utterances.setter
    def sample_utterances(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotSampleUtteranceArgs']]]]):
        pulumi.set(self, "sample_utterances", value)

    @property
    @pulumi.getter(name="slotCaptureSetting")
    def slot_capture_setting(self) -> Optional[pulumi.Input['BotSlotCaptureSettingArgs']]:
        """
        Specifies the next stage in the conversation after capturing the slot.
        """
        return pulumi.get(self, "slot_capture_setting")

    @slot_capture_setting.setter
    def slot_capture_setting(self, value: Optional[pulumi.Input['BotSlotCaptureSettingArgs']]):
        pulumi.set(self, "slot_capture_setting", value)

    @property
    @pulumi.getter(name="waitAndContinueSpecification")
    def wait_and_continue_specification(self) -> Optional[pulumi.Input['BotWaitAndContinueSpecificationArgs']]:
        """
        Specifies the prompts that Amazon Lex uses while a bot is waiting for customer input.
        """
        return pulumi.get(self, "wait_and_continue_specification")

    @wait_and_continue_specification.setter
    def wait_and_continue_specification(self, value: Optional[pulumi.Input['BotWaitAndContinueSpecificationArgs']]):
        pulumi.set(self, "wait_and_continue_specification", value)


@pulumi.input_type
class BotSlotValueOverrideMapArgs:
    def __init__(__self__, *,
                 slot_name: Optional[pulumi.Input[str]] = None,
                 slot_value_override: Optional[pulumi.Input['BotSlotValueOverrideArgs']] = None):
        """
        A map of slot names and their overridden values.
        """
        if slot_name is not None:
            pulumi.set(__self__, "slot_name", slot_name)
        if slot_value_override is not None:
            pulumi.set(__self__, "slot_value_override", slot_value_override)

    @property
    @pulumi.getter(name="slotName")
    def slot_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "slot_name")

    @slot_name.setter
    def slot_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "slot_name", value)

    @property
    @pulumi.getter(name="slotValueOverride")
    def slot_value_override(self) -> Optional[pulumi.Input['BotSlotValueOverrideArgs']]:
        return pulumi.get(self, "slot_value_override")

    @slot_value_override.setter
    def slot_value_override(self, value: Optional[pulumi.Input['BotSlotValueOverrideArgs']]):
        pulumi.set(self, "slot_value_override", value)


@pulumi.input_type
class BotSlotValueOverrideArgs:
    def __init__(__self__, *,
                 shape: Optional[pulumi.Input['BotSlotShape']] = None,
                 value: Optional[pulumi.Input['BotSlotValueArgs']] = None,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input['BotSlotValueOverrideArgs']]]] = None):
        """
        The slot values that Amazon Lex uses when it sets slot values in a dialog step.
        :param pulumi.Input['BotSlotShape'] shape: When the shape value is List, it indicates that the values field contains a list of slot values. When the value is Scalar, it indicates that the value field contains a single value.
        :param pulumi.Input['BotSlotValueArgs'] value: The current value of the slot.
        :param pulumi.Input[Sequence[pulumi.Input['BotSlotValueOverrideArgs']]] values: A list of one or more values that the user provided for the slot. For example, for a slot that elicits pizza toppings, the values might be "pepperoni" and "pineapple."
        """
        if shape is not None:
            pulumi.set(__self__, "shape", shape)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def shape(self) -> Optional[pulumi.Input['BotSlotShape']]:
        """
        When the shape value is List, it indicates that the values field contains a list of slot values. When the value is Scalar, it indicates that the value field contains a single value.
        """
        return pulumi.get(self, "shape")

    @shape.setter
    def shape(self, value: Optional[pulumi.Input['BotSlotShape']]):
        pulumi.set(self, "shape", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input['BotSlotValueArgs']]:
        """
        The current value of the slot.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input['BotSlotValueArgs']]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotSlotValueOverrideArgs']]]]:
        """
        A list of one or more values that the user provided for the slot. For example, for a slot that elicits pizza toppings, the values might be "pepperoni" and "pineapple."
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotSlotValueOverrideArgs']]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class BotSlotValueRegexFilterArgs:
    def __init__(__self__, *,
                 pattern: pulumi.Input[str]):
        """
        A regular expression used to validate the value of a slot.
        :param pulumi.Input[str] pattern: Regex pattern
        """
        pulumi.set(__self__, "pattern", pattern)

    @property
    @pulumi.getter
    def pattern(self) -> pulumi.Input[str]:
        """
        Regex pattern
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: pulumi.Input[str]):
        pulumi.set(self, "pattern", value)


@pulumi.input_type
class BotSlotValueSelectionSettingArgs:
    def __init__(__self__, *,
                 resolution_strategy: pulumi.Input['BotSlotValueResolutionStrategy'],
                 advanced_recognition_setting: Optional[pulumi.Input['BotAdvancedRecognitionSettingArgs']] = None,
                 regex_filter: Optional[pulumi.Input['BotSlotValueRegexFilterArgs']] = None):
        """
        Contains settings used by Amazon Lex to select a slot value.
        """
        pulumi.set(__self__, "resolution_strategy", resolution_strategy)
        if advanced_recognition_setting is not None:
            pulumi.set(__self__, "advanced_recognition_setting", advanced_recognition_setting)
        if regex_filter is not None:
            pulumi.set(__self__, "regex_filter", regex_filter)

    @property
    @pulumi.getter(name="resolutionStrategy")
    def resolution_strategy(self) -> pulumi.Input['BotSlotValueResolutionStrategy']:
        return pulumi.get(self, "resolution_strategy")

    @resolution_strategy.setter
    def resolution_strategy(self, value: pulumi.Input['BotSlotValueResolutionStrategy']):
        pulumi.set(self, "resolution_strategy", value)

    @property
    @pulumi.getter(name="advancedRecognitionSetting")
    def advanced_recognition_setting(self) -> Optional[pulumi.Input['BotAdvancedRecognitionSettingArgs']]:
        return pulumi.get(self, "advanced_recognition_setting")

    @advanced_recognition_setting.setter
    def advanced_recognition_setting(self, value: Optional[pulumi.Input['BotAdvancedRecognitionSettingArgs']]):
        pulumi.set(self, "advanced_recognition_setting", value)

    @property
    @pulumi.getter(name="regexFilter")
    def regex_filter(self) -> Optional[pulumi.Input['BotSlotValueRegexFilterArgs']]:
        return pulumi.get(self, "regex_filter")

    @regex_filter.setter
    def regex_filter(self, value: Optional[pulumi.Input['BotSlotValueRegexFilterArgs']]):
        pulumi.set(self, "regex_filter", value)


@pulumi.input_type
class BotSlotValueArgs:
    def __init__(__self__, *,
                 interpreted_value: Optional[pulumi.Input[str]] = None):
        """
        The value to set in a slot.
        :param pulumi.Input[str] interpreted_value: The value that Amazon Lex determines for the slot.
        """
        if interpreted_value is not None:
            pulumi.set(__self__, "interpreted_value", interpreted_value)

    @property
    @pulumi.getter(name="interpretedValue")
    def interpreted_value(self) -> Optional[pulumi.Input[str]]:
        """
        The value that Amazon Lex determines for the slot.
        """
        return pulumi.get(self, "interpreted_value")

    @interpreted_value.setter
    def interpreted_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "interpreted_value", value)


@pulumi.input_type
class BotSlotArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 slot_type_name: pulumi.Input[str],
                 value_elicitation_setting: pulumi.Input['BotSlotValueElicitationSettingArgs'],
                 description: Optional[pulumi.Input[str]] = None,
                 multiple_values_setting: Optional[pulumi.Input['BotMultipleValuesSettingArgs']] = None,
                 obfuscation_setting: Optional[pulumi.Input['BotObfuscationSettingArgs']] = None):
        """
        A slot is a variable needed to fulfill an intent, where an intent can require zero or more slots.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "slot_type_name", slot_type_name)
        pulumi.set(__self__, "value_elicitation_setting", value_elicitation_setting)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if multiple_values_setting is not None:
            pulumi.set(__self__, "multiple_values_setting", multiple_values_setting)
        if obfuscation_setting is not None:
            pulumi.set(__self__, "obfuscation_setting", obfuscation_setting)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="slotTypeName")
    def slot_type_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "slot_type_name")

    @slot_type_name.setter
    def slot_type_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "slot_type_name", value)

    @property
    @pulumi.getter(name="valueElicitationSetting")
    def value_elicitation_setting(self) -> pulumi.Input['BotSlotValueElicitationSettingArgs']:
        return pulumi.get(self, "value_elicitation_setting")

    @value_elicitation_setting.setter
    def value_elicitation_setting(self, value: pulumi.Input['BotSlotValueElicitationSettingArgs']):
        pulumi.set(self, "value_elicitation_setting", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="multipleValuesSetting")
    def multiple_values_setting(self) -> Optional[pulumi.Input['BotMultipleValuesSettingArgs']]:
        return pulumi.get(self, "multiple_values_setting")

    @multiple_values_setting.setter
    def multiple_values_setting(self, value: Optional[pulumi.Input['BotMultipleValuesSettingArgs']]):
        pulumi.set(self, "multiple_values_setting", value)

    @property
    @pulumi.getter(name="obfuscationSetting")
    def obfuscation_setting(self) -> Optional[pulumi.Input['BotObfuscationSettingArgs']]:
        return pulumi.get(self, "obfuscation_setting")

    @obfuscation_setting.setter
    def obfuscation_setting(self, value: Optional[pulumi.Input['BotObfuscationSettingArgs']]):
        pulumi.set(self, "obfuscation_setting", value)


@pulumi.input_type
class BotSsmlMessageArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str]):
        """
        A message in Speech Synthesis Markup Language (SSML).
        :param pulumi.Input[str] value: The SSML text that defines the prompt.
        """
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The SSML text that defines the prompt.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class BotStillWaitingResponseSpecificationArgs:
    def __init__(__self__, *,
                 frequency_in_seconds: pulumi.Input[int],
                 message_groups_list: pulumi.Input[Sequence[pulumi.Input['BotMessageGroupArgs']]],
                 timeout_in_seconds: pulumi.Input[int],
                 allow_interrupt: Optional[pulumi.Input[bool]] = None):
        """
        StillWaitingResponseSpecification.
        :param pulumi.Input[bool] allow_interrupt: Indicates whether the user can interrupt a speech prompt from the bot.
        """
        pulumi.set(__self__, "frequency_in_seconds", frequency_in_seconds)
        pulumi.set(__self__, "message_groups_list", message_groups_list)
        pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)
        if allow_interrupt is not None:
            pulumi.set(__self__, "allow_interrupt", allow_interrupt)

    @property
    @pulumi.getter(name="frequencyInSeconds")
    def frequency_in_seconds(self) -> pulumi.Input[int]:
        return pulumi.get(self, "frequency_in_seconds")

    @frequency_in_seconds.setter
    def frequency_in_seconds(self, value: pulumi.Input[int]):
        pulumi.set(self, "frequency_in_seconds", value)

    @property
    @pulumi.getter(name="messageGroupsList")
    def message_groups_list(self) -> pulumi.Input[Sequence[pulumi.Input['BotMessageGroupArgs']]]:
        return pulumi.get(self, "message_groups_list")

    @message_groups_list.setter
    def message_groups_list(self, value: pulumi.Input[Sequence[pulumi.Input['BotMessageGroupArgs']]]):
        pulumi.set(self, "message_groups_list", value)

    @property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> pulumi.Input[int]:
        return pulumi.get(self, "timeout_in_seconds")

    @timeout_in_seconds.setter
    def timeout_in_seconds(self, value: pulumi.Input[int]):
        pulumi.set(self, "timeout_in_seconds", value)

    @property
    @pulumi.getter(name="allowInterrupt")
    def allow_interrupt(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the user can interrupt a speech prompt from the bot.
        """
        return pulumi.get(self, "allow_interrupt")

    @allow_interrupt.setter
    def allow_interrupt(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_interrupt", value)


@pulumi.input_type
class BotTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        A key-value pair for tagging Lex resources
        :param pulumi.Input[str] key: The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        :param pulumi.Input[str] value: The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class BotTestBotAliasSettingsSentimentAnalysisSettingsPropertiesArgs:
    def __init__(__self__, *,
                 detect_sentiment: pulumi.Input[bool]):
        """
        Determines whether Amazon Lex will use Amazon Comprehend to detect the sentiment of user utterances.
        :param pulumi.Input[bool] detect_sentiment: Enable to call Amazon Comprehend for Sentiment natively within Lex
        """
        pulumi.set(__self__, "detect_sentiment", detect_sentiment)

    @property
    @pulumi.getter(name="detectSentiment")
    def detect_sentiment(self) -> pulumi.Input[bool]:
        """
        Enable to call Amazon Comprehend for Sentiment natively within Lex
        """
        return pulumi.get(self, "detect_sentiment")

    @detect_sentiment.setter
    def detect_sentiment(self, value: pulumi.Input[bool]):
        pulumi.set(self, "detect_sentiment", value)


@pulumi.input_type
class BotTestBotAliasSettingsArgs:
    def __init__(__self__, *,
                 bot_alias_locale_settings: Optional[pulumi.Input[Sequence[pulumi.Input['BotAliasLocaleSettingsItemArgs']]]] = None,
                 conversation_log_settings: Optional[pulumi.Input['BotConversationLogSettingsArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 sentiment_analysis_settings: Optional[pulumi.Input['BotTestBotAliasSettingsSentimentAnalysisSettingsPropertiesArgs']] = None):
        """
        Configuring the test bot alias settings for a given bot
        :param pulumi.Input['BotTestBotAliasSettingsSentimentAnalysisSettingsPropertiesArgs'] sentiment_analysis_settings: Determines whether Amazon Lex will use Amazon Comprehend to detect the sentiment of user utterances.
        """
        if bot_alias_locale_settings is not None:
            pulumi.set(__self__, "bot_alias_locale_settings", bot_alias_locale_settings)
        if conversation_log_settings is not None:
            pulumi.set(__self__, "conversation_log_settings", conversation_log_settings)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if sentiment_analysis_settings is not None:
            pulumi.set(__self__, "sentiment_analysis_settings", sentiment_analysis_settings)

    @property
    @pulumi.getter(name="botAliasLocaleSettings")
    def bot_alias_locale_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BotAliasLocaleSettingsItemArgs']]]]:
        return pulumi.get(self, "bot_alias_locale_settings")

    @bot_alias_locale_settings.setter
    def bot_alias_locale_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BotAliasLocaleSettingsItemArgs']]]]):
        pulumi.set(self, "bot_alias_locale_settings", value)

    @property
    @pulumi.getter(name="conversationLogSettings")
    def conversation_log_settings(self) -> Optional[pulumi.Input['BotConversationLogSettingsArgs']]:
        return pulumi.get(self, "conversation_log_settings")

    @conversation_log_settings.setter
    def conversation_log_settings(self, value: Optional[pulumi.Input['BotConversationLogSettingsArgs']]):
        pulumi.set(self, "conversation_log_settings", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="sentimentAnalysisSettings")
    def sentiment_analysis_settings(self) -> Optional[pulumi.Input['BotTestBotAliasSettingsSentimentAnalysisSettingsPropertiesArgs']]:
        """
        Determines whether Amazon Lex will use Amazon Comprehend to detect the sentiment of user utterances.
        """
        return pulumi.get(self, "sentiment_analysis_settings")

    @sentiment_analysis_settings.setter
    def sentiment_analysis_settings(self, value: Optional[pulumi.Input['BotTestBotAliasSettingsSentimentAnalysisSettingsPropertiesArgs']]):
        pulumi.set(self, "sentiment_analysis_settings", value)


@pulumi.input_type
class BotTextLogDestinationArgs:
    def __init__(__self__, *,
                 cloud_watch: pulumi.Input['BotCloudWatchLogGroupLogDestinationArgs']):
        """
        Defines the Amazon CloudWatch Logs destination log group for conversation text logs.
        """
        pulumi.set(__self__, "cloud_watch", cloud_watch)

    @property
    @pulumi.getter(name="cloudWatch")
    def cloud_watch(self) -> pulumi.Input['BotCloudWatchLogGroupLogDestinationArgs']:
        return pulumi.get(self, "cloud_watch")

    @cloud_watch.setter
    def cloud_watch(self, value: pulumi.Input['BotCloudWatchLogGroupLogDestinationArgs']):
        pulumi.set(self, "cloud_watch", value)


@pulumi.input_type
class BotTextLogSettingArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input['BotTextLogDestinationArgs'],
                 enabled: pulumi.Input[bool]):
        """
        Contains information about code hooks that Amazon Lex calls during a conversation.
        """
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input['BotTextLogDestinationArgs']:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input['BotTextLogDestinationArgs']):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class BotVersionLocaleDetailsArgs:
    def __init__(__self__, *,
                 source_bot_version: pulumi.Input[str]):
        """
        The version of a bot used for a bot locale.
        """
        pulumi.set(__self__, "source_bot_version", source_bot_version)

    @property
    @pulumi.getter(name="sourceBotVersion")
    def source_bot_version(self) -> pulumi.Input[str]:
        return pulumi.get(self, "source_bot_version")

    @source_bot_version.setter
    def source_bot_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_bot_version", value)


@pulumi.input_type
class BotVersionLocaleSpecificationArgs:
    def __init__(__self__, *,
                 bot_version_locale_details: pulumi.Input['BotVersionLocaleDetailsArgs'],
                 locale_id: pulumi.Input[str]):
        pulumi.set(__self__, "bot_version_locale_details", bot_version_locale_details)
        pulumi.set(__self__, "locale_id", locale_id)

    @property
    @pulumi.getter(name="botVersionLocaleDetails")
    def bot_version_locale_details(self) -> pulumi.Input['BotVersionLocaleDetailsArgs']:
        return pulumi.get(self, "bot_version_locale_details")

    @bot_version_locale_details.setter
    def bot_version_locale_details(self, value: pulumi.Input['BotVersionLocaleDetailsArgs']):
        pulumi.set(self, "bot_version_locale_details", value)

    @property
    @pulumi.getter(name="localeId")
    def locale_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "locale_id")

    @locale_id.setter
    def locale_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "locale_id", value)


@pulumi.input_type
class BotVoiceSettingsArgs:
    def __init__(__self__, *,
                 voice_id: pulumi.Input[str],
                 engine: Optional[pulumi.Input['BotVoiceSettingsEngine']] = None):
        """
        Settings for using an Amazon Polly voice to communicate with a user.
        :param pulumi.Input[str] voice_id: The Amazon Polly voice ID that Amazon Lex uses for voice interaction with the user.
        :param pulumi.Input['BotVoiceSettingsEngine'] engine: Indicates the type of Amazon Polly voice that Amazon Lex should use for voice interaction with the user. For more information, see the engine parameter of the SynthesizeSpeech operation in the Amazon Polly developer guide.
        """
        pulumi.set(__self__, "voice_id", voice_id)
        if engine is not None:
            pulumi.set(__self__, "engine", engine)

    @property
    @pulumi.getter(name="voiceId")
    def voice_id(self) -> pulumi.Input[str]:
        """
        The Amazon Polly voice ID that Amazon Lex uses for voice interaction with the user.
        """
        return pulumi.get(self, "voice_id")

    @voice_id.setter
    def voice_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "voice_id", value)

    @property
    @pulumi.getter
    def engine(self) -> Optional[pulumi.Input['BotVoiceSettingsEngine']]:
        """
        Indicates the type of Amazon Polly voice that Amazon Lex should use for voice interaction with the user. For more information, see the engine parameter of the SynthesizeSpeech operation in the Amazon Polly developer guide.
        """
        return pulumi.get(self, "engine")

    @engine.setter
    def engine(self, value: Optional[pulumi.Input['BotVoiceSettingsEngine']]):
        pulumi.set(self, "engine", value)


@pulumi.input_type
class BotWaitAndContinueSpecificationArgs:
    def __init__(__self__, *,
                 continue_response: pulumi.Input['BotResponseSpecificationArgs'],
                 waiting_response: pulumi.Input['BotResponseSpecificationArgs'],
                 is_active: Optional[pulumi.Input[bool]] = None,
                 still_waiting_response: Optional[pulumi.Input['BotStillWaitingResponseSpecificationArgs']] = None):
        """
        The prompts that Amazon Lex uses while a bot is waiting for customer input.
        :param pulumi.Input['BotResponseSpecificationArgs'] continue_response: The response that Amazon Lex sends to indicate that the bot is ready to continue the conversation.
        :param pulumi.Input['BotResponseSpecificationArgs'] waiting_response: The response that Amazon Lex sends to indicate that the bot is waiting for the conversation to continue.
        :param pulumi.Input[bool] is_active: Specifies whether the bot will wait for a user to respond.
        :param pulumi.Input['BotStillWaitingResponseSpecificationArgs'] still_waiting_response: The response that Amazon Lex sends periodically to the user to indicate that the bot is still waiting for input from the user.
        """
        pulumi.set(__self__, "continue_response", continue_response)
        pulumi.set(__self__, "waiting_response", waiting_response)
        if is_active is not None:
            pulumi.set(__self__, "is_active", is_active)
        if still_waiting_response is not None:
            pulumi.set(__self__, "still_waiting_response", still_waiting_response)

    @property
    @pulumi.getter(name="continueResponse")
    def continue_response(self) -> pulumi.Input['BotResponseSpecificationArgs']:
        """
        The response that Amazon Lex sends to indicate that the bot is ready to continue the conversation.
        """
        return pulumi.get(self, "continue_response")

    @continue_response.setter
    def continue_response(self, value: pulumi.Input['BotResponseSpecificationArgs']):
        pulumi.set(self, "continue_response", value)

    @property
    @pulumi.getter(name="waitingResponse")
    def waiting_response(self) -> pulumi.Input['BotResponseSpecificationArgs']:
        """
        The response that Amazon Lex sends to indicate that the bot is waiting for the conversation to continue.
        """
        return pulumi.get(self, "waiting_response")

    @waiting_response.setter
    def waiting_response(self, value: pulumi.Input['BotResponseSpecificationArgs']):
        pulumi.set(self, "waiting_response", value)

    @property
    @pulumi.getter(name="isActive")
    def is_active(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether the bot will wait for a user to respond.
        """
        return pulumi.get(self, "is_active")

    @is_active.setter
    def is_active(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_active", value)

    @property
    @pulumi.getter(name="stillWaitingResponse")
    def still_waiting_response(self) -> Optional[pulumi.Input['BotStillWaitingResponseSpecificationArgs']]:
        """
        The response that Amazon Lex sends periodically to the user to indicate that the bot is still waiting for input from the user.
        """
        return pulumi.get(self, "still_waiting_response")

    @still_waiting_response.setter
    def still_waiting_response(self, value: Optional[pulumi.Input['BotStillWaitingResponseSpecificationArgs']]):
        pulumi.set(self, "still_waiting_response", value)


@pulumi.input_type
class DataPrivacyPropertiesArgs:
    def __init__(__self__, *,
                 child_directed: pulumi.Input[bool]):
        """
        Data privacy setting of the Bot.
        """
        pulumi.set(__self__, "child_directed", child_directed)

    @property
    @pulumi.getter(name="childDirected")
    def child_directed(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "child_directed")

    @child_directed.setter
    def child_directed(self, value: pulumi.Input[bool]):
        pulumi.set(self, "child_directed", value)


@pulumi.input_type
class ResourcePolicyPolicyArgs:
    def __init__(__self__):
        """
        A resource policy to add to the resource. The policy is a JSON structure following the IAM syntax that contains one or more statements that define the policy.
        """
        pass


@pulumi.input_type
class SentimentAnalysisSettingsPropertiesArgs:
    def __init__(__self__, *,
                 detect_sentiment: pulumi.Input[bool]):
        """
        Determines whether Amazon Lex will use Amazon Comprehend to detect the sentiment of user utterances.
        :param pulumi.Input[bool] detect_sentiment: Enable to call Amazon Comprehend for Sentiment natively within Lex
        """
        pulumi.set(__self__, "detect_sentiment", detect_sentiment)

    @property
    @pulumi.getter(name="detectSentiment")
    def detect_sentiment(self) -> pulumi.Input[bool]:
        """
        Enable to call Amazon Comprehend for Sentiment natively within Lex
        """
        return pulumi.get(self, "detect_sentiment")

    @detect_sentiment.setter
    def detect_sentiment(self, value: pulumi.Input[bool]):
        pulumi.set(self, "detect_sentiment", value)


