# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'RecordingConfigurationDestinationConfigurationArgs',
    'RecordingConfigurationDestinationConfigurationArgsDict',
    'RecordingConfigurationRenditionConfigurationArgs',
    'RecordingConfigurationRenditionConfigurationArgsDict',
    'RecordingConfigurationS3DestinationConfigurationArgs',
    'RecordingConfigurationS3DestinationConfigurationArgsDict',
    'RecordingConfigurationThumbnailConfigurationArgs',
    'RecordingConfigurationThumbnailConfigurationArgsDict',
    'StageAutoParticipantRecordingConfigurationArgs',
    'StageAutoParticipantRecordingConfigurationArgsDict',
    'StorageConfigurationS3StorageConfigurationArgs',
    'StorageConfigurationS3StorageConfigurationArgsDict',
    'VideoPropertiesArgs',
    'VideoPropertiesArgsDict',
]

MYPY = False

if not MYPY:
    class RecordingConfigurationDestinationConfigurationArgsDict(TypedDict):
        """
        Recording Destination Configuration.
        """
        s3: NotRequired[pulumi.Input['RecordingConfigurationS3DestinationConfigurationArgsDict']]
        """
        An S3 destination configuration where recorded videos will be stored. See the [S3DestinationConfiguration](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ivs-recordingconfiguration-s3destinationconfiguration.html) property type for more information.
        """
elif False:
    RecordingConfigurationDestinationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordingConfigurationDestinationConfigurationArgs:
    def __init__(__self__, *,
                 s3: Optional[pulumi.Input['RecordingConfigurationS3DestinationConfigurationArgs']] = None):
        """
        Recording Destination Configuration.
        :param pulumi.Input['RecordingConfigurationS3DestinationConfigurationArgs'] s3: An S3 destination configuration where recorded videos will be stored. See the [S3DestinationConfiguration](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ivs-recordingconfiguration-s3destinationconfiguration.html) property type for more information.
        """
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['RecordingConfigurationS3DestinationConfigurationArgs']]:
        """
        An S3 destination configuration where recorded videos will be stored. See the [S3DestinationConfiguration](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ivs-recordingconfiguration-s3destinationconfiguration.html) property type for more information.
        """
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['RecordingConfigurationS3DestinationConfigurationArgs']]):
        pulumi.set(self, "s3", value)


if not MYPY:
    class RecordingConfigurationRenditionConfigurationArgsDict(TypedDict):
        """
        Rendition Configuration describes which renditions should be recorded for a stream.
        """
        rendition_selection: NotRequired[pulumi.Input['RecordingConfigurationRenditionConfigurationRenditionSelection']]
        """
        Resolution Selection indicates which set of renditions are recorded for a stream.
        """
        renditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['RecordingConfigurationRenditionConfigurationRenditionsItem']]]]
        """
        Renditions indicates which renditions are recorded for a stream.
        """
elif False:
    RecordingConfigurationRenditionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordingConfigurationRenditionConfigurationArgs:
    def __init__(__self__, *,
                 rendition_selection: Optional[pulumi.Input['RecordingConfigurationRenditionConfigurationRenditionSelection']] = None,
                 renditions: Optional[pulumi.Input[Sequence[pulumi.Input['RecordingConfigurationRenditionConfigurationRenditionsItem']]]] = None):
        """
        Rendition Configuration describes which renditions should be recorded for a stream.
        :param pulumi.Input['RecordingConfigurationRenditionConfigurationRenditionSelection'] rendition_selection: Resolution Selection indicates which set of renditions are recorded for a stream.
        :param pulumi.Input[Sequence[pulumi.Input['RecordingConfigurationRenditionConfigurationRenditionsItem']]] renditions: Renditions indicates which renditions are recorded for a stream.
        """
        if rendition_selection is not None:
            pulumi.set(__self__, "rendition_selection", rendition_selection)
        if renditions is not None:
            pulumi.set(__self__, "renditions", renditions)

    @property
    @pulumi.getter(name="renditionSelection")
    def rendition_selection(self) -> Optional[pulumi.Input['RecordingConfigurationRenditionConfigurationRenditionSelection']]:
        """
        Resolution Selection indicates which set of renditions are recorded for a stream.
        """
        return pulumi.get(self, "rendition_selection")

    @rendition_selection.setter
    def rendition_selection(self, value: Optional[pulumi.Input['RecordingConfigurationRenditionConfigurationRenditionSelection']]):
        pulumi.set(self, "rendition_selection", value)

    @property
    @pulumi.getter
    def renditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RecordingConfigurationRenditionConfigurationRenditionsItem']]]]:
        """
        Renditions indicates which renditions are recorded for a stream.
        """
        return pulumi.get(self, "renditions")

    @renditions.setter
    def renditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RecordingConfigurationRenditionConfigurationRenditionsItem']]]]):
        pulumi.set(self, "renditions", value)


if not MYPY:
    class RecordingConfigurationS3DestinationConfigurationArgsDict(TypedDict):
        """
        Recording S3 Destination Configuration.
        """
        bucket_name: pulumi.Input[str]
        """
        Location (S3 bucket name) where recorded videos will be stored.
        """
elif False:
    RecordingConfigurationS3DestinationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordingConfigurationS3DestinationConfigurationArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[str]):
        """
        Recording S3 Destination Configuration.
        :param pulumi.Input[str] bucket_name: Location (S3 bucket name) where recorded videos will be stored.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[str]:
        """
        Location (S3 bucket name) where recorded videos will be stored.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket_name", value)


if not MYPY:
    class RecordingConfigurationThumbnailConfigurationArgsDict(TypedDict):
        """
        Recording Thumbnail Configuration.
        """
        recording_mode: NotRequired[pulumi.Input['RecordingConfigurationThumbnailConfigurationRecordingMode']]
        """
        Thumbnail Recording Mode, which determines whether thumbnails are recorded at an interval or are disabled.
        """
        resolution: NotRequired[pulumi.Input['RecordingConfigurationThumbnailConfigurationResolution']]
        """
        Resolution indicates the desired resolution of recorded thumbnails.
        """
        storage: NotRequired[pulumi.Input[Sequence[pulumi.Input['RecordingConfigurationThumbnailConfigurationStorageItem']]]]
        """
        Storage indicates the format in which thumbnails are recorded.
        """
        target_interval_seconds: NotRequired[pulumi.Input[int]]
        """
        Target Interval Seconds defines the interval at which thumbnails are recorded. This field is required if RecordingMode is INTERVAL.
        """
elif False:
    RecordingConfigurationThumbnailConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordingConfigurationThumbnailConfigurationArgs:
    def __init__(__self__, *,
                 recording_mode: Optional[pulumi.Input['RecordingConfigurationThumbnailConfigurationRecordingMode']] = None,
                 resolution: Optional[pulumi.Input['RecordingConfigurationThumbnailConfigurationResolution']] = None,
                 storage: Optional[pulumi.Input[Sequence[pulumi.Input['RecordingConfigurationThumbnailConfigurationStorageItem']]]] = None,
                 target_interval_seconds: Optional[pulumi.Input[int]] = None):
        """
        Recording Thumbnail Configuration.
        :param pulumi.Input['RecordingConfigurationThumbnailConfigurationRecordingMode'] recording_mode: Thumbnail Recording Mode, which determines whether thumbnails are recorded at an interval or are disabled.
        :param pulumi.Input['RecordingConfigurationThumbnailConfigurationResolution'] resolution: Resolution indicates the desired resolution of recorded thumbnails.
        :param pulumi.Input[Sequence[pulumi.Input['RecordingConfigurationThumbnailConfigurationStorageItem']]] storage: Storage indicates the format in which thumbnails are recorded.
        :param pulumi.Input[int] target_interval_seconds: Target Interval Seconds defines the interval at which thumbnails are recorded. This field is required if RecordingMode is INTERVAL.
        """
        if recording_mode is not None:
            pulumi.set(__self__, "recording_mode", recording_mode)
        if resolution is not None:
            pulumi.set(__self__, "resolution", resolution)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)
        if target_interval_seconds is not None:
            pulumi.set(__self__, "target_interval_seconds", target_interval_seconds)

    @property
    @pulumi.getter(name="recordingMode")
    def recording_mode(self) -> Optional[pulumi.Input['RecordingConfigurationThumbnailConfigurationRecordingMode']]:
        """
        Thumbnail Recording Mode, which determines whether thumbnails are recorded at an interval or are disabled.
        """
        return pulumi.get(self, "recording_mode")

    @recording_mode.setter
    def recording_mode(self, value: Optional[pulumi.Input['RecordingConfigurationThumbnailConfigurationRecordingMode']]):
        pulumi.set(self, "recording_mode", value)

    @property
    @pulumi.getter
    def resolution(self) -> Optional[pulumi.Input['RecordingConfigurationThumbnailConfigurationResolution']]:
        """
        Resolution indicates the desired resolution of recorded thumbnails.
        """
        return pulumi.get(self, "resolution")

    @resolution.setter
    def resolution(self, value: Optional[pulumi.Input['RecordingConfigurationThumbnailConfigurationResolution']]):
        pulumi.set(self, "resolution", value)

    @property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RecordingConfigurationThumbnailConfigurationStorageItem']]]]:
        """
        Storage indicates the format in which thumbnails are recorded.
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RecordingConfigurationThumbnailConfigurationStorageItem']]]]):
        pulumi.set(self, "storage", value)

    @property
    @pulumi.getter(name="targetIntervalSeconds")
    def target_interval_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Target Interval Seconds defines the interval at which thumbnails are recorded. This field is required if RecordingMode is INTERVAL.
        """
        return pulumi.get(self, "target_interval_seconds")

    @target_interval_seconds.setter
    def target_interval_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "target_interval_seconds", value)


if not MYPY:
    class StageAutoParticipantRecordingConfigurationArgsDict(TypedDict):
        """
        Configuration object for individual participant recording, to attach to the new stage.
        """
        storage_configuration_arn: pulumi.Input[str]
        """
        ARN of the StorageConfiguration resource to use for individual participant recording.
        """
        media_types: NotRequired[pulumi.Input[Sequence[pulumi.Input['StageAutoParticipantRecordingConfigurationMediaTypesItem']]]]
        """
        Types of media to be recorded. Default: AUDIO_VIDEO.
        """
elif False:
    StageAutoParticipantRecordingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StageAutoParticipantRecordingConfigurationArgs:
    def __init__(__self__, *,
                 storage_configuration_arn: pulumi.Input[str],
                 media_types: Optional[pulumi.Input[Sequence[pulumi.Input['StageAutoParticipantRecordingConfigurationMediaTypesItem']]]] = None):
        """
        Configuration object for individual participant recording, to attach to the new stage.
        :param pulumi.Input[str] storage_configuration_arn: ARN of the StorageConfiguration resource to use for individual participant recording.
        :param pulumi.Input[Sequence[pulumi.Input['StageAutoParticipantRecordingConfigurationMediaTypesItem']]] media_types: Types of media to be recorded. Default: AUDIO_VIDEO.
        """
        pulumi.set(__self__, "storage_configuration_arn", storage_configuration_arn)
        if media_types is not None:
            pulumi.set(__self__, "media_types", media_types)

    @property
    @pulumi.getter(name="storageConfigurationArn")
    def storage_configuration_arn(self) -> pulumi.Input[str]:
        """
        ARN of the StorageConfiguration resource to use for individual participant recording.
        """
        return pulumi.get(self, "storage_configuration_arn")

    @storage_configuration_arn.setter
    def storage_configuration_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_configuration_arn", value)

    @property
    @pulumi.getter(name="mediaTypes")
    def media_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StageAutoParticipantRecordingConfigurationMediaTypesItem']]]]:
        """
        Types of media to be recorded. Default: AUDIO_VIDEO.
        """
        return pulumi.get(self, "media_types")

    @media_types.setter
    def media_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StageAutoParticipantRecordingConfigurationMediaTypesItem']]]]):
        pulumi.set(self, "media_types", value)


if not MYPY:
    class StorageConfigurationS3StorageConfigurationArgsDict(TypedDict):
        """
        A complex type that describes an S3 location where recorded videos will be stored.
        """
        bucket_name: pulumi.Input[str]
        """
        Location (S3 bucket name) where recorded videos will be stored. Note that the StorageConfiguration and S3 bucket must be in the same region as the Composition.
        """
elif False:
    StorageConfigurationS3StorageConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageConfigurationS3StorageConfigurationArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[str]):
        """
        A complex type that describes an S3 location where recorded videos will be stored.
        :param pulumi.Input[str] bucket_name: Location (S3 bucket name) where recorded videos will be stored. Note that the StorageConfiguration and S3 bucket must be in the same region as the Composition.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[str]:
        """
        Location (S3 bucket name) where recorded videos will be stored. Note that the StorageConfiguration and S3 bucket must be in the same region as the Composition.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket_name", value)


if not MYPY:
    class VideoPropertiesArgsDict(TypedDict):
        """
        Video configuration. Default: video resolution 1280x720, bitrate 2500 kbps, 30 fps
        """
        bitrate: NotRequired[pulumi.Input[int]]
        """
        Bitrate for generated output, in bps. Default: 2500000.
        """
        framerate: NotRequired[pulumi.Input[float]]
        """
        Video frame rate, in fps. Default: 30.
        """
        height: NotRequired[pulumi.Input[int]]
        """
        Video-resolution height. This must be an even number. Note that the maximum value is determined by width times height, such that the maximum total pixels is 2073600 (1920x1080 or 1080x1920). Default: 720.
        """
        width: NotRequired[pulumi.Input[int]]
        """
        Video-resolution width. This must be an even number. Note that the maximum value is determined by width times height, such that the maximum total pixels is 2073600 (1920x1080 or 1080x1920). Default: 1280.
        """
elif False:
    VideoPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VideoPropertiesArgs:
    def __init__(__self__, *,
                 bitrate: Optional[pulumi.Input[int]] = None,
                 framerate: Optional[pulumi.Input[float]] = None,
                 height: Optional[pulumi.Input[int]] = None,
                 width: Optional[pulumi.Input[int]] = None):
        """
        Video configuration. Default: video resolution 1280x720, bitrate 2500 kbps, 30 fps
        :param pulumi.Input[int] bitrate: Bitrate for generated output, in bps. Default: 2500000.
        :param pulumi.Input[float] framerate: Video frame rate, in fps. Default: 30.
        :param pulumi.Input[int] height: Video-resolution height. This must be an even number. Note that the maximum value is determined by width times height, such that the maximum total pixels is 2073600 (1920x1080 or 1080x1920). Default: 720.
        :param pulumi.Input[int] width: Video-resolution width. This must be an even number. Note that the maximum value is determined by width times height, such that the maximum total pixels is 2073600 (1920x1080 or 1080x1920). Default: 1280.
        """
        if bitrate is not None:
            pulumi.set(__self__, "bitrate", bitrate)
        if framerate is not None:
            pulumi.set(__self__, "framerate", framerate)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[pulumi.Input[int]]:
        """
        Bitrate for generated output, in bps. Default: 2500000.
        """
        return pulumi.get(self, "bitrate")

    @bitrate.setter
    def bitrate(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bitrate", value)

    @property
    @pulumi.getter
    def framerate(self) -> Optional[pulumi.Input[float]]:
        """
        Video frame rate, in fps. Default: 30.
        """
        return pulumi.get(self, "framerate")

    @framerate.setter
    def framerate(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "framerate", value)

    @property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[int]]:
        """
        Video-resolution height. This must be an even number. Note that the maximum value is determined by width times height, such that the maximum total pixels is 2073600 (1920x1080 or 1080x1920). Default: 720.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "height", value)

    @property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[int]]:
        """
        Video-resolution width. This must be an even number. Note that the maximum value is determined by width times height, such that the maximum total pixels is 2073600 (1920x1080 or 1080x1920). Default: 1280.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "width", value)


