# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'ChannelMultitrackInputConfigurationArgs',
    'ChannelMultitrackInputConfigurationArgsDict',
    'RecordingConfigurationDestinationConfigurationArgs',
    'RecordingConfigurationDestinationConfigurationArgsDict',
    'RecordingConfigurationRenditionConfigurationArgs',
    'RecordingConfigurationRenditionConfigurationArgsDict',
    'RecordingConfigurationS3DestinationConfigurationArgs',
    'RecordingConfigurationS3DestinationConfigurationArgsDict',
    'RecordingConfigurationThumbnailConfigurationArgs',
    'RecordingConfigurationThumbnailConfigurationArgsDict',
    'StageAutoParticipantRecordingConfigurationArgs',
    'StageAutoParticipantRecordingConfigurationArgsDict',
    'StageHlsConfigurationArgs',
    'StageHlsConfigurationArgsDict',
    'StageParticipantRecordingHlsConfigurationArgs',
    'StageParticipantRecordingHlsConfigurationArgsDict',
    'StageThumbnailConfigurationParticipantThumbnailConfigurationPropertiesArgs',
    'StageThumbnailConfigurationParticipantThumbnailConfigurationPropertiesArgsDict',
    'StageThumbnailConfigurationArgs',
    'StageThumbnailConfigurationArgsDict',
    'StorageConfigurationS3StorageConfigurationArgs',
    'StorageConfigurationS3StorageConfigurationArgsDict',
    'VideoPropertiesArgs',
    'VideoPropertiesArgsDict',
]

MYPY = False

if not MYPY:
    class ChannelMultitrackInputConfigurationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether multitrack input is enabled. Can be set to true only if channel type is STANDARD. Setting enabled to true with any other channel type will cause an exception. If true, then policy, maximumResolution, and containerFormat are required, and containerFormat must be set to FRAGMENTED_MP4. Default: false.
        """
        maximum_resolution: NotRequired[pulumi.Input['ChannelMultitrackInputConfigurationMaximumResolution']]
        """
        Maximum resolution for multitrack input. Required if enabled is true.
        """
        policy: NotRequired[pulumi.Input['ChannelMultitrackInputConfigurationPolicy']]
        """
        Indicates whether multitrack input is allowed or required. Required if enabled is true.
        """
elif False:
    ChannelMultitrackInputConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChannelMultitrackInputConfigurationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 maximum_resolution: Optional[pulumi.Input['ChannelMultitrackInputConfigurationMaximumResolution']] = None,
                 policy: Optional[pulumi.Input['ChannelMultitrackInputConfigurationPolicy']] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Indicates whether multitrack input is enabled. Can be set to true only if channel type is STANDARD. Setting enabled to true with any other channel type will cause an exception. If true, then policy, maximumResolution, and containerFormat are required, and containerFormat must be set to FRAGMENTED_MP4. Default: false.
        :param pulumi.Input['ChannelMultitrackInputConfigurationMaximumResolution'] maximum_resolution: Maximum resolution for multitrack input. Required if enabled is true.
        :param pulumi.Input['ChannelMultitrackInputConfigurationPolicy'] policy: Indicates whether multitrack input is allowed or required. Required if enabled is true.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if maximum_resolution is not None:
            pulumi.set(__self__, "maximum_resolution", maximum_resolution)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether multitrack input is enabled. Can be set to true only if channel type is STANDARD. Setting enabled to true with any other channel type will cause an exception. If true, then policy, maximumResolution, and containerFormat are required, and containerFormat must be set to FRAGMENTED_MP4. Default: false.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="maximumResolution")
    def maximum_resolution(self) -> Optional[pulumi.Input['ChannelMultitrackInputConfigurationMaximumResolution']]:
        """
        Maximum resolution for multitrack input. Required if enabled is true.
        """
        return pulumi.get(self, "maximum_resolution")

    @maximum_resolution.setter
    def maximum_resolution(self, value: Optional[pulumi.Input['ChannelMultitrackInputConfigurationMaximumResolution']]):
        pulumi.set(self, "maximum_resolution", value)

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input['ChannelMultitrackInputConfigurationPolicy']]:
        """
        Indicates whether multitrack input is allowed or required. Required if enabled is true.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input['ChannelMultitrackInputConfigurationPolicy']]):
        pulumi.set(self, "policy", value)


if not MYPY:
    class RecordingConfigurationDestinationConfigurationArgsDict(TypedDict):
        """
        Recording Destination Configuration.
        """
        s3: NotRequired[pulumi.Input['RecordingConfigurationS3DestinationConfigurationArgsDict']]
        """
        An S3 destination configuration where recorded videos will be stored. See the [S3DestinationConfiguration](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ivs-recordingconfiguration-s3destinationconfiguration.html) property type for more information.
        """
elif False:
    RecordingConfigurationDestinationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordingConfigurationDestinationConfigurationArgs:
    def __init__(__self__, *,
                 s3: Optional[pulumi.Input['RecordingConfigurationS3DestinationConfigurationArgs']] = None):
        """
        Recording Destination Configuration.
        :param pulumi.Input['RecordingConfigurationS3DestinationConfigurationArgs'] s3: An S3 destination configuration where recorded videos will be stored. See the [S3DestinationConfiguration](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ivs-recordingconfiguration-s3destinationconfiguration.html) property type for more information.
        """
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['RecordingConfigurationS3DestinationConfigurationArgs']]:
        """
        An S3 destination configuration where recorded videos will be stored. See the [S3DestinationConfiguration](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ivs-recordingconfiguration-s3destinationconfiguration.html) property type for more information.
        """
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['RecordingConfigurationS3DestinationConfigurationArgs']]):
        pulumi.set(self, "s3", value)


if not MYPY:
    class RecordingConfigurationRenditionConfigurationArgsDict(TypedDict):
        """
        Rendition Configuration describes which renditions should be recorded for a stream.
        """
        rendition_selection: NotRequired[pulumi.Input['RecordingConfigurationRenditionConfigurationRenditionSelection']]
        """
        Resolution Selection indicates which set of renditions are recorded for a stream.
        """
        renditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['RecordingConfigurationRenditionConfigurationRenditionsItem']]]]
        """
        Renditions indicates which renditions are recorded for a stream.
        """
elif False:
    RecordingConfigurationRenditionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordingConfigurationRenditionConfigurationArgs:
    def __init__(__self__, *,
                 rendition_selection: Optional[pulumi.Input['RecordingConfigurationRenditionConfigurationRenditionSelection']] = None,
                 renditions: Optional[pulumi.Input[Sequence[pulumi.Input['RecordingConfigurationRenditionConfigurationRenditionsItem']]]] = None):
        """
        Rendition Configuration describes which renditions should be recorded for a stream.
        :param pulumi.Input['RecordingConfigurationRenditionConfigurationRenditionSelection'] rendition_selection: Resolution Selection indicates which set of renditions are recorded for a stream.
        :param pulumi.Input[Sequence[pulumi.Input['RecordingConfigurationRenditionConfigurationRenditionsItem']]] renditions: Renditions indicates which renditions are recorded for a stream.
        """
        if rendition_selection is not None:
            pulumi.set(__self__, "rendition_selection", rendition_selection)
        if renditions is not None:
            pulumi.set(__self__, "renditions", renditions)

    @_builtins.property
    @pulumi.getter(name="renditionSelection")
    def rendition_selection(self) -> Optional[pulumi.Input['RecordingConfigurationRenditionConfigurationRenditionSelection']]:
        """
        Resolution Selection indicates which set of renditions are recorded for a stream.
        """
        return pulumi.get(self, "rendition_selection")

    @rendition_selection.setter
    def rendition_selection(self, value: Optional[pulumi.Input['RecordingConfigurationRenditionConfigurationRenditionSelection']]):
        pulumi.set(self, "rendition_selection", value)

    @_builtins.property
    @pulumi.getter
    def renditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RecordingConfigurationRenditionConfigurationRenditionsItem']]]]:
        """
        Renditions indicates which renditions are recorded for a stream.
        """
        return pulumi.get(self, "renditions")

    @renditions.setter
    def renditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RecordingConfigurationRenditionConfigurationRenditionsItem']]]]):
        pulumi.set(self, "renditions", value)


if not MYPY:
    class RecordingConfigurationS3DestinationConfigurationArgsDict(TypedDict):
        """
        Recording S3 Destination Configuration.
        """
        bucket_name: pulumi.Input[_builtins.str]
        """
        Location (S3 bucket name) where recorded videos will be stored.
        """
elif False:
    RecordingConfigurationS3DestinationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordingConfigurationS3DestinationConfigurationArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[_builtins.str]):
        """
        Recording S3 Destination Configuration.
        :param pulumi.Input[_builtins.str] bucket_name: Location (S3 bucket name) where recorded videos will be stored.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[_builtins.str]:
        """
        Location (S3 bucket name) where recorded videos will be stored.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_name", value)


if not MYPY:
    class RecordingConfigurationThumbnailConfigurationArgsDict(TypedDict):
        """
        Recording Thumbnail Configuration.
        """
        recording_mode: NotRequired[pulumi.Input['RecordingConfigurationThumbnailConfigurationRecordingMode']]
        """
        Thumbnail Recording Mode, which determines whether thumbnails are recorded at an interval or are disabled.
        """
        resolution: NotRequired[pulumi.Input['RecordingConfigurationThumbnailConfigurationResolution']]
        """
        Resolution indicates the desired resolution of recorded thumbnails.
        """
        storage: NotRequired[pulumi.Input[Sequence[pulumi.Input['RecordingConfigurationThumbnailConfigurationStorageItem']]]]
        """
        Storage indicates the format in which thumbnails are recorded.
        """
        target_interval_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Target Interval Seconds defines the interval at which thumbnails are recorded. This field is required if RecordingMode is INTERVAL.
        """
elif False:
    RecordingConfigurationThumbnailConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecordingConfigurationThumbnailConfigurationArgs:
    def __init__(__self__, *,
                 recording_mode: Optional[pulumi.Input['RecordingConfigurationThumbnailConfigurationRecordingMode']] = None,
                 resolution: Optional[pulumi.Input['RecordingConfigurationThumbnailConfigurationResolution']] = None,
                 storage: Optional[pulumi.Input[Sequence[pulumi.Input['RecordingConfigurationThumbnailConfigurationStorageItem']]]] = None,
                 target_interval_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        Recording Thumbnail Configuration.
        :param pulumi.Input['RecordingConfigurationThumbnailConfigurationRecordingMode'] recording_mode: Thumbnail Recording Mode, which determines whether thumbnails are recorded at an interval or are disabled.
        :param pulumi.Input['RecordingConfigurationThumbnailConfigurationResolution'] resolution: Resolution indicates the desired resolution of recorded thumbnails.
        :param pulumi.Input[Sequence[pulumi.Input['RecordingConfigurationThumbnailConfigurationStorageItem']]] storage: Storage indicates the format in which thumbnails are recorded.
        :param pulumi.Input[_builtins.int] target_interval_seconds: Target Interval Seconds defines the interval at which thumbnails are recorded. This field is required if RecordingMode is INTERVAL.
        """
        if recording_mode is not None:
            pulumi.set(__self__, "recording_mode", recording_mode)
        if resolution is not None:
            pulumi.set(__self__, "resolution", resolution)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)
        if target_interval_seconds is not None:
            pulumi.set(__self__, "target_interval_seconds", target_interval_seconds)

    @_builtins.property
    @pulumi.getter(name="recordingMode")
    def recording_mode(self) -> Optional[pulumi.Input['RecordingConfigurationThumbnailConfigurationRecordingMode']]:
        """
        Thumbnail Recording Mode, which determines whether thumbnails are recorded at an interval or are disabled.
        """
        return pulumi.get(self, "recording_mode")

    @recording_mode.setter
    def recording_mode(self, value: Optional[pulumi.Input['RecordingConfigurationThumbnailConfigurationRecordingMode']]):
        pulumi.set(self, "recording_mode", value)

    @_builtins.property
    @pulumi.getter
    def resolution(self) -> Optional[pulumi.Input['RecordingConfigurationThumbnailConfigurationResolution']]:
        """
        Resolution indicates the desired resolution of recorded thumbnails.
        """
        return pulumi.get(self, "resolution")

    @resolution.setter
    def resolution(self, value: Optional[pulumi.Input['RecordingConfigurationThumbnailConfigurationResolution']]):
        pulumi.set(self, "resolution", value)

    @_builtins.property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RecordingConfigurationThumbnailConfigurationStorageItem']]]]:
        """
        Storage indicates the format in which thumbnails are recorded.
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RecordingConfigurationThumbnailConfigurationStorageItem']]]]):
        pulumi.set(self, "storage", value)

    @_builtins.property
    @pulumi.getter(name="targetIntervalSeconds")
    def target_interval_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Target Interval Seconds defines the interval at which thumbnails are recorded. This field is required if RecordingMode is INTERVAL.
        """
        return pulumi.get(self, "target_interval_seconds")

    @target_interval_seconds.setter
    def target_interval_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "target_interval_seconds", value)


if not MYPY:
    class StageAutoParticipantRecordingConfigurationArgsDict(TypedDict):
        """
        Configuration object for individual participant recording, to attach to the new stage.
        """
        storage_configuration_arn: pulumi.Input[_builtins.str]
        """
        ARN of the StorageConfiguration resource to use for individual participant recording.
        """
        hls_configuration: NotRequired[pulumi.Input['StageHlsConfigurationArgsDict']]
        """
        HLS configuration object for individual participant recording.
        """
        media_types: NotRequired[pulumi.Input[Sequence[pulumi.Input['StageAutoParticipantRecordingConfigurationMediaTypesItem']]]]
        """
        Types of media to be recorded. Default: AUDIO_VIDEO.
        """
        recording_reconnect_window_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        If a stage publisher disconnects and then reconnects within the specified interval, the multiple recordings will be considered a single recording and merged together. The default value is 0, which disables merging.
        """
        thumbnail_configuration: NotRequired[pulumi.Input['StageThumbnailConfigurationArgsDict']]
        """
        A complex type that allows you to enable/disable the recording of thumbnails for individual participant recording and modify the interval at which thumbnails are generated for the live session.
        """
elif False:
    StageAutoParticipantRecordingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StageAutoParticipantRecordingConfigurationArgs:
    def __init__(__self__, *,
                 storage_configuration_arn: pulumi.Input[_builtins.str],
                 hls_configuration: Optional[pulumi.Input['StageHlsConfigurationArgs']] = None,
                 media_types: Optional[pulumi.Input[Sequence[pulumi.Input['StageAutoParticipantRecordingConfigurationMediaTypesItem']]]] = None,
                 recording_reconnect_window_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 thumbnail_configuration: Optional[pulumi.Input['StageThumbnailConfigurationArgs']] = None):
        """
        Configuration object for individual participant recording, to attach to the new stage.
        :param pulumi.Input[_builtins.str] storage_configuration_arn: ARN of the StorageConfiguration resource to use for individual participant recording.
        :param pulumi.Input['StageHlsConfigurationArgs'] hls_configuration: HLS configuration object for individual participant recording.
        :param pulumi.Input[Sequence[pulumi.Input['StageAutoParticipantRecordingConfigurationMediaTypesItem']]] media_types: Types of media to be recorded. Default: AUDIO_VIDEO.
        :param pulumi.Input[_builtins.int] recording_reconnect_window_seconds: If a stage publisher disconnects and then reconnects within the specified interval, the multiple recordings will be considered a single recording and merged together. The default value is 0, which disables merging.
        :param pulumi.Input['StageThumbnailConfigurationArgs'] thumbnail_configuration: A complex type that allows you to enable/disable the recording of thumbnails for individual participant recording and modify the interval at which thumbnails are generated for the live session.
        """
        pulumi.set(__self__, "storage_configuration_arn", storage_configuration_arn)
        if hls_configuration is not None:
            pulumi.set(__self__, "hls_configuration", hls_configuration)
        if media_types is not None:
            pulumi.set(__self__, "media_types", media_types)
        if recording_reconnect_window_seconds is not None:
            pulumi.set(__self__, "recording_reconnect_window_seconds", recording_reconnect_window_seconds)
        if thumbnail_configuration is not None:
            pulumi.set(__self__, "thumbnail_configuration", thumbnail_configuration)

    @_builtins.property
    @pulumi.getter(name="storageConfigurationArn")
    def storage_configuration_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the StorageConfiguration resource to use for individual participant recording.
        """
        return pulumi.get(self, "storage_configuration_arn")

    @storage_configuration_arn.setter
    def storage_configuration_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "storage_configuration_arn", value)

    @_builtins.property
    @pulumi.getter(name="hlsConfiguration")
    def hls_configuration(self) -> Optional[pulumi.Input['StageHlsConfigurationArgs']]:
        """
        HLS configuration object for individual participant recording.
        """
        return pulumi.get(self, "hls_configuration")

    @hls_configuration.setter
    def hls_configuration(self, value: Optional[pulumi.Input['StageHlsConfigurationArgs']]):
        pulumi.set(self, "hls_configuration", value)

    @_builtins.property
    @pulumi.getter(name="mediaTypes")
    def media_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StageAutoParticipantRecordingConfigurationMediaTypesItem']]]]:
        """
        Types of media to be recorded. Default: AUDIO_VIDEO.
        """
        return pulumi.get(self, "media_types")

    @media_types.setter
    def media_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StageAutoParticipantRecordingConfigurationMediaTypesItem']]]]):
        pulumi.set(self, "media_types", value)

    @_builtins.property
    @pulumi.getter(name="recordingReconnectWindowSeconds")
    def recording_reconnect_window_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        If a stage publisher disconnects and then reconnects within the specified interval, the multiple recordings will be considered a single recording and merged together. The default value is 0, which disables merging.
        """
        return pulumi.get(self, "recording_reconnect_window_seconds")

    @recording_reconnect_window_seconds.setter
    def recording_reconnect_window_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "recording_reconnect_window_seconds", value)

    @_builtins.property
    @pulumi.getter(name="thumbnailConfiguration")
    def thumbnail_configuration(self) -> Optional[pulumi.Input['StageThumbnailConfigurationArgs']]:
        """
        A complex type that allows you to enable/disable the recording of thumbnails for individual participant recording and modify the interval at which thumbnails are generated for the live session.
        """
        return pulumi.get(self, "thumbnail_configuration")

    @thumbnail_configuration.setter
    def thumbnail_configuration(self, value: Optional[pulumi.Input['StageThumbnailConfigurationArgs']]):
        pulumi.set(self, "thumbnail_configuration", value)


if not MYPY:
    class StageHlsConfigurationArgsDict(TypedDict):
        """
        HLS configuration object for individual participant recording.
        """
        participant_recording_hls_configuration: NotRequired[pulumi.Input['StageParticipantRecordingHlsConfigurationArgsDict']]
        """
        Object specifying a configuration of participant HLS recordings for individual participant recording.
        """
elif False:
    StageHlsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StageHlsConfigurationArgs:
    def __init__(__self__, *,
                 participant_recording_hls_configuration: Optional[pulumi.Input['StageParticipantRecordingHlsConfigurationArgs']] = None):
        """
        HLS configuration object for individual participant recording.
        :param pulumi.Input['StageParticipantRecordingHlsConfigurationArgs'] participant_recording_hls_configuration: Object specifying a configuration of participant HLS recordings for individual participant recording.
        """
        if participant_recording_hls_configuration is not None:
            pulumi.set(__self__, "participant_recording_hls_configuration", participant_recording_hls_configuration)

    @_builtins.property
    @pulumi.getter(name="participantRecordingHlsConfiguration")
    def participant_recording_hls_configuration(self) -> Optional[pulumi.Input['StageParticipantRecordingHlsConfigurationArgs']]:
        """
        Object specifying a configuration of participant HLS recordings for individual participant recording.
        """
        return pulumi.get(self, "participant_recording_hls_configuration")

    @participant_recording_hls_configuration.setter
    def participant_recording_hls_configuration(self, value: Optional[pulumi.Input['StageParticipantRecordingHlsConfigurationArgs']]):
        pulumi.set(self, "participant_recording_hls_configuration", value)


if not MYPY:
    class StageParticipantRecordingHlsConfigurationArgsDict(TypedDict):
        """
        An object representing a configuration of participant HLS recordings for individual participant recording.
        """
        target_segment_duration_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Defines the target duration for recorded segments generated when recording a stage participant. Segments may have durations longer than the specified value when needed to ensure each segment begins with a keyframe. Default: 6.
        """
elif False:
    StageParticipantRecordingHlsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StageParticipantRecordingHlsConfigurationArgs:
    def __init__(__self__, *,
                 target_segment_duration_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        An object representing a configuration of participant HLS recordings for individual participant recording.
        :param pulumi.Input[_builtins.int] target_segment_duration_seconds: Defines the target duration for recorded segments generated when recording a stage participant. Segments may have durations longer than the specified value when needed to ensure each segment begins with a keyframe. Default: 6.
        """
        if target_segment_duration_seconds is not None:
            pulumi.set(__self__, "target_segment_duration_seconds", target_segment_duration_seconds)

    @_builtins.property
    @pulumi.getter(name="targetSegmentDurationSeconds")
    def target_segment_duration_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Defines the target duration for recorded segments generated when recording a stage participant. Segments may have durations longer than the specified value when needed to ensure each segment begins with a keyframe. Default: 6.
        """
        return pulumi.get(self, "target_segment_duration_seconds")

    @target_segment_duration_seconds.setter
    def target_segment_duration_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "target_segment_duration_seconds", value)


if not MYPY:
    class StageThumbnailConfigurationParticipantThumbnailConfigurationPropertiesArgsDict(TypedDict):
        """
        An object representing a configuration of thumbnails for recorded video from an individual participant.
        """
        recording_mode: NotRequired[pulumi.Input['StageThumbnailConfigurationParticipantThumbnailConfigurationPropertiesRecordingMode']]
        """
        Thumbnail recording mode. Default: DISABLED.
        """
        storage: NotRequired[pulumi.Input[Sequence[pulumi.Input['StageThumbnailConfigurationParticipantThumbnailConfigurationPropertiesStorageItem']]]]
        """
        Indicates the format in which thumbnails are recorded. SEQUENTIAL records all generated thumbnails in a serial manner, to the media/thumbnails/high directory. LATEST saves the latest thumbnail in media/latest_thumbnail/high/thumb.jpg and overwrites it at the interval specified by targetIntervalSeconds. You can enable both SEQUENTIAL and LATEST. Default: SEQUENTIAL.
        """
        target_interval_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The targeted thumbnail-generation interval in seconds. This is configurable only if recordingMode is INTERVAL. Default: 60.
        """
elif False:
    StageThumbnailConfigurationParticipantThumbnailConfigurationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StageThumbnailConfigurationParticipantThumbnailConfigurationPropertiesArgs:
    def __init__(__self__, *,
                 recording_mode: Optional[pulumi.Input['StageThumbnailConfigurationParticipantThumbnailConfigurationPropertiesRecordingMode']] = None,
                 storage: Optional[pulumi.Input[Sequence[pulumi.Input['StageThumbnailConfigurationParticipantThumbnailConfigurationPropertiesStorageItem']]]] = None,
                 target_interval_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        An object representing a configuration of thumbnails for recorded video from an individual participant.
        :param pulumi.Input['StageThumbnailConfigurationParticipantThumbnailConfigurationPropertiesRecordingMode'] recording_mode: Thumbnail recording mode. Default: DISABLED.
        :param pulumi.Input[Sequence[pulumi.Input['StageThumbnailConfigurationParticipantThumbnailConfigurationPropertiesStorageItem']]] storage: Indicates the format in which thumbnails are recorded. SEQUENTIAL records all generated thumbnails in a serial manner, to the media/thumbnails/high directory. LATEST saves the latest thumbnail in media/latest_thumbnail/high/thumb.jpg and overwrites it at the interval specified by targetIntervalSeconds. You can enable both SEQUENTIAL and LATEST. Default: SEQUENTIAL.
        :param pulumi.Input[_builtins.int] target_interval_seconds: The targeted thumbnail-generation interval in seconds. This is configurable only if recordingMode is INTERVAL. Default: 60.
        """
        if recording_mode is not None:
            pulumi.set(__self__, "recording_mode", recording_mode)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)
        if target_interval_seconds is not None:
            pulumi.set(__self__, "target_interval_seconds", target_interval_seconds)

    @_builtins.property
    @pulumi.getter(name="recordingMode")
    def recording_mode(self) -> Optional[pulumi.Input['StageThumbnailConfigurationParticipantThumbnailConfigurationPropertiesRecordingMode']]:
        """
        Thumbnail recording mode. Default: DISABLED.
        """
        return pulumi.get(self, "recording_mode")

    @recording_mode.setter
    def recording_mode(self, value: Optional[pulumi.Input['StageThumbnailConfigurationParticipantThumbnailConfigurationPropertiesRecordingMode']]):
        pulumi.set(self, "recording_mode", value)

    @_builtins.property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StageThumbnailConfigurationParticipantThumbnailConfigurationPropertiesStorageItem']]]]:
        """
        Indicates the format in which thumbnails are recorded. SEQUENTIAL records all generated thumbnails in a serial manner, to the media/thumbnails/high directory. LATEST saves the latest thumbnail in media/latest_thumbnail/high/thumb.jpg and overwrites it at the interval specified by targetIntervalSeconds. You can enable both SEQUENTIAL and LATEST. Default: SEQUENTIAL.
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StageThumbnailConfigurationParticipantThumbnailConfigurationPropertiesStorageItem']]]]):
        pulumi.set(self, "storage", value)

    @_builtins.property
    @pulumi.getter(name="targetIntervalSeconds")
    def target_interval_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The targeted thumbnail-generation interval in seconds. This is configurable only if recordingMode is INTERVAL. Default: 60.
        """
        return pulumi.get(self, "target_interval_seconds")

    @target_interval_seconds.setter
    def target_interval_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "target_interval_seconds", value)


if not MYPY:
    class StageThumbnailConfigurationArgsDict(TypedDict):
        """
        A complex type that allows you to enable/disable the recording of thumbnails for individual participant recording and modify the interval at which thumbnails are generated for the live session.
        """
        participant_thumbnail_configuration: NotRequired[pulumi.Input['StageThumbnailConfigurationParticipantThumbnailConfigurationPropertiesArgsDict']]
        """
        An object representing a configuration of thumbnails for recorded video from an individual participant.
        """
elif False:
    StageThumbnailConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StageThumbnailConfigurationArgs:
    def __init__(__self__, *,
                 participant_thumbnail_configuration: Optional[pulumi.Input['StageThumbnailConfigurationParticipantThumbnailConfigurationPropertiesArgs']] = None):
        """
        A complex type that allows you to enable/disable the recording of thumbnails for individual participant recording and modify the interval at which thumbnails are generated for the live session.
        :param pulumi.Input['StageThumbnailConfigurationParticipantThumbnailConfigurationPropertiesArgs'] participant_thumbnail_configuration: An object representing a configuration of thumbnails for recorded video from an individual participant.
        """
        if participant_thumbnail_configuration is not None:
            pulumi.set(__self__, "participant_thumbnail_configuration", participant_thumbnail_configuration)

    @_builtins.property
    @pulumi.getter(name="participantThumbnailConfiguration")
    def participant_thumbnail_configuration(self) -> Optional[pulumi.Input['StageThumbnailConfigurationParticipantThumbnailConfigurationPropertiesArgs']]:
        """
        An object representing a configuration of thumbnails for recorded video from an individual participant.
        """
        return pulumi.get(self, "participant_thumbnail_configuration")

    @participant_thumbnail_configuration.setter
    def participant_thumbnail_configuration(self, value: Optional[pulumi.Input['StageThumbnailConfigurationParticipantThumbnailConfigurationPropertiesArgs']]):
        pulumi.set(self, "participant_thumbnail_configuration", value)


if not MYPY:
    class StorageConfigurationS3StorageConfigurationArgsDict(TypedDict):
        """
        A complex type that describes an S3 location where recorded videos will be stored.
        """
        bucket_name: pulumi.Input[_builtins.str]
        """
        Location (S3 bucket name) where recorded videos will be stored. Note that the StorageConfiguration and S3 bucket must be in the same region as the Composition.
        """
elif False:
    StorageConfigurationS3StorageConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageConfigurationS3StorageConfigurationArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[_builtins.str]):
        """
        A complex type that describes an S3 location where recorded videos will be stored.
        :param pulumi.Input[_builtins.str] bucket_name: Location (S3 bucket name) where recorded videos will be stored. Note that the StorageConfiguration and S3 bucket must be in the same region as the Composition.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[_builtins.str]:
        """
        Location (S3 bucket name) where recorded videos will be stored. Note that the StorageConfiguration and S3 bucket must be in the same region as the Composition.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_name", value)


if not MYPY:
    class VideoPropertiesArgsDict(TypedDict):
        """
        Video configuration. Default: video resolution 1280x720, bitrate 2500 kbps, 30 fps
        """
        bitrate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Bitrate for generated output, in bps. Default: 2500000.
        """
        framerate: NotRequired[pulumi.Input[_builtins.float]]
        """
        Video frame rate, in fps. Default: 30.
        """
        height: NotRequired[pulumi.Input[_builtins.int]]
        """
        Video-resolution height. This must be an even number. Note that the maximum value is determined by width times height, such that the maximum total pixels is 2073600 (1920x1080 or 1080x1920). Default: 720.
        """
        width: NotRequired[pulumi.Input[_builtins.int]]
        """
        Video-resolution width. This must be an even number. Note that the maximum value is determined by width times height, such that the maximum total pixels is 2073600 (1920x1080 or 1080x1920). Default: 1280.
        """
elif False:
    VideoPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VideoPropertiesArgs:
    def __init__(__self__, *,
                 bitrate: Optional[pulumi.Input[_builtins.int]] = None,
                 framerate: Optional[pulumi.Input[_builtins.float]] = None,
                 height: Optional[pulumi.Input[_builtins.int]] = None,
                 width: Optional[pulumi.Input[_builtins.int]] = None):
        """
        Video configuration. Default: video resolution 1280x720, bitrate 2500 kbps, 30 fps
        :param pulumi.Input[_builtins.int] bitrate: Bitrate for generated output, in bps. Default: 2500000.
        :param pulumi.Input[_builtins.float] framerate: Video frame rate, in fps. Default: 30.
        :param pulumi.Input[_builtins.int] height: Video-resolution height. This must be an even number. Note that the maximum value is determined by width times height, such that the maximum total pixels is 2073600 (1920x1080 or 1080x1920). Default: 720.
        :param pulumi.Input[_builtins.int] width: Video-resolution width. This must be an even number. Note that the maximum value is determined by width times height, such that the maximum total pixels is 2073600 (1920x1080 or 1080x1920). Default: 1280.
        """
        if bitrate is not None:
            pulumi.set(__self__, "bitrate", bitrate)
        if framerate is not None:
            pulumi.set(__self__, "framerate", framerate)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @_builtins.property
    @pulumi.getter
    def bitrate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Bitrate for generated output, in bps. Default: 2500000.
        """
        return pulumi.get(self, "bitrate")

    @bitrate.setter
    def bitrate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "bitrate", value)

    @_builtins.property
    @pulumi.getter
    def framerate(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Video frame rate, in fps. Default: 30.
        """
        return pulumi.get(self, "framerate")

    @framerate.setter
    def framerate(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "framerate", value)

    @_builtins.property
    @pulumi.getter
    def height(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Video-resolution height. This must be an even number. Note that the maximum value is determined by width times height, such that the maximum total pixels is 2073600 (1920x1080 or 1080x1920). Default: 720.
        """
        return pulumi.get(self, "height")

    @height.setter
    def height(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "height", value)

    @_builtins.property
    @pulumi.getter
    def width(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Video-resolution width. This must be an even number. Note that the maximum value is determined by width times height, such that the maximum total pixels is 2073600 (1920x1080 or 1080x1920). Default: 1280.
        """
        return pulumi.get(self, "width")

    @width.setter
    def width(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "width", value)


