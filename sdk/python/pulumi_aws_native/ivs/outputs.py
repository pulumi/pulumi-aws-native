# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'ChannelMultitrackInputConfiguration',
    'RecordingConfigurationDestinationConfiguration',
    'RecordingConfigurationRenditionConfiguration',
    'RecordingConfigurationS3DestinationConfiguration',
    'RecordingConfigurationThumbnailConfiguration',
    'StageAutoParticipantRecordingConfiguration',
    'StageAutoParticipantRecordingConfigurationHlsConfigurationProperties',
    'StageAutoParticipantRecordingConfigurationHlsConfigurationPropertiesParticipantRecordingHlsConfigurationProperties',
    'StageAutoParticipantRecordingConfigurationThumbnailConfigurationProperties',
    'StageAutoParticipantRecordingConfigurationThumbnailConfigurationPropertiesParticipantThumbnailConfigurationProperties',
    'StorageConfigurationS3StorageConfiguration',
    'VideoProperties',
]

@pulumi.output_type
class ChannelMultitrackInputConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maximumResolution":
            suggest = "maximum_resolution"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChannelMultitrackInputConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChannelMultitrackInputConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChannelMultitrackInputConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[builtins.bool] = None,
                 maximum_resolution: Optional['ChannelMultitrackInputConfigurationMaximumResolution'] = None,
                 policy: Optional['ChannelMultitrackInputConfigurationPolicy'] = None):
        """
        :param builtins.bool enabled: Indicates whether multitrack input is enabled. Can be set to true only if channel type is STANDARD. Setting enabled to true with any other channel type will cause an exception. If true, then policy, maximumResolution, and containerFormat are required, and containerFormat must be set to FRAGMENTED_MP4. Default: false.
        :param 'ChannelMultitrackInputConfigurationMaximumResolution' maximum_resolution: Maximum resolution for multitrack input. Required if enabled is true.
        :param 'ChannelMultitrackInputConfigurationPolicy' policy: Indicates whether multitrack input is allowed or required. Required if enabled is true.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if maximum_resolution is not None:
            pulumi.set(__self__, "maximum_resolution", maximum_resolution)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        Indicates whether multitrack input is enabled. Can be set to true only if channel type is STANDARD. Setting enabled to true with any other channel type will cause an exception. If true, then policy, maximumResolution, and containerFormat are required, and containerFormat must be set to FRAGMENTED_MP4. Default: false.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="maximumResolution")
    def maximum_resolution(self) -> Optional['ChannelMultitrackInputConfigurationMaximumResolution']:
        """
        Maximum resolution for multitrack input. Required if enabled is true.
        """
        return pulumi.get(self, "maximum_resolution")

    @property
    @pulumi.getter
    def policy(self) -> Optional['ChannelMultitrackInputConfigurationPolicy']:
        """
        Indicates whether multitrack input is allowed or required. Required if enabled is true.
        """
        return pulumi.get(self, "policy")


@pulumi.output_type
class RecordingConfigurationDestinationConfiguration(dict):
    """
    Recording Destination Configuration.
    """
    def __init__(__self__, *,
                 s3: Optional['outputs.RecordingConfigurationS3DestinationConfiguration'] = None):
        """
        Recording Destination Configuration.
        :param 'RecordingConfigurationS3DestinationConfiguration' s3: An S3 destination configuration where recorded videos will be stored. See the [S3DestinationConfiguration](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ivs-recordingconfiguration-s3destinationconfiguration.html) property type for more information.
        """
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @property
    @pulumi.getter
    def s3(self) -> Optional['outputs.RecordingConfigurationS3DestinationConfiguration']:
        """
        An S3 destination configuration where recorded videos will be stored. See the [S3DestinationConfiguration](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ivs-recordingconfiguration-s3destinationconfiguration.html) property type for more information.
        """
        return pulumi.get(self, "s3")


@pulumi.output_type
class RecordingConfigurationRenditionConfiguration(dict):
    """
    Rendition Configuration describes which renditions should be recorded for a stream.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "renditionSelection":
            suggest = "rendition_selection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecordingConfigurationRenditionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecordingConfigurationRenditionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecordingConfigurationRenditionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rendition_selection: Optional['RecordingConfigurationRenditionConfigurationRenditionSelection'] = None,
                 renditions: Optional[Sequence['RecordingConfigurationRenditionConfigurationRenditionsItem']] = None):
        """
        Rendition Configuration describes which renditions should be recorded for a stream.
        :param 'RecordingConfigurationRenditionConfigurationRenditionSelection' rendition_selection: Resolution Selection indicates which set of renditions are recorded for a stream.
        :param Sequence['RecordingConfigurationRenditionConfigurationRenditionsItem'] renditions: Renditions indicates which renditions are recorded for a stream.
        """
        if rendition_selection is not None:
            pulumi.set(__self__, "rendition_selection", rendition_selection)
        if renditions is not None:
            pulumi.set(__self__, "renditions", renditions)

    @property
    @pulumi.getter(name="renditionSelection")
    def rendition_selection(self) -> Optional['RecordingConfigurationRenditionConfigurationRenditionSelection']:
        """
        Resolution Selection indicates which set of renditions are recorded for a stream.
        """
        return pulumi.get(self, "rendition_selection")

    @property
    @pulumi.getter
    def renditions(self) -> Optional[Sequence['RecordingConfigurationRenditionConfigurationRenditionsItem']]:
        """
        Renditions indicates which renditions are recorded for a stream.
        """
        return pulumi.get(self, "renditions")


@pulumi.output_type
class RecordingConfigurationS3DestinationConfiguration(dict):
    """
    Recording S3 Destination Configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecordingConfigurationS3DestinationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecordingConfigurationS3DestinationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecordingConfigurationS3DestinationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: builtins.str):
        """
        Recording S3 Destination Configuration.
        :param builtins.str bucket_name: Location (S3 bucket name) where recorded videos will be stored.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> builtins.str:
        """
        Location (S3 bucket name) where recorded videos will be stored.
        """
        return pulumi.get(self, "bucket_name")


@pulumi.output_type
class RecordingConfigurationThumbnailConfiguration(dict):
    """
    Recording Thumbnail Configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recordingMode":
            suggest = "recording_mode"
        elif key == "targetIntervalSeconds":
            suggest = "target_interval_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecordingConfigurationThumbnailConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecordingConfigurationThumbnailConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecordingConfigurationThumbnailConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 recording_mode: Optional['RecordingConfigurationThumbnailConfigurationRecordingMode'] = None,
                 resolution: Optional['RecordingConfigurationThumbnailConfigurationResolution'] = None,
                 storage: Optional[Sequence['RecordingConfigurationThumbnailConfigurationStorageItem']] = None,
                 target_interval_seconds: Optional[builtins.int] = None):
        """
        Recording Thumbnail Configuration.
        :param 'RecordingConfigurationThumbnailConfigurationRecordingMode' recording_mode: Thumbnail Recording Mode, which determines whether thumbnails are recorded at an interval or are disabled.
        :param 'RecordingConfigurationThumbnailConfigurationResolution' resolution: Resolution indicates the desired resolution of recorded thumbnails.
        :param Sequence['RecordingConfigurationThumbnailConfigurationStorageItem'] storage: Storage indicates the format in which thumbnails are recorded.
        :param builtins.int target_interval_seconds: Target Interval Seconds defines the interval at which thumbnails are recorded. This field is required if RecordingMode is INTERVAL.
        """
        if recording_mode is not None:
            pulumi.set(__self__, "recording_mode", recording_mode)
        if resolution is not None:
            pulumi.set(__self__, "resolution", resolution)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)
        if target_interval_seconds is not None:
            pulumi.set(__self__, "target_interval_seconds", target_interval_seconds)

    @property
    @pulumi.getter(name="recordingMode")
    def recording_mode(self) -> Optional['RecordingConfigurationThumbnailConfigurationRecordingMode']:
        """
        Thumbnail Recording Mode, which determines whether thumbnails are recorded at an interval or are disabled.
        """
        return pulumi.get(self, "recording_mode")

    @property
    @pulumi.getter
    def resolution(self) -> Optional['RecordingConfigurationThumbnailConfigurationResolution']:
        """
        Resolution indicates the desired resolution of recorded thumbnails.
        """
        return pulumi.get(self, "resolution")

    @property
    @pulumi.getter
    def storage(self) -> Optional[Sequence['RecordingConfigurationThumbnailConfigurationStorageItem']]:
        """
        Storage indicates the format in which thumbnails are recorded.
        """
        return pulumi.get(self, "storage")

    @property
    @pulumi.getter(name="targetIntervalSeconds")
    def target_interval_seconds(self) -> Optional[builtins.int]:
        """
        Target Interval Seconds defines the interval at which thumbnails are recorded. This field is required if RecordingMode is INTERVAL.
        """
        return pulumi.get(self, "target_interval_seconds")


@pulumi.output_type
class StageAutoParticipantRecordingConfiguration(dict):
    """
    Configuration object for individual participant recording, to attach to the new stage.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageConfigurationArn":
            suggest = "storage_configuration_arn"
        elif key == "hlsConfiguration":
            suggest = "hls_configuration"
        elif key == "mediaTypes":
            suggest = "media_types"
        elif key == "recordingReconnectWindowSeconds":
            suggest = "recording_reconnect_window_seconds"
        elif key == "thumbnailConfiguration":
            suggest = "thumbnail_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StageAutoParticipantRecordingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StageAutoParticipantRecordingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StageAutoParticipantRecordingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 storage_configuration_arn: builtins.str,
                 hls_configuration: Optional['outputs.StageAutoParticipantRecordingConfigurationHlsConfigurationProperties'] = None,
                 media_types: Optional[Sequence['StageAutoParticipantRecordingConfigurationMediaTypesItem']] = None,
                 recording_reconnect_window_seconds: Optional[builtins.int] = None,
                 thumbnail_configuration: Optional['outputs.StageAutoParticipantRecordingConfigurationThumbnailConfigurationProperties'] = None):
        """
        Configuration object for individual participant recording, to attach to the new stage.
        :param builtins.str storage_configuration_arn: ARN of the StorageConfiguration resource to use for individual participant recording.
        :param 'StageAutoParticipantRecordingConfigurationHlsConfigurationProperties' hls_configuration: HLS configuration object for individual participant recording.
        :param Sequence['StageAutoParticipantRecordingConfigurationMediaTypesItem'] media_types: Types of media to be recorded. Default: AUDIO_VIDEO.
        :param builtins.int recording_reconnect_window_seconds: If a stage publisher disconnects and then reconnects within the specified interval, the multiple recordings will be considered a single recording and merged together. The default value is 0, which disables merging.
        :param 'StageAutoParticipantRecordingConfigurationThumbnailConfigurationProperties' thumbnail_configuration: A complex type that allows you to enable/disable the recording of thumbnails for individual participant recording and modify the interval at which thumbnails are generated for the live session.
        """
        pulumi.set(__self__, "storage_configuration_arn", storage_configuration_arn)
        if hls_configuration is not None:
            pulumi.set(__self__, "hls_configuration", hls_configuration)
        if media_types is not None:
            pulumi.set(__self__, "media_types", media_types)
        if recording_reconnect_window_seconds is not None:
            pulumi.set(__self__, "recording_reconnect_window_seconds", recording_reconnect_window_seconds)
        if thumbnail_configuration is not None:
            pulumi.set(__self__, "thumbnail_configuration", thumbnail_configuration)

    @property
    @pulumi.getter(name="storageConfigurationArn")
    def storage_configuration_arn(self) -> builtins.str:
        """
        ARN of the StorageConfiguration resource to use for individual participant recording.
        """
        return pulumi.get(self, "storage_configuration_arn")

    @property
    @pulumi.getter(name="hlsConfiguration")
    def hls_configuration(self) -> Optional['outputs.StageAutoParticipantRecordingConfigurationHlsConfigurationProperties']:
        """
        HLS configuration object for individual participant recording.
        """
        return pulumi.get(self, "hls_configuration")

    @property
    @pulumi.getter(name="mediaTypes")
    def media_types(self) -> Optional[Sequence['StageAutoParticipantRecordingConfigurationMediaTypesItem']]:
        """
        Types of media to be recorded. Default: AUDIO_VIDEO.
        """
        return pulumi.get(self, "media_types")

    @property
    @pulumi.getter(name="recordingReconnectWindowSeconds")
    def recording_reconnect_window_seconds(self) -> Optional[builtins.int]:
        """
        If a stage publisher disconnects and then reconnects within the specified interval, the multiple recordings will be considered a single recording and merged together. The default value is 0, which disables merging.
        """
        return pulumi.get(self, "recording_reconnect_window_seconds")

    @property
    @pulumi.getter(name="thumbnailConfiguration")
    def thumbnail_configuration(self) -> Optional['outputs.StageAutoParticipantRecordingConfigurationThumbnailConfigurationProperties']:
        """
        A complex type that allows you to enable/disable the recording of thumbnails for individual participant recording and modify the interval at which thumbnails are generated for the live session.
        """
        return pulumi.get(self, "thumbnail_configuration")


@pulumi.output_type
class StageAutoParticipantRecordingConfigurationHlsConfigurationProperties(dict):
    """
    HLS configuration object for individual participant recording.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "participantRecordingHlsConfiguration":
            suggest = "participant_recording_hls_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StageAutoParticipantRecordingConfigurationHlsConfigurationProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StageAutoParticipantRecordingConfigurationHlsConfigurationProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StageAutoParticipantRecordingConfigurationHlsConfigurationProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 participant_recording_hls_configuration: Optional['outputs.StageAutoParticipantRecordingConfigurationHlsConfigurationPropertiesParticipantRecordingHlsConfigurationProperties'] = None):
        """
        HLS configuration object for individual participant recording.
        :param 'StageAutoParticipantRecordingConfigurationHlsConfigurationPropertiesParticipantRecordingHlsConfigurationProperties' participant_recording_hls_configuration: An object representing a configuration of participant HLS recordings for individual participant recording.
        """
        if participant_recording_hls_configuration is not None:
            pulumi.set(__self__, "participant_recording_hls_configuration", participant_recording_hls_configuration)

    @property
    @pulumi.getter(name="participantRecordingHlsConfiguration")
    def participant_recording_hls_configuration(self) -> Optional['outputs.StageAutoParticipantRecordingConfigurationHlsConfigurationPropertiesParticipantRecordingHlsConfigurationProperties']:
        """
        An object representing a configuration of participant HLS recordings for individual participant recording.
        """
        return pulumi.get(self, "participant_recording_hls_configuration")


@pulumi.output_type
class StageAutoParticipantRecordingConfigurationHlsConfigurationPropertiesParticipantRecordingHlsConfigurationProperties(dict):
    """
    An object representing a configuration of participant HLS recordings for individual participant recording.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetSegmentDurationSeconds":
            suggest = "target_segment_duration_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StageAutoParticipantRecordingConfigurationHlsConfigurationPropertiesParticipantRecordingHlsConfigurationProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StageAutoParticipantRecordingConfigurationHlsConfigurationPropertiesParticipantRecordingHlsConfigurationProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StageAutoParticipantRecordingConfigurationHlsConfigurationPropertiesParticipantRecordingHlsConfigurationProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_segment_duration_seconds: Optional[builtins.int] = None):
        """
        An object representing a configuration of participant HLS recordings for individual participant recording.
        :param builtins.int target_segment_duration_seconds: Defines the target duration for recorded segments generated when recording a stage participant. Segments may have durations longer than the specified value when needed to ensure each segment begins with a keyframe. Default: 6.
        """
        if target_segment_duration_seconds is not None:
            pulumi.set(__self__, "target_segment_duration_seconds", target_segment_duration_seconds)

    @property
    @pulumi.getter(name="targetSegmentDurationSeconds")
    def target_segment_duration_seconds(self) -> Optional[builtins.int]:
        """
        Defines the target duration for recorded segments generated when recording a stage participant. Segments may have durations longer than the specified value when needed to ensure each segment begins with a keyframe. Default: 6.
        """
        return pulumi.get(self, "target_segment_duration_seconds")


@pulumi.output_type
class StageAutoParticipantRecordingConfigurationThumbnailConfigurationProperties(dict):
    """
    A complex type that allows you to enable/disable the recording of thumbnails for individual participant recording and modify the interval at which thumbnails are generated for the live session.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "participantThumbnailConfiguration":
            suggest = "participant_thumbnail_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StageAutoParticipantRecordingConfigurationThumbnailConfigurationProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StageAutoParticipantRecordingConfigurationThumbnailConfigurationProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StageAutoParticipantRecordingConfigurationThumbnailConfigurationProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 participant_thumbnail_configuration: Optional['outputs.StageAutoParticipantRecordingConfigurationThumbnailConfigurationPropertiesParticipantThumbnailConfigurationProperties'] = None):
        """
        A complex type that allows you to enable/disable the recording of thumbnails for individual participant recording and modify the interval at which thumbnails are generated for the live session.
        :param 'StageAutoParticipantRecordingConfigurationThumbnailConfigurationPropertiesParticipantThumbnailConfigurationProperties' participant_thumbnail_configuration: An object representing a configuration of thumbnails for recorded video from an individual participant.
        """
        if participant_thumbnail_configuration is not None:
            pulumi.set(__self__, "participant_thumbnail_configuration", participant_thumbnail_configuration)

    @property
    @pulumi.getter(name="participantThumbnailConfiguration")
    def participant_thumbnail_configuration(self) -> Optional['outputs.StageAutoParticipantRecordingConfigurationThumbnailConfigurationPropertiesParticipantThumbnailConfigurationProperties']:
        """
        An object representing a configuration of thumbnails for recorded video from an individual participant.
        """
        return pulumi.get(self, "participant_thumbnail_configuration")


@pulumi.output_type
class StageAutoParticipantRecordingConfigurationThumbnailConfigurationPropertiesParticipantThumbnailConfigurationProperties(dict):
    """
    An object representing a configuration of thumbnails for recorded video from an individual participant.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recordingMode":
            suggest = "recording_mode"
        elif key == "targetIntervalSeconds":
            suggest = "target_interval_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StageAutoParticipantRecordingConfigurationThumbnailConfigurationPropertiesParticipantThumbnailConfigurationProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StageAutoParticipantRecordingConfigurationThumbnailConfigurationPropertiesParticipantThumbnailConfigurationProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StageAutoParticipantRecordingConfigurationThumbnailConfigurationPropertiesParticipantThumbnailConfigurationProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 recording_mode: Optional['StageAutoParticipantRecordingConfigurationThumbnailConfigurationPropertiesParticipantThumbnailConfigurationPropertiesRecordingMode'] = None,
                 storage: Optional[Sequence['StageAutoParticipantRecordingConfigurationThumbnailConfigurationPropertiesParticipantThumbnailConfigurationPropertiesStorageItem']] = None,
                 target_interval_seconds: Optional[builtins.int] = None):
        """
        An object representing a configuration of thumbnails for recorded video from an individual participant.
        :param 'StageAutoParticipantRecordingConfigurationThumbnailConfigurationPropertiesParticipantThumbnailConfigurationPropertiesRecordingMode' recording_mode: Thumbnail recording mode. Default: DISABLED.
        :param Sequence['StageAutoParticipantRecordingConfigurationThumbnailConfigurationPropertiesParticipantThumbnailConfigurationPropertiesStorageItem'] storage: Indicates the format in which thumbnails are recorded. SEQUENTIAL records all generated thumbnails in a serial manner, to the media/thumbnails/high directory. LATEST saves the latest thumbnail in media/latest_thumbnail/high/thumb.jpg and overwrites it at the interval specified by targetIntervalSeconds. You can enable both SEQUENTIAL and LATEST. Default: SEQUENTIAL.
        :param builtins.int target_interval_seconds: The targeted thumbnail-generation interval in seconds. This is configurable only if recordingMode is INTERVAL. Default: 60.
        """
        if recording_mode is not None:
            pulumi.set(__self__, "recording_mode", recording_mode)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)
        if target_interval_seconds is not None:
            pulumi.set(__self__, "target_interval_seconds", target_interval_seconds)

    @property
    @pulumi.getter(name="recordingMode")
    def recording_mode(self) -> Optional['StageAutoParticipantRecordingConfigurationThumbnailConfigurationPropertiesParticipantThumbnailConfigurationPropertiesRecordingMode']:
        """
        Thumbnail recording mode. Default: DISABLED.
        """
        return pulumi.get(self, "recording_mode")

    @property
    @pulumi.getter
    def storage(self) -> Optional[Sequence['StageAutoParticipantRecordingConfigurationThumbnailConfigurationPropertiesParticipantThumbnailConfigurationPropertiesStorageItem']]:
        """
        Indicates the format in which thumbnails are recorded. SEQUENTIAL records all generated thumbnails in a serial manner, to the media/thumbnails/high directory. LATEST saves the latest thumbnail in media/latest_thumbnail/high/thumb.jpg and overwrites it at the interval specified by targetIntervalSeconds. You can enable both SEQUENTIAL and LATEST. Default: SEQUENTIAL.
        """
        return pulumi.get(self, "storage")

    @property
    @pulumi.getter(name="targetIntervalSeconds")
    def target_interval_seconds(self) -> Optional[builtins.int]:
        """
        The targeted thumbnail-generation interval in seconds. This is configurable only if recordingMode is INTERVAL. Default: 60.
        """
        return pulumi.get(self, "target_interval_seconds")


@pulumi.output_type
class StorageConfigurationS3StorageConfiguration(dict):
    """
    A complex type that describes an S3 location where recorded videos will be stored.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StorageConfigurationS3StorageConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StorageConfigurationS3StorageConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StorageConfigurationS3StorageConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: builtins.str):
        """
        A complex type that describes an S3 location where recorded videos will be stored.
        :param builtins.str bucket_name: Location (S3 bucket name) where recorded videos will be stored. Note that the StorageConfiguration and S3 bucket must be in the same region as the Composition.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> builtins.str:
        """
        Location (S3 bucket name) where recorded videos will be stored. Note that the StorageConfiguration and S3 bucket must be in the same region as the Composition.
        """
        return pulumi.get(self, "bucket_name")


@pulumi.output_type
class VideoProperties(dict):
    """
    Video configuration. Default: video resolution 1280x720, bitrate 2500 kbps, 30 fps
    """
    def __init__(__self__, *,
                 bitrate: Optional[builtins.int] = None,
                 framerate: Optional[builtins.float] = None,
                 height: Optional[builtins.int] = None,
                 width: Optional[builtins.int] = None):
        """
        Video configuration. Default: video resolution 1280x720, bitrate 2500 kbps, 30 fps
        :param builtins.int bitrate: Bitrate for generated output, in bps. Default: 2500000.
        :param builtins.float framerate: Video frame rate, in fps. Default: 30.
        :param builtins.int height: Video-resolution height. This must be an even number. Note that the maximum value is determined by width times height, such that the maximum total pixels is 2073600 (1920x1080 or 1080x1920). Default: 720.
        :param builtins.int width: Video-resolution width. This must be an even number. Note that the maximum value is determined by width times height, such that the maximum total pixels is 2073600 (1920x1080 or 1080x1920). Default: 1280.
        """
        if bitrate is not None:
            pulumi.set(__self__, "bitrate", bitrate)
        if framerate is not None:
            pulumi.set(__self__, "framerate", framerate)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def bitrate(self) -> Optional[builtins.int]:
        """
        Bitrate for generated output, in bps. Default: 2500000.
        """
        return pulumi.get(self, "bitrate")

    @property
    @pulumi.getter
    def framerate(self) -> Optional[builtins.float]:
        """
        Video frame rate, in fps. Default: 30.
        """
        return pulumi.get(self, "framerate")

    @property
    @pulumi.getter
    def height(self) -> Optional[builtins.int]:
        """
        Video-resolution height. This must be an even number. Note that the maximum value is determined by width times height, such that the maximum total pixels is 2073600 (1920x1080 or 1080x1920). Default: 720.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def width(self) -> Optional[builtins.int]:
        """
        Video-resolution width. This must be an even number. Note that the maximum value is determined by width times height, such that the maximum total pixels is 2073600 (1920x1080 or 1080x1920). Default: 1280.
        """
        return pulumi.get(self, "width")


