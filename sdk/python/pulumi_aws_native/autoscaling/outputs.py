# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'AutoScalingGroupAcceleratorCountRequest',
    'AutoScalingGroupAcceleratorTotalMemoryMiBRequest',
    'AutoScalingGroupBaselineEbsBandwidthMbpsRequest',
    'AutoScalingGroupInstanceMaintenancePolicy',
    'AutoScalingGroupInstanceRequirements',
    'AutoScalingGroupInstancesDistribution',
    'AutoScalingGroupLaunchTemplate',
    'AutoScalingGroupLaunchTemplateOverrides',
    'AutoScalingGroupLaunchTemplateSpecification',
    'AutoScalingGroupLifecycleHookSpecification',
    'AutoScalingGroupMemoryGiBPerVCpuRequest',
    'AutoScalingGroupMemoryMiBRequest',
    'AutoScalingGroupMetricsCollection',
    'AutoScalingGroupMixedInstancesPolicy',
    'AutoScalingGroupNetworkBandwidthGbpsRequest',
    'AutoScalingGroupNetworkInterfaceCountRequest',
    'AutoScalingGroupNotificationConfiguration',
    'AutoScalingGroupTagProperty',
    'AutoScalingGroupTotalLocalStorageGbRequest',
    'AutoScalingGroupVCpuCountRequest',
    'LaunchConfigurationBlockDevice',
    'LaunchConfigurationBlockDeviceMapping',
    'LaunchConfigurationMetadataOptions',
    'ScalingPolicyCustomizedMetricSpecification',
    'ScalingPolicyMetric',
    'ScalingPolicyMetricDataQuery',
    'ScalingPolicyMetricDimension',
    'ScalingPolicyMetricStat',
    'ScalingPolicyPredefinedMetricSpecification',
    'ScalingPolicyPredictiveScalingConfiguration',
    'ScalingPolicyPredictiveScalingCustomizedCapacityMetric',
    'ScalingPolicyPredictiveScalingCustomizedLoadMetric',
    'ScalingPolicyPredictiveScalingCustomizedScalingMetric',
    'ScalingPolicyPredictiveScalingMetricSpecification',
    'ScalingPolicyPredictiveScalingPredefinedLoadMetric',
    'ScalingPolicyPredictiveScalingPredefinedMetricPair',
    'ScalingPolicyPredictiveScalingPredefinedScalingMetric',
    'ScalingPolicyStepAdjustment',
    'ScalingPolicyTargetTrackingConfiguration',
    'WarmPoolInstanceReusePolicy',
]

@pulumi.output_type
class AutoScalingGroupAcceleratorCountRequest(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        AutoScalingGroupAcceleratorCountRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[int] = None,
             min: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class AutoScalingGroupAcceleratorTotalMemoryMiBRequest(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        AutoScalingGroupAcceleratorTotalMemoryMiBRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[int] = None,
             min: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class AutoScalingGroupBaselineEbsBandwidthMbpsRequest(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        AutoScalingGroupBaselineEbsBandwidthMbpsRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[int] = None,
             min: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class AutoScalingGroupInstanceMaintenancePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxHealthyPercentage":
            suggest = "max_healthy_percentage"
        elif key == "minHealthyPercentage":
            suggest = "min_healthy_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoScalingGroupInstanceMaintenancePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoScalingGroupInstanceMaintenancePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoScalingGroupInstanceMaintenancePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_healthy_percentage: Optional[int] = None,
                 min_healthy_percentage: Optional[int] = None):
        AutoScalingGroupInstanceMaintenancePolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_healthy_percentage=max_healthy_percentage,
            min_healthy_percentage=min_healthy_percentage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_healthy_percentage: Optional[int] = None,
             min_healthy_percentage: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if max_healthy_percentage is not None:
            _setter("max_healthy_percentage", max_healthy_percentage)
        if min_healthy_percentage is not None:
            _setter("min_healthy_percentage", min_healthy_percentage)

    @property
    @pulumi.getter(name="maxHealthyPercentage")
    def max_healthy_percentage(self) -> Optional[int]:
        return pulumi.get(self, "max_healthy_percentage")

    @property
    @pulumi.getter(name="minHealthyPercentage")
    def min_healthy_percentage(self) -> Optional[int]:
        return pulumi.get(self, "min_healthy_percentage")


@pulumi.output_type
class AutoScalingGroupInstanceRequirements(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceleratorCount":
            suggest = "accelerator_count"
        elif key == "acceleratorManufacturers":
            suggest = "accelerator_manufacturers"
        elif key == "acceleratorNames":
            suggest = "accelerator_names"
        elif key == "acceleratorTotalMemoryMiB":
            suggest = "accelerator_total_memory_mi_b"
        elif key == "acceleratorTypes":
            suggest = "accelerator_types"
        elif key == "allowedInstanceTypes":
            suggest = "allowed_instance_types"
        elif key == "bareMetal":
            suggest = "bare_metal"
        elif key == "baselineEbsBandwidthMbps":
            suggest = "baseline_ebs_bandwidth_mbps"
        elif key == "burstablePerformance":
            suggest = "burstable_performance"
        elif key == "cpuManufacturers":
            suggest = "cpu_manufacturers"
        elif key == "excludedInstanceTypes":
            suggest = "excluded_instance_types"
        elif key == "instanceGenerations":
            suggest = "instance_generations"
        elif key == "localStorage":
            suggest = "local_storage"
        elif key == "localStorageTypes":
            suggest = "local_storage_types"
        elif key == "memoryGiBPerVCpu":
            suggest = "memory_gi_b_per_v_cpu"
        elif key == "memoryMiB":
            suggest = "memory_mi_b"
        elif key == "networkBandwidthGbps":
            suggest = "network_bandwidth_gbps"
        elif key == "networkInterfaceCount":
            suggest = "network_interface_count"
        elif key == "onDemandMaxPricePercentageOverLowestPrice":
            suggest = "on_demand_max_price_percentage_over_lowest_price"
        elif key == "requireHibernateSupport":
            suggest = "require_hibernate_support"
        elif key == "spotMaxPricePercentageOverLowestPrice":
            suggest = "spot_max_price_percentage_over_lowest_price"
        elif key == "totalLocalStorageGb":
            suggest = "total_local_storage_gb"
        elif key == "vCpuCount":
            suggest = "v_cpu_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoScalingGroupInstanceRequirements. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoScalingGroupInstanceRequirements.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoScalingGroupInstanceRequirements.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accelerator_count: Optional['outputs.AutoScalingGroupAcceleratorCountRequest'] = None,
                 accelerator_manufacturers: Optional[Sequence[str]] = None,
                 accelerator_names: Optional[Sequence[str]] = None,
                 accelerator_total_memory_mi_b: Optional['outputs.AutoScalingGroupAcceleratorTotalMemoryMiBRequest'] = None,
                 accelerator_types: Optional[Sequence[str]] = None,
                 allowed_instance_types: Optional[Sequence[str]] = None,
                 bare_metal: Optional[str] = None,
                 baseline_ebs_bandwidth_mbps: Optional['outputs.AutoScalingGroupBaselineEbsBandwidthMbpsRequest'] = None,
                 burstable_performance: Optional[str] = None,
                 cpu_manufacturers: Optional[Sequence[str]] = None,
                 excluded_instance_types: Optional[Sequence[str]] = None,
                 instance_generations: Optional[Sequence[str]] = None,
                 local_storage: Optional[str] = None,
                 local_storage_types: Optional[Sequence[str]] = None,
                 memory_gi_b_per_v_cpu: Optional['outputs.AutoScalingGroupMemoryGiBPerVCpuRequest'] = None,
                 memory_mi_b: Optional['outputs.AutoScalingGroupMemoryMiBRequest'] = None,
                 network_bandwidth_gbps: Optional['outputs.AutoScalingGroupNetworkBandwidthGbpsRequest'] = None,
                 network_interface_count: Optional['outputs.AutoScalingGroupNetworkInterfaceCountRequest'] = None,
                 on_demand_max_price_percentage_over_lowest_price: Optional[int] = None,
                 require_hibernate_support: Optional[bool] = None,
                 spot_max_price_percentage_over_lowest_price: Optional[int] = None,
                 total_local_storage_gb: Optional['outputs.AutoScalingGroupTotalLocalStorageGbRequest'] = None,
                 v_cpu_count: Optional['outputs.AutoScalingGroupVCpuCountRequest'] = None):
        AutoScalingGroupInstanceRequirements._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            accelerator_count=accelerator_count,
            accelerator_manufacturers=accelerator_manufacturers,
            accelerator_names=accelerator_names,
            accelerator_total_memory_mi_b=accelerator_total_memory_mi_b,
            accelerator_types=accelerator_types,
            allowed_instance_types=allowed_instance_types,
            bare_metal=bare_metal,
            baseline_ebs_bandwidth_mbps=baseline_ebs_bandwidth_mbps,
            burstable_performance=burstable_performance,
            cpu_manufacturers=cpu_manufacturers,
            excluded_instance_types=excluded_instance_types,
            instance_generations=instance_generations,
            local_storage=local_storage,
            local_storage_types=local_storage_types,
            memory_gi_b_per_v_cpu=memory_gi_b_per_v_cpu,
            memory_mi_b=memory_mi_b,
            network_bandwidth_gbps=network_bandwidth_gbps,
            network_interface_count=network_interface_count,
            on_demand_max_price_percentage_over_lowest_price=on_demand_max_price_percentage_over_lowest_price,
            require_hibernate_support=require_hibernate_support,
            spot_max_price_percentage_over_lowest_price=spot_max_price_percentage_over_lowest_price,
            total_local_storage_gb=total_local_storage_gb,
            v_cpu_count=v_cpu_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             accelerator_count: Optional['outputs.AutoScalingGroupAcceleratorCountRequest'] = None,
             accelerator_manufacturers: Optional[Sequence[str]] = None,
             accelerator_names: Optional[Sequence[str]] = None,
             accelerator_total_memory_mi_b: Optional['outputs.AutoScalingGroupAcceleratorTotalMemoryMiBRequest'] = None,
             accelerator_types: Optional[Sequence[str]] = None,
             allowed_instance_types: Optional[Sequence[str]] = None,
             bare_metal: Optional[str] = None,
             baseline_ebs_bandwidth_mbps: Optional['outputs.AutoScalingGroupBaselineEbsBandwidthMbpsRequest'] = None,
             burstable_performance: Optional[str] = None,
             cpu_manufacturers: Optional[Sequence[str]] = None,
             excluded_instance_types: Optional[Sequence[str]] = None,
             instance_generations: Optional[Sequence[str]] = None,
             local_storage: Optional[str] = None,
             local_storage_types: Optional[Sequence[str]] = None,
             memory_gi_b_per_v_cpu: Optional['outputs.AutoScalingGroupMemoryGiBPerVCpuRequest'] = None,
             memory_mi_b: Optional['outputs.AutoScalingGroupMemoryMiBRequest'] = None,
             network_bandwidth_gbps: Optional['outputs.AutoScalingGroupNetworkBandwidthGbpsRequest'] = None,
             network_interface_count: Optional['outputs.AutoScalingGroupNetworkInterfaceCountRequest'] = None,
             on_demand_max_price_percentage_over_lowest_price: Optional[int] = None,
             require_hibernate_support: Optional[bool] = None,
             spot_max_price_percentage_over_lowest_price: Optional[int] = None,
             total_local_storage_gb: Optional['outputs.AutoScalingGroupTotalLocalStorageGbRequest'] = None,
             v_cpu_count: Optional['outputs.AutoScalingGroupVCpuCountRequest'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if accelerator_count is not None:
            _setter("accelerator_count", accelerator_count)
        if accelerator_manufacturers is not None:
            _setter("accelerator_manufacturers", accelerator_manufacturers)
        if accelerator_names is not None:
            _setter("accelerator_names", accelerator_names)
        if accelerator_total_memory_mi_b is not None:
            _setter("accelerator_total_memory_mi_b", accelerator_total_memory_mi_b)
        if accelerator_types is not None:
            _setter("accelerator_types", accelerator_types)
        if allowed_instance_types is not None:
            _setter("allowed_instance_types", allowed_instance_types)
        if bare_metal is not None:
            _setter("bare_metal", bare_metal)
        if baseline_ebs_bandwidth_mbps is not None:
            _setter("baseline_ebs_bandwidth_mbps", baseline_ebs_bandwidth_mbps)
        if burstable_performance is not None:
            _setter("burstable_performance", burstable_performance)
        if cpu_manufacturers is not None:
            _setter("cpu_manufacturers", cpu_manufacturers)
        if excluded_instance_types is not None:
            _setter("excluded_instance_types", excluded_instance_types)
        if instance_generations is not None:
            _setter("instance_generations", instance_generations)
        if local_storage is not None:
            _setter("local_storage", local_storage)
        if local_storage_types is not None:
            _setter("local_storage_types", local_storage_types)
        if memory_gi_b_per_v_cpu is not None:
            _setter("memory_gi_b_per_v_cpu", memory_gi_b_per_v_cpu)
        if memory_mi_b is not None:
            _setter("memory_mi_b", memory_mi_b)
        if network_bandwidth_gbps is not None:
            _setter("network_bandwidth_gbps", network_bandwidth_gbps)
        if network_interface_count is not None:
            _setter("network_interface_count", network_interface_count)
        if on_demand_max_price_percentage_over_lowest_price is not None:
            _setter("on_demand_max_price_percentage_over_lowest_price", on_demand_max_price_percentage_over_lowest_price)
        if require_hibernate_support is not None:
            _setter("require_hibernate_support", require_hibernate_support)
        if spot_max_price_percentage_over_lowest_price is not None:
            _setter("spot_max_price_percentage_over_lowest_price", spot_max_price_percentage_over_lowest_price)
        if total_local_storage_gb is not None:
            _setter("total_local_storage_gb", total_local_storage_gb)
        if v_cpu_count is not None:
            _setter("v_cpu_count", v_cpu_count)

    @property
    @pulumi.getter(name="acceleratorCount")
    def accelerator_count(self) -> Optional['outputs.AutoScalingGroupAcceleratorCountRequest']:
        return pulumi.get(self, "accelerator_count")

    @property
    @pulumi.getter(name="acceleratorManufacturers")
    def accelerator_manufacturers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "accelerator_manufacturers")

    @property
    @pulumi.getter(name="acceleratorNames")
    def accelerator_names(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "accelerator_names")

    @property
    @pulumi.getter(name="acceleratorTotalMemoryMiB")
    def accelerator_total_memory_mi_b(self) -> Optional['outputs.AutoScalingGroupAcceleratorTotalMemoryMiBRequest']:
        return pulumi.get(self, "accelerator_total_memory_mi_b")

    @property
    @pulumi.getter(name="acceleratorTypes")
    def accelerator_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "accelerator_types")

    @property
    @pulumi.getter(name="allowedInstanceTypes")
    def allowed_instance_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allowed_instance_types")

    @property
    @pulumi.getter(name="bareMetal")
    def bare_metal(self) -> Optional[str]:
        return pulumi.get(self, "bare_metal")

    @property
    @pulumi.getter(name="baselineEbsBandwidthMbps")
    def baseline_ebs_bandwidth_mbps(self) -> Optional['outputs.AutoScalingGroupBaselineEbsBandwidthMbpsRequest']:
        return pulumi.get(self, "baseline_ebs_bandwidth_mbps")

    @property
    @pulumi.getter(name="burstablePerformance")
    def burstable_performance(self) -> Optional[str]:
        return pulumi.get(self, "burstable_performance")

    @property
    @pulumi.getter(name="cpuManufacturers")
    def cpu_manufacturers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "cpu_manufacturers")

    @property
    @pulumi.getter(name="excludedInstanceTypes")
    def excluded_instance_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excluded_instance_types")

    @property
    @pulumi.getter(name="instanceGenerations")
    def instance_generations(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "instance_generations")

    @property
    @pulumi.getter(name="localStorage")
    def local_storage(self) -> Optional[str]:
        return pulumi.get(self, "local_storage")

    @property
    @pulumi.getter(name="localStorageTypes")
    def local_storage_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "local_storage_types")

    @property
    @pulumi.getter(name="memoryGiBPerVCpu")
    def memory_gi_b_per_v_cpu(self) -> Optional['outputs.AutoScalingGroupMemoryGiBPerVCpuRequest']:
        return pulumi.get(self, "memory_gi_b_per_v_cpu")

    @property
    @pulumi.getter(name="memoryMiB")
    def memory_mi_b(self) -> Optional['outputs.AutoScalingGroupMemoryMiBRequest']:
        return pulumi.get(self, "memory_mi_b")

    @property
    @pulumi.getter(name="networkBandwidthGbps")
    def network_bandwidth_gbps(self) -> Optional['outputs.AutoScalingGroupNetworkBandwidthGbpsRequest']:
        return pulumi.get(self, "network_bandwidth_gbps")

    @property
    @pulumi.getter(name="networkInterfaceCount")
    def network_interface_count(self) -> Optional['outputs.AutoScalingGroupNetworkInterfaceCountRequest']:
        return pulumi.get(self, "network_interface_count")

    @property
    @pulumi.getter(name="onDemandMaxPricePercentageOverLowestPrice")
    def on_demand_max_price_percentage_over_lowest_price(self) -> Optional[int]:
        return pulumi.get(self, "on_demand_max_price_percentage_over_lowest_price")

    @property
    @pulumi.getter(name="requireHibernateSupport")
    def require_hibernate_support(self) -> Optional[bool]:
        return pulumi.get(self, "require_hibernate_support")

    @property
    @pulumi.getter(name="spotMaxPricePercentageOverLowestPrice")
    def spot_max_price_percentage_over_lowest_price(self) -> Optional[int]:
        return pulumi.get(self, "spot_max_price_percentage_over_lowest_price")

    @property
    @pulumi.getter(name="totalLocalStorageGb")
    def total_local_storage_gb(self) -> Optional['outputs.AutoScalingGroupTotalLocalStorageGbRequest']:
        return pulumi.get(self, "total_local_storage_gb")

    @property
    @pulumi.getter(name="vCpuCount")
    def v_cpu_count(self) -> Optional['outputs.AutoScalingGroupVCpuCountRequest']:
        return pulumi.get(self, "v_cpu_count")


@pulumi.output_type
class AutoScalingGroupInstancesDistribution(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onDemandAllocationStrategy":
            suggest = "on_demand_allocation_strategy"
        elif key == "onDemandBaseCapacity":
            suggest = "on_demand_base_capacity"
        elif key == "onDemandPercentageAboveBaseCapacity":
            suggest = "on_demand_percentage_above_base_capacity"
        elif key == "spotAllocationStrategy":
            suggest = "spot_allocation_strategy"
        elif key == "spotInstancePools":
            suggest = "spot_instance_pools"
        elif key == "spotMaxPrice":
            suggest = "spot_max_price"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoScalingGroupInstancesDistribution. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoScalingGroupInstancesDistribution.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoScalingGroupInstancesDistribution.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 on_demand_allocation_strategy: Optional[str] = None,
                 on_demand_base_capacity: Optional[int] = None,
                 on_demand_percentage_above_base_capacity: Optional[int] = None,
                 spot_allocation_strategy: Optional[str] = None,
                 spot_instance_pools: Optional[int] = None,
                 spot_max_price: Optional[str] = None):
        AutoScalingGroupInstancesDistribution._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            on_demand_allocation_strategy=on_demand_allocation_strategy,
            on_demand_base_capacity=on_demand_base_capacity,
            on_demand_percentage_above_base_capacity=on_demand_percentage_above_base_capacity,
            spot_allocation_strategy=spot_allocation_strategy,
            spot_instance_pools=spot_instance_pools,
            spot_max_price=spot_max_price,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             on_demand_allocation_strategy: Optional[str] = None,
             on_demand_base_capacity: Optional[int] = None,
             on_demand_percentage_above_base_capacity: Optional[int] = None,
             spot_allocation_strategy: Optional[str] = None,
             spot_instance_pools: Optional[int] = None,
             spot_max_price: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if on_demand_allocation_strategy is not None:
            _setter("on_demand_allocation_strategy", on_demand_allocation_strategy)
        if on_demand_base_capacity is not None:
            _setter("on_demand_base_capacity", on_demand_base_capacity)
        if on_demand_percentage_above_base_capacity is not None:
            _setter("on_demand_percentage_above_base_capacity", on_demand_percentage_above_base_capacity)
        if spot_allocation_strategy is not None:
            _setter("spot_allocation_strategy", spot_allocation_strategy)
        if spot_instance_pools is not None:
            _setter("spot_instance_pools", spot_instance_pools)
        if spot_max_price is not None:
            _setter("spot_max_price", spot_max_price)

    @property
    @pulumi.getter(name="onDemandAllocationStrategy")
    def on_demand_allocation_strategy(self) -> Optional[str]:
        return pulumi.get(self, "on_demand_allocation_strategy")

    @property
    @pulumi.getter(name="onDemandBaseCapacity")
    def on_demand_base_capacity(self) -> Optional[int]:
        return pulumi.get(self, "on_demand_base_capacity")

    @property
    @pulumi.getter(name="onDemandPercentageAboveBaseCapacity")
    def on_demand_percentage_above_base_capacity(self) -> Optional[int]:
        return pulumi.get(self, "on_demand_percentage_above_base_capacity")

    @property
    @pulumi.getter(name="spotAllocationStrategy")
    def spot_allocation_strategy(self) -> Optional[str]:
        return pulumi.get(self, "spot_allocation_strategy")

    @property
    @pulumi.getter(name="spotInstancePools")
    def spot_instance_pools(self) -> Optional[int]:
        return pulumi.get(self, "spot_instance_pools")

    @property
    @pulumi.getter(name="spotMaxPrice")
    def spot_max_price(self) -> Optional[str]:
        return pulumi.get(self, "spot_max_price")


@pulumi.output_type
class AutoScalingGroupLaunchTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTemplateSpecification":
            suggest = "launch_template_specification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoScalingGroupLaunchTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoScalingGroupLaunchTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoScalingGroupLaunchTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 launch_template_specification: 'outputs.AutoScalingGroupLaunchTemplateSpecification',
                 overrides: Optional[Sequence['outputs.AutoScalingGroupLaunchTemplateOverrides']] = None):
        AutoScalingGroupLaunchTemplate._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            launch_template_specification=launch_template_specification,
            overrides=overrides,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             launch_template_specification: 'outputs.AutoScalingGroupLaunchTemplateSpecification',
             overrides: Optional[Sequence['outputs.AutoScalingGroupLaunchTemplateOverrides']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("launch_template_specification", launch_template_specification)
        if overrides is not None:
            _setter("overrides", overrides)

    @property
    @pulumi.getter(name="launchTemplateSpecification")
    def launch_template_specification(self) -> 'outputs.AutoScalingGroupLaunchTemplateSpecification':
        return pulumi.get(self, "launch_template_specification")

    @property
    @pulumi.getter
    def overrides(self) -> Optional[Sequence['outputs.AutoScalingGroupLaunchTemplateOverrides']]:
        return pulumi.get(self, "overrides")


@pulumi.output_type
class AutoScalingGroupLaunchTemplateOverrides(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceRequirements":
            suggest = "instance_requirements"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "launchTemplateSpecification":
            suggest = "launch_template_specification"
        elif key == "weightedCapacity":
            suggest = "weighted_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoScalingGroupLaunchTemplateOverrides. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoScalingGroupLaunchTemplateOverrides.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoScalingGroupLaunchTemplateOverrides.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_requirements: Optional['outputs.AutoScalingGroupInstanceRequirements'] = None,
                 instance_type: Optional[str] = None,
                 launch_template_specification: Optional['outputs.AutoScalingGroupLaunchTemplateSpecification'] = None,
                 weighted_capacity: Optional[str] = None):
        AutoScalingGroupLaunchTemplateOverrides._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_requirements=instance_requirements,
            instance_type=instance_type,
            launch_template_specification=launch_template_specification,
            weighted_capacity=weighted_capacity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_requirements: Optional['outputs.AutoScalingGroupInstanceRequirements'] = None,
             instance_type: Optional[str] = None,
             launch_template_specification: Optional['outputs.AutoScalingGroupLaunchTemplateSpecification'] = None,
             weighted_capacity: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if instance_requirements is not None:
            _setter("instance_requirements", instance_requirements)
        if instance_type is not None:
            _setter("instance_type", instance_type)
        if launch_template_specification is not None:
            _setter("launch_template_specification", launch_template_specification)
        if weighted_capacity is not None:
            _setter("weighted_capacity", weighted_capacity)

    @property
    @pulumi.getter(name="instanceRequirements")
    def instance_requirements(self) -> Optional['outputs.AutoScalingGroupInstanceRequirements']:
        return pulumi.get(self, "instance_requirements")

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[str]:
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter(name="launchTemplateSpecification")
    def launch_template_specification(self) -> Optional['outputs.AutoScalingGroupLaunchTemplateSpecification']:
        return pulumi.get(self, "launch_template_specification")

    @property
    @pulumi.getter(name="weightedCapacity")
    def weighted_capacity(self) -> Optional[str]:
        return pulumi.get(self, "weighted_capacity")


@pulumi.output_type
class AutoScalingGroupLaunchTemplateSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTemplateId":
            suggest = "launch_template_id"
        elif key == "launchTemplateName":
            suggest = "launch_template_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoScalingGroupLaunchTemplateSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoScalingGroupLaunchTemplateSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoScalingGroupLaunchTemplateSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 version: str,
                 launch_template_id: Optional[str] = None,
                 launch_template_name: Optional[str] = None):
        AutoScalingGroupLaunchTemplateSpecification._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            version=version,
            launch_template_id=launch_template_id,
            launch_template_name=launch_template_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             version: str,
             launch_template_id: Optional[str] = None,
             launch_template_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("version", version)
        if launch_template_id is not None:
            _setter("launch_template_id", launch_template_id)
        if launch_template_name is not None:
            _setter("launch_template_name", launch_template_name)

    @property
    @pulumi.getter
    def version(self) -> str:
        return pulumi.get(self, "version")

    @property
    @pulumi.getter(name="launchTemplateId")
    def launch_template_id(self) -> Optional[str]:
        return pulumi.get(self, "launch_template_id")

    @property
    @pulumi.getter(name="launchTemplateName")
    def launch_template_name(self) -> Optional[str]:
        return pulumi.get(self, "launch_template_name")


@pulumi.output_type
class AutoScalingGroupLifecycleHookSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lifecycleHookName":
            suggest = "lifecycle_hook_name"
        elif key == "lifecycleTransition":
            suggest = "lifecycle_transition"
        elif key == "defaultResult":
            suggest = "default_result"
        elif key == "heartbeatTimeout":
            suggest = "heartbeat_timeout"
        elif key == "notificationMetadata":
            suggest = "notification_metadata"
        elif key == "notificationTargetArn":
            suggest = "notification_target_arn"
        elif key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoScalingGroupLifecycleHookSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoScalingGroupLifecycleHookSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoScalingGroupLifecycleHookSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lifecycle_hook_name: str,
                 lifecycle_transition: str,
                 default_result: Optional[str] = None,
                 heartbeat_timeout: Optional[int] = None,
                 notification_metadata: Optional[str] = None,
                 notification_target_arn: Optional[str] = None,
                 role_arn: Optional[str] = None):
        AutoScalingGroupLifecycleHookSpecification._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            lifecycle_hook_name=lifecycle_hook_name,
            lifecycle_transition=lifecycle_transition,
            default_result=default_result,
            heartbeat_timeout=heartbeat_timeout,
            notification_metadata=notification_metadata,
            notification_target_arn=notification_target_arn,
            role_arn=role_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             lifecycle_hook_name: str,
             lifecycle_transition: str,
             default_result: Optional[str] = None,
             heartbeat_timeout: Optional[int] = None,
             notification_metadata: Optional[str] = None,
             notification_target_arn: Optional[str] = None,
             role_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("lifecycle_hook_name", lifecycle_hook_name)
        _setter("lifecycle_transition", lifecycle_transition)
        if default_result is not None:
            _setter("default_result", default_result)
        if heartbeat_timeout is not None:
            _setter("heartbeat_timeout", heartbeat_timeout)
        if notification_metadata is not None:
            _setter("notification_metadata", notification_metadata)
        if notification_target_arn is not None:
            _setter("notification_target_arn", notification_target_arn)
        if role_arn is not None:
            _setter("role_arn", role_arn)

    @property
    @pulumi.getter(name="lifecycleHookName")
    def lifecycle_hook_name(self) -> str:
        return pulumi.get(self, "lifecycle_hook_name")

    @property
    @pulumi.getter(name="lifecycleTransition")
    def lifecycle_transition(self) -> str:
        return pulumi.get(self, "lifecycle_transition")

    @property
    @pulumi.getter(name="defaultResult")
    def default_result(self) -> Optional[str]:
        return pulumi.get(self, "default_result")

    @property
    @pulumi.getter(name="heartbeatTimeout")
    def heartbeat_timeout(self) -> Optional[int]:
        return pulumi.get(self, "heartbeat_timeout")

    @property
    @pulumi.getter(name="notificationMetadata")
    def notification_metadata(self) -> Optional[str]:
        return pulumi.get(self, "notification_metadata")

    @property
    @pulumi.getter(name="notificationTargetArn")
    def notification_target_arn(self) -> Optional[str]:
        return pulumi.get(self, "notification_target_arn")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class AutoScalingGroupMemoryGiBPerVCpuRequest(dict):
    def __init__(__self__, *,
                 max: Optional[float] = None,
                 min: Optional[float] = None):
        AutoScalingGroupMemoryGiBPerVCpuRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[float] = None,
             min: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        return pulumi.get(self, "min")


@pulumi.output_type
class AutoScalingGroupMemoryMiBRequest(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        AutoScalingGroupMemoryMiBRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[int] = None,
             min: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class AutoScalingGroupMetricsCollection(dict):
    def __init__(__self__, *,
                 granularity: str,
                 metrics: Optional[Sequence[str]] = None):
        AutoScalingGroupMetricsCollection._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            granularity=granularity,
            metrics=metrics,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             granularity: str,
             metrics: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("granularity", granularity)
        if metrics is not None:
            _setter("metrics", metrics)

    @property
    @pulumi.getter
    def granularity(self) -> str:
        return pulumi.get(self, "granularity")

    @property
    @pulumi.getter
    def metrics(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "metrics")


@pulumi.output_type
class AutoScalingGroupMixedInstancesPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "launchTemplate":
            suggest = "launch_template"
        elif key == "instancesDistribution":
            suggest = "instances_distribution"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoScalingGroupMixedInstancesPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoScalingGroupMixedInstancesPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoScalingGroupMixedInstancesPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 launch_template: 'outputs.AutoScalingGroupLaunchTemplate',
                 instances_distribution: Optional['outputs.AutoScalingGroupInstancesDistribution'] = None):
        AutoScalingGroupMixedInstancesPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            launch_template=launch_template,
            instances_distribution=instances_distribution,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             launch_template: 'outputs.AutoScalingGroupLaunchTemplate',
             instances_distribution: Optional['outputs.AutoScalingGroupInstancesDistribution'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("launch_template", launch_template)
        if instances_distribution is not None:
            _setter("instances_distribution", instances_distribution)

    @property
    @pulumi.getter(name="launchTemplate")
    def launch_template(self) -> 'outputs.AutoScalingGroupLaunchTemplate':
        return pulumi.get(self, "launch_template")

    @property
    @pulumi.getter(name="instancesDistribution")
    def instances_distribution(self) -> Optional['outputs.AutoScalingGroupInstancesDistribution']:
        return pulumi.get(self, "instances_distribution")


@pulumi.output_type
class AutoScalingGroupNetworkBandwidthGbpsRequest(dict):
    def __init__(__self__, *,
                 max: Optional[float] = None,
                 min: Optional[float] = None):
        AutoScalingGroupNetworkBandwidthGbpsRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[float] = None,
             min: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        return pulumi.get(self, "min")


@pulumi.output_type
class AutoScalingGroupNetworkInterfaceCountRequest(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        AutoScalingGroupNetworkInterfaceCountRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[int] = None,
             min: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class AutoScalingGroupNotificationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "topicArn":
            suggest = "topic_arn"
        elif key == "notificationTypes":
            suggest = "notification_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoScalingGroupNotificationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoScalingGroupNotificationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoScalingGroupNotificationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 topic_arn: str,
                 notification_types: Optional[Sequence[str]] = None):
        AutoScalingGroupNotificationConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            topic_arn=topic_arn,
            notification_types=notification_types,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             topic_arn: str,
             notification_types: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("topic_arn", topic_arn)
        if notification_types is not None:
            _setter("notification_types", notification_types)

    @property
    @pulumi.getter(name="topicArn")
    def topic_arn(self) -> str:
        return pulumi.get(self, "topic_arn")

    @property
    @pulumi.getter(name="notificationTypes")
    def notification_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "notification_types")


@pulumi.output_type
class AutoScalingGroupTagProperty(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propagateAtLaunch":
            suggest = "propagate_at_launch"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutoScalingGroupTagProperty. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutoScalingGroupTagProperty.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutoScalingGroupTagProperty.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 propagate_at_launch: bool,
                 value: str):
        AutoScalingGroupTagProperty._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            propagate_at_launch=propagate_at_launch,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             propagate_at_launch: bool,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("propagate_at_launch", propagate_at_launch)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="propagateAtLaunch")
    def propagate_at_launch(self) -> bool:
        return pulumi.get(self, "propagate_at_launch")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class AutoScalingGroupTotalLocalStorageGbRequest(dict):
    def __init__(__self__, *,
                 max: Optional[float] = None,
                 min: Optional[float] = None):
        AutoScalingGroupTotalLocalStorageGbRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[float] = None,
             min: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        return pulumi.get(self, "min")


@pulumi.output_type
class AutoScalingGroupVCpuCountRequest(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 min: Optional[int] = None):
        AutoScalingGroupVCpuCountRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            min=min,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[int] = None,
             min: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        return pulumi.get(self, "min")


@pulumi.output_type
class LaunchConfigurationBlockDevice(dict):
    """
    BlockDevice is a subproperty of BlockDeviceMapping that describes an Amazon EBS volume.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchConfigurationBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchConfigurationBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchConfigurationBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_on_termination: Optional[bool] = None,
                 encrypted: Optional[bool] = None,
                 iops: Optional[int] = None,
                 snapshot_id: Optional[str] = None,
                 throughput: Optional[int] = None,
                 volume_size: Optional[int] = None,
                 volume_type: Optional[str] = None):
        """
        BlockDevice is a subproperty of BlockDeviceMapping that describes an Amazon EBS volume.
        :param bool delete_on_termination: Indicates whether the volume is deleted on instance termination. 
        :param bool encrypted: Specifies whether the volume should be encrypted. 
        :param int iops: The number of input/output (I/O) operations per second (IOPS) to provision for the volume. 
        :param str snapshot_id: The snapshot ID of the volume to use.
        :param int throughput: The throughput (MiBps) to provision for a gp3 volume.
        :param int volume_size: The volume size, in GiBs.
        :param str volume_type: The volume type.
        """
        LaunchConfigurationBlockDevice._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            delete_on_termination=delete_on_termination,
            encrypted=encrypted,
            iops=iops,
            snapshot_id=snapshot_id,
            throughput=throughput,
            volume_size=volume_size,
            volume_type=volume_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             delete_on_termination: Optional[bool] = None,
             encrypted: Optional[bool] = None,
             iops: Optional[int] = None,
             snapshot_id: Optional[str] = None,
             throughput: Optional[int] = None,
             volume_size: Optional[int] = None,
             volume_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if delete_on_termination is not None:
            _setter("delete_on_termination", delete_on_termination)
        if encrypted is not None:
            _setter("encrypted", encrypted)
        if iops is not None:
            _setter("iops", iops)
        if snapshot_id is not None:
            _setter("snapshot_id", snapshot_id)
        if throughput is not None:
            _setter("throughput", throughput)
        if volume_size is not None:
            _setter("volume_size", volume_size)
        if volume_type is not None:
            _setter("volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[bool]:
        """
        Indicates whether the volume is deleted on instance termination. 
        """
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[bool]:
        """
        Specifies whether the volume should be encrypted. 
        """
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        """
        The number of input/output (I/O) operations per second (IOPS) to provision for the volume. 
        """
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        """
        The snapshot ID of the volume to use.
        """
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter
    def throughput(self) -> Optional[int]:
        """
        The throughput (MiBps) to provision for a gp3 volume.
        """
        return pulumi.get(self, "throughput")

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[int]:
        """
        The volume size, in GiBs.
        """
        return pulumi.get(self, "volume_size")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[str]:
        """
        The volume type.
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class LaunchConfigurationBlockDeviceMapping(dict):
    """
    BlockDeviceMapping is a property of AWS::AutoScaling::LaunchConfiguration that describes a block device mapping for an Auto Scaling group.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "noDevice":
            suggest = "no_device"
        elif key == "virtualName":
            suggest = "virtual_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchConfigurationBlockDeviceMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchConfigurationBlockDeviceMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchConfigurationBlockDeviceMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: str,
                 ebs: Optional['outputs.LaunchConfigurationBlockDevice'] = None,
                 no_device: Optional[bool] = None,
                 virtual_name: Optional[str] = None):
        """
        BlockDeviceMapping is a property of AWS::AutoScaling::LaunchConfiguration that describes a block device mapping for an Auto Scaling group.
        :param str device_name: The device name exposed to the EC2 instance (for example, /dev/sdh or xvdh). 
        :param 'LaunchConfigurationBlockDevice' ebs: Parameters used to automatically set up EBS volumes when an instance is launched.
        :param bool no_device: Setting this value to true suppresses the specified device included in the block device mapping of the AMI.
        :param str virtual_name: The name of the virtual device.
        """
        LaunchConfigurationBlockDeviceMapping._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            device_name=device_name,
            ebs=ebs,
            no_device=no_device,
            virtual_name=virtual_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             device_name: str,
             ebs: Optional['outputs.LaunchConfigurationBlockDevice'] = None,
             no_device: Optional[bool] = None,
             virtual_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("device_name", device_name)
        if ebs is not None:
            _setter("ebs", ebs)
        if no_device is not None:
            _setter("no_device", no_device)
        if virtual_name is not None:
            _setter("virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> str:
        """
        The device name exposed to the EC2 instance (for example, /dev/sdh or xvdh). 
        """
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter
    def ebs(self) -> Optional['outputs.LaunchConfigurationBlockDevice']:
        """
        Parameters used to automatically set up EBS volumes when an instance is launched.
        """
        return pulumi.get(self, "ebs")

    @property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[bool]:
        """
        Setting this value to true suppresses the specified device included in the block device mapping of the AMI.
        """
        return pulumi.get(self, "no_device")

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[str]:
        """
        The name of the virtual device.
        """
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class LaunchConfigurationMetadataOptions(dict):
    """
    MetadataOptions is a property of AWS::AutoScaling::LaunchConfiguration that describes metadata options for the instances.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpEndpoint":
            suggest = "http_endpoint"
        elif key == "httpPutResponseHopLimit":
            suggest = "http_put_response_hop_limit"
        elif key == "httpTokens":
            suggest = "http_tokens"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LaunchConfigurationMetadataOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LaunchConfigurationMetadataOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LaunchConfigurationMetadataOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_endpoint: Optional[str] = None,
                 http_put_response_hop_limit: Optional[int] = None,
                 http_tokens: Optional[str] = None):
        """
        MetadataOptions is a property of AWS::AutoScaling::LaunchConfiguration that describes metadata options for the instances.
        :param str http_endpoint: This parameter enables or disables the HTTP metadata endpoint on your instances.
        :param int http_put_response_hop_limit: The desired HTTP PUT response hop limit for instance metadata requests.
        :param str http_tokens: The state of token usage for your instance metadata requests.
        """
        LaunchConfigurationMetadataOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            http_endpoint=http_endpoint,
            http_put_response_hop_limit=http_put_response_hop_limit,
            http_tokens=http_tokens,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             http_endpoint: Optional[str] = None,
             http_put_response_hop_limit: Optional[int] = None,
             http_tokens: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if http_endpoint is not None:
            _setter("http_endpoint", http_endpoint)
        if http_put_response_hop_limit is not None:
            _setter("http_put_response_hop_limit", http_put_response_hop_limit)
        if http_tokens is not None:
            _setter("http_tokens", http_tokens)

    @property
    @pulumi.getter(name="httpEndpoint")
    def http_endpoint(self) -> Optional[str]:
        """
        This parameter enables or disables the HTTP metadata endpoint on your instances.
        """
        return pulumi.get(self, "http_endpoint")

    @property
    @pulumi.getter(name="httpPutResponseHopLimit")
    def http_put_response_hop_limit(self) -> Optional[int]:
        """
        The desired HTTP PUT response hop limit for instance metadata requests.
        """
        return pulumi.get(self, "http_put_response_hop_limit")

    @property
    @pulumi.getter(name="httpTokens")
    def http_tokens(self) -> Optional[str]:
        """
        The state of token usage for your instance metadata requests.
        """
        return pulumi.get(self, "http_tokens")


@pulumi.output_type
class ScalingPolicyCustomizedMetricSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScalingPolicyCustomizedMetricSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScalingPolicyCustomizedMetricSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScalingPolicyCustomizedMetricSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_name: str,
                 namespace: str,
                 statistic: str,
                 dimensions: Optional[Sequence['outputs.ScalingPolicyMetricDimension']] = None,
                 unit: Optional[str] = None):
        ScalingPolicyCustomizedMetricSpecification._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric_name=metric_name,
            namespace=namespace,
            statistic=statistic,
            dimensions=dimensions,
            unit=unit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric_name: str,
             namespace: str,
             statistic: str,
             dimensions: Optional[Sequence['outputs.ScalingPolicyMetricDimension']] = None,
             unit: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("metric_name", metric_name)
        _setter("namespace", namespace)
        _setter("statistic", statistic)
        if dimensions is not None:
            _setter("dimensions", dimensions)
        if unit is not None:
            _setter("unit", unit)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def statistic(self) -> str:
        return pulumi.get(self, "statistic")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.ScalingPolicyMetricDimension']]:
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter
    def unit(self) -> Optional[str]:
        return pulumi.get(self, "unit")


@pulumi.output_type
class ScalingPolicyMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScalingPolicyMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScalingPolicyMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScalingPolicyMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_name: str,
                 namespace: str,
                 dimensions: Optional[Sequence['outputs.ScalingPolicyMetricDimension']] = None):
        ScalingPolicyMetric._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric_name=metric_name,
            namespace=namespace,
            dimensions=dimensions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric_name: str,
             namespace: str,
             dimensions: Optional[Sequence['outputs.ScalingPolicyMetricDimension']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("metric_name", metric_name)
        _setter("namespace", namespace)
        if dimensions is not None:
            _setter("dimensions", dimensions)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[Sequence['outputs.ScalingPolicyMetricDimension']]:
        return pulumi.get(self, "dimensions")


@pulumi.output_type
class ScalingPolicyMetricDataQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricStat":
            suggest = "metric_stat"
        elif key == "returnData":
            suggest = "return_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScalingPolicyMetricDataQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScalingPolicyMetricDataQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScalingPolicyMetricDataQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 expression: Optional[str] = None,
                 label: Optional[str] = None,
                 metric_stat: Optional['outputs.ScalingPolicyMetricStat'] = None,
                 return_data: Optional[bool] = None):
        ScalingPolicyMetricDataQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            expression=expression,
            label=label,
            metric_stat=metric_stat,
            return_data=return_data,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             expression: Optional[str] = None,
             label: Optional[str] = None,
             metric_stat: Optional['outputs.ScalingPolicyMetricStat'] = None,
             return_data: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        if expression is not None:
            _setter("expression", expression)
        if label is not None:
            _setter("label", label)
        if metric_stat is not None:
            _setter("metric_stat", metric_stat)
        if return_data is not None:
            _setter("return_data", return_data)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter(name="metricStat")
    def metric_stat(self) -> Optional['outputs.ScalingPolicyMetricStat']:
        return pulumi.get(self, "metric_stat")

    @property
    @pulumi.getter(name="returnData")
    def return_data(self) -> Optional[bool]:
        return pulumi.get(self, "return_data")


@pulumi.output_type
class ScalingPolicyMetricDimension(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        ScalingPolicyMetricDimension._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class ScalingPolicyMetricStat(dict):
    def __init__(__self__, *,
                 metric: 'outputs.ScalingPolicyMetric',
                 stat: str,
                 unit: Optional[str] = None):
        ScalingPolicyMetricStat._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric=metric,
            stat=stat,
            unit=unit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric: 'outputs.ScalingPolicyMetric',
             stat: str,
             unit: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("metric", metric)
        _setter("stat", stat)
        if unit is not None:
            _setter("unit", unit)

    @property
    @pulumi.getter
    def metric(self) -> 'outputs.ScalingPolicyMetric':
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def stat(self) -> str:
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter
    def unit(self) -> Optional[str]:
        return pulumi.get(self, "unit")


@pulumi.output_type
class ScalingPolicyPredefinedMetricSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "predefinedMetricType":
            suggest = "predefined_metric_type"
        elif key == "resourceLabel":
            suggest = "resource_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScalingPolicyPredefinedMetricSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScalingPolicyPredefinedMetricSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScalingPolicyPredefinedMetricSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 predefined_metric_type: str,
                 resource_label: Optional[str] = None):
        ScalingPolicyPredefinedMetricSpecification._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            predefined_metric_type=predefined_metric_type,
            resource_label=resource_label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             predefined_metric_type: str,
             resource_label: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("predefined_metric_type", predefined_metric_type)
        if resource_label is not None:
            _setter("resource_label", resource_label)

    @property
    @pulumi.getter(name="predefinedMetricType")
    def predefined_metric_type(self) -> str:
        return pulumi.get(self, "predefined_metric_type")

    @property
    @pulumi.getter(name="resourceLabel")
    def resource_label(self) -> Optional[str]:
        return pulumi.get(self, "resource_label")


@pulumi.output_type
class ScalingPolicyPredictiveScalingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricSpecifications":
            suggest = "metric_specifications"
        elif key == "maxCapacityBreachBehavior":
            suggest = "max_capacity_breach_behavior"
        elif key == "maxCapacityBuffer":
            suggest = "max_capacity_buffer"
        elif key == "schedulingBufferTime":
            suggest = "scheduling_buffer_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScalingPolicyPredictiveScalingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScalingPolicyPredictiveScalingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScalingPolicyPredictiveScalingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_specifications: Sequence['outputs.ScalingPolicyPredictiveScalingMetricSpecification'],
                 max_capacity_breach_behavior: Optional[str] = None,
                 max_capacity_buffer: Optional[int] = None,
                 mode: Optional[str] = None,
                 scheduling_buffer_time: Optional[int] = None):
        ScalingPolicyPredictiveScalingConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric_specifications=metric_specifications,
            max_capacity_breach_behavior=max_capacity_breach_behavior,
            max_capacity_buffer=max_capacity_buffer,
            mode=mode,
            scheduling_buffer_time=scheduling_buffer_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric_specifications: Sequence['outputs.ScalingPolicyPredictiveScalingMetricSpecification'],
             max_capacity_breach_behavior: Optional[str] = None,
             max_capacity_buffer: Optional[int] = None,
             mode: Optional[str] = None,
             scheduling_buffer_time: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("metric_specifications", metric_specifications)
        if max_capacity_breach_behavior is not None:
            _setter("max_capacity_breach_behavior", max_capacity_breach_behavior)
        if max_capacity_buffer is not None:
            _setter("max_capacity_buffer", max_capacity_buffer)
        if mode is not None:
            _setter("mode", mode)
        if scheduling_buffer_time is not None:
            _setter("scheduling_buffer_time", scheduling_buffer_time)

    @property
    @pulumi.getter(name="metricSpecifications")
    def metric_specifications(self) -> Sequence['outputs.ScalingPolicyPredictiveScalingMetricSpecification']:
        return pulumi.get(self, "metric_specifications")

    @property
    @pulumi.getter(name="maxCapacityBreachBehavior")
    def max_capacity_breach_behavior(self) -> Optional[str]:
        return pulumi.get(self, "max_capacity_breach_behavior")

    @property
    @pulumi.getter(name="maxCapacityBuffer")
    def max_capacity_buffer(self) -> Optional[int]:
        return pulumi.get(self, "max_capacity_buffer")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="schedulingBufferTime")
    def scheduling_buffer_time(self) -> Optional[int]:
        return pulumi.get(self, "scheduling_buffer_time")


@pulumi.output_type
class ScalingPolicyPredictiveScalingCustomizedCapacityMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricDataQueries":
            suggest = "metric_data_queries"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScalingPolicyPredictiveScalingCustomizedCapacityMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScalingPolicyPredictiveScalingCustomizedCapacityMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScalingPolicyPredictiveScalingCustomizedCapacityMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_data_queries: Sequence['outputs.ScalingPolicyMetricDataQuery']):
        ScalingPolicyPredictiveScalingCustomizedCapacityMetric._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric_data_queries=metric_data_queries,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric_data_queries: Sequence['outputs.ScalingPolicyMetricDataQuery'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("metric_data_queries", metric_data_queries)

    @property
    @pulumi.getter(name="metricDataQueries")
    def metric_data_queries(self) -> Sequence['outputs.ScalingPolicyMetricDataQuery']:
        return pulumi.get(self, "metric_data_queries")


@pulumi.output_type
class ScalingPolicyPredictiveScalingCustomizedLoadMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricDataQueries":
            suggest = "metric_data_queries"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScalingPolicyPredictiveScalingCustomizedLoadMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScalingPolicyPredictiveScalingCustomizedLoadMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScalingPolicyPredictiveScalingCustomizedLoadMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_data_queries: Sequence['outputs.ScalingPolicyMetricDataQuery']):
        ScalingPolicyPredictiveScalingCustomizedLoadMetric._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric_data_queries=metric_data_queries,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric_data_queries: Sequence['outputs.ScalingPolicyMetricDataQuery'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("metric_data_queries", metric_data_queries)

    @property
    @pulumi.getter(name="metricDataQueries")
    def metric_data_queries(self) -> Sequence['outputs.ScalingPolicyMetricDataQuery']:
        return pulumi.get(self, "metric_data_queries")


@pulumi.output_type
class ScalingPolicyPredictiveScalingCustomizedScalingMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricDataQueries":
            suggest = "metric_data_queries"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScalingPolicyPredictiveScalingCustomizedScalingMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScalingPolicyPredictiveScalingCustomizedScalingMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScalingPolicyPredictiveScalingCustomizedScalingMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_data_queries: Sequence['outputs.ScalingPolicyMetricDataQuery']):
        ScalingPolicyPredictiveScalingCustomizedScalingMetric._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric_data_queries=metric_data_queries,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric_data_queries: Sequence['outputs.ScalingPolicyMetricDataQuery'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("metric_data_queries", metric_data_queries)

    @property
    @pulumi.getter(name="metricDataQueries")
    def metric_data_queries(self) -> Sequence['outputs.ScalingPolicyMetricDataQuery']:
        return pulumi.get(self, "metric_data_queries")


@pulumi.output_type
class ScalingPolicyPredictiveScalingMetricSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetValue":
            suggest = "target_value"
        elif key == "customizedCapacityMetricSpecification":
            suggest = "customized_capacity_metric_specification"
        elif key == "customizedLoadMetricSpecification":
            suggest = "customized_load_metric_specification"
        elif key == "customizedScalingMetricSpecification":
            suggest = "customized_scaling_metric_specification"
        elif key == "predefinedLoadMetricSpecification":
            suggest = "predefined_load_metric_specification"
        elif key == "predefinedMetricPairSpecification":
            suggest = "predefined_metric_pair_specification"
        elif key == "predefinedScalingMetricSpecification":
            suggest = "predefined_scaling_metric_specification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScalingPolicyPredictiveScalingMetricSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScalingPolicyPredictiveScalingMetricSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScalingPolicyPredictiveScalingMetricSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_value: float,
                 customized_capacity_metric_specification: Optional['outputs.ScalingPolicyPredictiveScalingCustomizedCapacityMetric'] = None,
                 customized_load_metric_specification: Optional['outputs.ScalingPolicyPredictiveScalingCustomizedLoadMetric'] = None,
                 customized_scaling_metric_specification: Optional['outputs.ScalingPolicyPredictiveScalingCustomizedScalingMetric'] = None,
                 predefined_load_metric_specification: Optional['outputs.ScalingPolicyPredictiveScalingPredefinedLoadMetric'] = None,
                 predefined_metric_pair_specification: Optional['outputs.ScalingPolicyPredictiveScalingPredefinedMetricPair'] = None,
                 predefined_scaling_metric_specification: Optional['outputs.ScalingPolicyPredictiveScalingPredefinedScalingMetric'] = None):
        ScalingPolicyPredictiveScalingMetricSpecification._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target_value=target_value,
            customized_capacity_metric_specification=customized_capacity_metric_specification,
            customized_load_metric_specification=customized_load_metric_specification,
            customized_scaling_metric_specification=customized_scaling_metric_specification,
            predefined_load_metric_specification=predefined_load_metric_specification,
            predefined_metric_pair_specification=predefined_metric_pair_specification,
            predefined_scaling_metric_specification=predefined_scaling_metric_specification,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target_value: float,
             customized_capacity_metric_specification: Optional['outputs.ScalingPolicyPredictiveScalingCustomizedCapacityMetric'] = None,
             customized_load_metric_specification: Optional['outputs.ScalingPolicyPredictiveScalingCustomizedLoadMetric'] = None,
             customized_scaling_metric_specification: Optional['outputs.ScalingPolicyPredictiveScalingCustomizedScalingMetric'] = None,
             predefined_load_metric_specification: Optional['outputs.ScalingPolicyPredictiveScalingPredefinedLoadMetric'] = None,
             predefined_metric_pair_specification: Optional['outputs.ScalingPolicyPredictiveScalingPredefinedMetricPair'] = None,
             predefined_scaling_metric_specification: Optional['outputs.ScalingPolicyPredictiveScalingPredefinedScalingMetric'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("target_value", target_value)
        if customized_capacity_metric_specification is not None:
            _setter("customized_capacity_metric_specification", customized_capacity_metric_specification)
        if customized_load_metric_specification is not None:
            _setter("customized_load_metric_specification", customized_load_metric_specification)
        if customized_scaling_metric_specification is not None:
            _setter("customized_scaling_metric_specification", customized_scaling_metric_specification)
        if predefined_load_metric_specification is not None:
            _setter("predefined_load_metric_specification", predefined_load_metric_specification)
        if predefined_metric_pair_specification is not None:
            _setter("predefined_metric_pair_specification", predefined_metric_pair_specification)
        if predefined_scaling_metric_specification is not None:
            _setter("predefined_scaling_metric_specification", predefined_scaling_metric_specification)

    @property
    @pulumi.getter(name="targetValue")
    def target_value(self) -> float:
        return pulumi.get(self, "target_value")

    @property
    @pulumi.getter(name="customizedCapacityMetricSpecification")
    def customized_capacity_metric_specification(self) -> Optional['outputs.ScalingPolicyPredictiveScalingCustomizedCapacityMetric']:
        return pulumi.get(self, "customized_capacity_metric_specification")

    @property
    @pulumi.getter(name="customizedLoadMetricSpecification")
    def customized_load_metric_specification(self) -> Optional['outputs.ScalingPolicyPredictiveScalingCustomizedLoadMetric']:
        return pulumi.get(self, "customized_load_metric_specification")

    @property
    @pulumi.getter(name="customizedScalingMetricSpecification")
    def customized_scaling_metric_specification(self) -> Optional['outputs.ScalingPolicyPredictiveScalingCustomizedScalingMetric']:
        return pulumi.get(self, "customized_scaling_metric_specification")

    @property
    @pulumi.getter(name="predefinedLoadMetricSpecification")
    def predefined_load_metric_specification(self) -> Optional['outputs.ScalingPolicyPredictiveScalingPredefinedLoadMetric']:
        return pulumi.get(self, "predefined_load_metric_specification")

    @property
    @pulumi.getter(name="predefinedMetricPairSpecification")
    def predefined_metric_pair_specification(self) -> Optional['outputs.ScalingPolicyPredictiveScalingPredefinedMetricPair']:
        return pulumi.get(self, "predefined_metric_pair_specification")

    @property
    @pulumi.getter(name="predefinedScalingMetricSpecification")
    def predefined_scaling_metric_specification(self) -> Optional['outputs.ScalingPolicyPredictiveScalingPredefinedScalingMetric']:
        return pulumi.get(self, "predefined_scaling_metric_specification")


@pulumi.output_type
class ScalingPolicyPredictiveScalingPredefinedLoadMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "predefinedMetricType":
            suggest = "predefined_metric_type"
        elif key == "resourceLabel":
            suggest = "resource_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScalingPolicyPredictiveScalingPredefinedLoadMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScalingPolicyPredictiveScalingPredefinedLoadMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScalingPolicyPredictiveScalingPredefinedLoadMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 predefined_metric_type: str,
                 resource_label: Optional[str] = None):
        ScalingPolicyPredictiveScalingPredefinedLoadMetric._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            predefined_metric_type=predefined_metric_type,
            resource_label=resource_label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             predefined_metric_type: str,
             resource_label: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("predefined_metric_type", predefined_metric_type)
        if resource_label is not None:
            _setter("resource_label", resource_label)

    @property
    @pulumi.getter(name="predefinedMetricType")
    def predefined_metric_type(self) -> str:
        return pulumi.get(self, "predefined_metric_type")

    @property
    @pulumi.getter(name="resourceLabel")
    def resource_label(self) -> Optional[str]:
        return pulumi.get(self, "resource_label")


@pulumi.output_type
class ScalingPolicyPredictiveScalingPredefinedMetricPair(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "predefinedMetricType":
            suggest = "predefined_metric_type"
        elif key == "resourceLabel":
            suggest = "resource_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScalingPolicyPredictiveScalingPredefinedMetricPair. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScalingPolicyPredictiveScalingPredefinedMetricPair.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScalingPolicyPredictiveScalingPredefinedMetricPair.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 predefined_metric_type: str,
                 resource_label: Optional[str] = None):
        ScalingPolicyPredictiveScalingPredefinedMetricPair._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            predefined_metric_type=predefined_metric_type,
            resource_label=resource_label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             predefined_metric_type: str,
             resource_label: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("predefined_metric_type", predefined_metric_type)
        if resource_label is not None:
            _setter("resource_label", resource_label)

    @property
    @pulumi.getter(name="predefinedMetricType")
    def predefined_metric_type(self) -> str:
        return pulumi.get(self, "predefined_metric_type")

    @property
    @pulumi.getter(name="resourceLabel")
    def resource_label(self) -> Optional[str]:
        return pulumi.get(self, "resource_label")


@pulumi.output_type
class ScalingPolicyPredictiveScalingPredefinedScalingMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "predefinedMetricType":
            suggest = "predefined_metric_type"
        elif key == "resourceLabel":
            suggest = "resource_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScalingPolicyPredictiveScalingPredefinedScalingMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScalingPolicyPredictiveScalingPredefinedScalingMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScalingPolicyPredictiveScalingPredefinedScalingMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 predefined_metric_type: str,
                 resource_label: Optional[str] = None):
        ScalingPolicyPredictiveScalingPredefinedScalingMetric._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            predefined_metric_type=predefined_metric_type,
            resource_label=resource_label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             predefined_metric_type: str,
             resource_label: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("predefined_metric_type", predefined_metric_type)
        if resource_label is not None:
            _setter("resource_label", resource_label)

    @property
    @pulumi.getter(name="predefinedMetricType")
    def predefined_metric_type(self) -> str:
        return pulumi.get(self, "predefined_metric_type")

    @property
    @pulumi.getter(name="resourceLabel")
    def resource_label(self) -> Optional[str]:
        return pulumi.get(self, "resource_label")


@pulumi.output_type
class ScalingPolicyStepAdjustment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scalingAdjustment":
            suggest = "scaling_adjustment"
        elif key == "metricIntervalLowerBound":
            suggest = "metric_interval_lower_bound"
        elif key == "metricIntervalUpperBound":
            suggest = "metric_interval_upper_bound"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScalingPolicyStepAdjustment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScalingPolicyStepAdjustment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScalingPolicyStepAdjustment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scaling_adjustment: int,
                 metric_interval_lower_bound: Optional[float] = None,
                 metric_interval_upper_bound: Optional[float] = None):
        ScalingPolicyStepAdjustment._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            scaling_adjustment=scaling_adjustment,
            metric_interval_lower_bound=metric_interval_lower_bound,
            metric_interval_upper_bound=metric_interval_upper_bound,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             scaling_adjustment: int,
             metric_interval_lower_bound: Optional[float] = None,
             metric_interval_upper_bound: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("scaling_adjustment", scaling_adjustment)
        if metric_interval_lower_bound is not None:
            _setter("metric_interval_lower_bound", metric_interval_lower_bound)
        if metric_interval_upper_bound is not None:
            _setter("metric_interval_upper_bound", metric_interval_upper_bound)

    @property
    @pulumi.getter(name="scalingAdjustment")
    def scaling_adjustment(self) -> int:
        return pulumi.get(self, "scaling_adjustment")

    @property
    @pulumi.getter(name="metricIntervalLowerBound")
    def metric_interval_lower_bound(self) -> Optional[float]:
        return pulumi.get(self, "metric_interval_lower_bound")

    @property
    @pulumi.getter(name="metricIntervalUpperBound")
    def metric_interval_upper_bound(self) -> Optional[float]:
        return pulumi.get(self, "metric_interval_upper_bound")


@pulumi.output_type
class ScalingPolicyTargetTrackingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetValue":
            suggest = "target_value"
        elif key == "customizedMetricSpecification":
            suggest = "customized_metric_specification"
        elif key == "disableScaleIn":
            suggest = "disable_scale_in"
        elif key == "predefinedMetricSpecification":
            suggest = "predefined_metric_specification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScalingPolicyTargetTrackingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScalingPolicyTargetTrackingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScalingPolicyTargetTrackingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_value: float,
                 customized_metric_specification: Optional['outputs.ScalingPolicyCustomizedMetricSpecification'] = None,
                 disable_scale_in: Optional[bool] = None,
                 predefined_metric_specification: Optional['outputs.ScalingPolicyPredefinedMetricSpecification'] = None):
        ScalingPolicyTargetTrackingConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target_value=target_value,
            customized_metric_specification=customized_metric_specification,
            disable_scale_in=disable_scale_in,
            predefined_metric_specification=predefined_metric_specification,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target_value: float,
             customized_metric_specification: Optional['outputs.ScalingPolicyCustomizedMetricSpecification'] = None,
             disable_scale_in: Optional[bool] = None,
             predefined_metric_specification: Optional['outputs.ScalingPolicyPredefinedMetricSpecification'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("target_value", target_value)
        if customized_metric_specification is not None:
            _setter("customized_metric_specification", customized_metric_specification)
        if disable_scale_in is not None:
            _setter("disable_scale_in", disable_scale_in)
        if predefined_metric_specification is not None:
            _setter("predefined_metric_specification", predefined_metric_specification)

    @property
    @pulumi.getter(name="targetValue")
    def target_value(self) -> float:
        return pulumi.get(self, "target_value")

    @property
    @pulumi.getter(name="customizedMetricSpecification")
    def customized_metric_specification(self) -> Optional['outputs.ScalingPolicyCustomizedMetricSpecification']:
        return pulumi.get(self, "customized_metric_specification")

    @property
    @pulumi.getter(name="disableScaleIn")
    def disable_scale_in(self) -> Optional[bool]:
        return pulumi.get(self, "disable_scale_in")

    @property
    @pulumi.getter(name="predefinedMetricSpecification")
    def predefined_metric_specification(self) -> Optional['outputs.ScalingPolicyPredefinedMetricSpecification']:
        return pulumi.get(self, "predefined_metric_specification")


@pulumi.output_type
class WarmPoolInstanceReusePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "reuseOnScaleIn":
            suggest = "reuse_on_scale_in"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WarmPoolInstanceReusePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WarmPoolInstanceReusePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WarmPoolInstanceReusePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 reuse_on_scale_in: Optional[bool] = None):
        WarmPoolInstanceReusePolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            reuse_on_scale_in=reuse_on_scale_in,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             reuse_on_scale_in: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if reuse_on_scale_in is not None:
            _setter("reuse_on_scale_in", reuse_on_scale_in)

    @property
    @pulumi.getter(name="reuseOnScaleIn")
    def reuse_on_scale_in(self) -> Optional[bool]:
        return pulumi.get(self, "reuse_on_scale_in")


