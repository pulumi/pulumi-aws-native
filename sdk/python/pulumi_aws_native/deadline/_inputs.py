# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'FleetAcceleratorCapabilitiesArgs',
    'FleetAcceleratorCapabilitiesArgsDict',
    'FleetAcceleratorCountRangeArgs',
    'FleetAcceleratorCountRangeArgsDict',
    'FleetAcceleratorSelectionArgs',
    'FleetAcceleratorSelectionArgsDict',
    'FleetAcceleratorTotalMemoryMiBRangeArgs',
    'FleetAcceleratorTotalMemoryMiBRangeArgsDict',
    'FleetAmountCapabilityArgs',
    'FleetAmountCapabilityArgsDict',
    'FleetAttributeCapabilityArgs',
    'FleetAttributeCapabilityArgsDict',
    'FleetConfiguration0PropertiesArgs',
    'FleetConfiguration0PropertiesArgsDict',
    'FleetConfiguration1PropertiesArgs',
    'FleetConfiguration1PropertiesArgsDict',
    'FleetCustomerManagedFleetConfigurationArgs',
    'FleetCustomerManagedFleetConfigurationArgsDict',
    'FleetCustomerManagedWorkerCapabilitiesArgs',
    'FleetCustomerManagedWorkerCapabilitiesArgsDict',
    'FleetEc2EbsVolumeArgs',
    'FleetEc2EbsVolumeArgsDict',
    'FleetHostConfigurationArgs',
    'FleetHostConfigurationArgsDict',
    'FleetMemoryMiBRangeArgs',
    'FleetMemoryMiBRangeArgsDict',
    'FleetServiceManagedEc2FleetConfigurationArgs',
    'FleetServiceManagedEc2FleetConfigurationArgsDict',
    'FleetServiceManagedEc2InstanceCapabilitiesArgs',
    'FleetServiceManagedEc2InstanceCapabilitiesArgsDict',
    'FleetServiceManagedEc2InstanceMarketOptionsArgs',
    'FleetServiceManagedEc2InstanceMarketOptionsArgsDict',
    'FleetVCpuCountRangeArgs',
    'FleetVCpuCountRangeArgsDict',
    'FleetVpcConfigurationArgs',
    'FleetVpcConfigurationArgsDict',
    'QueueJobAttachmentSettingsArgs',
    'QueueJobAttachmentSettingsArgsDict',
    'QueueJobRunAsUserArgs',
    'QueueJobRunAsUserArgsDict',
    'QueuePosixUserArgs',
    'QueuePosixUserArgsDict',
    'QueueWindowsUserArgs',
    'QueueWindowsUserArgsDict',
    'StorageProfileFileSystemLocationArgs',
    'StorageProfileFileSystemLocationArgsDict',
]

MYPY = False

if not MYPY:
    class FleetAcceleratorCapabilitiesArgsDict(TypedDict):
        selections: pulumi.Input[Sequence[pulumi.Input['FleetAcceleratorSelectionArgsDict']]]
        count: NotRequired[pulumi.Input['FleetAcceleratorCountRangeArgsDict']]
elif False:
    FleetAcceleratorCapabilitiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetAcceleratorCapabilitiesArgs:
    def __init__(__self__, *,
                 selections: pulumi.Input[Sequence[pulumi.Input['FleetAcceleratorSelectionArgs']]],
                 count: Optional[pulumi.Input['FleetAcceleratorCountRangeArgs']] = None):
        pulumi.set(__self__, "selections", selections)
        if count is not None:
            pulumi.set(__self__, "count", count)

    @_builtins.property
    @pulumi.getter
    def selections(self) -> pulumi.Input[Sequence[pulumi.Input['FleetAcceleratorSelectionArgs']]]:
        return pulumi.get(self, "selections")

    @selections.setter
    def selections(self, value: pulumi.Input[Sequence[pulumi.Input['FleetAcceleratorSelectionArgs']]]):
        pulumi.set(self, "selections", value)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input['FleetAcceleratorCountRangeArgs']]:
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input['FleetAcceleratorCountRangeArgs']]):
        pulumi.set(self, "count", value)


if not MYPY:
    class FleetAcceleratorCountRangeArgsDict(TypedDict):
        min: pulumi.Input[_builtins.int]
        max: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    FleetAcceleratorCountRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetAcceleratorCountRangeArgs:
    def __init__(__self__, *,
                 min: pulumi.Input[_builtins.int],
                 max: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "min", min)
        if max is not None:
            pulumi.set(__self__, "max", max)

    @_builtins.property
    @pulumi.getter
    def min(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "min", value)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max", value)


if not MYPY:
    class FleetAcceleratorSelectionArgsDict(TypedDict):
        name: pulumi.Input['FleetAcceleratorSelectionName']
        runtime: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    FleetAcceleratorSelectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetAcceleratorSelectionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input['FleetAcceleratorSelectionName'],
                 runtime: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        if runtime is not None:
            pulumi.set(__self__, "runtime", runtime)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input['FleetAcceleratorSelectionName']:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input['FleetAcceleratorSelectionName']):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def runtime(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "runtime")

    @runtime.setter
    def runtime(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "runtime", value)


if not MYPY:
    class FleetAcceleratorTotalMemoryMiBRangeArgsDict(TypedDict):
        min: pulumi.Input[_builtins.int]
        max: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    FleetAcceleratorTotalMemoryMiBRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetAcceleratorTotalMemoryMiBRangeArgs:
    def __init__(__self__, *,
                 min: pulumi.Input[_builtins.int],
                 max: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "min", min)
        if max is not None:
            pulumi.set(__self__, "max", max)

    @_builtins.property
    @pulumi.getter
    def min(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "min", value)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max", value)


if not MYPY:
    class FleetAmountCapabilityArgsDict(TypedDict):
        min: pulumi.Input[_builtins.float]
        """
        The minimum amount of fleet worker capability.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the fleet capability.
        """
        max: NotRequired[pulumi.Input[_builtins.float]]
        """
        The maximum amount of the fleet worker capability.
        """
elif False:
    FleetAmountCapabilityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetAmountCapabilityArgs:
    def __init__(__self__, *,
                 min: pulumi.Input[_builtins.float],
                 name: pulumi.Input[_builtins.str],
                 max: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] min: The minimum amount of fleet worker capability.
        :param pulumi.Input[_builtins.str] name: The name of the fleet capability.
        :param pulumi.Input[_builtins.float] max: The maximum amount of the fleet worker capability.
        """
        pulumi.set(__self__, "min", min)
        pulumi.set(__self__, "name", name)
        if max is not None:
            pulumi.set(__self__, "max", max)

    @_builtins.property
    @pulumi.getter
    def min(self) -> pulumi.Input[_builtins.float]:
        """
        The minimum amount of fleet worker capability.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "min", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the fleet capability.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The maximum amount of the fleet worker capability.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "max", value)


if not MYPY:
    class FleetAttributeCapabilityArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of the fleet attribute capability for the worker.
        """
        values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The number of fleet attribute capabilities.
        """
elif False:
    FleetAttributeCapabilityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetAttributeCapabilityArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[_builtins.str] name: The name of the fleet attribute capability for the worker.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] values: The number of fleet attribute capabilities.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the fleet attribute capability for the worker.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The number of fleet attribute capabilities.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class FleetConfiguration0PropertiesArgsDict(TypedDict):
        customer_managed: pulumi.Input['FleetCustomerManagedFleetConfigurationArgsDict']
elif False:
    FleetConfiguration0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetConfiguration0PropertiesArgs:
    def __init__(__self__, *,
                 customer_managed: pulumi.Input['FleetCustomerManagedFleetConfigurationArgs']):
        pulumi.set(__self__, "customer_managed", customer_managed)

    @_builtins.property
    @pulumi.getter(name="customerManaged")
    def customer_managed(self) -> pulumi.Input['FleetCustomerManagedFleetConfigurationArgs']:
        return pulumi.get(self, "customer_managed")

    @customer_managed.setter
    def customer_managed(self, value: pulumi.Input['FleetCustomerManagedFleetConfigurationArgs']):
        pulumi.set(self, "customer_managed", value)


if not MYPY:
    class FleetConfiguration1PropertiesArgsDict(TypedDict):
        service_managed_ec2: pulumi.Input['FleetServiceManagedEc2FleetConfigurationArgsDict']
elif False:
    FleetConfiguration1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetConfiguration1PropertiesArgs:
    def __init__(__self__, *,
                 service_managed_ec2: pulumi.Input['FleetServiceManagedEc2FleetConfigurationArgs']):
        pulumi.set(__self__, "service_managed_ec2", service_managed_ec2)

    @_builtins.property
    @pulumi.getter(name="serviceManagedEc2")
    def service_managed_ec2(self) -> pulumi.Input['FleetServiceManagedEc2FleetConfigurationArgs']:
        return pulumi.get(self, "service_managed_ec2")

    @service_managed_ec2.setter
    def service_managed_ec2(self, value: pulumi.Input['FleetServiceManagedEc2FleetConfigurationArgs']):
        pulumi.set(self, "service_managed_ec2", value)


if not MYPY:
    class FleetCustomerManagedFleetConfigurationArgsDict(TypedDict):
        mode: pulumi.Input['FleetAutoScalingMode']
        worker_capabilities: pulumi.Input['FleetCustomerManagedWorkerCapabilitiesArgsDict']
        storage_profile_id: NotRequired[pulumi.Input[_builtins.str]]
        tag_propagation_mode: NotRequired[pulumi.Input['FleetTagPropagationMode']]
elif False:
    FleetCustomerManagedFleetConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetCustomerManagedFleetConfigurationArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input['FleetAutoScalingMode'],
                 worker_capabilities: pulumi.Input['FleetCustomerManagedWorkerCapabilitiesArgs'],
                 storage_profile_id: Optional[pulumi.Input[_builtins.str]] = None,
                 tag_propagation_mode: Optional[pulumi.Input['FleetTagPropagationMode']] = None):
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "worker_capabilities", worker_capabilities)
        if storage_profile_id is not None:
            pulumi.set(__self__, "storage_profile_id", storage_profile_id)
        if tag_propagation_mode is not None:
            pulumi.set(__self__, "tag_propagation_mode", tag_propagation_mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> pulumi.Input['FleetAutoScalingMode']:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input['FleetAutoScalingMode']):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter(name="workerCapabilities")
    def worker_capabilities(self) -> pulumi.Input['FleetCustomerManagedWorkerCapabilitiesArgs']:
        return pulumi.get(self, "worker_capabilities")

    @worker_capabilities.setter
    def worker_capabilities(self, value: pulumi.Input['FleetCustomerManagedWorkerCapabilitiesArgs']):
        pulumi.set(self, "worker_capabilities", value)

    @_builtins.property
    @pulumi.getter(name="storageProfileId")
    def storage_profile_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "storage_profile_id")

    @storage_profile_id.setter
    def storage_profile_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "storage_profile_id", value)

    @_builtins.property
    @pulumi.getter(name="tagPropagationMode")
    def tag_propagation_mode(self) -> Optional[pulumi.Input['FleetTagPropagationMode']]:
        return pulumi.get(self, "tag_propagation_mode")

    @tag_propagation_mode.setter
    def tag_propagation_mode(self, value: Optional[pulumi.Input['FleetTagPropagationMode']]):
        pulumi.set(self, "tag_propagation_mode", value)


if not MYPY:
    class FleetCustomerManagedWorkerCapabilitiesArgsDict(TypedDict):
        cpu_architecture_type: pulumi.Input['FleetCpuArchitectureType']
        memory_mi_b: pulumi.Input['FleetMemoryMiBRangeArgsDict']
        os_family: pulumi.Input['FleetCustomerManagedFleetOperatingSystemFamily']
        v_cpu_count: pulumi.Input['FleetVCpuCountRangeArgsDict']
        accelerator_count: NotRequired[pulumi.Input['FleetAcceleratorCountRangeArgsDict']]
        accelerator_total_memory_mi_b: NotRequired[pulumi.Input['FleetAcceleratorTotalMemoryMiBRangeArgsDict']]
        accelerator_types: NotRequired[pulumi.Input[Sequence[pulumi.Input['FleetAcceleratorType']]]]
        custom_amounts: NotRequired[pulumi.Input[Sequence[pulumi.Input['FleetAmountCapabilityArgsDict']]]]
        custom_attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input['FleetAttributeCapabilityArgsDict']]]]
elif False:
    FleetCustomerManagedWorkerCapabilitiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetCustomerManagedWorkerCapabilitiesArgs:
    def __init__(__self__, *,
                 cpu_architecture_type: pulumi.Input['FleetCpuArchitectureType'],
                 memory_mi_b: pulumi.Input['FleetMemoryMiBRangeArgs'],
                 os_family: pulumi.Input['FleetCustomerManagedFleetOperatingSystemFamily'],
                 v_cpu_count: pulumi.Input['FleetVCpuCountRangeArgs'],
                 accelerator_count: Optional[pulumi.Input['FleetAcceleratorCountRangeArgs']] = None,
                 accelerator_total_memory_mi_b: Optional[pulumi.Input['FleetAcceleratorTotalMemoryMiBRangeArgs']] = None,
                 accelerator_types: Optional[pulumi.Input[Sequence[pulumi.Input['FleetAcceleratorType']]]] = None,
                 custom_amounts: Optional[pulumi.Input[Sequence[pulumi.Input['FleetAmountCapabilityArgs']]]] = None,
                 custom_attributes: Optional[pulumi.Input[Sequence[pulumi.Input['FleetAttributeCapabilityArgs']]]] = None):
        pulumi.set(__self__, "cpu_architecture_type", cpu_architecture_type)
        pulumi.set(__self__, "memory_mi_b", memory_mi_b)
        pulumi.set(__self__, "os_family", os_family)
        pulumi.set(__self__, "v_cpu_count", v_cpu_count)
        if accelerator_count is not None:
            pulumi.set(__self__, "accelerator_count", accelerator_count)
        if accelerator_total_memory_mi_b is not None:
            pulumi.set(__self__, "accelerator_total_memory_mi_b", accelerator_total_memory_mi_b)
        if accelerator_types is not None:
            pulumi.set(__self__, "accelerator_types", accelerator_types)
        if custom_amounts is not None:
            pulumi.set(__self__, "custom_amounts", custom_amounts)
        if custom_attributes is not None:
            pulumi.set(__self__, "custom_attributes", custom_attributes)

    @_builtins.property
    @pulumi.getter(name="cpuArchitectureType")
    def cpu_architecture_type(self) -> pulumi.Input['FleetCpuArchitectureType']:
        return pulumi.get(self, "cpu_architecture_type")

    @cpu_architecture_type.setter
    def cpu_architecture_type(self, value: pulumi.Input['FleetCpuArchitectureType']):
        pulumi.set(self, "cpu_architecture_type", value)

    @_builtins.property
    @pulumi.getter(name="memoryMiB")
    def memory_mi_b(self) -> pulumi.Input['FleetMemoryMiBRangeArgs']:
        return pulumi.get(self, "memory_mi_b")

    @memory_mi_b.setter
    def memory_mi_b(self, value: pulumi.Input['FleetMemoryMiBRangeArgs']):
        pulumi.set(self, "memory_mi_b", value)

    @_builtins.property
    @pulumi.getter(name="osFamily")
    def os_family(self) -> pulumi.Input['FleetCustomerManagedFleetOperatingSystemFamily']:
        return pulumi.get(self, "os_family")

    @os_family.setter
    def os_family(self, value: pulumi.Input['FleetCustomerManagedFleetOperatingSystemFamily']):
        pulumi.set(self, "os_family", value)

    @_builtins.property
    @pulumi.getter(name="vCpuCount")
    def v_cpu_count(self) -> pulumi.Input['FleetVCpuCountRangeArgs']:
        return pulumi.get(self, "v_cpu_count")

    @v_cpu_count.setter
    def v_cpu_count(self, value: pulumi.Input['FleetVCpuCountRangeArgs']):
        pulumi.set(self, "v_cpu_count", value)

    @_builtins.property
    @pulumi.getter(name="acceleratorCount")
    def accelerator_count(self) -> Optional[pulumi.Input['FleetAcceleratorCountRangeArgs']]:
        return pulumi.get(self, "accelerator_count")

    @accelerator_count.setter
    def accelerator_count(self, value: Optional[pulumi.Input['FleetAcceleratorCountRangeArgs']]):
        pulumi.set(self, "accelerator_count", value)

    @_builtins.property
    @pulumi.getter(name="acceleratorTotalMemoryMiB")
    def accelerator_total_memory_mi_b(self) -> Optional[pulumi.Input['FleetAcceleratorTotalMemoryMiBRangeArgs']]:
        return pulumi.get(self, "accelerator_total_memory_mi_b")

    @accelerator_total_memory_mi_b.setter
    def accelerator_total_memory_mi_b(self, value: Optional[pulumi.Input['FleetAcceleratorTotalMemoryMiBRangeArgs']]):
        pulumi.set(self, "accelerator_total_memory_mi_b", value)

    @_builtins.property
    @pulumi.getter(name="acceleratorTypes")
    def accelerator_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FleetAcceleratorType']]]]:
        return pulumi.get(self, "accelerator_types")

    @accelerator_types.setter
    def accelerator_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FleetAcceleratorType']]]]):
        pulumi.set(self, "accelerator_types", value)

    @_builtins.property
    @pulumi.getter(name="customAmounts")
    def custom_amounts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FleetAmountCapabilityArgs']]]]:
        return pulumi.get(self, "custom_amounts")

    @custom_amounts.setter
    def custom_amounts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FleetAmountCapabilityArgs']]]]):
        pulumi.set(self, "custom_amounts", value)

    @_builtins.property
    @pulumi.getter(name="customAttributes")
    def custom_attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FleetAttributeCapabilityArgs']]]]:
        return pulumi.get(self, "custom_attributes")

    @custom_attributes.setter
    def custom_attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FleetAttributeCapabilityArgs']]]]):
        pulumi.set(self, "custom_attributes", value)


if not MYPY:
    class FleetEc2EbsVolumeArgsDict(TypedDict):
        iops: NotRequired[pulumi.Input[_builtins.int]]
        size_gi_b: NotRequired[pulumi.Input[_builtins.int]]
        throughput_mi_b: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    FleetEc2EbsVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetEc2EbsVolumeArgs:
    def __init__(__self__, *,
                 iops: Optional[pulumi.Input[_builtins.int]] = None,
                 size_gi_b: Optional[pulumi.Input[_builtins.int]] = None,
                 throughput_mi_b: Optional[pulumi.Input[_builtins.int]] = None):
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if size_gi_b is not None:
            pulumi.set(__self__, "size_gi_b", size_gi_b)
        if throughput_mi_b is not None:
            pulumi.set(__self__, "throughput_mi_b", throughput_mi_b)

    @_builtins.property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "iops", value)

    @_builtins.property
    @pulumi.getter(name="sizeGiB")
    def size_gi_b(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "size_gi_b")

    @size_gi_b.setter
    def size_gi_b(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "size_gi_b", value)

    @_builtins.property
    @pulumi.getter(name="throughputMiB")
    def throughput_mi_b(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "throughput_mi_b")

    @throughput_mi_b.setter
    def throughput_mi_b(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "throughput_mi_b", value)


if not MYPY:
    class FleetHostConfigurationArgsDict(TypedDict):
        script_body: pulumi.Input[_builtins.str]
        """
        The text of the script that runs as a worker is starting up that you can use to provide additional configuration for workers in your fleet. The script runs after a worker enters the `STARTING` state and before the worker processes tasks.

        For more information about using the script, see [Run scripts as an administrator to configure workers](https://docs.aws.amazon.com/deadline-cloud/latest/developerguide/smf-admin.html) in the *Deadline Cloud Developer Guide* .

        > The script runs as an administrative user ( `sudo root` on Linux, as an Administrator on Windows).
        """
        script_timeout_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum time that the host configuration can run. If the timeout expires, the worker enters the `NOT RESPONDING` state and shuts down. You are charged for the time that the worker is running the host configuration script.

        > You should configure your fleet for a maximum of one worker while testing your host configuration script to avoid starting additional workers. 

        The default is 300 seconds (5 minutes).
        """
elif False:
    FleetHostConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetHostConfigurationArgs:
    def __init__(__self__, *,
                 script_body: pulumi.Input[_builtins.str],
                 script_timeout_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] script_body: The text of the script that runs as a worker is starting up that you can use to provide additional configuration for workers in your fleet. The script runs after a worker enters the `STARTING` state and before the worker processes tasks.
               
               For more information about using the script, see [Run scripts as an administrator to configure workers](https://docs.aws.amazon.com/deadline-cloud/latest/developerguide/smf-admin.html) in the *Deadline Cloud Developer Guide* .
               
               > The script runs as an administrative user ( `sudo root` on Linux, as an Administrator on Windows).
        :param pulumi.Input[_builtins.int] script_timeout_seconds: The maximum time that the host configuration can run. If the timeout expires, the worker enters the `NOT RESPONDING` state and shuts down. You are charged for the time that the worker is running the host configuration script.
               
               > You should configure your fleet for a maximum of one worker while testing your host configuration script to avoid starting additional workers. 
               
               The default is 300 seconds (5 minutes).
        """
        pulumi.set(__self__, "script_body", script_body)
        if script_timeout_seconds is not None:
            pulumi.set(__self__, "script_timeout_seconds", script_timeout_seconds)

    @_builtins.property
    @pulumi.getter(name="scriptBody")
    def script_body(self) -> pulumi.Input[_builtins.str]:
        """
        The text of the script that runs as a worker is starting up that you can use to provide additional configuration for workers in your fleet. The script runs after a worker enters the `STARTING` state and before the worker processes tasks.

        For more information about using the script, see [Run scripts as an administrator to configure workers](https://docs.aws.amazon.com/deadline-cloud/latest/developerguide/smf-admin.html) in the *Deadline Cloud Developer Guide* .

        > The script runs as an administrative user ( `sudo root` on Linux, as an Administrator on Windows).
        """
        return pulumi.get(self, "script_body")

    @script_body.setter
    def script_body(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "script_body", value)

    @_builtins.property
    @pulumi.getter(name="scriptTimeoutSeconds")
    def script_timeout_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum time that the host configuration can run. If the timeout expires, the worker enters the `NOT RESPONDING` state and shuts down. You are charged for the time that the worker is running the host configuration script.

        > You should configure your fleet for a maximum of one worker while testing your host configuration script to avoid starting additional workers. 

        The default is 300 seconds (5 minutes).
        """
        return pulumi.get(self, "script_timeout_seconds")

    @script_timeout_seconds.setter
    def script_timeout_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "script_timeout_seconds", value)


if not MYPY:
    class FleetMemoryMiBRangeArgsDict(TypedDict):
        min: pulumi.Input[_builtins.int]
        max: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    FleetMemoryMiBRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetMemoryMiBRangeArgs:
    def __init__(__self__, *,
                 min: pulumi.Input[_builtins.int],
                 max: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "min", min)
        if max is not None:
            pulumi.set(__self__, "max", max)

    @_builtins.property
    @pulumi.getter
    def min(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "min", value)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max", value)


if not MYPY:
    class FleetServiceManagedEc2FleetConfigurationArgsDict(TypedDict):
        instance_capabilities: pulumi.Input['FleetServiceManagedEc2InstanceCapabilitiesArgsDict']
        instance_market_options: pulumi.Input['FleetServiceManagedEc2InstanceMarketOptionsArgsDict']
        storage_profile_id: NotRequired[pulumi.Input[_builtins.str]]
        vpc_configuration: NotRequired[pulumi.Input['FleetVpcConfigurationArgsDict']]
elif False:
    FleetServiceManagedEc2FleetConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetServiceManagedEc2FleetConfigurationArgs:
    def __init__(__self__, *,
                 instance_capabilities: pulumi.Input['FleetServiceManagedEc2InstanceCapabilitiesArgs'],
                 instance_market_options: pulumi.Input['FleetServiceManagedEc2InstanceMarketOptionsArgs'],
                 storage_profile_id: Optional[pulumi.Input[_builtins.str]] = None,
                 vpc_configuration: Optional[pulumi.Input['FleetVpcConfigurationArgs']] = None):
        pulumi.set(__self__, "instance_capabilities", instance_capabilities)
        pulumi.set(__self__, "instance_market_options", instance_market_options)
        if storage_profile_id is not None:
            pulumi.set(__self__, "storage_profile_id", storage_profile_id)
        if vpc_configuration is not None:
            pulumi.set(__self__, "vpc_configuration", vpc_configuration)

    @_builtins.property
    @pulumi.getter(name="instanceCapabilities")
    def instance_capabilities(self) -> pulumi.Input['FleetServiceManagedEc2InstanceCapabilitiesArgs']:
        return pulumi.get(self, "instance_capabilities")

    @instance_capabilities.setter
    def instance_capabilities(self, value: pulumi.Input['FleetServiceManagedEc2InstanceCapabilitiesArgs']):
        pulumi.set(self, "instance_capabilities", value)

    @_builtins.property
    @pulumi.getter(name="instanceMarketOptions")
    def instance_market_options(self) -> pulumi.Input['FleetServiceManagedEc2InstanceMarketOptionsArgs']:
        return pulumi.get(self, "instance_market_options")

    @instance_market_options.setter
    def instance_market_options(self, value: pulumi.Input['FleetServiceManagedEc2InstanceMarketOptionsArgs']):
        pulumi.set(self, "instance_market_options", value)

    @_builtins.property
    @pulumi.getter(name="storageProfileId")
    def storage_profile_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "storage_profile_id")

    @storage_profile_id.setter
    def storage_profile_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "storage_profile_id", value)

    @_builtins.property
    @pulumi.getter(name="vpcConfiguration")
    def vpc_configuration(self) -> Optional[pulumi.Input['FleetVpcConfigurationArgs']]:
        return pulumi.get(self, "vpc_configuration")

    @vpc_configuration.setter
    def vpc_configuration(self, value: Optional[pulumi.Input['FleetVpcConfigurationArgs']]):
        pulumi.set(self, "vpc_configuration", value)


if not MYPY:
    class FleetServiceManagedEc2InstanceCapabilitiesArgsDict(TypedDict):
        cpu_architecture_type: pulumi.Input['FleetCpuArchitectureType']
        memory_mi_b: pulumi.Input['FleetMemoryMiBRangeArgsDict']
        os_family: pulumi.Input['FleetServiceManagedFleetOperatingSystemFamily']
        v_cpu_count: pulumi.Input['FleetVCpuCountRangeArgsDict']
        accelerator_capabilities: NotRequired[pulumi.Input['FleetAcceleratorCapabilitiesArgsDict']]
        allowed_instance_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        custom_amounts: NotRequired[pulumi.Input[Sequence[pulumi.Input['FleetAmountCapabilityArgsDict']]]]
        custom_attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input['FleetAttributeCapabilityArgsDict']]]]
        excluded_instance_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        root_ebs_volume: NotRequired[pulumi.Input['FleetEc2EbsVolumeArgsDict']]
elif False:
    FleetServiceManagedEc2InstanceCapabilitiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetServiceManagedEc2InstanceCapabilitiesArgs:
    def __init__(__self__, *,
                 cpu_architecture_type: pulumi.Input['FleetCpuArchitectureType'],
                 memory_mi_b: pulumi.Input['FleetMemoryMiBRangeArgs'],
                 os_family: pulumi.Input['FleetServiceManagedFleetOperatingSystemFamily'],
                 v_cpu_count: pulumi.Input['FleetVCpuCountRangeArgs'],
                 accelerator_capabilities: Optional[pulumi.Input['FleetAcceleratorCapabilitiesArgs']] = None,
                 allowed_instance_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 custom_amounts: Optional[pulumi.Input[Sequence[pulumi.Input['FleetAmountCapabilityArgs']]]] = None,
                 custom_attributes: Optional[pulumi.Input[Sequence[pulumi.Input['FleetAttributeCapabilityArgs']]]] = None,
                 excluded_instance_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 root_ebs_volume: Optional[pulumi.Input['FleetEc2EbsVolumeArgs']] = None):
        pulumi.set(__self__, "cpu_architecture_type", cpu_architecture_type)
        pulumi.set(__self__, "memory_mi_b", memory_mi_b)
        pulumi.set(__self__, "os_family", os_family)
        pulumi.set(__self__, "v_cpu_count", v_cpu_count)
        if accelerator_capabilities is not None:
            pulumi.set(__self__, "accelerator_capabilities", accelerator_capabilities)
        if allowed_instance_types is not None:
            pulumi.set(__self__, "allowed_instance_types", allowed_instance_types)
        if custom_amounts is not None:
            pulumi.set(__self__, "custom_amounts", custom_amounts)
        if custom_attributes is not None:
            pulumi.set(__self__, "custom_attributes", custom_attributes)
        if excluded_instance_types is not None:
            pulumi.set(__self__, "excluded_instance_types", excluded_instance_types)
        if root_ebs_volume is not None:
            pulumi.set(__self__, "root_ebs_volume", root_ebs_volume)

    @_builtins.property
    @pulumi.getter(name="cpuArchitectureType")
    def cpu_architecture_type(self) -> pulumi.Input['FleetCpuArchitectureType']:
        return pulumi.get(self, "cpu_architecture_type")

    @cpu_architecture_type.setter
    def cpu_architecture_type(self, value: pulumi.Input['FleetCpuArchitectureType']):
        pulumi.set(self, "cpu_architecture_type", value)

    @_builtins.property
    @pulumi.getter(name="memoryMiB")
    def memory_mi_b(self) -> pulumi.Input['FleetMemoryMiBRangeArgs']:
        return pulumi.get(self, "memory_mi_b")

    @memory_mi_b.setter
    def memory_mi_b(self, value: pulumi.Input['FleetMemoryMiBRangeArgs']):
        pulumi.set(self, "memory_mi_b", value)

    @_builtins.property
    @pulumi.getter(name="osFamily")
    def os_family(self) -> pulumi.Input['FleetServiceManagedFleetOperatingSystemFamily']:
        return pulumi.get(self, "os_family")

    @os_family.setter
    def os_family(self, value: pulumi.Input['FleetServiceManagedFleetOperatingSystemFamily']):
        pulumi.set(self, "os_family", value)

    @_builtins.property
    @pulumi.getter(name="vCpuCount")
    def v_cpu_count(self) -> pulumi.Input['FleetVCpuCountRangeArgs']:
        return pulumi.get(self, "v_cpu_count")

    @v_cpu_count.setter
    def v_cpu_count(self, value: pulumi.Input['FleetVCpuCountRangeArgs']):
        pulumi.set(self, "v_cpu_count", value)

    @_builtins.property
    @pulumi.getter(name="acceleratorCapabilities")
    def accelerator_capabilities(self) -> Optional[pulumi.Input['FleetAcceleratorCapabilitiesArgs']]:
        return pulumi.get(self, "accelerator_capabilities")

    @accelerator_capabilities.setter
    def accelerator_capabilities(self, value: Optional[pulumi.Input['FleetAcceleratorCapabilitiesArgs']]):
        pulumi.set(self, "accelerator_capabilities", value)

    @_builtins.property
    @pulumi.getter(name="allowedInstanceTypes")
    def allowed_instance_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "allowed_instance_types")

    @allowed_instance_types.setter
    def allowed_instance_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_instance_types", value)

    @_builtins.property
    @pulumi.getter(name="customAmounts")
    def custom_amounts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FleetAmountCapabilityArgs']]]]:
        return pulumi.get(self, "custom_amounts")

    @custom_amounts.setter
    def custom_amounts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FleetAmountCapabilityArgs']]]]):
        pulumi.set(self, "custom_amounts", value)

    @_builtins.property
    @pulumi.getter(name="customAttributes")
    def custom_attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FleetAttributeCapabilityArgs']]]]:
        return pulumi.get(self, "custom_attributes")

    @custom_attributes.setter
    def custom_attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FleetAttributeCapabilityArgs']]]]):
        pulumi.set(self, "custom_attributes", value)

    @_builtins.property
    @pulumi.getter(name="excludedInstanceTypes")
    def excluded_instance_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "excluded_instance_types")

    @excluded_instance_types.setter
    def excluded_instance_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "excluded_instance_types", value)

    @_builtins.property
    @pulumi.getter(name="rootEbsVolume")
    def root_ebs_volume(self) -> Optional[pulumi.Input['FleetEc2EbsVolumeArgs']]:
        return pulumi.get(self, "root_ebs_volume")

    @root_ebs_volume.setter
    def root_ebs_volume(self, value: Optional[pulumi.Input['FleetEc2EbsVolumeArgs']]):
        pulumi.set(self, "root_ebs_volume", value)


if not MYPY:
    class FleetServiceManagedEc2InstanceMarketOptionsArgsDict(TypedDict):
        type: pulumi.Input['FleetEc2MarketType']
elif False:
    FleetServiceManagedEc2InstanceMarketOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetServiceManagedEc2InstanceMarketOptionsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['FleetEc2MarketType']):
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['FleetEc2MarketType']:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['FleetEc2MarketType']):
        pulumi.set(self, "type", value)


if not MYPY:
    class FleetVCpuCountRangeArgsDict(TypedDict):
        min: pulumi.Input[_builtins.int]
        max: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    FleetVCpuCountRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetVCpuCountRangeArgs:
    def __init__(__self__, *,
                 min: pulumi.Input[_builtins.int],
                 max: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "min", min)
        if max is not None:
            pulumi.set(__self__, "max", max)

    @_builtins.property
    @pulumi.getter
    def min(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "min", value)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max", value)


if not MYPY:
    class FleetVpcConfigurationArgsDict(TypedDict):
        resource_configuration_arns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    FleetVpcConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetVpcConfigurationArgs:
    def __init__(__self__, *,
                 resource_configuration_arns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if resource_configuration_arns is not None:
            pulumi.set(__self__, "resource_configuration_arns", resource_configuration_arns)

    @_builtins.property
    @pulumi.getter(name="resourceConfigurationArns")
    def resource_configuration_arns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "resource_configuration_arns")

    @resource_configuration_arns.setter
    def resource_configuration_arns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "resource_configuration_arns", value)


if not MYPY:
    class QueueJobAttachmentSettingsArgsDict(TypedDict):
        root_prefix: pulumi.Input[_builtins.str]
        """
        The root prefix.
        """
        s3_bucket_name: pulumi.Input[_builtins.str]
        """
        The Amazon S3 bucket name.
        """
elif False:
    QueueJobAttachmentSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QueueJobAttachmentSettingsArgs:
    def __init__(__self__, *,
                 root_prefix: pulumi.Input[_builtins.str],
                 s3_bucket_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] root_prefix: The root prefix.
        :param pulumi.Input[_builtins.str] s3_bucket_name: The Amazon S3 bucket name.
        """
        pulumi.set(__self__, "root_prefix", root_prefix)
        pulumi.set(__self__, "s3_bucket_name", s3_bucket_name)

    @_builtins.property
    @pulumi.getter(name="rootPrefix")
    def root_prefix(self) -> pulumi.Input[_builtins.str]:
        """
        The root prefix.
        """
        return pulumi.get(self, "root_prefix")

    @root_prefix.setter
    def root_prefix(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "root_prefix", value)

    @_builtins.property
    @pulumi.getter(name="s3BucketName")
    def s3_bucket_name(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon S3 bucket name.
        """
        return pulumi.get(self, "s3_bucket_name")

    @s3_bucket_name.setter
    def s3_bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "s3_bucket_name", value)


if not MYPY:
    class QueueJobRunAsUserArgsDict(TypedDict):
        run_as: pulumi.Input['QueueRunAs']
        """
        Specifies whether the job should run using the queue's system user or if the job should run using the worker agent system user.
        """
        posix: NotRequired[pulumi.Input['QueuePosixUserArgsDict']]
        """
        The user and group that the jobs in the queue run as.
        """
        windows: NotRequired[pulumi.Input['QueueWindowsUserArgsDict']]
        """
        Identifies a Microsoft Windows user.
        """
elif False:
    QueueJobRunAsUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QueueJobRunAsUserArgs:
    def __init__(__self__, *,
                 run_as: pulumi.Input['QueueRunAs'],
                 posix: Optional[pulumi.Input['QueuePosixUserArgs']] = None,
                 windows: Optional[pulumi.Input['QueueWindowsUserArgs']] = None):
        """
        :param pulumi.Input['QueueRunAs'] run_as: Specifies whether the job should run using the queue's system user or if the job should run using the worker agent system user.
        :param pulumi.Input['QueuePosixUserArgs'] posix: The user and group that the jobs in the queue run as.
        :param pulumi.Input['QueueWindowsUserArgs'] windows: Identifies a Microsoft Windows user.
        """
        pulumi.set(__self__, "run_as", run_as)
        if posix is not None:
            pulumi.set(__self__, "posix", posix)
        if windows is not None:
            pulumi.set(__self__, "windows", windows)

    @_builtins.property
    @pulumi.getter(name="runAs")
    def run_as(self) -> pulumi.Input['QueueRunAs']:
        """
        Specifies whether the job should run using the queue's system user or if the job should run using the worker agent system user.
        """
        return pulumi.get(self, "run_as")

    @run_as.setter
    def run_as(self, value: pulumi.Input['QueueRunAs']):
        pulumi.set(self, "run_as", value)

    @_builtins.property
    @pulumi.getter
    def posix(self) -> Optional[pulumi.Input['QueuePosixUserArgs']]:
        """
        The user and group that the jobs in the queue run as.
        """
        return pulumi.get(self, "posix")

    @posix.setter
    def posix(self, value: Optional[pulumi.Input['QueuePosixUserArgs']]):
        pulumi.set(self, "posix", value)

    @_builtins.property
    @pulumi.getter
    def windows(self) -> Optional[pulumi.Input['QueueWindowsUserArgs']]:
        """
        Identifies a Microsoft Windows user.
        """
        return pulumi.get(self, "windows")

    @windows.setter
    def windows(self, value: Optional[pulumi.Input['QueueWindowsUserArgs']]):
        pulumi.set(self, "windows", value)


if not MYPY:
    class QueuePosixUserArgsDict(TypedDict):
        group: pulumi.Input[_builtins.str]
        """
        The name of the POSIX user's group.
        """
        user: pulumi.Input[_builtins.str]
        """
        The name of the POSIX user.
        """
elif False:
    QueuePosixUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QueuePosixUserArgs:
    def __init__(__self__, *,
                 group: pulumi.Input[_builtins.str],
                 user: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] group: The name of the POSIX user's group.
        :param pulumi.Input[_builtins.str] user: The name of the POSIX user.
        """
        pulumi.set(__self__, "group", group)
        pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def group(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the POSIX user's group.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "group", value)

    @_builtins.property
    @pulumi.getter
    def user(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the POSIX user.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "user", value)


if not MYPY:
    class QueueWindowsUserArgsDict(TypedDict):
        password_arn: pulumi.Input[_builtins.str]
        """
        The password ARN for the Windows user.
        """
        user: pulumi.Input[_builtins.str]
        """
        The user.
        """
elif False:
    QueueWindowsUserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class QueueWindowsUserArgs:
    def __init__(__self__, *,
                 password_arn: pulumi.Input[_builtins.str],
                 user: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] password_arn: The password ARN for the Windows user.
        :param pulumi.Input[_builtins.str] user: The user.
        """
        pulumi.set(__self__, "password_arn", password_arn)
        pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter(name="passwordArn")
    def password_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The password ARN for the Windows user.
        """
        return pulumi.get(self, "password_arn")

    @password_arn.setter
    def password_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "password_arn", value)

    @_builtins.property
    @pulumi.getter
    def user(self) -> pulumi.Input[_builtins.str]:
        """
        The user.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "user", value)


if not MYPY:
    class StorageProfileFileSystemLocationArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The location name.
        """
        path: pulumi.Input[_builtins.str]
        """
        The file path.
        """
        type: pulumi.Input['StorageProfileFileSystemLocationType']
        """
        The type of file.
        """
elif False:
    StorageProfileFileSystemLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StorageProfileFileSystemLocationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 path: pulumi.Input[_builtins.str],
                 type: pulumi.Input['StorageProfileFileSystemLocationType']):
        """
        :param pulumi.Input[_builtins.str] name: The location name.
        :param pulumi.Input[_builtins.str] path: The file path.
        :param pulumi.Input['StorageProfileFileSystemLocationType'] type: The type of file.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The location name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> pulumi.Input[_builtins.str]:
        """
        The file path.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['StorageProfileFileSystemLocationType']:
        """
        The type of file.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['StorageProfileFileSystemLocationType']):
        pulumi.set(self, "type", value)


