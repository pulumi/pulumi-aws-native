# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AnomalyDetectorConfiguration',
    'AnomalyDetectorIgnoreNearExpected',
    'AnomalyDetectorLabel',
    'AnomalyDetectorMissingDataAction',
    'AnomalyDetectorRandomCutForestConfiguration',
    'ScraperCloudWatchLogDestination',
    'ScraperComponent',
    'ScraperComponentConfig',
    'ScraperDestination',
    'ScraperDestinationAmpConfigurationProperties',
    'ScraperLoggingConfiguration',
    'ScraperLoggingDestination',
    'ScraperRoleConfiguration',
    'ScraperScrapeConfiguration',
    'ScraperSource',
    'ScraperSourceEksConfigurationProperties',
    'WorkspaceCloudWatchLogDestination',
    'WorkspaceConfiguration',
    'WorkspaceLabel',
    'WorkspaceLimitsPerLabelSet',
    'WorkspaceLimitsPerLabelSetEntry',
    'WorkspaceLoggingConfiguration',
    'WorkspaceLoggingDestination',
    'WorkspaceLoggingFilter',
    'WorkspaceQueryLoggingConfiguration',
]

@pulumi.output_type
class AnomalyDetectorConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "randomCutForest":
            suggest = "random_cut_forest"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnomalyDetectorConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnomalyDetectorConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnomalyDetectorConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 random_cut_forest: 'outputs.AnomalyDetectorRandomCutForestConfiguration'):
        """
        :param 'AnomalyDetectorRandomCutForestConfiguration' random_cut_forest: The Random Cut Forest algorithm configuration for anomaly detection.
        """
        pulumi.set(__self__, "random_cut_forest", random_cut_forest)

    @_builtins.property
    @pulumi.getter(name="randomCutForest")
    def random_cut_forest(self) -> 'outputs.AnomalyDetectorRandomCutForestConfiguration':
        """
        The Random Cut Forest algorithm configuration for anomaly detection.
        """
        return pulumi.get(self, "random_cut_forest")


@pulumi.output_type
class AnomalyDetectorIgnoreNearExpected(dict):
    def __init__(__self__, *,
                 amount: Optional[_builtins.float] = None,
                 ratio: Optional[_builtins.float] = None):
        if amount is not None:
            pulumi.set(__self__, "amount", amount)
        if ratio is not None:
            pulumi.set(__self__, "ratio", ratio)

    @_builtins.property
    @pulumi.getter
    def amount(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "amount")

    @_builtins.property
    @pulumi.getter
    def ratio(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "ratio")


@pulumi.output_type
class AnomalyDetectorLabel(dict):
    """
    A key-value pair to provide meta-data and multi-dimensional data analysis for filtering and aggregation.
    """
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        A key-value pair to provide meta-data and multi-dimensional data analysis for filtering and aggregation.
        :param _builtins.str key: The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        :param _builtins.str value: The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AnomalyDetectorMissingDataAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "markAsAnomaly":
            suggest = "mark_as_anomaly"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnomalyDetectorMissingDataAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnomalyDetectorMissingDataAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnomalyDetectorMissingDataAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mark_as_anomaly: Optional[_builtins.bool] = None,
                 skip: Optional[_builtins.bool] = None):
        if mark_as_anomaly is not None:
            pulumi.set(__self__, "mark_as_anomaly", mark_as_anomaly)
        if skip is not None:
            pulumi.set(__self__, "skip", skip)

    @_builtins.property
    @pulumi.getter(name="markAsAnomaly")
    def mark_as_anomaly(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "mark_as_anomaly")

    @_builtins.property
    @pulumi.getter
    def skip(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "skip")


@pulumi.output_type
class AnomalyDetectorRandomCutForestConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ignoreNearExpectedFromAbove":
            suggest = "ignore_near_expected_from_above"
        elif key == "ignoreNearExpectedFromBelow":
            suggest = "ignore_near_expected_from_below"
        elif key == "sampleSize":
            suggest = "sample_size"
        elif key == "shingleSize":
            suggest = "shingle_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnomalyDetectorRandomCutForestConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnomalyDetectorRandomCutForestConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnomalyDetectorRandomCutForestConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query: _builtins.str,
                 ignore_near_expected_from_above: Optional['outputs.AnomalyDetectorIgnoreNearExpected'] = None,
                 ignore_near_expected_from_below: Optional['outputs.AnomalyDetectorIgnoreNearExpected'] = None,
                 sample_size: Optional[_builtins.int] = None,
                 shingle_size: Optional[_builtins.int] = None):
        """
        :param _builtins.str query: The Prometheus query used to retrieve the time-series data for anomaly detection.
               
               > Random Cut Forest queries must be wrapped by a supported PromQL aggregation operator. For more information, see [Aggregation operators](https://docs.aws.amazon.com/https://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators) on the *Prometheus docs* website.
               > 
               > *Supported PromQL aggregation operators* : `avg` , `count` , `group` , `max` , `min` , `quantile` , `stddev` , `stdvar` , and `sum` .
        :param 'AnomalyDetectorIgnoreNearExpected' ignore_near_expected_from_above: Configuration for ignoring values that are near expected values from above during anomaly detection.
        :param 'AnomalyDetectorIgnoreNearExpected' ignore_near_expected_from_below: Configuration for ignoring values that are near expected values from below during anomaly detection.
        :param _builtins.int sample_size: The number of data points sampled from the input stream for the Random Cut Forest algorithm. The default number is 256 consecutive data points.
        :param _builtins.int shingle_size: The number of consecutive data points used to create a shingle for the Random Cut Forest algorithm. The default number is 8 consecutive data points.
        """
        pulumi.set(__self__, "query", query)
        if ignore_near_expected_from_above is not None:
            pulumi.set(__self__, "ignore_near_expected_from_above", ignore_near_expected_from_above)
        if ignore_near_expected_from_below is not None:
            pulumi.set(__self__, "ignore_near_expected_from_below", ignore_near_expected_from_below)
        if sample_size is not None:
            pulumi.set(__self__, "sample_size", sample_size)
        if shingle_size is not None:
            pulumi.set(__self__, "shingle_size", shingle_size)

    @_builtins.property
    @pulumi.getter
    def query(self) -> _builtins.str:
        """
        The Prometheus query used to retrieve the time-series data for anomaly detection.

        > Random Cut Forest queries must be wrapped by a supported PromQL aggregation operator. For more information, see [Aggregation operators](https://docs.aws.amazon.com/https://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators) on the *Prometheus docs* website.
        > 
        > *Supported PromQL aggregation operators* : `avg` , `count` , `group` , `max` , `min` , `quantile` , `stddev` , `stdvar` , and `sum` .
        """
        return pulumi.get(self, "query")

    @_builtins.property
    @pulumi.getter(name="ignoreNearExpectedFromAbove")
    def ignore_near_expected_from_above(self) -> Optional['outputs.AnomalyDetectorIgnoreNearExpected']:
        """
        Configuration for ignoring values that are near expected values from above during anomaly detection.
        """
        return pulumi.get(self, "ignore_near_expected_from_above")

    @_builtins.property
    @pulumi.getter(name="ignoreNearExpectedFromBelow")
    def ignore_near_expected_from_below(self) -> Optional['outputs.AnomalyDetectorIgnoreNearExpected']:
        """
        Configuration for ignoring values that are near expected values from below during anomaly detection.
        """
        return pulumi.get(self, "ignore_near_expected_from_below")

    @_builtins.property
    @pulumi.getter(name="sampleSize")
    def sample_size(self) -> Optional[_builtins.int]:
        """
        The number of data points sampled from the input stream for the Random Cut Forest algorithm. The default number is 256 consecutive data points.
        """
        return pulumi.get(self, "sample_size")

    @_builtins.property
    @pulumi.getter(name="shingleSize")
    def shingle_size(self) -> Optional[_builtins.int]:
        """
        The number of consecutive data points used to create a shingle for the Random Cut Forest algorithm. The default number is 8 consecutive data points.
        """
        return pulumi.get(self, "shingle_size")


@pulumi.output_type
class ScraperCloudWatchLogDestination(dict):
    """
    Represents a cloudwatch logs destination for scraper logging
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logGroupArn":
            suggest = "log_group_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScraperCloudWatchLogDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScraperCloudWatchLogDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScraperCloudWatchLogDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_group_arn: Optional[_builtins.str] = None):
        """
        Represents a cloudwatch logs destination for scraper logging
        :param _builtins.str log_group_arn: ARN of the CloudWatch log group
        """
        if log_group_arn is not None:
            pulumi.set(__self__, "log_group_arn", log_group_arn)

    @_builtins.property
    @pulumi.getter(name="logGroupArn")
    def log_group_arn(self) -> Optional[_builtins.str]:
        """
        ARN of the CloudWatch log group
        """
        return pulumi.get(self, "log_group_arn")


@pulumi.output_type
class ScraperComponent(dict):
    def __init__(__self__, *,
                 type: 'ScraperComponentType',
                 config: Optional['outputs.ScraperComponentConfig'] = None):
        """
        :param 'ScraperComponentType' type: The type of the scraper component.
        :param 'ScraperComponentConfig' config: The configuration settings for the scraper component.
        """
        pulumi.set(__self__, "type", type)
        if config is not None:
            pulumi.set(__self__, "config", config)

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'ScraperComponentType':
        """
        The type of the scraper component.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def config(self) -> Optional['outputs.ScraperComponentConfig']:
        """
        The configuration settings for the scraper component.
        """
        return pulumi.get(self, "config")


@pulumi.output_type
class ScraperComponentConfig(dict):
    def __init__(__self__, *,
                 options: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param Mapping[str, _builtins.str] options: Configuration options for the scraper component.
        """
        if options is not None:
            pulumi.set(__self__, "options", options)

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Configuration options for the scraper component.
        """
        return pulumi.get(self, "options")


@pulumi.output_type
class ScraperDestination(dict):
    """
    Scraper metrics destination
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ampConfiguration":
            suggest = "amp_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScraperDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScraperDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScraperDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 amp_configuration: Optional['outputs.ScraperDestinationAmpConfigurationProperties'] = None):
        """
        Scraper metrics destination
        :param 'ScraperDestinationAmpConfigurationProperties' amp_configuration: Configuration for Amazon Managed Prometheus metrics destination
        """
        if amp_configuration is not None:
            pulumi.set(__self__, "amp_configuration", amp_configuration)

    @_builtins.property
    @pulumi.getter(name="ampConfiguration")
    def amp_configuration(self) -> Optional['outputs.ScraperDestinationAmpConfigurationProperties']:
        """
        Configuration for Amazon Managed Prometheus metrics destination
        """
        return pulumi.get(self, "amp_configuration")


@pulumi.output_type
class ScraperDestinationAmpConfigurationProperties(dict):
    """
    Configuration for Amazon Managed Prometheus metrics destination
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workspaceArn":
            suggest = "workspace_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScraperDestinationAmpConfigurationProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScraperDestinationAmpConfigurationProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScraperDestinationAmpConfigurationProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 workspace_arn: _builtins.str):
        """
        Configuration for Amazon Managed Prometheus metrics destination
        :param _builtins.str workspace_arn: ARN of an Amazon Managed Prometheus workspace
        """
        pulumi.set(__self__, "workspace_arn", workspace_arn)

    @_builtins.property
    @pulumi.getter(name="workspaceArn")
    def workspace_arn(self) -> _builtins.str:
        """
        ARN of an Amazon Managed Prometheus workspace
        """
        return pulumi.get(self, "workspace_arn")


@pulumi.output_type
class ScraperLoggingConfiguration(dict):
    """
    Configuration for scraper logging
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loggingDestination":
            suggest = "logging_destination"
        elif key == "scraperComponents":
            suggest = "scraper_components"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScraperLoggingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScraperLoggingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScraperLoggingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 logging_destination: 'outputs.ScraperLoggingDestination',
                 scraper_components: Sequence['outputs.ScraperComponent']):
        """
        Configuration for scraper logging
        """
        pulumi.set(__self__, "logging_destination", logging_destination)
        pulumi.set(__self__, "scraper_components", scraper_components)

    @_builtins.property
    @pulumi.getter(name="loggingDestination")
    def logging_destination(self) -> 'outputs.ScraperLoggingDestination':
        return pulumi.get(self, "logging_destination")

    @_builtins.property
    @pulumi.getter(name="scraperComponents")
    def scraper_components(self) -> Sequence['outputs.ScraperComponent']:
        return pulumi.get(self, "scraper_components")


@pulumi.output_type
class ScraperLoggingDestination(dict):
    """
    Destination for scraper logging
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudWatchLogs":
            suggest = "cloud_watch_logs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScraperLoggingDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScraperLoggingDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScraperLoggingDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_watch_logs: Optional['outputs.ScraperCloudWatchLogDestination'] = None):
        """
        Destination for scraper logging
        :param 'ScraperCloudWatchLogDestination' cloud_watch_logs: The CloudWatch Logs configuration for the scraper logging destination.
        """
        if cloud_watch_logs is not None:
            pulumi.set(__self__, "cloud_watch_logs", cloud_watch_logs)

    @_builtins.property
    @pulumi.getter(name="cloudWatchLogs")
    def cloud_watch_logs(self) -> Optional['outputs.ScraperCloudWatchLogDestination']:
        """
        The CloudWatch Logs configuration for the scraper logging destination.
        """
        return pulumi.get(self, "cloud_watch_logs")


@pulumi.output_type
class ScraperRoleConfiguration(dict):
    """
    Role configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceRoleArn":
            suggest = "source_role_arn"
        elif key == "targetRoleArn":
            suggest = "target_role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScraperRoleConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScraperRoleConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScraperRoleConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_role_arn: Optional[_builtins.str] = None,
                 target_role_arn: Optional[_builtins.str] = None):
        """
        Role configuration
        :param _builtins.str source_role_arn: IAM Role in source account
        :param _builtins.str target_role_arn: IAM Role in the target account
        """
        if source_role_arn is not None:
            pulumi.set(__self__, "source_role_arn", source_role_arn)
        if target_role_arn is not None:
            pulumi.set(__self__, "target_role_arn", target_role_arn)

    @_builtins.property
    @pulumi.getter(name="sourceRoleArn")
    def source_role_arn(self) -> Optional[_builtins.str]:
        """
        IAM Role in source account
        """
        return pulumi.get(self, "source_role_arn")

    @_builtins.property
    @pulumi.getter(name="targetRoleArn")
    def target_role_arn(self) -> Optional[_builtins.str]:
        """
        IAM Role in the target account
        """
        return pulumi.get(self, "target_role_arn")


@pulumi.output_type
class ScraperScrapeConfiguration(dict):
    """
    Scraper configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "configurationBlob":
            suggest = "configuration_blob"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScraperScrapeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScraperScrapeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScraperScrapeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 configuration_blob: Optional[_builtins.str] = None):
        """
        Scraper configuration
        :param _builtins.str configuration_blob: Prometheus compatible scrape configuration in base64 encoded blob format
        """
        if configuration_blob is not None:
            pulumi.set(__self__, "configuration_blob", configuration_blob)

    @_builtins.property
    @pulumi.getter(name="configurationBlob")
    def configuration_blob(self) -> Optional[_builtins.str]:
        """
        Prometheus compatible scrape configuration in base64 encoded blob format
        """
        return pulumi.get(self, "configuration_blob")


@pulumi.output_type
class ScraperSource(dict):
    """
    Scraper metrics source
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eksConfiguration":
            suggest = "eks_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScraperSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScraperSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScraperSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 eks_configuration: Optional['outputs.ScraperSourceEksConfigurationProperties'] = None):
        """
        Scraper metrics source
        :param 'ScraperSourceEksConfigurationProperties' eks_configuration: Configuration for EKS metrics source
        """
        if eks_configuration is not None:
            pulumi.set(__self__, "eks_configuration", eks_configuration)

    @_builtins.property
    @pulumi.getter(name="eksConfiguration")
    def eks_configuration(self) -> Optional['outputs.ScraperSourceEksConfigurationProperties']:
        """
        Configuration for EKS metrics source
        """
        return pulumi.get(self, "eks_configuration")


@pulumi.output_type
class ScraperSourceEksConfigurationProperties(dict):
    """
    Configuration for EKS metrics source
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterArn":
            suggest = "cluster_arn"
        elif key == "subnetIds":
            suggest = "subnet_ids"
        elif key == "securityGroupIds":
            suggest = "security_group_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScraperSourceEksConfigurationProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScraperSourceEksConfigurationProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScraperSourceEksConfigurationProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_arn: _builtins.str,
                 subnet_ids: Sequence[_builtins.str],
                 security_group_ids: Optional[Sequence[_builtins.str]] = None):
        """
        Configuration for EKS metrics source
        :param _builtins.str cluster_arn: ARN of an EKS cluster
        :param Sequence[_builtins.str] subnet_ids: List of subnet IDs
        :param Sequence[_builtins.str] security_group_ids: List of security group IDs
        """
        pulumi.set(__self__, "cluster_arn", cluster_arn)
        pulumi.set(__self__, "subnet_ids", subnet_ids)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)

    @_builtins.property
    @pulumi.getter(name="clusterArn")
    def cluster_arn(self) -> _builtins.str:
        """
        ARN of an EKS cluster
        """
        return pulumi.get(self, "cluster_arn")

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Sequence[_builtins.str]:
        """
        List of subnet IDs
        """
        return pulumi.get(self, "subnet_ids")

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of security group IDs
        """
        return pulumi.get(self, "security_group_ids")


@pulumi.output_type
class WorkspaceCloudWatchLogDestination(dict):
    """
    Represents a cloudwatch logs destination for query logging
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logGroupArn":
            suggest = "log_group_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceCloudWatchLogDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceCloudWatchLogDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceCloudWatchLogDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_group_arn: _builtins.str):
        """
        Represents a cloudwatch logs destination for query logging
        :param _builtins.str log_group_arn: The ARN of the CloudWatch Logs log group
        """
        pulumi.set(__self__, "log_group_arn", log_group_arn)

    @_builtins.property
    @pulumi.getter(name="logGroupArn")
    def log_group_arn(self) -> _builtins.str:
        """
        The ARN of the CloudWatch Logs log group
        """
        return pulumi.get(self, "log_group_arn")


@pulumi.output_type
class WorkspaceConfiguration(dict):
    """
    Workspace configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "limitsPerLabelSets":
            suggest = "limits_per_label_sets"
        elif key == "retentionPeriodInDays":
            suggest = "retention_period_in_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 limits_per_label_sets: Optional[Sequence['outputs.WorkspaceLimitsPerLabelSet']] = None,
                 retention_period_in_days: Optional[_builtins.int] = None):
        """
        Workspace configuration
        :param Sequence['WorkspaceLimitsPerLabelSet'] limits_per_label_sets: An array of label set and associated limits
        :param _builtins.int retention_period_in_days: How many days that metrics are retained in the workspace
        """
        if limits_per_label_sets is not None:
            pulumi.set(__self__, "limits_per_label_sets", limits_per_label_sets)
        if retention_period_in_days is not None:
            pulumi.set(__self__, "retention_period_in_days", retention_period_in_days)

    @_builtins.property
    @pulumi.getter(name="limitsPerLabelSets")
    def limits_per_label_sets(self) -> Optional[Sequence['outputs.WorkspaceLimitsPerLabelSet']]:
        """
        An array of label set and associated limits
        """
        return pulumi.get(self, "limits_per_label_sets")

    @_builtins.property
    @pulumi.getter(name="retentionPeriodInDays")
    def retention_period_in_days(self) -> Optional[_builtins.int]:
        """
        How many days that metrics are retained in the workspace
        """
        return pulumi.get(self, "retention_period_in_days")


@pulumi.output_type
class WorkspaceLabel(dict):
    """
    Series label
    """
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        Series label
        :param _builtins.str name: Name of the label
        :param _builtins.str value: Value of the label
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the label
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value of the label
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class WorkspaceLimitsPerLabelSet(dict):
    """
    Label set and its associated limits
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "labelSet":
            suggest = "label_set"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceLimitsPerLabelSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceLimitsPerLabelSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceLimitsPerLabelSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 label_set: Sequence['outputs.WorkspaceLabel'],
                 limits: 'outputs.WorkspaceLimitsPerLabelSetEntry'):
        """
        Label set and its associated limits
        :param Sequence['WorkspaceLabel'] label_set: An array of series labels
        :param 'WorkspaceLimitsPerLabelSetEntry' limits: This structure contains the information about the limits that apply to time series that match this label set.
        """
        pulumi.set(__self__, "label_set", label_set)
        pulumi.set(__self__, "limits", limits)

    @_builtins.property
    @pulumi.getter(name="labelSet")
    def label_set(self) -> Sequence['outputs.WorkspaceLabel']:
        """
        An array of series labels
        """
        return pulumi.get(self, "label_set")

    @_builtins.property
    @pulumi.getter
    def limits(self) -> 'outputs.WorkspaceLimitsPerLabelSetEntry':
        """
        This structure contains the information about the limits that apply to time series that match this label set.
        """
        return pulumi.get(self, "limits")


@pulumi.output_type
class WorkspaceLimitsPerLabelSetEntry(dict):
    """
    Limits that can be applied to a label set
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSeries":
            suggest = "max_series"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceLimitsPerLabelSetEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceLimitsPerLabelSetEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceLimitsPerLabelSetEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_series: Optional[_builtins.int] = None):
        """
        Limits that can be applied to a label set
        :param _builtins.int max_series: The maximum number of active series that can be ingested for this label set
        """
        if max_series is not None:
            pulumi.set(__self__, "max_series", max_series)

    @_builtins.property
    @pulumi.getter(name="maxSeries")
    def max_series(self) -> Optional[_builtins.int]:
        """
        The maximum number of active series that can be ingested for this label set
        """
        return pulumi.get(self, "max_series")


@pulumi.output_type
class WorkspaceLoggingConfiguration(dict):
    """
    Logging configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logGroupArn":
            suggest = "log_group_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceLoggingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceLoggingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceLoggingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_group_arn: Optional[_builtins.str] = None):
        """
        Logging configuration
        :param _builtins.str log_group_arn: CloudWatch log group ARN
        """
        if log_group_arn is not None:
            pulumi.set(__self__, "log_group_arn", log_group_arn)

    @_builtins.property
    @pulumi.getter(name="logGroupArn")
    def log_group_arn(self) -> Optional[_builtins.str]:
        """
        CloudWatch log group ARN
        """
        return pulumi.get(self, "log_group_arn")


@pulumi.output_type
class WorkspaceLoggingDestination(dict):
    """
    Destinations for query logging
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudWatchLogs":
            suggest = "cloud_watch_logs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceLoggingDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceLoggingDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceLoggingDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_watch_logs: 'outputs.WorkspaceCloudWatchLogDestination',
                 filters: 'outputs.WorkspaceLoggingFilter'):
        """
        Destinations for query logging
        :param 'WorkspaceCloudWatchLogDestination' cloud_watch_logs: Configuration details for logging to CloudWatch Logs.
        :param 'WorkspaceLoggingFilter' filters: Filtering criteria that determine which queries are logged.
        """
        pulumi.set(__self__, "cloud_watch_logs", cloud_watch_logs)
        pulumi.set(__self__, "filters", filters)

    @_builtins.property
    @pulumi.getter(name="cloudWatchLogs")
    def cloud_watch_logs(self) -> 'outputs.WorkspaceCloudWatchLogDestination':
        """
        Configuration details for logging to CloudWatch Logs.
        """
        return pulumi.get(self, "cloud_watch_logs")

    @_builtins.property
    @pulumi.getter
    def filters(self) -> 'outputs.WorkspaceLoggingFilter':
        """
        Filtering criteria that determine which queries are logged.
        """
        return pulumi.get(self, "filters")


@pulumi.output_type
class WorkspaceLoggingFilter(dict):
    """
    Filters for logging
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "qspThreshold":
            suggest = "qsp_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceLoggingFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceLoggingFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceLoggingFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 qsp_threshold: _builtins.int):
        """
        Filters for logging
        :param _builtins.int qsp_threshold: Query logs with QSP above this limit are vended
        """
        pulumi.set(__self__, "qsp_threshold", qsp_threshold)

    @_builtins.property
    @pulumi.getter(name="qspThreshold")
    def qsp_threshold(self) -> _builtins.int:
        """
        Query logs with QSP above this limit are vended
        """
        return pulumi.get(self, "qsp_threshold")


@pulumi.output_type
class WorkspaceQueryLoggingConfiguration(dict):
    """
    Query logging configuration
    """
    def __init__(__self__, *,
                 destinations: Sequence['outputs.WorkspaceLoggingDestination']):
        """
        Query logging configuration
        :param Sequence['WorkspaceLoggingDestination'] destinations: The destinations configuration for query logging
        """
        pulumi.set(__self__, "destinations", destinations)

    @_builtins.property
    @pulumi.getter
    def destinations(self) -> Sequence['outputs.WorkspaceLoggingDestination']:
        """
        The destinations configuration for query logging
        """
        return pulumi.get(self, "destinations")


