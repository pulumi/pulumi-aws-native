# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'AnomalyDetectorConfigurationArgs',
    'AnomalyDetectorConfigurationArgsDict',
    'AnomalyDetectorIgnoreNearExpectedArgs',
    'AnomalyDetectorIgnoreNearExpectedArgsDict',
    'AnomalyDetectorLabelArgs',
    'AnomalyDetectorLabelArgsDict',
    'AnomalyDetectorMissingDataActionArgs',
    'AnomalyDetectorMissingDataActionArgsDict',
    'AnomalyDetectorRandomCutForestConfigurationArgs',
    'AnomalyDetectorRandomCutForestConfigurationArgsDict',
    'ScraperCloudWatchLogDestinationArgs',
    'ScraperCloudWatchLogDestinationArgsDict',
    'ScraperComponentConfigArgs',
    'ScraperComponentConfigArgsDict',
    'ScraperComponentArgs',
    'ScraperComponentArgsDict',
    'ScraperDestinationAmpConfigurationPropertiesArgs',
    'ScraperDestinationAmpConfigurationPropertiesArgsDict',
    'ScraperDestinationArgs',
    'ScraperDestinationArgsDict',
    'ScraperLoggingConfigurationArgs',
    'ScraperLoggingConfigurationArgsDict',
    'ScraperLoggingDestinationArgs',
    'ScraperLoggingDestinationArgsDict',
    'ScraperRoleConfigurationArgs',
    'ScraperRoleConfigurationArgsDict',
    'ScraperScrapeConfigurationArgs',
    'ScraperScrapeConfigurationArgsDict',
    'ScraperSourceEksConfigurationPropertiesArgs',
    'ScraperSourceEksConfigurationPropertiesArgsDict',
    'ScraperSourceArgs',
    'ScraperSourceArgsDict',
    'WorkspaceCloudWatchLogDestinationArgs',
    'WorkspaceCloudWatchLogDestinationArgsDict',
    'WorkspaceConfigurationArgs',
    'WorkspaceConfigurationArgsDict',
    'WorkspaceLabelArgs',
    'WorkspaceLabelArgsDict',
    'WorkspaceLimitsPerLabelSetEntryArgs',
    'WorkspaceLimitsPerLabelSetEntryArgsDict',
    'WorkspaceLimitsPerLabelSetArgs',
    'WorkspaceLimitsPerLabelSetArgsDict',
    'WorkspaceLoggingConfigurationArgs',
    'WorkspaceLoggingConfigurationArgsDict',
    'WorkspaceLoggingDestinationArgs',
    'WorkspaceLoggingDestinationArgsDict',
    'WorkspaceLoggingFilterArgs',
    'WorkspaceLoggingFilterArgsDict',
    'WorkspaceQueryLoggingConfigurationArgs',
    'WorkspaceQueryLoggingConfigurationArgsDict',
]

MYPY = False

if not MYPY:
    class AnomalyDetectorConfigurationArgsDict(TypedDict):
        random_cut_forest: pulumi.Input['AnomalyDetectorRandomCutForestConfigurationArgsDict']
        """
        The Random Cut Forest algorithm configuration for anomaly detection.
        """
elif False:
    AnomalyDetectorConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnomalyDetectorConfigurationArgs:
    def __init__(__self__, *,
                 random_cut_forest: pulumi.Input['AnomalyDetectorRandomCutForestConfigurationArgs']):
        """
        :param pulumi.Input['AnomalyDetectorRandomCutForestConfigurationArgs'] random_cut_forest: The Random Cut Forest algorithm configuration for anomaly detection.
        """
        pulumi.set(__self__, "random_cut_forest", random_cut_forest)

    @_builtins.property
    @pulumi.getter(name="randomCutForest")
    def random_cut_forest(self) -> pulumi.Input['AnomalyDetectorRandomCutForestConfigurationArgs']:
        """
        The Random Cut Forest algorithm configuration for anomaly detection.
        """
        return pulumi.get(self, "random_cut_forest")

    @random_cut_forest.setter
    def random_cut_forest(self, value: pulumi.Input['AnomalyDetectorRandomCutForestConfigurationArgs']):
        pulumi.set(self, "random_cut_forest", value)


if not MYPY:
    class AnomalyDetectorIgnoreNearExpectedArgsDict(TypedDict):
        amount: NotRequired[pulumi.Input[_builtins.float]]
        ratio: NotRequired[pulumi.Input[_builtins.float]]
elif False:
    AnomalyDetectorIgnoreNearExpectedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnomalyDetectorIgnoreNearExpectedArgs:
    def __init__(__self__, *,
                 amount: Optional[pulumi.Input[_builtins.float]] = None,
                 ratio: Optional[pulumi.Input[_builtins.float]] = None):
        if amount is not None:
            pulumi.set(__self__, "amount", amount)
        if ratio is not None:
            pulumi.set(__self__, "ratio", ratio)

    @_builtins.property
    @pulumi.getter
    def amount(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "amount")

    @amount.setter
    def amount(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "amount", value)

    @_builtins.property
    @pulumi.getter
    def ratio(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "ratio")

    @ratio.setter
    def ratio(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "ratio", value)


if not MYPY:
    class AnomalyDetectorLabelArgsDict(TypedDict):
        """
        A key-value pair to provide meta-data and multi-dimensional data analysis for filtering and aggregation.
        """
        key: pulumi.Input[_builtins.str]
        """
        The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        value: pulumi.Input[_builtins.str]
        """
        The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
elif False:
    AnomalyDetectorLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnomalyDetectorLabelArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        A key-value pair to provide meta-data and multi-dimensional data analysis for filtering and aggregation.
        :param pulumi.Input[_builtins.str] key: The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        :param pulumi.Input[_builtins.str] value: The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        The value for the tag. You can specify a value that is 0 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AnomalyDetectorMissingDataActionArgsDict(TypedDict):
        mark_as_anomaly: NotRequired[pulumi.Input[_builtins.bool]]
        skip: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    AnomalyDetectorMissingDataActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnomalyDetectorMissingDataActionArgs:
    def __init__(__self__, *,
                 mark_as_anomaly: Optional[pulumi.Input[_builtins.bool]] = None,
                 skip: Optional[pulumi.Input[_builtins.bool]] = None):
        if mark_as_anomaly is not None:
            pulumi.set(__self__, "mark_as_anomaly", mark_as_anomaly)
        if skip is not None:
            pulumi.set(__self__, "skip", skip)

    @_builtins.property
    @pulumi.getter(name="markAsAnomaly")
    def mark_as_anomaly(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "mark_as_anomaly")

    @mark_as_anomaly.setter
    def mark_as_anomaly(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "mark_as_anomaly", value)

    @_builtins.property
    @pulumi.getter
    def skip(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "skip")

    @skip.setter
    def skip(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "skip", value)


if not MYPY:
    class AnomalyDetectorRandomCutForestConfigurationArgsDict(TypedDict):
        query: pulumi.Input[_builtins.str]
        """
        The Prometheus query used to retrieve the time-series data for anomaly detection.

        > Random Cut Forest queries must be wrapped by a supported PromQL aggregation operator. For more information, see [Aggregation operators](https://docs.aws.amazon.com/https://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators) on the *Prometheus docs* website.
        > 
        > *Supported PromQL aggregation operators* : `avg` , `count` , `group` , `max` , `min` , `quantile` , `stddev` , `stdvar` , and `sum` .
        """
        ignore_near_expected_from_above: NotRequired[pulumi.Input['AnomalyDetectorIgnoreNearExpectedArgsDict']]
        """
        Configuration for ignoring values that are near expected values from above during anomaly detection.
        """
        ignore_near_expected_from_below: NotRequired[pulumi.Input['AnomalyDetectorIgnoreNearExpectedArgsDict']]
        """
        Configuration for ignoring values that are near expected values from below during anomaly detection.
        """
        sample_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of data points sampled from the input stream for the Random Cut Forest algorithm. The default number is 256 consecutive data points.
        """
        shingle_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of consecutive data points used to create a shingle for the Random Cut Forest algorithm. The default number is 8 consecutive data points.
        """
elif False:
    AnomalyDetectorRandomCutForestConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnomalyDetectorRandomCutForestConfigurationArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[_builtins.str],
                 ignore_near_expected_from_above: Optional[pulumi.Input['AnomalyDetectorIgnoreNearExpectedArgs']] = None,
                 ignore_near_expected_from_below: Optional[pulumi.Input['AnomalyDetectorIgnoreNearExpectedArgs']] = None,
                 sample_size: Optional[pulumi.Input[_builtins.int]] = None,
                 shingle_size: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] query: The Prometheus query used to retrieve the time-series data for anomaly detection.
               
               > Random Cut Forest queries must be wrapped by a supported PromQL aggregation operator. For more information, see [Aggregation operators](https://docs.aws.amazon.com/https://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators) on the *Prometheus docs* website.
               > 
               > *Supported PromQL aggregation operators* : `avg` , `count` , `group` , `max` , `min` , `quantile` , `stddev` , `stdvar` , and `sum` .
        :param pulumi.Input['AnomalyDetectorIgnoreNearExpectedArgs'] ignore_near_expected_from_above: Configuration for ignoring values that are near expected values from above during anomaly detection.
        :param pulumi.Input['AnomalyDetectorIgnoreNearExpectedArgs'] ignore_near_expected_from_below: Configuration for ignoring values that are near expected values from below during anomaly detection.
        :param pulumi.Input[_builtins.int] sample_size: The number of data points sampled from the input stream for the Random Cut Forest algorithm. The default number is 256 consecutive data points.
        :param pulumi.Input[_builtins.int] shingle_size: The number of consecutive data points used to create a shingle for the Random Cut Forest algorithm. The default number is 8 consecutive data points.
        """
        pulumi.set(__self__, "query", query)
        if ignore_near_expected_from_above is not None:
            pulumi.set(__self__, "ignore_near_expected_from_above", ignore_near_expected_from_above)
        if ignore_near_expected_from_below is not None:
            pulumi.set(__self__, "ignore_near_expected_from_below", ignore_near_expected_from_below)
        if sample_size is not None:
            pulumi.set(__self__, "sample_size", sample_size)
        if shingle_size is not None:
            pulumi.set(__self__, "shingle_size", shingle_size)

    @_builtins.property
    @pulumi.getter
    def query(self) -> pulumi.Input[_builtins.str]:
        """
        The Prometheus query used to retrieve the time-series data for anomaly detection.

        > Random Cut Forest queries must be wrapped by a supported PromQL aggregation operator. For more information, see [Aggregation operators](https://docs.aws.amazon.com/https://prometheus.io/docs/prometheus/latest/querying/operators/#aggregation-operators) on the *Prometheus docs* website.
        > 
        > *Supported PromQL aggregation operators* : `avg` , `count` , `group` , `max` , `min` , `quantile` , `stddev` , `stdvar` , and `sum` .
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "query", value)

    @_builtins.property
    @pulumi.getter(name="ignoreNearExpectedFromAbove")
    def ignore_near_expected_from_above(self) -> Optional[pulumi.Input['AnomalyDetectorIgnoreNearExpectedArgs']]:
        """
        Configuration for ignoring values that are near expected values from above during anomaly detection.
        """
        return pulumi.get(self, "ignore_near_expected_from_above")

    @ignore_near_expected_from_above.setter
    def ignore_near_expected_from_above(self, value: Optional[pulumi.Input['AnomalyDetectorIgnoreNearExpectedArgs']]):
        pulumi.set(self, "ignore_near_expected_from_above", value)

    @_builtins.property
    @pulumi.getter(name="ignoreNearExpectedFromBelow")
    def ignore_near_expected_from_below(self) -> Optional[pulumi.Input['AnomalyDetectorIgnoreNearExpectedArgs']]:
        """
        Configuration for ignoring values that are near expected values from below during anomaly detection.
        """
        return pulumi.get(self, "ignore_near_expected_from_below")

    @ignore_near_expected_from_below.setter
    def ignore_near_expected_from_below(self, value: Optional[pulumi.Input['AnomalyDetectorIgnoreNearExpectedArgs']]):
        pulumi.set(self, "ignore_near_expected_from_below", value)

    @_builtins.property
    @pulumi.getter(name="sampleSize")
    def sample_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of data points sampled from the input stream for the Random Cut Forest algorithm. The default number is 256 consecutive data points.
        """
        return pulumi.get(self, "sample_size")

    @sample_size.setter
    def sample_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "sample_size", value)

    @_builtins.property
    @pulumi.getter(name="shingleSize")
    def shingle_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of consecutive data points used to create a shingle for the Random Cut Forest algorithm. The default number is 8 consecutive data points.
        """
        return pulumi.get(self, "shingle_size")

    @shingle_size.setter
    def shingle_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "shingle_size", value)


if not MYPY:
    class ScraperCloudWatchLogDestinationArgsDict(TypedDict):
        """
        Represents a cloudwatch logs destination for scraper logging
        """
        log_group_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        ARN of the CloudWatch log group
        """
elif False:
    ScraperCloudWatchLogDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScraperCloudWatchLogDestinationArgs:
    def __init__(__self__, *,
                 log_group_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Represents a cloudwatch logs destination for scraper logging
        :param pulumi.Input[_builtins.str] log_group_arn: ARN of the CloudWatch log group
        """
        if log_group_arn is not None:
            pulumi.set(__self__, "log_group_arn", log_group_arn)

    @_builtins.property
    @pulumi.getter(name="logGroupArn")
    def log_group_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ARN of the CloudWatch log group
        """
        return pulumi.get(self, "log_group_arn")

    @log_group_arn.setter
    def log_group_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_group_arn", value)


if not MYPY:
    class ScraperComponentConfigArgsDict(TypedDict):
        options: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Configuration options for the scraper component.
        """
elif False:
    ScraperComponentConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScraperComponentConfigArgs:
    def __init__(__self__, *,
                 options: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] options: Configuration options for the scraper component.
        """
        if options is not None:
            pulumi.set(__self__, "options", options)

    @_builtins.property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Configuration options for the scraper component.
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "options", value)


if not MYPY:
    class ScraperComponentArgsDict(TypedDict):
        type: pulumi.Input['ScraperComponentType']
        """
        The type of the scraper component.
        """
        config: NotRequired[pulumi.Input['ScraperComponentConfigArgsDict']]
        """
        The configuration settings for the scraper component.
        """
elif False:
    ScraperComponentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScraperComponentArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['ScraperComponentType'],
                 config: Optional[pulumi.Input['ScraperComponentConfigArgs']] = None):
        """
        :param pulumi.Input['ScraperComponentType'] type: The type of the scraper component.
        :param pulumi.Input['ScraperComponentConfigArgs'] config: The configuration settings for the scraper component.
        """
        pulumi.set(__self__, "type", type)
        if config is not None:
            pulumi.set(__self__, "config", config)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['ScraperComponentType']:
        """
        The type of the scraper component.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['ScraperComponentType']):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input['ScraperComponentConfigArgs']]:
        """
        The configuration settings for the scraper component.
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input['ScraperComponentConfigArgs']]):
        pulumi.set(self, "config", value)


if not MYPY:
    class ScraperDestinationAmpConfigurationPropertiesArgsDict(TypedDict):
        """
        Configuration for Amazon Managed Prometheus metrics destination
        """
        workspace_arn: pulumi.Input[_builtins.str]
        """
        ARN of an Amazon Managed Prometheus workspace
        """
elif False:
    ScraperDestinationAmpConfigurationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScraperDestinationAmpConfigurationPropertiesArgs:
    def __init__(__self__, *,
                 workspace_arn: pulumi.Input[_builtins.str]):
        """
        Configuration for Amazon Managed Prometheus metrics destination
        :param pulumi.Input[_builtins.str] workspace_arn: ARN of an Amazon Managed Prometheus workspace
        """
        pulumi.set(__self__, "workspace_arn", workspace_arn)

    @_builtins.property
    @pulumi.getter(name="workspaceArn")
    def workspace_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of an Amazon Managed Prometheus workspace
        """
        return pulumi.get(self, "workspace_arn")

    @workspace_arn.setter
    def workspace_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "workspace_arn", value)


if not MYPY:
    class ScraperDestinationArgsDict(TypedDict):
        """
        Scraper metrics destination
        """
        amp_configuration: NotRequired[pulumi.Input['ScraperDestinationAmpConfigurationPropertiesArgsDict']]
        """
        Configuration for Amazon Managed Prometheus metrics destination
        """
elif False:
    ScraperDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScraperDestinationArgs:
    def __init__(__self__, *,
                 amp_configuration: Optional[pulumi.Input['ScraperDestinationAmpConfigurationPropertiesArgs']] = None):
        """
        Scraper metrics destination
        :param pulumi.Input['ScraperDestinationAmpConfigurationPropertiesArgs'] amp_configuration: Configuration for Amazon Managed Prometheus metrics destination
        """
        if amp_configuration is not None:
            pulumi.set(__self__, "amp_configuration", amp_configuration)

    @_builtins.property
    @pulumi.getter(name="ampConfiguration")
    def amp_configuration(self) -> Optional[pulumi.Input['ScraperDestinationAmpConfigurationPropertiesArgs']]:
        """
        Configuration for Amazon Managed Prometheus metrics destination
        """
        return pulumi.get(self, "amp_configuration")

    @amp_configuration.setter
    def amp_configuration(self, value: Optional[pulumi.Input['ScraperDestinationAmpConfigurationPropertiesArgs']]):
        pulumi.set(self, "amp_configuration", value)


if not MYPY:
    class ScraperLoggingConfigurationArgsDict(TypedDict):
        """
        Configuration for scraper logging
        """
        logging_destination: pulumi.Input['ScraperLoggingDestinationArgsDict']
        scraper_components: pulumi.Input[Sequence[pulumi.Input['ScraperComponentArgsDict']]]
elif False:
    ScraperLoggingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScraperLoggingConfigurationArgs:
    def __init__(__self__, *,
                 logging_destination: pulumi.Input['ScraperLoggingDestinationArgs'],
                 scraper_components: pulumi.Input[Sequence[pulumi.Input['ScraperComponentArgs']]]):
        """
        Configuration for scraper logging
        """
        pulumi.set(__self__, "logging_destination", logging_destination)
        pulumi.set(__self__, "scraper_components", scraper_components)

    @_builtins.property
    @pulumi.getter(name="loggingDestination")
    def logging_destination(self) -> pulumi.Input['ScraperLoggingDestinationArgs']:
        return pulumi.get(self, "logging_destination")

    @logging_destination.setter
    def logging_destination(self, value: pulumi.Input['ScraperLoggingDestinationArgs']):
        pulumi.set(self, "logging_destination", value)

    @_builtins.property
    @pulumi.getter(name="scraperComponents")
    def scraper_components(self) -> pulumi.Input[Sequence[pulumi.Input['ScraperComponentArgs']]]:
        return pulumi.get(self, "scraper_components")

    @scraper_components.setter
    def scraper_components(self, value: pulumi.Input[Sequence[pulumi.Input['ScraperComponentArgs']]]):
        pulumi.set(self, "scraper_components", value)


if not MYPY:
    class ScraperLoggingDestinationArgsDict(TypedDict):
        """
        Destination for scraper logging
        """
        cloud_watch_logs: NotRequired[pulumi.Input['ScraperCloudWatchLogDestinationArgsDict']]
        """
        The CloudWatch Logs configuration for the scraper logging destination.
        """
elif False:
    ScraperLoggingDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScraperLoggingDestinationArgs:
    def __init__(__self__, *,
                 cloud_watch_logs: Optional[pulumi.Input['ScraperCloudWatchLogDestinationArgs']] = None):
        """
        Destination for scraper logging
        :param pulumi.Input['ScraperCloudWatchLogDestinationArgs'] cloud_watch_logs: The CloudWatch Logs configuration for the scraper logging destination.
        """
        if cloud_watch_logs is not None:
            pulumi.set(__self__, "cloud_watch_logs", cloud_watch_logs)

    @_builtins.property
    @pulumi.getter(name="cloudWatchLogs")
    def cloud_watch_logs(self) -> Optional[pulumi.Input['ScraperCloudWatchLogDestinationArgs']]:
        """
        The CloudWatch Logs configuration for the scraper logging destination.
        """
        return pulumi.get(self, "cloud_watch_logs")

    @cloud_watch_logs.setter
    def cloud_watch_logs(self, value: Optional[pulumi.Input['ScraperCloudWatchLogDestinationArgs']]):
        pulumi.set(self, "cloud_watch_logs", value)


if not MYPY:
    class ScraperRoleConfigurationArgsDict(TypedDict):
        """
        Role configuration
        """
        source_role_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        IAM Role in source account
        """
        target_role_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        IAM Role in the target account
        """
elif False:
    ScraperRoleConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScraperRoleConfigurationArgs:
    def __init__(__self__, *,
                 source_role_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 target_role_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Role configuration
        :param pulumi.Input[_builtins.str] source_role_arn: IAM Role in source account
        :param pulumi.Input[_builtins.str] target_role_arn: IAM Role in the target account
        """
        if source_role_arn is not None:
            pulumi.set(__self__, "source_role_arn", source_role_arn)
        if target_role_arn is not None:
            pulumi.set(__self__, "target_role_arn", target_role_arn)

    @_builtins.property
    @pulumi.getter(name="sourceRoleArn")
    def source_role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IAM Role in source account
        """
        return pulumi.get(self, "source_role_arn")

    @source_role_arn.setter
    def source_role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_role_arn", value)

    @_builtins.property
    @pulumi.getter(name="targetRoleArn")
    def target_role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IAM Role in the target account
        """
        return pulumi.get(self, "target_role_arn")

    @target_role_arn.setter
    def target_role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_role_arn", value)


if not MYPY:
    class ScraperScrapeConfigurationArgsDict(TypedDict):
        """
        Scraper configuration
        """
        configuration_blob: NotRequired[pulumi.Input[_builtins.str]]
        """
        Prometheus compatible scrape configuration in base64 encoded blob format
        """
elif False:
    ScraperScrapeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScraperScrapeConfigurationArgs:
    def __init__(__self__, *,
                 configuration_blob: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Scraper configuration
        :param pulumi.Input[_builtins.str] configuration_blob: Prometheus compatible scrape configuration in base64 encoded blob format
        """
        if configuration_blob is not None:
            pulumi.set(__self__, "configuration_blob", configuration_blob)

    @_builtins.property
    @pulumi.getter(name="configurationBlob")
    def configuration_blob(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Prometheus compatible scrape configuration in base64 encoded blob format
        """
        return pulumi.get(self, "configuration_blob")

    @configuration_blob.setter
    def configuration_blob(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "configuration_blob", value)


if not MYPY:
    class ScraperSourceEksConfigurationPropertiesArgsDict(TypedDict):
        """
        Configuration for EKS metrics source
        """
        cluster_arn: pulumi.Input[_builtins.str]
        """
        ARN of an EKS cluster
        """
        subnet_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of subnet IDs
        """
        security_group_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of security group IDs
        """
elif False:
    ScraperSourceEksConfigurationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScraperSourceEksConfigurationPropertiesArgs:
    def __init__(__self__, *,
                 cluster_arn: pulumi.Input[_builtins.str],
                 subnet_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        Configuration for EKS metrics source
        :param pulumi.Input[_builtins.str] cluster_arn: ARN of an EKS cluster
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] subnet_ids: List of subnet IDs
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] security_group_ids: List of security group IDs
        """
        pulumi.set(__self__, "cluster_arn", cluster_arn)
        pulumi.set(__self__, "subnet_ids", subnet_ids)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)

    @_builtins.property
    @pulumi.getter(name="clusterArn")
    def cluster_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of an EKS cluster
        """
        return pulumi.get(self, "cluster_arn")

    @cluster_arn.setter
    def cluster_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cluster_arn", value)

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of subnet IDs
        """
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "subnet_ids", value)

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of security group IDs
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "security_group_ids", value)


if not MYPY:
    class ScraperSourceArgsDict(TypedDict):
        """
        Scraper metrics source
        """
        eks_configuration: NotRequired[pulumi.Input['ScraperSourceEksConfigurationPropertiesArgsDict']]
        """
        Configuration for EKS metrics source
        """
elif False:
    ScraperSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScraperSourceArgs:
    def __init__(__self__, *,
                 eks_configuration: Optional[pulumi.Input['ScraperSourceEksConfigurationPropertiesArgs']] = None):
        """
        Scraper metrics source
        :param pulumi.Input['ScraperSourceEksConfigurationPropertiesArgs'] eks_configuration: Configuration for EKS metrics source
        """
        if eks_configuration is not None:
            pulumi.set(__self__, "eks_configuration", eks_configuration)

    @_builtins.property
    @pulumi.getter(name="eksConfiguration")
    def eks_configuration(self) -> Optional[pulumi.Input['ScraperSourceEksConfigurationPropertiesArgs']]:
        """
        Configuration for EKS metrics source
        """
        return pulumi.get(self, "eks_configuration")

    @eks_configuration.setter
    def eks_configuration(self, value: Optional[pulumi.Input['ScraperSourceEksConfigurationPropertiesArgs']]):
        pulumi.set(self, "eks_configuration", value)


if not MYPY:
    class WorkspaceCloudWatchLogDestinationArgsDict(TypedDict):
        """
        Represents a cloudwatch logs destination for query logging
        """
        log_group_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the CloudWatch Logs log group
        """
elif False:
    WorkspaceCloudWatchLogDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkspaceCloudWatchLogDestinationArgs:
    def __init__(__self__, *,
                 log_group_arn: pulumi.Input[_builtins.str]):
        """
        Represents a cloudwatch logs destination for query logging
        :param pulumi.Input[_builtins.str] log_group_arn: The ARN of the CloudWatch Logs log group
        """
        pulumi.set(__self__, "log_group_arn", log_group_arn)

    @_builtins.property
    @pulumi.getter(name="logGroupArn")
    def log_group_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the CloudWatch Logs log group
        """
        return pulumi.get(self, "log_group_arn")

    @log_group_arn.setter
    def log_group_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_group_arn", value)


if not MYPY:
    class WorkspaceConfigurationArgsDict(TypedDict):
        """
        Workspace configuration
        """
        limits_per_label_sets: NotRequired[pulumi.Input[Sequence[pulumi.Input['WorkspaceLimitsPerLabelSetArgsDict']]]]
        """
        An array of label set and associated limits
        """
        retention_period_in_days: NotRequired[pulumi.Input[_builtins.int]]
        """
        How many days that metrics are retained in the workspace
        """
elif False:
    WorkspaceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkspaceConfigurationArgs:
    def __init__(__self__, *,
                 limits_per_label_sets: Optional[pulumi.Input[Sequence[pulumi.Input['WorkspaceLimitsPerLabelSetArgs']]]] = None,
                 retention_period_in_days: Optional[pulumi.Input[_builtins.int]] = None):
        """
        Workspace configuration
        :param pulumi.Input[Sequence[pulumi.Input['WorkspaceLimitsPerLabelSetArgs']]] limits_per_label_sets: An array of label set and associated limits
        :param pulumi.Input[_builtins.int] retention_period_in_days: How many days that metrics are retained in the workspace
        """
        if limits_per_label_sets is not None:
            pulumi.set(__self__, "limits_per_label_sets", limits_per_label_sets)
        if retention_period_in_days is not None:
            pulumi.set(__self__, "retention_period_in_days", retention_period_in_days)

    @_builtins.property
    @pulumi.getter(name="limitsPerLabelSets")
    def limits_per_label_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkspaceLimitsPerLabelSetArgs']]]]:
        """
        An array of label set and associated limits
        """
        return pulumi.get(self, "limits_per_label_sets")

    @limits_per_label_sets.setter
    def limits_per_label_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkspaceLimitsPerLabelSetArgs']]]]):
        pulumi.set(self, "limits_per_label_sets", value)

    @_builtins.property
    @pulumi.getter(name="retentionPeriodInDays")
    def retention_period_in_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        How many days that metrics are retained in the workspace
        """
        return pulumi.get(self, "retention_period_in_days")

    @retention_period_in_days.setter
    def retention_period_in_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "retention_period_in_days", value)


if not MYPY:
    class WorkspaceLabelArgsDict(TypedDict):
        """
        Series label
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of the label
        """
        value: pulumi.Input[_builtins.str]
        """
        Value of the label
        """
elif False:
    WorkspaceLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkspaceLabelArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        Series label
        :param pulumi.Input[_builtins.str] name: Name of the label
        :param pulumi.Input[_builtins.str] value: Value of the label
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the label
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        Value of the label
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WorkspaceLimitsPerLabelSetEntryArgsDict(TypedDict):
        """
        Limits that can be applied to a label set
        """
        max_series: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum number of active series that can be ingested for this label set
        """
elif False:
    WorkspaceLimitsPerLabelSetEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkspaceLimitsPerLabelSetEntryArgs:
    def __init__(__self__, *,
                 max_series: Optional[pulumi.Input[_builtins.int]] = None):
        """
        Limits that can be applied to a label set
        :param pulumi.Input[_builtins.int] max_series: The maximum number of active series that can be ingested for this label set
        """
        if max_series is not None:
            pulumi.set(__self__, "max_series", max_series)

    @_builtins.property
    @pulumi.getter(name="maxSeries")
    def max_series(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum number of active series that can be ingested for this label set
        """
        return pulumi.get(self, "max_series")

    @max_series.setter
    def max_series(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_series", value)


if not MYPY:
    class WorkspaceLimitsPerLabelSetArgsDict(TypedDict):
        """
        Label set and its associated limits
        """
        label_set: pulumi.Input[Sequence[pulumi.Input['WorkspaceLabelArgsDict']]]
        """
        An array of series labels
        """
        limits: pulumi.Input['WorkspaceLimitsPerLabelSetEntryArgsDict']
        """
        This structure contains the information about the limits that apply to time series that match this label set.
        """
elif False:
    WorkspaceLimitsPerLabelSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkspaceLimitsPerLabelSetArgs:
    def __init__(__self__, *,
                 label_set: pulumi.Input[Sequence[pulumi.Input['WorkspaceLabelArgs']]],
                 limits: pulumi.Input['WorkspaceLimitsPerLabelSetEntryArgs']):
        """
        Label set and its associated limits
        :param pulumi.Input[Sequence[pulumi.Input['WorkspaceLabelArgs']]] label_set: An array of series labels
        :param pulumi.Input['WorkspaceLimitsPerLabelSetEntryArgs'] limits: This structure contains the information about the limits that apply to time series that match this label set.
        """
        pulumi.set(__self__, "label_set", label_set)
        pulumi.set(__self__, "limits", limits)

    @_builtins.property
    @pulumi.getter(name="labelSet")
    def label_set(self) -> pulumi.Input[Sequence[pulumi.Input['WorkspaceLabelArgs']]]:
        """
        An array of series labels
        """
        return pulumi.get(self, "label_set")

    @label_set.setter
    def label_set(self, value: pulumi.Input[Sequence[pulumi.Input['WorkspaceLabelArgs']]]):
        pulumi.set(self, "label_set", value)

    @_builtins.property
    @pulumi.getter
    def limits(self) -> pulumi.Input['WorkspaceLimitsPerLabelSetEntryArgs']:
        """
        This structure contains the information about the limits that apply to time series that match this label set.
        """
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: pulumi.Input['WorkspaceLimitsPerLabelSetEntryArgs']):
        pulumi.set(self, "limits", value)


if not MYPY:
    class WorkspaceLoggingConfigurationArgsDict(TypedDict):
        """
        Logging configuration
        """
        log_group_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        CloudWatch log group ARN
        """
elif False:
    WorkspaceLoggingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkspaceLoggingConfigurationArgs:
    def __init__(__self__, *,
                 log_group_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Logging configuration
        :param pulumi.Input[_builtins.str] log_group_arn: CloudWatch log group ARN
        """
        if log_group_arn is not None:
            pulumi.set(__self__, "log_group_arn", log_group_arn)

    @_builtins.property
    @pulumi.getter(name="logGroupArn")
    def log_group_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        CloudWatch log group ARN
        """
        return pulumi.get(self, "log_group_arn")

    @log_group_arn.setter
    def log_group_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_group_arn", value)


if not MYPY:
    class WorkspaceLoggingDestinationArgsDict(TypedDict):
        """
        Destinations for query logging
        """
        cloud_watch_logs: pulumi.Input['WorkspaceCloudWatchLogDestinationArgsDict']
        """
        Configuration details for logging to CloudWatch Logs.
        """
        filters: pulumi.Input['WorkspaceLoggingFilterArgsDict']
        """
        Filtering criteria that determine which queries are logged.
        """
elif False:
    WorkspaceLoggingDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkspaceLoggingDestinationArgs:
    def __init__(__self__, *,
                 cloud_watch_logs: pulumi.Input['WorkspaceCloudWatchLogDestinationArgs'],
                 filters: pulumi.Input['WorkspaceLoggingFilterArgs']):
        """
        Destinations for query logging
        :param pulumi.Input['WorkspaceCloudWatchLogDestinationArgs'] cloud_watch_logs: Configuration details for logging to CloudWatch Logs.
        :param pulumi.Input['WorkspaceLoggingFilterArgs'] filters: Filtering criteria that determine which queries are logged.
        """
        pulumi.set(__self__, "cloud_watch_logs", cloud_watch_logs)
        pulumi.set(__self__, "filters", filters)

    @_builtins.property
    @pulumi.getter(name="cloudWatchLogs")
    def cloud_watch_logs(self) -> pulumi.Input['WorkspaceCloudWatchLogDestinationArgs']:
        """
        Configuration details for logging to CloudWatch Logs.
        """
        return pulumi.get(self, "cloud_watch_logs")

    @cloud_watch_logs.setter
    def cloud_watch_logs(self, value: pulumi.Input['WorkspaceCloudWatchLogDestinationArgs']):
        pulumi.set(self, "cloud_watch_logs", value)

    @_builtins.property
    @pulumi.getter
    def filters(self) -> pulumi.Input['WorkspaceLoggingFilterArgs']:
        """
        Filtering criteria that determine which queries are logged.
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: pulumi.Input['WorkspaceLoggingFilterArgs']):
        pulumi.set(self, "filters", value)


if not MYPY:
    class WorkspaceLoggingFilterArgsDict(TypedDict):
        """
        Filters for logging
        """
        qsp_threshold: pulumi.Input[_builtins.int]
        """
        Query logs with QSP above this limit are vended
        """
elif False:
    WorkspaceLoggingFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkspaceLoggingFilterArgs:
    def __init__(__self__, *,
                 qsp_threshold: pulumi.Input[_builtins.int]):
        """
        Filters for logging
        :param pulumi.Input[_builtins.int] qsp_threshold: Query logs with QSP above this limit are vended
        """
        pulumi.set(__self__, "qsp_threshold", qsp_threshold)

    @_builtins.property
    @pulumi.getter(name="qspThreshold")
    def qsp_threshold(self) -> pulumi.Input[_builtins.int]:
        """
        Query logs with QSP above this limit are vended
        """
        return pulumi.get(self, "qsp_threshold")

    @qsp_threshold.setter
    def qsp_threshold(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "qsp_threshold", value)


if not MYPY:
    class WorkspaceQueryLoggingConfigurationArgsDict(TypedDict):
        """
        Query logging configuration
        """
        destinations: pulumi.Input[Sequence[pulumi.Input['WorkspaceLoggingDestinationArgsDict']]]
        """
        The destinations configuration for query logging
        """
elif False:
    WorkspaceQueryLoggingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkspaceQueryLoggingConfigurationArgs:
    def __init__(__self__, *,
                 destinations: pulumi.Input[Sequence[pulumi.Input['WorkspaceLoggingDestinationArgs']]]):
        """
        Query logging configuration
        :param pulumi.Input[Sequence[pulumi.Input['WorkspaceLoggingDestinationArgs']]] destinations: The destinations configuration for query logging
        """
        pulumi.set(__self__, "destinations", destinations)

    @_builtins.property
    @pulumi.getter
    def destinations(self) -> pulumi.Input[Sequence[pulumi.Input['WorkspaceLoggingDestinationArgs']]]:
        """
        The destinations configuration for query logging
        """
        return pulumi.get(self, "destinations")

    @destinations.setter
    def destinations(self, value: pulumi.Input[Sequence[pulumi.Input['WorkspaceLoggingDestinationArgs']]]):
        pulumi.set(self, "destinations", value)


