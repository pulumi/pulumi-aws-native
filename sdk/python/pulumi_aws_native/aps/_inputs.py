# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ScraperDestinationAmpConfigurationPropertiesArgs',
    'ScraperDestinationAmpConfigurationPropertiesArgsDict',
    'ScraperDestinationArgs',
    'ScraperDestinationArgsDict',
    'ScraperRoleConfigurationArgs',
    'ScraperRoleConfigurationArgsDict',
    'ScraperScrapeConfigurationArgs',
    'ScraperScrapeConfigurationArgsDict',
    'ScraperSourceEksConfigurationPropertiesArgs',
    'ScraperSourceEksConfigurationPropertiesArgsDict',
    'ScraperSourceArgs',
    'ScraperSourceArgsDict',
    'WorkspaceConfigurationArgs',
    'WorkspaceConfigurationArgsDict',
    'WorkspaceLabelArgs',
    'WorkspaceLabelArgsDict',
    'WorkspaceLimitsPerLabelSetEntryArgs',
    'WorkspaceLimitsPerLabelSetEntryArgsDict',
    'WorkspaceLimitsPerLabelSetArgs',
    'WorkspaceLimitsPerLabelSetArgsDict',
    'WorkspaceLoggingConfigurationArgs',
    'WorkspaceLoggingConfigurationArgsDict',
]

MYPY = False

if not MYPY:
    class ScraperDestinationAmpConfigurationPropertiesArgsDict(TypedDict):
        """
        Configuration for Amazon Managed Prometheus metrics destination
        """
        workspace_arn: pulumi.Input[builtins.str]
        """
        ARN of an Amazon Managed Prometheus workspace
        """
elif False:
    ScraperDestinationAmpConfigurationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScraperDestinationAmpConfigurationPropertiesArgs:
    def __init__(__self__, *,
                 workspace_arn: pulumi.Input[builtins.str]):
        """
        Configuration for Amazon Managed Prometheus metrics destination
        :param pulumi.Input[builtins.str] workspace_arn: ARN of an Amazon Managed Prometheus workspace
        """
        pulumi.set(__self__, "workspace_arn", workspace_arn)

    @property
    @pulumi.getter(name="workspaceArn")
    def workspace_arn(self) -> pulumi.Input[builtins.str]:
        """
        ARN of an Amazon Managed Prometheus workspace
        """
        return pulumi.get(self, "workspace_arn")

    @workspace_arn.setter
    def workspace_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "workspace_arn", value)


if not MYPY:
    class ScraperDestinationArgsDict(TypedDict):
        """
        Scraper metrics destination
        """
        amp_configuration: NotRequired[pulumi.Input['ScraperDestinationAmpConfigurationPropertiesArgsDict']]
        """
        Configuration for Amazon Managed Prometheus metrics destination
        """
elif False:
    ScraperDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScraperDestinationArgs:
    def __init__(__self__, *,
                 amp_configuration: Optional[pulumi.Input['ScraperDestinationAmpConfigurationPropertiesArgs']] = None):
        """
        Scraper metrics destination
        :param pulumi.Input['ScraperDestinationAmpConfigurationPropertiesArgs'] amp_configuration: Configuration for Amazon Managed Prometheus metrics destination
        """
        if amp_configuration is not None:
            pulumi.set(__self__, "amp_configuration", amp_configuration)

    @property
    @pulumi.getter(name="ampConfiguration")
    def amp_configuration(self) -> Optional[pulumi.Input['ScraperDestinationAmpConfigurationPropertiesArgs']]:
        """
        Configuration for Amazon Managed Prometheus metrics destination
        """
        return pulumi.get(self, "amp_configuration")

    @amp_configuration.setter
    def amp_configuration(self, value: Optional[pulumi.Input['ScraperDestinationAmpConfigurationPropertiesArgs']]):
        pulumi.set(self, "amp_configuration", value)


if not MYPY:
    class ScraperRoleConfigurationArgsDict(TypedDict):
        """
        Role configuration
        """
        source_role_arn: NotRequired[pulumi.Input[builtins.str]]
        """
        IAM Role in source account
        """
        target_role_arn: NotRequired[pulumi.Input[builtins.str]]
        """
        IAM Role in the target account
        """
elif False:
    ScraperRoleConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScraperRoleConfigurationArgs:
    def __init__(__self__, *,
                 source_role_arn: Optional[pulumi.Input[builtins.str]] = None,
                 target_role_arn: Optional[pulumi.Input[builtins.str]] = None):
        """
        Role configuration
        :param pulumi.Input[builtins.str] source_role_arn: IAM Role in source account
        :param pulumi.Input[builtins.str] target_role_arn: IAM Role in the target account
        """
        if source_role_arn is not None:
            pulumi.set(__self__, "source_role_arn", source_role_arn)
        if target_role_arn is not None:
            pulumi.set(__self__, "target_role_arn", target_role_arn)

    @property
    @pulumi.getter(name="sourceRoleArn")
    def source_role_arn(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        IAM Role in source account
        """
        return pulumi.get(self, "source_role_arn")

    @source_role_arn.setter
    def source_role_arn(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "source_role_arn", value)

    @property
    @pulumi.getter(name="targetRoleArn")
    def target_role_arn(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        IAM Role in the target account
        """
        return pulumi.get(self, "target_role_arn")

    @target_role_arn.setter
    def target_role_arn(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "target_role_arn", value)


if not MYPY:
    class ScraperScrapeConfigurationArgsDict(TypedDict):
        """
        Scraper configuration
        """
        configuration_blob: NotRequired[pulumi.Input[builtins.str]]
        """
        Prometheus compatible scrape configuration in base64 encoded blob format
        """
elif False:
    ScraperScrapeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScraperScrapeConfigurationArgs:
    def __init__(__self__, *,
                 configuration_blob: Optional[pulumi.Input[builtins.str]] = None):
        """
        Scraper configuration
        :param pulumi.Input[builtins.str] configuration_blob: Prometheus compatible scrape configuration in base64 encoded blob format
        """
        if configuration_blob is not None:
            pulumi.set(__self__, "configuration_blob", configuration_blob)

    @property
    @pulumi.getter(name="configurationBlob")
    def configuration_blob(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Prometheus compatible scrape configuration in base64 encoded blob format
        """
        return pulumi.get(self, "configuration_blob")

    @configuration_blob.setter
    def configuration_blob(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "configuration_blob", value)


if not MYPY:
    class ScraperSourceEksConfigurationPropertiesArgsDict(TypedDict):
        """
        Configuration for EKS metrics source
        """
        cluster_arn: pulumi.Input[builtins.str]
        """
        ARN of an EKS cluster
        """
        subnet_ids: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        List of subnet IDs
        """
        security_group_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of security group IDs
        """
elif False:
    ScraperSourceEksConfigurationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScraperSourceEksConfigurationPropertiesArgs:
    def __init__(__self__, *,
                 cluster_arn: pulumi.Input[builtins.str],
                 subnet_ids: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        Configuration for EKS metrics source
        :param pulumi.Input[builtins.str] cluster_arn: ARN of an EKS cluster
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] subnet_ids: List of subnet IDs
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] security_group_ids: List of security group IDs
        """
        pulumi.set(__self__, "cluster_arn", cluster_arn)
        pulumi.set(__self__, "subnet_ids", subnet_ids)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)

    @property
    @pulumi.getter(name="clusterArn")
    def cluster_arn(self) -> pulumi.Input[builtins.str]:
        """
        ARN of an EKS cluster
        """
        return pulumi.get(self, "cluster_arn")

    @cluster_arn.setter
    def cluster_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "cluster_arn", value)

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        List of subnet IDs
        """
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "subnet_ids", value)

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of security group IDs
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "security_group_ids", value)


if not MYPY:
    class ScraperSourceArgsDict(TypedDict):
        """
        Scraper metrics source
        """
        eks_configuration: NotRequired[pulumi.Input['ScraperSourceEksConfigurationPropertiesArgsDict']]
        """
        Configuration for EKS metrics source
        """
elif False:
    ScraperSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScraperSourceArgs:
    def __init__(__self__, *,
                 eks_configuration: Optional[pulumi.Input['ScraperSourceEksConfigurationPropertiesArgs']] = None):
        """
        Scraper metrics source
        :param pulumi.Input['ScraperSourceEksConfigurationPropertiesArgs'] eks_configuration: Configuration for EKS metrics source
        """
        if eks_configuration is not None:
            pulumi.set(__self__, "eks_configuration", eks_configuration)

    @property
    @pulumi.getter(name="eksConfiguration")
    def eks_configuration(self) -> Optional[pulumi.Input['ScraperSourceEksConfigurationPropertiesArgs']]:
        """
        Configuration for EKS metrics source
        """
        return pulumi.get(self, "eks_configuration")

    @eks_configuration.setter
    def eks_configuration(self, value: Optional[pulumi.Input['ScraperSourceEksConfigurationPropertiesArgs']]):
        pulumi.set(self, "eks_configuration", value)


if not MYPY:
    class WorkspaceConfigurationArgsDict(TypedDict):
        """
        Workspace configuration
        """
        limits_per_label_sets: NotRequired[pulumi.Input[Sequence[pulumi.Input['WorkspaceLimitsPerLabelSetArgsDict']]]]
        """
        An array of label set and associated limits
        """
        retention_period_in_days: NotRequired[pulumi.Input[builtins.int]]
        """
        How many days that metrics are retained in the workspace
        """
elif False:
    WorkspaceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkspaceConfigurationArgs:
    def __init__(__self__, *,
                 limits_per_label_sets: Optional[pulumi.Input[Sequence[pulumi.Input['WorkspaceLimitsPerLabelSetArgs']]]] = None,
                 retention_period_in_days: Optional[pulumi.Input[builtins.int]] = None):
        """
        Workspace configuration
        :param pulumi.Input[Sequence[pulumi.Input['WorkspaceLimitsPerLabelSetArgs']]] limits_per_label_sets: An array of label set and associated limits
        :param pulumi.Input[builtins.int] retention_period_in_days: How many days that metrics are retained in the workspace
        """
        if limits_per_label_sets is not None:
            pulumi.set(__self__, "limits_per_label_sets", limits_per_label_sets)
        if retention_period_in_days is not None:
            pulumi.set(__self__, "retention_period_in_days", retention_period_in_days)

    @property
    @pulumi.getter(name="limitsPerLabelSets")
    def limits_per_label_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkspaceLimitsPerLabelSetArgs']]]]:
        """
        An array of label set and associated limits
        """
        return pulumi.get(self, "limits_per_label_sets")

    @limits_per_label_sets.setter
    def limits_per_label_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkspaceLimitsPerLabelSetArgs']]]]):
        pulumi.set(self, "limits_per_label_sets", value)

    @property
    @pulumi.getter(name="retentionPeriodInDays")
    def retention_period_in_days(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        How many days that metrics are retained in the workspace
        """
        return pulumi.get(self, "retention_period_in_days")

    @retention_period_in_days.setter
    def retention_period_in_days(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "retention_period_in_days", value)


if not MYPY:
    class WorkspaceLabelArgsDict(TypedDict):
        """
        Series label
        """
        name: pulumi.Input[builtins.str]
        """
        Name of the label
        """
        value: pulumi.Input[builtins.str]
        """
        Value of the label
        """
elif False:
    WorkspaceLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkspaceLabelArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str]):
        """
        Series label
        :param pulumi.Input[builtins.str] name: Name of the label
        :param pulumi.Input[builtins.str] value: Value of the label
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the label
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        Value of the label
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WorkspaceLimitsPerLabelSetEntryArgsDict(TypedDict):
        """
        Limits that can be applied to a label set
        """
        max_series: NotRequired[pulumi.Input[builtins.int]]
        """
        The maximum number of active series that can be ingested for this label set
        """
elif False:
    WorkspaceLimitsPerLabelSetEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkspaceLimitsPerLabelSetEntryArgs:
    def __init__(__self__, *,
                 max_series: Optional[pulumi.Input[builtins.int]] = None):
        """
        Limits that can be applied to a label set
        :param pulumi.Input[builtins.int] max_series: The maximum number of active series that can be ingested for this label set
        """
        if max_series is not None:
            pulumi.set(__self__, "max_series", max_series)

    @property
    @pulumi.getter(name="maxSeries")
    def max_series(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The maximum number of active series that can be ingested for this label set
        """
        return pulumi.get(self, "max_series")

    @max_series.setter
    def max_series(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_series", value)


if not MYPY:
    class WorkspaceLimitsPerLabelSetArgsDict(TypedDict):
        """
        Label set and its associated limits
        """
        label_set: pulumi.Input[Sequence[pulumi.Input['WorkspaceLabelArgsDict']]]
        """
        An array of series labels
        """
        limits: pulumi.Input['WorkspaceLimitsPerLabelSetEntryArgsDict']
        """
        This structure contains the information about the limits that apply to time series that match this label set.
        """
elif False:
    WorkspaceLimitsPerLabelSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkspaceLimitsPerLabelSetArgs:
    def __init__(__self__, *,
                 label_set: pulumi.Input[Sequence[pulumi.Input['WorkspaceLabelArgs']]],
                 limits: pulumi.Input['WorkspaceLimitsPerLabelSetEntryArgs']):
        """
        Label set and its associated limits
        :param pulumi.Input[Sequence[pulumi.Input['WorkspaceLabelArgs']]] label_set: An array of series labels
        :param pulumi.Input['WorkspaceLimitsPerLabelSetEntryArgs'] limits: This structure contains the information about the limits that apply to time series that match this label set.
        """
        pulumi.set(__self__, "label_set", label_set)
        pulumi.set(__self__, "limits", limits)

    @property
    @pulumi.getter(name="labelSet")
    def label_set(self) -> pulumi.Input[Sequence[pulumi.Input['WorkspaceLabelArgs']]]:
        """
        An array of series labels
        """
        return pulumi.get(self, "label_set")

    @label_set.setter
    def label_set(self, value: pulumi.Input[Sequence[pulumi.Input['WorkspaceLabelArgs']]]):
        pulumi.set(self, "label_set", value)

    @property
    @pulumi.getter
    def limits(self) -> pulumi.Input['WorkspaceLimitsPerLabelSetEntryArgs']:
        """
        This structure contains the information about the limits that apply to time series that match this label set.
        """
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: pulumi.Input['WorkspaceLimitsPerLabelSetEntryArgs']):
        pulumi.set(self, "limits", value)


if not MYPY:
    class WorkspaceLoggingConfigurationArgsDict(TypedDict):
        """
        Logging configuration
        """
        log_group_arn: NotRequired[pulumi.Input[builtins.str]]
        """
        CloudWatch log group ARN
        """
elif False:
    WorkspaceLoggingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkspaceLoggingConfigurationArgs:
    def __init__(__self__, *,
                 log_group_arn: Optional[pulumi.Input[builtins.str]] = None):
        """
        Logging configuration
        :param pulumi.Input[builtins.str] log_group_arn: CloudWatch log group ARN
        """
        if log_group_arn is not None:
            pulumi.set(__self__, "log_group_arn", log_group_arn)

    @property
    @pulumi.getter(name="logGroupArn")
    def log_group_arn(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        CloudWatch log group ARN
        """
        return pulumi.get(self, "log_group_arn")

    @log_group_arn.setter
    def log_group_arn(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "log_group_arn", value)


