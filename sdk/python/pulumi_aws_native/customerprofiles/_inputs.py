# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'CalculatedAttributeDefinitionAttributeDetailsArgs',
    'CalculatedAttributeDefinitionAttributeDetailsArgsDict',
    'CalculatedAttributeDefinitionAttributeItemArgs',
    'CalculatedAttributeDefinitionAttributeItemArgsDict',
    'CalculatedAttributeDefinitionConditionsArgs',
    'CalculatedAttributeDefinitionConditionsArgsDict',
    'CalculatedAttributeDefinitionRangeArgs',
    'CalculatedAttributeDefinitionRangeArgsDict',
    'CalculatedAttributeDefinitionThresholdArgs',
    'CalculatedAttributeDefinitionThresholdArgsDict',
    'DomainAttributeTypesSelectorArgs',
    'DomainAttributeTypesSelectorArgsDict',
    'DomainAutoMergingArgs',
    'DomainAutoMergingArgsDict',
    'DomainConflictResolutionArgs',
    'DomainConflictResolutionArgsDict',
    'DomainConsolidationArgs',
    'DomainConsolidationArgsDict',
    'DomainExportingConfigArgs',
    'DomainExportingConfigArgsDict',
    'DomainJobScheduleArgs',
    'DomainJobScheduleArgsDict',
    'DomainMatchingRuleArgs',
    'DomainMatchingRuleArgsDict',
    'DomainMatchingArgs',
    'DomainMatchingArgsDict',
    'DomainRuleBasedMatchingArgs',
    'DomainRuleBasedMatchingArgsDict',
    'DomainS3ExportingConfigArgs',
    'DomainS3ExportingConfigArgsDict',
    'IntegrationConnectorOperatorArgs',
    'IntegrationConnectorOperatorArgsDict',
    'IntegrationFlowDefinitionArgs',
    'IntegrationFlowDefinitionArgsDict',
    'IntegrationIncrementalPullConfigArgs',
    'IntegrationIncrementalPullConfigArgsDict',
    'IntegrationMarketoSourcePropertiesArgs',
    'IntegrationMarketoSourcePropertiesArgsDict',
    'IntegrationObjectTypeMappingArgs',
    'IntegrationObjectTypeMappingArgsDict',
    'IntegrationS3SourcePropertiesArgs',
    'IntegrationS3SourcePropertiesArgsDict',
    'IntegrationSalesforceSourcePropertiesArgs',
    'IntegrationSalesforceSourcePropertiesArgsDict',
    'IntegrationScheduledTriggerPropertiesArgs',
    'IntegrationScheduledTriggerPropertiesArgsDict',
    'IntegrationServiceNowSourcePropertiesArgs',
    'IntegrationServiceNowSourcePropertiesArgsDict',
    'IntegrationSourceConnectorPropertiesArgs',
    'IntegrationSourceConnectorPropertiesArgsDict',
    'IntegrationSourceFlowConfigArgs',
    'IntegrationSourceFlowConfigArgsDict',
    'IntegrationTaskPropertiesMapArgs',
    'IntegrationTaskPropertiesMapArgsDict',
    'IntegrationTaskArgs',
    'IntegrationTaskArgsDict',
    'IntegrationTriggerConfigArgs',
    'IntegrationTriggerConfigArgsDict',
    'IntegrationTriggerPropertiesArgs',
    'IntegrationTriggerPropertiesArgsDict',
    'IntegrationZendeskSourcePropertiesArgs',
    'IntegrationZendeskSourcePropertiesArgsDict',
    'ObjectTypeFieldMapArgs',
    'ObjectTypeFieldMapArgsDict',
    'ObjectTypeFieldArgs',
    'ObjectTypeFieldArgsDict',
    'ObjectTypeKeyMapArgs',
    'ObjectTypeKeyMapArgsDict',
    'ObjectTypeKeyArgs',
    'ObjectTypeKeyArgsDict',
]

MYPY = False

if not MYPY:
    class CalculatedAttributeDefinitionAttributeDetailsArgsDict(TypedDict):
        """
        Mathematical expression and a list of attribute items specified in that expression.
        """
        attributes: pulumi.Input[Sequence[pulumi.Input['CalculatedAttributeDefinitionAttributeItemArgsDict']]]
        """
        Mathematical expression and a list of attribute items specified in that expression.
        """
        expression: pulumi.Input[str]
        """
        Mathematical expression that is performed on attribute items provided in the attribute list. Each element in the expression should follow the structure of \\"{ObjectTypeName.AttributeName}\\".
        """
elif False:
    CalculatedAttributeDefinitionAttributeDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CalculatedAttributeDefinitionAttributeDetailsArgs:
    def __init__(__self__, *,
                 attributes: pulumi.Input[Sequence[pulumi.Input['CalculatedAttributeDefinitionAttributeItemArgs']]],
                 expression: pulumi.Input[str]):
        """
        Mathematical expression and a list of attribute items specified in that expression.
        :param pulumi.Input[Sequence[pulumi.Input['CalculatedAttributeDefinitionAttributeItemArgs']]] attributes: Mathematical expression and a list of attribute items specified in that expression.
        :param pulumi.Input[str] expression: Mathematical expression that is performed on attribute items provided in the attribute list. Each element in the expression should follow the structure of \\"{ObjectTypeName.AttributeName}\\".
        """
        pulumi.set(__self__, "attributes", attributes)
        pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter
    def attributes(self) -> pulumi.Input[Sequence[pulumi.Input['CalculatedAttributeDefinitionAttributeItemArgs']]]:
        """
        Mathematical expression and a list of attribute items specified in that expression.
        """
        return pulumi.get(self, "attributes")

    @attributes.setter
    def attributes(self, value: pulumi.Input[Sequence[pulumi.Input['CalculatedAttributeDefinitionAttributeItemArgs']]]):
        pulumi.set(self, "attributes", value)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        """
        Mathematical expression that is performed on attribute items provided in the attribute list. Each element in the expression should follow the structure of \\"{ObjectTypeName.AttributeName}\\".
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)


if not MYPY:
    class CalculatedAttributeDefinitionAttributeItemArgsDict(TypedDict):
        """
        The details of a single attribute item specified in the mathematical expression.
        """
        name: pulumi.Input[str]
elif False:
    CalculatedAttributeDefinitionAttributeItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CalculatedAttributeDefinitionAttributeItemArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        The details of a single attribute item specified in the mathematical expression.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class CalculatedAttributeDefinitionConditionsArgsDict(TypedDict):
        """
        The conditions including range, object count, and threshold for the calculated attribute.
        """
        object_count: NotRequired[pulumi.Input[int]]
        """
        The number of profile objects used for the calculated attribute.
        """
        range: NotRequired[pulumi.Input['CalculatedAttributeDefinitionRangeArgsDict']]
        """
        The relative time period over which data is included in the aggregation.
        """
        threshold: NotRequired[pulumi.Input['CalculatedAttributeDefinitionThresholdArgsDict']]
        """
        The threshold for the calculated attribute.
        """
elif False:
    CalculatedAttributeDefinitionConditionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CalculatedAttributeDefinitionConditionsArgs:
    def __init__(__self__, *,
                 object_count: Optional[pulumi.Input[int]] = None,
                 range: Optional[pulumi.Input['CalculatedAttributeDefinitionRangeArgs']] = None,
                 threshold: Optional[pulumi.Input['CalculatedAttributeDefinitionThresholdArgs']] = None):
        """
        The conditions including range, object count, and threshold for the calculated attribute.
        :param pulumi.Input[int] object_count: The number of profile objects used for the calculated attribute.
        :param pulumi.Input['CalculatedAttributeDefinitionRangeArgs'] range: The relative time period over which data is included in the aggregation.
        :param pulumi.Input['CalculatedAttributeDefinitionThresholdArgs'] threshold: The threshold for the calculated attribute.
        """
        if object_count is not None:
            pulumi.set(__self__, "object_count", object_count)
        if range is not None:
            pulumi.set(__self__, "range", range)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="objectCount")
    def object_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of profile objects used for the calculated attribute.
        """
        return pulumi.get(self, "object_count")

    @object_count.setter
    def object_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "object_count", value)

    @property
    @pulumi.getter
    def range(self) -> Optional[pulumi.Input['CalculatedAttributeDefinitionRangeArgs']]:
        """
        The relative time period over which data is included in the aggregation.
        """
        return pulumi.get(self, "range")

    @range.setter
    def range(self, value: Optional[pulumi.Input['CalculatedAttributeDefinitionRangeArgs']]):
        pulumi.set(self, "range", value)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input['CalculatedAttributeDefinitionThresholdArgs']]:
        """
        The threshold for the calculated attribute.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input['CalculatedAttributeDefinitionThresholdArgs']]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class CalculatedAttributeDefinitionRangeArgsDict(TypedDict):
        """
        The relative time period over which data is included in the aggregation.
        """
        unit: pulumi.Input['CalculatedAttributeDefinitionRangeUnit']
        """
        The unit of time.
        """
        value: pulumi.Input[int]
        """
        The amount of time of the specified unit.
        """
elif False:
    CalculatedAttributeDefinitionRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CalculatedAttributeDefinitionRangeArgs:
    def __init__(__self__, *,
                 unit: pulumi.Input['CalculatedAttributeDefinitionRangeUnit'],
                 value: pulumi.Input[int]):
        """
        The relative time period over which data is included in the aggregation.
        :param pulumi.Input['CalculatedAttributeDefinitionRangeUnit'] unit: The unit of time.
        :param pulumi.Input[int] value: The amount of time of the specified unit.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input['CalculatedAttributeDefinitionRangeUnit']:
        """
        The unit of time.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input['CalculatedAttributeDefinitionRangeUnit']):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[int]:
        """
        The amount of time of the specified unit.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[int]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CalculatedAttributeDefinitionThresholdArgsDict(TypedDict):
        """
        The threshold for the calculated attribute.
        """
        operator: pulumi.Input['CalculatedAttributeDefinitionThresholdOperator']
        """
        The operator of the threshold.
        """
        value: pulumi.Input[str]
        """
        The value of the threshold.
        """
elif False:
    CalculatedAttributeDefinitionThresholdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CalculatedAttributeDefinitionThresholdArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input['CalculatedAttributeDefinitionThresholdOperator'],
                 value: pulumi.Input[str]):
        """
        The threshold for the calculated attribute.
        :param pulumi.Input['CalculatedAttributeDefinitionThresholdOperator'] operator: The operator of the threshold.
        :param pulumi.Input[str] value: The value of the threshold.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input['CalculatedAttributeDefinitionThresholdOperator']:
        """
        The operator of the threshold.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input['CalculatedAttributeDefinitionThresholdOperator']):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value of the threshold.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DomainAttributeTypesSelectorArgsDict(TypedDict):
        """
        Configures information about the AttributeTypesSelector where the rule-based identity resolution uses to match profiles.
        """
        attribute_matching_model: pulumi.Input['DomainAttributeTypesSelectorAttributeMatchingModel']
        """
        Configures the AttributeMatchingModel, you can either choose ONE_TO_ONE or MANY_TO_MANY.
        """
        address: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The Address type. You can choose from Address, BusinessAddress, MaillingAddress, and ShippingAddress. You only can use the Address type in the MatchingRule. For example, if you want to match profile based on BusinessAddress.City or MaillingAddress.City, you need to choose the BusinessAddress and the MaillingAddress to represent the Address type and specify the Address.City on the matching rule.
        """
        email_address: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The Email type. You can choose from EmailAddress, BusinessEmailAddress and PersonalEmailAddress. You only can use the EmailAddress type in the MatchingRule. For example, if you want to match profile based on PersonalEmailAddress or BusinessEmailAddress, you need to choose the PersonalEmailAddress and the BusinessEmailAddress to represent the EmailAddress type and only specify the EmailAddress on the matching rule.
        """
        phone_number: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The PhoneNumber type. You can choose from PhoneNumber, HomePhoneNumber, and MobilePhoneNumber. You only can use the PhoneNumber type in the MatchingRule. For example, if you want to match a profile based on Phone or HomePhone, you need to choose the Phone and the HomePhone to represent the PhoneNumber type and only specify the PhoneNumber on the matching rule.
        """
elif False:
    DomainAttributeTypesSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainAttributeTypesSelectorArgs:
    def __init__(__self__, *,
                 attribute_matching_model: pulumi.Input['DomainAttributeTypesSelectorAttributeMatchingModel'],
                 address: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 email_address: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 phone_number: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Configures information about the AttributeTypesSelector where the rule-based identity resolution uses to match profiles.
        :param pulumi.Input['DomainAttributeTypesSelectorAttributeMatchingModel'] attribute_matching_model: Configures the AttributeMatchingModel, you can either choose ONE_TO_ONE or MANY_TO_MANY.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] address: The Address type. You can choose from Address, BusinessAddress, MaillingAddress, and ShippingAddress. You only can use the Address type in the MatchingRule. For example, if you want to match profile based on BusinessAddress.City or MaillingAddress.City, you need to choose the BusinessAddress and the MaillingAddress to represent the Address type and specify the Address.City on the matching rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] email_address: The Email type. You can choose from EmailAddress, BusinessEmailAddress and PersonalEmailAddress. You only can use the EmailAddress type in the MatchingRule. For example, if you want to match profile based on PersonalEmailAddress or BusinessEmailAddress, you need to choose the PersonalEmailAddress and the BusinessEmailAddress to represent the EmailAddress type and only specify the EmailAddress on the matching rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] phone_number: The PhoneNumber type. You can choose from PhoneNumber, HomePhoneNumber, and MobilePhoneNumber. You only can use the PhoneNumber type in the MatchingRule. For example, if you want to match a profile based on Phone or HomePhone, you need to choose the Phone and the HomePhone to represent the PhoneNumber type and only specify the PhoneNumber on the matching rule.
        """
        pulumi.set(__self__, "attribute_matching_model", attribute_matching_model)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if email_address is not None:
            pulumi.set(__self__, "email_address", email_address)
        if phone_number is not None:
            pulumi.set(__self__, "phone_number", phone_number)

    @property
    @pulumi.getter(name="attributeMatchingModel")
    def attribute_matching_model(self) -> pulumi.Input['DomainAttributeTypesSelectorAttributeMatchingModel']:
        """
        Configures the AttributeMatchingModel, you can either choose ONE_TO_ONE or MANY_TO_MANY.
        """
        return pulumi.get(self, "attribute_matching_model")

    @attribute_matching_model.setter
    def attribute_matching_model(self, value: pulumi.Input['DomainAttributeTypesSelectorAttributeMatchingModel']):
        pulumi.set(self, "attribute_matching_model", value)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The Address type. You can choose from Address, BusinessAddress, MaillingAddress, and ShippingAddress. You only can use the Address type in the MatchingRule. For example, if you want to match profile based on BusinessAddress.City or MaillingAddress.City, you need to choose the BusinessAddress and the MaillingAddress to represent the Address type and specify the Address.City on the matching rule.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The Email type. You can choose from EmailAddress, BusinessEmailAddress and PersonalEmailAddress. You only can use the EmailAddress type in the MatchingRule. For example, if you want to match profile based on PersonalEmailAddress or BusinessEmailAddress, you need to choose the PersonalEmailAddress and the BusinessEmailAddress to represent the EmailAddress type and only specify the EmailAddress on the matching rule.
        """
        return pulumi.get(self, "email_address")

    @email_address.setter
    def email_address(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "email_address", value)

    @property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The PhoneNumber type. You can choose from PhoneNumber, HomePhoneNumber, and MobilePhoneNumber. You only can use the PhoneNumber type in the MatchingRule. For example, if you want to match a profile based on Phone or HomePhone, you need to choose the Phone and the HomePhone to represent the PhoneNumber type and only specify the PhoneNumber on the matching rule.
        """
        return pulumi.get(self, "phone_number")

    @phone_number.setter
    def phone_number(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "phone_number", value)


if not MYPY:
    class DomainAutoMergingArgsDict(TypedDict):
        """
        Configuration information about the auto-merging process.
        """
        enabled: pulumi.Input[bool]
        """
        The flag that enables the auto-merging of duplicate profiles.
        """
        conflict_resolution: NotRequired[pulumi.Input['DomainConflictResolutionArgsDict']]
        """
        Determines how the auto-merging process should resolve conflicts between different profiles. For example, if Profile A and Profile B have the same `FirstName` and `LastName` , `ConflictResolution` specifies which `EmailAddress` should be used.
        """
        consolidation: NotRequired[pulumi.Input['DomainConsolidationArgsDict']]
        """
        A list of matching attributes that represent matching criteria. If two profiles meet at least one of the requirements in the matching attributes list, they will be merged.
        """
        min_allowed_confidence_score_for_merging: NotRequired[pulumi.Input[float]]
        """
        A number between 0 and 1 that represents the minimum confidence score required for profiles within a matching group to be merged during the auto-merge process. A higher score means higher similarity required to merge profiles.
        """
elif False:
    DomainAutoMergingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainAutoMergingArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 conflict_resolution: Optional[pulumi.Input['DomainConflictResolutionArgs']] = None,
                 consolidation: Optional[pulumi.Input['DomainConsolidationArgs']] = None,
                 min_allowed_confidence_score_for_merging: Optional[pulumi.Input[float]] = None):
        """
        Configuration information about the auto-merging process.
        :param pulumi.Input[bool] enabled: The flag that enables the auto-merging of duplicate profiles.
        :param pulumi.Input['DomainConflictResolutionArgs'] conflict_resolution: Determines how the auto-merging process should resolve conflicts between different profiles. For example, if Profile A and Profile B have the same `FirstName` and `LastName` , `ConflictResolution` specifies which `EmailAddress` should be used.
        :param pulumi.Input['DomainConsolidationArgs'] consolidation: A list of matching attributes that represent matching criteria. If two profiles meet at least one of the requirements in the matching attributes list, they will be merged.
        :param pulumi.Input[float] min_allowed_confidence_score_for_merging: A number between 0 and 1 that represents the minimum confidence score required for profiles within a matching group to be merged during the auto-merge process. A higher score means higher similarity required to merge profiles.
        """
        pulumi.set(__self__, "enabled", enabled)
        if conflict_resolution is not None:
            pulumi.set(__self__, "conflict_resolution", conflict_resolution)
        if consolidation is not None:
            pulumi.set(__self__, "consolidation", consolidation)
        if min_allowed_confidence_score_for_merging is not None:
            pulumi.set(__self__, "min_allowed_confidence_score_for_merging", min_allowed_confidence_score_for_merging)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        The flag that enables the auto-merging of duplicate profiles.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="conflictResolution")
    def conflict_resolution(self) -> Optional[pulumi.Input['DomainConflictResolutionArgs']]:
        """
        Determines how the auto-merging process should resolve conflicts between different profiles. For example, if Profile A and Profile B have the same `FirstName` and `LastName` , `ConflictResolution` specifies which `EmailAddress` should be used.
        """
        return pulumi.get(self, "conflict_resolution")

    @conflict_resolution.setter
    def conflict_resolution(self, value: Optional[pulumi.Input['DomainConflictResolutionArgs']]):
        pulumi.set(self, "conflict_resolution", value)

    @property
    @pulumi.getter
    def consolidation(self) -> Optional[pulumi.Input['DomainConsolidationArgs']]:
        """
        A list of matching attributes that represent matching criteria. If two profiles meet at least one of the requirements in the matching attributes list, they will be merged.
        """
        return pulumi.get(self, "consolidation")

    @consolidation.setter
    def consolidation(self, value: Optional[pulumi.Input['DomainConsolidationArgs']]):
        pulumi.set(self, "consolidation", value)

    @property
    @pulumi.getter(name="minAllowedConfidenceScoreForMerging")
    def min_allowed_confidence_score_for_merging(self) -> Optional[pulumi.Input[float]]:
        """
        A number between 0 and 1 that represents the minimum confidence score required for profiles within a matching group to be merged during the auto-merge process. A higher score means higher similarity required to merge profiles.
        """
        return pulumi.get(self, "min_allowed_confidence_score_for_merging")

    @min_allowed_confidence_score_for_merging.setter
    def min_allowed_confidence_score_for_merging(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "min_allowed_confidence_score_for_merging", value)


if not MYPY:
    class DomainConflictResolutionArgsDict(TypedDict):
        """
        How the auto-merging process should resolve conflicts between different profiles. For example, if Profile A and Profile B have the same FirstName and LastName (and that is the matching criteria), which EmailAddress should be used? 
        """
        conflict_resolving_model: pulumi.Input['DomainConflictResolutionConflictResolvingModel']
        """
        How the auto-merging process should resolve conflicts between different profiles.
        """
        source_name: NotRequired[pulumi.Input[str]]
        """
        The ObjectType name that is used to resolve profile merging conflicts when choosing SOURCE as the ConflictResolvingModel.
        """
elif False:
    DomainConflictResolutionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainConflictResolutionArgs:
    def __init__(__self__, *,
                 conflict_resolving_model: pulumi.Input['DomainConflictResolutionConflictResolvingModel'],
                 source_name: Optional[pulumi.Input[str]] = None):
        """
        How the auto-merging process should resolve conflicts between different profiles. For example, if Profile A and Profile B have the same FirstName and LastName (and that is the matching criteria), which EmailAddress should be used? 
        :param pulumi.Input['DomainConflictResolutionConflictResolvingModel'] conflict_resolving_model: How the auto-merging process should resolve conflicts between different profiles.
        :param pulumi.Input[str] source_name: The ObjectType name that is used to resolve profile merging conflicts when choosing SOURCE as the ConflictResolvingModel.
        """
        pulumi.set(__self__, "conflict_resolving_model", conflict_resolving_model)
        if source_name is not None:
            pulumi.set(__self__, "source_name", source_name)

    @property
    @pulumi.getter(name="conflictResolvingModel")
    def conflict_resolving_model(self) -> pulumi.Input['DomainConflictResolutionConflictResolvingModel']:
        """
        How the auto-merging process should resolve conflicts between different profiles.
        """
        return pulumi.get(self, "conflict_resolving_model")

    @conflict_resolving_model.setter
    def conflict_resolving_model(self, value: pulumi.Input['DomainConflictResolutionConflictResolvingModel']):
        pulumi.set(self, "conflict_resolving_model", value)

    @property
    @pulumi.getter(name="sourceName")
    def source_name(self) -> Optional[pulumi.Input[str]]:
        """
        The ObjectType name that is used to resolve profile merging conflicts when choosing SOURCE as the ConflictResolvingModel.
        """
        return pulumi.get(self, "source_name")

    @source_name.setter
    def source_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_name", value)


if not MYPY:
    class DomainConsolidationArgsDict(TypedDict):
        """
        A list of matching attributes that represent matching criteria. If two profiles meet at least one of the requirements in the matching attributes list, they will be merged.
        """
        matching_attributes_list: pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[str]]]]]
        """
        A list of matching criteria.
        """
elif False:
    DomainConsolidationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainConsolidationArgs:
    def __init__(__self__, *,
                 matching_attributes_list: pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[str]]]]]):
        """
        A list of matching attributes that represent matching criteria. If two profiles meet at least one of the requirements in the matching attributes list, they will be merged.
        :param pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[str]]]]] matching_attributes_list: A list of matching criteria.
        """
        pulumi.set(__self__, "matching_attributes_list", matching_attributes_list)

    @property
    @pulumi.getter(name="matchingAttributesList")
    def matching_attributes_list(self) -> pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[str]]]]]:
        """
        A list of matching criteria.
        """
        return pulumi.get(self, "matching_attributes_list")

    @matching_attributes_list.setter
    def matching_attributes_list(self, value: pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[str]]]]]):
        pulumi.set(self, "matching_attributes_list", value)


if not MYPY:
    class DomainExportingConfigArgsDict(TypedDict):
        """
        Configuration information for exporting Identity Resolution results, for example, to an S3 bucket.
        """
        s3_exporting: NotRequired[pulumi.Input['DomainS3ExportingConfigArgsDict']]
elif False:
    DomainExportingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainExportingConfigArgs:
    def __init__(__self__, *,
                 s3_exporting: Optional[pulumi.Input['DomainS3ExportingConfigArgs']] = None):
        """
        Configuration information for exporting Identity Resolution results, for example, to an S3 bucket.
        """
        if s3_exporting is not None:
            pulumi.set(__self__, "s3_exporting", s3_exporting)

    @property
    @pulumi.getter(name="s3Exporting")
    def s3_exporting(self) -> Optional[pulumi.Input['DomainS3ExportingConfigArgs']]:
        return pulumi.get(self, "s3_exporting")

    @s3_exporting.setter
    def s3_exporting(self, value: Optional[pulumi.Input['DomainS3ExportingConfigArgs']]):
        pulumi.set(self, "s3_exporting", value)


if not MYPY:
    class DomainJobScheduleArgsDict(TypedDict):
        """
        The day and time when do you want to start the Identity Resolution Job every week.
        """
        day_of_the_week: pulumi.Input['DomainJobScheduleDayOfTheWeek']
        """
        The day when the Identity Resolution Job should run every week.
        """
        time: pulumi.Input[str]
        """
        The time when the Identity Resolution Job should run every week.
        """
elif False:
    DomainJobScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainJobScheduleArgs:
    def __init__(__self__, *,
                 day_of_the_week: pulumi.Input['DomainJobScheduleDayOfTheWeek'],
                 time: pulumi.Input[str]):
        """
        The day and time when do you want to start the Identity Resolution Job every week.
        :param pulumi.Input['DomainJobScheduleDayOfTheWeek'] day_of_the_week: The day when the Identity Resolution Job should run every week.
        :param pulumi.Input[str] time: The time when the Identity Resolution Job should run every week.
        """
        pulumi.set(__self__, "day_of_the_week", day_of_the_week)
        pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter(name="dayOfTheWeek")
    def day_of_the_week(self) -> pulumi.Input['DomainJobScheduleDayOfTheWeek']:
        """
        The day when the Identity Resolution Job should run every week.
        """
        return pulumi.get(self, "day_of_the_week")

    @day_of_the_week.setter
    def day_of_the_week(self, value: pulumi.Input['DomainJobScheduleDayOfTheWeek']):
        pulumi.set(self, "day_of_the_week", value)

    @property
    @pulumi.getter
    def time(self) -> pulumi.Input[str]:
        """
        The time when the Identity Resolution Job should run every week.
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: pulumi.Input[str]):
        pulumi.set(self, "time", value)


if not MYPY:
    class DomainMatchingRuleArgsDict(TypedDict):
        """
        Specifies how does the rule-based matching process should match profiles.
        """
        rule: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A single rule level of the `MatchRules` . Configures how the rule-based matching process should match profiles.
        """
elif False:
    DomainMatchingRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainMatchingRuleArgs:
    def __init__(__self__, *,
                 rule: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        Specifies how does the rule-based matching process should match profiles.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] rule: A single rule level of the `MatchRules` . Configures how the rule-based matching process should match profiles.
        """
        pulumi.set(__self__, "rule", rule)

    @property
    @pulumi.getter
    def rule(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A single rule level of the `MatchRules` . Configures how the rule-based matching process should match profiles.
        """
        return pulumi.get(self, "rule")

    @rule.setter
    def rule(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "rule", value)


if not MYPY:
    class DomainMatchingArgsDict(TypedDict):
        """
        The process of matching duplicate profiles. If Matching = true, Amazon Connect Customer Profiles starts a weekly batch process called Identity Resolution Job. If you do not specify a date and time for Identity Resolution Job to run, by default it runs every Saturday at 12AM UTC to detect duplicate profiles in your domains. After the Identity Resolution Job completes, use the GetMatches API to return and review the results. Or, if you have configured ExportingConfig in the MatchingRequest, you can download the results from S3.
        """
        enabled: pulumi.Input[bool]
        """
        The flag that enables the matching process of duplicate profiles.
        """
        auto_merging: NotRequired[pulumi.Input['DomainAutoMergingArgsDict']]
        """
        Configuration information about the auto-merging process.
        """
        exporting_config: NotRequired[pulumi.Input['DomainExportingConfigArgsDict']]
        """
        The S3 location where Identity Resolution Jobs write result files.
        """
        job_schedule: NotRequired[pulumi.Input['DomainJobScheduleArgsDict']]
        """
        The day and time when do you want to start the Identity Resolution Job every week.
        """
elif False:
    DomainMatchingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainMatchingArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 auto_merging: Optional[pulumi.Input['DomainAutoMergingArgs']] = None,
                 exporting_config: Optional[pulumi.Input['DomainExportingConfigArgs']] = None,
                 job_schedule: Optional[pulumi.Input['DomainJobScheduleArgs']] = None):
        """
        The process of matching duplicate profiles. If Matching = true, Amazon Connect Customer Profiles starts a weekly batch process called Identity Resolution Job. If you do not specify a date and time for Identity Resolution Job to run, by default it runs every Saturday at 12AM UTC to detect duplicate profiles in your domains. After the Identity Resolution Job completes, use the GetMatches API to return and review the results. Or, if you have configured ExportingConfig in the MatchingRequest, you can download the results from S3.
        :param pulumi.Input[bool] enabled: The flag that enables the matching process of duplicate profiles.
        :param pulumi.Input['DomainAutoMergingArgs'] auto_merging: Configuration information about the auto-merging process.
        :param pulumi.Input['DomainExportingConfigArgs'] exporting_config: The S3 location where Identity Resolution Jobs write result files.
        :param pulumi.Input['DomainJobScheduleArgs'] job_schedule: The day and time when do you want to start the Identity Resolution Job every week.
        """
        pulumi.set(__self__, "enabled", enabled)
        if auto_merging is not None:
            pulumi.set(__self__, "auto_merging", auto_merging)
        if exporting_config is not None:
            pulumi.set(__self__, "exporting_config", exporting_config)
        if job_schedule is not None:
            pulumi.set(__self__, "job_schedule", job_schedule)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        The flag that enables the matching process of duplicate profiles.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="autoMerging")
    def auto_merging(self) -> Optional[pulumi.Input['DomainAutoMergingArgs']]:
        """
        Configuration information about the auto-merging process.
        """
        return pulumi.get(self, "auto_merging")

    @auto_merging.setter
    def auto_merging(self, value: Optional[pulumi.Input['DomainAutoMergingArgs']]):
        pulumi.set(self, "auto_merging", value)

    @property
    @pulumi.getter(name="exportingConfig")
    def exporting_config(self) -> Optional[pulumi.Input['DomainExportingConfigArgs']]:
        """
        The S3 location where Identity Resolution Jobs write result files.
        """
        return pulumi.get(self, "exporting_config")

    @exporting_config.setter
    def exporting_config(self, value: Optional[pulumi.Input['DomainExportingConfigArgs']]):
        pulumi.set(self, "exporting_config", value)

    @property
    @pulumi.getter(name="jobSchedule")
    def job_schedule(self) -> Optional[pulumi.Input['DomainJobScheduleArgs']]:
        """
        The day and time when do you want to start the Identity Resolution Job every week.
        """
        return pulumi.get(self, "job_schedule")

    @job_schedule.setter
    def job_schedule(self, value: Optional[pulumi.Input['DomainJobScheduleArgs']]):
        pulumi.set(self, "job_schedule", value)


if not MYPY:
    class DomainRuleBasedMatchingArgsDict(TypedDict):
        """
        The process of matching duplicate profiles using the Rule-Based matching. If RuleBasedMatching = true, Amazon Connect Customer Profiles will start to match and merge your profiles according to your configuration in the RuleBasedMatchingRequest. You can use the ListRuleBasedMatches and GetSimilarProfiles API to return and review the results. Also, if you have configured ExportingConfig in the RuleBasedMatchingRequest, you can download the results from S3.
        """
        enabled: pulumi.Input[bool]
        """
        The flag that enables the rule-based matching process of duplicate profiles.
        """
        attribute_types_selector: NotRequired[pulumi.Input['DomainAttributeTypesSelectorArgsDict']]
        """
        Configures information about the `AttributeTypesSelector` where the rule-based identity resolution uses to match profiles.
        """
        conflict_resolution: NotRequired[pulumi.Input['DomainConflictResolutionArgsDict']]
        """
        Determines how the auto-merging process should resolve conflicts between different profiles. For example, if Profile A and Profile B have the same `FirstName` and `LastName` , `ConflictResolution` specifies which `EmailAddress` should be used.
        """
        exporting_config: NotRequired[pulumi.Input['DomainExportingConfigArgsDict']]
        """
        The S3 location where Identity Resolution Jobs write result files.
        """
        matching_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainMatchingRuleArgsDict']]]]
        """
        Configures how the rule-based matching process should match profiles. You can have up to 15 MatchingRule in the MatchingRules.
        """
        max_allowed_rule_level_for_matching: NotRequired[pulumi.Input[int]]
        """
        Indicates the maximum allowed rule level for matching.
        """
        max_allowed_rule_level_for_merging: NotRequired[pulumi.Input[int]]
        """
        Indicates the maximum allowed rule level for merging.
        """
        status: NotRequired[pulumi.Input['DomainRuleBasedMatchingStatus']]
        """
        The status of rule-based matching rule.
        """
elif False:
    DomainRuleBasedMatchingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainRuleBasedMatchingArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 attribute_types_selector: Optional[pulumi.Input['DomainAttributeTypesSelectorArgs']] = None,
                 conflict_resolution: Optional[pulumi.Input['DomainConflictResolutionArgs']] = None,
                 exporting_config: Optional[pulumi.Input['DomainExportingConfigArgs']] = None,
                 matching_rules: Optional[pulumi.Input[Sequence[pulumi.Input['DomainMatchingRuleArgs']]]] = None,
                 max_allowed_rule_level_for_matching: Optional[pulumi.Input[int]] = None,
                 max_allowed_rule_level_for_merging: Optional[pulumi.Input[int]] = None,
                 status: Optional[pulumi.Input['DomainRuleBasedMatchingStatus']] = None):
        """
        The process of matching duplicate profiles using the Rule-Based matching. If RuleBasedMatching = true, Amazon Connect Customer Profiles will start to match and merge your profiles according to your configuration in the RuleBasedMatchingRequest. You can use the ListRuleBasedMatches and GetSimilarProfiles API to return and review the results. Also, if you have configured ExportingConfig in the RuleBasedMatchingRequest, you can download the results from S3.
        :param pulumi.Input[bool] enabled: The flag that enables the rule-based matching process of duplicate profiles.
        :param pulumi.Input['DomainAttributeTypesSelectorArgs'] attribute_types_selector: Configures information about the `AttributeTypesSelector` where the rule-based identity resolution uses to match profiles.
        :param pulumi.Input['DomainConflictResolutionArgs'] conflict_resolution: Determines how the auto-merging process should resolve conflicts between different profiles. For example, if Profile A and Profile B have the same `FirstName` and `LastName` , `ConflictResolution` specifies which `EmailAddress` should be used.
        :param pulumi.Input['DomainExportingConfigArgs'] exporting_config: The S3 location where Identity Resolution Jobs write result files.
        :param pulumi.Input[Sequence[pulumi.Input['DomainMatchingRuleArgs']]] matching_rules: Configures how the rule-based matching process should match profiles. You can have up to 15 MatchingRule in the MatchingRules.
        :param pulumi.Input[int] max_allowed_rule_level_for_matching: Indicates the maximum allowed rule level for matching.
        :param pulumi.Input[int] max_allowed_rule_level_for_merging: Indicates the maximum allowed rule level for merging.
        :param pulumi.Input['DomainRuleBasedMatchingStatus'] status: The status of rule-based matching rule.
        """
        pulumi.set(__self__, "enabled", enabled)
        if attribute_types_selector is not None:
            pulumi.set(__self__, "attribute_types_selector", attribute_types_selector)
        if conflict_resolution is not None:
            pulumi.set(__self__, "conflict_resolution", conflict_resolution)
        if exporting_config is not None:
            pulumi.set(__self__, "exporting_config", exporting_config)
        if matching_rules is not None:
            pulumi.set(__self__, "matching_rules", matching_rules)
        if max_allowed_rule_level_for_matching is not None:
            pulumi.set(__self__, "max_allowed_rule_level_for_matching", max_allowed_rule_level_for_matching)
        if max_allowed_rule_level_for_merging is not None:
            pulumi.set(__self__, "max_allowed_rule_level_for_merging", max_allowed_rule_level_for_merging)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        The flag that enables the rule-based matching process of duplicate profiles.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="attributeTypesSelector")
    def attribute_types_selector(self) -> Optional[pulumi.Input['DomainAttributeTypesSelectorArgs']]:
        """
        Configures information about the `AttributeTypesSelector` where the rule-based identity resolution uses to match profiles.
        """
        return pulumi.get(self, "attribute_types_selector")

    @attribute_types_selector.setter
    def attribute_types_selector(self, value: Optional[pulumi.Input['DomainAttributeTypesSelectorArgs']]):
        pulumi.set(self, "attribute_types_selector", value)

    @property
    @pulumi.getter(name="conflictResolution")
    def conflict_resolution(self) -> Optional[pulumi.Input['DomainConflictResolutionArgs']]:
        """
        Determines how the auto-merging process should resolve conflicts between different profiles. For example, if Profile A and Profile B have the same `FirstName` and `LastName` , `ConflictResolution` specifies which `EmailAddress` should be used.
        """
        return pulumi.get(self, "conflict_resolution")

    @conflict_resolution.setter
    def conflict_resolution(self, value: Optional[pulumi.Input['DomainConflictResolutionArgs']]):
        pulumi.set(self, "conflict_resolution", value)

    @property
    @pulumi.getter(name="exportingConfig")
    def exporting_config(self) -> Optional[pulumi.Input['DomainExportingConfigArgs']]:
        """
        The S3 location where Identity Resolution Jobs write result files.
        """
        return pulumi.get(self, "exporting_config")

    @exporting_config.setter
    def exporting_config(self, value: Optional[pulumi.Input['DomainExportingConfigArgs']]):
        pulumi.set(self, "exporting_config", value)

    @property
    @pulumi.getter(name="matchingRules")
    def matching_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainMatchingRuleArgs']]]]:
        """
        Configures how the rule-based matching process should match profiles. You can have up to 15 MatchingRule in the MatchingRules.
        """
        return pulumi.get(self, "matching_rules")

    @matching_rules.setter
    def matching_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainMatchingRuleArgs']]]]):
        pulumi.set(self, "matching_rules", value)

    @property
    @pulumi.getter(name="maxAllowedRuleLevelForMatching")
    def max_allowed_rule_level_for_matching(self) -> Optional[pulumi.Input[int]]:
        """
        Indicates the maximum allowed rule level for matching.
        """
        return pulumi.get(self, "max_allowed_rule_level_for_matching")

    @max_allowed_rule_level_for_matching.setter
    def max_allowed_rule_level_for_matching(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_allowed_rule_level_for_matching", value)

    @property
    @pulumi.getter(name="maxAllowedRuleLevelForMerging")
    def max_allowed_rule_level_for_merging(self) -> Optional[pulumi.Input[int]]:
        """
        Indicates the maximum allowed rule level for merging.
        """
        return pulumi.get(self, "max_allowed_rule_level_for_merging")

    @max_allowed_rule_level_for_merging.setter
    def max_allowed_rule_level_for_merging(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_allowed_rule_level_for_merging", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input['DomainRuleBasedMatchingStatus']]:
        """
        The status of rule-based matching rule.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input['DomainRuleBasedMatchingStatus']]):
        pulumi.set(self, "status", value)


if not MYPY:
    class DomainS3ExportingConfigArgsDict(TypedDict):
        """
        The S3 location where Identity Resolution Jobs write result files.
        """
        s3_bucket_name: pulumi.Input[str]
        """
        The name of the S3 bucket where Identity Resolution Jobs write result files.
        """
        s3_key_name: NotRequired[pulumi.Input[str]]
        """
        The S3 key name of the location where Identity Resolution Jobs write result files.
        """
elif False:
    DomainS3ExportingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainS3ExportingConfigArgs:
    def __init__(__self__, *,
                 s3_bucket_name: pulumi.Input[str],
                 s3_key_name: Optional[pulumi.Input[str]] = None):
        """
        The S3 location where Identity Resolution Jobs write result files.
        :param pulumi.Input[str] s3_bucket_name: The name of the S3 bucket where Identity Resolution Jobs write result files.
        :param pulumi.Input[str] s3_key_name: The S3 key name of the location where Identity Resolution Jobs write result files.
        """
        pulumi.set(__self__, "s3_bucket_name", s3_bucket_name)
        if s3_key_name is not None:
            pulumi.set(__self__, "s3_key_name", s3_key_name)

    @property
    @pulumi.getter(name="s3BucketName")
    def s3_bucket_name(self) -> pulumi.Input[str]:
        """
        The name of the S3 bucket where Identity Resolution Jobs write result files.
        """
        return pulumi.get(self, "s3_bucket_name")

    @s3_bucket_name.setter
    def s3_bucket_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_bucket_name", value)

    @property
    @pulumi.getter(name="s3KeyName")
    def s3_key_name(self) -> Optional[pulumi.Input[str]]:
        """
        The S3 key name of the location where Identity Resolution Jobs write result files.
        """
        return pulumi.get(self, "s3_key_name")

    @s3_key_name.setter
    def s3_key_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_key_name", value)


if not MYPY:
    class IntegrationConnectorOperatorArgsDict(TypedDict):
        marketo: NotRequired[pulumi.Input['IntegrationMarketoConnectorOperator']]
        """
        The operation to be performed on the provided Marketo source fields.
        """
        s3: NotRequired[pulumi.Input['IntegrationS3ConnectorOperator']]
        """
        The operation to be performed on the provided Amazon S3 source fields.
        """
        salesforce: NotRequired[pulumi.Input['IntegrationSalesforceConnectorOperator']]
        """
        The operation to be performed on the provided Salesforce source fields.
        """
        service_now: NotRequired[pulumi.Input['IntegrationServiceNowConnectorOperator']]
        """
        The operation to be performed on the provided ServiceNow source fields.
        """
        zendesk: NotRequired[pulumi.Input['IntegrationZendeskConnectorOperator']]
        """
        The operation to be performed on the provided Zendesk source fields.
        """
elif False:
    IntegrationConnectorOperatorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationConnectorOperatorArgs:
    def __init__(__self__, *,
                 marketo: Optional[pulumi.Input['IntegrationMarketoConnectorOperator']] = None,
                 s3: Optional[pulumi.Input['IntegrationS3ConnectorOperator']] = None,
                 salesforce: Optional[pulumi.Input['IntegrationSalesforceConnectorOperator']] = None,
                 service_now: Optional[pulumi.Input['IntegrationServiceNowConnectorOperator']] = None,
                 zendesk: Optional[pulumi.Input['IntegrationZendeskConnectorOperator']] = None):
        """
        :param pulumi.Input['IntegrationMarketoConnectorOperator'] marketo: The operation to be performed on the provided Marketo source fields.
        :param pulumi.Input['IntegrationS3ConnectorOperator'] s3: The operation to be performed on the provided Amazon S3 source fields.
        :param pulumi.Input['IntegrationSalesforceConnectorOperator'] salesforce: The operation to be performed on the provided Salesforce source fields.
        :param pulumi.Input['IntegrationServiceNowConnectorOperator'] service_now: The operation to be performed on the provided ServiceNow source fields.
        :param pulumi.Input['IntegrationZendeskConnectorOperator'] zendesk: The operation to be performed on the provided Zendesk source fields.
        """
        if marketo is not None:
            pulumi.set(__self__, "marketo", marketo)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if salesforce is not None:
            pulumi.set(__self__, "salesforce", salesforce)
        if service_now is not None:
            pulumi.set(__self__, "service_now", service_now)
        if zendesk is not None:
            pulumi.set(__self__, "zendesk", zendesk)

    @property
    @pulumi.getter
    def marketo(self) -> Optional[pulumi.Input['IntegrationMarketoConnectorOperator']]:
        """
        The operation to be performed on the provided Marketo source fields.
        """
        return pulumi.get(self, "marketo")

    @marketo.setter
    def marketo(self, value: Optional[pulumi.Input['IntegrationMarketoConnectorOperator']]):
        pulumi.set(self, "marketo", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['IntegrationS3ConnectorOperator']]:
        """
        The operation to be performed on the provided Amazon S3 source fields.
        """
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['IntegrationS3ConnectorOperator']]):
        pulumi.set(self, "s3", value)

    @property
    @pulumi.getter
    def salesforce(self) -> Optional[pulumi.Input['IntegrationSalesforceConnectorOperator']]:
        """
        The operation to be performed on the provided Salesforce source fields.
        """
        return pulumi.get(self, "salesforce")

    @salesforce.setter
    def salesforce(self, value: Optional[pulumi.Input['IntegrationSalesforceConnectorOperator']]):
        pulumi.set(self, "salesforce", value)

    @property
    @pulumi.getter(name="serviceNow")
    def service_now(self) -> Optional[pulumi.Input['IntegrationServiceNowConnectorOperator']]:
        """
        The operation to be performed on the provided ServiceNow source fields.
        """
        return pulumi.get(self, "service_now")

    @service_now.setter
    def service_now(self, value: Optional[pulumi.Input['IntegrationServiceNowConnectorOperator']]):
        pulumi.set(self, "service_now", value)

    @property
    @pulumi.getter
    def zendesk(self) -> Optional[pulumi.Input['IntegrationZendeskConnectorOperator']]:
        """
        The operation to be performed on the provided Zendesk source fields.
        """
        return pulumi.get(self, "zendesk")

    @zendesk.setter
    def zendesk(self, value: Optional[pulumi.Input['IntegrationZendeskConnectorOperator']]):
        pulumi.set(self, "zendesk", value)


if not MYPY:
    class IntegrationFlowDefinitionArgsDict(TypedDict):
        flow_name: pulumi.Input[str]
        """
        The specified name of the flow. Use underscores (_) or hyphens (-) only. Spaces are not allowed.
        """
        kms_arn: pulumi.Input[str]
        """
        The Amazon Resource Name (ARN) of the AWS Key Management Service (KMS) key you provide for encryption.
        """
        source_flow_config: pulumi.Input['IntegrationSourceFlowConfigArgsDict']
        """
        The configuration that controls how Customer Profiles retrieves data from the source.
        """
        tasks: pulumi.Input[Sequence[pulumi.Input['IntegrationTaskArgsDict']]]
        """
        A list of tasks that Customer Profiles performs while transferring the data in the flow run.
        """
        trigger_config: pulumi.Input['IntegrationTriggerConfigArgsDict']
        """
        The trigger settings that determine how and when the flow runs.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        A description of the flow you want to create.
        """
elif False:
    IntegrationFlowDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationFlowDefinitionArgs:
    def __init__(__self__, *,
                 flow_name: pulumi.Input[str],
                 kms_arn: pulumi.Input[str],
                 source_flow_config: pulumi.Input['IntegrationSourceFlowConfigArgs'],
                 tasks: pulumi.Input[Sequence[pulumi.Input['IntegrationTaskArgs']]],
                 trigger_config: pulumi.Input['IntegrationTriggerConfigArgs'],
                 description: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] flow_name: The specified name of the flow. Use underscores (_) or hyphens (-) only. Spaces are not allowed.
        :param pulumi.Input[str] kms_arn: The Amazon Resource Name (ARN) of the AWS Key Management Service (KMS) key you provide for encryption.
        :param pulumi.Input['IntegrationSourceFlowConfigArgs'] source_flow_config: The configuration that controls how Customer Profiles retrieves data from the source.
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationTaskArgs']]] tasks: A list of tasks that Customer Profiles performs while transferring the data in the flow run.
        :param pulumi.Input['IntegrationTriggerConfigArgs'] trigger_config: The trigger settings that determine how and when the flow runs.
        :param pulumi.Input[str] description: A description of the flow you want to create.
        """
        pulumi.set(__self__, "flow_name", flow_name)
        pulumi.set(__self__, "kms_arn", kms_arn)
        pulumi.set(__self__, "source_flow_config", source_flow_config)
        pulumi.set(__self__, "tasks", tasks)
        pulumi.set(__self__, "trigger_config", trigger_config)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter(name="flowName")
    def flow_name(self) -> pulumi.Input[str]:
        """
        The specified name of the flow. Use underscores (_) or hyphens (-) only. Spaces are not allowed.
        """
        return pulumi.get(self, "flow_name")

    @flow_name.setter
    def flow_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "flow_name", value)

    @property
    @pulumi.getter(name="kmsArn")
    def kms_arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the AWS Key Management Service (KMS) key you provide for encryption.
        """
        return pulumi.get(self, "kms_arn")

    @kms_arn.setter
    def kms_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "kms_arn", value)

    @property
    @pulumi.getter(name="sourceFlowConfig")
    def source_flow_config(self) -> pulumi.Input['IntegrationSourceFlowConfigArgs']:
        """
        The configuration that controls how Customer Profiles retrieves data from the source.
        """
        return pulumi.get(self, "source_flow_config")

    @source_flow_config.setter
    def source_flow_config(self, value: pulumi.Input['IntegrationSourceFlowConfigArgs']):
        pulumi.set(self, "source_flow_config", value)

    @property
    @pulumi.getter
    def tasks(self) -> pulumi.Input[Sequence[pulumi.Input['IntegrationTaskArgs']]]:
        """
        A list of tasks that Customer Profiles performs while transferring the data in the flow run.
        """
        return pulumi.get(self, "tasks")

    @tasks.setter
    def tasks(self, value: pulumi.Input[Sequence[pulumi.Input['IntegrationTaskArgs']]]):
        pulumi.set(self, "tasks", value)

    @property
    @pulumi.getter(name="triggerConfig")
    def trigger_config(self) -> pulumi.Input['IntegrationTriggerConfigArgs']:
        """
        The trigger settings that determine how and when the flow runs.
        """
        return pulumi.get(self, "trigger_config")

    @trigger_config.setter
    def trigger_config(self, value: pulumi.Input['IntegrationTriggerConfigArgs']):
        pulumi.set(self, "trigger_config", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A description of the flow you want to create.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class IntegrationIncrementalPullConfigArgsDict(TypedDict):
        datetime_type_field_name: NotRequired[pulumi.Input[str]]
        """
        A field that specifies the date time or timestamp field as the criteria to use when importing incremental records from the source.
        """
elif False:
    IntegrationIncrementalPullConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationIncrementalPullConfigArgs:
    def __init__(__self__, *,
                 datetime_type_field_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] datetime_type_field_name: A field that specifies the date time or timestamp field as the criteria to use when importing incremental records from the source.
        """
        if datetime_type_field_name is not None:
            pulumi.set(__self__, "datetime_type_field_name", datetime_type_field_name)

    @property
    @pulumi.getter(name="datetimeTypeFieldName")
    def datetime_type_field_name(self) -> Optional[pulumi.Input[str]]:
        """
        A field that specifies the date time or timestamp field as the criteria to use when importing incremental records from the source.
        """
        return pulumi.get(self, "datetime_type_field_name")

    @datetime_type_field_name.setter
    def datetime_type_field_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datetime_type_field_name", value)


if not MYPY:
    class IntegrationMarketoSourcePropertiesArgsDict(TypedDict):
        object: pulumi.Input[str]
        """
        The object specified in the Marketo flow source.
        """
elif False:
    IntegrationMarketoSourcePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationMarketoSourcePropertiesArgs:
    def __init__(__self__, *,
                 object: pulumi.Input[str]):
        """
        :param pulumi.Input[str] object: The object specified in the Marketo flow source.
        """
        pulumi.set(__self__, "object", object)

    @property
    @pulumi.getter
    def object(self) -> pulumi.Input[str]:
        """
        The object specified in the Marketo flow source.
        """
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: pulumi.Input[str]):
        pulumi.set(self, "object", value)


if not MYPY:
    class IntegrationObjectTypeMappingArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        The key.
        """
        value: pulumi.Input[str]
        """
        The value.
        """
elif False:
    IntegrationObjectTypeMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationObjectTypeMappingArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: The key.
        :param pulumi.Input[str] value: The value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class IntegrationS3SourcePropertiesArgsDict(TypedDict):
        bucket_name: pulumi.Input[str]
        """
        The Amazon S3 bucket name where the source files are stored.
        """
        bucket_prefix: NotRequired[pulumi.Input[str]]
        """
        The object key for the Amazon S3 bucket in which the source files are stored.
        """
elif False:
    IntegrationS3SourcePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationS3SourcePropertiesArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[str],
                 bucket_prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bucket_name: The Amazon S3 bucket name where the source files are stored.
        :param pulumi.Input[str] bucket_prefix: The object key for the Amazon S3 bucket in which the source files are stored.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        if bucket_prefix is not None:
            pulumi.set(__self__, "bucket_prefix", bucket_prefix)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[str]:
        """
        The Amazon S3 bucket name where the source files are stored.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The object key for the Amazon S3 bucket in which the source files are stored.
        """
        return pulumi.get(self, "bucket_prefix")

    @bucket_prefix.setter
    def bucket_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket_prefix", value)


if not MYPY:
    class IntegrationSalesforceSourcePropertiesArgsDict(TypedDict):
        object: pulumi.Input[str]
        """
        The object specified in the Salesforce flow source.
        """
        enable_dynamic_field_update: NotRequired[pulumi.Input[bool]]
        """
        The flag that enables dynamic fetching of new (recently added) fields in the Salesforce objects while running a flow.
        """
        include_deleted_records: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether Amazon AppFlow includes deleted files in the flow run.
        """
elif False:
    IntegrationSalesforceSourcePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationSalesforceSourcePropertiesArgs:
    def __init__(__self__, *,
                 object: pulumi.Input[str],
                 enable_dynamic_field_update: Optional[pulumi.Input[bool]] = None,
                 include_deleted_records: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] object: The object specified in the Salesforce flow source.
        :param pulumi.Input[bool] enable_dynamic_field_update: The flag that enables dynamic fetching of new (recently added) fields in the Salesforce objects while running a flow.
        :param pulumi.Input[bool] include_deleted_records: Indicates whether Amazon AppFlow includes deleted files in the flow run.
        """
        pulumi.set(__self__, "object", object)
        if enable_dynamic_field_update is not None:
            pulumi.set(__self__, "enable_dynamic_field_update", enable_dynamic_field_update)
        if include_deleted_records is not None:
            pulumi.set(__self__, "include_deleted_records", include_deleted_records)

    @property
    @pulumi.getter
    def object(self) -> pulumi.Input[str]:
        """
        The object specified in the Salesforce flow source.
        """
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: pulumi.Input[str]):
        pulumi.set(self, "object", value)

    @property
    @pulumi.getter(name="enableDynamicFieldUpdate")
    def enable_dynamic_field_update(self) -> Optional[pulumi.Input[bool]]:
        """
        The flag that enables dynamic fetching of new (recently added) fields in the Salesforce objects while running a flow.
        """
        return pulumi.get(self, "enable_dynamic_field_update")

    @enable_dynamic_field_update.setter
    def enable_dynamic_field_update(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_dynamic_field_update", value)

    @property
    @pulumi.getter(name="includeDeletedRecords")
    def include_deleted_records(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether Amazon AppFlow includes deleted files in the flow run.
        """
        return pulumi.get(self, "include_deleted_records")

    @include_deleted_records.setter
    def include_deleted_records(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_deleted_records", value)


if not MYPY:
    class IntegrationScheduledTriggerPropertiesArgsDict(TypedDict):
        schedule_expression: pulumi.Input[str]
        """
        The scheduling expression that determines the rate at which the schedule will run, for example rate (5 minutes).
        """
        data_pull_mode: NotRequired[pulumi.Input['IntegrationScheduledTriggerPropertiesDataPullMode']]
        """
        Specifies whether a scheduled flow has an incremental data transfer or a complete data transfer for each flow run.
        """
        first_execution_from: NotRequired[pulumi.Input[float]]
        """
        Specifies the date range for the records to import from the connector in the first flow run.
        """
        schedule_end_time: NotRequired[pulumi.Input[float]]
        """
        Specifies the scheduled end time for a scheduled-trigger flow.
        """
        schedule_offset: NotRequired[pulumi.Input[int]]
        """
        Specifies the optional offset that is added to the time interval for a schedule-triggered flow.
        """
        schedule_start_time: NotRequired[pulumi.Input[float]]
        """
        Specifies the scheduled start time for a scheduled-trigger flow.
        """
        timezone: NotRequired[pulumi.Input[str]]
        """
        Specifies the time zone used when referring to the date and time of a scheduled-triggered flow, such as America/New_York.
        """
elif False:
    IntegrationScheduledTriggerPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationScheduledTriggerPropertiesArgs:
    def __init__(__self__, *,
                 schedule_expression: pulumi.Input[str],
                 data_pull_mode: Optional[pulumi.Input['IntegrationScheduledTriggerPropertiesDataPullMode']] = None,
                 first_execution_from: Optional[pulumi.Input[float]] = None,
                 schedule_end_time: Optional[pulumi.Input[float]] = None,
                 schedule_offset: Optional[pulumi.Input[int]] = None,
                 schedule_start_time: Optional[pulumi.Input[float]] = None,
                 timezone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] schedule_expression: The scheduling expression that determines the rate at which the schedule will run, for example rate (5 minutes).
        :param pulumi.Input['IntegrationScheduledTriggerPropertiesDataPullMode'] data_pull_mode: Specifies whether a scheduled flow has an incremental data transfer or a complete data transfer for each flow run.
        :param pulumi.Input[float] first_execution_from: Specifies the date range for the records to import from the connector in the first flow run.
        :param pulumi.Input[float] schedule_end_time: Specifies the scheduled end time for a scheduled-trigger flow.
        :param pulumi.Input[int] schedule_offset: Specifies the optional offset that is added to the time interval for a schedule-triggered flow.
        :param pulumi.Input[float] schedule_start_time: Specifies the scheduled start time for a scheduled-trigger flow.
        :param pulumi.Input[str] timezone: Specifies the time zone used when referring to the date and time of a scheduled-triggered flow, such as America/New_York.
        """
        pulumi.set(__self__, "schedule_expression", schedule_expression)
        if data_pull_mode is not None:
            pulumi.set(__self__, "data_pull_mode", data_pull_mode)
        if first_execution_from is not None:
            pulumi.set(__self__, "first_execution_from", first_execution_from)
        if schedule_end_time is not None:
            pulumi.set(__self__, "schedule_end_time", schedule_end_time)
        if schedule_offset is not None:
            pulumi.set(__self__, "schedule_offset", schedule_offset)
        if schedule_start_time is not None:
            pulumi.set(__self__, "schedule_start_time", schedule_start_time)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)

    @property
    @pulumi.getter(name="scheduleExpression")
    def schedule_expression(self) -> pulumi.Input[str]:
        """
        The scheduling expression that determines the rate at which the schedule will run, for example rate (5 minutes).
        """
        return pulumi.get(self, "schedule_expression")

    @schedule_expression.setter
    def schedule_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "schedule_expression", value)

    @property
    @pulumi.getter(name="dataPullMode")
    def data_pull_mode(self) -> Optional[pulumi.Input['IntegrationScheduledTriggerPropertiesDataPullMode']]:
        """
        Specifies whether a scheduled flow has an incremental data transfer or a complete data transfer for each flow run.
        """
        return pulumi.get(self, "data_pull_mode")

    @data_pull_mode.setter
    def data_pull_mode(self, value: Optional[pulumi.Input['IntegrationScheduledTriggerPropertiesDataPullMode']]):
        pulumi.set(self, "data_pull_mode", value)

    @property
    @pulumi.getter(name="firstExecutionFrom")
    def first_execution_from(self) -> Optional[pulumi.Input[float]]:
        """
        Specifies the date range for the records to import from the connector in the first flow run.
        """
        return pulumi.get(self, "first_execution_from")

    @first_execution_from.setter
    def first_execution_from(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "first_execution_from", value)

    @property
    @pulumi.getter(name="scheduleEndTime")
    def schedule_end_time(self) -> Optional[pulumi.Input[float]]:
        """
        Specifies the scheduled end time for a scheduled-trigger flow.
        """
        return pulumi.get(self, "schedule_end_time")

    @schedule_end_time.setter
    def schedule_end_time(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "schedule_end_time", value)

    @property
    @pulumi.getter(name="scheduleOffset")
    def schedule_offset(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the optional offset that is added to the time interval for a schedule-triggered flow.
        """
        return pulumi.get(self, "schedule_offset")

    @schedule_offset.setter
    def schedule_offset(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "schedule_offset", value)

    @property
    @pulumi.getter(name="scheduleStartTime")
    def schedule_start_time(self) -> Optional[pulumi.Input[float]]:
        """
        Specifies the scheduled start time for a scheduled-trigger flow.
        """
        return pulumi.get(self, "schedule_start_time")

    @schedule_start_time.setter
    def schedule_start_time(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "schedule_start_time", value)

    @property
    @pulumi.getter
    def timezone(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the time zone used when referring to the date and time of a scheduled-triggered flow, such as America/New_York.
        """
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timezone", value)


if not MYPY:
    class IntegrationServiceNowSourcePropertiesArgsDict(TypedDict):
        object: pulumi.Input[str]
        """
        The object specified in the ServiceNow flow source.
        """
elif False:
    IntegrationServiceNowSourcePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationServiceNowSourcePropertiesArgs:
    def __init__(__self__, *,
                 object: pulumi.Input[str]):
        """
        :param pulumi.Input[str] object: The object specified in the ServiceNow flow source.
        """
        pulumi.set(__self__, "object", object)

    @property
    @pulumi.getter
    def object(self) -> pulumi.Input[str]:
        """
        The object specified in the ServiceNow flow source.
        """
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: pulumi.Input[str]):
        pulumi.set(self, "object", value)


if not MYPY:
    class IntegrationSourceConnectorPropertiesArgsDict(TypedDict):
        marketo: NotRequired[pulumi.Input['IntegrationMarketoSourcePropertiesArgsDict']]
        """
        The properties that are applied when Marketo is being used as a source.
        """
        s3: NotRequired[pulumi.Input['IntegrationS3SourcePropertiesArgsDict']]
        """
        The properties that are applied when Amazon S3 is being used as the flow source.
        """
        salesforce: NotRequired[pulumi.Input['IntegrationSalesforceSourcePropertiesArgsDict']]
        """
        The properties that are applied when Salesforce is being used as a source.
        """
        service_now: NotRequired[pulumi.Input['IntegrationServiceNowSourcePropertiesArgsDict']]
        """
        The properties that are applied when ServiceNow is being used as a source.
        """
        zendesk: NotRequired[pulumi.Input['IntegrationZendeskSourcePropertiesArgsDict']]
        """
        The properties that are applied when using Zendesk as a flow source.
        """
elif False:
    IntegrationSourceConnectorPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationSourceConnectorPropertiesArgs:
    def __init__(__self__, *,
                 marketo: Optional[pulumi.Input['IntegrationMarketoSourcePropertiesArgs']] = None,
                 s3: Optional[pulumi.Input['IntegrationS3SourcePropertiesArgs']] = None,
                 salesforce: Optional[pulumi.Input['IntegrationSalesforceSourcePropertiesArgs']] = None,
                 service_now: Optional[pulumi.Input['IntegrationServiceNowSourcePropertiesArgs']] = None,
                 zendesk: Optional[pulumi.Input['IntegrationZendeskSourcePropertiesArgs']] = None):
        """
        :param pulumi.Input['IntegrationMarketoSourcePropertiesArgs'] marketo: The properties that are applied when Marketo is being used as a source.
        :param pulumi.Input['IntegrationS3SourcePropertiesArgs'] s3: The properties that are applied when Amazon S3 is being used as the flow source.
        :param pulumi.Input['IntegrationSalesforceSourcePropertiesArgs'] salesforce: The properties that are applied when Salesforce is being used as a source.
        :param pulumi.Input['IntegrationServiceNowSourcePropertiesArgs'] service_now: The properties that are applied when ServiceNow is being used as a source.
        :param pulumi.Input['IntegrationZendeskSourcePropertiesArgs'] zendesk: The properties that are applied when using Zendesk as a flow source.
        """
        if marketo is not None:
            pulumi.set(__self__, "marketo", marketo)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if salesforce is not None:
            pulumi.set(__self__, "salesforce", salesforce)
        if service_now is not None:
            pulumi.set(__self__, "service_now", service_now)
        if zendesk is not None:
            pulumi.set(__self__, "zendesk", zendesk)

    @property
    @pulumi.getter
    def marketo(self) -> Optional[pulumi.Input['IntegrationMarketoSourcePropertiesArgs']]:
        """
        The properties that are applied when Marketo is being used as a source.
        """
        return pulumi.get(self, "marketo")

    @marketo.setter
    def marketo(self, value: Optional[pulumi.Input['IntegrationMarketoSourcePropertiesArgs']]):
        pulumi.set(self, "marketo", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['IntegrationS3SourcePropertiesArgs']]:
        """
        The properties that are applied when Amazon S3 is being used as the flow source.
        """
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['IntegrationS3SourcePropertiesArgs']]):
        pulumi.set(self, "s3", value)

    @property
    @pulumi.getter
    def salesforce(self) -> Optional[pulumi.Input['IntegrationSalesforceSourcePropertiesArgs']]:
        """
        The properties that are applied when Salesforce is being used as a source.
        """
        return pulumi.get(self, "salesforce")

    @salesforce.setter
    def salesforce(self, value: Optional[pulumi.Input['IntegrationSalesforceSourcePropertiesArgs']]):
        pulumi.set(self, "salesforce", value)

    @property
    @pulumi.getter(name="serviceNow")
    def service_now(self) -> Optional[pulumi.Input['IntegrationServiceNowSourcePropertiesArgs']]:
        """
        The properties that are applied when ServiceNow is being used as a source.
        """
        return pulumi.get(self, "service_now")

    @service_now.setter
    def service_now(self, value: Optional[pulumi.Input['IntegrationServiceNowSourcePropertiesArgs']]):
        pulumi.set(self, "service_now", value)

    @property
    @pulumi.getter
    def zendesk(self) -> Optional[pulumi.Input['IntegrationZendeskSourcePropertiesArgs']]:
        """
        The properties that are applied when using Zendesk as a flow source.
        """
        return pulumi.get(self, "zendesk")

    @zendesk.setter
    def zendesk(self, value: Optional[pulumi.Input['IntegrationZendeskSourcePropertiesArgs']]):
        pulumi.set(self, "zendesk", value)


if not MYPY:
    class IntegrationSourceFlowConfigArgsDict(TypedDict):
        connector_type: pulumi.Input['IntegrationConnectorType']
        """
        The type of connector, such as Salesforce, Marketo, and so on.
        """
        source_connector_properties: pulumi.Input['IntegrationSourceConnectorPropertiesArgsDict']
        """
        Specifies the information that is required to query a particular source connector.
        """
        connector_profile_name: NotRequired[pulumi.Input[str]]
        """
        The name of the Amazon AppFlow connector profile. This name must be unique for each connector profile in the AWS account .
        """
        incremental_pull_config: NotRequired[pulumi.Input['IntegrationIncrementalPullConfigArgsDict']]
        """
        Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided, the fields specified in the configuration are used when querying for the incremental data pull.
        """
elif False:
    IntegrationSourceFlowConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationSourceFlowConfigArgs:
    def __init__(__self__, *,
                 connector_type: pulumi.Input['IntegrationConnectorType'],
                 source_connector_properties: pulumi.Input['IntegrationSourceConnectorPropertiesArgs'],
                 connector_profile_name: Optional[pulumi.Input[str]] = None,
                 incremental_pull_config: Optional[pulumi.Input['IntegrationIncrementalPullConfigArgs']] = None):
        """
        :param pulumi.Input['IntegrationConnectorType'] connector_type: The type of connector, such as Salesforce, Marketo, and so on.
        :param pulumi.Input['IntegrationSourceConnectorPropertiesArgs'] source_connector_properties: Specifies the information that is required to query a particular source connector.
        :param pulumi.Input[str] connector_profile_name: The name of the Amazon AppFlow connector profile. This name must be unique for each connector profile in the AWS account .
        :param pulumi.Input['IntegrationIncrementalPullConfigArgs'] incremental_pull_config: Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided, the fields specified in the configuration are used when querying for the incremental data pull.
        """
        pulumi.set(__self__, "connector_type", connector_type)
        pulumi.set(__self__, "source_connector_properties", source_connector_properties)
        if connector_profile_name is not None:
            pulumi.set(__self__, "connector_profile_name", connector_profile_name)
        if incremental_pull_config is not None:
            pulumi.set(__self__, "incremental_pull_config", incremental_pull_config)

    @property
    @pulumi.getter(name="connectorType")
    def connector_type(self) -> pulumi.Input['IntegrationConnectorType']:
        """
        The type of connector, such as Salesforce, Marketo, and so on.
        """
        return pulumi.get(self, "connector_type")

    @connector_type.setter
    def connector_type(self, value: pulumi.Input['IntegrationConnectorType']):
        pulumi.set(self, "connector_type", value)

    @property
    @pulumi.getter(name="sourceConnectorProperties")
    def source_connector_properties(self) -> pulumi.Input['IntegrationSourceConnectorPropertiesArgs']:
        """
        Specifies the information that is required to query a particular source connector.
        """
        return pulumi.get(self, "source_connector_properties")

    @source_connector_properties.setter
    def source_connector_properties(self, value: pulumi.Input['IntegrationSourceConnectorPropertiesArgs']):
        pulumi.set(self, "source_connector_properties", value)

    @property
    @pulumi.getter(name="connectorProfileName")
    def connector_profile_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the Amazon AppFlow connector profile. This name must be unique for each connector profile in the AWS account .
        """
        return pulumi.get(self, "connector_profile_name")

    @connector_profile_name.setter
    def connector_profile_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connector_profile_name", value)

    @property
    @pulumi.getter(name="incrementalPullConfig")
    def incremental_pull_config(self) -> Optional[pulumi.Input['IntegrationIncrementalPullConfigArgs']]:
        """
        Defines the configuration for a scheduled incremental data pull. If a valid configuration is provided, the fields specified in the configuration are used when querying for the incremental data pull.
        """
        return pulumi.get(self, "incremental_pull_config")

    @incremental_pull_config.setter
    def incremental_pull_config(self, value: Optional[pulumi.Input['IntegrationIncrementalPullConfigArgs']]):
        pulumi.set(self, "incremental_pull_config", value)


if not MYPY:
    class IntegrationTaskPropertiesMapArgsDict(TypedDict):
        operator_property_key: pulumi.Input['IntegrationOperatorPropertiesKeys']
        """
        The task property key.
        """
        property: pulumi.Input[str]
        """
        The task property value.
        """
elif False:
    IntegrationTaskPropertiesMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationTaskPropertiesMapArgs:
    def __init__(__self__, *,
                 operator_property_key: pulumi.Input['IntegrationOperatorPropertiesKeys'],
                 property: pulumi.Input[str]):
        """
        :param pulumi.Input['IntegrationOperatorPropertiesKeys'] operator_property_key: The task property key.
        :param pulumi.Input[str] property: The task property value.
        """
        pulumi.set(__self__, "operator_property_key", operator_property_key)
        pulumi.set(__self__, "property", property)

    @property
    @pulumi.getter(name="operatorPropertyKey")
    def operator_property_key(self) -> pulumi.Input['IntegrationOperatorPropertiesKeys']:
        """
        The task property key.
        """
        return pulumi.get(self, "operator_property_key")

    @operator_property_key.setter
    def operator_property_key(self, value: pulumi.Input['IntegrationOperatorPropertiesKeys']):
        pulumi.set(self, "operator_property_key", value)

    @property
    @pulumi.getter
    def property(self) -> pulumi.Input[str]:
        """
        The task property value.
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: pulumi.Input[str]):
        pulumi.set(self, "property", value)


if not MYPY:
    class IntegrationTaskArgsDict(TypedDict):
        source_fields: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The source fields to which a particular task is applied.
        """
        task_type: pulumi.Input['IntegrationTaskType']
        """
        Specifies the particular task implementation that Amazon AppFlow performs.
        """
        connector_operator: NotRequired[pulumi.Input['IntegrationConnectorOperatorArgsDict']]
        """
        The operation to be performed on the provided source fields.
        """
        destination_field: NotRequired[pulumi.Input[str]]
        """
        A field in a destination connector, or a field value against which Amazon AppFlow validates a source field.
        """
        task_properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['IntegrationTaskPropertiesMapArgsDict']]]]
        """
        A map used to store task-related information. The service looks for particular information based on the TaskType.
        """
elif False:
    IntegrationTaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationTaskArgs:
    def __init__(__self__, *,
                 source_fields: pulumi.Input[Sequence[pulumi.Input[str]]],
                 task_type: pulumi.Input['IntegrationTaskType'],
                 connector_operator: Optional[pulumi.Input['IntegrationConnectorOperatorArgs']] = None,
                 destination_field: Optional[pulumi.Input[str]] = None,
                 task_properties: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationTaskPropertiesMapArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] source_fields: The source fields to which a particular task is applied.
        :param pulumi.Input['IntegrationTaskType'] task_type: Specifies the particular task implementation that Amazon AppFlow performs.
        :param pulumi.Input['IntegrationConnectorOperatorArgs'] connector_operator: The operation to be performed on the provided source fields.
        :param pulumi.Input[str] destination_field: A field in a destination connector, or a field value against which Amazon AppFlow validates a source field.
        :param pulumi.Input[Sequence[pulumi.Input['IntegrationTaskPropertiesMapArgs']]] task_properties: A map used to store task-related information. The service looks for particular information based on the TaskType.
        """
        pulumi.set(__self__, "source_fields", source_fields)
        pulumi.set(__self__, "task_type", task_type)
        if connector_operator is not None:
            pulumi.set(__self__, "connector_operator", connector_operator)
        if destination_field is not None:
            pulumi.set(__self__, "destination_field", destination_field)
        if task_properties is not None:
            pulumi.set(__self__, "task_properties", task_properties)

    @property
    @pulumi.getter(name="sourceFields")
    def source_fields(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The source fields to which a particular task is applied.
        """
        return pulumi.get(self, "source_fields")

    @source_fields.setter
    def source_fields(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "source_fields", value)

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> pulumi.Input['IntegrationTaskType']:
        """
        Specifies the particular task implementation that Amazon AppFlow performs.
        """
        return pulumi.get(self, "task_type")

    @task_type.setter
    def task_type(self, value: pulumi.Input['IntegrationTaskType']):
        pulumi.set(self, "task_type", value)

    @property
    @pulumi.getter(name="connectorOperator")
    def connector_operator(self) -> Optional[pulumi.Input['IntegrationConnectorOperatorArgs']]:
        """
        The operation to be performed on the provided source fields.
        """
        return pulumi.get(self, "connector_operator")

    @connector_operator.setter
    def connector_operator(self, value: Optional[pulumi.Input['IntegrationConnectorOperatorArgs']]):
        pulumi.set(self, "connector_operator", value)

    @property
    @pulumi.getter(name="destinationField")
    def destination_field(self) -> Optional[pulumi.Input[str]]:
        """
        A field in a destination connector, or a field value against which Amazon AppFlow validates a source field.
        """
        return pulumi.get(self, "destination_field")

    @destination_field.setter
    def destination_field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_field", value)

    @property
    @pulumi.getter(name="taskProperties")
    def task_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationTaskPropertiesMapArgs']]]]:
        """
        A map used to store task-related information. The service looks for particular information based on the TaskType.
        """
        return pulumi.get(self, "task_properties")

    @task_properties.setter
    def task_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationTaskPropertiesMapArgs']]]]):
        pulumi.set(self, "task_properties", value)


if not MYPY:
    class IntegrationTriggerConfigArgsDict(TypedDict):
        trigger_type: pulumi.Input['IntegrationTriggerType']
        """
        Specifies the type of flow trigger. It can be OnDemand, Scheduled, or Event.
        """
        trigger_properties: NotRequired[pulumi.Input['IntegrationTriggerPropertiesArgsDict']]
        """
        Specifies the configuration details of a schedule-triggered flow that you define. Currently, these settings only apply to the Scheduled trigger type.
        """
elif False:
    IntegrationTriggerConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationTriggerConfigArgs:
    def __init__(__self__, *,
                 trigger_type: pulumi.Input['IntegrationTriggerType'],
                 trigger_properties: Optional[pulumi.Input['IntegrationTriggerPropertiesArgs']] = None):
        """
        :param pulumi.Input['IntegrationTriggerType'] trigger_type: Specifies the type of flow trigger. It can be OnDemand, Scheduled, or Event.
        :param pulumi.Input['IntegrationTriggerPropertiesArgs'] trigger_properties: Specifies the configuration details of a schedule-triggered flow that you define. Currently, these settings only apply to the Scheduled trigger type.
        """
        pulumi.set(__self__, "trigger_type", trigger_type)
        if trigger_properties is not None:
            pulumi.set(__self__, "trigger_properties", trigger_properties)

    @property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> pulumi.Input['IntegrationTriggerType']:
        """
        Specifies the type of flow trigger. It can be OnDemand, Scheduled, or Event.
        """
        return pulumi.get(self, "trigger_type")

    @trigger_type.setter
    def trigger_type(self, value: pulumi.Input['IntegrationTriggerType']):
        pulumi.set(self, "trigger_type", value)

    @property
    @pulumi.getter(name="triggerProperties")
    def trigger_properties(self) -> Optional[pulumi.Input['IntegrationTriggerPropertiesArgs']]:
        """
        Specifies the configuration details of a schedule-triggered flow that you define. Currently, these settings only apply to the Scheduled trigger type.
        """
        return pulumi.get(self, "trigger_properties")

    @trigger_properties.setter
    def trigger_properties(self, value: Optional[pulumi.Input['IntegrationTriggerPropertiesArgs']]):
        pulumi.set(self, "trigger_properties", value)


if not MYPY:
    class IntegrationTriggerPropertiesArgsDict(TypedDict):
        scheduled: NotRequired[pulumi.Input['IntegrationScheduledTriggerPropertiesArgsDict']]
        """
        Specifies the configuration details of a schedule-triggered flow that you define.
        """
elif False:
    IntegrationTriggerPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationTriggerPropertiesArgs:
    def __init__(__self__, *,
                 scheduled: Optional[pulumi.Input['IntegrationScheduledTriggerPropertiesArgs']] = None):
        """
        :param pulumi.Input['IntegrationScheduledTriggerPropertiesArgs'] scheduled: Specifies the configuration details of a schedule-triggered flow that you define.
        """
        if scheduled is not None:
            pulumi.set(__self__, "scheduled", scheduled)

    @property
    @pulumi.getter
    def scheduled(self) -> Optional[pulumi.Input['IntegrationScheduledTriggerPropertiesArgs']]:
        """
        Specifies the configuration details of a schedule-triggered flow that you define.
        """
        return pulumi.get(self, "scheduled")

    @scheduled.setter
    def scheduled(self, value: Optional[pulumi.Input['IntegrationScheduledTriggerPropertiesArgs']]):
        pulumi.set(self, "scheduled", value)


if not MYPY:
    class IntegrationZendeskSourcePropertiesArgsDict(TypedDict):
        object: pulumi.Input[str]
        """
        The object specified in the Zendesk flow source.
        """
elif False:
    IntegrationZendeskSourcePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationZendeskSourcePropertiesArgs:
    def __init__(__self__, *,
                 object: pulumi.Input[str]):
        """
        :param pulumi.Input[str] object: The object specified in the Zendesk flow source.
        """
        pulumi.set(__self__, "object", object)

    @property
    @pulumi.getter
    def object(self) -> pulumi.Input[str]:
        """
        The object specified in the Zendesk flow source.
        """
        return pulumi.get(self, "object")

    @object.setter
    def object(self, value: pulumi.Input[str]):
        pulumi.set(self, "object", value)


if not MYPY:
    class ObjectTypeFieldMapArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the field.
        """
        object_type_field: NotRequired[pulumi.Input['ObjectTypeFieldArgsDict']]
        """
        Represents a field in a ProfileObjectType.
        """
elif False:
    ObjectTypeFieldMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObjectTypeFieldMapArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 object_type_field: Optional[pulumi.Input['ObjectTypeFieldArgs']] = None):
        """
        :param pulumi.Input[str] name: Name of the field.
        :param pulumi.Input['ObjectTypeFieldArgs'] object_type_field: Represents a field in a ProfileObjectType.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if object_type_field is not None:
            pulumi.set(__self__, "object_type_field", object_type_field)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the field.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="objectTypeField")
    def object_type_field(self) -> Optional[pulumi.Input['ObjectTypeFieldArgs']]:
        """
        Represents a field in a ProfileObjectType.
        """
        return pulumi.get(self, "object_type_field")

    @object_type_field.setter
    def object_type_field(self, value: Optional[pulumi.Input['ObjectTypeFieldArgs']]):
        pulumi.set(self, "object_type_field", value)


if not MYPY:
    class ObjectTypeFieldArgsDict(TypedDict):
        """
        Represents a field in a ProfileObjectType.
        """
        content_type: NotRequired[pulumi.Input['ObjectTypeFieldContentType']]
        """
        The content type of the field. Used for determining equality when searching.
        """
        source: NotRequired[pulumi.Input[str]]
        """
        A field of a ProfileObject. For example: _source.FirstName, where "_source" is a ProfileObjectType of a Zendesk user and "FirstName" is a field in that ObjectType.
        """
        target: NotRequired[pulumi.Input[str]]
        """
        The location of the data in the standard ProfileObject model. For example: _profile.Address.PostalCode.
        """
elif False:
    ObjectTypeFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObjectTypeFieldArgs:
    def __init__(__self__, *,
                 content_type: Optional[pulumi.Input['ObjectTypeFieldContentType']] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 target: Optional[pulumi.Input[str]] = None):
        """
        Represents a field in a ProfileObjectType.
        :param pulumi.Input['ObjectTypeFieldContentType'] content_type: The content type of the field. Used for determining equality when searching.
        :param pulumi.Input[str] source: A field of a ProfileObject. For example: _source.FirstName, where "_source" is a ProfileObjectType of a Zendesk user and "FirstName" is a field in that ObjectType.
        :param pulumi.Input[str] target: The location of the data in the standard ProfileObject model. For example: _profile.Address.PostalCode.
        """
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input['ObjectTypeFieldContentType']]:
        """
        The content type of the field. Used for determining equality when searching.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input['ObjectTypeFieldContentType']]):
        pulumi.set(self, "content_type", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        A field of a ProfileObject. For example: _source.FirstName, where "_source" is a ProfileObjectType of a Zendesk user and "FirstName" is a field in that ObjectType.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        """
        The location of the data in the standard ProfileObject model. For example: _profile.Address.PostalCode.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)


if not MYPY:
    class ObjectTypeKeyMapArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the key.
        """
        object_type_key_list: NotRequired[pulumi.Input[Sequence[pulumi.Input['ObjectTypeKeyArgsDict']]]]
        """
        A list of ObjectTypeKey.
        """
elif False:
    ObjectTypeKeyMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObjectTypeKeyMapArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 object_type_key_list: Optional[pulumi.Input[Sequence[pulumi.Input['ObjectTypeKeyArgs']]]] = None):
        """
        :param pulumi.Input[str] name: Name of the key.
        :param pulumi.Input[Sequence[pulumi.Input['ObjectTypeKeyArgs']]] object_type_key_list: A list of ObjectTypeKey.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if object_type_key_list is not None:
            pulumi.set(__self__, "object_type_key_list", object_type_key_list)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the key.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="objectTypeKeyList")
    def object_type_key_list(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ObjectTypeKeyArgs']]]]:
        """
        A list of ObjectTypeKey.
        """
        return pulumi.get(self, "object_type_key_list")

    @object_type_key_list.setter
    def object_type_key_list(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ObjectTypeKeyArgs']]]]):
        pulumi.set(self, "object_type_key_list", value)


if not MYPY:
    class ObjectTypeKeyArgsDict(TypedDict):
        """
        An object that defines the Key element of a ProfileObject. A Key is a special element that can be used to search for a customer profile.
        """
        field_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The reference for the key name of the fields map. 
        """
        standard_identifiers: NotRequired[pulumi.Input[Sequence[pulumi.Input['ObjectTypeKeyStandardIdentifiersItem']]]]
        """
        The types of keys that a ProfileObject can have. Each ProfileObject can have only 1 UNIQUE key but multiple PROFILE keys. PROFILE means that this key can be used to tie an object to a PROFILE. UNIQUE means that it can be used to uniquely identify an object. If a key a is marked as SECONDARY, it will be used to search for profiles after all other PROFILE keys have been searched. A LOOKUP_ONLY key is only used to match a profile but is not persisted to be used for searching of the profile. A NEW_ONLY key is only used if the profile does not already exist before the object is ingested, otherwise it is only used for matching objects to profiles.
        """
elif False:
    ObjectTypeKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObjectTypeKeyArgs:
    def __init__(__self__, *,
                 field_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 standard_identifiers: Optional[pulumi.Input[Sequence[pulumi.Input['ObjectTypeKeyStandardIdentifiersItem']]]] = None):
        """
        An object that defines the Key element of a ProfileObject. A Key is a special element that can be used to search for a customer profile.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] field_names: The reference for the key name of the fields map. 
        :param pulumi.Input[Sequence[pulumi.Input['ObjectTypeKeyStandardIdentifiersItem']]] standard_identifiers: The types of keys that a ProfileObject can have. Each ProfileObject can have only 1 UNIQUE key but multiple PROFILE keys. PROFILE means that this key can be used to tie an object to a PROFILE. UNIQUE means that it can be used to uniquely identify an object. If a key a is marked as SECONDARY, it will be used to search for profiles after all other PROFILE keys have been searched. A LOOKUP_ONLY key is only used to match a profile but is not persisted to be used for searching of the profile. A NEW_ONLY key is only used if the profile does not already exist before the object is ingested, otherwise it is only used for matching objects to profiles.
        """
        if field_names is not None:
            pulumi.set(__self__, "field_names", field_names)
        if standard_identifiers is not None:
            pulumi.set(__self__, "standard_identifiers", standard_identifiers)

    @property
    @pulumi.getter(name="fieldNames")
    def field_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The reference for the key name of the fields map. 
        """
        return pulumi.get(self, "field_names")

    @field_names.setter
    def field_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "field_names", value)

    @property
    @pulumi.getter(name="standardIdentifiers")
    def standard_identifiers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ObjectTypeKeyStandardIdentifiersItem']]]]:
        """
        The types of keys that a ProfileObject can have. Each ProfileObject can have only 1 UNIQUE key but multiple PROFILE keys. PROFILE means that this key can be used to tie an object to a PROFILE. UNIQUE means that it can be used to uniquely identify an object. If a key a is marked as SECONDARY, it will be used to search for profiles after all other PROFILE keys have been searched. A LOOKUP_ONLY key is only used to match a profile but is not persisted to be used for searching of the profile. A NEW_ONLY key is only used if the profile does not already exist before the object is ingested, otherwise it is only used for matching objects to profiles.
        """
        return pulumi.get(self, "standard_identifiers")

    @standard_identifiers.setter
    def standard_identifiers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ObjectTypeKeyStandardIdentifiersItem']]]]):
        pulumi.set(self, "standard_identifiers", value)


