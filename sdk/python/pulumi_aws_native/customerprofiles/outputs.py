# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'CalculatedAttributeDefinitionAttributeDetails',
    'CalculatedAttributeDefinitionAttributeItem',
    'CalculatedAttributeDefinitionConditions',
    'CalculatedAttributeDefinitionRange',
    'CalculatedAttributeDefinitionThreshold',
    'DestinationDetailsProperties',
    'DomainAttributeTypesSelector',
    'DomainAutoMerging',
    'DomainConflictResolution',
    'DomainConsolidation',
    'DomainExportingConfig',
    'DomainJobSchedule',
    'DomainMatching',
    'DomainMatchingRule',
    'DomainRuleBasedMatching',
    'DomainS3ExportingConfig',
    'DomainStats',
    'IntegrationConnectorOperator',
    'IntegrationFlowDefinition',
    'IntegrationIncrementalPullConfig',
    'IntegrationMarketoSourceProperties',
    'IntegrationObjectTypeMapping',
    'IntegrationS3SourceProperties',
    'IntegrationSalesforceSourceProperties',
    'IntegrationScheduledTriggerProperties',
    'IntegrationServiceNowSourceProperties',
    'IntegrationSourceConnectorProperties',
    'IntegrationSourceFlowConfig',
    'IntegrationTask',
    'IntegrationTaskPropertiesMap',
    'IntegrationTriggerConfig',
    'IntegrationTriggerProperties',
    'IntegrationZendeskSourceProperties',
    'ObjectTypeField',
    'ObjectTypeFieldMap',
    'ObjectTypeKey',
    'ObjectTypeKeyMap',
]

@pulumi.output_type
class CalculatedAttributeDefinitionAttributeDetails(dict):
    """
    Mathematical expression and a list of attribute items specified in that expression.
    """
    def __init__(__self__, *,
                 attributes: Sequence['outputs.CalculatedAttributeDefinitionAttributeItem'],
                 expression: str):
        """
        Mathematical expression and a list of attribute items specified in that expression.
        """
        pulumi.set(__self__, "attributes", attributes)
        pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter
    def attributes(self) -> Sequence['outputs.CalculatedAttributeDefinitionAttributeItem']:
        return pulumi.get(self, "attributes")

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")


@pulumi.output_type
class CalculatedAttributeDefinitionAttributeItem(dict):
    """
    The details of a single attribute item specified in the mathematical expression.
    """
    def __init__(__self__, *,
                 name: str):
        """
        The details of a single attribute item specified in the mathematical expression.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class CalculatedAttributeDefinitionConditions(dict):
    """
    The conditions including range, object count, and threshold for the calculated attribute.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "objectCount":
            suggest = "object_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CalculatedAttributeDefinitionConditions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CalculatedAttributeDefinitionConditions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CalculatedAttributeDefinitionConditions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 object_count: Optional[int] = None,
                 range: Optional['outputs.CalculatedAttributeDefinitionRange'] = None,
                 threshold: Optional['outputs.CalculatedAttributeDefinitionThreshold'] = None):
        """
        The conditions including range, object count, and threshold for the calculated attribute.
        """
        if object_count is not None:
            pulumi.set(__self__, "object_count", object_count)
        if range is not None:
            pulumi.set(__self__, "range", range)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="objectCount")
    def object_count(self) -> Optional[int]:
        return pulumi.get(self, "object_count")

    @property
    @pulumi.getter
    def range(self) -> Optional['outputs.CalculatedAttributeDefinitionRange']:
        return pulumi.get(self, "range")

    @property
    @pulumi.getter
    def threshold(self) -> Optional['outputs.CalculatedAttributeDefinitionThreshold']:
        return pulumi.get(self, "threshold")


@pulumi.output_type
class CalculatedAttributeDefinitionRange(dict):
    """
    The relative time period over which data is included in the aggregation.
    """
    def __init__(__self__, *,
                 unit: 'CalculatedAttributeDefinitionRangeUnit',
                 value: int):
        """
        The relative time period over which data is included in the aggregation.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> 'CalculatedAttributeDefinitionRangeUnit':
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> int:
        return pulumi.get(self, "value")


@pulumi.output_type
class CalculatedAttributeDefinitionThreshold(dict):
    """
    The threshold for the calculated attribute.
    """
    def __init__(__self__, *,
                 operator: 'CalculatedAttributeDefinitionThresholdOperator',
                 value: str):
        """
        The threshold for the calculated attribute.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def operator(self) -> 'CalculatedAttributeDefinitionThresholdOperator':
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class DestinationDetailsProperties(dict):
    """
    Details regarding the Kinesis stream.
    """
    def __init__(__self__, *,
                 status: 'EventStreamStatus',
                 uri: str):
        """
        Details regarding the Kinesis stream.
        """
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def status(self) -> 'EventStreamStatus':
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def uri(self) -> str:
        return pulumi.get(self, "uri")


@pulumi.output_type
class DomainAttributeTypesSelector(dict):
    """
    Configures information about the AttributeTypesSelector where the rule-based identity resolution uses to match profiles.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeMatchingModel":
            suggest = "attribute_matching_model"
        elif key == "emailAddress":
            suggest = "email_address"
        elif key == "phoneNumber":
            suggest = "phone_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainAttributeTypesSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainAttributeTypesSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainAttributeTypesSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_matching_model: 'DomainAttributeTypesSelectorAttributeMatchingModel',
                 address: Optional[Sequence[str]] = None,
                 email_address: Optional[Sequence[str]] = None,
                 phone_number: Optional[Sequence[str]] = None):
        """
        Configures information about the AttributeTypesSelector where the rule-based identity resolution uses to match profiles.
        :param 'DomainAttributeTypesSelectorAttributeMatchingModel' attribute_matching_model: Configures the AttributeMatchingModel, you can either choose ONE_TO_ONE or MANY_TO_MANY.
        :param Sequence[str] address: The Address type. You can choose from Address, BusinessAddress, MaillingAddress, and ShippingAddress. You only can use the Address type in the MatchingRule. For example, if you want to match profile based on BusinessAddress.City or MaillingAddress.City, you need to choose the BusinessAddress and the MaillingAddress to represent the Address type and specify the Address.City on the matching rule.
        :param Sequence[str] email_address: The Email type. You can choose from EmailAddress, BusinessEmailAddress and PersonalEmailAddress. You only can use the EmailAddress type in the MatchingRule. For example, if you want to match profile based on PersonalEmailAddress or BusinessEmailAddress, you need to choose the PersonalEmailAddress and the BusinessEmailAddress to represent the EmailAddress type and only specify the EmailAddress on the matching rule.
        :param Sequence[str] phone_number: The PhoneNumber type. You can choose from PhoneNumber, HomePhoneNumber, and MobilePhoneNumber. You only can use the PhoneNumber type in the MatchingRule. For example, if you want to match a profile based on Phone or HomePhone, you need to choose the Phone and the HomePhone to represent the PhoneNumber type and only specify the PhoneNumber on the matching rule.
        """
        pulumi.set(__self__, "attribute_matching_model", attribute_matching_model)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if email_address is not None:
            pulumi.set(__self__, "email_address", email_address)
        if phone_number is not None:
            pulumi.set(__self__, "phone_number", phone_number)

    @property
    @pulumi.getter(name="attributeMatchingModel")
    def attribute_matching_model(self) -> 'DomainAttributeTypesSelectorAttributeMatchingModel':
        """
        Configures the AttributeMatchingModel, you can either choose ONE_TO_ONE or MANY_TO_MANY.
        """
        return pulumi.get(self, "attribute_matching_model")

    @property
    @pulumi.getter
    def address(self) -> Optional[Sequence[str]]:
        """
        The Address type. You can choose from Address, BusinessAddress, MaillingAddress, and ShippingAddress. You only can use the Address type in the MatchingRule. For example, if you want to match profile based on BusinessAddress.City or MaillingAddress.City, you need to choose the BusinessAddress and the MaillingAddress to represent the Address type and specify the Address.City on the matching rule.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> Optional[Sequence[str]]:
        """
        The Email type. You can choose from EmailAddress, BusinessEmailAddress and PersonalEmailAddress. You only can use the EmailAddress type in the MatchingRule. For example, if you want to match profile based on PersonalEmailAddress or BusinessEmailAddress, you need to choose the PersonalEmailAddress and the BusinessEmailAddress to represent the EmailAddress type and only specify the EmailAddress on the matching rule.
        """
        return pulumi.get(self, "email_address")

    @property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> Optional[Sequence[str]]:
        """
        The PhoneNumber type. You can choose from PhoneNumber, HomePhoneNumber, and MobilePhoneNumber. You only can use the PhoneNumber type in the MatchingRule. For example, if you want to match a profile based on Phone or HomePhone, you need to choose the Phone and the HomePhone to represent the PhoneNumber type and only specify the PhoneNumber on the matching rule.
        """
        return pulumi.get(self, "phone_number")


@pulumi.output_type
class DomainAutoMerging(dict):
    """
    Configuration information about the auto-merging process.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conflictResolution":
            suggest = "conflict_resolution"
        elif key == "minAllowedConfidenceScoreForMerging":
            suggest = "min_allowed_confidence_score_for_merging"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainAutoMerging. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainAutoMerging.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainAutoMerging.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 conflict_resolution: Optional['outputs.DomainConflictResolution'] = None,
                 consolidation: Optional['outputs.DomainConsolidation'] = None,
                 min_allowed_confidence_score_for_merging: Optional[float] = None):
        """
        Configuration information about the auto-merging process.
        :param bool enabled: The flag that enables the auto-merging of duplicate profiles.
        :param float min_allowed_confidence_score_for_merging: A number between 0 and 1 that represents the minimum confidence score required for profiles within a matching group to be merged during the auto-merge process. A higher score means higher similarity required to merge profiles.
        """
        pulumi.set(__self__, "enabled", enabled)
        if conflict_resolution is not None:
            pulumi.set(__self__, "conflict_resolution", conflict_resolution)
        if consolidation is not None:
            pulumi.set(__self__, "consolidation", consolidation)
        if min_allowed_confidence_score_for_merging is not None:
            pulumi.set(__self__, "min_allowed_confidence_score_for_merging", min_allowed_confidence_score_for_merging)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        The flag that enables the auto-merging of duplicate profiles.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="conflictResolution")
    def conflict_resolution(self) -> Optional['outputs.DomainConflictResolution']:
        return pulumi.get(self, "conflict_resolution")

    @property
    @pulumi.getter
    def consolidation(self) -> Optional['outputs.DomainConsolidation']:
        return pulumi.get(self, "consolidation")

    @property
    @pulumi.getter(name="minAllowedConfidenceScoreForMerging")
    def min_allowed_confidence_score_for_merging(self) -> Optional[float]:
        """
        A number between 0 and 1 that represents the minimum confidence score required for profiles within a matching group to be merged during the auto-merge process. A higher score means higher similarity required to merge profiles.
        """
        return pulumi.get(self, "min_allowed_confidence_score_for_merging")


@pulumi.output_type
class DomainConflictResolution(dict):
    """
    How the auto-merging process should resolve conflicts between different profiles. For example, if Profile A and Profile B have the same FirstName and LastName (and that is the matching criteria), which EmailAddress should be used? 
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conflictResolvingModel":
            suggest = "conflict_resolving_model"
        elif key == "sourceName":
            suggest = "source_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainConflictResolution. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainConflictResolution.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainConflictResolution.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conflict_resolving_model: 'DomainConflictResolutionConflictResolvingModel',
                 source_name: Optional[str] = None):
        """
        How the auto-merging process should resolve conflicts between different profiles. For example, if Profile A and Profile B have the same FirstName and LastName (and that is the matching criteria), which EmailAddress should be used? 
        :param 'DomainConflictResolutionConflictResolvingModel' conflict_resolving_model: How the auto-merging process should resolve conflicts between different profiles.
        :param str source_name: The ObjectType name that is used to resolve profile merging conflicts when choosing SOURCE as the ConflictResolvingModel.
        """
        pulumi.set(__self__, "conflict_resolving_model", conflict_resolving_model)
        if source_name is not None:
            pulumi.set(__self__, "source_name", source_name)

    @property
    @pulumi.getter(name="conflictResolvingModel")
    def conflict_resolving_model(self) -> 'DomainConflictResolutionConflictResolvingModel':
        """
        How the auto-merging process should resolve conflicts between different profiles.
        """
        return pulumi.get(self, "conflict_resolving_model")

    @property
    @pulumi.getter(name="sourceName")
    def source_name(self) -> Optional[str]:
        """
        The ObjectType name that is used to resolve profile merging conflicts when choosing SOURCE as the ConflictResolvingModel.
        """
        return pulumi.get(self, "source_name")


@pulumi.output_type
class DomainConsolidation(dict):
    """
    A list of matching attributes that represent matching criteria. If two profiles meet at least one of the requirements in the matching attributes list, they will be merged.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchingAttributesList":
            suggest = "matching_attributes_list"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainConsolidation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainConsolidation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainConsolidation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 matching_attributes_list: Sequence[Sequence[str]]):
        """
        A list of matching attributes that represent matching criteria. If two profiles meet at least one of the requirements in the matching attributes list, they will be merged.
        :param Sequence[Sequence[str]] matching_attributes_list: A list of matching criteria.
        """
        pulumi.set(__self__, "matching_attributes_list", matching_attributes_list)

    @property
    @pulumi.getter(name="matchingAttributesList")
    def matching_attributes_list(self) -> Sequence[Sequence[str]]:
        """
        A list of matching criteria.
        """
        return pulumi.get(self, "matching_attributes_list")


@pulumi.output_type
class DomainExportingConfig(dict):
    """
    Configuration information for exporting Identity Resolution results, for example, to an S3 bucket.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "s3Exporting":
            suggest = "s3_exporting"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainExportingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainExportingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainExportingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 s3_exporting: Optional['outputs.DomainS3ExportingConfig'] = None):
        """
        Configuration information for exporting Identity Resolution results, for example, to an S3 bucket.
        """
        if s3_exporting is not None:
            pulumi.set(__self__, "s3_exporting", s3_exporting)

    @property
    @pulumi.getter(name="s3Exporting")
    def s3_exporting(self) -> Optional['outputs.DomainS3ExportingConfig']:
        return pulumi.get(self, "s3_exporting")


@pulumi.output_type
class DomainJobSchedule(dict):
    """
    The day and time when do you want to start the Identity Resolution Job every week.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dayOfTheWeek":
            suggest = "day_of_the_week"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainJobSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainJobSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainJobSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 day_of_the_week: 'DomainJobScheduleDayOfTheWeek',
                 time: str):
        """
        The day and time when do you want to start the Identity Resolution Job every week.
        :param 'DomainJobScheduleDayOfTheWeek' day_of_the_week: The day when the Identity Resolution Job should run every week.
        :param str time: The time when the Identity Resolution Job should run every week.
        """
        pulumi.set(__self__, "day_of_the_week", day_of_the_week)
        pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter(name="dayOfTheWeek")
    def day_of_the_week(self) -> 'DomainJobScheduleDayOfTheWeek':
        """
        The day when the Identity Resolution Job should run every week.
        """
        return pulumi.get(self, "day_of_the_week")

    @property
    @pulumi.getter
    def time(self) -> str:
        """
        The time when the Identity Resolution Job should run every week.
        """
        return pulumi.get(self, "time")


@pulumi.output_type
class DomainMatching(dict):
    """
    The process of matching duplicate profiles. If Matching = true, Amazon Connect Customer Profiles starts a weekly batch process called Identity Resolution Job. If you do not specify a date and time for Identity Resolution Job to run, by default it runs every Saturday at 12AM UTC to detect duplicate profiles in your domains. After the Identity Resolution Job completes, use the GetMatches API to return and review the results. Or, if you have configured ExportingConfig in the MatchingRequest, you can download the results from S3.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoMerging":
            suggest = "auto_merging"
        elif key == "exportingConfig":
            suggest = "exporting_config"
        elif key == "jobSchedule":
            suggest = "job_schedule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainMatching. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainMatching.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainMatching.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 auto_merging: Optional['outputs.DomainAutoMerging'] = None,
                 exporting_config: Optional['outputs.DomainExportingConfig'] = None,
                 job_schedule: Optional['outputs.DomainJobSchedule'] = None):
        """
        The process of matching duplicate profiles. If Matching = true, Amazon Connect Customer Profiles starts a weekly batch process called Identity Resolution Job. If you do not specify a date and time for Identity Resolution Job to run, by default it runs every Saturday at 12AM UTC to detect duplicate profiles in your domains. After the Identity Resolution Job completes, use the GetMatches API to return and review the results. Or, if you have configured ExportingConfig in the MatchingRequest, you can download the results from S3.
        :param bool enabled: The flag that enables the matching process of duplicate profiles.
        """
        pulumi.set(__self__, "enabled", enabled)
        if auto_merging is not None:
            pulumi.set(__self__, "auto_merging", auto_merging)
        if exporting_config is not None:
            pulumi.set(__self__, "exporting_config", exporting_config)
        if job_schedule is not None:
            pulumi.set(__self__, "job_schedule", job_schedule)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        The flag that enables the matching process of duplicate profiles.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="autoMerging")
    def auto_merging(self) -> Optional['outputs.DomainAutoMerging']:
        return pulumi.get(self, "auto_merging")

    @property
    @pulumi.getter(name="exportingConfig")
    def exporting_config(self) -> Optional['outputs.DomainExportingConfig']:
        return pulumi.get(self, "exporting_config")

    @property
    @pulumi.getter(name="jobSchedule")
    def job_schedule(self) -> Optional['outputs.DomainJobSchedule']:
        return pulumi.get(self, "job_schedule")


@pulumi.output_type
class DomainMatchingRule(dict):
    """
    Specifies how does the rule-based matching process should match profiles.
    """
    def __init__(__self__, *,
                 rule: Sequence[str]):
        """
        Specifies how does the rule-based matching process should match profiles.
        """
        pulumi.set(__self__, "rule", rule)

    @property
    @pulumi.getter
    def rule(self) -> Sequence[str]:
        return pulumi.get(self, "rule")


@pulumi.output_type
class DomainRuleBasedMatching(dict):
    """
    The process of matching duplicate profiles using the Rule-Based matching. If RuleBasedMatching = true, Amazon Connect Customer Profiles will start to match and merge your profiles according to your configuration in the RuleBasedMatchingRequest. You can use the ListRuleBasedMatches and GetSimilarProfiles API to return and review the results. Also, if you have configured ExportingConfig in the RuleBasedMatchingRequest, you can download the results from S3.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeTypesSelector":
            suggest = "attribute_types_selector"
        elif key == "conflictResolution":
            suggest = "conflict_resolution"
        elif key == "exportingConfig":
            suggest = "exporting_config"
        elif key == "matchingRules":
            suggest = "matching_rules"
        elif key == "maxAllowedRuleLevelForMatching":
            suggest = "max_allowed_rule_level_for_matching"
        elif key == "maxAllowedRuleLevelForMerging":
            suggest = "max_allowed_rule_level_for_merging"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainRuleBasedMatching. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainRuleBasedMatching.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainRuleBasedMatching.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 attribute_types_selector: Optional['outputs.DomainAttributeTypesSelector'] = None,
                 conflict_resolution: Optional['outputs.DomainConflictResolution'] = None,
                 exporting_config: Optional['outputs.DomainExportingConfig'] = None,
                 matching_rules: Optional[Sequence['outputs.DomainMatchingRule']] = None,
                 max_allowed_rule_level_for_matching: Optional[int] = None,
                 max_allowed_rule_level_for_merging: Optional[int] = None,
                 status: Optional['DomainRuleBasedMatchingStatus'] = None):
        """
        The process of matching duplicate profiles using the Rule-Based matching. If RuleBasedMatching = true, Amazon Connect Customer Profiles will start to match and merge your profiles according to your configuration in the RuleBasedMatchingRequest. You can use the ListRuleBasedMatches and GetSimilarProfiles API to return and review the results. Also, if you have configured ExportingConfig in the RuleBasedMatchingRequest, you can download the results from S3.
        :param bool enabled: The flag that enables the rule-based matching process of duplicate profiles.
        :param Sequence['DomainMatchingRule'] matching_rules: Configures how the rule-based matching process should match profiles. You can have up to 15 MatchingRule in the MatchingRules.
        :param int max_allowed_rule_level_for_matching: Indicates the maximum allowed rule level for matching.
        :param int max_allowed_rule_level_for_merging: Indicates the maximum allowed rule level for merging.
        """
        pulumi.set(__self__, "enabled", enabled)
        if attribute_types_selector is not None:
            pulumi.set(__self__, "attribute_types_selector", attribute_types_selector)
        if conflict_resolution is not None:
            pulumi.set(__self__, "conflict_resolution", conflict_resolution)
        if exporting_config is not None:
            pulumi.set(__self__, "exporting_config", exporting_config)
        if matching_rules is not None:
            pulumi.set(__self__, "matching_rules", matching_rules)
        if max_allowed_rule_level_for_matching is not None:
            pulumi.set(__self__, "max_allowed_rule_level_for_matching", max_allowed_rule_level_for_matching)
        if max_allowed_rule_level_for_merging is not None:
            pulumi.set(__self__, "max_allowed_rule_level_for_merging", max_allowed_rule_level_for_merging)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        The flag that enables the rule-based matching process of duplicate profiles.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="attributeTypesSelector")
    def attribute_types_selector(self) -> Optional['outputs.DomainAttributeTypesSelector']:
        return pulumi.get(self, "attribute_types_selector")

    @property
    @pulumi.getter(name="conflictResolution")
    def conflict_resolution(self) -> Optional['outputs.DomainConflictResolution']:
        return pulumi.get(self, "conflict_resolution")

    @property
    @pulumi.getter(name="exportingConfig")
    def exporting_config(self) -> Optional['outputs.DomainExportingConfig']:
        return pulumi.get(self, "exporting_config")

    @property
    @pulumi.getter(name="matchingRules")
    def matching_rules(self) -> Optional[Sequence['outputs.DomainMatchingRule']]:
        """
        Configures how the rule-based matching process should match profiles. You can have up to 15 MatchingRule in the MatchingRules.
        """
        return pulumi.get(self, "matching_rules")

    @property
    @pulumi.getter(name="maxAllowedRuleLevelForMatching")
    def max_allowed_rule_level_for_matching(self) -> Optional[int]:
        """
        Indicates the maximum allowed rule level for matching.
        """
        return pulumi.get(self, "max_allowed_rule_level_for_matching")

    @property
    @pulumi.getter(name="maxAllowedRuleLevelForMerging")
    def max_allowed_rule_level_for_merging(self) -> Optional[int]:
        """
        Indicates the maximum allowed rule level for merging.
        """
        return pulumi.get(self, "max_allowed_rule_level_for_merging")

    @property
    @pulumi.getter
    def status(self) -> Optional['DomainRuleBasedMatchingStatus']:
        return pulumi.get(self, "status")


@pulumi.output_type
class DomainS3ExportingConfig(dict):
    """
    The S3 location where Identity Resolution Jobs write result files.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "s3BucketName":
            suggest = "s3_bucket_name"
        elif key == "s3KeyName":
            suggest = "s3_key_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainS3ExportingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainS3ExportingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainS3ExportingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 s3_bucket_name: str,
                 s3_key_name: Optional[str] = None):
        """
        The S3 location where Identity Resolution Jobs write result files.
        :param str s3_bucket_name: The name of the S3 bucket where Identity Resolution Jobs write result files.
        :param str s3_key_name: The S3 key name of the location where Identity Resolution Jobs write result files.
        """
        pulumi.set(__self__, "s3_bucket_name", s3_bucket_name)
        if s3_key_name is not None:
            pulumi.set(__self__, "s3_key_name", s3_key_name)

    @property
    @pulumi.getter(name="s3BucketName")
    def s3_bucket_name(self) -> str:
        """
        The name of the S3 bucket where Identity Resolution Jobs write result files.
        """
        return pulumi.get(self, "s3_bucket_name")

    @property
    @pulumi.getter(name="s3KeyName")
    def s3_key_name(self) -> Optional[str]:
        """
        The S3 key name of the location where Identity Resolution Jobs write result files.
        """
        return pulumi.get(self, "s3_key_name")


@pulumi.output_type
class DomainStats(dict):
    """
    Usage-specific statistics about the domain.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "meteringProfileCount":
            suggest = "metering_profile_count"
        elif key == "objectCount":
            suggest = "object_count"
        elif key == "profileCount":
            suggest = "profile_count"
        elif key == "totalSize":
            suggest = "total_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainStats. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainStats.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainStats.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metering_profile_count: Optional[float] = None,
                 object_count: Optional[float] = None,
                 profile_count: Optional[float] = None,
                 total_size: Optional[float] = None):
        """
        Usage-specific statistics about the domain.
        :param float metering_profile_count: The number of profiles that you are currently paying for in the domain. If you have more than 100 objects associated with a single profile, that profile counts as two profiles. If you have more than 200 objects, that profile counts as three, and so on.
        :param float object_count: The total number of objects in domain.
        :param float profile_count: The total number of profiles currently in the domain.
        :param float total_size: The total size, in bytes, of all objects in the domain.
        """
        if metering_profile_count is not None:
            pulumi.set(__self__, "metering_profile_count", metering_profile_count)
        if object_count is not None:
            pulumi.set(__self__, "object_count", object_count)
        if profile_count is not None:
            pulumi.set(__self__, "profile_count", profile_count)
        if total_size is not None:
            pulumi.set(__self__, "total_size", total_size)

    @property
    @pulumi.getter(name="meteringProfileCount")
    def metering_profile_count(self) -> Optional[float]:
        """
        The number of profiles that you are currently paying for in the domain. If you have more than 100 objects associated with a single profile, that profile counts as two profiles. If you have more than 200 objects, that profile counts as three, and so on.
        """
        return pulumi.get(self, "metering_profile_count")

    @property
    @pulumi.getter(name="objectCount")
    def object_count(self) -> Optional[float]:
        """
        The total number of objects in domain.
        """
        return pulumi.get(self, "object_count")

    @property
    @pulumi.getter(name="profileCount")
    def profile_count(self) -> Optional[float]:
        """
        The total number of profiles currently in the domain.
        """
        return pulumi.get(self, "profile_count")

    @property
    @pulumi.getter(name="totalSize")
    def total_size(self) -> Optional[float]:
        """
        The total size, in bytes, of all objects in the domain.
        """
        return pulumi.get(self, "total_size")


@pulumi.output_type
class IntegrationConnectorOperator(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceNow":
            suggest = "service_now"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationConnectorOperator. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationConnectorOperator.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationConnectorOperator.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 marketo: Optional['IntegrationMarketoConnectorOperator'] = None,
                 s3: Optional['IntegrationS3ConnectorOperator'] = None,
                 salesforce: Optional['IntegrationSalesforceConnectorOperator'] = None,
                 service_now: Optional['IntegrationServiceNowConnectorOperator'] = None,
                 zendesk: Optional['IntegrationZendeskConnectorOperator'] = None):
        if marketo is not None:
            pulumi.set(__self__, "marketo", marketo)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if salesforce is not None:
            pulumi.set(__self__, "salesforce", salesforce)
        if service_now is not None:
            pulumi.set(__self__, "service_now", service_now)
        if zendesk is not None:
            pulumi.set(__self__, "zendesk", zendesk)

    @property
    @pulumi.getter
    def marketo(self) -> Optional['IntegrationMarketoConnectorOperator']:
        return pulumi.get(self, "marketo")

    @property
    @pulumi.getter
    def s3(self) -> Optional['IntegrationS3ConnectorOperator']:
        return pulumi.get(self, "s3")

    @property
    @pulumi.getter
    def salesforce(self) -> Optional['IntegrationSalesforceConnectorOperator']:
        return pulumi.get(self, "salesforce")

    @property
    @pulumi.getter(name="serviceNow")
    def service_now(self) -> Optional['IntegrationServiceNowConnectorOperator']:
        return pulumi.get(self, "service_now")

    @property
    @pulumi.getter
    def zendesk(self) -> Optional['IntegrationZendeskConnectorOperator']:
        return pulumi.get(self, "zendesk")


@pulumi.output_type
class IntegrationFlowDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "flowName":
            suggest = "flow_name"
        elif key == "kmsArn":
            suggest = "kms_arn"
        elif key == "sourceFlowConfig":
            suggest = "source_flow_config"
        elif key == "triggerConfig":
            suggest = "trigger_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationFlowDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationFlowDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationFlowDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 flow_name: str,
                 kms_arn: str,
                 source_flow_config: 'outputs.IntegrationSourceFlowConfig',
                 tasks: Sequence['outputs.IntegrationTask'],
                 trigger_config: 'outputs.IntegrationTriggerConfig',
                 description: Optional[str] = None):
        pulumi.set(__self__, "flow_name", flow_name)
        pulumi.set(__self__, "kms_arn", kms_arn)
        pulumi.set(__self__, "source_flow_config", source_flow_config)
        pulumi.set(__self__, "tasks", tasks)
        pulumi.set(__self__, "trigger_config", trigger_config)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter(name="flowName")
    def flow_name(self) -> str:
        return pulumi.get(self, "flow_name")

    @property
    @pulumi.getter(name="kmsArn")
    def kms_arn(self) -> str:
        return pulumi.get(self, "kms_arn")

    @property
    @pulumi.getter(name="sourceFlowConfig")
    def source_flow_config(self) -> 'outputs.IntegrationSourceFlowConfig':
        return pulumi.get(self, "source_flow_config")

    @property
    @pulumi.getter
    def tasks(self) -> Sequence['outputs.IntegrationTask']:
        return pulumi.get(self, "tasks")

    @property
    @pulumi.getter(name="triggerConfig")
    def trigger_config(self) -> 'outputs.IntegrationTriggerConfig':
        return pulumi.get(self, "trigger_config")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class IntegrationIncrementalPullConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datetimeTypeFieldName":
            suggest = "datetime_type_field_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationIncrementalPullConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationIncrementalPullConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationIncrementalPullConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datetime_type_field_name: Optional[str] = None):
        if datetime_type_field_name is not None:
            pulumi.set(__self__, "datetime_type_field_name", datetime_type_field_name)

    @property
    @pulumi.getter(name="datetimeTypeFieldName")
    def datetime_type_field_name(self) -> Optional[str]:
        return pulumi.get(self, "datetime_type_field_name")


@pulumi.output_type
class IntegrationMarketoSourceProperties(dict):
    def __init__(__self__, *,
                 object: str):
        pulumi.set(__self__, "object", object)

    @property
    @pulumi.getter
    def object(self) -> str:
        return pulumi.get(self, "object")


@pulumi.output_type
class IntegrationObjectTypeMapping(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class IntegrationS3SourceProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "bucketPrefix":
            suggest = "bucket_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationS3SourceProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationS3SourceProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationS3SourceProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: str,
                 bucket_prefix: Optional[str] = None):
        pulumi.set(__self__, "bucket_name", bucket_name)
        if bucket_prefix is not None:
            pulumi.set(__self__, "bucket_prefix", bucket_prefix)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> str:
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="bucketPrefix")
    def bucket_prefix(self) -> Optional[str]:
        return pulumi.get(self, "bucket_prefix")


@pulumi.output_type
class IntegrationSalesforceSourceProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableDynamicFieldUpdate":
            suggest = "enable_dynamic_field_update"
        elif key == "includeDeletedRecords":
            suggest = "include_deleted_records"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationSalesforceSourceProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationSalesforceSourceProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationSalesforceSourceProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 object: str,
                 enable_dynamic_field_update: Optional[bool] = None,
                 include_deleted_records: Optional[bool] = None):
        pulumi.set(__self__, "object", object)
        if enable_dynamic_field_update is not None:
            pulumi.set(__self__, "enable_dynamic_field_update", enable_dynamic_field_update)
        if include_deleted_records is not None:
            pulumi.set(__self__, "include_deleted_records", include_deleted_records)

    @property
    @pulumi.getter
    def object(self) -> str:
        return pulumi.get(self, "object")

    @property
    @pulumi.getter(name="enableDynamicFieldUpdate")
    def enable_dynamic_field_update(self) -> Optional[bool]:
        return pulumi.get(self, "enable_dynamic_field_update")

    @property
    @pulumi.getter(name="includeDeletedRecords")
    def include_deleted_records(self) -> Optional[bool]:
        return pulumi.get(self, "include_deleted_records")


@pulumi.output_type
class IntegrationScheduledTriggerProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scheduleExpression":
            suggest = "schedule_expression"
        elif key == "dataPullMode":
            suggest = "data_pull_mode"
        elif key == "firstExecutionFrom":
            suggest = "first_execution_from"
        elif key == "scheduleEndTime":
            suggest = "schedule_end_time"
        elif key == "scheduleOffset":
            suggest = "schedule_offset"
        elif key == "scheduleStartTime":
            suggest = "schedule_start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationScheduledTriggerProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationScheduledTriggerProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationScheduledTriggerProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 schedule_expression: str,
                 data_pull_mode: Optional['IntegrationScheduledTriggerPropertiesDataPullMode'] = None,
                 first_execution_from: Optional[float] = None,
                 schedule_end_time: Optional[float] = None,
                 schedule_offset: Optional[int] = None,
                 schedule_start_time: Optional[float] = None,
                 timezone: Optional[str] = None):
        pulumi.set(__self__, "schedule_expression", schedule_expression)
        if data_pull_mode is not None:
            pulumi.set(__self__, "data_pull_mode", data_pull_mode)
        if first_execution_from is not None:
            pulumi.set(__self__, "first_execution_from", first_execution_from)
        if schedule_end_time is not None:
            pulumi.set(__self__, "schedule_end_time", schedule_end_time)
        if schedule_offset is not None:
            pulumi.set(__self__, "schedule_offset", schedule_offset)
        if schedule_start_time is not None:
            pulumi.set(__self__, "schedule_start_time", schedule_start_time)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)

    @property
    @pulumi.getter(name="scheduleExpression")
    def schedule_expression(self) -> str:
        return pulumi.get(self, "schedule_expression")

    @property
    @pulumi.getter(name="dataPullMode")
    def data_pull_mode(self) -> Optional['IntegrationScheduledTriggerPropertiesDataPullMode']:
        return pulumi.get(self, "data_pull_mode")

    @property
    @pulumi.getter(name="firstExecutionFrom")
    def first_execution_from(self) -> Optional[float]:
        return pulumi.get(self, "first_execution_from")

    @property
    @pulumi.getter(name="scheduleEndTime")
    def schedule_end_time(self) -> Optional[float]:
        return pulumi.get(self, "schedule_end_time")

    @property
    @pulumi.getter(name="scheduleOffset")
    def schedule_offset(self) -> Optional[int]:
        return pulumi.get(self, "schedule_offset")

    @property
    @pulumi.getter(name="scheduleStartTime")
    def schedule_start_time(self) -> Optional[float]:
        return pulumi.get(self, "schedule_start_time")

    @property
    @pulumi.getter
    def timezone(self) -> Optional[str]:
        return pulumi.get(self, "timezone")


@pulumi.output_type
class IntegrationServiceNowSourceProperties(dict):
    def __init__(__self__, *,
                 object: str):
        pulumi.set(__self__, "object", object)

    @property
    @pulumi.getter
    def object(self) -> str:
        return pulumi.get(self, "object")


@pulumi.output_type
class IntegrationSourceConnectorProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceNow":
            suggest = "service_now"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationSourceConnectorProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationSourceConnectorProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationSourceConnectorProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 marketo: Optional['outputs.IntegrationMarketoSourceProperties'] = None,
                 s3: Optional['outputs.IntegrationS3SourceProperties'] = None,
                 salesforce: Optional['outputs.IntegrationSalesforceSourceProperties'] = None,
                 service_now: Optional['outputs.IntegrationServiceNowSourceProperties'] = None,
                 zendesk: Optional['outputs.IntegrationZendeskSourceProperties'] = None):
        if marketo is not None:
            pulumi.set(__self__, "marketo", marketo)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if salesforce is not None:
            pulumi.set(__self__, "salesforce", salesforce)
        if service_now is not None:
            pulumi.set(__self__, "service_now", service_now)
        if zendesk is not None:
            pulumi.set(__self__, "zendesk", zendesk)

    @property
    @pulumi.getter
    def marketo(self) -> Optional['outputs.IntegrationMarketoSourceProperties']:
        return pulumi.get(self, "marketo")

    @property
    @pulumi.getter
    def s3(self) -> Optional['outputs.IntegrationS3SourceProperties']:
        return pulumi.get(self, "s3")

    @property
    @pulumi.getter
    def salesforce(self) -> Optional['outputs.IntegrationSalesforceSourceProperties']:
        return pulumi.get(self, "salesforce")

    @property
    @pulumi.getter(name="serviceNow")
    def service_now(self) -> Optional['outputs.IntegrationServiceNowSourceProperties']:
        return pulumi.get(self, "service_now")

    @property
    @pulumi.getter
    def zendesk(self) -> Optional['outputs.IntegrationZendeskSourceProperties']:
        return pulumi.get(self, "zendesk")


@pulumi.output_type
class IntegrationSourceFlowConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectorType":
            suggest = "connector_type"
        elif key == "sourceConnectorProperties":
            suggest = "source_connector_properties"
        elif key == "connectorProfileName":
            suggest = "connector_profile_name"
        elif key == "incrementalPullConfig":
            suggest = "incremental_pull_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationSourceFlowConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationSourceFlowConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationSourceFlowConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connector_type: 'IntegrationConnectorType',
                 source_connector_properties: 'outputs.IntegrationSourceConnectorProperties',
                 connector_profile_name: Optional[str] = None,
                 incremental_pull_config: Optional['outputs.IntegrationIncrementalPullConfig'] = None):
        pulumi.set(__self__, "connector_type", connector_type)
        pulumi.set(__self__, "source_connector_properties", source_connector_properties)
        if connector_profile_name is not None:
            pulumi.set(__self__, "connector_profile_name", connector_profile_name)
        if incremental_pull_config is not None:
            pulumi.set(__self__, "incremental_pull_config", incremental_pull_config)

    @property
    @pulumi.getter(name="connectorType")
    def connector_type(self) -> 'IntegrationConnectorType':
        return pulumi.get(self, "connector_type")

    @property
    @pulumi.getter(name="sourceConnectorProperties")
    def source_connector_properties(self) -> 'outputs.IntegrationSourceConnectorProperties':
        return pulumi.get(self, "source_connector_properties")

    @property
    @pulumi.getter(name="connectorProfileName")
    def connector_profile_name(self) -> Optional[str]:
        return pulumi.get(self, "connector_profile_name")

    @property
    @pulumi.getter(name="incrementalPullConfig")
    def incremental_pull_config(self) -> Optional['outputs.IntegrationIncrementalPullConfig']:
        return pulumi.get(self, "incremental_pull_config")


@pulumi.output_type
class IntegrationTask(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceFields":
            suggest = "source_fields"
        elif key == "taskType":
            suggest = "task_type"
        elif key == "connectorOperator":
            suggest = "connector_operator"
        elif key == "destinationField":
            suggest = "destination_field"
        elif key == "taskProperties":
            suggest = "task_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationTask. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationTask.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationTask.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_fields: Sequence[str],
                 task_type: 'IntegrationTaskType',
                 connector_operator: Optional['outputs.IntegrationConnectorOperator'] = None,
                 destination_field: Optional[str] = None,
                 task_properties: Optional[Sequence['outputs.IntegrationTaskPropertiesMap']] = None):
        pulumi.set(__self__, "source_fields", source_fields)
        pulumi.set(__self__, "task_type", task_type)
        if connector_operator is not None:
            pulumi.set(__self__, "connector_operator", connector_operator)
        if destination_field is not None:
            pulumi.set(__self__, "destination_field", destination_field)
        if task_properties is not None:
            pulumi.set(__self__, "task_properties", task_properties)

    @property
    @pulumi.getter(name="sourceFields")
    def source_fields(self) -> Sequence[str]:
        return pulumi.get(self, "source_fields")

    @property
    @pulumi.getter(name="taskType")
    def task_type(self) -> 'IntegrationTaskType':
        return pulumi.get(self, "task_type")

    @property
    @pulumi.getter(name="connectorOperator")
    def connector_operator(self) -> Optional['outputs.IntegrationConnectorOperator']:
        return pulumi.get(self, "connector_operator")

    @property
    @pulumi.getter(name="destinationField")
    def destination_field(self) -> Optional[str]:
        return pulumi.get(self, "destination_field")

    @property
    @pulumi.getter(name="taskProperties")
    def task_properties(self) -> Optional[Sequence['outputs.IntegrationTaskPropertiesMap']]:
        return pulumi.get(self, "task_properties")


@pulumi.output_type
class IntegrationTaskPropertiesMap(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorPropertyKey":
            suggest = "operator_property_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationTaskPropertiesMap. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationTaskPropertiesMap.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationTaskPropertiesMap.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_property_key: 'IntegrationOperatorPropertiesKeys',
                 property: str):
        pulumi.set(__self__, "operator_property_key", operator_property_key)
        pulumi.set(__self__, "property", property)

    @property
    @pulumi.getter(name="operatorPropertyKey")
    def operator_property_key(self) -> 'IntegrationOperatorPropertiesKeys':
        return pulumi.get(self, "operator_property_key")

    @property
    @pulumi.getter
    def property(self) -> str:
        return pulumi.get(self, "property")


@pulumi.output_type
class IntegrationTriggerConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "triggerType":
            suggest = "trigger_type"
        elif key == "triggerProperties":
            suggest = "trigger_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntegrationTriggerConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntegrationTriggerConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntegrationTriggerConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 trigger_type: 'IntegrationTriggerType',
                 trigger_properties: Optional['outputs.IntegrationTriggerProperties'] = None):
        pulumi.set(__self__, "trigger_type", trigger_type)
        if trigger_properties is not None:
            pulumi.set(__self__, "trigger_properties", trigger_properties)

    @property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> 'IntegrationTriggerType':
        return pulumi.get(self, "trigger_type")

    @property
    @pulumi.getter(name="triggerProperties")
    def trigger_properties(self) -> Optional['outputs.IntegrationTriggerProperties']:
        return pulumi.get(self, "trigger_properties")


@pulumi.output_type
class IntegrationTriggerProperties(dict):
    def __init__(__self__, *,
                 scheduled: Optional['outputs.IntegrationScheduledTriggerProperties'] = None):
        if scheduled is not None:
            pulumi.set(__self__, "scheduled", scheduled)

    @property
    @pulumi.getter
    def scheduled(self) -> Optional['outputs.IntegrationScheduledTriggerProperties']:
        return pulumi.get(self, "scheduled")


@pulumi.output_type
class IntegrationZendeskSourceProperties(dict):
    def __init__(__self__, *,
                 object: str):
        pulumi.set(__self__, "object", object)

    @property
    @pulumi.getter
    def object(self) -> str:
        return pulumi.get(self, "object")


@pulumi.output_type
class ObjectTypeField(dict):
    """
    Represents a field in a ProfileObjectType.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentType":
            suggest = "content_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ObjectTypeField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ObjectTypeField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ObjectTypeField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content_type: Optional['ObjectTypeFieldContentType'] = None,
                 source: Optional[str] = None,
                 target: Optional[str] = None):
        """
        Represents a field in a ProfileObjectType.
        :param 'ObjectTypeFieldContentType' content_type: The content type of the field. Used for determining equality when searching.
        :param str source: A field of a ProfileObject. For example: _source.FirstName, where "_source" is a ProfileObjectType of a Zendesk user and "FirstName" is a field in that ObjectType.
        :param str target: The location of the data in the standard ProfileObject model. For example: _profile.Address.PostalCode.
        """
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional['ObjectTypeFieldContentType']:
        """
        The content type of the field. Used for determining equality when searching.
        """
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        """
        A field of a ProfileObject. For example: _source.FirstName, where "_source" is a ProfileObjectType of a Zendesk user and "FirstName" is a field in that ObjectType.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        The location of the data in the standard ProfileObject model. For example: _profile.Address.PostalCode.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class ObjectTypeFieldMap(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "objectTypeField":
            suggest = "object_type_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ObjectTypeFieldMap. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ObjectTypeFieldMap.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ObjectTypeFieldMap.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 object_type_field: Optional['outputs.ObjectTypeField'] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if object_type_field is not None:
            pulumi.set(__self__, "object_type_field", object_type_field)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="objectTypeField")
    def object_type_field(self) -> Optional['outputs.ObjectTypeField']:
        return pulumi.get(self, "object_type_field")


@pulumi.output_type
class ObjectTypeKey(dict):
    """
    An object that defines the Key element of a ProfileObject. A Key is a special element that can be used to search for a customer profile.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldNames":
            suggest = "field_names"
        elif key == "standardIdentifiers":
            suggest = "standard_identifiers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ObjectTypeKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ObjectTypeKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ObjectTypeKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_names: Optional[Sequence[str]] = None,
                 standard_identifiers: Optional[Sequence['ObjectTypeKeyStandardIdentifiersItem']] = None):
        """
        An object that defines the Key element of a ProfileObject. A Key is a special element that can be used to search for a customer profile.
        :param Sequence[str] field_names: The reference for the key name of the fields map. 
        :param Sequence['ObjectTypeKeyStandardIdentifiersItem'] standard_identifiers: The types of keys that a ProfileObject can have. Each ProfileObject can have only 1 UNIQUE key but multiple PROFILE keys. PROFILE means that this key can be used to tie an object to a PROFILE. UNIQUE means that it can be used to uniquely identify an object. If a key a is marked as SECONDARY, it will be used to search for profiles after all other PROFILE keys have been searched. A LOOKUP_ONLY key is only used to match a profile but is not persisted to be used for searching of the profile. A NEW_ONLY key is only used if the profile does not already exist before the object is ingested, otherwise it is only used for matching objects to profiles.
        """
        if field_names is not None:
            pulumi.set(__self__, "field_names", field_names)
        if standard_identifiers is not None:
            pulumi.set(__self__, "standard_identifiers", standard_identifiers)

    @property
    @pulumi.getter(name="fieldNames")
    def field_names(self) -> Optional[Sequence[str]]:
        """
        The reference for the key name of the fields map. 
        """
        return pulumi.get(self, "field_names")

    @property
    @pulumi.getter(name="standardIdentifiers")
    def standard_identifiers(self) -> Optional[Sequence['ObjectTypeKeyStandardIdentifiersItem']]:
        """
        The types of keys that a ProfileObject can have. Each ProfileObject can have only 1 UNIQUE key but multiple PROFILE keys. PROFILE means that this key can be used to tie an object to a PROFILE. UNIQUE means that it can be used to uniquely identify an object. If a key a is marked as SECONDARY, it will be used to search for profiles after all other PROFILE keys have been searched. A LOOKUP_ONLY key is only used to match a profile but is not persisted to be used for searching of the profile. A NEW_ONLY key is only used if the profile does not already exist before the object is ingested, otherwise it is only used for matching objects to profiles.
        """
        return pulumi.get(self, "standard_identifiers")


@pulumi.output_type
class ObjectTypeKeyMap(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "objectTypeKeyList":
            suggest = "object_type_key_list"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ObjectTypeKeyMap. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ObjectTypeKeyMap.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ObjectTypeKeyMap.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 object_type_key_list: Optional[Sequence['outputs.ObjectTypeKey']] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if object_type_key_list is not None:
            pulumi.set(__self__, "object_type_key_list", object_type_key_list)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="objectTypeKeyList")
    def object_type_key_list(self) -> Optional[Sequence['outputs.ObjectTypeKey']]:
        return pulumi.get(self, "object_type_key_list")


