# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'GroupInsightsConfiguration',
    'SamplingRule',
    'SamplingRuleRecord',
    'SamplingRuleUpdate',
]

@pulumi.output_type
class GroupInsightsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insightsEnabled":
            suggest = "insights_enabled"
        elif key == "notificationsEnabled":
            suggest = "notifications_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GroupInsightsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GroupInsightsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GroupInsightsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insights_enabled: Optional[_builtins.bool] = None,
                 notifications_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool insights_enabled: Set the InsightsEnabled value to true to enable insights or false to disable insights.
        :param _builtins.bool notifications_enabled: Set the NotificationsEnabled value to true to enable insights notifications. Notifications can only be enabled on a group with InsightsEnabled set to true.
        """
        if insights_enabled is not None:
            pulumi.set(__self__, "insights_enabled", insights_enabled)
        if notifications_enabled is not None:
            pulumi.set(__self__, "notifications_enabled", notifications_enabled)

    @_builtins.property
    @pulumi.getter(name="insightsEnabled")
    def insights_enabled(self) -> Optional[_builtins.bool]:
        """
        Set the InsightsEnabled value to true to enable insights or false to disable insights.
        """
        return pulumi.get(self, "insights_enabled")

    @_builtins.property
    @pulumi.getter(name="notificationsEnabled")
    def notifications_enabled(self) -> Optional[_builtins.bool]:
        """
        Set the NotificationsEnabled value to true to enable insights notifications. Notifications can only be enabled on a group with InsightsEnabled set to true.
        """
        return pulumi.get(self, "notifications_enabled")


@pulumi.output_type
class SamplingRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fixedRate":
            suggest = "fixed_rate"
        elif key == "httpMethod":
            suggest = "http_method"
        elif key == "reservoirSize":
            suggest = "reservoir_size"
        elif key == "resourceArn":
            suggest = "resource_arn"
        elif key == "serviceName":
            suggest = "service_name"
        elif key == "serviceType":
            suggest = "service_type"
        elif key == "urlPath":
            suggest = "url_path"
        elif key == "ruleArn":
            suggest = "rule_arn"
        elif key == "ruleName":
            suggest = "rule_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SamplingRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SamplingRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SamplingRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fixed_rate: _builtins.float,
                 host: _builtins.str,
                 http_method: _builtins.str,
                 priority: _builtins.int,
                 reservoir_size: _builtins.int,
                 resource_arn: _builtins.str,
                 service_name: _builtins.str,
                 service_type: _builtins.str,
                 url_path: _builtins.str,
                 attributes: Optional[Mapping[str, _builtins.str]] = None,
                 rule_arn: Optional[_builtins.str] = None,
                 rule_name: Optional[_builtins.str] = None,
                 version: Optional[_builtins.int] = None):
        """
        :param _builtins.float fixed_rate: The percentage of matching requests to instrument, after the reservoir is exhausted.
        :param _builtins.str host: Matches the hostname from a request URL.
        :param _builtins.str http_method: Matches the HTTP method from a request URL.
        :param _builtins.int priority: The priority of the sampling rule.
        :param _builtins.int reservoir_size: A fixed number of matching requests to instrument per second, prior to applying the fixed rate. The reservoir is not used directly by services, but applies to all services using the rule collectively.
        :param _builtins.str resource_arn: Matches the ARN of the AWS resource on which the service runs.
        :param _builtins.str service_name: Matches the name that the service uses to identify itself in segments.
        :param _builtins.str service_type: Matches the origin that the service uses to identify its type in segments.
        :param _builtins.str url_path: Matches the path from a request URL.
        :param Mapping[str, _builtins.str] attributes: Matches attributes derived from the request.
        :param _builtins.str rule_arn: The ARN of the sampling rule. Specify a rule by either name or ARN, but not both.
               
               > Specifying a sampling rule by name is recommended, as specifying by ARN will be deprecated in future.
        :param _builtins.str rule_name: The name of the sampling rule. Specify a rule by either name or ARN, but not both.
        :param _builtins.int version: The version of the sampling rule format (1)
        """
        pulumi.set(__self__, "fixed_rate", fixed_rate)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "http_method", http_method)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "reservoir_size", reservoir_size)
        pulumi.set(__self__, "resource_arn", resource_arn)
        pulumi.set(__self__, "service_name", service_name)
        pulumi.set(__self__, "service_type", service_type)
        pulumi.set(__self__, "url_path", url_path)
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if rule_arn is not None:
            pulumi.set(__self__, "rule_arn", rule_arn)
        if rule_name is not None:
            pulumi.set(__self__, "rule_name", rule_name)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="fixedRate")
    def fixed_rate(self) -> _builtins.float:
        """
        The percentage of matching requests to instrument, after the reservoir is exhausted.
        """
        return pulumi.get(self, "fixed_rate")

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        Matches the hostname from a request URL.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> _builtins.str:
        """
        Matches the HTTP method from a request URL.
        """
        return pulumi.get(self, "http_method")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        """
        The priority of the sampling rule.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="reservoirSize")
    def reservoir_size(self) -> _builtins.int:
        """
        A fixed number of matching requests to instrument per second, prior to applying the fixed rate. The reservoir is not used directly by services, but applies to all services using the rule collectively.
        """
        return pulumi.get(self, "reservoir_size")

    @_builtins.property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> _builtins.str:
        """
        Matches the ARN of the AWS resource on which the service runs.
        """
        return pulumi.get(self, "resource_arn")

    @_builtins.property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> _builtins.str:
        """
        Matches the name that the service uses to identify itself in segments.
        """
        return pulumi.get(self, "service_name")

    @_builtins.property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> _builtins.str:
        """
        Matches the origin that the service uses to identify its type in segments.
        """
        return pulumi.get(self, "service_type")

    @_builtins.property
    @pulumi.getter(name="urlPath")
    def url_path(self) -> _builtins.str:
        """
        Matches the path from a request URL.
        """
        return pulumi.get(self, "url_path")

    @_builtins.property
    @pulumi.getter
    def attributes(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Matches attributes derived from the request.
        """
        return pulumi.get(self, "attributes")

    @_builtins.property
    @pulumi.getter(name="ruleArn")
    def rule_arn(self) -> Optional[_builtins.str]:
        """
        The ARN of the sampling rule. Specify a rule by either name or ARN, but not both.

        > Specifying a sampling rule by name is recommended, as specifying by ARN will be deprecated in future.
        """
        return pulumi.get(self, "rule_arn")

    @_builtins.property
    @pulumi.getter(name="ruleName")
    def rule_name(self) -> Optional[_builtins.str]:
        """
        The name of the sampling rule. Specify a rule by either name or ARN, but not both.
        """
        return pulumi.get(self, "rule_name")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.int]:
        """
        The version of the sampling rule format (1)
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class SamplingRuleRecord(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "modifiedAt":
            suggest = "modified_at"
        elif key == "samplingRule":
            suggest = "sampling_rule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SamplingRuleRecord. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SamplingRuleRecord.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SamplingRuleRecord.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[_builtins.str] = None,
                 modified_at: Optional[_builtins.str] = None,
                 sampling_rule: Optional['outputs.SamplingRule'] = None):
        """
        :param _builtins.str created_at: When the rule was created, in Unix time seconds.
        :param _builtins.str modified_at: When the rule was modified, in Unix time seconds.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if modified_at is not None:
            pulumi.set(__self__, "modified_at", modified_at)
        if sampling_rule is not None:
            pulumi.set(__self__, "sampling_rule", sampling_rule)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        When the rule was created, in Unix time seconds.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="modifiedAt")
    def modified_at(self) -> Optional[_builtins.str]:
        """
        When the rule was modified, in Unix time seconds.
        """
        return pulumi.get(self, "modified_at")

    @_builtins.property
    @pulumi.getter(name="samplingRule")
    def sampling_rule(self) -> Optional['outputs.SamplingRule']:
        return pulumi.get(self, "sampling_rule")


@pulumi.output_type
class SamplingRuleUpdate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fixedRate":
            suggest = "fixed_rate"
        elif key == "httpMethod":
            suggest = "http_method"
        elif key == "reservoirSize":
            suggest = "reservoir_size"
        elif key == "resourceArn":
            suggest = "resource_arn"
        elif key == "ruleArn":
            suggest = "rule_arn"
        elif key == "ruleName":
            suggest = "rule_name"
        elif key == "serviceName":
            suggest = "service_name"
        elif key == "serviceType":
            suggest = "service_type"
        elif key == "urlPath":
            suggest = "url_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SamplingRuleUpdate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SamplingRuleUpdate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SamplingRuleUpdate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attributes: Optional[Mapping[str, _builtins.str]] = None,
                 fixed_rate: Optional[_builtins.float] = None,
                 host: Optional[_builtins.str] = None,
                 http_method: Optional[_builtins.str] = None,
                 priority: Optional[_builtins.int] = None,
                 reservoir_size: Optional[_builtins.int] = None,
                 resource_arn: Optional[_builtins.str] = None,
                 rule_arn: Optional[_builtins.str] = None,
                 rule_name: Optional[_builtins.str] = None,
                 service_name: Optional[_builtins.str] = None,
                 service_type: Optional[_builtins.str] = None,
                 url_path: Optional[_builtins.str] = None):
        """
        :param Mapping[str, _builtins.str] attributes: Matches attributes derived from the request.
        :param _builtins.float fixed_rate: The percentage of matching requests to instrument, after the reservoir is exhausted.
        :param _builtins.str host: Matches the hostname from a request URL.
        :param _builtins.str http_method: Matches the HTTP method from a request URL.
        :param _builtins.int priority: The priority of the sampling rule.
        :param _builtins.int reservoir_size: A fixed number of matching requests to instrument per second, prior to applying the fixed rate. The reservoir is not used directly by services, but applies to all services using the rule collectively.
        :param _builtins.str resource_arn: Matches the ARN of the AWS resource on which the service runs.
        :param _builtins.str service_name: Matches the name that the service uses to identify itself in segments.
        :param _builtins.str service_type: Matches the origin that the service uses to identify its type in segments.
        :param _builtins.str url_path: Matches the path from a request URL.
        """
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if fixed_rate is not None:
            pulumi.set(__self__, "fixed_rate", fixed_rate)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if reservoir_size is not None:
            pulumi.set(__self__, "reservoir_size", reservoir_size)
        if resource_arn is not None:
            pulumi.set(__self__, "resource_arn", resource_arn)
        if rule_arn is not None:
            pulumi.set(__self__, "rule_arn", rule_arn)
        if rule_name is not None:
            pulumi.set(__self__, "rule_name", rule_name)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)
        if service_type is not None:
            pulumi.set(__self__, "service_type", service_type)
        if url_path is not None:
            pulumi.set(__self__, "url_path", url_path)

    @_builtins.property
    @pulumi.getter
    def attributes(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Matches attributes derived from the request.
        """
        return pulumi.get(self, "attributes")

    @_builtins.property
    @pulumi.getter(name="fixedRate")
    def fixed_rate(self) -> Optional[_builtins.float]:
        """
        The percentage of matching requests to instrument, after the reservoir is exhausted.
        """
        return pulumi.get(self, "fixed_rate")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        Matches the hostname from a request URL.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional[_builtins.str]:
        """
        Matches the HTTP method from a request URL.
        """
        return pulumi.get(self, "http_method")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.int]:
        """
        The priority of the sampling rule.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="reservoirSize")
    def reservoir_size(self) -> Optional[_builtins.int]:
        """
        A fixed number of matching requests to instrument per second, prior to applying the fixed rate. The reservoir is not used directly by services, but applies to all services using the rule collectively.
        """
        return pulumi.get(self, "reservoir_size")

    @_builtins.property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> Optional[_builtins.str]:
        """
        Matches the ARN of the AWS resource on which the service runs.
        """
        return pulumi.get(self, "resource_arn")

    @_builtins.property
    @pulumi.getter(name="ruleArn")
    def rule_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "rule_arn")

    @_builtins.property
    @pulumi.getter(name="ruleName")
    def rule_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "rule_name")

    @_builtins.property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[_builtins.str]:
        """
        Matches the name that the service uses to identify itself in segments.
        """
        return pulumi.get(self, "service_name")

    @_builtins.property
    @pulumi.getter(name="serviceType")
    def service_type(self) -> Optional[_builtins.str]:
        """
        Matches the origin that the service uses to identify its type in segments.
        """
        return pulumi.get(self, "service_type")

    @_builtins.property
    @pulumi.getter(name="urlPath")
    def url_path(self) -> Optional[_builtins.str]:
        """
        Matches the path from a request URL.
        """
        return pulumi.get(self, "url_path")


