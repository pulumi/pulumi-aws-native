# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'AuthenticationModePropertiesArgs',
    'AuthenticationModePropertiesArgsDict',
    'GlobalReplicationGroupMemberArgs',
    'GlobalReplicationGroupMemberArgsDict',
    'GlobalReplicationGroupRegionalConfigurationArgs',
    'GlobalReplicationGroupRegionalConfigurationArgsDict',
    'GlobalReplicationGroupReshardingConfigurationArgs',
    'GlobalReplicationGroupReshardingConfigurationArgsDict',
    'ServerlessCacheCacheUsageLimitsArgs',
    'ServerlessCacheCacheUsageLimitsArgsDict',
    'ServerlessCacheDataStorageArgs',
    'ServerlessCacheDataStorageArgsDict',
    'ServerlessCacheEcpuPerSecondArgs',
    'ServerlessCacheEcpuPerSecondArgsDict',
    'ServerlessCacheEndpointArgs',
    'ServerlessCacheEndpointArgsDict',
]

MYPY = False

if not MYPY:
    class AuthenticationModePropertiesArgsDict(TypedDict):
        """
        Specifies the authentication mode to use. Below is an example of the possible JSON values:

        ```
        { Passwords: ["*****", "******"] // If Type is password.
        }
        ```
        """
        type: pulumi.Input['UserAuthenticationModePropertiesType']
        """
        Authentication Type
        """
        passwords: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Passwords used for this user account. You can create up to two passwords for each user.
        """
elif False:
    AuthenticationModePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthenticationModePropertiesArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['UserAuthenticationModePropertiesType'],
                 passwords: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        Specifies the authentication mode to use. Below is an example of the possible JSON values:

        ```
        { Passwords: ["*****", "******"] // If Type is password.
        }
        ```
        :param pulumi.Input['UserAuthenticationModePropertiesType'] type: Authentication Type
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] passwords: Passwords used for this user account. You can create up to two passwords for each user.
        """
        pulumi.set(__self__, "type", type)
        if passwords is not None:
            pulumi.set(__self__, "passwords", passwords)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['UserAuthenticationModePropertiesType']:
        """
        Authentication Type
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['UserAuthenticationModePropertiesType']):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def passwords(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Passwords used for this user account. You can create up to two passwords for each user.
        """
        return pulumi.get(self, "passwords")

    @passwords.setter
    def passwords(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "passwords", value)


if not MYPY:
    class GlobalReplicationGroupMemberArgsDict(TypedDict):
        replication_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Regionally unique identifier for the member i.e. ReplicationGroupId.
        """
        replication_group_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        The AWS region of the Global Datastore member.
        """
        role: NotRequired[pulumi.Input['GlobalReplicationGroupMemberRole']]
        """
        Indicates the role of the member, primary or secondary.
        """
elif False:
    GlobalReplicationGroupMemberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GlobalReplicationGroupMemberArgs:
    def __init__(__self__, *,
                 replication_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 replication_group_region: Optional[pulumi.Input[_builtins.str]] = None,
                 role: Optional[pulumi.Input['GlobalReplicationGroupMemberRole']] = None):
        """
        :param pulumi.Input[_builtins.str] replication_group_id: Regionally unique identifier for the member i.e. ReplicationGroupId.
        :param pulumi.Input[_builtins.str] replication_group_region: The AWS region of the Global Datastore member.
        :param pulumi.Input['GlobalReplicationGroupMemberRole'] role: Indicates the role of the member, primary or secondary.
        """
        if replication_group_id is not None:
            pulumi.set(__self__, "replication_group_id", replication_group_id)
        if replication_group_region is not None:
            pulumi.set(__self__, "replication_group_region", replication_group_region)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @_builtins.property
    @pulumi.getter(name="replicationGroupId")
    def replication_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Regionally unique identifier for the member i.e. ReplicationGroupId.
        """
        return pulumi.get(self, "replication_group_id")

    @replication_group_id.setter
    def replication_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "replication_group_id", value)

    @_builtins.property
    @pulumi.getter(name="replicationGroupRegion")
    def replication_group_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The AWS region of the Global Datastore member.
        """
        return pulumi.get(self, "replication_group_region")

    @replication_group_region.setter
    def replication_group_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "replication_group_region", value)

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input['GlobalReplicationGroupMemberRole']]:
        """
        Indicates the role of the member, primary or secondary.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input['GlobalReplicationGroupMemberRole']]):
        pulumi.set(self, "role", value)


if not MYPY:
    class GlobalReplicationGroupRegionalConfigurationArgsDict(TypedDict):
        replication_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The replication group id of the Global Datastore member.
        """
        replication_group_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        The AWS region of the Global Datastore member.
        """
        resharding_configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['GlobalReplicationGroupReshardingConfigurationArgsDict']]]]
        """
        A list of PreferredAvailabilityZones objects that specifies the configuration of a node group in the resharded cluster. 
        """
elif False:
    GlobalReplicationGroupRegionalConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GlobalReplicationGroupRegionalConfigurationArgs:
    def __init__(__self__, *,
                 replication_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 replication_group_region: Optional[pulumi.Input[_builtins.str]] = None,
                 resharding_configurations: Optional[pulumi.Input[Sequence[pulumi.Input['GlobalReplicationGroupReshardingConfigurationArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] replication_group_id: The replication group id of the Global Datastore member.
        :param pulumi.Input[_builtins.str] replication_group_region: The AWS region of the Global Datastore member.
        :param pulumi.Input[Sequence[pulumi.Input['GlobalReplicationGroupReshardingConfigurationArgs']]] resharding_configurations: A list of PreferredAvailabilityZones objects that specifies the configuration of a node group in the resharded cluster. 
        """
        if replication_group_id is not None:
            pulumi.set(__self__, "replication_group_id", replication_group_id)
        if replication_group_region is not None:
            pulumi.set(__self__, "replication_group_region", replication_group_region)
        if resharding_configurations is not None:
            pulumi.set(__self__, "resharding_configurations", resharding_configurations)

    @_builtins.property
    @pulumi.getter(name="replicationGroupId")
    def replication_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The replication group id of the Global Datastore member.
        """
        return pulumi.get(self, "replication_group_id")

    @replication_group_id.setter
    def replication_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "replication_group_id", value)

    @_builtins.property
    @pulumi.getter(name="replicationGroupRegion")
    def replication_group_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The AWS region of the Global Datastore member.
        """
        return pulumi.get(self, "replication_group_region")

    @replication_group_region.setter
    def replication_group_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "replication_group_region", value)

    @_builtins.property
    @pulumi.getter(name="reshardingConfigurations")
    def resharding_configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GlobalReplicationGroupReshardingConfigurationArgs']]]]:
        """
        A list of PreferredAvailabilityZones objects that specifies the configuration of a node group in the resharded cluster. 
        """
        return pulumi.get(self, "resharding_configurations")

    @resharding_configurations.setter
    def resharding_configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GlobalReplicationGroupReshardingConfigurationArgs']]]]):
        pulumi.set(self, "resharding_configurations", value)


if not MYPY:
    class GlobalReplicationGroupReshardingConfigurationArgsDict(TypedDict):
        node_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique identifier for the Node Group. This is either auto-generated by ElastiCache (4-digit id) or a user supplied id.
        """
        preferred_availability_zones: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of preferred availability zones for the nodes of new node groups.
        """
elif False:
    GlobalReplicationGroupReshardingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GlobalReplicationGroupReshardingConfigurationArgs:
    def __init__(__self__, *,
                 node_group_id: Optional[pulumi.Input[_builtins.str]] = None,
                 preferred_availability_zones: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] node_group_id: Unique identifier for the Node Group. This is either auto-generated by ElastiCache (4-digit id) or a user supplied id.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] preferred_availability_zones: A list of preferred availability zones for the nodes of new node groups.
        """
        if node_group_id is not None:
            pulumi.set(__self__, "node_group_id", node_group_id)
        if preferred_availability_zones is not None:
            pulumi.set(__self__, "preferred_availability_zones", preferred_availability_zones)

    @_builtins.property
    @pulumi.getter(name="nodeGroupId")
    def node_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique identifier for the Node Group. This is either auto-generated by ElastiCache (4-digit id) or a user supplied id.
        """
        return pulumi.get(self, "node_group_id")

    @node_group_id.setter
    def node_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "node_group_id", value)

    @_builtins.property
    @pulumi.getter(name="preferredAvailabilityZones")
    def preferred_availability_zones(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of preferred availability zones for the nodes of new node groups.
        """
        return pulumi.get(self, "preferred_availability_zones")

    @preferred_availability_zones.setter
    def preferred_availability_zones(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "preferred_availability_zones", value)


if not MYPY:
    class ServerlessCacheCacheUsageLimitsArgsDict(TypedDict):
        """
        The cache capacity limit of the Serverless Cache.
        """
        data_storage: NotRequired[pulumi.Input['ServerlessCacheDataStorageArgsDict']]
        """
        The maximum data storage limit in the cache, expressed in Gigabytes.
        """
        ecpu_per_second: NotRequired[pulumi.Input['ServerlessCacheEcpuPerSecondArgsDict']]
        """
        The number of ElastiCache Processing Units (ECPU) the cache can consume per second.
        """
elif False:
    ServerlessCacheCacheUsageLimitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessCacheCacheUsageLimitsArgs:
    def __init__(__self__, *,
                 data_storage: Optional[pulumi.Input['ServerlessCacheDataStorageArgs']] = None,
                 ecpu_per_second: Optional[pulumi.Input['ServerlessCacheEcpuPerSecondArgs']] = None):
        """
        The cache capacity limit of the Serverless Cache.
        :param pulumi.Input['ServerlessCacheDataStorageArgs'] data_storage: The maximum data storage limit in the cache, expressed in Gigabytes.
        :param pulumi.Input['ServerlessCacheEcpuPerSecondArgs'] ecpu_per_second: The number of ElastiCache Processing Units (ECPU) the cache can consume per second.
        """
        if data_storage is not None:
            pulumi.set(__self__, "data_storage", data_storage)
        if ecpu_per_second is not None:
            pulumi.set(__self__, "ecpu_per_second", ecpu_per_second)

    @_builtins.property
    @pulumi.getter(name="dataStorage")
    def data_storage(self) -> Optional[pulumi.Input['ServerlessCacheDataStorageArgs']]:
        """
        The maximum data storage limit in the cache, expressed in Gigabytes.
        """
        return pulumi.get(self, "data_storage")

    @data_storage.setter
    def data_storage(self, value: Optional[pulumi.Input['ServerlessCacheDataStorageArgs']]):
        pulumi.set(self, "data_storage", value)

    @_builtins.property
    @pulumi.getter(name="ecpuPerSecond")
    def ecpu_per_second(self) -> Optional[pulumi.Input['ServerlessCacheEcpuPerSecondArgs']]:
        """
        The number of ElastiCache Processing Units (ECPU) the cache can consume per second.
        """
        return pulumi.get(self, "ecpu_per_second")

    @ecpu_per_second.setter
    def ecpu_per_second(self, value: Optional[pulumi.Input['ServerlessCacheEcpuPerSecondArgs']]):
        pulumi.set(self, "ecpu_per_second", value)


if not MYPY:
    class ServerlessCacheDataStorageArgsDict(TypedDict):
        """
        The cached data capacity of the Serverless Cache.
        """
        unit: pulumi.Input['ServerlessCacheDataStorageUnit']
        """
        The unit of cached data capacity of the Serverless Cache.
        """
        maximum: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum cached data capacity of the Serverless Cache.
        """
        minimum: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum cached data capacity of the Serverless Cache.
        """
elif False:
    ServerlessCacheDataStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessCacheDataStorageArgs:
    def __init__(__self__, *,
                 unit: pulumi.Input['ServerlessCacheDataStorageUnit'],
                 maximum: Optional[pulumi.Input[_builtins.int]] = None,
                 minimum: Optional[pulumi.Input[_builtins.int]] = None):
        """
        The cached data capacity of the Serverless Cache.
        :param pulumi.Input['ServerlessCacheDataStorageUnit'] unit: The unit of cached data capacity of the Serverless Cache.
        :param pulumi.Input[_builtins.int] maximum: The maximum cached data capacity of the Serverless Cache.
        :param pulumi.Input[_builtins.int] minimum: The minimum cached data capacity of the Serverless Cache.
        """
        pulumi.set(__self__, "unit", unit)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> pulumi.Input['ServerlessCacheDataStorageUnit']:
        """
        The unit of cached data capacity of the Serverless Cache.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input['ServerlessCacheDataStorageUnit']):
        pulumi.set(self, "unit", value)

    @_builtins.property
    @pulumi.getter
    def maximum(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum cached data capacity of the Serverless Cache.
        """
        return pulumi.get(self, "maximum")

    @maximum.setter
    def maximum(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "maximum", value)

    @_builtins.property
    @pulumi.getter
    def minimum(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum cached data capacity of the Serverless Cache.
        """
        return pulumi.get(self, "minimum")

    @minimum.setter
    def minimum(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "minimum", value)


if not MYPY:
    class ServerlessCacheEcpuPerSecondArgsDict(TypedDict):
        """
        The ECPU per second of the Serverless Cache.
        """
        maximum: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum ECPU per second of the Serverless Cache.
        """
        minimum: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum ECPU per second of the Serverless Cache.
        """
elif False:
    ServerlessCacheEcpuPerSecondArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessCacheEcpuPerSecondArgs:
    def __init__(__self__, *,
                 maximum: Optional[pulumi.Input[_builtins.int]] = None,
                 minimum: Optional[pulumi.Input[_builtins.int]] = None):
        """
        The ECPU per second of the Serverless Cache.
        :param pulumi.Input[_builtins.int] maximum: The maximum ECPU per second of the Serverless Cache.
        :param pulumi.Input[_builtins.int] minimum: The minimum ECPU per second of the Serverless Cache.
        """
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)

    @_builtins.property
    @pulumi.getter
    def maximum(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum ECPU per second of the Serverless Cache.
        """
        return pulumi.get(self, "maximum")

    @maximum.setter
    def maximum(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "maximum", value)

    @_builtins.property
    @pulumi.getter
    def minimum(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum ECPU per second of the Serverless Cache.
        """
        return pulumi.get(self, "minimum")

    @minimum.setter
    def minimum(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "minimum", value)


if not MYPY:
    class ServerlessCacheEndpointArgsDict(TypedDict):
        """
        The address and the port.
        """
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Endpoint address.
        """
        port: NotRequired[pulumi.Input[_builtins.str]]
        """
        Endpoint port.
        """
elif False:
    ServerlessCacheEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerlessCacheEndpointArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The address and the port.
        :param pulumi.Input[_builtins.str] address: Endpoint address.
        :param pulumi.Input[_builtins.str] port: Endpoint port.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Endpoint address.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Endpoint port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port", value)


