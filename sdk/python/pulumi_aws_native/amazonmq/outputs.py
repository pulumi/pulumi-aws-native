# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'BrokerConfigurationId',
    'BrokerEncryptionOptions',
    'BrokerLdapServerMetadata',
    'BrokerLogList',
    'BrokerMaintenanceWindow',
    'BrokerUser',
]

@pulumi.output_type
class BrokerConfigurationId(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 revision: _builtins.int):
        """
        :param _builtins.str id: The unique ID that Amazon MQ generates for the configuration.
        :param _builtins.int revision: The revision number of the configuration.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "revision", revision)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The unique ID that Amazon MQ generates for the configuration.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def revision(self) -> _builtins.int:
        """
        The revision number of the configuration.
        """
        return pulumi.get(self, "revision")


@pulumi.output_type
class BrokerEncryptionOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "useAwsOwnedKey":
            suggest = "use_aws_owned_key"
        elif key == "kmsKeyId":
            suggest = "kms_key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrokerEncryptionOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrokerEncryptionOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrokerEncryptionOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 use_aws_owned_key: _builtins.bool,
                 kms_key_id: Optional[_builtins.str] = None):
        """
        :param _builtins.bool use_aws_owned_key: Enables the use of an AWS owned CMK using AWS KMS (KMS). Set to `true` by default, if no value is provided, for example, for RabbitMQ brokers.
        :param _builtins.str kms_key_id: The customer master key (CMK) to use for the A KMS (KMS). 
               This key is used to encrypt your data at rest. If not provided, Amazon MQ will use a default CMK to encrypt your data.
               The Key ARN is recommended so that drift can be detected,
               but a key ID or key alias will also be accepted for API compatibility reasons.
        """
        pulumi.set(__self__, "use_aws_owned_key", use_aws_owned_key)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)

    @_builtins.property
    @pulumi.getter(name="useAwsOwnedKey")
    def use_aws_owned_key(self) -> _builtins.bool:
        """
        Enables the use of an AWS owned CMK using AWS KMS (KMS). Set to `true` by default, if no value is provided, for example, for RabbitMQ brokers.
        """
        return pulumi.get(self, "use_aws_owned_key")

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        """
        The customer master key (CMK) to use for the A KMS (KMS). 
        This key is used to encrypt your data at rest. If not provided, Amazon MQ will use a default CMK to encrypt your data.
        The Key ARN is recommended so that drift can be detected,
        but a key ID or key alias will also be accepted for API compatibility reasons.
        """
        return pulumi.get(self, "kms_key_id")


@pulumi.output_type
class BrokerLdapServerMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleBase":
            suggest = "role_base"
        elif key == "roleSearchMatching":
            suggest = "role_search_matching"
        elif key == "serviceAccountUsername":
            suggest = "service_account_username"
        elif key == "userBase":
            suggest = "user_base"
        elif key == "userSearchMatching":
            suggest = "user_search_matching"
        elif key == "roleName":
            suggest = "role_name"
        elif key == "roleSearchSubtree":
            suggest = "role_search_subtree"
        elif key == "serviceAccountPassword":
            suggest = "service_account_password"
        elif key == "userRoleName":
            suggest = "user_role_name"
        elif key == "userSearchSubtree":
            suggest = "user_search_subtree"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrokerLdapServerMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrokerLdapServerMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrokerLdapServerMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hosts: Sequence[_builtins.str],
                 role_base: _builtins.str,
                 role_search_matching: _builtins.str,
                 service_account_username: _builtins.str,
                 user_base: _builtins.str,
                 user_search_matching: _builtins.str,
                 role_name: Optional[_builtins.str] = None,
                 role_search_subtree: Optional[_builtins.bool] = None,
                 service_account_password: Optional[_builtins.str] = None,
                 user_role_name: Optional[_builtins.str] = None,
                 user_search_subtree: Optional[_builtins.bool] = None):
        """
        :param Sequence[_builtins.str] hosts: Specifies the location of the LDAP server such as AWS Directory Service for Microsoft Active Directory . Optional failover server.
        :param _builtins.str role_base: The distinguished name of the node in the directory information tree (DIT) to search for roles or groups. For example, `ou=group` , `ou=corp` , `dc=corp` , `dc=example` , `dc=com` .
        :param _builtins.str role_search_matching: The LDAP search filter used to find roles within the roleBase. The distinguished name of the user matched by userSearchMatching is substituted into the `{0}` placeholder in the search filter. The client's username is substituted into the `{1}` placeholder. For example, if you set this option to `(member=uid={1})` for the user janedoe, the search filter becomes `(member=uid=janedoe)` after string substitution. It matches all role entries that have a member attribute equal to `uid=janedoe` under the subtree selected by the `RoleBases` .
        :param _builtins.str service_account_username: Service account username. A service account is an account in your LDAP server that has access to initiate a connection. For example, `cn=admin` , `ou=corp` , `dc=corp` , `dc=example` , `dc=com` .
        :param _builtins.str user_base: Select a particular subtree of the directory information tree (DIT) to search for user entries. The subtree is specified by a DN, which specifies the base node of the subtree. For example, by setting this option to `ou=Users` , `ou=corp` , `dc=corp` , `dc=example` , `dc=com` , the search for user entries is restricted to the subtree beneath `ou=Users` , `ou=corp` , `dc=corp` , `dc=example` , `dc=com` .
        :param _builtins.str user_search_matching: The LDAP search filter used to find users within the `userBase` . The client's username is substituted into the `{0}` placeholder in the search filter. For example, if this option is set to `(uid={0})` and the received username is `janedoe` , the search filter becomes `(uid=janedoe)` after string substitution. It will result in matching an entry like `uid=janedoe` , `ou=Users` , `ou=corp` , `dc=corp` , `dc=example` , `dc=com` .
        :param _builtins.str role_name: The group name attribute in a role entry whose value is the name of that role. For example, you can specify `cn` for a group entry's common name. If authentication succeeds, then the user is assigned the the value of the `cn` attribute for each role entry that they are a member of.
        :param _builtins.bool role_search_subtree: The directory search scope for the role. If set to true, scope is to search the entire subtree.
        :param _builtins.str service_account_password: Service account password. A service account is an account in your LDAP server that has access to initiate a connection. For example, `cn=admin` , `dc=corp` , `dc=example` , `dc=com` .
        :param _builtins.str user_role_name: The name of the LDAP attribute in the user's directory entry for the user's group membership. In some cases, user roles may be identified by the value of an attribute in the user's directory entry. The `UserRoleName` option allows you to provide the name of this attribute.
        :param _builtins.bool user_search_subtree: The directory search scope for the user. If set to true, scope is to search the entire subtree.
        """
        pulumi.set(__self__, "hosts", hosts)
        pulumi.set(__self__, "role_base", role_base)
        pulumi.set(__self__, "role_search_matching", role_search_matching)
        pulumi.set(__self__, "service_account_username", service_account_username)
        pulumi.set(__self__, "user_base", user_base)
        pulumi.set(__self__, "user_search_matching", user_search_matching)
        if role_name is not None:
            pulumi.set(__self__, "role_name", role_name)
        if role_search_subtree is not None:
            pulumi.set(__self__, "role_search_subtree", role_search_subtree)
        if service_account_password is not None:
            pulumi.set(__self__, "service_account_password", service_account_password)
        if user_role_name is not None:
            pulumi.set(__self__, "user_role_name", user_role_name)
        if user_search_subtree is not None:
            pulumi.set(__self__, "user_search_subtree", user_search_subtree)

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Sequence[_builtins.str]:
        """
        Specifies the location of the LDAP server such as AWS Directory Service for Microsoft Active Directory . Optional failover server.
        """
        return pulumi.get(self, "hosts")

    @_builtins.property
    @pulumi.getter(name="roleBase")
    def role_base(self) -> _builtins.str:
        """
        The distinguished name of the node in the directory information tree (DIT) to search for roles or groups. For example, `ou=group` , `ou=corp` , `dc=corp` , `dc=example` , `dc=com` .
        """
        return pulumi.get(self, "role_base")

    @_builtins.property
    @pulumi.getter(name="roleSearchMatching")
    def role_search_matching(self) -> _builtins.str:
        """
        The LDAP search filter used to find roles within the roleBase. The distinguished name of the user matched by userSearchMatching is substituted into the `{0}` placeholder in the search filter. The client's username is substituted into the `{1}` placeholder. For example, if you set this option to `(member=uid={1})` for the user janedoe, the search filter becomes `(member=uid=janedoe)` after string substitution. It matches all role entries that have a member attribute equal to `uid=janedoe` under the subtree selected by the `RoleBases` .
        """
        return pulumi.get(self, "role_search_matching")

    @_builtins.property
    @pulumi.getter(name="serviceAccountUsername")
    def service_account_username(self) -> _builtins.str:
        """
        Service account username. A service account is an account in your LDAP server that has access to initiate a connection. For example, `cn=admin` , `ou=corp` , `dc=corp` , `dc=example` , `dc=com` .
        """
        return pulumi.get(self, "service_account_username")

    @_builtins.property
    @pulumi.getter(name="userBase")
    def user_base(self) -> _builtins.str:
        """
        Select a particular subtree of the directory information tree (DIT) to search for user entries. The subtree is specified by a DN, which specifies the base node of the subtree. For example, by setting this option to `ou=Users` , `ou=corp` , `dc=corp` , `dc=example` , `dc=com` , the search for user entries is restricted to the subtree beneath `ou=Users` , `ou=corp` , `dc=corp` , `dc=example` , `dc=com` .
        """
        return pulumi.get(self, "user_base")

    @_builtins.property
    @pulumi.getter(name="userSearchMatching")
    def user_search_matching(self) -> _builtins.str:
        """
        The LDAP search filter used to find users within the `userBase` . The client's username is substituted into the `{0}` placeholder in the search filter. For example, if this option is set to `(uid={0})` and the received username is `janedoe` , the search filter becomes `(uid=janedoe)` after string substitution. It will result in matching an entry like `uid=janedoe` , `ou=Users` , `ou=corp` , `dc=corp` , `dc=example` , `dc=com` .
        """
        return pulumi.get(self, "user_search_matching")

    @_builtins.property
    @pulumi.getter(name="roleName")
    def role_name(self) -> Optional[_builtins.str]:
        """
        The group name attribute in a role entry whose value is the name of that role. For example, you can specify `cn` for a group entry's common name. If authentication succeeds, then the user is assigned the the value of the `cn` attribute for each role entry that they are a member of.
        """
        return pulumi.get(self, "role_name")

    @_builtins.property
    @pulumi.getter(name="roleSearchSubtree")
    def role_search_subtree(self) -> Optional[_builtins.bool]:
        """
        The directory search scope for the role. If set to true, scope is to search the entire subtree.
        """
        return pulumi.get(self, "role_search_subtree")

    @_builtins.property
    @pulumi.getter(name="serviceAccountPassword")
    def service_account_password(self) -> Optional[_builtins.str]:
        """
        Service account password. A service account is an account in your LDAP server that has access to initiate a connection. For example, `cn=admin` , `dc=corp` , `dc=example` , `dc=com` .
        """
        return pulumi.get(self, "service_account_password")

    @_builtins.property
    @pulumi.getter(name="userRoleName")
    def user_role_name(self) -> Optional[_builtins.str]:
        """
        The name of the LDAP attribute in the user's directory entry for the user's group membership. In some cases, user roles may be identified by the value of an attribute in the user's directory entry. The `UserRoleName` option allows you to provide the name of this attribute.
        """
        return pulumi.get(self, "user_role_name")

    @_builtins.property
    @pulumi.getter(name="userSearchSubtree")
    def user_search_subtree(self) -> Optional[_builtins.bool]:
        """
        The directory search scope for the user. If set to true, scope is to search the entire subtree.
        """
        return pulumi.get(self, "user_search_subtree")


@pulumi.output_type
class BrokerLogList(dict):
    def __init__(__self__, *,
                 audit: Optional[_builtins.bool] = None,
                 general: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool audit: Enables audit logging. Every user management action made using JMX or the ActiveMQ Web Console is logged. Does not apply to RabbitMQ brokers.
        :param _builtins.bool general: Enables general logging.
        """
        if audit is not None:
            pulumi.set(__self__, "audit", audit)
        if general is not None:
            pulumi.set(__self__, "general", general)

    @_builtins.property
    @pulumi.getter
    def audit(self) -> Optional[_builtins.bool]:
        """
        Enables audit logging. Every user management action made using JMX or the ActiveMQ Web Console is logged. Does not apply to RabbitMQ brokers.
        """
        return pulumi.get(self, "audit")

    @_builtins.property
    @pulumi.getter
    def general(self) -> Optional[_builtins.bool]:
        """
        Enables general logging.
        """
        return pulumi.get(self, "general")


@pulumi.output_type
class BrokerMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dayOfWeek":
            suggest = "day_of_week"
        elif key == "timeOfDay":
            suggest = "time_of_day"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrokerMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrokerMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrokerMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 day_of_week: _builtins.str,
                 time_of_day: _builtins.str,
                 time_zone: _builtins.str):
        """
        :param Union['BrokerMaintenanceWindowDayOfWeek', _builtins.str] day_of_week: _Allowed Values_: <code>MONDAY</code> | <code>TUESDAY</code> | <code>WEDNESDAY</code> | <code>THURSDAY</code> | <code>FRIDAY</code> | <code>SATURDAY</code> | <code>SUNDAY</code>
        :param _builtins.str time_of_day: The time, in 24-hour format, and use only numbers separated by a colon, HH:MM or HH:MM:SS. Example: 13:05.
               When writing YAML this may need to be quoted to prevent a timestamp being read and converted to a number of minutes or seconds.
        :param _builtins.str time_zone: The time zone, UTC by default, in either the Country/City format, or the UTC offset format.
        """
        pulumi.set(__self__, "day_of_week", day_of_week)
        pulumi.set(__self__, "time_of_day", time_of_day)
        pulumi.set(__self__, "time_zone", time_zone)

    @_builtins.property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> _builtins.str:
        """
        _Allowed Values_: <code>MONDAY</code> | <code>TUESDAY</code> | <code>WEDNESDAY</code> | <code>THURSDAY</code> | <code>FRIDAY</code> | <code>SATURDAY</code> | <code>SUNDAY</code>
        """
        return pulumi.get(self, "day_of_week")

    @_builtins.property
    @pulumi.getter(name="timeOfDay")
    def time_of_day(self) -> _builtins.str:
        """
        The time, in 24-hour format, and use only numbers separated by a colon, HH:MM or HH:MM:SS. Example: 13:05.
        When writing YAML this may need to be quoted to prevent a timestamp being read and converted to a number of minutes or seconds.
        """
        return pulumi.get(self, "time_of_day")

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> _builtins.str:
        """
        The time zone, UTC by default, in either the Country/City format, or the UTC offset format.
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class BrokerUser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consoleAccess":
            suggest = "console_access"
        elif key == "replicationUser":
            suggest = "replication_user"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BrokerUser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BrokerUser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BrokerUser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password: _builtins.str,
                 username: _builtins.str,
                 console_access: Optional[_builtins.bool] = None,
                 groups: Optional[Sequence[_builtins.str]] = None,
                 replication_user: Optional[_builtins.bool] = None):
        """
        :param _builtins.str password: The password of the user. This value must be at least 12 characters long, must contain at least 4 unique characters, and must not contain commas, colons, or equal signs (,:=).
        :param _builtins.str username: The username of the broker user. For Amazon MQ for ActiveMQ brokers, this value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). For Amazon MQ for RabbitMQ brokers, this value can contain only alphanumeric characters, dashes, periods, underscores (- . _). This value must not contain a tilde (~) character. Amazon MQ prohibts using guest as a valid usename. This value must be 2-100 characters long.
               
               > Do not add personally identifiable information (PII) or other confidential or sensitive information in broker usernames. Broker usernames are accessible to other AWS services, including CloudWatch Logs . Broker usernames are not intended to be used for private or sensitive data.
        :param _builtins.bool console_access: Enables access to the ActiveMQ web console for the ActiveMQ user. Does not apply to RabbitMQ brokers.
        :param Sequence[_builtins.str] groups: The list of groups (20 maximum) to which the ActiveMQ user belongs. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long. Does not apply to RabbitMQ brokers.
        :param _builtins.bool replication_user: Defines if this user is intended for CRDR replication purposes.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        if console_access is not None:
            pulumi.set(__self__, "console_access", console_access)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if replication_user is not None:
            pulumi.set(__self__, "replication_user", replication_user)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        The password of the user. This value must be at least 12 characters long, must contain at least 4 unique characters, and must not contain commas, colons, or equal signs (,:=).
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        The username of the broker user. For Amazon MQ for ActiveMQ brokers, this value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). For Amazon MQ for RabbitMQ brokers, this value can contain only alphanumeric characters, dashes, periods, underscores (- . _). This value must not contain a tilde (~) character. Amazon MQ prohibts using guest as a valid usename. This value must be 2-100 characters long.

        > Do not add personally identifiable information (PII) or other confidential or sensitive information in broker usernames. Broker usernames are accessible to other AWS services, including CloudWatch Logs . Broker usernames are not intended to be used for private or sensitive data.
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter(name="consoleAccess")
    def console_access(self) -> Optional[_builtins.bool]:
        """
        Enables access to the ActiveMQ web console for the ActiveMQ user. Does not apply to RabbitMQ brokers.
        """
        return pulumi.get(self, "console_access")

    @_builtins.property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        The list of groups (20 maximum) to which the ActiveMQ user belongs. This value can contain only alphanumeric characters, dashes, periods, underscores, and tildes (- . _ ~). This value must be 2-100 characters long. Does not apply to RabbitMQ brokers.
        """
        return pulumi.get(self, "groups")

    @_builtins.property
    @pulumi.getter(name="replicationUser")
    def replication_user(self) -> Optional[_builtins.bool]:
        """
        Defines if this user is intended for CRDR replication purposes.
        """
        return pulumi.get(self, "replication_user")


