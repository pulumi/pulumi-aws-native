# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'ApplicationAutoStartConfigurationArgs',
    'ApplicationAutoStartConfigurationArgsDict',
    'ApplicationAutoStopConfigurationArgs',
    'ApplicationAutoStopConfigurationArgsDict',
    'ApplicationCloudWatchLoggingConfigurationArgs',
    'ApplicationCloudWatchLoggingConfigurationArgsDict',
    'ApplicationConfigurationObjectArgs',
    'ApplicationConfigurationObjectArgsDict',
    'ApplicationIdentityCenterConfigurationArgs',
    'ApplicationIdentityCenterConfigurationArgsDict',
    'ApplicationImageConfigurationInputArgs',
    'ApplicationImageConfigurationInputArgsDict',
    'ApplicationInitialCapacityConfigKeyValuePairArgs',
    'ApplicationInitialCapacityConfigKeyValuePairArgsDict',
    'ApplicationInitialCapacityConfigArgs',
    'ApplicationInitialCapacityConfigArgsDict',
    'ApplicationInteractiveConfigurationArgs',
    'ApplicationInteractiveConfigurationArgsDict',
    'ApplicationLogTypeMapKeyValuePairArgs',
    'ApplicationLogTypeMapKeyValuePairArgsDict',
    'ApplicationManagedPersistenceMonitoringConfigurationArgs',
    'ApplicationManagedPersistenceMonitoringConfigurationArgsDict',
    'ApplicationMaximumAllowedResourcesArgs',
    'ApplicationMaximumAllowedResourcesArgsDict',
    'ApplicationMonitoringConfigurationArgs',
    'ApplicationMonitoringConfigurationArgsDict',
    'ApplicationNetworkConfigurationArgs',
    'ApplicationNetworkConfigurationArgsDict',
    'ApplicationPrometheusMonitoringConfigurationArgs',
    'ApplicationPrometheusMonitoringConfigurationArgsDict',
    'ApplicationS3MonitoringConfigurationArgs',
    'ApplicationS3MonitoringConfigurationArgsDict',
    'ApplicationSchedulerConfigurationArgs',
    'ApplicationSchedulerConfigurationArgsDict',
    'ApplicationWorkerConfigurationArgs',
    'ApplicationWorkerConfigurationArgsDict',
    'ApplicationWorkerTypeSpecificationInputArgs',
    'ApplicationWorkerTypeSpecificationInputArgsDict',
]

MYPY = False

if not MYPY:
    class ApplicationAutoStartConfigurationArgsDict(TypedDict):
        """
        Configuration for Auto Start of Application
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set to true, the Application will automatically start. Defaults to true.
        """
elif False:
    ApplicationAutoStartConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationAutoStartConfigurationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        Configuration for Auto Start of Application
        :param pulumi.Input[_builtins.bool] enabled: If set to true, the Application will automatically start. Defaults to true.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set to true, the Application will automatically start. Defaults to true.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ApplicationAutoStopConfigurationArgsDict(TypedDict):
        """
        Configuration for Auto Stop of Application
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set to true, the Application will automatically stop after being idle. Defaults to true.
        """
        idle_timeout_minutes: NotRequired[pulumi.Input[_builtins.int]]
        """
        The amount of time [in minutes] to wait before auto stopping the Application when idle. Defaults to 15 minutes.
        """
elif False:
    ApplicationAutoStopConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationAutoStopConfigurationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 idle_timeout_minutes: Optional[pulumi.Input[_builtins.int]] = None):
        """
        Configuration for Auto Stop of Application
        :param pulumi.Input[_builtins.bool] enabled: If set to true, the Application will automatically stop after being idle. Defaults to true.
        :param pulumi.Input[_builtins.int] idle_timeout_minutes: The amount of time [in minutes] to wait before auto stopping the Application when idle. Defaults to 15 minutes.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if idle_timeout_minutes is not None:
            pulumi.set(__self__, "idle_timeout_minutes", idle_timeout_minutes)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set to true, the Application will automatically stop after being idle. Defaults to true.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="idleTimeoutMinutes")
    def idle_timeout_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The amount of time [in minutes] to wait before auto stopping the Application when idle. Defaults to 15 minutes.
        """
        return pulumi.get(self, "idle_timeout_minutes")

    @idle_timeout_minutes.setter
    def idle_timeout_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "idle_timeout_minutes", value)


if not MYPY:
    class ApplicationCloudWatchLoggingConfigurationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set to false, CloudWatch logging will be turned off. Defaults to false.
        """
        encryption_key_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        KMS key ARN to encrypt the logs stored in given CloudWatch log-group.
        """
        log_group_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Log-group name to produce log-streams on CloudWatch. If undefined, logs will be produced in a default log-group /aws/emr-serverless
        """
        log_stream_name_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Log-stream name prefix by which log-stream names will start in the CloudWatch Log-group.
        """
        log_type_map: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApplicationLogTypeMapKeyValuePairArgsDict']]]]
        """
        The specific log-streams which need to be uploaded to CloudWatch.
        """
elif False:
    ApplicationCloudWatchLoggingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationCloudWatchLoggingConfigurationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 encryption_key_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 log_group_name: Optional[pulumi.Input[_builtins.str]] = None,
                 log_stream_name_prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 log_type_map: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationLogTypeMapKeyValuePairArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If set to false, CloudWatch logging will be turned off. Defaults to false.
        :param pulumi.Input[_builtins.str] encryption_key_arn: KMS key ARN to encrypt the logs stored in given CloudWatch log-group.
        :param pulumi.Input[_builtins.str] log_group_name: Log-group name to produce log-streams on CloudWatch. If undefined, logs will be produced in a default log-group /aws/emr-serverless
        :param pulumi.Input[_builtins.str] log_stream_name_prefix: Log-stream name prefix by which log-stream names will start in the CloudWatch Log-group.
        :param pulumi.Input[Sequence[pulumi.Input['ApplicationLogTypeMapKeyValuePairArgs']]] log_type_map: The specific log-streams which need to be uploaded to CloudWatch.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if encryption_key_arn is not None:
            pulumi.set(__self__, "encryption_key_arn", encryption_key_arn)
        if log_group_name is not None:
            pulumi.set(__self__, "log_group_name", log_group_name)
        if log_stream_name_prefix is not None:
            pulumi.set(__self__, "log_stream_name_prefix", log_stream_name_prefix)
        if log_type_map is not None:
            pulumi.set(__self__, "log_type_map", log_type_map)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set to false, CloudWatch logging will be turned off. Defaults to false.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="encryptionKeyArn")
    def encryption_key_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        KMS key ARN to encrypt the logs stored in given CloudWatch log-group.
        """
        return pulumi.get(self, "encryption_key_arn")

    @encryption_key_arn.setter
    def encryption_key_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "encryption_key_arn", value)

    @_builtins.property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Log-group name to produce log-streams on CloudWatch. If undefined, logs will be produced in a default log-group /aws/emr-serverless
        """
        return pulumi.get(self, "log_group_name")

    @log_group_name.setter
    def log_group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_group_name", value)

    @_builtins.property
    @pulumi.getter(name="logStreamNamePrefix")
    def log_stream_name_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Log-stream name prefix by which log-stream names will start in the CloudWatch Log-group.
        """
        return pulumi.get(self, "log_stream_name_prefix")

    @log_stream_name_prefix.setter
    def log_stream_name_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_stream_name_prefix", value)

    @_builtins.property
    @pulumi.getter(name="logTypeMap")
    def log_type_map(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationLogTypeMapKeyValuePairArgs']]]]:
        """
        The specific log-streams which need to be uploaded to CloudWatch.
        """
        return pulumi.get(self, "log_type_map")

    @log_type_map.setter
    def log_type_map(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationLogTypeMapKeyValuePairArgs']]]]):
        pulumi.set(self, "log_type_map", value)


if not MYPY:
    class ApplicationConfigurationObjectArgsDict(TypedDict):
        """
        Configuration for a JobRun.
        """
        classification: pulumi.Input[_builtins.str]
        """
        String with a maximum length of 1024.
        """
        configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApplicationConfigurationObjectArgsDict']]]]
        properties: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
elif False:
    ApplicationConfigurationObjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationConfigurationObjectArgs:
    def __init__(__self__, *,
                 classification: pulumi.Input[_builtins.str],
                 configurations: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationConfigurationObjectArgs']]]] = None,
                 properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        Configuration for a JobRun.
        :param pulumi.Input[_builtins.str] classification: String with a maximum length of 1024.
        """
        pulumi.set(__self__, "classification", classification)
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @_builtins.property
    @pulumi.getter
    def classification(self) -> pulumi.Input[_builtins.str]:
        """
        String with a maximum length of 1024.
        """
        return pulumi.get(self, "classification")

    @classification.setter
    def classification(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "classification", value)

    @_builtins.property
    @pulumi.getter
    def configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationConfigurationObjectArgs']]]]:
        return pulumi.get(self, "configurations")

    @configurations.setter
    def configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApplicationConfigurationObjectArgs']]]]):
        pulumi.set(self, "configurations", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "properties", value)


if not MYPY:
    class ApplicationIdentityCenterConfigurationArgsDict(TypedDict):
        """
        The IAM IdentityCenter configuration for trusted-identity-propagation on this application. Supported with release labels emr-7.8.0 and above.
        """
        identity_center_instance_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IAM IdentityCenter instance arn
        """
elif False:
    ApplicationIdentityCenterConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationIdentityCenterConfigurationArgs:
    def __init__(__self__, *,
                 identity_center_instance_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The IAM IdentityCenter configuration for trusted-identity-propagation on this application. Supported with release labels emr-7.8.0 and above.
        :param pulumi.Input[_builtins.str] identity_center_instance_arn: The IAM IdentityCenter instance arn
        """
        if identity_center_instance_arn is not None:
            pulumi.set(__self__, "identity_center_instance_arn", identity_center_instance_arn)

    @_builtins.property
    @pulumi.getter(name="identityCenterInstanceArn")
    def identity_center_instance_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IAM IdentityCenter instance arn
        """
        return pulumi.get(self, "identity_center_instance_arn")

    @identity_center_instance_arn.setter
    def identity_center_instance_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity_center_instance_arn", value)


if not MYPY:
    class ApplicationImageConfigurationInputArgsDict(TypedDict):
        """
        The image configuration.
        """
        image_uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URI of an image in the Amazon ECR registry. This field is required when you create a new application. If you leave this field blank in an update, Amazon EMR will remove the image configuration.
        """
elif False:
    ApplicationImageConfigurationInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationImageConfigurationInputArgs:
    def __init__(__self__, *,
                 image_uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The image configuration.
        :param pulumi.Input[_builtins.str] image_uri: The URI of an image in the Amazon ECR registry. This field is required when you create a new application. If you leave this field blank in an update, Amazon EMR will remove the image configuration.
        """
        if image_uri is not None:
            pulumi.set(__self__, "image_uri", image_uri)

    @_builtins.property
    @pulumi.getter(name="imageUri")
    def image_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URI of an image in the Amazon ECR registry. This field is required when you create a new application. If you leave this field blank in an update, Amazon EMR will remove the image configuration.
        """
        return pulumi.get(self, "image_uri")

    @image_uri.setter
    def image_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image_uri", value)


if not MYPY:
    class ApplicationInitialCapacityConfigKeyValuePairArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        Worker type for an analytics framework.
        """
        value: pulumi.Input['ApplicationInitialCapacityConfigArgsDict']
elif False:
    ApplicationInitialCapacityConfigKeyValuePairArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationInitialCapacityConfigKeyValuePairArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input['ApplicationInitialCapacityConfigArgs']):
        """
        :param pulumi.Input[_builtins.str] key: Worker type for an analytics framework.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Worker type for an analytics framework.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input['ApplicationInitialCapacityConfigArgs']:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input['ApplicationInitialCapacityConfigArgs']):
        pulumi.set(self, "value", value)


if not MYPY:
    class ApplicationInitialCapacityConfigArgsDict(TypedDict):
        worker_configuration: pulumi.Input['ApplicationWorkerConfigurationArgsDict']
        worker_count: pulumi.Input[_builtins.int]
        """
        Initial count of workers to be initialized when an Application is started. This count will be continued to be maintained until the Application is stopped
        """
elif False:
    ApplicationInitialCapacityConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationInitialCapacityConfigArgs:
    def __init__(__self__, *,
                 worker_configuration: pulumi.Input['ApplicationWorkerConfigurationArgs'],
                 worker_count: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] worker_count: Initial count of workers to be initialized when an Application is started. This count will be continued to be maintained until the Application is stopped
        """
        pulumi.set(__self__, "worker_configuration", worker_configuration)
        pulumi.set(__self__, "worker_count", worker_count)

    @_builtins.property
    @pulumi.getter(name="workerConfiguration")
    def worker_configuration(self) -> pulumi.Input['ApplicationWorkerConfigurationArgs']:
        return pulumi.get(self, "worker_configuration")

    @worker_configuration.setter
    def worker_configuration(self, value: pulumi.Input['ApplicationWorkerConfigurationArgs']):
        pulumi.set(self, "worker_configuration", value)

    @_builtins.property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> pulumi.Input[_builtins.int]:
        """
        Initial count of workers to be initialized when an Application is started. This count will be continued to be maintained until the Application is stopped
        """
        return pulumi.get(self, "worker_count")

    @worker_count.setter
    def worker_count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "worker_count", value)


if not MYPY:
    class ApplicationInteractiveConfigurationArgsDict(TypedDict):
        livy_endpoint_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables an Apache Livy endpoint that you can connect to and run interactive jobs
        """
        studio_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enabled you to connect an Application to Amazon EMR Studio to run interactive workloads in a notebook
        """
elif False:
    ApplicationInteractiveConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationInteractiveConfigurationArgs:
    def __init__(__self__, *,
                 livy_endpoint_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 studio_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] livy_endpoint_enabled: Enables an Apache Livy endpoint that you can connect to and run interactive jobs
        :param pulumi.Input[_builtins.bool] studio_enabled: Enabled you to connect an Application to Amazon EMR Studio to run interactive workloads in a notebook
        """
        if livy_endpoint_enabled is not None:
            pulumi.set(__self__, "livy_endpoint_enabled", livy_endpoint_enabled)
        if studio_enabled is not None:
            pulumi.set(__self__, "studio_enabled", studio_enabled)

    @_builtins.property
    @pulumi.getter(name="livyEndpointEnabled")
    def livy_endpoint_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables an Apache Livy endpoint that you can connect to and run interactive jobs
        """
        return pulumi.get(self, "livy_endpoint_enabled")

    @livy_endpoint_enabled.setter
    def livy_endpoint_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "livy_endpoint_enabled", value)

    @_builtins.property
    @pulumi.getter(name="studioEnabled")
    def studio_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enabled you to connect an Application to Amazon EMR Studio to run interactive workloads in a notebook
        """
        return pulumi.get(self, "studio_enabled")

    @studio_enabled.setter
    def studio_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "studio_enabled", value)


if not MYPY:
    class ApplicationLogTypeMapKeyValuePairArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    ApplicationLogTypeMapKeyValuePairArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationLogTypeMapKeyValuePairArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ApplicationManagedPersistenceMonitoringConfigurationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set to false, managed logging will be turned off. Defaults to true.
        """
        encryption_key_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        KMS key ARN to encrypt the logs stored in managed persistence
        """
elif False:
    ApplicationManagedPersistenceMonitoringConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationManagedPersistenceMonitoringConfigurationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 encryption_key_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If set to false, managed logging will be turned off. Defaults to true.
        :param pulumi.Input[_builtins.str] encryption_key_arn: KMS key ARN to encrypt the logs stored in managed persistence
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if encryption_key_arn is not None:
            pulumi.set(__self__, "encryption_key_arn", encryption_key_arn)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set to false, managed logging will be turned off. Defaults to true.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="encryptionKeyArn")
    def encryption_key_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        KMS key ARN to encrypt the logs stored in managed persistence
        """
        return pulumi.get(self, "encryption_key_arn")

    @encryption_key_arn.setter
    def encryption_key_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "encryption_key_arn", value)


if not MYPY:
    class ApplicationMaximumAllowedResourcesArgsDict(TypedDict):
        cpu: pulumi.Input[_builtins.str]
        """
        Per worker CPU resource. vCPU is the only supported unit and specifying vCPU is optional.
        """
        memory: pulumi.Input[_builtins.str]
        """
        Per worker memory resource. GB is the only supported unit and specifying GB is optional.
        """
        disk: NotRequired[pulumi.Input[_builtins.str]]
        """
        Per worker Disk resource. GB is the only supported unit and specifying GB is optional
        """
elif False:
    ApplicationMaximumAllowedResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationMaximumAllowedResourcesArgs:
    def __init__(__self__, *,
                 cpu: pulumi.Input[_builtins.str],
                 memory: pulumi.Input[_builtins.str],
                 disk: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cpu: Per worker CPU resource. vCPU is the only supported unit and specifying vCPU is optional.
        :param pulumi.Input[_builtins.str] memory: Per worker memory resource. GB is the only supported unit and specifying GB is optional.
        :param pulumi.Input[_builtins.str] disk: Per worker Disk resource. GB is the only supported unit and specifying GB is optional
        """
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "memory", memory)
        if disk is not None:
            pulumi.set(__self__, "disk", disk)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> pulumi.Input[_builtins.str]:
        """
        Per worker CPU resource. vCPU is the only supported unit and specifying vCPU is optional.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cpu", value)

    @_builtins.property
    @pulumi.getter
    def memory(self) -> pulumi.Input[_builtins.str]:
        """
        Per worker memory resource. GB is the only supported unit and specifying GB is optional.
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "memory", value)

    @_builtins.property
    @pulumi.getter
    def disk(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Per worker Disk resource. GB is the only supported unit and specifying GB is optional
        """
        return pulumi.get(self, "disk")

    @disk.setter
    def disk(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "disk", value)


if not MYPY:
    class ApplicationMonitoringConfigurationArgsDict(TypedDict):
        """
        Monitoring configuration for batch and interactive JobRun.
        """
        cloud_watch_logging_configuration: NotRequired[pulumi.Input['ApplicationCloudWatchLoggingConfigurationArgsDict']]
        """
        CloudWatch logging configurations for a JobRun.
        """
        managed_persistence_monitoring_configuration: NotRequired[pulumi.Input['ApplicationManagedPersistenceMonitoringConfigurationArgsDict']]
        """
        Managed log persistence configurations for a JobRun.
        """
        prometheus_monitoring_configuration: NotRequired[pulumi.Input['ApplicationPrometheusMonitoringConfigurationArgsDict']]
        """
        Prometheus monitoring configurations for a JobRun.
        """
        s3_monitoring_configuration: NotRequired[pulumi.Input['ApplicationS3MonitoringConfigurationArgsDict']]
        """
        S3 monitoring configurations for a JobRun.
        """
elif False:
    ApplicationMonitoringConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationMonitoringConfigurationArgs:
    def __init__(__self__, *,
                 cloud_watch_logging_configuration: Optional[pulumi.Input['ApplicationCloudWatchLoggingConfigurationArgs']] = None,
                 managed_persistence_monitoring_configuration: Optional[pulumi.Input['ApplicationManagedPersistenceMonitoringConfigurationArgs']] = None,
                 prometheus_monitoring_configuration: Optional[pulumi.Input['ApplicationPrometheusMonitoringConfigurationArgs']] = None,
                 s3_monitoring_configuration: Optional[pulumi.Input['ApplicationS3MonitoringConfigurationArgs']] = None):
        """
        Monitoring configuration for batch and interactive JobRun.
        :param pulumi.Input['ApplicationCloudWatchLoggingConfigurationArgs'] cloud_watch_logging_configuration: CloudWatch logging configurations for a JobRun.
        :param pulumi.Input['ApplicationManagedPersistenceMonitoringConfigurationArgs'] managed_persistence_monitoring_configuration: Managed log persistence configurations for a JobRun.
        :param pulumi.Input['ApplicationPrometheusMonitoringConfigurationArgs'] prometheus_monitoring_configuration: Prometheus monitoring configurations for a JobRun.
        :param pulumi.Input['ApplicationS3MonitoringConfigurationArgs'] s3_monitoring_configuration: S3 monitoring configurations for a JobRun.
        """
        if cloud_watch_logging_configuration is not None:
            pulumi.set(__self__, "cloud_watch_logging_configuration", cloud_watch_logging_configuration)
        if managed_persistence_monitoring_configuration is not None:
            pulumi.set(__self__, "managed_persistence_monitoring_configuration", managed_persistence_monitoring_configuration)
        if prometheus_monitoring_configuration is not None:
            pulumi.set(__self__, "prometheus_monitoring_configuration", prometheus_monitoring_configuration)
        if s3_monitoring_configuration is not None:
            pulumi.set(__self__, "s3_monitoring_configuration", s3_monitoring_configuration)

    @_builtins.property
    @pulumi.getter(name="cloudWatchLoggingConfiguration")
    def cloud_watch_logging_configuration(self) -> Optional[pulumi.Input['ApplicationCloudWatchLoggingConfigurationArgs']]:
        """
        CloudWatch logging configurations for a JobRun.
        """
        return pulumi.get(self, "cloud_watch_logging_configuration")

    @cloud_watch_logging_configuration.setter
    def cloud_watch_logging_configuration(self, value: Optional[pulumi.Input['ApplicationCloudWatchLoggingConfigurationArgs']]):
        pulumi.set(self, "cloud_watch_logging_configuration", value)

    @_builtins.property
    @pulumi.getter(name="managedPersistenceMonitoringConfiguration")
    def managed_persistence_monitoring_configuration(self) -> Optional[pulumi.Input['ApplicationManagedPersistenceMonitoringConfigurationArgs']]:
        """
        Managed log persistence configurations for a JobRun.
        """
        return pulumi.get(self, "managed_persistence_monitoring_configuration")

    @managed_persistence_monitoring_configuration.setter
    def managed_persistence_monitoring_configuration(self, value: Optional[pulumi.Input['ApplicationManagedPersistenceMonitoringConfigurationArgs']]):
        pulumi.set(self, "managed_persistence_monitoring_configuration", value)

    @_builtins.property
    @pulumi.getter(name="prometheusMonitoringConfiguration")
    def prometheus_monitoring_configuration(self) -> Optional[pulumi.Input['ApplicationPrometheusMonitoringConfigurationArgs']]:
        """
        Prometheus monitoring configurations for a JobRun.
        """
        return pulumi.get(self, "prometheus_monitoring_configuration")

    @prometheus_monitoring_configuration.setter
    def prometheus_monitoring_configuration(self, value: Optional[pulumi.Input['ApplicationPrometheusMonitoringConfigurationArgs']]):
        pulumi.set(self, "prometheus_monitoring_configuration", value)

    @_builtins.property
    @pulumi.getter(name="s3MonitoringConfiguration")
    def s3_monitoring_configuration(self) -> Optional[pulumi.Input['ApplicationS3MonitoringConfigurationArgs']]:
        """
        S3 monitoring configurations for a JobRun.
        """
        return pulumi.get(self, "s3_monitoring_configuration")

    @s3_monitoring_configuration.setter
    def s3_monitoring_configuration(self, value: Optional[pulumi.Input['ApplicationS3MonitoringConfigurationArgs']]):
        pulumi.set(self, "s3_monitoring_configuration", value)


if not MYPY:
    class ApplicationNetworkConfigurationArgsDict(TypedDict):
        security_group_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The ID of the security groups in the VPC to which you want to connect your job or application.
        """
        subnet_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The ID of the subnets in the VPC to which you want to connect your job or application.
        """
elif False:
    ApplicationNetworkConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationNetworkConfigurationArgs:
    def __init__(__self__, *,
                 security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 subnet_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] security_group_ids: The ID of the security groups in the VPC to which you want to connect your job or application.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] subnet_ids: The ID of the subnets in the VPC to which you want to connect your job or application.
        """
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if subnet_ids is not None:
            pulumi.set(__self__, "subnet_ids", subnet_ids)

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The ID of the security groups in the VPC to which you want to connect your job or application.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "security_group_ids", value)

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The ID of the subnets in the VPC to which you want to connect your job or application.
        """
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "subnet_ids", value)


if not MYPY:
    class ApplicationPrometheusMonitoringConfigurationArgsDict(TypedDict):
        remote_write_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The remote write URL in the Amazon Managed Service for Prometheus workspace to send metrics to.
        """
elif False:
    ApplicationPrometheusMonitoringConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationPrometheusMonitoringConfigurationArgs:
    def __init__(__self__, *,
                 remote_write_url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] remote_write_url: The remote write URL in the Amazon Managed Service for Prometheus workspace to send metrics to.
        """
        if remote_write_url is not None:
            pulumi.set(__self__, "remote_write_url", remote_write_url)

    @_builtins.property
    @pulumi.getter(name="remoteWriteUrl")
    def remote_write_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The remote write URL in the Amazon Managed Service for Prometheus workspace to send metrics to.
        """
        return pulumi.get(self, "remote_write_url")

    @remote_write_url.setter
    def remote_write_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "remote_write_url", value)


if not MYPY:
    class ApplicationS3MonitoringConfigurationArgsDict(TypedDict):
        encryption_key_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        KMS key ARN to encrypt the logs stored in given s3
        """
        log_uri: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ApplicationS3MonitoringConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationS3MonitoringConfigurationArgs:
    def __init__(__self__, *,
                 encryption_key_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 log_uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] encryption_key_arn: KMS key ARN to encrypt the logs stored in given s3
        """
        if encryption_key_arn is not None:
            pulumi.set(__self__, "encryption_key_arn", encryption_key_arn)
        if log_uri is not None:
            pulumi.set(__self__, "log_uri", log_uri)

    @_builtins.property
    @pulumi.getter(name="encryptionKeyArn")
    def encryption_key_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        KMS key ARN to encrypt the logs stored in given s3
        """
        return pulumi.get(self, "encryption_key_arn")

    @encryption_key_arn.setter
    def encryption_key_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "encryption_key_arn", value)

    @_builtins.property
    @pulumi.getter(name="logUri")
    def log_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "log_uri")

    @log_uri.setter
    def log_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_uri", value)


if not MYPY:
    class ApplicationSchedulerConfigurationArgsDict(TypedDict):
        """
        The scheduler configuration for batch and streaming jobs running on this application. Supported with release labels emr-7.0.0 and above.
        """
        max_concurrent_runs: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum concurrent job runs on this application. If scheduler configuration is enabled on your application, the default value is 15. The valid range is 1 to 1000.
        """
        queue_timeout_minutes: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum duration in minutes for the job in QUEUED state. If scheduler configuration is enabled on your application, the default value is 360 minutes (6 hours). The valid range is from 15 to 720.
        """
elif False:
    ApplicationSchedulerConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationSchedulerConfigurationArgs:
    def __init__(__self__, *,
                 max_concurrent_runs: Optional[pulumi.Input[_builtins.int]] = None,
                 queue_timeout_minutes: Optional[pulumi.Input[_builtins.int]] = None):
        """
        The scheduler configuration for batch and streaming jobs running on this application. Supported with release labels emr-7.0.0 and above.
        :param pulumi.Input[_builtins.int] max_concurrent_runs: The maximum concurrent job runs on this application. If scheduler configuration is enabled on your application, the default value is 15. The valid range is 1 to 1000.
        :param pulumi.Input[_builtins.int] queue_timeout_minutes: The maximum duration in minutes for the job in QUEUED state. If scheduler configuration is enabled on your application, the default value is 360 minutes (6 hours). The valid range is from 15 to 720.
        """
        if max_concurrent_runs is not None:
            pulumi.set(__self__, "max_concurrent_runs", max_concurrent_runs)
        if queue_timeout_minutes is not None:
            pulumi.set(__self__, "queue_timeout_minutes", queue_timeout_minutes)

    @_builtins.property
    @pulumi.getter(name="maxConcurrentRuns")
    def max_concurrent_runs(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum concurrent job runs on this application. If scheduler configuration is enabled on your application, the default value is 15. The valid range is 1 to 1000.
        """
        return pulumi.get(self, "max_concurrent_runs")

    @max_concurrent_runs.setter
    def max_concurrent_runs(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_concurrent_runs", value)

    @_builtins.property
    @pulumi.getter(name="queueTimeoutMinutes")
    def queue_timeout_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum duration in minutes for the job in QUEUED state. If scheduler configuration is enabled on your application, the default value is 360 minutes (6 hours). The valid range is from 15 to 720.
        """
        return pulumi.get(self, "queue_timeout_minutes")

    @queue_timeout_minutes.setter
    def queue_timeout_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "queue_timeout_minutes", value)


if not MYPY:
    class ApplicationWorkerConfigurationArgsDict(TypedDict):
        cpu: pulumi.Input[_builtins.str]
        """
        Per worker CPU resource. vCPU is the only supported unit and specifying vCPU is optional.
        """
        memory: pulumi.Input[_builtins.str]
        """
        Per worker memory resource. GB is the only supported unit and specifying GB is optional.
        """
        disk: NotRequired[pulumi.Input[_builtins.str]]
        """
        Per worker Disk resource. GB is the only supported unit and specifying GB is optional
        """
        disk_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Per worker DiskType resource. Shuffle optimized and Standard are only supported types and specifying diskType is optional
        """
elif False:
    ApplicationWorkerConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationWorkerConfigurationArgs:
    def __init__(__self__, *,
                 cpu: pulumi.Input[_builtins.str],
                 memory: pulumi.Input[_builtins.str],
                 disk: Optional[pulumi.Input[_builtins.str]] = None,
                 disk_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cpu: Per worker CPU resource. vCPU is the only supported unit and specifying vCPU is optional.
        :param pulumi.Input[_builtins.str] memory: Per worker memory resource. GB is the only supported unit and specifying GB is optional.
        :param pulumi.Input[_builtins.str] disk: Per worker Disk resource. GB is the only supported unit and specifying GB is optional
        :param pulumi.Input[_builtins.str] disk_type: Per worker DiskType resource. Shuffle optimized and Standard are only supported types and specifying diskType is optional
        """
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "memory", memory)
        if disk is not None:
            pulumi.set(__self__, "disk", disk)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> pulumi.Input[_builtins.str]:
        """
        Per worker CPU resource. vCPU is the only supported unit and specifying vCPU is optional.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cpu", value)

    @_builtins.property
    @pulumi.getter
    def memory(self) -> pulumi.Input[_builtins.str]:
        """
        Per worker memory resource. GB is the only supported unit and specifying GB is optional.
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "memory", value)

    @_builtins.property
    @pulumi.getter
    def disk(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Per worker Disk resource. GB is the only supported unit and specifying GB is optional
        """
        return pulumi.get(self, "disk")

    @disk.setter
    def disk(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "disk", value)

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Per worker DiskType resource. Shuffle optimized and Standard are only supported types and specifying diskType is optional
        """
        return pulumi.get(self, "disk_type")

    @disk_type.setter
    def disk_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "disk_type", value)


if not MYPY:
    class ApplicationWorkerTypeSpecificationInputArgsDict(TypedDict):
        """
        The specifications for a worker type.
        """
        image_configuration: NotRequired[pulumi.Input['ApplicationImageConfigurationInputArgsDict']]
        """
        The image configuration for a worker type.
        """
elif False:
    ApplicationWorkerTypeSpecificationInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationWorkerTypeSpecificationInputArgs:
    def __init__(__self__, *,
                 image_configuration: Optional[pulumi.Input['ApplicationImageConfigurationInputArgs']] = None):
        """
        The specifications for a worker type.
        :param pulumi.Input['ApplicationImageConfigurationInputArgs'] image_configuration: The image configuration for a worker type.
        """
        if image_configuration is not None:
            pulumi.set(__self__, "image_configuration", image_configuration)

    @_builtins.property
    @pulumi.getter(name="imageConfiguration")
    def image_configuration(self) -> Optional[pulumi.Input['ApplicationImageConfigurationInputArgs']]:
        """
        The image configuration for a worker type.
        """
        return pulumi.get(self, "image_configuration")

    @image_configuration.setter
    def image_configuration(self, value: Optional[pulumi.Input['ApplicationImageConfigurationInputArgs']]):
        pulumi.set(self, "image_configuration", value)


