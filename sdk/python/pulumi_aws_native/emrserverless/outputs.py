# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'ApplicationAutoStartConfiguration',
    'ApplicationAutoStopConfiguration',
    'ApplicationCloudWatchLoggingConfiguration',
    'ApplicationConfigurationObject',
    'ApplicationIdentityCenterConfiguration',
    'ApplicationImageConfigurationInput',
    'ApplicationInitialCapacityConfig',
    'ApplicationInitialCapacityConfigKeyValuePair',
    'ApplicationInteractiveConfiguration',
    'ApplicationLogTypeMapKeyValuePair',
    'ApplicationManagedPersistenceMonitoringConfiguration',
    'ApplicationMaximumAllowedResources',
    'ApplicationMonitoringConfiguration',
    'ApplicationNetworkConfiguration',
    'ApplicationPrometheusMonitoringConfiguration',
    'ApplicationS3MonitoringConfiguration',
    'ApplicationSchedulerConfiguration',
    'ApplicationWorkerConfiguration',
    'ApplicationWorkerTypeSpecificationInput',
]

@pulumi.output_type
class ApplicationAutoStartConfiguration(dict):
    """
    Configuration for Auto Start of Application
    """
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        Configuration for Auto Start of Application
        :param _builtins.bool enabled: If set to true, the Application will automatically start. Defaults to true.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set to true, the Application will automatically start. Defaults to true.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ApplicationAutoStopConfiguration(dict):
    """
    Configuration for Auto Stop of Application
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "idleTimeoutMinutes":
            suggest = "idle_timeout_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationAutoStopConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationAutoStopConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationAutoStopConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 idle_timeout_minutes: Optional[_builtins.int] = None):
        """
        Configuration for Auto Stop of Application
        :param _builtins.bool enabled: If set to true, the Application will automatically stop after being idle. Defaults to true.
        :param _builtins.int idle_timeout_minutes: The amount of time [in minutes] to wait before auto stopping the Application when idle. Defaults to 15 minutes.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if idle_timeout_minutes is not None:
            pulumi.set(__self__, "idle_timeout_minutes", idle_timeout_minutes)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set to true, the Application will automatically stop after being idle. Defaults to true.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="idleTimeoutMinutes")
    def idle_timeout_minutes(self) -> Optional[_builtins.int]:
        """
        The amount of time [in minutes] to wait before auto stopping the Application when idle. Defaults to 15 minutes.
        """
        return pulumi.get(self, "idle_timeout_minutes")


@pulumi.output_type
class ApplicationCloudWatchLoggingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptionKeyArn":
            suggest = "encryption_key_arn"
        elif key == "logGroupName":
            suggest = "log_group_name"
        elif key == "logStreamNamePrefix":
            suggest = "log_stream_name_prefix"
        elif key == "logTypeMap":
            suggest = "log_type_map"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationCloudWatchLoggingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationCloudWatchLoggingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationCloudWatchLoggingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 encryption_key_arn: Optional[_builtins.str] = None,
                 log_group_name: Optional[_builtins.str] = None,
                 log_stream_name_prefix: Optional[_builtins.str] = None,
                 log_type_map: Optional[Sequence['outputs.ApplicationLogTypeMapKeyValuePair']] = None):
        """
        :param _builtins.bool enabled: If set to false, CloudWatch logging will be turned off. Defaults to false.
        :param _builtins.str encryption_key_arn: KMS key ARN to encrypt the logs stored in given CloudWatch log-group.
        :param _builtins.str log_group_name: Log-group name to produce log-streams on CloudWatch. If undefined, logs will be produced in a default log-group /aws/emr-serverless
        :param _builtins.str log_stream_name_prefix: Log-stream name prefix by which log-stream names will start in the CloudWatch Log-group.
        :param Sequence['ApplicationLogTypeMapKeyValuePair'] log_type_map: The specific log-streams which need to be uploaded to CloudWatch.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if encryption_key_arn is not None:
            pulumi.set(__self__, "encryption_key_arn", encryption_key_arn)
        if log_group_name is not None:
            pulumi.set(__self__, "log_group_name", log_group_name)
        if log_stream_name_prefix is not None:
            pulumi.set(__self__, "log_stream_name_prefix", log_stream_name_prefix)
        if log_type_map is not None:
            pulumi.set(__self__, "log_type_map", log_type_map)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set to false, CloudWatch logging will be turned off. Defaults to false.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="encryptionKeyArn")
    def encryption_key_arn(self) -> Optional[_builtins.str]:
        """
        KMS key ARN to encrypt the logs stored in given CloudWatch log-group.
        """
        return pulumi.get(self, "encryption_key_arn")

    @_builtins.property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> Optional[_builtins.str]:
        """
        Log-group name to produce log-streams on CloudWatch. If undefined, logs will be produced in a default log-group /aws/emr-serverless
        """
        return pulumi.get(self, "log_group_name")

    @_builtins.property
    @pulumi.getter(name="logStreamNamePrefix")
    def log_stream_name_prefix(self) -> Optional[_builtins.str]:
        """
        Log-stream name prefix by which log-stream names will start in the CloudWatch Log-group.
        """
        return pulumi.get(self, "log_stream_name_prefix")

    @_builtins.property
    @pulumi.getter(name="logTypeMap")
    def log_type_map(self) -> Optional[Sequence['outputs.ApplicationLogTypeMapKeyValuePair']]:
        """
        The specific log-streams which need to be uploaded to CloudWatch.
        """
        return pulumi.get(self, "log_type_map")


@pulumi.output_type
class ApplicationConfigurationObject(dict):
    """
    Configuration for a JobRun.
    """
    def __init__(__self__, *,
                 classification: _builtins.str,
                 configurations: Optional[Sequence['outputs.ApplicationConfigurationObject']] = None,
                 properties: Optional[Mapping[str, _builtins.str]] = None):
        """
        Configuration for a JobRun.
        :param _builtins.str classification: String with a maximum length of 1024.
        """
        pulumi.set(__self__, "classification", classification)
        if configurations is not None:
            pulumi.set(__self__, "configurations", configurations)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @_builtins.property
    @pulumi.getter
    def classification(self) -> _builtins.str:
        """
        String with a maximum length of 1024.
        """
        return pulumi.get(self, "classification")

    @_builtins.property
    @pulumi.getter
    def configurations(self) -> Optional[Sequence['outputs.ApplicationConfigurationObject']]:
        return pulumi.get(self, "configurations")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "properties")


@pulumi.output_type
class ApplicationIdentityCenterConfiguration(dict):
    """
    The IAM IdentityCenter configuration for trusted-identity-propagation on this application. Supported with release labels emr-7.8.0 and above.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "identityCenterInstanceArn":
            suggest = "identity_center_instance_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationIdentityCenterConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationIdentityCenterConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationIdentityCenterConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identity_center_instance_arn: Optional[_builtins.str] = None):
        """
        The IAM IdentityCenter configuration for trusted-identity-propagation on this application. Supported with release labels emr-7.8.0 and above.
        :param _builtins.str identity_center_instance_arn: The IAM IdentityCenter instance arn
        """
        if identity_center_instance_arn is not None:
            pulumi.set(__self__, "identity_center_instance_arn", identity_center_instance_arn)

    @_builtins.property
    @pulumi.getter(name="identityCenterInstanceArn")
    def identity_center_instance_arn(self) -> Optional[_builtins.str]:
        """
        The IAM IdentityCenter instance arn
        """
        return pulumi.get(self, "identity_center_instance_arn")


@pulumi.output_type
class ApplicationImageConfigurationInput(dict):
    """
    The image configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageUri":
            suggest = "image_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationImageConfigurationInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationImageConfigurationInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationImageConfigurationInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_uri: Optional[_builtins.str] = None):
        """
        The image configuration.
        :param _builtins.str image_uri: The URI of an image in the Amazon ECR registry. This field is required when you create a new application. If you leave this field blank in an update, Amazon EMR will remove the image configuration.
        """
        if image_uri is not None:
            pulumi.set(__self__, "image_uri", image_uri)

    @_builtins.property
    @pulumi.getter(name="imageUri")
    def image_uri(self) -> Optional[_builtins.str]:
        """
        The URI of an image in the Amazon ECR registry. This field is required when you create a new application. If you leave this field blank in an update, Amazon EMR will remove the image configuration.
        """
        return pulumi.get(self, "image_uri")


@pulumi.output_type
class ApplicationInitialCapacityConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workerConfiguration":
            suggest = "worker_configuration"
        elif key == "workerCount":
            suggest = "worker_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationInitialCapacityConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationInitialCapacityConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationInitialCapacityConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 worker_configuration: 'outputs.ApplicationWorkerConfiguration',
                 worker_count: _builtins.int):
        """
        :param _builtins.int worker_count: Initial count of workers to be initialized when an Application is started. This count will be continued to be maintained until the Application is stopped
        """
        pulumi.set(__self__, "worker_configuration", worker_configuration)
        pulumi.set(__self__, "worker_count", worker_count)

    @_builtins.property
    @pulumi.getter(name="workerConfiguration")
    def worker_configuration(self) -> 'outputs.ApplicationWorkerConfiguration':
        return pulumi.get(self, "worker_configuration")

    @_builtins.property
    @pulumi.getter(name="workerCount")
    def worker_count(self) -> _builtins.int:
        """
        Initial count of workers to be initialized when an Application is started. This count will be continued to be maintained until the Application is stopped
        """
        return pulumi.get(self, "worker_count")


@pulumi.output_type
class ApplicationInitialCapacityConfigKeyValuePair(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: 'outputs.ApplicationInitialCapacityConfig'):
        """
        :param _builtins.str key: Worker type for an analytics framework.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Worker type for an analytics framework.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> 'outputs.ApplicationInitialCapacityConfig':
        return pulumi.get(self, "value")


@pulumi.output_type
class ApplicationInteractiveConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "livyEndpointEnabled":
            suggest = "livy_endpoint_enabled"
        elif key == "studioEnabled":
            suggest = "studio_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationInteractiveConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationInteractiveConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationInteractiveConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 livy_endpoint_enabled: Optional[_builtins.bool] = None,
                 studio_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool livy_endpoint_enabled: Enables an Apache Livy endpoint that you can connect to and run interactive jobs
        :param _builtins.bool studio_enabled: Enabled you to connect an Application to Amazon EMR Studio to run interactive workloads in a notebook
        """
        if livy_endpoint_enabled is not None:
            pulumi.set(__self__, "livy_endpoint_enabled", livy_endpoint_enabled)
        if studio_enabled is not None:
            pulumi.set(__self__, "studio_enabled", studio_enabled)

    @_builtins.property
    @pulumi.getter(name="livyEndpointEnabled")
    def livy_endpoint_enabled(self) -> Optional[_builtins.bool]:
        """
        Enables an Apache Livy endpoint that you can connect to and run interactive jobs
        """
        return pulumi.get(self, "livy_endpoint_enabled")

    @_builtins.property
    @pulumi.getter(name="studioEnabled")
    def studio_enabled(self) -> Optional[_builtins.bool]:
        """
        Enabled you to connect an Application to Amazon EMR Studio to run interactive workloads in a notebook
        """
        return pulumi.get(self, "studio_enabled")


@pulumi.output_type
class ApplicationLogTypeMapKeyValuePair(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: Sequence[_builtins.str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ApplicationManagedPersistenceMonitoringConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptionKeyArn":
            suggest = "encryption_key_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationManagedPersistenceMonitoringConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationManagedPersistenceMonitoringConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationManagedPersistenceMonitoringConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 encryption_key_arn: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: If set to false, managed logging will be turned off. Defaults to true.
        :param _builtins.str encryption_key_arn: KMS key ARN to encrypt the logs stored in managed persistence
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if encryption_key_arn is not None:
            pulumi.set(__self__, "encryption_key_arn", encryption_key_arn)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        If set to false, managed logging will be turned off. Defaults to true.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="encryptionKeyArn")
    def encryption_key_arn(self) -> Optional[_builtins.str]:
        """
        KMS key ARN to encrypt the logs stored in managed persistence
        """
        return pulumi.get(self, "encryption_key_arn")


@pulumi.output_type
class ApplicationMaximumAllowedResources(dict):
    def __init__(__self__, *,
                 cpu: _builtins.str,
                 memory: _builtins.str,
                 disk: Optional[_builtins.str] = None):
        """
        :param _builtins.str cpu: Per worker CPU resource. vCPU is the only supported unit and specifying vCPU is optional.
        :param _builtins.str memory: Per worker memory resource. GB is the only supported unit and specifying GB is optional.
        :param _builtins.str disk: Per worker Disk resource. GB is the only supported unit and specifying GB is optional
        """
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "memory", memory)
        if disk is not None:
            pulumi.set(__self__, "disk", disk)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> _builtins.str:
        """
        Per worker CPU resource. vCPU is the only supported unit and specifying vCPU is optional.
        """
        return pulumi.get(self, "cpu")

    @_builtins.property
    @pulumi.getter
    def memory(self) -> _builtins.str:
        """
        Per worker memory resource. GB is the only supported unit and specifying GB is optional.
        """
        return pulumi.get(self, "memory")

    @_builtins.property
    @pulumi.getter
    def disk(self) -> Optional[_builtins.str]:
        """
        Per worker Disk resource. GB is the only supported unit and specifying GB is optional
        """
        return pulumi.get(self, "disk")


@pulumi.output_type
class ApplicationMonitoringConfiguration(dict):
    """
    Monitoring configuration for batch and interactive JobRun.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudWatchLoggingConfiguration":
            suggest = "cloud_watch_logging_configuration"
        elif key == "managedPersistenceMonitoringConfiguration":
            suggest = "managed_persistence_monitoring_configuration"
        elif key == "prometheusMonitoringConfiguration":
            suggest = "prometheus_monitoring_configuration"
        elif key == "s3MonitoringConfiguration":
            suggest = "s3_monitoring_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationMonitoringConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationMonitoringConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationMonitoringConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_watch_logging_configuration: Optional['outputs.ApplicationCloudWatchLoggingConfiguration'] = None,
                 managed_persistence_monitoring_configuration: Optional['outputs.ApplicationManagedPersistenceMonitoringConfiguration'] = None,
                 prometheus_monitoring_configuration: Optional['outputs.ApplicationPrometheusMonitoringConfiguration'] = None,
                 s3_monitoring_configuration: Optional['outputs.ApplicationS3MonitoringConfiguration'] = None):
        """
        Monitoring configuration for batch and interactive JobRun.
        :param 'ApplicationCloudWatchLoggingConfiguration' cloud_watch_logging_configuration: CloudWatch logging configurations for a JobRun.
        :param 'ApplicationManagedPersistenceMonitoringConfiguration' managed_persistence_monitoring_configuration: Managed log persistence configurations for a JobRun.
        :param 'ApplicationPrometheusMonitoringConfiguration' prometheus_monitoring_configuration: Prometheus monitoring configurations for a JobRun.
        :param 'ApplicationS3MonitoringConfiguration' s3_monitoring_configuration: S3 monitoring configurations for a JobRun.
        """
        if cloud_watch_logging_configuration is not None:
            pulumi.set(__self__, "cloud_watch_logging_configuration", cloud_watch_logging_configuration)
        if managed_persistence_monitoring_configuration is not None:
            pulumi.set(__self__, "managed_persistence_monitoring_configuration", managed_persistence_monitoring_configuration)
        if prometheus_monitoring_configuration is not None:
            pulumi.set(__self__, "prometheus_monitoring_configuration", prometheus_monitoring_configuration)
        if s3_monitoring_configuration is not None:
            pulumi.set(__self__, "s3_monitoring_configuration", s3_monitoring_configuration)

    @_builtins.property
    @pulumi.getter(name="cloudWatchLoggingConfiguration")
    def cloud_watch_logging_configuration(self) -> Optional['outputs.ApplicationCloudWatchLoggingConfiguration']:
        """
        CloudWatch logging configurations for a JobRun.
        """
        return pulumi.get(self, "cloud_watch_logging_configuration")

    @_builtins.property
    @pulumi.getter(name="managedPersistenceMonitoringConfiguration")
    def managed_persistence_monitoring_configuration(self) -> Optional['outputs.ApplicationManagedPersistenceMonitoringConfiguration']:
        """
        Managed log persistence configurations for a JobRun.
        """
        return pulumi.get(self, "managed_persistence_monitoring_configuration")

    @_builtins.property
    @pulumi.getter(name="prometheusMonitoringConfiguration")
    def prometheus_monitoring_configuration(self) -> Optional['outputs.ApplicationPrometheusMonitoringConfiguration']:
        """
        Prometheus monitoring configurations for a JobRun.
        """
        return pulumi.get(self, "prometheus_monitoring_configuration")

    @_builtins.property
    @pulumi.getter(name="s3MonitoringConfiguration")
    def s3_monitoring_configuration(self) -> Optional['outputs.ApplicationS3MonitoringConfiguration']:
        """
        S3 monitoring configurations for a JobRun.
        """
        return pulumi.get(self, "s3_monitoring_configuration")


@pulumi.output_type
class ApplicationNetworkConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "subnetIds":
            suggest = "subnet_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationNetworkConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationNetworkConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationNetworkConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 security_group_ids: Optional[Sequence[_builtins.str]] = None,
                 subnet_ids: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] security_group_ids: The ID of the security groups in the VPC to which you want to connect your job or application.
        :param Sequence[_builtins.str] subnet_ids: The ID of the subnets in the VPC to which you want to connect your job or application.
        """
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if subnet_ids is not None:
            pulumi.set(__self__, "subnet_ids", subnet_ids)

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        The ID of the security groups in the VPC to which you want to connect your job or application.
        """
        return pulumi.get(self, "security_group_ids")

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        The ID of the subnets in the VPC to which you want to connect your job or application.
        """
        return pulumi.get(self, "subnet_ids")


@pulumi.output_type
class ApplicationPrometheusMonitoringConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "remoteWriteUrl":
            suggest = "remote_write_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationPrometheusMonitoringConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationPrometheusMonitoringConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationPrometheusMonitoringConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 remote_write_url: Optional[_builtins.str] = None):
        """
        :param _builtins.str remote_write_url: The remote write URL in the Amazon Managed Service for Prometheus workspace to send metrics to.
        """
        if remote_write_url is not None:
            pulumi.set(__self__, "remote_write_url", remote_write_url)

    @_builtins.property
    @pulumi.getter(name="remoteWriteUrl")
    def remote_write_url(self) -> Optional[_builtins.str]:
        """
        The remote write URL in the Amazon Managed Service for Prometheus workspace to send metrics to.
        """
        return pulumi.get(self, "remote_write_url")


@pulumi.output_type
class ApplicationS3MonitoringConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptionKeyArn":
            suggest = "encryption_key_arn"
        elif key == "logUri":
            suggest = "log_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationS3MonitoringConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationS3MonitoringConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationS3MonitoringConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 encryption_key_arn: Optional[_builtins.str] = None,
                 log_uri: Optional[_builtins.str] = None):
        """
        :param _builtins.str encryption_key_arn: KMS key ARN to encrypt the logs stored in given s3
        """
        if encryption_key_arn is not None:
            pulumi.set(__self__, "encryption_key_arn", encryption_key_arn)
        if log_uri is not None:
            pulumi.set(__self__, "log_uri", log_uri)

    @_builtins.property
    @pulumi.getter(name="encryptionKeyArn")
    def encryption_key_arn(self) -> Optional[_builtins.str]:
        """
        KMS key ARN to encrypt the logs stored in given s3
        """
        return pulumi.get(self, "encryption_key_arn")

    @_builtins.property
    @pulumi.getter(name="logUri")
    def log_uri(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "log_uri")


@pulumi.output_type
class ApplicationSchedulerConfiguration(dict):
    """
    The scheduler configuration for batch and streaming jobs running on this application. Supported with release labels emr-7.0.0 and above.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConcurrentRuns":
            suggest = "max_concurrent_runs"
        elif key == "queueTimeoutMinutes":
            suggest = "queue_timeout_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationSchedulerConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationSchedulerConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationSchedulerConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_concurrent_runs: Optional[_builtins.int] = None,
                 queue_timeout_minutes: Optional[_builtins.int] = None):
        """
        The scheduler configuration for batch and streaming jobs running on this application. Supported with release labels emr-7.0.0 and above.
        :param _builtins.int max_concurrent_runs: The maximum concurrent job runs on this application. If scheduler configuration is enabled on your application, the default value is 15. The valid range is 1 to 1000.
        :param _builtins.int queue_timeout_minutes: The maximum duration in minutes for the job in QUEUED state. If scheduler configuration is enabled on your application, the default value is 360 minutes (6 hours). The valid range is from 15 to 720.
        """
        if max_concurrent_runs is not None:
            pulumi.set(__self__, "max_concurrent_runs", max_concurrent_runs)
        if queue_timeout_minutes is not None:
            pulumi.set(__self__, "queue_timeout_minutes", queue_timeout_minutes)

    @_builtins.property
    @pulumi.getter(name="maxConcurrentRuns")
    def max_concurrent_runs(self) -> Optional[_builtins.int]:
        """
        The maximum concurrent job runs on this application. If scheduler configuration is enabled on your application, the default value is 15. The valid range is 1 to 1000.
        """
        return pulumi.get(self, "max_concurrent_runs")

    @_builtins.property
    @pulumi.getter(name="queueTimeoutMinutes")
    def queue_timeout_minutes(self) -> Optional[_builtins.int]:
        """
        The maximum duration in minutes for the job in QUEUED state. If scheduler configuration is enabled on your application, the default value is 360 minutes (6 hours). The valid range is from 15 to 720.
        """
        return pulumi.get(self, "queue_timeout_minutes")


@pulumi.output_type
class ApplicationWorkerConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "diskType":
            suggest = "disk_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationWorkerConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationWorkerConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationWorkerConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu: _builtins.str,
                 memory: _builtins.str,
                 disk: Optional[_builtins.str] = None,
                 disk_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str cpu: Per worker CPU resource. vCPU is the only supported unit and specifying vCPU is optional.
        :param _builtins.str memory: Per worker memory resource. GB is the only supported unit and specifying GB is optional.
        :param _builtins.str disk: Per worker Disk resource. GB is the only supported unit and specifying GB is optional
        :param _builtins.str disk_type: Per worker DiskType resource. Shuffle optimized and Standard are only supported types and specifying diskType is optional
        """
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "memory", memory)
        if disk is not None:
            pulumi.set(__self__, "disk", disk)
        if disk_type is not None:
            pulumi.set(__self__, "disk_type", disk_type)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> _builtins.str:
        """
        Per worker CPU resource. vCPU is the only supported unit and specifying vCPU is optional.
        """
        return pulumi.get(self, "cpu")

    @_builtins.property
    @pulumi.getter
    def memory(self) -> _builtins.str:
        """
        Per worker memory resource. GB is the only supported unit and specifying GB is optional.
        """
        return pulumi.get(self, "memory")

    @_builtins.property
    @pulumi.getter
    def disk(self) -> Optional[_builtins.str]:
        """
        Per worker Disk resource. GB is the only supported unit and specifying GB is optional
        """
        return pulumi.get(self, "disk")

    @_builtins.property
    @pulumi.getter(name="diskType")
    def disk_type(self) -> Optional[_builtins.str]:
        """
        Per worker DiskType resource. Shuffle optimized and Standard are only supported types and specifying diskType is optional
        """
        return pulumi.get(self, "disk_type")


@pulumi.output_type
class ApplicationWorkerTypeSpecificationInput(dict):
    """
    The specifications for a worker type.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageConfiguration":
            suggest = "image_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationWorkerTypeSpecificationInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationWorkerTypeSpecificationInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationWorkerTypeSpecificationInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_configuration: Optional['outputs.ApplicationImageConfigurationInput'] = None):
        """
        The specifications for a worker type.
        :param 'ApplicationImageConfigurationInput' image_configuration: The image configuration for a worker type.
        """
        if image_configuration is not None:
            pulumi.set(__self__, "image_configuration", image_configuration)

    @_builtins.property
    @pulumi.getter(name="imageConfiguration")
    def image_configuration(self) -> Optional['outputs.ApplicationImageConfigurationInput']:
        """
        The image configuration for a worker type.
        """
        return pulumi.get(self, "image_configuration")


