# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'CanaryArtifactConfigArgs',
    'CanaryArtifactConfigArgsDict',
    'CanaryBaseScreenshotArgs',
    'CanaryBaseScreenshotArgsDict',
    'CanaryBrowserConfigArgs',
    'CanaryBrowserConfigArgsDict',
    'CanaryCodeArgs',
    'CanaryCodeArgsDict',
    'CanaryDependencyArgs',
    'CanaryDependencyArgsDict',
    'CanaryRetryConfigArgs',
    'CanaryRetryConfigArgsDict',
    'CanaryRunConfigArgs',
    'CanaryRunConfigArgsDict',
    'CanaryS3EncryptionArgs',
    'CanaryS3EncryptionArgsDict',
    'CanaryScheduleArgs',
    'CanaryScheduleArgsDict',
    'CanaryVisualReferenceArgs',
    'CanaryVisualReferenceArgsDict',
    'CanaryVpcConfigArgs',
    'CanaryVpcConfigArgsDict',
]

MYPY = False

if not MYPY:
    class CanaryArtifactConfigArgsDict(TypedDict):
        s3_encryption: NotRequired[pulumi.Input['CanaryS3EncryptionArgsDict']]
        """
        Encryption configuration for uploading artifacts to S3
        """
elif False:
    CanaryArtifactConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CanaryArtifactConfigArgs:
    def __init__(__self__, *,
                 s3_encryption: Optional[pulumi.Input['CanaryS3EncryptionArgs']] = None):
        """
        :param pulumi.Input['CanaryS3EncryptionArgs'] s3_encryption: Encryption configuration for uploading artifacts to S3
        """
        if s3_encryption is not None:
            pulumi.set(__self__, "s3_encryption", s3_encryption)

    @_builtins.property
    @pulumi.getter(name="s3Encryption")
    def s3_encryption(self) -> Optional[pulumi.Input['CanaryS3EncryptionArgs']]:
        """
        Encryption configuration for uploading artifacts to S3
        """
        return pulumi.get(self, "s3_encryption")

    @s3_encryption.setter
    def s3_encryption(self, value: Optional[pulumi.Input['CanaryS3EncryptionArgs']]):
        pulumi.set(self, "s3_encryption", value)


if not MYPY:
    class CanaryBaseScreenshotArgsDict(TypedDict):
        screenshot_name: pulumi.Input[_builtins.str]
        """
        Name of the screenshot to be used as base reference for visual testing
        """
        ignore_coordinates: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of coordinates of rectangles to be ignored during visual testing
        """
elif False:
    CanaryBaseScreenshotArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CanaryBaseScreenshotArgs:
    def __init__(__self__, *,
                 screenshot_name: pulumi.Input[_builtins.str],
                 ignore_coordinates: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] screenshot_name: Name of the screenshot to be used as base reference for visual testing
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ignore_coordinates: List of coordinates of rectangles to be ignored during visual testing
        """
        pulumi.set(__self__, "screenshot_name", screenshot_name)
        if ignore_coordinates is not None:
            pulumi.set(__self__, "ignore_coordinates", ignore_coordinates)

    @_builtins.property
    @pulumi.getter(name="screenshotName")
    def screenshot_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the screenshot to be used as base reference for visual testing
        """
        return pulumi.get(self, "screenshot_name")

    @screenshot_name.setter
    def screenshot_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "screenshot_name", value)

    @_builtins.property
    @pulumi.getter(name="ignoreCoordinates")
    def ignore_coordinates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of coordinates of rectangles to be ignored during visual testing
        """
        return pulumi.get(self, "ignore_coordinates")

    @ignore_coordinates.setter
    def ignore_coordinates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ignore_coordinates", value)


if not MYPY:
    class CanaryBrowserConfigArgsDict(TypedDict):
        browser_type: pulumi.Input['CanaryBrowserType']
        """
        The browser type associated with this browser configuration.
        """
elif False:
    CanaryBrowserConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CanaryBrowserConfigArgs:
    def __init__(__self__, *,
                 browser_type: pulumi.Input['CanaryBrowserType']):
        """
        :param pulumi.Input['CanaryBrowserType'] browser_type: The browser type associated with this browser configuration.
        """
        pulumi.set(__self__, "browser_type", browser_type)

    @_builtins.property
    @pulumi.getter(name="browserType")
    def browser_type(self) -> pulumi.Input['CanaryBrowserType']:
        """
        The browser type associated with this browser configuration.
        """
        return pulumi.get(self, "browser_type")

    @browser_type.setter
    def browser_type(self, value: pulumi.Input['CanaryBrowserType']):
        pulumi.set(self, "browser_type", value)


if not MYPY:
    class CanaryCodeArgsDict(TypedDict):
        blueprint_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        `BlueprintTypes` are a list of templates that enable simplified canary creation. You can create canaries for common monitoring scenarios by providing only a JSON configuration file instead of writing custom scripts. `multi-checks` is the only supported value.

        When you specify `BlueprintTypes` , the `Handler` field cannot be specified since the blueprint provides a pre-defined entry point.
        """
        dependencies: NotRequired[pulumi.Input[Sequence[pulumi.Input['CanaryDependencyArgsDict']]]]
        """
        List of Lambda layers to attach to the canary
        """
        handler: NotRequired[pulumi.Input[_builtins.str]]
        """
        The entry point to use for the source code when running the canary. For canaries that use the `syn-python-selenium-1.0` runtime or a `syn-nodejs.puppeteer` runtime earlier than `syn-nodejs.puppeteer-3.4` , the handler must be specified as `*fileName* .handler` . For `syn-python-selenium-1.1` , `syn-nodejs.puppeteer-3.4` , and later runtimes, the handler can be specified as `*fileName* . *functionName*` , or you can specify a folder where canary scripts reside as `*folder* / *fileName* . *functionName*` .

        This field is required when you don't specify `BlueprintTypes` and is not allowed when you specify `BlueprintTypes` .
        """
        s3_bucket: NotRequired[pulumi.Input[_builtins.str]]
        """
        If your canary script is located in S3, specify the bucket name here. The bucket must already exist.
        """
        s3_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Amazon S3 key of your script. For more information, see [Working with Amazon S3 Objects](https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingObjects.html) .
        """
        s3_object_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Amazon S3 version ID of your script.
        """
        script: NotRequired[pulumi.Input[_builtins.str]]
        """
        If you input your canary script directly into the canary instead of referring to an S3 location, the value of this parameter is the script in plain text. It can be up to 5 MB.
        """
        source_location_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ARN of the Lambda layer where Synthetics stores the canary script code.
        """
elif False:
    CanaryCodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CanaryCodeArgs:
    def __init__(__self__, *,
                 blueprint_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 dependencies: Optional[pulumi.Input[Sequence[pulumi.Input['CanaryDependencyArgs']]]] = None,
                 handler: Optional[pulumi.Input[_builtins.str]] = None,
                 s3_bucket: Optional[pulumi.Input[_builtins.str]] = None,
                 s3_key: Optional[pulumi.Input[_builtins.str]] = None,
                 s3_object_version: Optional[pulumi.Input[_builtins.str]] = None,
                 script: Optional[pulumi.Input[_builtins.str]] = None,
                 source_location_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] blueprint_types: `BlueprintTypes` are a list of templates that enable simplified canary creation. You can create canaries for common monitoring scenarios by providing only a JSON configuration file instead of writing custom scripts. `multi-checks` is the only supported value.
               
               When you specify `BlueprintTypes` , the `Handler` field cannot be specified since the blueprint provides a pre-defined entry point.
        :param pulumi.Input[Sequence[pulumi.Input['CanaryDependencyArgs']]] dependencies: List of Lambda layers to attach to the canary
        :param pulumi.Input[_builtins.str] handler: The entry point to use for the source code when running the canary. For canaries that use the `syn-python-selenium-1.0` runtime or a `syn-nodejs.puppeteer` runtime earlier than `syn-nodejs.puppeteer-3.4` , the handler must be specified as `*fileName* .handler` . For `syn-python-selenium-1.1` , `syn-nodejs.puppeteer-3.4` , and later runtimes, the handler can be specified as `*fileName* . *functionName*` , or you can specify a folder where canary scripts reside as `*folder* / *fileName* . *functionName*` .
               
               This field is required when you don't specify `BlueprintTypes` and is not allowed when you specify `BlueprintTypes` .
        :param pulumi.Input[_builtins.str] s3_bucket: If your canary script is located in S3, specify the bucket name here. The bucket must already exist.
        :param pulumi.Input[_builtins.str] s3_key: The Amazon S3 key of your script. For more information, see [Working with Amazon S3 Objects](https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingObjects.html) .
        :param pulumi.Input[_builtins.str] s3_object_version: The Amazon S3 version ID of your script.
        :param pulumi.Input[_builtins.str] script: If you input your canary script directly into the canary instead of referring to an S3 location, the value of this parameter is the script in plain text. It can be up to 5 MB.
        :param pulumi.Input[_builtins.str] source_location_arn: The ARN of the Lambda layer where Synthetics stores the canary script code.
        """
        if blueprint_types is not None:
            pulumi.set(__self__, "blueprint_types", blueprint_types)
        if dependencies is not None:
            pulumi.set(__self__, "dependencies", dependencies)
        if handler is not None:
            pulumi.set(__self__, "handler", handler)
        if s3_bucket is not None:
            pulumi.set(__self__, "s3_bucket", s3_bucket)
        if s3_key is not None:
            pulumi.set(__self__, "s3_key", s3_key)
        if s3_object_version is not None:
            pulumi.set(__self__, "s3_object_version", s3_object_version)
        if script is not None:
            pulumi.set(__self__, "script", script)
        if source_location_arn is not None:
            pulumi.set(__self__, "source_location_arn", source_location_arn)

    @_builtins.property
    @pulumi.getter(name="blueprintTypes")
    def blueprint_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        `BlueprintTypes` are a list of templates that enable simplified canary creation. You can create canaries for common monitoring scenarios by providing only a JSON configuration file instead of writing custom scripts. `multi-checks` is the only supported value.

        When you specify `BlueprintTypes` , the `Handler` field cannot be specified since the blueprint provides a pre-defined entry point.
        """
        return pulumi.get(self, "blueprint_types")

    @blueprint_types.setter
    def blueprint_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "blueprint_types", value)

    @_builtins.property
    @pulumi.getter
    def dependencies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CanaryDependencyArgs']]]]:
        """
        List of Lambda layers to attach to the canary
        """
        return pulumi.get(self, "dependencies")

    @dependencies.setter
    def dependencies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CanaryDependencyArgs']]]]):
        pulumi.set(self, "dependencies", value)

    @_builtins.property
    @pulumi.getter
    def handler(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The entry point to use for the source code when running the canary. For canaries that use the `syn-python-selenium-1.0` runtime or a `syn-nodejs.puppeteer` runtime earlier than `syn-nodejs.puppeteer-3.4` , the handler must be specified as `*fileName* .handler` . For `syn-python-selenium-1.1` , `syn-nodejs.puppeteer-3.4` , and later runtimes, the handler can be specified as `*fileName* . *functionName*` , or you can specify a folder where canary scripts reside as `*folder* / *fileName* . *functionName*` .

        This field is required when you don't specify `BlueprintTypes` and is not allowed when you specify `BlueprintTypes` .
        """
        return pulumi.get(self, "handler")

    @handler.setter
    def handler(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "handler", value)

    @_builtins.property
    @pulumi.getter(name="s3Bucket")
    def s3_bucket(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If your canary script is located in S3, specify the bucket name here. The bucket must already exist.
        """
        return pulumi.get(self, "s3_bucket")

    @s3_bucket.setter
    def s3_bucket(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "s3_bucket", value)

    @_builtins.property
    @pulumi.getter(name="s3Key")
    def s3_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Amazon S3 key of your script. For more information, see [Working with Amazon S3 Objects](https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingObjects.html) .
        """
        return pulumi.get(self, "s3_key")

    @s3_key.setter
    def s3_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "s3_key", value)

    @_builtins.property
    @pulumi.getter(name="s3ObjectVersion")
    def s3_object_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Amazon S3 version ID of your script.
        """
        return pulumi.get(self, "s3_object_version")

    @s3_object_version.setter
    def s3_object_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "s3_object_version", value)

    @_builtins.property
    @pulumi.getter
    def script(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If you input your canary script directly into the canary instead of referring to an S3 location, the value of this parameter is the script in plain text. It can be up to 5 MB.
        """
        return pulumi.get(self, "script")

    @script.setter
    def script(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "script", value)

    @_builtins.property
    @pulumi.getter(name="sourceLocationArn")
    def source_location_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ARN of the Lambda layer where Synthetics stores the canary script code.
        """
        return pulumi.get(self, "source_location_arn")

    @source_location_arn.setter
    def source_location_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_location_arn", value)


if not MYPY:
    class CanaryDependencyArgsDict(TypedDict):
        reference: pulumi.Input[_builtins.str]
        """
        ARN of the Lambda layer
        """
        type: NotRequired[pulumi.Input['CanaryDependencyType']]
        """
        Type of dependency
        """
elif False:
    CanaryDependencyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CanaryDependencyArgs:
    def __init__(__self__, *,
                 reference: pulumi.Input[_builtins.str],
                 type: Optional[pulumi.Input['CanaryDependencyType']] = None):
        """
        :param pulumi.Input[_builtins.str] reference: ARN of the Lambda layer
        :param pulumi.Input['CanaryDependencyType'] type: Type of dependency
        """
        pulumi.set(__self__, "reference", reference)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def reference(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of the Lambda layer
        """
        return pulumi.get(self, "reference")

    @reference.setter
    def reference(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "reference", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['CanaryDependencyType']]:
        """
        Type of dependency
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['CanaryDependencyType']]):
        pulumi.set(self, "type", value)


if not MYPY:
    class CanaryRetryConfigArgsDict(TypedDict):
        max_retries: pulumi.Input[_builtins.int]
        """
        maximum times the canary will be retried upon the scheduled run failure
        """
elif False:
    CanaryRetryConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CanaryRetryConfigArgs:
    def __init__(__self__, *,
                 max_retries: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] max_retries: maximum times the canary will be retried upon the scheduled run failure
        """
        pulumi.set(__self__, "max_retries", max_retries)

    @_builtins.property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> pulumi.Input[_builtins.int]:
        """
        maximum times the canary will be retried upon the scheduled run failure
        """
        return pulumi.get(self, "max_retries")

    @max_retries.setter
    def max_retries(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max_retries", value)


if not MYPY:
    class CanaryRunConfigArgsDict(TypedDict):
        active_tracing: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable active tracing if set to true
        """
        environment_variables: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Environment variable key-value pairs.
        """
        ephemeral_storage: NotRequired[pulumi.Input[_builtins.int]]
        """
        Provide ephemeralStorage available for canary in MB
        """
        memory_in_mb: NotRequired[pulumi.Input[_builtins.int]]
        """
        Provide maximum memory available for canary in MB
        """
        timeout_in_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Provide maximum canary timeout per run in seconds
        """
elif False:
    CanaryRunConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CanaryRunConfigArgs:
    def __init__(__self__, *,
                 active_tracing: Optional[pulumi.Input[_builtins.bool]] = None,
                 environment_variables: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 ephemeral_storage: Optional[pulumi.Input[_builtins.int]] = None,
                 memory_in_mb: Optional[pulumi.Input[_builtins.int]] = None,
                 timeout_in_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] active_tracing: Enable active tracing if set to true
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] environment_variables: Environment variable key-value pairs.
        :param pulumi.Input[_builtins.int] ephemeral_storage: Provide ephemeralStorage available for canary in MB
        :param pulumi.Input[_builtins.int] memory_in_mb: Provide maximum memory available for canary in MB
        :param pulumi.Input[_builtins.int] timeout_in_seconds: Provide maximum canary timeout per run in seconds
        """
        if active_tracing is not None:
            pulumi.set(__self__, "active_tracing", active_tracing)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if ephemeral_storage is not None:
            pulumi.set(__self__, "ephemeral_storage", ephemeral_storage)
        if memory_in_mb is not None:
            pulumi.set(__self__, "memory_in_mb", memory_in_mb)
        if timeout_in_seconds is not None:
            pulumi.set(__self__, "timeout_in_seconds", timeout_in_seconds)

    @_builtins.property
    @pulumi.getter(name="activeTracing")
    def active_tracing(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable active tracing if set to true
        """
        return pulumi.get(self, "active_tracing")

    @active_tracing.setter
    def active_tracing(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "active_tracing", value)

    @_builtins.property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Environment variable key-value pairs.
        """
        return pulumi.get(self, "environment_variables")

    @environment_variables.setter
    def environment_variables(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "environment_variables", value)

    @_builtins.property
    @pulumi.getter(name="ephemeralStorage")
    def ephemeral_storage(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Provide ephemeralStorage available for canary in MB
        """
        return pulumi.get(self, "ephemeral_storage")

    @ephemeral_storage.setter
    def ephemeral_storage(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ephemeral_storage", value)

    @_builtins.property
    @pulumi.getter(name="memoryInMb")
    def memory_in_mb(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Provide maximum memory available for canary in MB
        """
        return pulumi.get(self, "memory_in_mb")

    @memory_in_mb.setter
    def memory_in_mb(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "memory_in_mb", value)

    @_builtins.property
    @pulumi.getter(name="timeoutInSeconds")
    def timeout_in_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Provide maximum canary timeout per run in seconds
        """
        return pulumi.get(self, "timeout_in_seconds")

    @timeout_in_seconds.setter
    def timeout_in_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_in_seconds", value)


if not MYPY:
    class CanaryS3EncryptionArgsDict(TypedDict):
        encryption_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Encryption mode for encrypting artifacts when uploading to S3. Valid values: SSE_S3 and SSE_KMS.
        """
        kms_key_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        KMS key Arn for encrypting artifacts when uploading to S3. You must specify KMS key Arn for SSE_KMS encryption mode only.
        """
elif False:
    CanaryS3EncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CanaryS3EncryptionArgs:
    def __init__(__self__, *,
                 encryption_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 kms_key_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] encryption_mode: Encryption mode for encrypting artifacts when uploading to S3. Valid values: SSE_S3 and SSE_KMS.
        :param pulumi.Input[_builtins.str] kms_key_arn: KMS key Arn for encrypting artifacts when uploading to S3. You must specify KMS key Arn for SSE_KMS encryption mode only.
        """
        if encryption_mode is not None:
            pulumi.set(__self__, "encryption_mode", encryption_mode)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @_builtins.property
    @pulumi.getter(name="encryptionMode")
    def encryption_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Encryption mode for encrypting artifacts when uploading to S3. Valid values: SSE_S3 and SSE_KMS.
        """
        return pulumi.get(self, "encryption_mode")

    @encryption_mode.setter
    def encryption_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "encryption_mode", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        KMS key Arn for encrypting artifacts when uploading to S3. You must specify KMS key Arn for SSE_KMS encryption mode only.
        """
        return pulumi.get(self, "kms_key_arn")

    @kms_key_arn.setter
    def kms_key_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_arn", value)


if not MYPY:
    class CanaryScheduleArgsDict(TypedDict):
        expression: pulumi.Input[_builtins.str]
        """
        A `rate` expression or a `cron` expression that defines how often the canary is to run.

        For a rate expression, The syntax is `rate( *number unit* )` . *unit* can be `minute` , `minutes` , or `hour` .

        For example, `rate(1 minute)` runs the canary once a minute, `rate(10 minutes)` runs it once every 10 minutes, and `rate(1 hour)` runs it once every hour. You can specify a frequency between `rate(1 minute)` and `rate(1 hour)` .

        Specifying `rate(0 minute)` or `rate(0 hour)` is a special value that causes the canary to run only once when it is started.

        Use `cron( *expression* )` to specify a cron expression. You can't schedule a canary to wait for more than a year before running. For information about the syntax for cron expressions, see [Scheduling canary runs using cron](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Synthetics_Canaries_cron.html) .
        """
        duration_in_seconds: NotRequired[pulumi.Input[_builtins.str]]
        """
        How long, in seconds, for the canary to continue making regular runs according to the schedule in the `Expression` value. If you specify 0, the canary continues making runs until you stop it. If you omit this field, the default of 0 is used.
        """
        retry_config: NotRequired[pulumi.Input['CanaryRetryConfigArgsDict']]
        """
        Provide canary auto retry configuration
        """
elif False:
    CanaryScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CanaryScheduleArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[_builtins.str],
                 duration_in_seconds: Optional[pulumi.Input[_builtins.str]] = None,
                 retry_config: Optional[pulumi.Input['CanaryRetryConfigArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] expression: A `rate` expression or a `cron` expression that defines how often the canary is to run.
               
               For a rate expression, The syntax is `rate( *number unit* )` . *unit* can be `minute` , `minutes` , or `hour` .
               
               For example, `rate(1 minute)` runs the canary once a minute, `rate(10 minutes)` runs it once every 10 minutes, and `rate(1 hour)` runs it once every hour. You can specify a frequency between `rate(1 minute)` and `rate(1 hour)` .
               
               Specifying `rate(0 minute)` or `rate(0 hour)` is a special value that causes the canary to run only once when it is started.
               
               Use `cron( *expression* )` to specify a cron expression. You can't schedule a canary to wait for more than a year before running. For information about the syntax for cron expressions, see [Scheduling canary runs using cron](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Synthetics_Canaries_cron.html) .
        :param pulumi.Input[_builtins.str] duration_in_seconds: How long, in seconds, for the canary to continue making regular runs according to the schedule in the `Expression` value. If you specify 0, the canary continues making runs until you stop it. If you omit this field, the default of 0 is used.
        :param pulumi.Input['CanaryRetryConfigArgs'] retry_config: Provide canary auto retry configuration
        """
        pulumi.set(__self__, "expression", expression)
        if duration_in_seconds is not None:
            pulumi.set(__self__, "duration_in_seconds", duration_in_seconds)
        if retry_config is not None:
            pulumi.set(__self__, "retry_config", retry_config)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> pulumi.Input[_builtins.str]:
        """
        A `rate` expression or a `cron` expression that defines how often the canary is to run.

        For a rate expression, The syntax is `rate( *number unit* )` . *unit* can be `minute` , `minutes` , or `hour` .

        For example, `rate(1 minute)` runs the canary once a minute, `rate(10 minutes)` runs it once every 10 minutes, and `rate(1 hour)` runs it once every hour. You can specify a frequency between `rate(1 minute)` and `rate(1 hour)` .

        Specifying `rate(0 minute)` or `rate(0 hour)` is a special value that causes the canary to run only once when it is started.

        Use `cron( *expression* )` to specify a cron expression. You can't schedule a canary to wait for more than a year before running. For information about the syntax for cron expressions, see [Scheduling canary runs using cron](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch_Synthetics_Canaries_cron.html) .
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter(name="durationInSeconds")
    def duration_in_seconds(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How long, in seconds, for the canary to continue making regular runs according to the schedule in the `Expression` value. If you specify 0, the canary continues making runs until you stop it. If you omit this field, the default of 0 is used.
        """
        return pulumi.get(self, "duration_in_seconds")

    @duration_in_seconds.setter
    def duration_in_seconds(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "duration_in_seconds", value)

    @_builtins.property
    @pulumi.getter(name="retryConfig")
    def retry_config(self) -> Optional[pulumi.Input['CanaryRetryConfigArgs']]:
        """
        Provide canary auto retry configuration
        """
        return pulumi.get(self, "retry_config")

    @retry_config.setter
    def retry_config(self, value: Optional[pulumi.Input['CanaryRetryConfigArgs']]):
        pulumi.set(self, "retry_config", value)


if not MYPY:
    class CanaryVisualReferenceArgsDict(TypedDict):
        base_canary_run_id: pulumi.Input[_builtins.str]
        """
        Canary run id to be used as base reference for visual testing
        """
        base_screenshots: NotRequired[pulumi.Input[Sequence[pulumi.Input['CanaryBaseScreenshotArgsDict']]]]
        """
        List of screenshots used as base reference for visual testing
        """
        browser_type: NotRequired[pulumi.Input['CanaryBrowserType']]
        """
        The browser type associated with this visual reference configuration. Valid values are `CHROME` and `FIREFOX` .
        """
elif False:
    CanaryVisualReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CanaryVisualReferenceArgs:
    def __init__(__self__, *,
                 base_canary_run_id: pulumi.Input[_builtins.str],
                 base_screenshots: Optional[pulumi.Input[Sequence[pulumi.Input['CanaryBaseScreenshotArgs']]]] = None,
                 browser_type: Optional[pulumi.Input['CanaryBrowserType']] = None):
        """
        :param pulumi.Input[_builtins.str] base_canary_run_id: Canary run id to be used as base reference for visual testing
        :param pulumi.Input[Sequence[pulumi.Input['CanaryBaseScreenshotArgs']]] base_screenshots: List of screenshots used as base reference for visual testing
        :param pulumi.Input['CanaryBrowserType'] browser_type: The browser type associated with this visual reference configuration. Valid values are `CHROME` and `FIREFOX` .
        """
        pulumi.set(__self__, "base_canary_run_id", base_canary_run_id)
        if base_screenshots is not None:
            pulumi.set(__self__, "base_screenshots", base_screenshots)
        if browser_type is not None:
            pulumi.set(__self__, "browser_type", browser_type)

    @_builtins.property
    @pulumi.getter(name="baseCanaryRunId")
    def base_canary_run_id(self) -> pulumi.Input[_builtins.str]:
        """
        Canary run id to be used as base reference for visual testing
        """
        return pulumi.get(self, "base_canary_run_id")

    @base_canary_run_id.setter
    def base_canary_run_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "base_canary_run_id", value)

    @_builtins.property
    @pulumi.getter(name="baseScreenshots")
    def base_screenshots(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CanaryBaseScreenshotArgs']]]]:
        """
        List of screenshots used as base reference for visual testing
        """
        return pulumi.get(self, "base_screenshots")

    @base_screenshots.setter
    def base_screenshots(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CanaryBaseScreenshotArgs']]]]):
        pulumi.set(self, "base_screenshots", value)

    @_builtins.property
    @pulumi.getter(name="browserType")
    def browser_type(self) -> Optional[pulumi.Input['CanaryBrowserType']]:
        """
        The browser type associated with this visual reference configuration. Valid values are `CHROME` and `FIREFOX` .
        """
        return pulumi.get(self, "browser_type")

    @browser_type.setter
    def browser_type(self, value: Optional[pulumi.Input['CanaryBrowserType']]):
        pulumi.set(self, "browser_type", value)


if not MYPY:
    class CanaryVpcConfigArgsDict(TypedDict):
        security_group_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The IDs of the security groups for this canary.
        """
        subnet_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The IDs of the subnets where this canary is to run.
        """
        ipv6_allowed_for_dual_stack: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allow outbound IPv6 traffic on VPC canaries that are connected to dual-stack subnets if set to true
        """
        vpc_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the VPC where this canary is to run.
        """
elif False:
    CanaryVpcConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CanaryVpcConfigArgs:
    def __init__(__self__, *,
                 security_group_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 subnet_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 ipv6_allowed_for_dual_stack: Optional[pulumi.Input[_builtins.bool]] = None,
                 vpc_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] security_group_ids: The IDs of the security groups for this canary.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] subnet_ids: The IDs of the subnets where this canary is to run.
        :param pulumi.Input[_builtins.bool] ipv6_allowed_for_dual_stack: Allow outbound IPv6 traffic on VPC canaries that are connected to dual-stack subnets if set to true
        :param pulumi.Input[_builtins.str] vpc_id: The ID of the VPC where this canary is to run.
        """
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnet_ids", subnet_ids)
        if ipv6_allowed_for_dual_stack is not None:
            pulumi.set(__self__, "ipv6_allowed_for_dual_stack", ipv6_allowed_for_dual_stack)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The IDs of the security groups for this canary.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "security_group_ids", value)

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The IDs of the subnets where this canary is to run.
        """
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "subnet_ids", value)

    @_builtins.property
    @pulumi.getter(name="ipv6AllowedForDualStack")
    def ipv6_allowed_for_dual_stack(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allow outbound IPv6 traffic on VPC canaries that are connected to dual-stack subnets if set to true
        """
        return pulumi.get(self, "ipv6_allowed_for_dual_stack")

    @ipv6_allowed_for_dual_stack.setter
    def ipv6_allowed_for_dual_stack(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ipv6_allowed_for_dual_stack", value)

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the VPC where this canary is to run.
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vpc_id", value)


