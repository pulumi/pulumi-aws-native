# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AnnotationStoreReferenceItem',
    'AnnotationStoreSseConfig',
    'AnnotationStoreStoreOptionsProperties',
    'AnnotationStoreTsvStoreOptions',
    'ReferenceStoreSseConfig',
    'SequenceStoreSseConfig',
    'VariantStoreReferenceItem',
    'VariantStoreSseConfig',
    'WorkflowContainerRegistryMap',
    'WorkflowDefinitionRepository',
    'WorkflowImageMapping',
    'WorkflowParameter',
    'WorkflowRegistryMapping',
    'WorkflowSourceReference',
    'WorkflowVersionContainerRegistryMap',
    'WorkflowVersionDefinitionRepository',
    'WorkflowVersionImageMapping',
    'WorkflowVersionRegistryMapping',
    'WorkflowVersionSourceReference',
    'WorkflowVersionWorkflowParameter',
]

@pulumi.output_type
class AnnotationStoreReferenceItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "referenceArn":
            suggest = "reference_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnnotationStoreReferenceItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnnotationStoreReferenceItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnnotationStoreReferenceItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 reference_arn: _builtins.str):
        """
        :param _builtins.str reference_arn: The reference's ARN.
        """
        pulumi.set(__self__, "reference_arn", reference_arn)

    @_builtins.property
    @pulumi.getter(name="referenceArn")
    def reference_arn(self) -> _builtins.str:
        """
        The reference's ARN.
        """
        return pulumi.get(self, "reference_arn")


@pulumi.output_type
class AnnotationStoreSseConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyArn":
            suggest = "key_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnnotationStoreSseConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnnotationStoreSseConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnnotationStoreSseConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: 'AnnotationStoreEncryptionType',
                 key_arn: Optional[_builtins.str] = None):
        """
        :param 'AnnotationStoreEncryptionType' type: The encryption type.
        :param _builtins.str key_arn: An encryption key ARN.
        """
        pulumi.set(__self__, "type", type)
        if key_arn is not None:
            pulumi.set(__self__, "key_arn", key_arn)

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'AnnotationStoreEncryptionType':
        """
        The encryption type.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="keyArn")
    def key_arn(self) -> Optional[_builtins.str]:
        """
        An encryption key ARN.
        """
        return pulumi.get(self, "key_arn")


@pulumi.output_type
class AnnotationStoreStoreOptionsProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tsvStoreOptions":
            suggest = "tsv_store_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnnotationStoreStoreOptionsProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnnotationStoreStoreOptionsProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnnotationStoreStoreOptionsProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tsv_store_options: 'outputs.AnnotationStoreTsvStoreOptions'):
        pulumi.set(__self__, "tsv_store_options", tsv_store_options)

    @_builtins.property
    @pulumi.getter(name="tsvStoreOptions")
    def tsv_store_options(self) -> 'outputs.AnnotationStoreTsvStoreOptions':
        return pulumi.get(self, "tsv_store_options")


@pulumi.output_type
class AnnotationStoreTsvStoreOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "annotationType":
            suggest = "annotation_type"
        elif key == "formatToHeader":
            suggest = "format_to_header"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnnotationStoreTsvStoreOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnnotationStoreTsvStoreOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnnotationStoreTsvStoreOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 annotation_type: Optional['AnnotationStoreAnnotationType'] = None,
                 format_to_header: Optional[Mapping[str, _builtins.str]] = None,
                 schema: Optional[Sequence[Mapping[str, 'AnnotationStoreSchemaValueType']]] = None):
        if annotation_type is not None:
            pulumi.set(__self__, "annotation_type", annotation_type)
        if format_to_header is not None:
            pulumi.set(__self__, "format_to_header", format_to_header)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)

    @_builtins.property
    @pulumi.getter(name="annotationType")
    def annotation_type(self) -> Optional['AnnotationStoreAnnotationType']:
        return pulumi.get(self, "annotation_type")

    @_builtins.property
    @pulumi.getter(name="formatToHeader")
    def format_to_header(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "format_to_header")

    @_builtins.property
    @pulumi.getter
    def schema(self) -> Optional[Sequence[Mapping[str, 'AnnotationStoreSchemaValueType']]]:
        return pulumi.get(self, "schema")


@pulumi.output_type
class ReferenceStoreSseConfig(dict):
    """
    Server-side encryption (SSE) settings for a store.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyArn":
            suggest = "key_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReferenceStoreSseConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReferenceStoreSseConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReferenceStoreSseConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: 'ReferenceStoreEncryptionType',
                 key_arn: Optional[_builtins.str] = None):
        """
        Server-side encryption (SSE) settings for a store.
        :param 'ReferenceStoreEncryptionType' type: The encryption type.
        :param _builtins.str key_arn: An encryption key ARN.
        """
        pulumi.set(__self__, "type", type)
        if key_arn is not None:
            pulumi.set(__self__, "key_arn", key_arn)

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'ReferenceStoreEncryptionType':
        """
        The encryption type.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="keyArn")
    def key_arn(self) -> Optional[_builtins.str]:
        """
        An encryption key ARN.
        """
        return pulumi.get(self, "key_arn")


@pulumi.output_type
class SequenceStoreSseConfig(dict):
    """
    Server-side encryption (SSE) settings for a store.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyArn":
            suggest = "key_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SequenceStoreSseConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SequenceStoreSseConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SequenceStoreSseConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: 'SequenceStoreEncryptionType',
                 key_arn: Optional[_builtins.str] = None):
        """
        Server-side encryption (SSE) settings for a store.
        :param 'SequenceStoreEncryptionType' type: The encryption type.
        :param _builtins.str key_arn: An encryption key ARN.
        """
        pulumi.set(__self__, "type", type)
        if key_arn is not None:
            pulumi.set(__self__, "key_arn", key_arn)

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'SequenceStoreEncryptionType':
        """
        The encryption type.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="keyArn")
    def key_arn(self) -> Optional[_builtins.str]:
        """
        An encryption key ARN.
        """
        return pulumi.get(self, "key_arn")


@pulumi.output_type
class VariantStoreReferenceItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "referenceArn":
            suggest = "reference_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VariantStoreReferenceItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VariantStoreReferenceItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VariantStoreReferenceItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 reference_arn: _builtins.str):
        """
        :param _builtins.str reference_arn: The reference's ARN.
        """
        pulumi.set(__self__, "reference_arn", reference_arn)

    @_builtins.property
    @pulumi.getter(name="referenceArn")
    def reference_arn(self) -> _builtins.str:
        """
        The reference's ARN.
        """
        return pulumi.get(self, "reference_arn")


@pulumi.output_type
class VariantStoreSseConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyArn":
            suggest = "key_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VariantStoreSseConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VariantStoreSseConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VariantStoreSseConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: 'VariantStoreEncryptionType',
                 key_arn: Optional[_builtins.str] = None):
        """
        :param 'VariantStoreEncryptionType' type: The encryption type.
        :param _builtins.str key_arn: An encryption key ARN.
        """
        pulumi.set(__self__, "type", type)
        if key_arn is not None:
            pulumi.set(__self__, "key_arn", key_arn)

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'VariantStoreEncryptionType':
        """
        The encryption type.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="keyArn")
    def key_arn(self) -> Optional[_builtins.str]:
        """
        An encryption key ARN.
        """
        return pulumi.get(self, "key_arn")


@pulumi.output_type
class WorkflowContainerRegistryMap(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageMappings":
            suggest = "image_mappings"
        elif key == "registryMappings":
            suggest = "registry_mappings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowContainerRegistryMap. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowContainerRegistryMap.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowContainerRegistryMap.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_mappings: Optional[Sequence['outputs.WorkflowImageMapping']] = None,
                 registry_mappings: Optional[Sequence['outputs.WorkflowRegistryMapping']] = None):
        """
        :param Sequence['WorkflowImageMapping'] image_mappings: Image mappings specify path mappings between the ECR private repository and their corresponding external repositories.
        :param Sequence['WorkflowRegistryMapping'] registry_mappings: Mapping that provides the ECR repository path where upstream container images are pulled and synchronized.
        """
        if image_mappings is not None:
            pulumi.set(__self__, "image_mappings", image_mappings)
        if registry_mappings is not None:
            pulumi.set(__self__, "registry_mappings", registry_mappings)

    @_builtins.property
    @pulumi.getter(name="imageMappings")
    def image_mappings(self) -> Optional[Sequence['outputs.WorkflowImageMapping']]:
        """
        Image mappings specify path mappings between the ECR private repository and their corresponding external repositories.
        """
        return pulumi.get(self, "image_mappings")

    @_builtins.property
    @pulumi.getter(name="registryMappings")
    def registry_mappings(self) -> Optional[Sequence['outputs.WorkflowRegistryMapping']]:
        """
        Mapping that provides the ECR repository path where upstream container images are pulled and synchronized.
        """
        return pulumi.get(self, "registry_mappings")


@pulumi.output_type
class WorkflowDefinitionRepository(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionArn":
            suggest = "connection_arn"
        elif key == "excludeFilePatterns":
            suggest = "exclude_file_patterns"
        elif key == "fullRepositoryId":
            suggest = "full_repository_id"
        elif key == "sourceReference":
            suggest = "source_reference"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowDefinitionRepository. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowDefinitionRepository.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowDefinitionRepository.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_arn: Optional[_builtins.str] = None,
                 exclude_file_patterns: Optional[Sequence[_builtins.str]] = None,
                 full_repository_id: Optional[_builtins.str] = None,
                 source_reference: Optional['outputs.WorkflowSourceReference'] = None):
        """
        :param _builtins.str connection_arn: The Amazon Resource Name (ARN) of the connection to the source code repository.
        :param Sequence[_builtins.str] exclude_file_patterns: A list of file patterns to exclude when retrieving the workflow definition from the repository.
        :param _builtins.str full_repository_id: The full repository identifier, including the repository owner and name. For example, 'repository-owner/repository-name'.
        :param 'WorkflowSourceReference' source_reference: The source reference for the repository, such as a branch name, tag, or commit ID.
        """
        if connection_arn is not None:
            pulumi.set(__self__, "connection_arn", connection_arn)
        if exclude_file_patterns is not None:
            pulumi.set(__self__, "exclude_file_patterns", exclude_file_patterns)
        if full_repository_id is not None:
            pulumi.set(__self__, "full_repository_id", full_repository_id)
        if source_reference is not None:
            pulumi.set(__self__, "source_reference", source_reference)

    @_builtins.property
    @pulumi.getter(name="connectionArn")
    def connection_arn(self) -> Optional[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the connection to the source code repository.
        """
        return pulumi.get(self, "connection_arn")

    @_builtins.property
    @pulumi.getter(name="excludeFilePatterns")
    def exclude_file_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of file patterns to exclude when retrieving the workflow definition from the repository.
        """
        return pulumi.get(self, "exclude_file_patterns")

    @_builtins.property
    @pulumi.getter(name="fullRepositoryId")
    def full_repository_id(self) -> Optional[_builtins.str]:
        """
        The full repository identifier, including the repository owner and name. For example, 'repository-owner/repository-name'.
        """
        return pulumi.get(self, "full_repository_id")

    @_builtins.property
    @pulumi.getter(name="sourceReference")
    def source_reference(self) -> Optional['outputs.WorkflowSourceReference']:
        """
        The source reference for the repository, such as a branch name, tag, or commit ID.
        """
        return pulumi.get(self, "source_reference")


@pulumi.output_type
class WorkflowImageMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationImage":
            suggest = "destination_image"
        elif key == "sourceImage":
            suggest = "source_image"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowImageMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowImageMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowImageMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_image: Optional[_builtins.str] = None,
                 source_image: Optional[_builtins.str] = None):
        """
        :param _builtins.str destination_image: Specifies the URI of the corresponding image in the private ECR registry.
        :param _builtins.str source_image: Specifies the URI of the source image in the upstream registry.
        """
        if destination_image is not None:
            pulumi.set(__self__, "destination_image", destination_image)
        if source_image is not None:
            pulumi.set(__self__, "source_image", source_image)

    @_builtins.property
    @pulumi.getter(name="destinationImage")
    def destination_image(self) -> Optional[_builtins.str]:
        """
        Specifies the URI of the corresponding image in the private ECR registry.
        """
        return pulumi.get(self, "destination_image")

    @_builtins.property
    @pulumi.getter(name="sourceImage")
    def source_image(self) -> Optional[_builtins.str]:
        """
        Specifies the URI of the source image in the upstream registry.
        """
        return pulumi.get(self, "source_image")


@pulumi.output_type
class WorkflowParameter(dict):
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 optional: Optional[_builtins.bool] = None):
        """
        :param _builtins.str description: The parameter's description.
        :param _builtins.bool optional: Whether the parameter is optional.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The parameter's description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def optional(self) -> Optional[_builtins.bool]:
        """
        Whether the parameter is optional.
        """
        return pulumi.get(self, "optional")


@pulumi.output_type
class WorkflowRegistryMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ecrAccountId":
            suggest = "ecr_account_id"
        elif key == "ecrRepositoryPrefix":
            suggest = "ecr_repository_prefix"
        elif key == "upstreamRegistryUrl":
            suggest = "upstream_registry_url"
        elif key == "upstreamRepositoryPrefix":
            suggest = "upstream_repository_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowRegistryMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowRegistryMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowRegistryMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ecr_account_id: Optional[_builtins.str] = None,
                 ecr_repository_prefix: Optional[_builtins.str] = None,
                 upstream_registry_url: Optional[_builtins.str] = None,
                 upstream_repository_prefix: Optional[_builtins.str] = None):
        """
        :param _builtins.str ecr_account_id: Account ID of the account that owns the upstream container image.
        :param _builtins.str ecr_repository_prefix: The repository prefix to use in the ECR private repository.
        :param _builtins.str upstream_registry_url: The URI of the upstream registry.
        :param _builtins.str upstream_repository_prefix: The repository prefix of the corresponding repository in the upstream registry.
        """
        if ecr_account_id is not None:
            pulumi.set(__self__, "ecr_account_id", ecr_account_id)
        if ecr_repository_prefix is not None:
            pulumi.set(__self__, "ecr_repository_prefix", ecr_repository_prefix)
        if upstream_registry_url is not None:
            pulumi.set(__self__, "upstream_registry_url", upstream_registry_url)
        if upstream_repository_prefix is not None:
            pulumi.set(__self__, "upstream_repository_prefix", upstream_repository_prefix)

    @_builtins.property
    @pulumi.getter(name="ecrAccountId")
    def ecr_account_id(self) -> Optional[_builtins.str]:
        """
        Account ID of the account that owns the upstream container image.
        """
        return pulumi.get(self, "ecr_account_id")

    @_builtins.property
    @pulumi.getter(name="ecrRepositoryPrefix")
    def ecr_repository_prefix(self) -> Optional[_builtins.str]:
        """
        The repository prefix to use in the ECR private repository.
        """
        return pulumi.get(self, "ecr_repository_prefix")

    @_builtins.property
    @pulumi.getter(name="upstreamRegistryUrl")
    def upstream_registry_url(self) -> Optional[_builtins.str]:
        """
        The URI of the upstream registry.
        """
        return pulumi.get(self, "upstream_registry_url")

    @_builtins.property
    @pulumi.getter(name="upstreamRepositoryPrefix")
    def upstream_repository_prefix(self) -> Optional[_builtins.str]:
        """
        The repository prefix of the corresponding repository in the upstream registry.
        """
        return pulumi.get(self, "upstream_repository_prefix")


@pulumi.output_type
class WorkflowSourceReference(dict):
    def __init__(__self__, *,
                 type: Optional['WorkflowSourceReferencetype'] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param 'WorkflowSourceReferencetype' type: The type of source reference, such as branch, tag, or commit.
        :param _builtins.str value: The value of the source reference, such as the branch name, tag name, or commit ID.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional['WorkflowSourceReferencetype']:
        """
        The type of source reference, such as branch, tag, or commit.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The value of the source reference, such as the branch name, tag name, or commit ID.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class WorkflowVersionContainerRegistryMap(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageMappings":
            suggest = "image_mappings"
        elif key == "registryMappings":
            suggest = "registry_mappings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowVersionContainerRegistryMap. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowVersionContainerRegistryMap.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowVersionContainerRegistryMap.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_mappings: Optional[Sequence['outputs.WorkflowVersionImageMapping']] = None,
                 registry_mappings: Optional[Sequence['outputs.WorkflowVersionRegistryMapping']] = None):
        """
        :param Sequence['WorkflowVersionImageMapping'] image_mappings: Image mappings specify path mappings between the ECR private repository and their corresponding external repositories.
        :param Sequence['WorkflowVersionRegistryMapping'] registry_mappings: Mapping that provides the ECR repository path where upstream container images are pulled and synchronized.
        """
        if image_mappings is not None:
            pulumi.set(__self__, "image_mappings", image_mappings)
        if registry_mappings is not None:
            pulumi.set(__self__, "registry_mappings", registry_mappings)

    @_builtins.property
    @pulumi.getter(name="imageMappings")
    def image_mappings(self) -> Optional[Sequence['outputs.WorkflowVersionImageMapping']]:
        """
        Image mappings specify path mappings between the ECR private repository and their corresponding external repositories.
        """
        return pulumi.get(self, "image_mappings")

    @_builtins.property
    @pulumi.getter(name="registryMappings")
    def registry_mappings(self) -> Optional[Sequence['outputs.WorkflowVersionRegistryMapping']]:
        """
        Mapping that provides the ECR repository path where upstream container images are pulled and synchronized.
        """
        return pulumi.get(self, "registry_mappings")


@pulumi.output_type
class WorkflowVersionDefinitionRepository(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionArn":
            suggest = "connection_arn"
        elif key == "excludeFilePatterns":
            suggest = "exclude_file_patterns"
        elif key == "fullRepositoryId":
            suggest = "full_repository_id"
        elif key == "sourceReference":
            suggest = "source_reference"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowVersionDefinitionRepository. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowVersionDefinitionRepository.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowVersionDefinitionRepository.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_arn: Optional[_builtins.str] = None,
                 exclude_file_patterns: Optional[Sequence[_builtins.str]] = None,
                 full_repository_id: Optional[_builtins.str] = None,
                 source_reference: Optional['outputs.WorkflowVersionSourceReference'] = None):
        """
        :param _builtins.str connection_arn: The Amazon Resource Name (ARN) of the connection to the source code repository.
        :param Sequence[_builtins.str] exclude_file_patterns: A list of file patterns to exclude when retrieving the workflow definition from the repository.
        :param _builtins.str full_repository_id: The full repository identifier, including the repository owner and name. For example, 'repository-owner/repository-name'.
        :param 'WorkflowVersionSourceReference' source_reference: The source reference for the repository, such as a branch name, tag, or commit ID.
        """
        if connection_arn is not None:
            pulumi.set(__self__, "connection_arn", connection_arn)
        if exclude_file_patterns is not None:
            pulumi.set(__self__, "exclude_file_patterns", exclude_file_patterns)
        if full_repository_id is not None:
            pulumi.set(__self__, "full_repository_id", full_repository_id)
        if source_reference is not None:
            pulumi.set(__self__, "source_reference", source_reference)

    @_builtins.property
    @pulumi.getter(name="connectionArn")
    def connection_arn(self) -> Optional[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the connection to the source code repository.
        """
        return pulumi.get(self, "connection_arn")

    @_builtins.property
    @pulumi.getter(name="excludeFilePatterns")
    def exclude_file_patterns(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of file patterns to exclude when retrieving the workflow definition from the repository.
        """
        return pulumi.get(self, "exclude_file_patterns")

    @_builtins.property
    @pulumi.getter(name="fullRepositoryId")
    def full_repository_id(self) -> Optional[_builtins.str]:
        """
        The full repository identifier, including the repository owner and name. For example, 'repository-owner/repository-name'.
        """
        return pulumi.get(self, "full_repository_id")

    @_builtins.property
    @pulumi.getter(name="sourceReference")
    def source_reference(self) -> Optional['outputs.WorkflowVersionSourceReference']:
        """
        The source reference for the repository, such as a branch name, tag, or commit ID.
        """
        return pulumi.get(self, "source_reference")


@pulumi.output_type
class WorkflowVersionImageMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationImage":
            suggest = "destination_image"
        elif key == "sourceImage":
            suggest = "source_image"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowVersionImageMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowVersionImageMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowVersionImageMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_image: Optional[_builtins.str] = None,
                 source_image: Optional[_builtins.str] = None):
        """
        :param _builtins.str destination_image: Specifies the URI of the corresponding image in the private ECR registry.
        :param _builtins.str source_image: Specifies the URI of the source image in the upstream registry.
        """
        if destination_image is not None:
            pulumi.set(__self__, "destination_image", destination_image)
        if source_image is not None:
            pulumi.set(__self__, "source_image", source_image)

    @_builtins.property
    @pulumi.getter(name="destinationImage")
    def destination_image(self) -> Optional[_builtins.str]:
        """
        Specifies the URI of the corresponding image in the private ECR registry.
        """
        return pulumi.get(self, "destination_image")

    @_builtins.property
    @pulumi.getter(name="sourceImage")
    def source_image(self) -> Optional[_builtins.str]:
        """
        Specifies the URI of the source image in the upstream registry.
        """
        return pulumi.get(self, "source_image")


@pulumi.output_type
class WorkflowVersionRegistryMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ecrAccountId":
            suggest = "ecr_account_id"
        elif key == "ecrRepositoryPrefix":
            suggest = "ecr_repository_prefix"
        elif key == "upstreamRegistryUrl":
            suggest = "upstream_registry_url"
        elif key == "upstreamRepositoryPrefix":
            suggest = "upstream_repository_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkflowVersionRegistryMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkflowVersionRegistryMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkflowVersionRegistryMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ecr_account_id: Optional[_builtins.str] = None,
                 ecr_repository_prefix: Optional[_builtins.str] = None,
                 upstream_registry_url: Optional[_builtins.str] = None,
                 upstream_repository_prefix: Optional[_builtins.str] = None):
        """
        :param _builtins.str ecr_account_id: Account ID of the account that owns the upstream container image.
        :param _builtins.str ecr_repository_prefix: The repository prefix to use in the ECR private repository.
        :param _builtins.str upstream_registry_url: The URI of the upstream registry.
        :param _builtins.str upstream_repository_prefix: The repository prefix of the corresponding repository in the upstream registry.
        """
        if ecr_account_id is not None:
            pulumi.set(__self__, "ecr_account_id", ecr_account_id)
        if ecr_repository_prefix is not None:
            pulumi.set(__self__, "ecr_repository_prefix", ecr_repository_prefix)
        if upstream_registry_url is not None:
            pulumi.set(__self__, "upstream_registry_url", upstream_registry_url)
        if upstream_repository_prefix is not None:
            pulumi.set(__self__, "upstream_repository_prefix", upstream_repository_prefix)

    @_builtins.property
    @pulumi.getter(name="ecrAccountId")
    def ecr_account_id(self) -> Optional[_builtins.str]:
        """
        Account ID of the account that owns the upstream container image.
        """
        return pulumi.get(self, "ecr_account_id")

    @_builtins.property
    @pulumi.getter(name="ecrRepositoryPrefix")
    def ecr_repository_prefix(self) -> Optional[_builtins.str]:
        """
        The repository prefix to use in the ECR private repository.
        """
        return pulumi.get(self, "ecr_repository_prefix")

    @_builtins.property
    @pulumi.getter(name="upstreamRegistryUrl")
    def upstream_registry_url(self) -> Optional[_builtins.str]:
        """
        The URI of the upstream registry.
        """
        return pulumi.get(self, "upstream_registry_url")

    @_builtins.property
    @pulumi.getter(name="upstreamRepositoryPrefix")
    def upstream_repository_prefix(self) -> Optional[_builtins.str]:
        """
        The repository prefix of the corresponding repository in the upstream registry.
        """
        return pulumi.get(self, "upstream_repository_prefix")


@pulumi.output_type
class WorkflowVersionSourceReference(dict):
    def __init__(__self__, *,
                 type: Optional['WorkflowVersionSourceReferencetype'] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param 'WorkflowVersionSourceReferencetype' type: The type of source reference, such as branch, tag, or commit.
        :param _builtins.str value: The value of the source reference, such as the branch name, tag name, or commit ID.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional['WorkflowVersionSourceReferencetype']:
        """
        The type of source reference, such as branch, tag, or commit.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The value of the source reference, such as the branch name, tag name, or commit ID.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class WorkflowVersionWorkflowParameter(dict):
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 optional: Optional[_builtins.bool] = None):
        """
        :param _builtins.str description: The parameter's description.
        :param _builtins.bool optional: Whether the parameter is optional.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The parameter's description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def optional(self) -> Optional[_builtins.bool]:
        """
        Whether the parameter is optional.
        """
        return pulumi.get(self, "optional")


