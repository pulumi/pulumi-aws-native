# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'AnnotationStoreReferenceItemArgs',
    'AnnotationStoreReferenceItemArgsDict',
    'AnnotationStoreSseConfigArgs',
    'AnnotationStoreSseConfigArgsDict',
    'AnnotationStoreStoreOptionsPropertiesArgs',
    'AnnotationStoreStoreOptionsPropertiesArgsDict',
    'AnnotationStoreTsvStoreOptionsArgs',
    'AnnotationStoreTsvStoreOptionsArgsDict',
    'ReferenceStoreSseConfigArgs',
    'ReferenceStoreSseConfigArgsDict',
    'SequenceStoreSseConfigArgs',
    'SequenceStoreSseConfigArgsDict',
    'VariantStoreReferenceItemArgs',
    'VariantStoreReferenceItemArgsDict',
    'VariantStoreSseConfigArgs',
    'VariantStoreSseConfigArgsDict',
    'WorkflowContainerRegistryMapArgs',
    'WorkflowContainerRegistryMapArgsDict',
    'WorkflowDefinitionRepositoryArgs',
    'WorkflowDefinitionRepositoryArgsDict',
    'WorkflowImageMappingArgs',
    'WorkflowImageMappingArgsDict',
    'WorkflowParameterArgs',
    'WorkflowParameterArgsDict',
    'WorkflowRegistryMappingArgs',
    'WorkflowRegistryMappingArgsDict',
    'WorkflowSourceReferenceArgs',
    'WorkflowSourceReferenceArgsDict',
    'WorkflowVersionContainerRegistryMapArgs',
    'WorkflowVersionContainerRegistryMapArgsDict',
    'WorkflowVersionDefinitionRepositoryArgs',
    'WorkflowVersionDefinitionRepositoryArgsDict',
    'WorkflowVersionImageMappingArgs',
    'WorkflowVersionImageMappingArgsDict',
    'WorkflowVersionRegistryMappingArgs',
    'WorkflowVersionRegistryMappingArgsDict',
    'WorkflowVersionSourceReferenceArgs',
    'WorkflowVersionSourceReferenceArgsDict',
    'WorkflowVersionWorkflowParameterArgs',
    'WorkflowVersionWorkflowParameterArgsDict',
]

MYPY = False

if not MYPY:
    class AnnotationStoreReferenceItemArgsDict(TypedDict):
        reference_arn: pulumi.Input[_builtins.str]
        """
        The reference's ARN.
        """
elif False:
    AnnotationStoreReferenceItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnnotationStoreReferenceItemArgs:
    def __init__(__self__, *,
                 reference_arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] reference_arn: The reference's ARN.
        """
        pulumi.set(__self__, "reference_arn", reference_arn)

    @_builtins.property
    @pulumi.getter(name="referenceArn")
    def reference_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The reference's ARN.
        """
        return pulumi.get(self, "reference_arn")

    @reference_arn.setter
    def reference_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "reference_arn", value)


if not MYPY:
    class AnnotationStoreSseConfigArgsDict(TypedDict):
        type: pulumi.Input['AnnotationStoreEncryptionType']
        """
        The encryption type.
        """
        key_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        An encryption key ARN.
        """
elif False:
    AnnotationStoreSseConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnnotationStoreSseConfigArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['AnnotationStoreEncryptionType'],
                 key_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['AnnotationStoreEncryptionType'] type: The encryption type.
        :param pulumi.Input[_builtins.str] key_arn: An encryption key ARN.
        """
        pulumi.set(__self__, "type", type)
        if key_arn is not None:
            pulumi.set(__self__, "key_arn", key_arn)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['AnnotationStoreEncryptionType']:
        """
        The encryption type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['AnnotationStoreEncryptionType']):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="keyArn")
    def key_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An encryption key ARN.
        """
        return pulumi.get(self, "key_arn")

    @key_arn.setter
    def key_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_arn", value)


if not MYPY:
    class AnnotationStoreStoreOptionsPropertiesArgsDict(TypedDict):
        tsv_store_options: pulumi.Input['AnnotationStoreTsvStoreOptionsArgsDict']
elif False:
    AnnotationStoreStoreOptionsPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnnotationStoreStoreOptionsPropertiesArgs:
    def __init__(__self__, *,
                 tsv_store_options: pulumi.Input['AnnotationStoreTsvStoreOptionsArgs']):
        pulumi.set(__self__, "tsv_store_options", tsv_store_options)

    @_builtins.property
    @pulumi.getter(name="tsvStoreOptions")
    def tsv_store_options(self) -> pulumi.Input['AnnotationStoreTsvStoreOptionsArgs']:
        return pulumi.get(self, "tsv_store_options")

    @tsv_store_options.setter
    def tsv_store_options(self, value: pulumi.Input['AnnotationStoreTsvStoreOptionsArgs']):
        pulumi.set(self, "tsv_store_options", value)


if not MYPY:
    class AnnotationStoreTsvStoreOptionsArgsDict(TypedDict):
        annotation_type: NotRequired[pulumi.Input['AnnotationStoreAnnotationType']]
        format_to_header: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        schema: NotRequired[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input['AnnotationStoreSchemaValueType']]]]]]
elif False:
    AnnotationStoreTsvStoreOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnnotationStoreTsvStoreOptionsArgs:
    def __init__(__self__, *,
                 annotation_type: Optional[pulumi.Input['AnnotationStoreAnnotationType']] = None,
                 format_to_header: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 schema: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input['AnnotationStoreSchemaValueType']]]]]] = None):
        if annotation_type is not None:
            pulumi.set(__self__, "annotation_type", annotation_type)
        if format_to_header is not None:
            pulumi.set(__self__, "format_to_header", format_to_header)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)

    @_builtins.property
    @pulumi.getter(name="annotationType")
    def annotation_type(self) -> Optional[pulumi.Input['AnnotationStoreAnnotationType']]:
        return pulumi.get(self, "annotation_type")

    @annotation_type.setter
    def annotation_type(self, value: Optional[pulumi.Input['AnnotationStoreAnnotationType']]):
        pulumi.set(self, "annotation_type", value)

    @_builtins.property
    @pulumi.getter(name="formatToHeader")
    def format_to_header(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "format_to_header")

    @format_to_header.setter
    def format_to_header(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "format_to_header", value)

    @_builtins.property
    @pulumi.getter
    def schema(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input['AnnotationStoreSchemaValueType']]]]]]:
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input['AnnotationStoreSchemaValueType']]]]]]):
        pulumi.set(self, "schema", value)


if not MYPY:
    class ReferenceStoreSseConfigArgsDict(TypedDict):
        """
        Server-side encryption (SSE) settings for a store.
        """
        type: pulumi.Input['ReferenceStoreEncryptionType']
        """
        The encryption type.
        """
        key_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        An encryption key ARN.
        """
elif False:
    ReferenceStoreSseConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReferenceStoreSseConfigArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['ReferenceStoreEncryptionType'],
                 key_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Server-side encryption (SSE) settings for a store.
        :param pulumi.Input['ReferenceStoreEncryptionType'] type: The encryption type.
        :param pulumi.Input[_builtins.str] key_arn: An encryption key ARN.
        """
        pulumi.set(__self__, "type", type)
        if key_arn is not None:
            pulumi.set(__self__, "key_arn", key_arn)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['ReferenceStoreEncryptionType']:
        """
        The encryption type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['ReferenceStoreEncryptionType']):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="keyArn")
    def key_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An encryption key ARN.
        """
        return pulumi.get(self, "key_arn")

    @key_arn.setter
    def key_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_arn", value)


if not MYPY:
    class SequenceStoreSseConfigArgsDict(TypedDict):
        """
        Server-side encryption (SSE) settings for a store.
        """
        type: pulumi.Input['SequenceStoreEncryptionType']
        """
        The encryption type.
        """
        key_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        An encryption key ARN.
        """
elif False:
    SequenceStoreSseConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SequenceStoreSseConfigArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['SequenceStoreEncryptionType'],
                 key_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Server-side encryption (SSE) settings for a store.
        :param pulumi.Input['SequenceStoreEncryptionType'] type: The encryption type.
        :param pulumi.Input[_builtins.str] key_arn: An encryption key ARN.
        """
        pulumi.set(__self__, "type", type)
        if key_arn is not None:
            pulumi.set(__self__, "key_arn", key_arn)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['SequenceStoreEncryptionType']:
        """
        The encryption type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['SequenceStoreEncryptionType']):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="keyArn")
    def key_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An encryption key ARN.
        """
        return pulumi.get(self, "key_arn")

    @key_arn.setter
    def key_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_arn", value)


if not MYPY:
    class VariantStoreReferenceItemArgsDict(TypedDict):
        reference_arn: pulumi.Input[_builtins.str]
        """
        The reference's ARN.
        """
elif False:
    VariantStoreReferenceItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VariantStoreReferenceItemArgs:
    def __init__(__self__, *,
                 reference_arn: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] reference_arn: The reference's ARN.
        """
        pulumi.set(__self__, "reference_arn", reference_arn)

    @_builtins.property
    @pulumi.getter(name="referenceArn")
    def reference_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The reference's ARN.
        """
        return pulumi.get(self, "reference_arn")

    @reference_arn.setter
    def reference_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "reference_arn", value)


if not MYPY:
    class VariantStoreSseConfigArgsDict(TypedDict):
        type: pulumi.Input['VariantStoreEncryptionType']
        """
        The encryption type.
        """
        key_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        An encryption key ARN.
        """
elif False:
    VariantStoreSseConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VariantStoreSseConfigArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['VariantStoreEncryptionType'],
                 key_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['VariantStoreEncryptionType'] type: The encryption type.
        :param pulumi.Input[_builtins.str] key_arn: An encryption key ARN.
        """
        pulumi.set(__self__, "type", type)
        if key_arn is not None:
            pulumi.set(__self__, "key_arn", key_arn)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['VariantStoreEncryptionType']:
        """
        The encryption type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['VariantStoreEncryptionType']):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="keyArn")
    def key_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An encryption key ARN.
        """
        return pulumi.get(self, "key_arn")

    @key_arn.setter
    def key_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_arn", value)


if not MYPY:
    class WorkflowContainerRegistryMapArgsDict(TypedDict):
        image_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['WorkflowImageMappingArgsDict']]]]
        """
        Image mappings specify path mappings between the ECR private repository and their corresponding external repositories.
        """
        registry_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['WorkflowRegistryMappingArgsDict']]]]
        """
        Mapping that provides the ECR repository path where upstream container images are pulled and synchronized.
        """
elif False:
    WorkflowContainerRegistryMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkflowContainerRegistryMapArgs:
    def __init__(__self__, *,
                 image_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowImageMappingArgs']]]] = None,
                 registry_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowRegistryMappingArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WorkflowImageMappingArgs']]] image_mappings: Image mappings specify path mappings between the ECR private repository and their corresponding external repositories.
        :param pulumi.Input[Sequence[pulumi.Input['WorkflowRegistryMappingArgs']]] registry_mappings: Mapping that provides the ECR repository path where upstream container images are pulled and synchronized.
        """
        if image_mappings is not None:
            pulumi.set(__self__, "image_mappings", image_mappings)
        if registry_mappings is not None:
            pulumi.set(__self__, "registry_mappings", registry_mappings)

    @_builtins.property
    @pulumi.getter(name="imageMappings")
    def image_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowImageMappingArgs']]]]:
        """
        Image mappings specify path mappings between the ECR private repository and their corresponding external repositories.
        """
        return pulumi.get(self, "image_mappings")

    @image_mappings.setter
    def image_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowImageMappingArgs']]]]):
        pulumi.set(self, "image_mappings", value)

    @_builtins.property
    @pulumi.getter(name="registryMappings")
    def registry_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowRegistryMappingArgs']]]]:
        """
        Mapping that provides the ECR repository path where upstream container images are pulled and synchronized.
        """
        return pulumi.get(self, "registry_mappings")

    @registry_mappings.setter
    def registry_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowRegistryMappingArgs']]]]):
        pulumi.set(self, "registry_mappings", value)


if not MYPY:
    class WorkflowDefinitionRepositoryArgsDict(TypedDict):
        connection_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Amazon Resource Name (ARN) of the connection to the source code repository.
        """
        exclude_file_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of file patterns to exclude when retrieving the workflow definition from the repository.
        """
        full_repository_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The full repository identifier, including the repository owner and name. For example, 'repository-owner/repository-name'.
        """
        source_reference: NotRequired[pulumi.Input['WorkflowSourceReferenceArgsDict']]
        """
        The source reference for the repository, such as a branch name, tag, or commit ID.
        """
elif False:
    WorkflowDefinitionRepositoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkflowDefinitionRepositoryArgs:
    def __init__(__self__, *,
                 connection_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 exclude_file_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 full_repository_id: Optional[pulumi.Input[_builtins.str]] = None,
                 source_reference: Optional[pulumi.Input['WorkflowSourceReferenceArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] connection_arn: The Amazon Resource Name (ARN) of the connection to the source code repository.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_file_patterns: A list of file patterns to exclude when retrieving the workflow definition from the repository.
        :param pulumi.Input[_builtins.str] full_repository_id: The full repository identifier, including the repository owner and name. For example, 'repository-owner/repository-name'.
        :param pulumi.Input['WorkflowSourceReferenceArgs'] source_reference: The source reference for the repository, such as a branch name, tag, or commit ID.
        """
        if connection_arn is not None:
            pulumi.set(__self__, "connection_arn", connection_arn)
        if exclude_file_patterns is not None:
            pulumi.set(__self__, "exclude_file_patterns", exclude_file_patterns)
        if full_repository_id is not None:
            pulumi.set(__self__, "full_repository_id", full_repository_id)
        if source_reference is not None:
            pulumi.set(__self__, "source_reference", source_reference)

    @_builtins.property
    @pulumi.getter(name="connectionArn")
    def connection_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Amazon Resource Name (ARN) of the connection to the source code repository.
        """
        return pulumi.get(self, "connection_arn")

    @connection_arn.setter
    def connection_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "connection_arn", value)

    @_builtins.property
    @pulumi.getter(name="excludeFilePatterns")
    def exclude_file_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of file patterns to exclude when retrieving the workflow definition from the repository.
        """
        return pulumi.get(self, "exclude_file_patterns")

    @exclude_file_patterns.setter
    def exclude_file_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_file_patterns", value)

    @_builtins.property
    @pulumi.getter(name="fullRepositoryId")
    def full_repository_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The full repository identifier, including the repository owner and name. For example, 'repository-owner/repository-name'.
        """
        return pulumi.get(self, "full_repository_id")

    @full_repository_id.setter
    def full_repository_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "full_repository_id", value)

    @_builtins.property
    @pulumi.getter(name="sourceReference")
    def source_reference(self) -> Optional[pulumi.Input['WorkflowSourceReferenceArgs']]:
        """
        The source reference for the repository, such as a branch name, tag, or commit ID.
        """
        return pulumi.get(self, "source_reference")

    @source_reference.setter
    def source_reference(self, value: Optional[pulumi.Input['WorkflowSourceReferenceArgs']]):
        pulumi.set(self, "source_reference", value)


if not MYPY:
    class WorkflowImageMappingArgsDict(TypedDict):
        destination_image: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the URI of the corresponding image in the private ECR registry.
        """
        source_image: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the URI of the source image in the upstream registry.
        """
elif False:
    WorkflowImageMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkflowImageMappingArgs:
    def __init__(__self__, *,
                 destination_image: Optional[pulumi.Input[_builtins.str]] = None,
                 source_image: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] destination_image: Specifies the URI of the corresponding image in the private ECR registry.
        :param pulumi.Input[_builtins.str] source_image: Specifies the URI of the source image in the upstream registry.
        """
        if destination_image is not None:
            pulumi.set(__self__, "destination_image", destination_image)
        if source_image is not None:
            pulumi.set(__self__, "source_image", source_image)

    @_builtins.property
    @pulumi.getter(name="destinationImage")
    def destination_image(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the URI of the corresponding image in the private ECR registry.
        """
        return pulumi.get(self, "destination_image")

    @destination_image.setter
    def destination_image(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination_image", value)

    @_builtins.property
    @pulumi.getter(name="sourceImage")
    def source_image(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the URI of the source image in the upstream registry.
        """
        return pulumi.get(self, "source_image")

    @source_image.setter
    def source_image(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_image", value)


if not MYPY:
    class WorkflowParameterArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The parameter's description.
        """
        optional: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the parameter is optional.
        """
elif False:
    WorkflowParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkflowParameterArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 optional: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] description: The parameter's description.
        :param pulumi.Input[_builtins.bool] optional: Whether the parameter is optional.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The parameter's description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def optional(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the parameter is optional.
        """
        return pulumi.get(self, "optional")

    @optional.setter
    def optional(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "optional", value)


if not MYPY:
    class WorkflowRegistryMappingArgsDict(TypedDict):
        ecr_account_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Account ID of the account that owns the upstream container image.
        """
        ecr_repository_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The repository prefix to use in the ECR private repository.
        """
        upstream_registry_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URI of the upstream registry.
        """
        upstream_repository_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The repository prefix of the corresponding repository in the upstream registry.
        """
elif False:
    WorkflowRegistryMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkflowRegistryMappingArgs:
    def __init__(__self__, *,
                 ecr_account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 ecr_repository_prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 upstream_registry_url: Optional[pulumi.Input[_builtins.str]] = None,
                 upstream_repository_prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ecr_account_id: Account ID of the account that owns the upstream container image.
        :param pulumi.Input[_builtins.str] ecr_repository_prefix: The repository prefix to use in the ECR private repository.
        :param pulumi.Input[_builtins.str] upstream_registry_url: The URI of the upstream registry.
        :param pulumi.Input[_builtins.str] upstream_repository_prefix: The repository prefix of the corresponding repository in the upstream registry.
        """
        if ecr_account_id is not None:
            pulumi.set(__self__, "ecr_account_id", ecr_account_id)
        if ecr_repository_prefix is not None:
            pulumi.set(__self__, "ecr_repository_prefix", ecr_repository_prefix)
        if upstream_registry_url is not None:
            pulumi.set(__self__, "upstream_registry_url", upstream_registry_url)
        if upstream_repository_prefix is not None:
            pulumi.set(__self__, "upstream_repository_prefix", upstream_repository_prefix)

    @_builtins.property
    @pulumi.getter(name="ecrAccountId")
    def ecr_account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Account ID of the account that owns the upstream container image.
        """
        return pulumi.get(self, "ecr_account_id")

    @ecr_account_id.setter
    def ecr_account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ecr_account_id", value)

    @_builtins.property
    @pulumi.getter(name="ecrRepositoryPrefix")
    def ecr_repository_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The repository prefix to use in the ECR private repository.
        """
        return pulumi.get(self, "ecr_repository_prefix")

    @ecr_repository_prefix.setter
    def ecr_repository_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ecr_repository_prefix", value)

    @_builtins.property
    @pulumi.getter(name="upstreamRegistryUrl")
    def upstream_registry_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URI of the upstream registry.
        """
        return pulumi.get(self, "upstream_registry_url")

    @upstream_registry_url.setter
    def upstream_registry_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "upstream_registry_url", value)

    @_builtins.property
    @pulumi.getter(name="upstreamRepositoryPrefix")
    def upstream_repository_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The repository prefix of the corresponding repository in the upstream registry.
        """
        return pulumi.get(self, "upstream_repository_prefix")

    @upstream_repository_prefix.setter
    def upstream_repository_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "upstream_repository_prefix", value)


if not MYPY:
    class WorkflowSourceReferenceArgsDict(TypedDict):
        type: NotRequired[pulumi.Input['WorkflowSourceReferencetype']]
        """
        The type of source reference, such as branch, tag, or commit.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the source reference, such as the branch name, tag name, or commit ID.
        """
elif False:
    WorkflowSourceReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkflowSourceReferenceArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input['WorkflowSourceReferencetype']] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['WorkflowSourceReferencetype'] type: The type of source reference, such as branch, tag, or commit.
        :param pulumi.Input[_builtins.str] value: The value of the source reference, such as the branch name, tag name, or commit ID.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['WorkflowSourceReferencetype']]:
        """
        The type of source reference, such as branch, tag, or commit.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['WorkflowSourceReferencetype']]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the source reference, such as the branch name, tag name, or commit ID.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WorkflowVersionContainerRegistryMapArgsDict(TypedDict):
        image_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['WorkflowVersionImageMappingArgsDict']]]]
        """
        Image mappings specify path mappings between the ECR private repository and their corresponding external repositories.
        """
        registry_mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['WorkflowVersionRegistryMappingArgsDict']]]]
        """
        Mapping that provides the ECR repository path where upstream container images are pulled and synchronized.
        """
elif False:
    WorkflowVersionContainerRegistryMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkflowVersionContainerRegistryMapArgs:
    def __init__(__self__, *,
                 image_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowVersionImageMappingArgs']]]] = None,
                 registry_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowVersionRegistryMappingArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WorkflowVersionImageMappingArgs']]] image_mappings: Image mappings specify path mappings between the ECR private repository and their corresponding external repositories.
        :param pulumi.Input[Sequence[pulumi.Input['WorkflowVersionRegistryMappingArgs']]] registry_mappings: Mapping that provides the ECR repository path where upstream container images are pulled and synchronized.
        """
        if image_mappings is not None:
            pulumi.set(__self__, "image_mappings", image_mappings)
        if registry_mappings is not None:
            pulumi.set(__self__, "registry_mappings", registry_mappings)

    @_builtins.property
    @pulumi.getter(name="imageMappings")
    def image_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowVersionImageMappingArgs']]]]:
        """
        Image mappings specify path mappings between the ECR private repository and their corresponding external repositories.
        """
        return pulumi.get(self, "image_mappings")

    @image_mappings.setter
    def image_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowVersionImageMappingArgs']]]]):
        pulumi.set(self, "image_mappings", value)

    @_builtins.property
    @pulumi.getter(name="registryMappings")
    def registry_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowVersionRegistryMappingArgs']]]]:
        """
        Mapping that provides the ECR repository path where upstream container images are pulled and synchronized.
        """
        return pulumi.get(self, "registry_mappings")

    @registry_mappings.setter
    def registry_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkflowVersionRegistryMappingArgs']]]]):
        pulumi.set(self, "registry_mappings", value)


if not MYPY:
    class WorkflowVersionDefinitionRepositoryArgsDict(TypedDict):
        connection_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Amazon Resource Name (ARN) of the connection to the source code repository.
        """
        exclude_file_patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of file patterns to exclude when retrieving the workflow definition from the repository.
        """
        full_repository_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The full repository identifier, including the repository owner and name. For example, 'repository-owner/repository-name'.
        """
        source_reference: NotRequired[pulumi.Input['WorkflowVersionSourceReferenceArgsDict']]
        """
        The source reference for the repository, such as a branch name, tag, or commit ID.
        """
elif False:
    WorkflowVersionDefinitionRepositoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkflowVersionDefinitionRepositoryArgs:
    def __init__(__self__, *,
                 connection_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 exclude_file_patterns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 full_repository_id: Optional[pulumi.Input[_builtins.str]] = None,
                 source_reference: Optional[pulumi.Input['WorkflowVersionSourceReferenceArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] connection_arn: The Amazon Resource Name (ARN) of the connection to the source code repository.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_file_patterns: A list of file patterns to exclude when retrieving the workflow definition from the repository.
        :param pulumi.Input[_builtins.str] full_repository_id: The full repository identifier, including the repository owner and name. For example, 'repository-owner/repository-name'.
        :param pulumi.Input['WorkflowVersionSourceReferenceArgs'] source_reference: The source reference for the repository, such as a branch name, tag, or commit ID.
        """
        if connection_arn is not None:
            pulumi.set(__self__, "connection_arn", connection_arn)
        if exclude_file_patterns is not None:
            pulumi.set(__self__, "exclude_file_patterns", exclude_file_patterns)
        if full_repository_id is not None:
            pulumi.set(__self__, "full_repository_id", full_repository_id)
        if source_reference is not None:
            pulumi.set(__self__, "source_reference", source_reference)

    @_builtins.property
    @pulumi.getter(name="connectionArn")
    def connection_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Amazon Resource Name (ARN) of the connection to the source code repository.
        """
        return pulumi.get(self, "connection_arn")

    @connection_arn.setter
    def connection_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "connection_arn", value)

    @_builtins.property
    @pulumi.getter(name="excludeFilePatterns")
    def exclude_file_patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of file patterns to exclude when retrieving the workflow definition from the repository.
        """
        return pulumi.get(self, "exclude_file_patterns")

    @exclude_file_patterns.setter
    def exclude_file_patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_file_patterns", value)

    @_builtins.property
    @pulumi.getter(name="fullRepositoryId")
    def full_repository_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The full repository identifier, including the repository owner and name. For example, 'repository-owner/repository-name'.
        """
        return pulumi.get(self, "full_repository_id")

    @full_repository_id.setter
    def full_repository_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "full_repository_id", value)

    @_builtins.property
    @pulumi.getter(name="sourceReference")
    def source_reference(self) -> Optional[pulumi.Input['WorkflowVersionSourceReferenceArgs']]:
        """
        The source reference for the repository, such as a branch name, tag, or commit ID.
        """
        return pulumi.get(self, "source_reference")

    @source_reference.setter
    def source_reference(self, value: Optional[pulumi.Input['WorkflowVersionSourceReferenceArgs']]):
        pulumi.set(self, "source_reference", value)


if not MYPY:
    class WorkflowVersionImageMappingArgsDict(TypedDict):
        destination_image: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the URI of the corresponding image in the private ECR registry.
        """
        source_image: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the URI of the source image in the upstream registry.
        """
elif False:
    WorkflowVersionImageMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkflowVersionImageMappingArgs:
    def __init__(__self__, *,
                 destination_image: Optional[pulumi.Input[_builtins.str]] = None,
                 source_image: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] destination_image: Specifies the URI of the corresponding image in the private ECR registry.
        :param pulumi.Input[_builtins.str] source_image: Specifies the URI of the source image in the upstream registry.
        """
        if destination_image is not None:
            pulumi.set(__self__, "destination_image", destination_image)
        if source_image is not None:
            pulumi.set(__self__, "source_image", source_image)

    @_builtins.property
    @pulumi.getter(name="destinationImage")
    def destination_image(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the URI of the corresponding image in the private ECR registry.
        """
        return pulumi.get(self, "destination_image")

    @destination_image.setter
    def destination_image(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination_image", value)

    @_builtins.property
    @pulumi.getter(name="sourceImage")
    def source_image(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the URI of the source image in the upstream registry.
        """
        return pulumi.get(self, "source_image")

    @source_image.setter
    def source_image(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_image", value)


if not MYPY:
    class WorkflowVersionRegistryMappingArgsDict(TypedDict):
        ecr_account_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Account ID of the account that owns the upstream container image.
        """
        ecr_repository_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The repository prefix to use in the ECR private repository.
        """
        upstream_registry_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URI of the upstream registry.
        """
        upstream_repository_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The repository prefix of the corresponding repository in the upstream registry.
        """
elif False:
    WorkflowVersionRegistryMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkflowVersionRegistryMappingArgs:
    def __init__(__self__, *,
                 ecr_account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 ecr_repository_prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 upstream_registry_url: Optional[pulumi.Input[_builtins.str]] = None,
                 upstream_repository_prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ecr_account_id: Account ID of the account that owns the upstream container image.
        :param pulumi.Input[_builtins.str] ecr_repository_prefix: The repository prefix to use in the ECR private repository.
        :param pulumi.Input[_builtins.str] upstream_registry_url: The URI of the upstream registry.
        :param pulumi.Input[_builtins.str] upstream_repository_prefix: The repository prefix of the corresponding repository in the upstream registry.
        """
        if ecr_account_id is not None:
            pulumi.set(__self__, "ecr_account_id", ecr_account_id)
        if ecr_repository_prefix is not None:
            pulumi.set(__self__, "ecr_repository_prefix", ecr_repository_prefix)
        if upstream_registry_url is not None:
            pulumi.set(__self__, "upstream_registry_url", upstream_registry_url)
        if upstream_repository_prefix is not None:
            pulumi.set(__self__, "upstream_repository_prefix", upstream_repository_prefix)

    @_builtins.property
    @pulumi.getter(name="ecrAccountId")
    def ecr_account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Account ID of the account that owns the upstream container image.
        """
        return pulumi.get(self, "ecr_account_id")

    @ecr_account_id.setter
    def ecr_account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ecr_account_id", value)

    @_builtins.property
    @pulumi.getter(name="ecrRepositoryPrefix")
    def ecr_repository_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The repository prefix to use in the ECR private repository.
        """
        return pulumi.get(self, "ecr_repository_prefix")

    @ecr_repository_prefix.setter
    def ecr_repository_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ecr_repository_prefix", value)

    @_builtins.property
    @pulumi.getter(name="upstreamRegistryUrl")
    def upstream_registry_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URI of the upstream registry.
        """
        return pulumi.get(self, "upstream_registry_url")

    @upstream_registry_url.setter
    def upstream_registry_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "upstream_registry_url", value)

    @_builtins.property
    @pulumi.getter(name="upstreamRepositoryPrefix")
    def upstream_repository_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The repository prefix of the corresponding repository in the upstream registry.
        """
        return pulumi.get(self, "upstream_repository_prefix")

    @upstream_repository_prefix.setter
    def upstream_repository_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "upstream_repository_prefix", value)


if not MYPY:
    class WorkflowVersionSourceReferenceArgsDict(TypedDict):
        type: NotRequired[pulumi.Input['WorkflowVersionSourceReferencetype']]
        """
        The type of source reference, such as branch, tag, or commit.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the source reference, such as the branch name, tag name, or commit ID.
        """
elif False:
    WorkflowVersionSourceReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkflowVersionSourceReferenceArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input['WorkflowVersionSourceReferencetype']] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['WorkflowVersionSourceReferencetype'] type: The type of source reference, such as branch, tag, or commit.
        :param pulumi.Input[_builtins.str] value: The value of the source reference, such as the branch name, tag name, or commit ID.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['WorkflowVersionSourceReferencetype']]:
        """
        The type of source reference, such as branch, tag, or commit.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['WorkflowVersionSourceReferencetype']]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the source reference, such as the branch name, tag name, or commit ID.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WorkflowVersionWorkflowParameterArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The parameter's description.
        """
        optional: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the parameter is optional.
        """
elif False:
    WorkflowVersionWorkflowParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkflowVersionWorkflowParameterArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 optional: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] description: The parameter's description.
        :param pulumi.Input[_builtins.bool] optional: Whether the parameter is optional.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if optional is not None:
            pulumi.set(__self__, "optional", optional)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The parameter's description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def optional(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the parameter is optional.
        """
        return pulumi.get(self, "optional")

    @optional.setter
    def optional(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "optional", value)


