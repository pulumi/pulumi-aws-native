# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'GetLoadBalancerResult',
    'AwaitableGetLoadBalancerResult',
    'get_load_balancer',
    'get_load_balancer_output',
]

@pulumi.output_type
class GetLoadBalancerResult:
    def __init__(__self__, access_logging_policy=None, app_cookie_stickiness_policy=None, availability_zones=None, canonical_hosted_zone_name=None, canonical_hosted_zone_name_id=None, connection_draining_policy=None, connection_settings=None, cross_zone=None, d_ns_name=None, health_check=None, id=None, instances=None, l_b_cookie_stickiness_policy=None, listeners=None, policies=None, security_groups=None, source_security_group_group_name=None, source_security_group_owner_alias=None, subnets=None, tags=None):
        if access_logging_policy and not isinstance(access_logging_policy, dict):
            raise TypeError("Expected argument 'access_logging_policy' to be a dict")
        pulumi.set(__self__, "access_logging_policy", access_logging_policy)
        if app_cookie_stickiness_policy and not isinstance(app_cookie_stickiness_policy, list):
            raise TypeError("Expected argument 'app_cookie_stickiness_policy' to be a list")
        pulumi.set(__self__, "app_cookie_stickiness_policy", app_cookie_stickiness_policy)
        if availability_zones and not isinstance(availability_zones, list):
            raise TypeError("Expected argument 'availability_zones' to be a list")
        pulumi.set(__self__, "availability_zones", availability_zones)
        if canonical_hosted_zone_name and not isinstance(canonical_hosted_zone_name, str):
            raise TypeError("Expected argument 'canonical_hosted_zone_name' to be a str")
        pulumi.set(__self__, "canonical_hosted_zone_name", canonical_hosted_zone_name)
        if canonical_hosted_zone_name_id and not isinstance(canonical_hosted_zone_name_id, str):
            raise TypeError("Expected argument 'canonical_hosted_zone_name_id' to be a str")
        pulumi.set(__self__, "canonical_hosted_zone_name_id", canonical_hosted_zone_name_id)
        if connection_draining_policy and not isinstance(connection_draining_policy, dict):
            raise TypeError("Expected argument 'connection_draining_policy' to be a dict")
        pulumi.set(__self__, "connection_draining_policy", connection_draining_policy)
        if connection_settings and not isinstance(connection_settings, dict):
            raise TypeError("Expected argument 'connection_settings' to be a dict")
        pulumi.set(__self__, "connection_settings", connection_settings)
        if cross_zone and not isinstance(cross_zone, bool):
            raise TypeError("Expected argument 'cross_zone' to be a bool")
        pulumi.set(__self__, "cross_zone", cross_zone)
        if d_ns_name and not isinstance(d_ns_name, str):
            raise TypeError("Expected argument 'd_ns_name' to be a str")
        pulumi.set(__self__, "d_ns_name", d_ns_name)
        if health_check and not isinstance(health_check, dict):
            raise TypeError("Expected argument 'health_check' to be a dict")
        pulumi.set(__self__, "health_check", health_check)
        if id and not isinstance(id, str):
            raise TypeError("Expected argument 'id' to be a str")
        pulumi.set(__self__, "id", id)
        if instances and not isinstance(instances, list):
            raise TypeError("Expected argument 'instances' to be a list")
        pulumi.set(__self__, "instances", instances)
        if l_b_cookie_stickiness_policy and not isinstance(l_b_cookie_stickiness_policy, list):
            raise TypeError("Expected argument 'l_b_cookie_stickiness_policy' to be a list")
        pulumi.set(__self__, "l_b_cookie_stickiness_policy", l_b_cookie_stickiness_policy)
        if listeners and not isinstance(listeners, list):
            raise TypeError("Expected argument 'listeners' to be a list")
        pulumi.set(__self__, "listeners", listeners)
        if policies and not isinstance(policies, list):
            raise TypeError("Expected argument 'policies' to be a list")
        pulumi.set(__self__, "policies", policies)
        if security_groups and not isinstance(security_groups, list):
            raise TypeError("Expected argument 'security_groups' to be a list")
        pulumi.set(__self__, "security_groups", security_groups)
        if source_security_group_group_name and not isinstance(source_security_group_group_name, str):
            raise TypeError("Expected argument 'source_security_group_group_name' to be a str")
        pulumi.set(__self__, "source_security_group_group_name", source_security_group_group_name)
        if source_security_group_owner_alias and not isinstance(source_security_group_owner_alias, str):
            raise TypeError("Expected argument 'source_security_group_owner_alias' to be a str")
        pulumi.set(__self__, "source_security_group_owner_alias", source_security_group_owner_alias)
        if subnets and not isinstance(subnets, list):
            raise TypeError("Expected argument 'subnets' to be a list")
        pulumi.set(__self__, "subnets", subnets)
        if tags and not isinstance(tags, list):
            raise TypeError("Expected argument 'tags' to be a list")
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="accessLoggingPolicy")
    def access_logging_policy(self) -> Optional['outputs.LoadBalancerAccessLoggingPolicy']:
        return pulumi.get(self, "access_logging_policy")

    @property
    @pulumi.getter(name="appCookieStickinessPolicy")
    def app_cookie_stickiness_policy(self) -> Optional[Sequence['outputs.LoadBalancerAppCookieStickinessPolicy']]:
        return pulumi.get(self, "app_cookie_stickiness_policy")

    @property
    @pulumi.getter(name="availabilityZones")
    def availability_zones(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "availability_zones")

    @property
    @pulumi.getter(name="canonicalHostedZoneName")
    def canonical_hosted_zone_name(self) -> Optional[str]:
        return pulumi.get(self, "canonical_hosted_zone_name")

    @property
    @pulumi.getter(name="canonicalHostedZoneNameID")
    def canonical_hosted_zone_name_id(self) -> Optional[str]:
        return pulumi.get(self, "canonical_hosted_zone_name_id")

    @property
    @pulumi.getter(name="connectionDrainingPolicy")
    def connection_draining_policy(self) -> Optional['outputs.LoadBalancerConnectionDrainingPolicy']:
        return pulumi.get(self, "connection_draining_policy")

    @property
    @pulumi.getter(name="connectionSettings")
    def connection_settings(self) -> Optional['outputs.LoadBalancerConnectionSettings']:
        return pulumi.get(self, "connection_settings")

    @property
    @pulumi.getter(name="crossZone")
    def cross_zone(self) -> Optional[bool]:
        return pulumi.get(self, "cross_zone")

    @property
    @pulumi.getter(name="dNSName")
    def d_ns_name(self) -> Optional[str]:
        return pulumi.get(self, "d_ns_name")

    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional['outputs.LoadBalancerHealthCheck']:
        return pulumi.get(self, "health_check")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def instances(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "instances")

    @property
    @pulumi.getter(name="lBCookieStickinessPolicy")
    def l_b_cookie_stickiness_policy(self) -> Optional[Sequence['outputs.LoadBalancerLBCookieStickinessPolicy']]:
        return pulumi.get(self, "l_b_cookie_stickiness_policy")

    @property
    @pulumi.getter
    def listeners(self) -> Optional[Sequence['outputs.LoadBalancerListeners']]:
        return pulumi.get(self, "listeners")

    @property
    @pulumi.getter
    def policies(self) -> Optional[Sequence['outputs.LoadBalancerPolicies']]:
        return pulumi.get(self, "policies")

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "security_groups")

    @property
    @pulumi.getter(name="sourceSecurityGroupGroupName")
    def source_security_group_group_name(self) -> Optional[str]:
        return pulumi.get(self, "source_security_group_group_name")

    @property
    @pulumi.getter(name="sourceSecurityGroupOwnerAlias")
    def source_security_group_owner_alias(self) -> Optional[str]:
        return pulumi.get(self, "source_security_group_owner_alias")

    @property
    @pulumi.getter
    def subnets(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "subnets")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.LoadBalancerTag']]:
        return pulumi.get(self, "tags")


class AwaitableGetLoadBalancerResult(GetLoadBalancerResult):
    # pylint: disable=using-constant-test
    def __await__(self):
        if False:
            yield self
        return GetLoadBalancerResult(
            access_logging_policy=self.access_logging_policy,
            app_cookie_stickiness_policy=self.app_cookie_stickiness_policy,
            availability_zones=self.availability_zones,
            canonical_hosted_zone_name=self.canonical_hosted_zone_name,
            canonical_hosted_zone_name_id=self.canonical_hosted_zone_name_id,
            connection_draining_policy=self.connection_draining_policy,
            connection_settings=self.connection_settings,
            cross_zone=self.cross_zone,
            d_ns_name=self.d_ns_name,
            health_check=self.health_check,
            id=self.id,
            instances=self.instances,
            l_b_cookie_stickiness_policy=self.l_b_cookie_stickiness_policy,
            listeners=self.listeners,
            policies=self.policies,
            security_groups=self.security_groups,
            source_security_group_group_name=self.source_security_group_group_name,
            source_security_group_owner_alias=self.source_security_group_owner_alias,
            subnets=self.subnets,
            tags=self.tags)


def get_load_balancer(id: Optional[str] = None,
                      opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetLoadBalancerResult:
    """
    Resource Type definition for AWS::ElasticLoadBalancing::LoadBalancer
    """
    __args__ = dict()
    __args__['id'] = id
    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke('aws-native:elasticloadbalancing:getLoadBalancer', __args__, opts=opts, typ=GetLoadBalancerResult).value

    return AwaitableGetLoadBalancerResult(
        access_logging_policy=__ret__.access_logging_policy,
        app_cookie_stickiness_policy=__ret__.app_cookie_stickiness_policy,
        availability_zones=__ret__.availability_zones,
        canonical_hosted_zone_name=__ret__.canonical_hosted_zone_name,
        canonical_hosted_zone_name_id=__ret__.canonical_hosted_zone_name_id,
        connection_draining_policy=__ret__.connection_draining_policy,
        connection_settings=__ret__.connection_settings,
        cross_zone=__ret__.cross_zone,
        d_ns_name=__ret__.d_ns_name,
        health_check=__ret__.health_check,
        id=__ret__.id,
        instances=__ret__.instances,
        l_b_cookie_stickiness_policy=__ret__.l_b_cookie_stickiness_policy,
        listeners=__ret__.listeners,
        policies=__ret__.policies,
        security_groups=__ret__.security_groups,
        source_security_group_group_name=__ret__.source_security_group_group_name,
        source_security_group_owner_alias=__ret__.source_security_group_owner_alias,
        subnets=__ret__.subnets,
        tags=__ret__.tags)


@_utilities.lift_output_func(get_load_balancer)
def get_load_balancer_output(id: Optional[pulumi.Input[str]] = None,
                             opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetLoadBalancerResult]:
    """
    Resource Type definition for AWS::ElasticLoadBalancing::LoadBalancer
    """
    ...
