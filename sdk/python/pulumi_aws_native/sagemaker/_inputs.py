# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'AppImageConfigCodeEditorAppImageConfigArgs',
    'AppImageConfigCodeEditorAppImageConfigArgsDict',
    'AppImageConfigContainerConfigArgs',
    'AppImageConfigContainerConfigArgsDict',
    'AppImageConfigCustomImageContainerEnvironmentVariableArgs',
    'AppImageConfigCustomImageContainerEnvironmentVariableArgsDict',
    'AppImageConfigFileSystemConfigArgs',
    'AppImageConfigFileSystemConfigArgsDict',
    'AppImageConfigJupyterLabAppImageConfigArgs',
    'AppImageConfigJupyterLabAppImageConfigArgsDict',
    'AppImageConfigKernelGatewayImageConfigArgs',
    'AppImageConfigKernelGatewayImageConfigArgsDict',
    'AppImageConfigKernelSpecArgs',
    'AppImageConfigKernelSpecArgsDict',
    'AppResourceSpecArgs',
    'AppResourceSpecArgsDict',
    'ClusterInstanceGroupArgs',
    'ClusterInstanceGroupArgsDict',
    'ClusterInstanceStorageConfigArgs',
    'ClusterInstanceStorageConfigArgsDict',
    'ClusterLifeCycleConfigArgs',
    'ClusterLifeCycleConfigArgsDict',
    'ClusterOrchestratorEksConfigArgs',
    'ClusterOrchestratorEksConfigArgsDict',
    'ClusterOrchestratorArgs',
    'ClusterOrchestratorArgsDict',
    'ClusterVpcConfigArgs',
    'ClusterVpcConfigArgsDict',
    'DataQualityJobDefinitionBatchTransformInputArgs',
    'DataQualityJobDefinitionBatchTransformInputArgsDict',
    'DataQualityJobDefinitionClusterConfigArgs',
    'DataQualityJobDefinitionClusterConfigArgsDict',
    'DataQualityJobDefinitionConstraintsResourceArgs',
    'DataQualityJobDefinitionConstraintsResourceArgsDict',
    'DataQualityJobDefinitionCsvArgs',
    'DataQualityJobDefinitionCsvArgsDict',
    'DataQualityJobDefinitionDataQualityAppSpecificationArgs',
    'DataQualityJobDefinitionDataQualityAppSpecificationArgsDict',
    'DataQualityJobDefinitionDataQualityBaselineConfigArgs',
    'DataQualityJobDefinitionDataQualityBaselineConfigArgsDict',
    'DataQualityJobDefinitionDataQualityJobInputArgs',
    'DataQualityJobDefinitionDataQualityJobInputArgsDict',
    'DataQualityJobDefinitionDatasetFormatArgs',
    'DataQualityJobDefinitionDatasetFormatArgsDict',
    'DataQualityJobDefinitionEndpointInputArgs',
    'DataQualityJobDefinitionEndpointInputArgsDict',
    'DataQualityJobDefinitionJsonArgs',
    'DataQualityJobDefinitionJsonArgsDict',
    'DataQualityJobDefinitionMonitoringOutputConfigArgs',
    'DataQualityJobDefinitionMonitoringOutputConfigArgsDict',
    'DataQualityJobDefinitionMonitoringOutputArgs',
    'DataQualityJobDefinitionMonitoringOutputArgsDict',
    'DataQualityJobDefinitionMonitoringResourcesArgs',
    'DataQualityJobDefinitionMonitoringResourcesArgsDict',
    'DataQualityJobDefinitionNetworkConfigArgs',
    'DataQualityJobDefinitionNetworkConfigArgsDict',
    'DataQualityJobDefinitionS3OutputArgs',
    'DataQualityJobDefinitionS3OutputArgsDict',
    'DataQualityJobDefinitionStatisticsResourceArgs',
    'DataQualityJobDefinitionStatisticsResourceArgsDict',
    'DataQualityJobDefinitionStoppingConditionArgs',
    'DataQualityJobDefinitionStoppingConditionArgsDict',
    'DataQualityJobDefinitionVpcConfigArgs',
    'DataQualityJobDefinitionVpcConfigArgsDict',
    'DeviceFleetEdgeOutputConfigArgs',
    'DeviceFleetEdgeOutputConfigArgsDict',
    'DeviceArgs',
    'DeviceArgsDict',
    'DomainAppLifecycleManagementArgs',
    'DomainAppLifecycleManagementArgsDict',
    'DomainCodeEditorAppSettingsArgs',
    'DomainCodeEditorAppSettingsArgsDict',
    'DomainCodeRepositoryArgs',
    'DomainCodeRepositoryArgsDict',
    'DomainCustomFileSystemConfigArgs',
    'DomainCustomFileSystemConfigArgsDict',
    'DomainCustomImageArgs',
    'DomainCustomImageArgsDict',
    'DomainCustomPosixUserConfigArgs',
    'DomainCustomPosixUserConfigArgsDict',
    'DomainDefaultEbsStorageSettingsArgs',
    'DomainDefaultEbsStorageSettingsArgsDict',
    'DomainDefaultSpaceSettingsArgs',
    'DomainDefaultSpaceSettingsArgsDict',
    'DomainDefaultSpaceStorageSettingsArgs',
    'DomainDefaultSpaceStorageSettingsArgsDict',
    'DomainDockerSettingsArgs',
    'DomainDockerSettingsArgsDict',
    'DomainEfsFileSystemConfigArgs',
    'DomainEfsFileSystemConfigArgsDict',
    'DomainIdleSettingsArgs',
    'DomainIdleSettingsArgsDict',
    'DomainJupyterLabAppSettingsArgs',
    'DomainJupyterLabAppSettingsArgsDict',
    'DomainJupyterServerAppSettingsArgs',
    'DomainJupyterServerAppSettingsArgsDict',
    'DomainKernelGatewayAppSettingsArgs',
    'DomainKernelGatewayAppSettingsArgsDict',
    'DomainRSessionAppSettingsArgs',
    'DomainRSessionAppSettingsArgsDict',
    'DomainRStudioServerProAppSettingsArgs',
    'DomainRStudioServerProAppSettingsArgsDict',
    'DomainRStudioServerProDomainSettingsArgs',
    'DomainRStudioServerProDomainSettingsArgsDict',
    'DomainResourceSpecArgs',
    'DomainResourceSpecArgsDict',
    'DomainSettingsArgs',
    'DomainSettingsArgsDict',
    'DomainSharingSettingsArgs',
    'DomainSharingSettingsArgsDict',
    'DomainStudioWebPortalSettingsArgs',
    'DomainStudioWebPortalSettingsArgsDict',
    'DomainUserSettingsArgs',
    'DomainUserSettingsArgsDict',
    'EndpointAlarmArgs',
    'EndpointAlarmArgsDict',
    'EndpointAutoRollbackConfigArgs',
    'EndpointAutoRollbackConfigArgsDict',
    'EndpointBlueGreenUpdatePolicyArgs',
    'EndpointBlueGreenUpdatePolicyArgsDict',
    'EndpointCapacitySizeArgs',
    'EndpointCapacitySizeArgsDict',
    'EndpointDeploymentConfigArgs',
    'EndpointDeploymentConfigArgsDict',
    'EndpointRollingUpdatePolicyArgs',
    'EndpointRollingUpdatePolicyArgsDict',
    'EndpointTrafficRoutingConfigArgs',
    'EndpointTrafficRoutingConfigArgsDict',
    'EndpointVariantPropertyArgs',
    'EndpointVariantPropertyArgsDict',
    'FeatureGroupDataCatalogConfigArgs',
    'FeatureGroupDataCatalogConfigArgsDict',
    'FeatureGroupFeatureDefinitionArgs',
    'FeatureGroupFeatureDefinitionArgsDict',
    'FeatureGroupOnlineStoreSecurityConfigArgs',
    'FeatureGroupOnlineStoreSecurityConfigArgsDict',
    'FeatureGroupS3StorageConfigArgs',
    'FeatureGroupS3StorageConfigArgsDict',
    'FeatureGroupThroughputConfigArgs',
    'FeatureGroupThroughputConfigArgsDict',
    'FeatureGroupTtlDurationArgs',
    'FeatureGroupTtlDurationArgsDict',
    'InferenceComponentComputeResourceRequirementsArgs',
    'InferenceComponentComputeResourceRequirementsArgsDict',
    'InferenceComponentContainerSpecificationArgs',
    'InferenceComponentContainerSpecificationArgsDict',
    'InferenceComponentDeployedImageArgs',
    'InferenceComponentDeployedImageArgsDict',
    'InferenceComponentRuntimeConfigArgs',
    'InferenceComponentRuntimeConfigArgsDict',
    'InferenceComponentSpecificationArgs',
    'InferenceComponentSpecificationArgsDict',
    'InferenceComponentStartupParametersArgs',
    'InferenceComponentStartupParametersArgsDict',
    'InferenceExperimentCaptureContentTypeHeaderArgs',
    'InferenceExperimentCaptureContentTypeHeaderArgsDict',
    'InferenceExperimentDataStorageConfigArgs',
    'InferenceExperimentDataStorageConfigArgsDict',
    'InferenceExperimentModelInfrastructureConfigArgs',
    'InferenceExperimentModelInfrastructureConfigArgsDict',
    'InferenceExperimentModelVariantConfigArgs',
    'InferenceExperimentModelVariantConfigArgsDict',
    'InferenceExperimentRealTimeInferenceConfigArgs',
    'InferenceExperimentRealTimeInferenceConfigArgsDict',
    'InferenceExperimentScheduleArgs',
    'InferenceExperimentScheduleArgsDict',
    'InferenceExperimentShadowModeConfigArgs',
    'InferenceExperimentShadowModeConfigArgsDict',
    'InferenceExperimentShadowModelVariantConfigArgs',
    'InferenceExperimentShadowModelVariantConfigArgsDict',
    'ModelBiasJobDefinitionBatchTransformInputArgs',
    'ModelBiasJobDefinitionBatchTransformInputArgsDict',
    'ModelBiasJobDefinitionClusterConfigArgs',
    'ModelBiasJobDefinitionClusterConfigArgsDict',
    'ModelBiasJobDefinitionConstraintsResourceArgs',
    'ModelBiasJobDefinitionConstraintsResourceArgsDict',
    'ModelBiasJobDefinitionCsvArgs',
    'ModelBiasJobDefinitionCsvArgsDict',
    'ModelBiasJobDefinitionDatasetFormatArgs',
    'ModelBiasJobDefinitionDatasetFormatArgsDict',
    'ModelBiasJobDefinitionEndpointInputArgs',
    'ModelBiasJobDefinitionEndpointInputArgsDict',
    'ModelBiasJobDefinitionJsonArgs',
    'ModelBiasJobDefinitionJsonArgsDict',
    'ModelBiasJobDefinitionModelBiasAppSpecificationArgs',
    'ModelBiasJobDefinitionModelBiasAppSpecificationArgsDict',
    'ModelBiasJobDefinitionModelBiasBaselineConfigArgs',
    'ModelBiasJobDefinitionModelBiasBaselineConfigArgsDict',
    'ModelBiasJobDefinitionModelBiasJobInputArgs',
    'ModelBiasJobDefinitionModelBiasJobInputArgsDict',
    'ModelBiasJobDefinitionMonitoringGroundTruthS3InputArgs',
    'ModelBiasJobDefinitionMonitoringGroundTruthS3InputArgsDict',
    'ModelBiasJobDefinitionMonitoringOutputConfigArgs',
    'ModelBiasJobDefinitionMonitoringOutputConfigArgsDict',
    'ModelBiasJobDefinitionMonitoringOutputArgs',
    'ModelBiasJobDefinitionMonitoringOutputArgsDict',
    'ModelBiasJobDefinitionMonitoringResourcesArgs',
    'ModelBiasJobDefinitionMonitoringResourcesArgsDict',
    'ModelBiasJobDefinitionNetworkConfigArgs',
    'ModelBiasJobDefinitionNetworkConfigArgsDict',
    'ModelBiasJobDefinitionS3OutputArgs',
    'ModelBiasJobDefinitionS3OutputArgsDict',
    'ModelBiasJobDefinitionStoppingConditionArgs',
    'ModelBiasJobDefinitionStoppingConditionArgsDict',
    'ModelBiasJobDefinitionVpcConfigArgs',
    'ModelBiasJobDefinitionVpcConfigArgsDict',
    'ModelCardAdditionalInformationArgs',
    'ModelCardAdditionalInformationArgsDict',
    'ModelCardBarChartMetricArgs',
    'ModelCardBarChartMetricArgsDict',
    'ModelCardBusinessDetailsArgs',
    'ModelCardBusinessDetailsArgsDict',
    'ModelCardContainerArgs',
    'ModelCardContainerArgsDict',
    'ModelCardContentArgs',
    'ModelCardContentArgsDict',
    'ModelCardEvaluationDetailArgs',
    'ModelCardEvaluationDetailArgsDict',
    'ModelCardInferenceSpecificationArgs',
    'ModelCardInferenceSpecificationArgsDict',
    'ModelCardIntendedUsesArgs',
    'ModelCardIntendedUsesArgsDict',
    'ModelCardLinearGraphMetricArgs',
    'ModelCardLinearGraphMetricArgsDict',
    'ModelCardMatrixMetricArgs',
    'ModelCardMatrixMetricArgsDict',
    'ModelCardMetricGroupArgs',
    'ModelCardMetricGroupArgsDict',
    'ModelCardModelOverviewInferenceEnvironmentPropertiesArgs',
    'ModelCardModelOverviewInferenceEnvironmentPropertiesArgsDict',
    'ModelCardModelOverviewArgs',
    'ModelCardModelOverviewArgsDict',
    'ModelCardModelPackageCreatorArgs',
    'ModelCardModelPackageCreatorArgsDict',
    'ModelCardModelPackageDetailsArgs',
    'ModelCardModelPackageDetailsArgsDict',
    'ModelCardObjectiveFunctionFunctionPropertiesArgs',
    'ModelCardObjectiveFunctionFunctionPropertiesArgsDict',
    'ModelCardObjectiveFunctionArgs',
    'ModelCardObjectiveFunctionArgsDict',
    'ModelCardSecurityConfigArgs',
    'ModelCardSecurityConfigArgsDict',
    'ModelCardSimpleMetricArgs',
    'ModelCardSimpleMetricArgsDict',
    'ModelCardSourceAlgorithmArgs',
    'ModelCardSourceAlgorithmArgsDict',
    'ModelCardTrainingDetailsTrainingJobDetailsPropertiesTrainingEnvironmentPropertiesArgs',
    'ModelCardTrainingDetailsTrainingJobDetailsPropertiesTrainingEnvironmentPropertiesArgsDict',
    'ModelCardTrainingDetailsTrainingJobDetailsPropertiesArgs',
    'ModelCardTrainingDetailsTrainingJobDetailsPropertiesArgsDict',
    'ModelCardTrainingDetailsArgs',
    'ModelCardTrainingDetailsArgsDict',
    'ModelCardTrainingHyperParameterArgs',
    'ModelCardTrainingHyperParameterArgsDict',
    'ModelCardTrainingMetricArgs',
    'ModelCardTrainingMetricArgsDict',
    'ModelCardUserContextArgs',
    'ModelCardUserContextArgsDict',
    'ModelExplainabilityJobDefinitionBatchTransformInputArgs',
    'ModelExplainabilityJobDefinitionBatchTransformInputArgsDict',
    'ModelExplainabilityJobDefinitionClusterConfigArgs',
    'ModelExplainabilityJobDefinitionClusterConfigArgsDict',
    'ModelExplainabilityJobDefinitionConstraintsResourceArgs',
    'ModelExplainabilityJobDefinitionConstraintsResourceArgsDict',
    'ModelExplainabilityJobDefinitionCsvArgs',
    'ModelExplainabilityJobDefinitionCsvArgsDict',
    'ModelExplainabilityJobDefinitionDatasetFormatArgs',
    'ModelExplainabilityJobDefinitionDatasetFormatArgsDict',
    'ModelExplainabilityJobDefinitionEndpointInputArgs',
    'ModelExplainabilityJobDefinitionEndpointInputArgsDict',
    'ModelExplainabilityJobDefinitionJsonArgs',
    'ModelExplainabilityJobDefinitionJsonArgsDict',
    'ModelExplainabilityJobDefinitionModelExplainabilityAppSpecificationArgs',
    'ModelExplainabilityJobDefinitionModelExplainabilityAppSpecificationArgsDict',
    'ModelExplainabilityJobDefinitionModelExplainabilityBaselineConfigArgs',
    'ModelExplainabilityJobDefinitionModelExplainabilityBaselineConfigArgsDict',
    'ModelExplainabilityJobDefinitionModelExplainabilityJobInputArgs',
    'ModelExplainabilityJobDefinitionModelExplainabilityJobInputArgsDict',
    'ModelExplainabilityJobDefinitionMonitoringOutputConfigArgs',
    'ModelExplainabilityJobDefinitionMonitoringOutputConfigArgsDict',
    'ModelExplainabilityJobDefinitionMonitoringOutputArgs',
    'ModelExplainabilityJobDefinitionMonitoringOutputArgsDict',
    'ModelExplainabilityJobDefinitionMonitoringResourcesArgs',
    'ModelExplainabilityJobDefinitionMonitoringResourcesArgsDict',
    'ModelExplainabilityJobDefinitionNetworkConfigArgs',
    'ModelExplainabilityJobDefinitionNetworkConfigArgsDict',
    'ModelExplainabilityJobDefinitionS3OutputArgs',
    'ModelExplainabilityJobDefinitionS3OutputArgsDict',
    'ModelExplainabilityJobDefinitionStoppingConditionArgs',
    'ModelExplainabilityJobDefinitionStoppingConditionArgsDict',
    'ModelExplainabilityJobDefinitionVpcConfigArgs',
    'ModelExplainabilityJobDefinitionVpcConfigArgsDict',
    'ModelPackageAdditionalInferenceSpecificationDefinitionArgs',
    'ModelPackageAdditionalInferenceSpecificationDefinitionArgsDict',
    'ModelPackageBiasArgs',
    'ModelPackageBiasArgsDict',
    'ModelPackageContainerDefinitionModelInputPropertiesArgs',
    'ModelPackageContainerDefinitionModelInputPropertiesArgsDict',
    'ModelPackageContainerDefinitionArgs',
    'ModelPackageContainerDefinitionArgsDict',
    'ModelPackageCustomerMetadataPropertiesArgs',
    'ModelPackageCustomerMetadataPropertiesArgsDict',
    'ModelPackageDataSourceArgs',
    'ModelPackageDataSourceArgsDict',
    'ModelPackageDriftCheckBaselinesArgs',
    'ModelPackageDriftCheckBaselinesArgsDict',
    'ModelPackageDriftCheckBiasArgs',
    'ModelPackageDriftCheckBiasArgsDict',
    'ModelPackageDriftCheckExplainabilityArgs',
    'ModelPackageDriftCheckExplainabilityArgsDict',
    'ModelPackageDriftCheckModelDataQualityArgs',
    'ModelPackageDriftCheckModelDataQualityArgsDict',
    'ModelPackageDriftCheckModelQualityArgs',
    'ModelPackageDriftCheckModelQualityArgsDict',
    'ModelPackageEnvironmentArgs',
    'ModelPackageEnvironmentArgsDict',
    'ModelPackageExplainabilityArgs',
    'ModelPackageExplainabilityArgsDict',
    'ModelPackageFileSourceArgs',
    'ModelPackageFileSourceArgsDict',
    'ModelPackageInferenceSpecificationArgs',
    'ModelPackageInferenceSpecificationArgsDict',
    'ModelPackageMetadataPropertiesArgs',
    'ModelPackageMetadataPropertiesArgsDict',
    'ModelPackageMetricsSourceArgs',
    'ModelPackageMetricsSourceArgsDict',
    'ModelPackageModelAccessConfigArgs',
    'ModelPackageModelAccessConfigArgsDict',
    'ModelPackageModelCardArgs',
    'ModelPackageModelCardArgsDict',
    'ModelPackageModelDataQualityArgs',
    'ModelPackageModelDataQualityArgsDict',
    'ModelPackageModelDataSourceArgs',
    'ModelPackageModelDataSourceArgsDict',
    'ModelPackageModelMetricsArgs',
    'ModelPackageModelMetricsArgsDict',
    'ModelPackageModelQualityArgs',
    'ModelPackageModelQualityArgsDict',
    'ModelPackageS3DataSourceArgs',
    'ModelPackageS3DataSourceArgsDict',
    'ModelPackageS3ModelDataSourceArgs',
    'ModelPackageS3ModelDataSourceArgsDict',
    'ModelPackageSecurityConfigArgs',
    'ModelPackageSecurityConfigArgsDict',
    'ModelPackageSourceAlgorithmSpecificationArgs',
    'ModelPackageSourceAlgorithmSpecificationArgsDict',
    'ModelPackageSourceAlgorithmArgs',
    'ModelPackageSourceAlgorithmArgsDict',
    'ModelPackageStatusDetailsArgs',
    'ModelPackageStatusDetailsArgsDict',
    'ModelPackageStatusItemArgs',
    'ModelPackageStatusItemArgsDict',
    'ModelPackageTransformInputArgs',
    'ModelPackageTransformInputArgsDict',
    'ModelPackageTransformJobDefinitionArgs',
    'ModelPackageTransformJobDefinitionArgsDict',
    'ModelPackageTransformOutputArgs',
    'ModelPackageTransformOutputArgsDict',
    'ModelPackageTransformResourcesArgs',
    'ModelPackageTransformResourcesArgsDict',
    'ModelPackageValidationProfileArgs',
    'ModelPackageValidationProfileArgsDict',
    'ModelPackageValidationSpecificationArgs',
    'ModelPackageValidationSpecificationArgsDict',
    'ModelQualityJobDefinitionBatchTransformInputArgs',
    'ModelQualityJobDefinitionBatchTransformInputArgsDict',
    'ModelQualityJobDefinitionClusterConfigArgs',
    'ModelQualityJobDefinitionClusterConfigArgsDict',
    'ModelQualityJobDefinitionConstraintsResourceArgs',
    'ModelQualityJobDefinitionConstraintsResourceArgsDict',
    'ModelQualityJobDefinitionCsvArgs',
    'ModelQualityJobDefinitionCsvArgsDict',
    'ModelQualityJobDefinitionDatasetFormatArgs',
    'ModelQualityJobDefinitionDatasetFormatArgsDict',
    'ModelQualityJobDefinitionEndpointInputArgs',
    'ModelQualityJobDefinitionEndpointInputArgsDict',
    'ModelQualityJobDefinitionJsonArgs',
    'ModelQualityJobDefinitionJsonArgsDict',
    'ModelQualityJobDefinitionModelQualityAppSpecificationArgs',
    'ModelQualityJobDefinitionModelQualityAppSpecificationArgsDict',
    'ModelQualityJobDefinitionModelQualityBaselineConfigArgs',
    'ModelQualityJobDefinitionModelQualityBaselineConfigArgsDict',
    'ModelQualityJobDefinitionModelQualityJobInputArgs',
    'ModelQualityJobDefinitionModelQualityJobInputArgsDict',
    'ModelQualityJobDefinitionMonitoringGroundTruthS3InputArgs',
    'ModelQualityJobDefinitionMonitoringGroundTruthS3InputArgsDict',
    'ModelQualityJobDefinitionMonitoringOutputConfigArgs',
    'ModelQualityJobDefinitionMonitoringOutputConfigArgsDict',
    'ModelQualityJobDefinitionMonitoringOutputArgs',
    'ModelQualityJobDefinitionMonitoringOutputArgsDict',
    'ModelQualityJobDefinitionMonitoringResourcesArgs',
    'ModelQualityJobDefinitionMonitoringResourcesArgsDict',
    'ModelQualityJobDefinitionNetworkConfigArgs',
    'ModelQualityJobDefinitionNetworkConfigArgsDict',
    'ModelQualityJobDefinitionS3OutputArgs',
    'ModelQualityJobDefinitionS3OutputArgsDict',
    'ModelQualityJobDefinitionStoppingConditionArgs',
    'ModelQualityJobDefinitionStoppingConditionArgsDict',
    'ModelQualityJobDefinitionVpcConfigArgs',
    'ModelQualityJobDefinitionVpcConfigArgsDict',
    'MonitoringScheduleBaselineConfigArgs',
    'MonitoringScheduleBaselineConfigArgsDict',
    'MonitoringScheduleBatchTransformInputArgs',
    'MonitoringScheduleBatchTransformInputArgsDict',
    'MonitoringScheduleClusterConfigArgs',
    'MonitoringScheduleClusterConfigArgsDict',
    'MonitoringScheduleConfigArgs',
    'MonitoringScheduleConfigArgsDict',
    'MonitoringScheduleConstraintsResourceArgs',
    'MonitoringScheduleConstraintsResourceArgsDict',
    'MonitoringScheduleCsvArgs',
    'MonitoringScheduleCsvArgsDict',
    'MonitoringScheduleDatasetFormatArgs',
    'MonitoringScheduleDatasetFormatArgsDict',
    'MonitoringScheduleEndpointInputArgs',
    'MonitoringScheduleEndpointInputArgsDict',
    'MonitoringScheduleJsonArgs',
    'MonitoringScheduleJsonArgsDict',
    'MonitoringScheduleMonitoringAppSpecificationArgs',
    'MonitoringScheduleMonitoringAppSpecificationArgsDict',
    'MonitoringScheduleMonitoringExecutionSummaryArgs',
    'MonitoringScheduleMonitoringExecutionSummaryArgsDict',
    'MonitoringScheduleMonitoringInputArgs',
    'MonitoringScheduleMonitoringInputArgsDict',
    'MonitoringScheduleMonitoringJobDefinitionArgs',
    'MonitoringScheduleMonitoringJobDefinitionArgsDict',
    'MonitoringScheduleMonitoringOutputConfigArgs',
    'MonitoringScheduleMonitoringOutputConfigArgsDict',
    'MonitoringScheduleMonitoringOutputArgs',
    'MonitoringScheduleMonitoringOutputArgsDict',
    'MonitoringScheduleMonitoringResourcesArgs',
    'MonitoringScheduleMonitoringResourcesArgsDict',
    'MonitoringScheduleNetworkConfigArgs',
    'MonitoringScheduleNetworkConfigArgsDict',
    'MonitoringScheduleS3OutputArgs',
    'MonitoringScheduleS3OutputArgsDict',
    'MonitoringScheduleScheduleConfigArgs',
    'MonitoringScheduleScheduleConfigArgsDict',
    'MonitoringScheduleStatisticsResourceArgs',
    'MonitoringScheduleStatisticsResourceArgsDict',
    'MonitoringScheduleStoppingConditionArgs',
    'MonitoringScheduleStoppingConditionArgsDict',
    'MonitoringScheduleVpcConfigArgs',
    'MonitoringScheduleVpcConfigArgsDict',
    'OfflineStoreConfigPropertiesArgs',
    'OfflineStoreConfigPropertiesArgsDict',
    'OnlineStoreConfigPropertiesArgs',
    'OnlineStoreConfigPropertiesArgsDict',
    'ParallelismConfigurationPropertiesArgs',
    'ParallelismConfigurationPropertiesArgsDict',
    'PipelineDefinition0PropertiesArgs',
    'PipelineDefinition0PropertiesArgsDict',
    'PipelineDefinition1PropertiesArgs',
    'PipelineDefinition1PropertiesArgsDict',
    'PipelineS3LocationArgs',
    'PipelineS3LocationArgsDict',
    'ProjectProvisioningParameterArgs',
    'ProjectProvisioningParameterArgsDict',
    'ServiceCatalogProvisionedProductDetailsPropertiesArgs',
    'ServiceCatalogProvisionedProductDetailsPropertiesArgsDict',
    'ServiceCatalogProvisioningDetailsPropertiesArgs',
    'ServiceCatalogProvisioningDetailsPropertiesArgsDict',
    'SpaceAppLifecycleManagementArgs',
    'SpaceAppLifecycleManagementArgsDict',
    'SpaceCodeEditorAppSettingsArgs',
    'SpaceCodeEditorAppSettingsArgsDict',
    'SpaceCodeRepositoryArgs',
    'SpaceCodeRepositoryArgsDict',
    'SpaceCustomFileSystemArgs',
    'SpaceCustomFileSystemArgsDict',
    'SpaceCustomImageArgs',
    'SpaceCustomImageArgsDict',
    'SpaceEbsStorageSettingsArgs',
    'SpaceEbsStorageSettingsArgsDict',
    'SpaceEfsFileSystemArgs',
    'SpaceEfsFileSystemArgsDict',
    'SpaceIdleSettingsArgs',
    'SpaceIdleSettingsArgsDict',
    'SpaceJupyterLabAppSettingsArgs',
    'SpaceJupyterLabAppSettingsArgsDict',
    'SpaceJupyterServerAppSettingsArgs',
    'SpaceJupyterServerAppSettingsArgsDict',
    'SpaceKernelGatewayAppSettingsArgs',
    'SpaceKernelGatewayAppSettingsArgsDict',
    'SpaceOwnershipSettingsArgs',
    'SpaceOwnershipSettingsArgsDict',
    'SpaceResourceSpecArgs',
    'SpaceResourceSpecArgsDict',
    'SpaceSettingsArgs',
    'SpaceSettingsArgsDict',
    'SpaceSharingSettingsArgs',
    'SpaceSharingSettingsArgsDict',
    'SpaceStorageSettingsArgs',
    'SpaceStorageSettingsArgsDict',
    'UserProfileAppLifecycleManagementArgs',
    'UserProfileAppLifecycleManagementArgsDict',
    'UserProfileCodeEditorAppSettingsArgs',
    'UserProfileCodeEditorAppSettingsArgsDict',
    'UserProfileCodeRepositoryArgs',
    'UserProfileCodeRepositoryArgsDict',
    'UserProfileCustomFileSystemConfigArgs',
    'UserProfileCustomFileSystemConfigArgsDict',
    'UserProfileCustomImageArgs',
    'UserProfileCustomImageArgsDict',
    'UserProfileCustomPosixUserConfigArgs',
    'UserProfileCustomPosixUserConfigArgsDict',
    'UserProfileDefaultEbsStorageSettingsArgs',
    'UserProfileDefaultEbsStorageSettingsArgsDict',
    'UserProfileDefaultSpaceStorageSettingsArgs',
    'UserProfileDefaultSpaceStorageSettingsArgsDict',
    'UserProfileEfsFileSystemConfigArgs',
    'UserProfileEfsFileSystemConfigArgsDict',
    'UserProfileIdleSettingsArgs',
    'UserProfileIdleSettingsArgsDict',
    'UserProfileJupyterLabAppSettingsArgs',
    'UserProfileJupyterLabAppSettingsArgsDict',
    'UserProfileJupyterServerAppSettingsArgs',
    'UserProfileJupyterServerAppSettingsArgsDict',
    'UserProfileKernelGatewayAppSettingsArgs',
    'UserProfileKernelGatewayAppSettingsArgsDict',
    'UserProfileRStudioServerProAppSettingsArgs',
    'UserProfileRStudioServerProAppSettingsArgsDict',
    'UserProfileResourceSpecArgs',
    'UserProfileResourceSpecArgsDict',
    'UserProfileSharingSettingsArgs',
    'UserProfileSharingSettingsArgsDict',
    'UserProfileStudioWebPortalSettingsArgs',
    'UserProfileStudioWebPortalSettingsArgsDict',
    'UserProfileUserSettingsArgs',
    'UserProfileUserSettingsArgsDict',
]

MYPY = False

if not MYPY:
    class AppImageConfigCodeEditorAppImageConfigArgsDict(TypedDict):
        """
        The configuration for the kernels in a SageMaker image running as a CodeEditor app.
        """
        container_config: NotRequired[pulumi.Input['AppImageConfigContainerConfigArgsDict']]
        """
        The container configuration for a SageMaker image.
        """
elif False:
    AppImageConfigCodeEditorAppImageConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppImageConfigCodeEditorAppImageConfigArgs:
    def __init__(__self__, *,
                 container_config: Optional[pulumi.Input['AppImageConfigContainerConfigArgs']] = None):
        """
        The configuration for the kernels in a SageMaker image running as a CodeEditor app.
        :param pulumi.Input['AppImageConfigContainerConfigArgs'] container_config: The container configuration for a SageMaker image.
        """
        if container_config is not None:
            pulumi.set(__self__, "container_config", container_config)

    @property
    @pulumi.getter(name="containerConfig")
    def container_config(self) -> Optional[pulumi.Input['AppImageConfigContainerConfigArgs']]:
        """
        The container configuration for a SageMaker image.
        """
        return pulumi.get(self, "container_config")

    @container_config.setter
    def container_config(self, value: Optional[pulumi.Input['AppImageConfigContainerConfigArgs']]):
        pulumi.set(self, "container_config", value)


if not MYPY:
    class AppImageConfigContainerConfigArgsDict(TypedDict):
        """
        The container configuration for a SageMaker image.
        """
        container_arguments: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of arguments to apply to the container.
        """
        container_entrypoint: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The custom entry point to use on container.
        """
        container_environment_variables: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppImageConfigCustomImageContainerEnvironmentVariableArgsDict']]]]
        """
        A list of variables to apply to the custom container.
        """
elif False:
    AppImageConfigContainerConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppImageConfigContainerConfigArgs:
    def __init__(__self__, *,
                 container_arguments: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 container_entrypoint: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 container_environment_variables: Optional[pulumi.Input[Sequence[pulumi.Input['AppImageConfigCustomImageContainerEnvironmentVariableArgs']]]] = None):
        """
        The container configuration for a SageMaker image.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] container_arguments: A list of arguments to apply to the container.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] container_entrypoint: The custom entry point to use on container.
        :param pulumi.Input[Sequence[pulumi.Input['AppImageConfigCustomImageContainerEnvironmentVariableArgs']]] container_environment_variables: A list of variables to apply to the custom container.
        """
        if container_arguments is not None:
            pulumi.set(__self__, "container_arguments", container_arguments)
        if container_entrypoint is not None:
            pulumi.set(__self__, "container_entrypoint", container_entrypoint)
        if container_environment_variables is not None:
            pulumi.set(__self__, "container_environment_variables", container_environment_variables)

    @property
    @pulumi.getter(name="containerArguments")
    def container_arguments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of arguments to apply to the container.
        """
        return pulumi.get(self, "container_arguments")

    @container_arguments.setter
    def container_arguments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "container_arguments", value)

    @property
    @pulumi.getter(name="containerEntrypoint")
    def container_entrypoint(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The custom entry point to use on container.
        """
        return pulumi.get(self, "container_entrypoint")

    @container_entrypoint.setter
    def container_entrypoint(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "container_entrypoint", value)

    @property
    @pulumi.getter(name="containerEnvironmentVariables")
    def container_environment_variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppImageConfigCustomImageContainerEnvironmentVariableArgs']]]]:
        """
        A list of variables to apply to the custom container.
        """
        return pulumi.get(self, "container_environment_variables")

    @container_environment_variables.setter
    def container_environment_variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppImageConfigCustomImageContainerEnvironmentVariableArgs']]]]):
        pulumi.set(self, "container_environment_variables", value)


if not MYPY:
    class AppImageConfigCustomImageContainerEnvironmentVariableArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        The key that identifies a container environment variable.
        """
        value: pulumi.Input[str]
        """
        The value of the container environment variable.
        """
elif False:
    AppImageConfigCustomImageContainerEnvironmentVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppImageConfigCustomImageContainerEnvironmentVariableArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: The key that identifies a container environment variable.
        :param pulumi.Input[str] value: The value of the container environment variable.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key that identifies a container environment variable.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value of the container environment variable.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AppImageConfigFileSystemConfigArgsDict(TypedDict):
        """
        The Amazon Elastic File System (EFS) storage configuration for a SageMaker image.
        """
        default_gid: NotRequired[pulumi.Input[int]]
        """
        The default POSIX group ID (GID). If not specified, defaults to 100.
        """
        default_uid: NotRequired[pulumi.Input[int]]
        """
        The default POSIX user ID (UID). If not specified, defaults to 1000.
        """
        mount_path: NotRequired[pulumi.Input[str]]
        """
        The path within the image to mount the user's EFS home directory. The directory should be empty. If not specified, defaults to /home/sagemaker-user.
        """
elif False:
    AppImageConfigFileSystemConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppImageConfigFileSystemConfigArgs:
    def __init__(__self__, *,
                 default_gid: Optional[pulumi.Input[int]] = None,
                 default_uid: Optional[pulumi.Input[int]] = None,
                 mount_path: Optional[pulumi.Input[str]] = None):
        """
        The Amazon Elastic File System (EFS) storage configuration for a SageMaker image.
        :param pulumi.Input[int] default_gid: The default POSIX group ID (GID). If not specified, defaults to 100.
        :param pulumi.Input[int] default_uid: The default POSIX user ID (UID). If not specified, defaults to 1000.
        :param pulumi.Input[str] mount_path: The path within the image to mount the user's EFS home directory. The directory should be empty. If not specified, defaults to /home/sagemaker-user.
        """
        if default_gid is not None:
            pulumi.set(__self__, "default_gid", default_gid)
        if default_uid is not None:
            pulumi.set(__self__, "default_uid", default_uid)
        if mount_path is not None:
            pulumi.set(__self__, "mount_path", mount_path)

    @property
    @pulumi.getter(name="defaultGid")
    def default_gid(self) -> Optional[pulumi.Input[int]]:
        """
        The default POSIX group ID (GID). If not specified, defaults to 100.
        """
        return pulumi.get(self, "default_gid")

    @default_gid.setter
    def default_gid(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "default_gid", value)

    @property
    @pulumi.getter(name="defaultUid")
    def default_uid(self) -> Optional[pulumi.Input[int]]:
        """
        The default POSIX user ID (UID). If not specified, defaults to 1000.
        """
        return pulumi.get(self, "default_uid")

    @default_uid.setter
    def default_uid(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "default_uid", value)

    @property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path within the image to mount the user's EFS home directory. The directory should be empty. If not specified, defaults to /home/sagemaker-user.
        """
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mount_path", value)


if not MYPY:
    class AppImageConfigJupyterLabAppImageConfigArgsDict(TypedDict):
        """
        The configuration for the kernels in a SageMaker image running as a JupyterLab app.
        """
        container_config: NotRequired[pulumi.Input['AppImageConfigContainerConfigArgsDict']]
        """
        The container configuration for a SageMaker image.
        """
elif False:
    AppImageConfigJupyterLabAppImageConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppImageConfigJupyterLabAppImageConfigArgs:
    def __init__(__self__, *,
                 container_config: Optional[pulumi.Input['AppImageConfigContainerConfigArgs']] = None):
        """
        The configuration for the kernels in a SageMaker image running as a JupyterLab app.
        :param pulumi.Input['AppImageConfigContainerConfigArgs'] container_config: The container configuration for a SageMaker image.
        """
        if container_config is not None:
            pulumi.set(__self__, "container_config", container_config)

    @property
    @pulumi.getter(name="containerConfig")
    def container_config(self) -> Optional[pulumi.Input['AppImageConfigContainerConfigArgs']]:
        """
        The container configuration for a SageMaker image.
        """
        return pulumi.get(self, "container_config")

    @container_config.setter
    def container_config(self, value: Optional[pulumi.Input['AppImageConfigContainerConfigArgs']]):
        pulumi.set(self, "container_config", value)


if not MYPY:
    class AppImageConfigKernelGatewayImageConfigArgsDict(TypedDict):
        """
        The configuration for the file system and kernels in a SageMaker image running as a KernelGateway app.
        """
        kernel_specs: pulumi.Input[Sequence[pulumi.Input['AppImageConfigKernelSpecArgsDict']]]
        """
        The specification of the Jupyter kernels in the image.
        """
        file_system_config: NotRequired[pulumi.Input['AppImageConfigFileSystemConfigArgsDict']]
        """
        The Amazon Elastic File System (EFS) storage configuration for a SageMaker image.
        """
elif False:
    AppImageConfigKernelGatewayImageConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppImageConfigKernelGatewayImageConfigArgs:
    def __init__(__self__, *,
                 kernel_specs: pulumi.Input[Sequence[pulumi.Input['AppImageConfigKernelSpecArgs']]],
                 file_system_config: Optional[pulumi.Input['AppImageConfigFileSystemConfigArgs']] = None):
        """
        The configuration for the file system and kernels in a SageMaker image running as a KernelGateway app.
        :param pulumi.Input[Sequence[pulumi.Input['AppImageConfigKernelSpecArgs']]] kernel_specs: The specification of the Jupyter kernels in the image.
        :param pulumi.Input['AppImageConfigFileSystemConfigArgs'] file_system_config: The Amazon Elastic File System (EFS) storage configuration for a SageMaker image.
        """
        pulumi.set(__self__, "kernel_specs", kernel_specs)
        if file_system_config is not None:
            pulumi.set(__self__, "file_system_config", file_system_config)

    @property
    @pulumi.getter(name="kernelSpecs")
    def kernel_specs(self) -> pulumi.Input[Sequence[pulumi.Input['AppImageConfigKernelSpecArgs']]]:
        """
        The specification of the Jupyter kernels in the image.
        """
        return pulumi.get(self, "kernel_specs")

    @kernel_specs.setter
    def kernel_specs(self, value: pulumi.Input[Sequence[pulumi.Input['AppImageConfigKernelSpecArgs']]]):
        pulumi.set(self, "kernel_specs", value)

    @property
    @pulumi.getter(name="fileSystemConfig")
    def file_system_config(self) -> Optional[pulumi.Input['AppImageConfigFileSystemConfigArgs']]:
        """
        The Amazon Elastic File System (EFS) storage configuration for a SageMaker image.
        """
        return pulumi.get(self, "file_system_config")

    @file_system_config.setter
    def file_system_config(self, value: Optional[pulumi.Input['AppImageConfigFileSystemConfigArgs']]):
        pulumi.set(self, "file_system_config", value)


if not MYPY:
    class AppImageConfigKernelSpecArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the kernel.
        """
        display_name: NotRequired[pulumi.Input[str]]
        """
        The display name of the kernel.
        """
elif False:
    AppImageConfigKernelSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppImageConfigKernelSpecArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 display_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the kernel.
        :param pulumi.Input[str] display_name: The display name of the kernel.
        """
        pulumi.set(__self__, "name", name)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the kernel.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        The display name of the kernel.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class AppResourceSpecArgsDict(TypedDict):
        instance_type: NotRequired[pulumi.Input['AppResourceSpecInstanceType']]
        """
        The instance type that the image version runs on.
        """
        lifecycle_config_arn: NotRequired[pulumi.Input[str]]
        """
        The Amazon Resource Name (ARN) of the Lifecycle Configuration to attach to the Resource.
        """
        sage_maker_image_arn: NotRequired[pulumi.Input[str]]
        """
        The ARN of the SageMaker image that the image version belongs to.
        """
        sage_maker_image_version_arn: NotRequired[pulumi.Input[str]]
        """
        The ARN of the image version created on the instance.
        """
elif False:
    AppResourceSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppResourceSpecArgs:
    def __init__(__self__, *,
                 instance_type: Optional[pulumi.Input['AppResourceSpecInstanceType']] = None,
                 lifecycle_config_arn: Optional[pulumi.Input[str]] = None,
                 sage_maker_image_arn: Optional[pulumi.Input[str]] = None,
                 sage_maker_image_version_arn: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['AppResourceSpecInstanceType'] instance_type: The instance type that the image version runs on.
        :param pulumi.Input[str] lifecycle_config_arn: The Amazon Resource Name (ARN) of the Lifecycle Configuration to attach to the Resource.
        :param pulumi.Input[str] sage_maker_image_arn: The ARN of the SageMaker image that the image version belongs to.
        :param pulumi.Input[str] sage_maker_image_version_arn: The ARN of the image version created on the instance.
        """
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if lifecycle_config_arn is not None:
            pulumi.set(__self__, "lifecycle_config_arn", lifecycle_config_arn)
        if sage_maker_image_arn is not None:
            pulumi.set(__self__, "sage_maker_image_arn", sage_maker_image_arn)
        if sage_maker_image_version_arn is not None:
            pulumi.set(__self__, "sage_maker_image_version_arn", sage_maker_image_version_arn)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[pulumi.Input['AppResourceSpecInstanceType']]:
        """
        The instance type that the image version runs on.
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: Optional[pulumi.Input['AppResourceSpecInstanceType']]):
        pulumi.set(self, "instance_type", value)

    @property
    @pulumi.getter(name="lifecycleConfigArn")
    def lifecycle_config_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon Resource Name (ARN) of the Lifecycle Configuration to attach to the Resource.
        """
        return pulumi.get(self, "lifecycle_config_arn")

    @lifecycle_config_arn.setter
    def lifecycle_config_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_config_arn", value)

    @property
    @pulumi.getter(name="sageMakerImageArn")
    def sage_maker_image_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The ARN of the SageMaker image that the image version belongs to.
        """
        return pulumi.get(self, "sage_maker_image_arn")

    @sage_maker_image_arn.setter
    def sage_maker_image_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sage_maker_image_arn", value)

    @property
    @pulumi.getter(name="sageMakerImageVersionArn")
    def sage_maker_image_version_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The ARN of the image version created on the instance.
        """
        return pulumi.get(self, "sage_maker_image_version_arn")

    @sage_maker_image_version_arn.setter
    def sage_maker_image_version_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sage_maker_image_version_arn", value)


if not MYPY:
    class ClusterInstanceGroupArgsDict(TypedDict):
        """
        Details of an instance group in a SageMaker HyperPod cluster.
        """
        execution_role: pulumi.Input[str]
        instance_count: pulumi.Input[int]
        """
        The number of instances you specified to add to the instance group of a SageMaker HyperPod cluster.
        """
        instance_group_name: pulumi.Input[str]
        instance_type: pulumi.Input[str]
        life_cycle_config: pulumi.Input['ClusterLifeCycleConfigArgsDict']
        current_count: NotRequired[pulumi.Input[int]]
        """
        The number of instances that are currently in the instance group of a SageMaker HyperPod cluster.
        """
        custom_metadata: NotRequired[Any]
        instance_storage_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterInstanceStorageConfigArgsDict']]]]
        on_start_deep_health_checks: NotRequired[pulumi.Input[Sequence[pulumi.Input['ClusterDeepHealthCheckType']]]]
        override_vpc_config: NotRequired[pulumi.Input['ClusterVpcConfigArgsDict']]
        threads_per_core: NotRequired[pulumi.Input[int]]
        """
        The number you specified to TreadsPerCore in CreateCluster for enabling or disabling multithreading. For instance types that support multithreading, you can specify 1 for disabling multithreading and 2 for enabling multithreading.
        """
elif False:
    ClusterInstanceGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterInstanceGroupArgs:
    def __init__(__self__, *,
                 execution_role: pulumi.Input[str],
                 instance_count: pulumi.Input[int],
                 instance_group_name: pulumi.Input[str],
                 instance_type: pulumi.Input[str],
                 life_cycle_config: pulumi.Input['ClusterLifeCycleConfigArgs'],
                 current_count: Optional[pulumi.Input[int]] = None,
                 custom_metadata: Optional[Any] = None,
                 instance_storage_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterInstanceStorageConfigArgs']]]] = None,
                 on_start_deep_health_checks: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterDeepHealthCheckType']]]] = None,
                 override_vpc_config: Optional[pulumi.Input['ClusterVpcConfigArgs']] = None,
                 threads_per_core: Optional[pulumi.Input[int]] = None):
        """
        Details of an instance group in a SageMaker HyperPod cluster.
        :param pulumi.Input[int] instance_count: The number of instances you specified to add to the instance group of a SageMaker HyperPod cluster.
        :param pulumi.Input[int] current_count: The number of instances that are currently in the instance group of a SageMaker HyperPod cluster.
        :param pulumi.Input[int] threads_per_core: The number you specified to TreadsPerCore in CreateCluster for enabling or disabling multithreading. For instance types that support multithreading, you can specify 1 for disabling multithreading and 2 for enabling multithreading.
        """
        pulumi.set(__self__, "execution_role", execution_role)
        pulumi.set(__self__, "instance_count", instance_count)
        pulumi.set(__self__, "instance_group_name", instance_group_name)
        pulumi.set(__self__, "instance_type", instance_type)
        pulumi.set(__self__, "life_cycle_config", life_cycle_config)
        if current_count is not None:
            pulumi.set(__self__, "current_count", current_count)
        if custom_metadata is not None:
            pulumi.set(__self__, "custom_metadata", custom_metadata)
        if instance_storage_configs is not None:
            pulumi.set(__self__, "instance_storage_configs", instance_storage_configs)
        if on_start_deep_health_checks is not None:
            pulumi.set(__self__, "on_start_deep_health_checks", on_start_deep_health_checks)
        if override_vpc_config is not None:
            pulumi.set(__self__, "override_vpc_config", override_vpc_config)
        if threads_per_core is not None:
            pulumi.set(__self__, "threads_per_core", threads_per_core)

    @property
    @pulumi.getter(name="executionRole")
    def execution_role(self) -> pulumi.Input[str]:
        return pulumi.get(self, "execution_role")

    @execution_role.setter
    def execution_role(self, value: pulumi.Input[str]):
        pulumi.set(self, "execution_role", value)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> pulumi.Input[int]:
        """
        The number of instances you specified to add to the instance group of a SageMaker HyperPod cluster.
        """
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "instance_count", value)

    @property
    @pulumi.getter(name="instanceGroupName")
    def instance_group_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "instance_group_name")

    @instance_group_name.setter
    def instance_group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance_group_name", value)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance_type", value)

    @property
    @pulumi.getter(name="lifeCycleConfig")
    def life_cycle_config(self) -> pulumi.Input['ClusterLifeCycleConfigArgs']:
        return pulumi.get(self, "life_cycle_config")

    @life_cycle_config.setter
    def life_cycle_config(self, value: pulumi.Input['ClusterLifeCycleConfigArgs']):
        pulumi.set(self, "life_cycle_config", value)

    @property
    @pulumi.getter(name="currentCount")
    def current_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of instances that are currently in the instance group of a SageMaker HyperPod cluster.
        """
        return pulumi.get(self, "current_count")

    @current_count.setter
    def current_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "current_count", value)

    @property
    @pulumi.getter(name="customMetadata")
    def custom_metadata(self) -> Optional[Any]:
        return pulumi.get(self, "custom_metadata")

    @custom_metadata.setter
    def custom_metadata(self, value: Optional[Any]):
        pulumi.set(self, "custom_metadata", value)

    @property
    @pulumi.getter(name="instanceStorageConfigs")
    def instance_storage_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterInstanceStorageConfigArgs']]]]:
        return pulumi.get(self, "instance_storage_configs")

    @instance_storage_configs.setter
    def instance_storage_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterInstanceStorageConfigArgs']]]]):
        pulumi.set(self, "instance_storage_configs", value)

    @property
    @pulumi.getter(name="onStartDeepHealthChecks")
    def on_start_deep_health_checks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterDeepHealthCheckType']]]]:
        return pulumi.get(self, "on_start_deep_health_checks")

    @on_start_deep_health_checks.setter
    def on_start_deep_health_checks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterDeepHealthCheckType']]]]):
        pulumi.set(self, "on_start_deep_health_checks", value)

    @property
    @pulumi.getter(name="overrideVpcConfig")
    def override_vpc_config(self) -> Optional[pulumi.Input['ClusterVpcConfigArgs']]:
        return pulumi.get(self, "override_vpc_config")

    @override_vpc_config.setter
    def override_vpc_config(self, value: Optional[pulumi.Input['ClusterVpcConfigArgs']]):
        pulumi.set(self, "override_vpc_config", value)

    @property
    @pulumi.getter(name="threadsPerCore")
    def threads_per_core(self) -> Optional[pulumi.Input[int]]:
        """
        The number you specified to TreadsPerCore in CreateCluster for enabling or disabling multithreading. For instance types that support multithreading, you can specify 1 for disabling multithreading and 2 for enabling multithreading.
        """
        return pulumi.get(self, "threads_per_core")

    @threads_per_core.setter
    def threads_per_core(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "threads_per_core", value)


if not MYPY:
    class ClusterInstanceStorageConfigArgsDict(TypedDict):
        """
        Defines the configuration for attaching additional storage to the instances in the SageMaker HyperPod cluster instance group.
        """
        pass
elif False:
    ClusterInstanceStorageConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterInstanceStorageConfigArgs:
    def __init__(__self__):
        """
        Defines the configuration for attaching additional storage to the instances in the SageMaker HyperPod cluster instance group.
        """
        pass


if not MYPY:
    class ClusterLifeCycleConfigArgsDict(TypedDict):
        """
        The lifecycle configuration for a SageMaker HyperPod cluster.
        """
        on_create: pulumi.Input[str]
        """
        The file name of the entrypoint script of lifecycle scripts under SourceS3Uri. This entrypoint script runs during cluster creation.
        """
        source_s3_uri: pulumi.Input[str]
        """
        An Amazon S3 bucket path where your lifecycle scripts are stored.
        """
elif False:
    ClusterLifeCycleConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterLifeCycleConfigArgs:
    def __init__(__self__, *,
                 on_create: pulumi.Input[str],
                 source_s3_uri: pulumi.Input[str]):
        """
        The lifecycle configuration for a SageMaker HyperPod cluster.
        :param pulumi.Input[str] on_create: The file name of the entrypoint script of lifecycle scripts under SourceS3Uri. This entrypoint script runs during cluster creation.
        :param pulumi.Input[str] source_s3_uri: An Amazon S3 bucket path where your lifecycle scripts are stored.
        """
        pulumi.set(__self__, "on_create", on_create)
        pulumi.set(__self__, "source_s3_uri", source_s3_uri)

    @property
    @pulumi.getter(name="onCreate")
    def on_create(self) -> pulumi.Input[str]:
        """
        The file name of the entrypoint script of lifecycle scripts under SourceS3Uri. This entrypoint script runs during cluster creation.
        """
        return pulumi.get(self, "on_create")

    @on_create.setter
    def on_create(self, value: pulumi.Input[str]):
        pulumi.set(self, "on_create", value)

    @property
    @pulumi.getter(name="sourceS3Uri")
    def source_s3_uri(self) -> pulumi.Input[str]:
        """
        An Amazon S3 bucket path where your lifecycle scripts are stored.
        """
        return pulumi.get(self, "source_s3_uri")

    @source_s3_uri.setter
    def source_s3_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_s3_uri", value)


if not MYPY:
    class ClusterOrchestratorEksConfigArgsDict(TypedDict):
        """
        Specifies parameter(s) related to EKS as orchestrator, e.g. the EKS cluster nodes will attach to,
        """
        cluster_arn: pulumi.Input[str]
        """
        The ARN of the EKS cluster, such as arn:aws:eks:us-west-2:123456789012:cluster/my-eks-cluster
        """
elif False:
    ClusterOrchestratorEksConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterOrchestratorEksConfigArgs:
    def __init__(__self__, *,
                 cluster_arn: pulumi.Input[str]):
        """
        Specifies parameter(s) related to EKS as orchestrator, e.g. the EKS cluster nodes will attach to,
        :param pulumi.Input[str] cluster_arn: The ARN of the EKS cluster, such as arn:aws:eks:us-west-2:123456789012:cluster/my-eks-cluster
        """
        pulumi.set(__self__, "cluster_arn", cluster_arn)

    @property
    @pulumi.getter(name="clusterArn")
    def cluster_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the EKS cluster, such as arn:aws:eks:us-west-2:123456789012:cluster/my-eks-cluster
        """
        return pulumi.get(self, "cluster_arn")

    @cluster_arn.setter
    def cluster_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "cluster_arn", value)


if not MYPY:
    class ClusterOrchestratorArgsDict(TypedDict):
        """
        Specifies parameter(s) specific to the orchestrator, e.g. specify the EKS cluster.
        """
        eks: pulumi.Input['ClusterOrchestratorEksConfigArgsDict']
        """
        The configuration of the Amazon EKS orchestrator cluster for the SageMaker HyperPod cluster.
        """
elif False:
    ClusterOrchestratorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterOrchestratorArgs:
    def __init__(__self__, *,
                 eks: pulumi.Input['ClusterOrchestratorEksConfigArgs']):
        """
        Specifies parameter(s) specific to the orchestrator, e.g. specify the EKS cluster.
        :param pulumi.Input['ClusterOrchestratorEksConfigArgs'] eks: The configuration of the Amazon EKS orchestrator cluster for the SageMaker HyperPod cluster.
        """
        pulumi.set(__self__, "eks", eks)

    @property
    @pulumi.getter
    def eks(self) -> pulumi.Input['ClusterOrchestratorEksConfigArgs']:
        """
        The configuration of the Amazon EKS orchestrator cluster for the SageMaker HyperPod cluster.
        """
        return pulumi.get(self, "eks")

    @eks.setter
    def eks(self, value: pulumi.Input['ClusterOrchestratorEksConfigArgs']):
        pulumi.set(self, "eks", value)


if not MYPY:
    class ClusterVpcConfigArgsDict(TypedDict):
        """
        Specifies an Amazon Virtual Private Cloud (VPC) that your SageMaker jobs, hosted models, and compute resources have access to. You can control access to and from your resources by configuring a VPC.
        """
        security_group_ids: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the Subnets field.
        """
        subnets: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The ID of the subnets in the VPC to which you want to connect your training job or model.
        """
elif False:
    ClusterVpcConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterVpcConfigArgs:
    def __init__(__self__, *,
                 security_group_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 subnets: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        Specifies an Amazon Virtual Private Cloud (VPC) that your SageMaker jobs, hosted models, and compute resources have access to. You can control access to and from your resources by configuring a VPC.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_group_ids: The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the Subnets field.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subnets: The ID of the subnets in the VPC to which you want to connect your training job or model.
        """
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnets", subnets)

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the Subnets field.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "security_group_ids", value)

    @property
    @pulumi.getter
    def subnets(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The ID of the subnets in the VPC to which you want to connect your training job or model.
        """
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "subnets", value)


if not MYPY:
    class DataQualityJobDefinitionBatchTransformInputArgsDict(TypedDict):
        """
        The batch transform input for a monitoring job.
        """
        data_captured_destination_s3_uri: pulumi.Input[str]
        """
        A URI that identifies the Amazon S3 storage location where Batch Transform Job captures data.
        """
        dataset_format: pulumi.Input['DataQualityJobDefinitionDatasetFormatArgsDict']
        """
        The dataset format for your batch transform job.
        """
        local_path: pulumi.Input[str]
        """
        Path to the filesystem where the endpoint data is available to the container.
        """
        exclude_features_attribute: NotRequired[pulumi.Input[str]]
        """
        Indexes or names of the features to be excluded from analysis
        """
        s3_data_distribution_type: NotRequired[pulumi.Input['DataQualityJobDefinitionBatchTransformInputS3DataDistributionType']]
        """
        Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
        """
        s3_input_mode: NotRequired[pulumi.Input['DataQualityJobDefinitionBatchTransformInputS3InputMode']]
        """
        Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
        """
elif False:
    DataQualityJobDefinitionBatchTransformInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataQualityJobDefinitionBatchTransformInputArgs:
    def __init__(__self__, *,
                 data_captured_destination_s3_uri: pulumi.Input[str],
                 dataset_format: pulumi.Input['DataQualityJobDefinitionDatasetFormatArgs'],
                 local_path: pulumi.Input[str],
                 exclude_features_attribute: Optional[pulumi.Input[str]] = None,
                 s3_data_distribution_type: Optional[pulumi.Input['DataQualityJobDefinitionBatchTransformInputS3DataDistributionType']] = None,
                 s3_input_mode: Optional[pulumi.Input['DataQualityJobDefinitionBatchTransformInputS3InputMode']] = None):
        """
        The batch transform input for a monitoring job.
        :param pulumi.Input[str] data_captured_destination_s3_uri: A URI that identifies the Amazon S3 storage location where Batch Transform Job captures data.
        :param pulumi.Input['DataQualityJobDefinitionDatasetFormatArgs'] dataset_format: The dataset format for your batch transform job.
        :param pulumi.Input[str] local_path: Path to the filesystem where the endpoint data is available to the container.
        :param pulumi.Input[str] exclude_features_attribute: Indexes or names of the features to be excluded from analysis
        :param pulumi.Input['DataQualityJobDefinitionBatchTransformInputS3DataDistributionType'] s3_data_distribution_type: Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
        :param pulumi.Input['DataQualityJobDefinitionBatchTransformInputS3InputMode'] s3_input_mode: Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
        """
        pulumi.set(__self__, "data_captured_destination_s3_uri", data_captured_destination_s3_uri)
        pulumi.set(__self__, "dataset_format", dataset_format)
        pulumi.set(__self__, "local_path", local_path)
        if exclude_features_attribute is not None:
            pulumi.set(__self__, "exclude_features_attribute", exclude_features_attribute)
        if s3_data_distribution_type is not None:
            pulumi.set(__self__, "s3_data_distribution_type", s3_data_distribution_type)
        if s3_input_mode is not None:
            pulumi.set(__self__, "s3_input_mode", s3_input_mode)

    @property
    @pulumi.getter(name="dataCapturedDestinationS3Uri")
    def data_captured_destination_s3_uri(self) -> pulumi.Input[str]:
        """
        A URI that identifies the Amazon S3 storage location where Batch Transform Job captures data.
        """
        return pulumi.get(self, "data_captured_destination_s3_uri")

    @data_captured_destination_s3_uri.setter
    def data_captured_destination_s3_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_captured_destination_s3_uri", value)

    @property
    @pulumi.getter(name="datasetFormat")
    def dataset_format(self) -> pulumi.Input['DataQualityJobDefinitionDatasetFormatArgs']:
        """
        The dataset format for your batch transform job.
        """
        return pulumi.get(self, "dataset_format")

    @dataset_format.setter
    def dataset_format(self, value: pulumi.Input['DataQualityJobDefinitionDatasetFormatArgs']):
        pulumi.set(self, "dataset_format", value)

    @property
    @pulumi.getter(name="localPath")
    def local_path(self) -> pulumi.Input[str]:
        """
        Path to the filesystem where the endpoint data is available to the container.
        """
        return pulumi.get(self, "local_path")

    @local_path.setter
    def local_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "local_path", value)

    @property
    @pulumi.getter(name="excludeFeaturesAttribute")
    def exclude_features_attribute(self) -> Optional[pulumi.Input[str]]:
        """
        Indexes or names of the features to be excluded from analysis
        """
        return pulumi.get(self, "exclude_features_attribute")

    @exclude_features_attribute.setter
    def exclude_features_attribute(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exclude_features_attribute", value)

    @property
    @pulumi.getter(name="s3DataDistributionType")
    def s3_data_distribution_type(self) -> Optional[pulumi.Input['DataQualityJobDefinitionBatchTransformInputS3DataDistributionType']]:
        """
        Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
        """
        return pulumi.get(self, "s3_data_distribution_type")

    @s3_data_distribution_type.setter
    def s3_data_distribution_type(self, value: Optional[pulumi.Input['DataQualityJobDefinitionBatchTransformInputS3DataDistributionType']]):
        pulumi.set(self, "s3_data_distribution_type", value)

    @property
    @pulumi.getter(name="s3InputMode")
    def s3_input_mode(self) -> Optional[pulumi.Input['DataQualityJobDefinitionBatchTransformInputS3InputMode']]:
        """
        Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
        """
        return pulumi.get(self, "s3_input_mode")

    @s3_input_mode.setter
    def s3_input_mode(self, value: Optional[pulumi.Input['DataQualityJobDefinitionBatchTransformInputS3InputMode']]):
        pulumi.set(self, "s3_input_mode", value)


if not MYPY:
    class DataQualityJobDefinitionClusterConfigArgsDict(TypedDict):
        """
        Configuration for the cluster used to run model monitoring jobs.
        """
        instance_count: pulumi.Input[int]
        """
        The number of ML compute instances to use in the model monitoring job. For distributed processing jobs, specify a value greater than 1. The default value is 1.
        """
        instance_type: pulumi.Input[str]
        """
        The ML compute instance type for the processing job.
        """
        volume_size_in_gb: pulumi.Input[int]
        """
        The size of the ML storage volume, in gigabytes, that you want to provision. You must specify sufficient ML storage for your scenario.
        """
        volume_kms_key_id: NotRequired[pulumi.Input[str]]
        """
        The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the model monitoring job.
        """
elif False:
    DataQualityJobDefinitionClusterConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataQualityJobDefinitionClusterConfigArgs:
    def __init__(__self__, *,
                 instance_count: pulumi.Input[int],
                 instance_type: pulumi.Input[str],
                 volume_size_in_gb: pulumi.Input[int],
                 volume_kms_key_id: Optional[pulumi.Input[str]] = None):
        """
        Configuration for the cluster used to run model monitoring jobs.
        :param pulumi.Input[int] instance_count: The number of ML compute instances to use in the model monitoring job. For distributed processing jobs, specify a value greater than 1. The default value is 1.
        :param pulumi.Input[str] instance_type: The ML compute instance type for the processing job.
        :param pulumi.Input[int] volume_size_in_gb: The size of the ML storage volume, in gigabytes, that you want to provision. You must specify sufficient ML storage for your scenario.
        :param pulumi.Input[str] volume_kms_key_id: The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the model monitoring job.
        """
        pulumi.set(__self__, "instance_count", instance_count)
        pulumi.set(__self__, "instance_type", instance_type)
        pulumi.set(__self__, "volume_size_in_gb", volume_size_in_gb)
        if volume_kms_key_id is not None:
            pulumi.set(__self__, "volume_kms_key_id", volume_kms_key_id)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> pulumi.Input[int]:
        """
        The number of ML compute instances to use in the model monitoring job. For distributed processing jobs, specify a value greater than 1. The default value is 1.
        """
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "instance_count", value)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> pulumi.Input[str]:
        """
        The ML compute instance type for the processing job.
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance_type", value)

    @property
    @pulumi.getter(name="volumeSizeInGb")
    def volume_size_in_gb(self) -> pulumi.Input[int]:
        """
        The size of the ML storage volume, in gigabytes, that you want to provision. You must specify sufficient ML storage for your scenario.
        """
        return pulumi.get(self, "volume_size_in_gb")

    @volume_size_in_gb.setter
    def volume_size_in_gb(self, value: pulumi.Input[int]):
        pulumi.set(self, "volume_size_in_gb", value)

    @property
    @pulumi.getter(name="volumeKmsKeyId")
    def volume_kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the model monitoring job.
        """
        return pulumi.get(self, "volume_kms_key_id")

    @volume_kms_key_id.setter
    def volume_kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_kms_key_id", value)


if not MYPY:
    class DataQualityJobDefinitionConstraintsResourceArgsDict(TypedDict):
        """
        The baseline constraints resource for a monitoring job.
        """
        s3_uri: NotRequired[pulumi.Input[str]]
        """
        The Amazon S3 URI for baseline constraint file in Amazon S3 that the current monitoring job should validated against.
        """
elif False:
    DataQualityJobDefinitionConstraintsResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataQualityJobDefinitionConstraintsResourceArgs:
    def __init__(__self__, *,
                 s3_uri: Optional[pulumi.Input[str]] = None):
        """
        The baseline constraints resource for a monitoring job.
        :param pulumi.Input[str] s3_uri: The Amazon S3 URI for baseline constraint file in Amazon S3 that the current monitoring job should validated against.
        """
        if s3_uri is not None:
            pulumi.set(__self__, "s3_uri", s3_uri)

    @property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon S3 URI for baseline constraint file in Amazon S3 that the current monitoring job should validated against.
        """
        return pulumi.get(self, "s3_uri")

    @s3_uri.setter
    def s3_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_uri", value)


if not MYPY:
    class DataQualityJobDefinitionCsvArgsDict(TypedDict):
        """
        The CSV format
        """
        header: NotRequired[pulumi.Input[bool]]
        """
        A boolean flag indicating if given CSV has header
        """
elif False:
    DataQualityJobDefinitionCsvArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataQualityJobDefinitionCsvArgs:
    def __init__(__self__, *,
                 header: Optional[pulumi.Input[bool]] = None):
        """
        The CSV format
        :param pulumi.Input[bool] header: A boolean flag indicating if given CSV has header
        """
        if header is not None:
            pulumi.set(__self__, "header", header)

    @property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean flag indicating if given CSV has header
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "header", value)


if not MYPY:
    class DataQualityJobDefinitionDataQualityAppSpecificationArgsDict(TypedDict):
        """
        Container image configuration object for the monitoring job.
        """
        image_uri: pulumi.Input[str]
        """
        The container image to be run by the monitoring job.
        """
        container_arguments: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of arguments for the container used to run the monitoring job.
        """
        container_entrypoint: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies the entrypoint for a container used to run the monitoring job.
        """
        environment: NotRequired[Any]
        """
        Sets the environment variables in the Docker container
        """
        post_analytics_processor_source_uri: NotRequired[pulumi.Input[str]]
        """
        An Amazon S3 URI to a script that is called after analysis has been performed. Applicable only for the built-in (first party) containers.
        """
        record_preprocessor_source_uri: NotRequired[pulumi.Input[str]]
        """
        An Amazon S3 URI to a script that is called per row prior to running analysis. It can base64 decode the payload and convert it into a flatted json so that the built-in container can use the converted data. Applicable only for the built-in (first party) containers
        """
elif False:
    DataQualityJobDefinitionDataQualityAppSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataQualityJobDefinitionDataQualityAppSpecificationArgs:
    def __init__(__self__, *,
                 image_uri: pulumi.Input[str],
                 container_arguments: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 container_entrypoint: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 environment: Optional[Any] = None,
                 post_analytics_processor_source_uri: Optional[pulumi.Input[str]] = None,
                 record_preprocessor_source_uri: Optional[pulumi.Input[str]] = None):
        """
        Container image configuration object for the monitoring job.
        :param pulumi.Input[str] image_uri: The container image to be run by the monitoring job.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] container_arguments: An array of arguments for the container used to run the monitoring job.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] container_entrypoint: Specifies the entrypoint for a container used to run the monitoring job.
        :param Any environment: Sets the environment variables in the Docker container
        :param pulumi.Input[str] post_analytics_processor_source_uri: An Amazon S3 URI to a script that is called after analysis has been performed. Applicable only for the built-in (first party) containers.
        :param pulumi.Input[str] record_preprocessor_source_uri: An Amazon S3 URI to a script that is called per row prior to running analysis. It can base64 decode the payload and convert it into a flatted json so that the built-in container can use the converted data. Applicable only for the built-in (first party) containers
        """
        pulumi.set(__self__, "image_uri", image_uri)
        if container_arguments is not None:
            pulumi.set(__self__, "container_arguments", container_arguments)
        if container_entrypoint is not None:
            pulumi.set(__self__, "container_entrypoint", container_entrypoint)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if post_analytics_processor_source_uri is not None:
            pulumi.set(__self__, "post_analytics_processor_source_uri", post_analytics_processor_source_uri)
        if record_preprocessor_source_uri is not None:
            pulumi.set(__self__, "record_preprocessor_source_uri", record_preprocessor_source_uri)

    @property
    @pulumi.getter(name="imageUri")
    def image_uri(self) -> pulumi.Input[str]:
        """
        The container image to be run by the monitoring job.
        """
        return pulumi.get(self, "image_uri")

    @image_uri.setter
    def image_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "image_uri", value)

    @property
    @pulumi.getter(name="containerArguments")
    def container_arguments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of arguments for the container used to run the monitoring job.
        """
        return pulumi.get(self, "container_arguments")

    @container_arguments.setter
    def container_arguments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "container_arguments", value)

    @property
    @pulumi.getter(name="containerEntrypoint")
    def container_entrypoint(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies the entrypoint for a container used to run the monitoring job.
        """
        return pulumi.get(self, "container_entrypoint")

    @container_entrypoint.setter
    def container_entrypoint(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "container_entrypoint", value)

    @property
    @pulumi.getter
    def environment(self) -> Optional[Any]:
        """
        Sets the environment variables in the Docker container
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[Any]):
        pulumi.set(self, "environment", value)

    @property
    @pulumi.getter(name="postAnalyticsProcessorSourceUri")
    def post_analytics_processor_source_uri(self) -> Optional[pulumi.Input[str]]:
        """
        An Amazon S3 URI to a script that is called after analysis has been performed. Applicable only for the built-in (first party) containers.
        """
        return pulumi.get(self, "post_analytics_processor_source_uri")

    @post_analytics_processor_source_uri.setter
    def post_analytics_processor_source_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "post_analytics_processor_source_uri", value)

    @property
    @pulumi.getter(name="recordPreprocessorSourceUri")
    def record_preprocessor_source_uri(self) -> Optional[pulumi.Input[str]]:
        """
        An Amazon S3 URI to a script that is called per row prior to running analysis. It can base64 decode the payload and convert it into a flatted json so that the built-in container can use the converted data. Applicable only for the built-in (first party) containers
        """
        return pulumi.get(self, "record_preprocessor_source_uri")

    @record_preprocessor_source_uri.setter
    def record_preprocessor_source_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "record_preprocessor_source_uri", value)


if not MYPY:
    class DataQualityJobDefinitionDataQualityBaselineConfigArgsDict(TypedDict):
        """
        Baseline configuration used to validate that the data conforms to the specified constraints and statistics.
        """
        baselining_job_name: NotRequired[pulumi.Input[str]]
        """
        The name of the job that performs baselining for the data quality monitoring job.
        """
        constraints_resource: NotRequired[pulumi.Input['DataQualityJobDefinitionConstraintsResourceArgsDict']]
        """
        The constraints resource for a monitoring job.
        """
        statistics_resource: NotRequired[pulumi.Input['DataQualityJobDefinitionStatisticsResourceArgsDict']]
        """
        Configuration for monitoring constraints and monitoring statistics. These baseline resources are compared against the results of the current job from the series of jobs scheduled to collect data periodically.
        """
elif False:
    DataQualityJobDefinitionDataQualityBaselineConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataQualityJobDefinitionDataQualityBaselineConfigArgs:
    def __init__(__self__, *,
                 baselining_job_name: Optional[pulumi.Input[str]] = None,
                 constraints_resource: Optional[pulumi.Input['DataQualityJobDefinitionConstraintsResourceArgs']] = None,
                 statistics_resource: Optional[pulumi.Input['DataQualityJobDefinitionStatisticsResourceArgs']] = None):
        """
        Baseline configuration used to validate that the data conforms to the specified constraints and statistics.
        :param pulumi.Input[str] baselining_job_name: The name of the job that performs baselining for the data quality monitoring job.
        :param pulumi.Input['DataQualityJobDefinitionConstraintsResourceArgs'] constraints_resource: The constraints resource for a monitoring job.
        :param pulumi.Input['DataQualityJobDefinitionStatisticsResourceArgs'] statistics_resource: Configuration for monitoring constraints and monitoring statistics. These baseline resources are compared against the results of the current job from the series of jobs scheduled to collect data periodically.
        """
        if baselining_job_name is not None:
            pulumi.set(__self__, "baselining_job_name", baselining_job_name)
        if constraints_resource is not None:
            pulumi.set(__self__, "constraints_resource", constraints_resource)
        if statistics_resource is not None:
            pulumi.set(__self__, "statistics_resource", statistics_resource)

    @property
    @pulumi.getter(name="baseliningJobName")
    def baselining_job_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the job that performs baselining for the data quality monitoring job.
        """
        return pulumi.get(self, "baselining_job_name")

    @baselining_job_name.setter
    def baselining_job_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "baselining_job_name", value)

    @property
    @pulumi.getter(name="constraintsResource")
    def constraints_resource(self) -> Optional[pulumi.Input['DataQualityJobDefinitionConstraintsResourceArgs']]:
        """
        The constraints resource for a monitoring job.
        """
        return pulumi.get(self, "constraints_resource")

    @constraints_resource.setter
    def constraints_resource(self, value: Optional[pulumi.Input['DataQualityJobDefinitionConstraintsResourceArgs']]):
        pulumi.set(self, "constraints_resource", value)

    @property
    @pulumi.getter(name="statisticsResource")
    def statistics_resource(self) -> Optional[pulumi.Input['DataQualityJobDefinitionStatisticsResourceArgs']]:
        """
        Configuration for monitoring constraints and monitoring statistics. These baseline resources are compared against the results of the current job from the series of jobs scheduled to collect data periodically.
        """
        return pulumi.get(self, "statistics_resource")

    @statistics_resource.setter
    def statistics_resource(self, value: Optional[pulumi.Input['DataQualityJobDefinitionStatisticsResourceArgs']]):
        pulumi.set(self, "statistics_resource", value)


if not MYPY:
    class DataQualityJobDefinitionDataQualityJobInputArgsDict(TypedDict):
        """
        The inputs for a monitoring job.
        """
        batch_transform_input: NotRequired[pulumi.Input['DataQualityJobDefinitionBatchTransformInputArgsDict']]
        """
        Input object for the batch transform job.
        """
        endpoint_input: NotRequired[pulumi.Input['DataQualityJobDefinitionEndpointInputArgsDict']]
        """
        Input object for the endpoint
        """
elif False:
    DataQualityJobDefinitionDataQualityJobInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataQualityJobDefinitionDataQualityJobInputArgs:
    def __init__(__self__, *,
                 batch_transform_input: Optional[pulumi.Input['DataQualityJobDefinitionBatchTransformInputArgs']] = None,
                 endpoint_input: Optional[pulumi.Input['DataQualityJobDefinitionEndpointInputArgs']] = None):
        """
        The inputs for a monitoring job.
        :param pulumi.Input['DataQualityJobDefinitionBatchTransformInputArgs'] batch_transform_input: Input object for the batch transform job.
        :param pulumi.Input['DataQualityJobDefinitionEndpointInputArgs'] endpoint_input: Input object for the endpoint
        """
        if batch_transform_input is not None:
            pulumi.set(__self__, "batch_transform_input", batch_transform_input)
        if endpoint_input is not None:
            pulumi.set(__self__, "endpoint_input", endpoint_input)

    @property
    @pulumi.getter(name="batchTransformInput")
    def batch_transform_input(self) -> Optional[pulumi.Input['DataQualityJobDefinitionBatchTransformInputArgs']]:
        """
        Input object for the batch transform job.
        """
        return pulumi.get(self, "batch_transform_input")

    @batch_transform_input.setter
    def batch_transform_input(self, value: Optional[pulumi.Input['DataQualityJobDefinitionBatchTransformInputArgs']]):
        pulumi.set(self, "batch_transform_input", value)

    @property
    @pulumi.getter(name="endpointInput")
    def endpoint_input(self) -> Optional[pulumi.Input['DataQualityJobDefinitionEndpointInputArgs']]:
        """
        Input object for the endpoint
        """
        return pulumi.get(self, "endpoint_input")

    @endpoint_input.setter
    def endpoint_input(self, value: Optional[pulumi.Input['DataQualityJobDefinitionEndpointInputArgs']]):
        pulumi.set(self, "endpoint_input", value)


if not MYPY:
    class DataQualityJobDefinitionDatasetFormatArgsDict(TypedDict):
        """
        The dataset format of the data to monitor
        """
        csv: NotRequired[pulumi.Input['DataQualityJobDefinitionCsvArgsDict']]
        json: NotRequired[pulumi.Input['DataQualityJobDefinitionJsonArgsDict']]
        parquet: NotRequired[pulumi.Input[bool]]
elif False:
    DataQualityJobDefinitionDatasetFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataQualityJobDefinitionDatasetFormatArgs:
    def __init__(__self__, *,
                 csv: Optional[pulumi.Input['DataQualityJobDefinitionCsvArgs']] = None,
                 json: Optional[pulumi.Input['DataQualityJobDefinitionJsonArgs']] = None,
                 parquet: Optional[pulumi.Input[bool]] = None):
        """
        The dataset format of the data to monitor
        """
        if csv is not None:
            pulumi.set(__self__, "csv", csv)
        if json is not None:
            pulumi.set(__self__, "json", json)
        if parquet is not None:
            pulumi.set(__self__, "parquet", parquet)

    @property
    @pulumi.getter
    def csv(self) -> Optional[pulumi.Input['DataQualityJobDefinitionCsvArgs']]:
        return pulumi.get(self, "csv")

    @csv.setter
    def csv(self, value: Optional[pulumi.Input['DataQualityJobDefinitionCsvArgs']]):
        pulumi.set(self, "csv", value)

    @property
    @pulumi.getter
    def json(self) -> Optional[pulumi.Input['DataQualityJobDefinitionJsonArgs']]:
        return pulumi.get(self, "json")

    @json.setter
    def json(self, value: Optional[pulumi.Input['DataQualityJobDefinitionJsonArgs']]):
        pulumi.set(self, "json", value)

    @property
    @pulumi.getter
    def parquet(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "parquet")

    @parquet.setter
    def parquet(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "parquet", value)


if not MYPY:
    class DataQualityJobDefinitionEndpointInputArgsDict(TypedDict):
        """
        The endpoint for a monitoring job.
        """
        endpoint_name: pulumi.Input[str]
        """
        An endpoint in customer's account which has enabled `DataCaptureConfig` enabled.
        """
        local_path: pulumi.Input[str]
        """
        Path to the filesystem where the endpoint data is available to the container.
        """
        exclude_features_attribute: NotRequired[pulumi.Input[str]]
        """
        Indexes or names of the features to be excluded from analysis
        """
        s3_data_distribution_type: NotRequired[pulumi.Input['DataQualityJobDefinitionEndpointInputS3DataDistributionType']]
        """
        Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
        """
        s3_input_mode: NotRequired[pulumi.Input['DataQualityJobDefinitionEndpointInputS3InputMode']]
        """
        Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
        """
elif False:
    DataQualityJobDefinitionEndpointInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataQualityJobDefinitionEndpointInputArgs:
    def __init__(__self__, *,
                 endpoint_name: pulumi.Input[str],
                 local_path: pulumi.Input[str],
                 exclude_features_attribute: Optional[pulumi.Input[str]] = None,
                 s3_data_distribution_type: Optional[pulumi.Input['DataQualityJobDefinitionEndpointInputS3DataDistributionType']] = None,
                 s3_input_mode: Optional[pulumi.Input['DataQualityJobDefinitionEndpointInputS3InputMode']] = None):
        """
        The endpoint for a monitoring job.
        :param pulumi.Input[str] endpoint_name: An endpoint in customer's account which has enabled `DataCaptureConfig` enabled.
        :param pulumi.Input[str] local_path: Path to the filesystem where the endpoint data is available to the container.
        :param pulumi.Input[str] exclude_features_attribute: Indexes or names of the features to be excluded from analysis
        :param pulumi.Input['DataQualityJobDefinitionEndpointInputS3DataDistributionType'] s3_data_distribution_type: Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
        :param pulumi.Input['DataQualityJobDefinitionEndpointInputS3InputMode'] s3_input_mode: Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
        """
        pulumi.set(__self__, "endpoint_name", endpoint_name)
        pulumi.set(__self__, "local_path", local_path)
        if exclude_features_attribute is not None:
            pulumi.set(__self__, "exclude_features_attribute", exclude_features_attribute)
        if s3_data_distribution_type is not None:
            pulumi.set(__self__, "s3_data_distribution_type", s3_data_distribution_type)
        if s3_input_mode is not None:
            pulumi.set(__self__, "s3_input_mode", s3_input_mode)

    @property
    @pulumi.getter(name="endpointName")
    def endpoint_name(self) -> pulumi.Input[str]:
        """
        An endpoint in customer's account which has enabled `DataCaptureConfig` enabled.
        """
        return pulumi.get(self, "endpoint_name")

    @endpoint_name.setter
    def endpoint_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint_name", value)

    @property
    @pulumi.getter(name="localPath")
    def local_path(self) -> pulumi.Input[str]:
        """
        Path to the filesystem where the endpoint data is available to the container.
        """
        return pulumi.get(self, "local_path")

    @local_path.setter
    def local_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "local_path", value)

    @property
    @pulumi.getter(name="excludeFeaturesAttribute")
    def exclude_features_attribute(self) -> Optional[pulumi.Input[str]]:
        """
        Indexes or names of the features to be excluded from analysis
        """
        return pulumi.get(self, "exclude_features_attribute")

    @exclude_features_attribute.setter
    def exclude_features_attribute(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exclude_features_attribute", value)

    @property
    @pulumi.getter(name="s3DataDistributionType")
    def s3_data_distribution_type(self) -> Optional[pulumi.Input['DataQualityJobDefinitionEndpointInputS3DataDistributionType']]:
        """
        Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
        """
        return pulumi.get(self, "s3_data_distribution_type")

    @s3_data_distribution_type.setter
    def s3_data_distribution_type(self, value: Optional[pulumi.Input['DataQualityJobDefinitionEndpointInputS3DataDistributionType']]):
        pulumi.set(self, "s3_data_distribution_type", value)

    @property
    @pulumi.getter(name="s3InputMode")
    def s3_input_mode(self) -> Optional[pulumi.Input['DataQualityJobDefinitionEndpointInputS3InputMode']]:
        """
        Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
        """
        return pulumi.get(self, "s3_input_mode")

    @s3_input_mode.setter
    def s3_input_mode(self, value: Optional[pulumi.Input['DataQualityJobDefinitionEndpointInputS3InputMode']]):
        pulumi.set(self, "s3_input_mode", value)


if not MYPY:
    class DataQualityJobDefinitionJsonArgsDict(TypedDict):
        """
        The Json format
        """
        line: NotRequired[pulumi.Input[bool]]
        """
        A boolean flag indicating if it is JSON line format
        """
elif False:
    DataQualityJobDefinitionJsonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataQualityJobDefinitionJsonArgs:
    def __init__(__self__, *,
                 line: Optional[pulumi.Input[bool]] = None):
        """
        The Json format
        :param pulumi.Input[bool] line: A boolean flag indicating if it is JSON line format
        """
        if line is not None:
            pulumi.set(__self__, "line", line)

    @property
    @pulumi.getter
    def line(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean flag indicating if it is JSON line format
        """
        return pulumi.get(self, "line")

    @line.setter
    def line(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "line", value)


if not MYPY:
    class DataQualityJobDefinitionMonitoringOutputConfigArgsDict(TypedDict):
        """
        The output configuration for monitoring jobs.
        """
        monitoring_outputs: pulumi.Input[Sequence[pulumi.Input['DataQualityJobDefinitionMonitoringOutputArgsDict']]]
        """
        Monitoring outputs for monitoring jobs. This is where the output of the periodic monitoring jobs is uploaded.
        """
        kms_key_id: NotRequired[pulumi.Input[str]]
        """
        The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.
        """
elif False:
    DataQualityJobDefinitionMonitoringOutputConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataQualityJobDefinitionMonitoringOutputConfigArgs:
    def __init__(__self__, *,
                 monitoring_outputs: pulumi.Input[Sequence[pulumi.Input['DataQualityJobDefinitionMonitoringOutputArgs']]],
                 kms_key_id: Optional[pulumi.Input[str]] = None):
        """
        The output configuration for monitoring jobs.
        :param pulumi.Input[Sequence[pulumi.Input['DataQualityJobDefinitionMonitoringOutputArgs']]] monitoring_outputs: Monitoring outputs for monitoring jobs. This is where the output of the periodic monitoring jobs is uploaded.
        :param pulumi.Input[str] kms_key_id: The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.
        """
        pulumi.set(__self__, "monitoring_outputs", monitoring_outputs)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)

    @property
    @pulumi.getter(name="monitoringOutputs")
    def monitoring_outputs(self) -> pulumi.Input[Sequence[pulumi.Input['DataQualityJobDefinitionMonitoringOutputArgs']]]:
        """
        Monitoring outputs for monitoring jobs. This is where the output of the periodic monitoring jobs is uploaded.
        """
        return pulumi.get(self, "monitoring_outputs")

    @monitoring_outputs.setter
    def monitoring_outputs(self, value: pulumi.Input[Sequence[pulumi.Input['DataQualityJobDefinitionMonitoringOutputArgs']]]):
        pulumi.set(self, "monitoring_outputs", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)


if not MYPY:
    class DataQualityJobDefinitionMonitoringOutputArgsDict(TypedDict):
        """
        The output object for a monitoring job.
        """
        s3_output: pulumi.Input['DataQualityJobDefinitionS3OutputArgsDict']
        """
        The Amazon S3 storage location where the results of a monitoring job are saved.
        """
elif False:
    DataQualityJobDefinitionMonitoringOutputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataQualityJobDefinitionMonitoringOutputArgs:
    def __init__(__self__, *,
                 s3_output: pulumi.Input['DataQualityJobDefinitionS3OutputArgs']):
        """
        The output object for a monitoring job.
        :param pulumi.Input['DataQualityJobDefinitionS3OutputArgs'] s3_output: The Amazon S3 storage location where the results of a monitoring job are saved.
        """
        pulumi.set(__self__, "s3_output", s3_output)

    @property
    @pulumi.getter(name="s3Output")
    def s3_output(self) -> pulumi.Input['DataQualityJobDefinitionS3OutputArgs']:
        """
        The Amazon S3 storage location where the results of a monitoring job are saved.
        """
        return pulumi.get(self, "s3_output")

    @s3_output.setter
    def s3_output(self, value: pulumi.Input['DataQualityJobDefinitionS3OutputArgs']):
        pulumi.set(self, "s3_output", value)


if not MYPY:
    class DataQualityJobDefinitionMonitoringResourcesArgsDict(TypedDict):
        """
        Identifies the resources to deploy for a monitoring job.
        """
        cluster_config: pulumi.Input['DataQualityJobDefinitionClusterConfigArgsDict']
        """
        The configuration for the cluster resources used to run the processing job.
        """
elif False:
    DataQualityJobDefinitionMonitoringResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataQualityJobDefinitionMonitoringResourcesArgs:
    def __init__(__self__, *,
                 cluster_config: pulumi.Input['DataQualityJobDefinitionClusterConfigArgs']):
        """
        Identifies the resources to deploy for a monitoring job.
        :param pulumi.Input['DataQualityJobDefinitionClusterConfigArgs'] cluster_config: The configuration for the cluster resources used to run the processing job.
        """
        pulumi.set(__self__, "cluster_config", cluster_config)

    @property
    @pulumi.getter(name="clusterConfig")
    def cluster_config(self) -> pulumi.Input['DataQualityJobDefinitionClusterConfigArgs']:
        """
        The configuration for the cluster resources used to run the processing job.
        """
        return pulumi.get(self, "cluster_config")

    @cluster_config.setter
    def cluster_config(self, value: pulumi.Input['DataQualityJobDefinitionClusterConfigArgs']):
        pulumi.set(self, "cluster_config", value)


if not MYPY:
    class DataQualityJobDefinitionNetworkConfigArgsDict(TypedDict):
        """
        Networking options for a job, such as network traffic encryption between containers, whether to allow inbound and outbound network calls to and from containers, and the VPC subnets and security groups to use for VPC-enabled jobs.
        """
        enable_inter_container_traffic_encryption: NotRequired[pulumi.Input[bool]]
        """
        Whether to encrypt all communications between distributed processing jobs. Choose True to encrypt communications. Encryption provides greater security for distributed processing jobs, but the processing might take longer.
        """
        enable_network_isolation: NotRequired[pulumi.Input[bool]]
        """
        Whether to allow inbound and outbound network calls to and from the containers used for the processing job.
        """
        vpc_config: NotRequired[pulumi.Input['DataQualityJobDefinitionVpcConfigArgsDict']]
        """
        Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC.
        """
elif False:
    DataQualityJobDefinitionNetworkConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataQualityJobDefinitionNetworkConfigArgs:
    def __init__(__self__, *,
                 enable_inter_container_traffic_encryption: Optional[pulumi.Input[bool]] = None,
                 enable_network_isolation: Optional[pulumi.Input[bool]] = None,
                 vpc_config: Optional[pulumi.Input['DataQualityJobDefinitionVpcConfigArgs']] = None):
        """
        Networking options for a job, such as network traffic encryption between containers, whether to allow inbound and outbound network calls to and from containers, and the VPC subnets and security groups to use for VPC-enabled jobs.
        :param pulumi.Input[bool] enable_inter_container_traffic_encryption: Whether to encrypt all communications between distributed processing jobs. Choose True to encrypt communications. Encryption provides greater security for distributed processing jobs, but the processing might take longer.
        :param pulumi.Input[bool] enable_network_isolation: Whether to allow inbound and outbound network calls to and from the containers used for the processing job.
        :param pulumi.Input['DataQualityJobDefinitionVpcConfigArgs'] vpc_config: Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC.
        """
        if enable_inter_container_traffic_encryption is not None:
            pulumi.set(__self__, "enable_inter_container_traffic_encryption", enable_inter_container_traffic_encryption)
        if enable_network_isolation is not None:
            pulumi.set(__self__, "enable_network_isolation", enable_network_isolation)
        if vpc_config is not None:
            pulumi.set(__self__, "vpc_config", vpc_config)

    @property
    @pulumi.getter(name="enableInterContainerTrafficEncryption")
    def enable_inter_container_traffic_encryption(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to encrypt all communications between distributed processing jobs. Choose True to encrypt communications. Encryption provides greater security for distributed processing jobs, but the processing might take longer.
        """
        return pulumi.get(self, "enable_inter_container_traffic_encryption")

    @enable_inter_container_traffic_encryption.setter
    def enable_inter_container_traffic_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_inter_container_traffic_encryption", value)

    @property
    @pulumi.getter(name="enableNetworkIsolation")
    def enable_network_isolation(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to allow inbound and outbound network calls to and from the containers used for the processing job.
        """
        return pulumi.get(self, "enable_network_isolation")

    @enable_network_isolation.setter
    def enable_network_isolation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_network_isolation", value)

    @property
    @pulumi.getter(name="vpcConfig")
    def vpc_config(self) -> Optional[pulumi.Input['DataQualityJobDefinitionVpcConfigArgs']]:
        """
        Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC.
        """
        return pulumi.get(self, "vpc_config")

    @vpc_config.setter
    def vpc_config(self, value: Optional[pulumi.Input['DataQualityJobDefinitionVpcConfigArgs']]):
        pulumi.set(self, "vpc_config", value)


if not MYPY:
    class DataQualityJobDefinitionS3OutputArgsDict(TypedDict):
        """
        Information about where and how to store the results of a monitoring job.
        """
        local_path: pulumi.Input[str]
        """
        The local path to the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job. LocalPath is an absolute path for the output data.
        """
        s3_uri: pulumi.Input[str]
        """
        A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
        """
        s3_upload_mode: NotRequired[pulumi.Input['DataQualityJobDefinitionS3OutputS3UploadMode']]
        """
        Whether to upload the results of the monitoring job continuously or after the job completes.
        """
elif False:
    DataQualityJobDefinitionS3OutputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataQualityJobDefinitionS3OutputArgs:
    def __init__(__self__, *,
                 local_path: pulumi.Input[str],
                 s3_uri: pulumi.Input[str],
                 s3_upload_mode: Optional[pulumi.Input['DataQualityJobDefinitionS3OutputS3UploadMode']] = None):
        """
        Information about where and how to store the results of a monitoring job.
        :param pulumi.Input[str] local_path: The local path to the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job. LocalPath is an absolute path for the output data.
        :param pulumi.Input[str] s3_uri: A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
        :param pulumi.Input['DataQualityJobDefinitionS3OutputS3UploadMode'] s3_upload_mode: Whether to upload the results of the monitoring job continuously or after the job completes.
        """
        pulumi.set(__self__, "local_path", local_path)
        pulumi.set(__self__, "s3_uri", s3_uri)
        if s3_upload_mode is not None:
            pulumi.set(__self__, "s3_upload_mode", s3_upload_mode)

    @property
    @pulumi.getter(name="localPath")
    def local_path(self) -> pulumi.Input[str]:
        """
        The local path to the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job. LocalPath is an absolute path for the output data.
        """
        return pulumi.get(self, "local_path")

    @local_path.setter
    def local_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "local_path", value)

    @property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> pulumi.Input[str]:
        """
        A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
        """
        return pulumi.get(self, "s3_uri")

    @s3_uri.setter
    def s3_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_uri", value)

    @property
    @pulumi.getter(name="s3UploadMode")
    def s3_upload_mode(self) -> Optional[pulumi.Input['DataQualityJobDefinitionS3OutputS3UploadMode']]:
        """
        Whether to upload the results of the monitoring job continuously or after the job completes.
        """
        return pulumi.get(self, "s3_upload_mode")

    @s3_upload_mode.setter
    def s3_upload_mode(self, value: Optional[pulumi.Input['DataQualityJobDefinitionS3OutputS3UploadMode']]):
        pulumi.set(self, "s3_upload_mode", value)


if not MYPY:
    class DataQualityJobDefinitionStatisticsResourceArgsDict(TypedDict):
        """
        The baseline statistics resource for a monitoring job.
        """
        s3_uri: NotRequired[pulumi.Input[str]]
        """
        The Amazon S3 URI for the baseline statistics file in Amazon S3 that the current monitoring job should be validated against.
        """
elif False:
    DataQualityJobDefinitionStatisticsResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataQualityJobDefinitionStatisticsResourceArgs:
    def __init__(__self__, *,
                 s3_uri: Optional[pulumi.Input[str]] = None):
        """
        The baseline statistics resource for a monitoring job.
        :param pulumi.Input[str] s3_uri: The Amazon S3 URI for the baseline statistics file in Amazon S3 that the current monitoring job should be validated against.
        """
        if s3_uri is not None:
            pulumi.set(__self__, "s3_uri", s3_uri)

    @property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon S3 URI for the baseline statistics file in Amazon S3 that the current monitoring job should be validated against.
        """
        return pulumi.get(self, "s3_uri")

    @s3_uri.setter
    def s3_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_uri", value)


if not MYPY:
    class DataQualityJobDefinitionStoppingConditionArgsDict(TypedDict):
        """
        Specifies a time limit for how long the monitoring job is allowed to run.
        """
        max_runtime_in_seconds: pulumi.Input[int]
        """
        The maximum runtime allowed in seconds.
        """
elif False:
    DataQualityJobDefinitionStoppingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataQualityJobDefinitionStoppingConditionArgs:
    def __init__(__self__, *,
                 max_runtime_in_seconds: pulumi.Input[int]):
        """
        Specifies a time limit for how long the monitoring job is allowed to run.
        :param pulumi.Input[int] max_runtime_in_seconds: The maximum runtime allowed in seconds.
        """
        pulumi.set(__self__, "max_runtime_in_seconds", max_runtime_in_seconds)

    @property
    @pulumi.getter(name="maxRuntimeInSeconds")
    def max_runtime_in_seconds(self) -> pulumi.Input[int]:
        """
        The maximum runtime allowed in seconds.
        """
        return pulumi.get(self, "max_runtime_in_seconds")

    @max_runtime_in_seconds.setter
    def max_runtime_in_seconds(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_runtime_in_seconds", value)


if not MYPY:
    class DataQualityJobDefinitionVpcConfigArgsDict(TypedDict):
        """
        Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC.
        """
        security_group_ids: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the Subnets field.
        """
        subnets: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The ID of the subnets in the VPC to which you want to connect to your monitoring jobs.
        """
elif False:
    DataQualityJobDefinitionVpcConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataQualityJobDefinitionVpcConfigArgs:
    def __init__(__self__, *,
                 security_group_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 subnets: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_group_ids: The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the Subnets field.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subnets: The ID of the subnets in the VPC to which you want to connect to your monitoring jobs.
        """
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnets", subnets)

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the Subnets field.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "security_group_ids", value)

    @property
    @pulumi.getter
    def subnets(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The ID of the subnets in the VPC to which you want to connect to your monitoring jobs.
        """
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "subnets", value)


if not MYPY:
    class DeviceFleetEdgeOutputConfigArgsDict(TypedDict):
        s3_output_location: pulumi.Input[str]
        """
        The Amazon Simple Storage (S3) bucket URI
        """
        kms_key_id: NotRequired[pulumi.Input[str]]
        """
        The KMS key id used for encryption on the S3 bucket
        """
elif False:
    DeviceFleetEdgeOutputConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceFleetEdgeOutputConfigArgs:
    def __init__(__self__, *,
                 s3_output_location: pulumi.Input[str],
                 kms_key_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] s3_output_location: The Amazon Simple Storage (S3) bucket URI
        :param pulumi.Input[str] kms_key_id: The KMS key id used for encryption on the S3 bucket
        """
        pulumi.set(__self__, "s3_output_location", s3_output_location)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)

    @property
    @pulumi.getter(name="s3OutputLocation")
    def s3_output_location(self) -> pulumi.Input[str]:
        """
        The Amazon Simple Storage (S3) bucket URI
        """
        return pulumi.get(self, "s3_output_location")

    @s3_output_location.setter
    def s3_output_location(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_output_location", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The KMS key id used for encryption on the S3 bucket
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)


if not MYPY:
    class DeviceArgsDict(TypedDict):
        """
        Edge device you want to create
        """
        device_name: pulumi.Input[str]
        """
        The name of the device
        """
        description: NotRequired[pulumi.Input[str]]
        """
        Description of the device
        """
        iot_thing_name: NotRequired[pulumi.Input[str]]
        """
        AWS Internet of Things (IoT) object name.
        """
elif False:
    DeviceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeviceArgs:
    def __init__(__self__, *,
                 device_name: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 iot_thing_name: Optional[pulumi.Input[str]] = None):
        """
        Edge device you want to create
        :param pulumi.Input[str] device_name: The name of the device
        :param pulumi.Input[str] description: Description of the device
        :param pulumi.Input[str] iot_thing_name: AWS Internet of Things (IoT) object name.
        """
        pulumi.set(__self__, "device_name", device_name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if iot_thing_name is not None:
            pulumi.set(__self__, "iot_thing_name", iot_thing_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> pulumi.Input[str]:
        """
        The name of the device
        """
        return pulumi.get(self, "device_name")

    @device_name.setter
    def device_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "device_name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of the device
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="iotThingName")
    def iot_thing_name(self) -> Optional[pulumi.Input[str]]:
        """
        AWS Internet of Things (IoT) object name.
        """
        return pulumi.get(self, "iot_thing_name")

    @iot_thing_name.setter
    def iot_thing_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "iot_thing_name", value)


if not MYPY:
    class DomainAppLifecycleManagementArgsDict(TypedDict):
        idle_settings: NotRequired[pulumi.Input['DomainIdleSettingsArgsDict']]
        """
        Settings related to idle shutdown of Studio applications.
        """
elif False:
    DomainAppLifecycleManagementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainAppLifecycleManagementArgs:
    def __init__(__self__, *,
                 idle_settings: Optional[pulumi.Input['DomainIdleSettingsArgs']] = None):
        """
        :param pulumi.Input['DomainIdleSettingsArgs'] idle_settings: Settings related to idle shutdown of Studio applications.
        """
        if idle_settings is not None:
            pulumi.set(__self__, "idle_settings", idle_settings)

    @property
    @pulumi.getter(name="idleSettings")
    def idle_settings(self) -> Optional[pulumi.Input['DomainIdleSettingsArgs']]:
        """
        Settings related to idle shutdown of Studio applications.
        """
        return pulumi.get(self, "idle_settings")

    @idle_settings.setter
    def idle_settings(self, value: Optional[pulumi.Input['DomainIdleSettingsArgs']]):
        pulumi.set(self, "idle_settings", value)


if not MYPY:
    class DomainCodeEditorAppSettingsArgsDict(TypedDict):
        """
        The CodeEditor app settings.
        """
        app_lifecycle_management: NotRequired[pulumi.Input['DomainAppLifecycleManagementArgsDict']]
        """
        Settings that are used to configure and manage the lifecycle of CodeEditor applications.
        """
        custom_images: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainCustomImageArgsDict']]]]
        """
        A list of custom images for use for CodeEditor apps.
        """
        default_resource_spec: NotRequired[pulumi.Input['DomainResourceSpecArgsDict']]
        """
        The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the CodeEditor app.
        """
        lifecycle_config_arns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of LifecycleConfigArns available for use with CodeEditor apps.
        """
elif False:
    DomainCodeEditorAppSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainCodeEditorAppSettingsArgs:
    def __init__(__self__, *,
                 app_lifecycle_management: Optional[pulumi.Input['DomainAppLifecycleManagementArgs']] = None,
                 custom_images: Optional[pulumi.Input[Sequence[pulumi.Input['DomainCustomImageArgs']]]] = None,
                 default_resource_spec: Optional[pulumi.Input['DomainResourceSpecArgs']] = None,
                 lifecycle_config_arns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The CodeEditor app settings.
        :param pulumi.Input['DomainAppLifecycleManagementArgs'] app_lifecycle_management: Settings that are used to configure and manage the lifecycle of CodeEditor applications.
        :param pulumi.Input[Sequence[pulumi.Input['DomainCustomImageArgs']]] custom_images: A list of custom images for use for CodeEditor apps.
        :param pulumi.Input['DomainResourceSpecArgs'] default_resource_spec: The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the CodeEditor app.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] lifecycle_config_arns: A list of LifecycleConfigArns available for use with CodeEditor apps.
        """
        if app_lifecycle_management is not None:
            pulumi.set(__self__, "app_lifecycle_management", app_lifecycle_management)
        if custom_images is not None:
            pulumi.set(__self__, "custom_images", custom_images)
        if default_resource_spec is not None:
            pulumi.set(__self__, "default_resource_spec", default_resource_spec)
        if lifecycle_config_arns is not None:
            pulumi.set(__self__, "lifecycle_config_arns", lifecycle_config_arns)

    @property
    @pulumi.getter(name="appLifecycleManagement")
    def app_lifecycle_management(self) -> Optional[pulumi.Input['DomainAppLifecycleManagementArgs']]:
        """
        Settings that are used to configure and manage the lifecycle of CodeEditor applications.
        """
        return pulumi.get(self, "app_lifecycle_management")

    @app_lifecycle_management.setter
    def app_lifecycle_management(self, value: Optional[pulumi.Input['DomainAppLifecycleManagementArgs']]):
        pulumi.set(self, "app_lifecycle_management", value)

    @property
    @pulumi.getter(name="customImages")
    def custom_images(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainCustomImageArgs']]]]:
        """
        A list of custom images for use for CodeEditor apps.
        """
        return pulumi.get(self, "custom_images")

    @custom_images.setter
    def custom_images(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainCustomImageArgs']]]]):
        pulumi.set(self, "custom_images", value)

    @property
    @pulumi.getter(name="defaultResourceSpec")
    def default_resource_spec(self) -> Optional[pulumi.Input['DomainResourceSpecArgs']]:
        """
        The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the CodeEditor app.
        """
        return pulumi.get(self, "default_resource_spec")

    @default_resource_spec.setter
    def default_resource_spec(self, value: Optional[pulumi.Input['DomainResourceSpecArgs']]):
        pulumi.set(self, "default_resource_spec", value)

    @property
    @pulumi.getter(name="lifecycleConfigArns")
    def lifecycle_config_arns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of LifecycleConfigArns available for use with CodeEditor apps.
        """
        return pulumi.get(self, "lifecycle_config_arns")

    @lifecycle_config_arns.setter
    def lifecycle_config_arns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "lifecycle_config_arns", value)


if not MYPY:
    class DomainCodeRepositoryArgsDict(TypedDict):
        repository_url: pulumi.Input[str]
        """
        A CodeRepository (valid URL) to be used within Jupyter's Git extension.
        """
elif False:
    DomainCodeRepositoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainCodeRepositoryArgs:
    def __init__(__self__, *,
                 repository_url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] repository_url: A CodeRepository (valid URL) to be used within Jupyter's Git extension.
        """
        pulumi.set(__self__, "repository_url", repository_url)

    @property
    @pulumi.getter(name="repositoryUrl")
    def repository_url(self) -> pulumi.Input[str]:
        """
        A CodeRepository (valid URL) to be used within Jupyter's Git extension.
        """
        return pulumi.get(self, "repository_url")

    @repository_url.setter
    def repository_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "repository_url", value)


if not MYPY:
    class DomainCustomFileSystemConfigArgsDict(TypedDict):
        efs_file_system_config: NotRequired[pulumi.Input['DomainEfsFileSystemConfigArgsDict']]
        """
        The settings for a custom Amazon EFS file system.
        """
elif False:
    DomainCustomFileSystemConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainCustomFileSystemConfigArgs:
    def __init__(__self__, *,
                 efs_file_system_config: Optional[pulumi.Input['DomainEfsFileSystemConfigArgs']] = None):
        """
        :param pulumi.Input['DomainEfsFileSystemConfigArgs'] efs_file_system_config: The settings for a custom Amazon EFS file system.
        """
        if efs_file_system_config is not None:
            pulumi.set(__self__, "efs_file_system_config", efs_file_system_config)

    @property
    @pulumi.getter(name="efsFileSystemConfig")
    def efs_file_system_config(self) -> Optional[pulumi.Input['DomainEfsFileSystemConfigArgs']]:
        """
        The settings for a custom Amazon EFS file system.
        """
        return pulumi.get(self, "efs_file_system_config")

    @efs_file_system_config.setter
    def efs_file_system_config(self, value: Optional[pulumi.Input['DomainEfsFileSystemConfigArgs']]):
        pulumi.set(self, "efs_file_system_config", value)


if not MYPY:
    class DomainCustomImageArgsDict(TypedDict):
        """
        A custom SageMaker image.
        """
        app_image_config_name: pulumi.Input[str]
        """
        The Name of the AppImageConfig.
        """
        image_name: pulumi.Input[str]
        """
        The name of the CustomImage. Must be unique to your account.
        """
        image_version_number: NotRequired[pulumi.Input[int]]
        """
        The version number of the CustomImage.
        """
elif False:
    DomainCustomImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainCustomImageArgs:
    def __init__(__self__, *,
                 app_image_config_name: pulumi.Input[str],
                 image_name: pulumi.Input[str],
                 image_version_number: Optional[pulumi.Input[int]] = None):
        """
        A custom SageMaker image.
        :param pulumi.Input[str] app_image_config_name: The Name of the AppImageConfig.
        :param pulumi.Input[str] image_name: The name of the CustomImage. Must be unique to your account.
        :param pulumi.Input[int] image_version_number: The version number of the CustomImage.
        """
        pulumi.set(__self__, "app_image_config_name", app_image_config_name)
        pulumi.set(__self__, "image_name", image_name)
        if image_version_number is not None:
            pulumi.set(__self__, "image_version_number", image_version_number)

    @property
    @pulumi.getter(name="appImageConfigName")
    def app_image_config_name(self) -> pulumi.Input[str]:
        """
        The Name of the AppImageConfig.
        """
        return pulumi.get(self, "app_image_config_name")

    @app_image_config_name.setter
    def app_image_config_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_image_config_name", value)

    @property
    @pulumi.getter(name="imageName")
    def image_name(self) -> pulumi.Input[str]:
        """
        The name of the CustomImage. Must be unique to your account.
        """
        return pulumi.get(self, "image_name")

    @image_name.setter
    def image_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "image_name", value)

    @property
    @pulumi.getter(name="imageVersionNumber")
    def image_version_number(self) -> Optional[pulumi.Input[int]]:
        """
        The version number of the CustomImage.
        """
        return pulumi.get(self, "image_version_number")

    @image_version_number.setter
    def image_version_number(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "image_version_number", value)


if not MYPY:
    class DomainCustomPosixUserConfigArgsDict(TypedDict):
        gid: pulumi.Input[int]
        """
        The POSIX group ID.
        """
        uid: pulumi.Input[int]
        """
        The POSIX user ID.
        """
elif False:
    DomainCustomPosixUserConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainCustomPosixUserConfigArgs:
    def __init__(__self__, *,
                 gid: pulumi.Input[int],
                 uid: pulumi.Input[int]):
        """
        :param pulumi.Input[int] gid: The POSIX group ID.
        :param pulumi.Input[int] uid: The POSIX user ID.
        """
        pulumi.set(__self__, "gid", gid)
        pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def gid(self) -> pulumi.Input[int]:
        """
        The POSIX group ID.
        """
        return pulumi.get(self, "gid")

    @gid.setter
    def gid(self, value: pulumi.Input[int]):
        pulumi.set(self, "gid", value)

    @property
    @pulumi.getter
    def uid(self) -> pulumi.Input[int]:
        """
        The POSIX user ID.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: pulumi.Input[int]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class DomainDefaultEbsStorageSettingsArgsDict(TypedDict):
        """
        Properties related to the Amazon Elastic Block Store volume. Must be provided if storage type is Amazon EBS and must not be provided if storage type is not Amazon EBS
        """
        default_ebs_volume_size_in_gb: pulumi.Input[int]
        """
        Default size of the Amazon EBS volume in Gb
        """
        maximum_ebs_volume_size_in_gb: pulumi.Input[int]
        """
        Maximum size of the Amazon EBS volume in Gb. Must be greater than or equal to the DefaultEbsVolumeSizeInGb.
        """
elif False:
    DomainDefaultEbsStorageSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainDefaultEbsStorageSettingsArgs:
    def __init__(__self__, *,
                 default_ebs_volume_size_in_gb: pulumi.Input[int],
                 maximum_ebs_volume_size_in_gb: pulumi.Input[int]):
        """
        Properties related to the Amazon Elastic Block Store volume. Must be provided if storage type is Amazon EBS and must not be provided if storage type is not Amazon EBS
        :param pulumi.Input[int] default_ebs_volume_size_in_gb: Default size of the Amazon EBS volume in Gb
        :param pulumi.Input[int] maximum_ebs_volume_size_in_gb: Maximum size of the Amazon EBS volume in Gb. Must be greater than or equal to the DefaultEbsVolumeSizeInGb.
        """
        pulumi.set(__self__, "default_ebs_volume_size_in_gb", default_ebs_volume_size_in_gb)
        pulumi.set(__self__, "maximum_ebs_volume_size_in_gb", maximum_ebs_volume_size_in_gb)

    @property
    @pulumi.getter(name="defaultEbsVolumeSizeInGb")
    def default_ebs_volume_size_in_gb(self) -> pulumi.Input[int]:
        """
        Default size of the Amazon EBS volume in Gb
        """
        return pulumi.get(self, "default_ebs_volume_size_in_gb")

    @default_ebs_volume_size_in_gb.setter
    def default_ebs_volume_size_in_gb(self, value: pulumi.Input[int]):
        pulumi.set(self, "default_ebs_volume_size_in_gb", value)

    @property
    @pulumi.getter(name="maximumEbsVolumeSizeInGb")
    def maximum_ebs_volume_size_in_gb(self) -> pulumi.Input[int]:
        """
        Maximum size of the Amazon EBS volume in Gb. Must be greater than or equal to the DefaultEbsVolumeSizeInGb.
        """
        return pulumi.get(self, "maximum_ebs_volume_size_in_gb")

    @maximum_ebs_volume_size_in_gb.setter
    def maximum_ebs_volume_size_in_gb(self, value: pulumi.Input[int]):
        pulumi.set(self, "maximum_ebs_volume_size_in_gb", value)


if not MYPY:
    class DomainDefaultSpaceSettingsArgsDict(TypedDict):
        """
        A collection of settings that apply to spaces of Amazon SageMaker Studio. These settings are specified when the Create/Update Domain API is called.
        """
        execution_role: pulumi.Input[str]
        """
        The execution role for the space.
        """
        custom_file_system_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainCustomFileSystemConfigArgsDict']]]]
        """
        The settings for assigning a custom file system to a domain. Permitted users can access this file system in Amazon SageMaker Studio.
        """
        custom_posix_user_config: NotRequired[pulumi.Input['DomainCustomPosixUserConfigArgsDict']]
        """
        The Jupyter lab's custom posix user configurations.
        """
        jupyter_lab_app_settings: NotRequired[pulumi.Input['DomainJupyterLabAppSettingsArgsDict']]
        """
        The Jupyter lab's app settings.
        """
        jupyter_server_app_settings: NotRequired[pulumi.Input['DomainJupyterServerAppSettingsArgsDict']]
        """
        The Jupyter server's app settings.
        """
        kernel_gateway_app_settings: NotRequired[pulumi.Input['DomainKernelGatewayAppSettingsArgsDict']]
        """
        The kernel gateway app settings.
        """
        security_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The security groups for the Amazon Virtual Private Cloud (VPC) that Studio uses for communication.
        """
        space_storage_settings: NotRequired[pulumi.Input['DomainDefaultSpaceStorageSettingsArgsDict']]
        """
        The Jupyter lab's space storage settings.
        """
elif False:
    DomainDefaultSpaceSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainDefaultSpaceSettingsArgs:
    def __init__(__self__, *,
                 execution_role: pulumi.Input[str],
                 custom_file_system_configs: Optional[pulumi.Input[Sequence[pulumi.Input['DomainCustomFileSystemConfigArgs']]]] = None,
                 custom_posix_user_config: Optional[pulumi.Input['DomainCustomPosixUserConfigArgs']] = None,
                 jupyter_lab_app_settings: Optional[pulumi.Input['DomainJupyterLabAppSettingsArgs']] = None,
                 jupyter_server_app_settings: Optional[pulumi.Input['DomainJupyterServerAppSettingsArgs']] = None,
                 kernel_gateway_app_settings: Optional[pulumi.Input['DomainKernelGatewayAppSettingsArgs']] = None,
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 space_storage_settings: Optional[pulumi.Input['DomainDefaultSpaceStorageSettingsArgs']] = None):
        """
        A collection of settings that apply to spaces of Amazon SageMaker Studio. These settings are specified when the Create/Update Domain API is called.
        :param pulumi.Input[str] execution_role: The execution role for the space.
        :param pulumi.Input[Sequence[pulumi.Input['DomainCustomFileSystemConfigArgs']]] custom_file_system_configs: The settings for assigning a custom file system to a domain. Permitted users can access this file system in Amazon SageMaker Studio.
        :param pulumi.Input['DomainCustomPosixUserConfigArgs'] custom_posix_user_config: The Jupyter lab's custom posix user configurations.
        :param pulumi.Input['DomainJupyterLabAppSettingsArgs'] jupyter_lab_app_settings: The Jupyter lab's app settings.
        :param pulumi.Input['DomainJupyterServerAppSettingsArgs'] jupyter_server_app_settings: The Jupyter server's app settings.
        :param pulumi.Input['DomainKernelGatewayAppSettingsArgs'] kernel_gateway_app_settings: The kernel gateway app settings.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_groups: The security groups for the Amazon Virtual Private Cloud (VPC) that Studio uses for communication.
        :param pulumi.Input['DomainDefaultSpaceStorageSettingsArgs'] space_storage_settings: The Jupyter lab's space storage settings.
        """
        pulumi.set(__self__, "execution_role", execution_role)
        if custom_file_system_configs is not None:
            pulumi.set(__self__, "custom_file_system_configs", custom_file_system_configs)
        if custom_posix_user_config is not None:
            pulumi.set(__self__, "custom_posix_user_config", custom_posix_user_config)
        if jupyter_lab_app_settings is not None:
            pulumi.set(__self__, "jupyter_lab_app_settings", jupyter_lab_app_settings)
        if jupyter_server_app_settings is not None:
            pulumi.set(__self__, "jupyter_server_app_settings", jupyter_server_app_settings)
        if kernel_gateway_app_settings is not None:
            pulumi.set(__self__, "kernel_gateway_app_settings", kernel_gateway_app_settings)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if space_storage_settings is not None:
            pulumi.set(__self__, "space_storage_settings", space_storage_settings)

    @property
    @pulumi.getter(name="executionRole")
    def execution_role(self) -> pulumi.Input[str]:
        """
        The execution role for the space.
        """
        return pulumi.get(self, "execution_role")

    @execution_role.setter
    def execution_role(self, value: pulumi.Input[str]):
        pulumi.set(self, "execution_role", value)

    @property
    @pulumi.getter(name="customFileSystemConfigs")
    def custom_file_system_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainCustomFileSystemConfigArgs']]]]:
        """
        The settings for assigning a custom file system to a domain. Permitted users can access this file system in Amazon SageMaker Studio.
        """
        return pulumi.get(self, "custom_file_system_configs")

    @custom_file_system_configs.setter
    def custom_file_system_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainCustomFileSystemConfigArgs']]]]):
        pulumi.set(self, "custom_file_system_configs", value)

    @property
    @pulumi.getter(name="customPosixUserConfig")
    def custom_posix_user_config(self) -> Optional[pulumi.Input['DomainCustomPosixUserConfigArgs']]:
        """
        The Jupyter lab's custom posix user configurations.
        """
        return pulumi.get(self, "custom_posix_user_config")

    @custom_posix_user_config.setter
    def custom_posix_user_config(self, value: Optional[pulumi.Input['DomainCustomPosixUserConfigArgs']]):
        pulumi.set(self, "custom_posix_user_config", value)

    @property
    @pulumi.getter(name="jupyterLabAppSettings")
    def jupyter_lab_app_settings(self) -> Optional[pulumi.Input['DomainJupyterLabAppSettingsArgs']]:
        """
        The Jupyter lab's app settings.
        """
        return pulumi.get(self, "jupyter_lab_app_settings")

    @jupyter_lab_app_settings.setter
    def jupyter_lab_app_settings(self, value: Optional[pulumi.Input['DomainJupyterLabAppSettingsArgs']]):
        pulumi.set(self, "jupyter_lab_app_settings", value)

    @property
    @pulumi.getter(name="jupyterServerAppSettings")
    def jupyter_server_app_settings(self) -> Optional[pulumi.Input['DomainJupyterServerAppSettingsArgs']]:
        """
        The Jupyter server's app settings.
        """
        return pulumi.get(self, "jupyter_server_app_settings")

    @jupyter_server_app_settings.setter
    def jupyter_server_app_settings(self, value: Optional[pulumi.Input['DomainJupyterServerAppSettingsArgs']]):
        pulumi.set(self, "jupyter_server_app_settings", value)

    @property
    @pulumi.getter(name="kernelGatewayAppSettings")
    def kernel_gateway_app_settings(self) -> Optional[pulumi.Input['DomainKernelGatewayAppSettingsArgs']]:
        """
        The kernel gateway app settings.
        """
        return pulumi.get(self, "kernel_gateway_app_settings")

    @kernel_gateway_app_settings.setter
    def kernel_gateway_app_settings(self, value: Optional[pulumi.Input['DomainKernelGatewayAppSettingsArgs']]):
        pulumi.set(self, "kernel_gateway_app_settings", value)

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The security groups for the Amazon Virtual Private Cloud (VPC) that Studio uses for communication.
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_groups", value)

    @property
    @pulumi.getter(name="spaceStorageSettings")
    def space_storage_settings(self) -> Optional[pulumi.Input['DomainDefaultSpaceStorageSettingsArgs']]:
        """
        The Jupyter lab's space storage settings.
        """
        return pulumi.get(self, "space_storage_settings")

    @space_storage_settings.setter
    def space_storage_settings(self, value: Optional[pulumi.Input['DomainDefaultSpaceStorageSettingsArgs']]):
        pulumi.set(self, "space_storage_settings", value)


if not MYPY:
    class DomainDefaultSpaceStorageSettingsArgsDict(TypedDict):
        """
        Default storage settings for a space.
        """
        default_ebs_storage_settings: NotRequired[pulumi.Input['DomainDefaultEbsStorageSettingsArgsDict']]
        """
        The default EBS storage settings for a space.
        """
elif False:
    DomainDefaultSpaceStorageSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainDefaultSpaceStorageSettingsArgs:
    def __init__(__self__, *,
                 default_ebs_storage_settings: Optional[pulumi.Input['DomainDefaultEbsStorageSettingsArgs']] = None):
        """
        Default storage settings for a space.
        :param pulumi.Input['DomainDefaultEbsStorageSettingsArgs'] default_ebs_storage_settings: The default EBS storage settings for a space.
        """
        if default_ebs_storage_settings is not None:
            pulumi.set(__self__, "default_ebs_storage_settings", default_ebs_storage_settings)

    @property
    @pulumi.getter(name="defaultEbsStorageSettings")
    def default_ebs_storage_settings(self) -> Optional[pulumi.Input['DomainDefaultEbsStorageSettingsArgs']]:
        """
        The default EBS storage settings for a space.
        """
        return pulumi.get(self, "default_ebs_storage_settings")

    @default_ebs_storage_settings.setter
    def default_ebs_storage_settings(self, value: Optional[pulumi.Input['DomainDefaultEbsStorageSettingsArgs']]):
        pulumi.set(self, "default_ebs_storage_settings", value)


if not MYPY:
    class DomainDockerSettingsArgsDict(TypedDict):
        """
        A collection of settings that are required to start docker-proxy server.
        """
        enable_docker_access: NotRequired[pulumi.Input['DomainDockerSettingsEnableDockerAccess']]
        """
        The flag to enable/disable docker-proxy server
        """
        vpc_only_trusted_accounts: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of account id's that would be used to pull images from in VpcOnly mode
        """
elif False:
    DomainDockerSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainDockerSettingsArgs:
    def __init__(__self__, *,
                 enable_docker_access: Optional[pulumi.Input['DomainDockerSettingsEnableDockerAccess']] = None,
                 vpc_only_trusted_accounts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        A collection of settings that are required to start docker-proxy server.
        :param pulumi.Input['DomainDockerSettingsEnableDockerAccess'] enable_docker_access: The flag to enable/disable docker-proxy server
        :param pulumi.Input[Sequence[pulumi.Input[str]]] vpc_only_trusted_accounts: A list of account id's that would be used to pull images from in VpcOnly mode
        """
        if enable_docker_access is not None:
            pulumi.set(__self__, "enable_docker_access", enable_docker_access)
        if vpc_only_trusted_accounts is not None:
            pulumi.set(__self__, "vpc_only_trusted_accounts", vpc_only_trusted_accounts)

    @property
    @pulumi.getter(name="enableDockerAccess")
    def enable_docker_access(self) -> Optional[pulumi.Input['DomainDockerSettingsEnableDockerAccess']]:
        """
        The flag to enable/disable docker-proxy server
        """
        return pulumi.get(self, "enable_docker_access")

    @enable_docker_access.setter
    def enable_docker_access(self, value: Optional[pulumi.Input['DomainDockerSettingsEnableDockerAccess']]):
        pulumi.set(self, "enable_docker_access", value)

    @property
    @pulumi.getter(name="vpcOnlyTrustedAccounts")
    def vpc_only_trusted_accounts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of account id's that would be used to pull images from in VpcOnly mode
        """
        return pulumi.get(self, "vpc_only_trusted_accounts")

    @vpc_only_trusted_accounts.setter
    def vpc_only_trusted_accounts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "vpc_only_trusted_accounts", value)


if not MYPY:
    class DomainEfsFileSystemConfigArgsDict(TypedDict):
        file_system_id: pulumi.Input[str]
        """
        The ID of your Amazon EFS file system.
        """
        file_system_path: NotRequired[pulumi.Input[str]]
        """
        The path to the file system directory that is accessible in Amazon SageMaker Studio. Permitted users can access only this directory and below.
        """
elif False:
    DomainEfsFileSystemConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainEfsFileSystemConfigArgs:
    def __init__(__self__, *,
                 file_system_id: pulumi.Input[str],
                 file_system_path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] file_system_id: The ID of your Amazon EFS file system.
        :param pulumi.Input[str] file_system_path: The path to the file system directory that is accessible in Amazon SageMaker Studio. Permitted users can access only this directory and below.
        """
        pulumi.set(__self__, "file_system_id", file_system_id)
        if file_system_path is not None:
            pulumi.set(__self__, "file_system_path", file_system_path)

    @property
    @pulumi.getter(name="fileSystemId")
    def file_system_id(self) -> pulumi.Input[str]:
        """
        The ID of your Amazon EFS file system.
        """
        return pulumi.get(self, "file_system_id")

    @file_system_id.setter
    def file_system_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "file_system_id", value)

    @property
    @pulumi.getter(name="fileSystemPath")
    def file_system_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the file system directory that is accessible in Amazon SageMaker Studio. Permitted users can access only this directory and below.
        """
        return pulumi.get(self, "file_system_path")

    @file_system_path.setter
    def file_system_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_system_path", value)


if not MYPY:
    class DomainIdleSettingsArgsDict(TypedDict):
        idle_timeout_in_minutes: NotRequired[pulumi.Input[int]]
        """
        The time that SageMaker waits after the application becomes idle before shutting it down.
        """
        lifecycle_management: NotRequired[pulumi.Input['DomainLifecycleManagement']]
        """
        Indicates whether idle shutdown is activated for the application type.
        """
        max_idle_timeout_in_minutes: NotRequired[pulumi.Input[int]]
        """
        The maximum value in minutes that custom idle shutdown can be set to by the user.
        """
        min_idle_timeout_in_minutes: NotRequired[pulumi.Input[int]]
        """
        The minimum value in minutes that custom idle shutdown can be set to by the user.
        """
elif False:
    DomainIdleSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainIdleSettingsArgs:
    def __init__(__self__, *,
                 idle_timeout_in_minutes: Optional[pulumi.Input[int]] = None,
                 lifecycle_management: Optional[pulumi.Input['DomainLifecycleManagement']] = None,
                 max_idle_timeout_in_minutes: Optional[pulumi.Input[int]] = None,
                 min_idle_timeout_in_minutes: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] idle_timeout_in_minutes: The time that SageMaker waits after the application becomes idle before shutting it down.
        :param pulumi.Input['DomainLifecycleManagement'] lifecycle_management: Indicates whether idle shutdown is activated for the application type.
        :param pulumi.Input[int] max_idle_timeout_in_minutes: The maximum value in minutes that custom idle shutdown can be set to by the user.
        :param pulumi.Input[int] min_idle_timeout_in_minutes: The minimum value in minutes that custom idle shutdown can be set to by the user.
        """
        if idle_timeout_in_minutes is not None:
            pulumi.set(__self__, "idle_timeout_in_minutes", idle_timeout_in_minutes)
        if lifecycle_management is not None:
            pulumi.set(__self__, "lifecycle_management", lifecycle_management)
        if max_idle_timeout_in_minutes is not None:
            pulumi.set(__self__, "max_idle_timeout_in_minutes", max_idle_timeout_in_minutes)
        if min_idle_timeout_in_minutes is not None:
            pulumi.set(__self__, "min_idle_timeout_in_minutes", min_idle_timeout_in_minutes)

    @property
    @pulumi.getter(name="idleTimeoutInMinutes")
    def idle_timeout_in_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        The time that SageMaker waits after the application becomes idle before shutting it down.
        """
        return pulumi.get(self, "idle_timeout_in_minutes")

    @idle_timeout_in_minutes.setter
    def idle_timeout_in_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "idle_timeout_in_minutes", value)

    @property
    @pulumi.getter(name="lifecycleManagement")
    def lifecycle_management(self) -> Optional[pulumi.Input['DomainLifecycleManagement']]:
        """
        Indicates whether idle shutdown is activated for the application type.
        """
        return pulumi.get(self, "lifecycle_management")

    @lifecycle_management.setter
    def lifecycle_management(self, value: Optional[pulumi.Input['DomainLifecycleManagement']]):
        pulumi.set(self, "lifecycle_management", value)

    @property
    @pulumi.getter(name="maxIdleTimeoutInMinutes")
    def max_idle_timeout_in_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum value in minutes that custom idle shutdown can be set to by the user.
        """
        return pulumi.get(self, "max_idle_timeout_in_minutes")

    @max_idle_timeout_in_minutes.setter
    def max_idle_timeout_in_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_idle_timeout_in_minutes", value)

    @property
    @pulumi.getter(name="minIdleTimeoutInMinutes")
    def min_idle_timeout_in_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum value in minutes that custom idle shutdown can be set to by the user.
        """
        return pulumi.get(self, "min_idle_timeout_in_minutes")

    @min_idle_timeout_in_minutes.setter
    def min_idle_timeout_in_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_idle_timeout_in_minutes", value)


if not MYPY:
    class DomainJupyterLabAppSettingsArgsDict(TypedDict):
        """
        The JupyterLab app settings.
        """
        app_lifecycle_management: NotRequired[pulumi.Input['DomainAppLifecycleManagementArgsDict']]
        """
        Indicates whether idle shutdown is activated for JupyterLab applications.
        """
        code_repositories: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainCodeRepositoryArgsDict']]]]
        """
        A list of CodeRepositories available for use with JupyterLab apps.
        """
        custom_images: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainCustomImageArgsDict']]]]
        """
        A list of custom images for use for JupyterLab apps.
        """
        default_resource_spec: NotRequired[pulumi.Input['DomainResourceSpecArgsDict']]
        """
        The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the JupyterLab app.
        """
        lifecycle_config_arns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of LifecycleConfigArns available for use with JupyterLab apps.
        """
elif False:
    DomainJupyterLabAppSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainJupyterLabAppSettingsArgs:
    def __init__(__self__, *,
                 app_lifecycle_management: Optional[pulumi.Input['DomainAppLifecycleManagementArgs']] = None,
                 code_repositories: Optional[pulumi.Input[Sequence[pulumi.Input['DomainCodeRepositoryArgs']]]] = None,
                 custom_images: Optional[pulumi.Input[Sequence[pulumi.Input['DomainCustomImageArgs']]]] = None,
                 default_resource_spec: Optional[pulumi.Input['DomainResourceSpecArgs']] = None,
                 lifecycle_config_arns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The JupyterLab app settings.
        :param pulumi.Input['DomainAppLifecycleManagementArgs'] app_lifecycle_management: Indicates whether idle shutdown is activated for JupyterLab applications.
        :param pulumi.Input[Sequence[pulumi.Input['DomainCodeRepositoryArgs']]] code_repositories: A list of CodeRepositories available for use with JupyterLab apps.
        :param pulumi.Input[Sequence[pulumi.Input['DomainCustomImageArgs']]] custom_images: A list of custom images for use for JupyterLab apps.
        :param pulumi.Input['DomainResourceSpecArgs'] default_resource_spec: The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the JupyterLab app.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] lifecycle_config_arns: A list of LifecycleConfigArns available for use with JupyterLab apps.
        """
        if app_lifecycle_management is not None:
            pulumi.set(__self__, "app_lifecycle_management", app_lifecycle_management)
        if code_repositories is not None:
            pulumi.set(__self__, "code_repositories", code_repositories)
        if custom_images is not None:
            pulumi.set(__self__, "custom_images", custom_images)
        if default_resource_spec is not None:
            pulumi.set(__self__, "default_resource_spec", default_resource_spec)
        if lifecycle_config_arns is not None:
            pulumi.set(__self__, "lifecycle_config_arns", lifecycle_config_arns)

    @property
    @pulumi.getter(name="appLifecycleManagement")
    def app_lifecycle_management(self) -> Optional[pulumi.Input['DomainAppLifecycleManagementArgs']]:
        """
        Indicates whether idle shutdown is activated for JupyterLab applications.
        """
        return pulumi.get(self, "app_lifecycle_management")

    @app_lifecycle_management.setter
    def app_lifecycle_management(self, value: Optional[pulumi.Input['DomainAppLifecycleManagementArgs']]):
        pulumi.set(self, "app_lifecycle_management", value)

    @property
    @pulumi.getter(name="codeRepositories")
    def code_repositories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainCodeRepositoryArgs']]]]:
        """
        A list of CodeRepositories available for use with JupyterLab apps.
        """
        return pulumi.get(self, "code_repositories")

    @code_repositories.setter
    def code_repositories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainCodeRepositoryArgs']]]]):
        pulumi.set(self, "code_repositories", value)

    @property
    @pulumi.getter(name="customImages")
    def custom_images(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainCustomImageArgs']]]]:
        """
        A list of custom images for use for JupyterLab apps.
        """
        return pulumi.get(self, "custom_images")

    @custom_images.setter
    def custom_images(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainCustomImageArgs']]]]):
        pulumi.set(self, "custom_images", value)

    @property
    @pulumi.getter(name="defaultResourceSpec")
    def default_resource_spec(self) -> Optional[pulumi.Input['DomainResourceSpecArgs']]:
        """
        The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the JupyterLab app.
        """
        return pulumi.get(self, "default_resource_spec")

    @default_resource_spec.setter
    def default_resource_spec(self, value: Optional[pulumi.Input['DomainResourceSpecArgs']]):
        pulumi.set(self, "default_resource_spec", value)

    @property
    @pulumi.getter(name="lifecycleConfigArns")
    def lifecycle_config_arns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of LifecycleConfigArns available for use with JupyterLab apps.
        """
        return pulumi.get(self, "lifecycle_config_arns")

    @lifecycle_config_arns.setter
    def lifecycle_config_arns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "lifecycle_config_arns", value)


if not MYPY:
    class DomainJupyterServerAppSettingsArgsDict(TypedDict):
        """
        The JupyterServer app settings.
        """
        default_resource_spec: NotRequired[pulumi.Input['DomainResourceSpecArgsDict']]
        """
        The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the JupyterServer app.
        """
        lifecycle_config_arns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of LifecycleConfigArns available for use with JupyterServer apps.
        """
elif False:
    DomainJupyterServerAppSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainJupyterServerAppSettingsArgs:
    def __init__(__self__, *,
                 default_resource_spec: Optional[pulumi.Input['DomainResourceSpecArgs']] = None,
                 lifecycle_config_arns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The JupyterServer app settings.
        :param pulumi.Input['DomainResourceSpecArgs'] default_resource_spec: The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the JupyterServer app.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] lifecycle_config_arns: A list of LifecycleConfigArns available for use with JupyterServer apps.
        """
        if default_resource_spec is not None:
            pulumi.set(__self__, "default_resource_spec", default_resource_spec)
        if lifecycle_config_arns is not None:
            pulumi.set(__self__, "lifecycle_config_arns", lifecycle_config_arns)

    @property
    @pulumi.getter(name="defaultResourceSpec")
    def default_resource_spec(self) -> Optional[pulumi.Input['DomainResourceSpecArgs']]:
        """
        The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the JupyterServer app.
        """
        return pulumi.get(self, "default_resource_spec")

    @default_resource_spec.setter
    def default_resource_spec(self, value: Optional[pulumi.Input['DomainResourceSpecArgs']]):
        pulumi.set(self, "default_resource_spec", value)

    @property
    @pulumi.getter(name="lifecycleConfigArns")
    def lifecycle_config_arns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of LifecycleConfigArns available for use with JupyterServer apps.
        """
        return pulumi.get(self, "lifecycle_config_arns")

    @lifecycle_config_arns.setter
    def lifecycle_config_arns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "lifecycle_config_arns", value)


if not MYPY:
    class DomainKernelGatewayAppSettingsArgsDict(TypedDict):
        """
        The kernel gateway app settings.
        """
        custom_images: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainCustomImageArgsDict']]]]
        """
        A list of custom SageMaker images that are configured to run as a KernelGateway app.
        """
        default_resource_spec: NotRequired[pulumi.Input['DomainResourceSpecArgsDict']]
        """
        The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the KernelGateway app.
        """
        lifecycle_config_arns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of LifecycleConfigArns available for use with KernelGateway apps.
        """
elif False:
    DomainKernelGatewayAppSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainKernelGatewayAppSettingsArgs:
    def __init__(__self__, *,
                 custom_images: Optional[pulumi.Input[Sequence[pulumi.Input['DomainCustomImageArgs']]]] = None,
                 default_resource_spec: Optional[pulumi.Input['DomainResourceSpecArgs']] = None,
                 lifecycle_config_arns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The kernel gateway app settings.
        :param pulumi.Input[Sequence[pulumi.Input['DomainCustomImageArgs']]] custom_images: A list of custom SageMaker images that are configured to run as a KernelGateway app.
        :param pulumi.Input['DomainResourceSpecArgs'] default_resource_spec: The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the KernelGateway app.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] lifecycle_config_arns: A list of LifecycleConfigArns available for use with KernelGateway apps.
        """
        if custom_images is not None:
            pulumi.set(__self__, "custom_images", custom_images)
        if default_resource_spec is not None:
            pulumi.set(__self__, "default_resource_spec", default_resource_spec)
        if lifecycle_config_arns is not None:
            pulumi.set(__self__, "lifecycle_config_arns", lifecycle_config_arns)

    @property
    @pulumi.getter(name="customImages")
    def custom_images(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainCustomImageArgs']]]]:
        """
        A list of custom SageMaker images that are configured to run as a KernelGateway app.
        """
        return pulumi.get(self, "custom_images")

    @custom_images.setter
    def custom_images(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainCustomImageArgs']]]]):
        pulumi.set(self, "custom_images", value)

    @property
    @pulumi.getter(name="defaultResourceSpec")
    def default_resource_spec(self) -> Optional[pulumi.Input['DomainResourceSpecArgs']]:
        """
        The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the KernelGateway app.
        """
        return pulumi.get(self, "default_resource_spec")

    @default_resource_spec.setter
    def default_resource_spec(self, value: Optional[pulumi.Input['DomainResourceSpecArgs']]):
        pulumi.set(self, "default_resource_spec", value)

    @property
    @pulumi.getter(name="lifecycleConfigArns")
    def lifecycle_config_arns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of LifecycleConfigArns available for use with KernelGateway apps.
        """
        return pulumi.get(self, "lifecycle_config_arns")

    @lifecycle_config_arns.setter
    def lifecycle_config_arns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "lifecycle_config_arns", value)


if not MYPY:
    class DomainRSessionAppSettingsArgsDict(TypedDict):
        """
        A collection of settings that apply to an RSessionGateway app.
        """
        custom_images: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainCustomImageArgsDict']]]]
        """
        A list of custom SageMaker images that are configured to run as a KernelGateway app.
        """
        default_resource_spec: NotRequired[pulumi.Input['DomainResourceSpecArgsDict']]
        """
        Specifies the ARNs of a SageMaker image and SageMaker image version, and the instance type that the version runs on.
        """
elif False:
    DomainRSessionAppSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainRSessionAppSettingsArgs:
    def __init__(__self__, *,
                 custom_images: Optional[pulumi.Input[Sequence[pulumi.Input['DomainCustomImageArgs']]]] = None,
                 default_resource_spec: Optional[pulumi.Input['DomainResourceSpecArgs']] = None):
        """
        A collection of settings that apply to an RSessionGateway app.
        :param pulumi.Input[Sequence[pulumi.Input['DomainCustomImageArgs']]] custom_images: A list of custom SageMaker images that are configured to run as a KernelGateway app.
        :param pulumi.Input['DomainResourceSpecArgs'] default_resource_spec: Specifies the ARNs of a SageMaker image and SageMaker image version, and the instance type that the version runs on.
        """
        if custom_images is not None:
            pulumi.set(__self__, "custom_images", custom_images)
        if default_resource_spec is not None:
            pulumi.set(__self__, "default_resource_spec", default_resource_spec)

    @property
    @pulumi.getter(name="customImages")
    def custom_images(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainCustomImageArgs']]]]:
        """
        A list of custom SageMaker images that are configured to run as a KernelGateway app.
        """
        return pulumi.get(self, "custom_images")

    @custom_images.setter
    def custom_images(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainCustomImageArgs']]]]):
        pulumi.set(self, "custom_images", value)

    @property
    @pulumi.getter(name="defaultResourceSpec")
    def default_resource_spec(self) -> Optional[pulumi.Input['DomainResourceSpecArgs']]:
        """
        Specifies the ARNs of a SageMaker image and SageMaker image version, and the instance type that the version runs on.
        """
        return pulumi.get(self, "default_resource_spec")

    @default_resource_spec.setter
    def default_resource_spec(self, value: Optional[pulumi.Input['DomainResourceSpecArgs']]):
        pulumi.set(self, "default_resource_spec", value)


if not MYPY:
    class DomainRStudioServerProAppSettingsArgsDict(TypedDict):
        """
        A collection of settings that configure user interaction with the RStudioServerPro app.
        """
        access_status: NotRequired[pulumi.Input['DomainRStudioServerProAppSettingsAccessStatus']]
        """
        Indicates whether the current user has access to the RStudioServerPro app.
        """
        user_group: NotRequired[pulumi.Input['DomainRStudioServerProAppSettingsUserGroup']]
        """
        The level of permissions that the user has within the RStudioServerPro app. This value defaults to User. The Admin value allows the user access to the RStudio Administrative Dashboard.
        """
elif False:
    DomainRStudioServerProAppSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainRStudioServerProAppSettingsArgs:
    def __init__(__self__, *,
                 access_status: Optional[pulumi.Input['DomainRStudioServerProAppSettingsAccessStatus']] = None,
                 user_group: Optional[pulumi.Input['DomainRStudioServerProAppSettingsUserGroup']] = None):
        """
        A collection of settings that configure user interaction with the RStudioServerPro app.
        :param pulumi.Input['DomainRStudioServerProAppSettingsAccessStatus'] access_status: Indicates whether the current user has access to the RStudioServerPro app.
        :param pulumi.Input['DomainRStudioServerProAppSettingsUserGroup'] user_group: The level of permissions that the user has within the RStudioServerPro app. This value defaults to User. The Admin value allows the user access to the RStudio Administrative Dashboard.
        """
        if access_status is not None:
            pulumi.set(__self__, "access_status", access_status)
        if user_group is not None:
            pulumi.set(__self__, "user_group", user_group)

    @property
    @pulumi.getter(name="accessStatus")
    def access_status(self) -> Optional[pulumi.Input['DomainRStudioServerProAppSettingsAccessStatus']]:
        """
        Indicates whether the current user has access to the RStudioServerPro app.
        """
        return pulumi.get(self, "access_status")

    @access_status.setter
    def access_status(self, value: Optional[pulumi.Input['DomainRStudioServerProAppSettingsAccessStatus']]):
        pulumi.set(self, "access_status", value)

    @property
    @pulumi.getter(name="userGroup")
    def user_group(self) -> Optional[pulumi.Input['DomainRStudioServerProAppSettingsUserGroup']]:
        """
        The level of permissions that the user has within the RStudioServerPro app. This value defaults to User. The Admin value allows the user access to the RStudio Administrative Dashboard.
        """
        return pulumi.get(self, "user_group")

    @user_group.setter
    def user_group(self, value: Optional[pulumi.Input['DomainRStudioServerProAppSettingsUserGroup']]):
        pulumi.set(self, "user_group", value)


if not MYPY:
    class DomainRStudioServerProDomainSettingsArgsDict(TypedDict):
        """
        A collection of settings that update the current configuration for the RStudioServerPro Domain-level app.
        """
        domain_execution_role_arn: pulumi.Input[str]
        """
        The ARN of the execution role for the RStudioServerPro Domain-level app.
        """
        default_resource_spec: NotRequired[pulumi.Input['DomainResourceSpecArgsDict']]
        """
        A collection that defines the default `InstanceType` , `SageMakerImageArn` , and `SageMakerImageVersionArn` for the Domain.
        """
        r_studio_connect_url: NotRequired[pulumi.Input[str]]
        """
        A URL pointing to an RStudio Connect server.
        """
        r_studio_package_manager_url: NotRequired[pulumi.Input[str]]
        """
        A URL pointing to an RStudio Package Manager server.
        """
elif False:
    DomainRStudioServerProDomainSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainRStudioServerProDomainSettingsArgs:
    def __init__(__self__, *,
                 domain_execution_role_arn: pulumi.Input[str],
                 default_resource_spec: Optional[pulumi.Input['DomainResourceSpecArgs']] = None,
                 r_studio_connect_url: Optional[pulumi.Input[str]] = None,
                 r_studio_package_manager_url: Optional[pulumi.Input[str]] = None):
        """
        A collection of settings that update the current configuration for the RStudioServerPro Domain-level app.
        :param pulumi.Input[str] domain_execution_role_arn: The ARN of the execution role for the RStudioServerPro Domain-level app.
        :param pulumi.Input['DomainResourceSpecArgs'] default_resource_spec: A collection that defines the default `InstanceType` , `SageMakerImageArn` , and `SageMakerImageVersionArn` for the Domain.
        :param pulumi.Input[str] r_studio_connect_url: A URL pointing to an RStudio Connect server.
        :param pulumi.Input[str] r_studio_package_manager_url: A URL pointing to an RStudio Package Manager server.
        """
        pulumi.set(__self__, "domain_execution_role_arn", domain_execution_role_arn)
        if default_resource_spec is not None:
            pulumi.set(__self__, "default_resource_spec", default_resource_spec)
        if r_studio_connect_url is not None:
            pulumi.set(__self__, "r_studio_connect_url", r_studio_connect_url)
        if r_studio_package_manager_url is not None:
            pulumi.set(__self__, "r_studio_package_manager_url", r_studio_package_manager_url)

    @property
    @pulumi.getter(name="domainExecutionRoleArn")
    def domain_execution_role_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the execution role for the RStudioServerPro Domain-level app.
        """
        return pulumi.get(self, "domain_execution_role_arn")

    @domain_execution_role_arn.setter
    def domain_execution_role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain_execution_role_arn", value)

    @property
    @pulumi.getter(name="defaultResourceSpec")
    def default_resource_spec(self) -> Optional[pulumi.Input['DomainResourceSpecArgs']]:
        """
        A collection that defines the default `InstanceType` , `SageMakerImageArn` , and `SageMakerImageVersionArn` for the Domain.
        """
        return pulumi.get(self, "default_resource_spec")

    @default_resource_spec.setter
    def default_resource_spec(self, value: Optional[pulumi.Input['DomainResourceSpecArgs']]):
        pulumi.set(self, "default_resource_spec", value)

    @property
    @pulumi.getter(name="rStudioConnectUrl")
    def r_studio_connect_url(self) -> Optional[pulumi.Input[str]]:
        """
        A URL pointing to an RStudio Connect server.
        """
        return pulumi.get(self, "r_studio_connect_url")

    @r_studio_connect_url.setter
    def r_studio_connect_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "r_studio_connect_url", value)

    @property
    @pulumi.getter(name="rStudioPackageManagerUrl")
    def r_studio_package_manager_url(self) -> Optional[pulumi.Input[str]]:
        """
        A URL pointing to an RStudio Package Manager server.
        """
        return pulumi.get(self, "r_studio_package_manager_url")

    @r_studio_package_manager_url.setter
    def r_studio_package_manager_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "r_studio_package_manager_url", value)


if not MYPY:
    class DomainResourceSpecArgsDict(TypedDict):
        instance_type: NotRequired[pulumi.Input['DomainResourceSpecInstanceType']]
        """
        The instance type that the image version runs on.
        """
        lifecycle_config_arn: NotRequired[pulumi.Input[str]]
        """
        The Amazon Resource Name (ARN) of the Lifecycle Configuration to attach to the Resource.
        """
        sage_maker_image_arn: NotRequired[pulumi.Input[str]]
        """
        The Amazon Resource Name (ARN) of the SageMaker image that the image version belongs to.
        """
        sage_maker_image_version_arn: NotRequired[pulumi.Input[str]]
        """
        The Amazon Resource Name (ARN) of the image version created on the instance.
        """
elif False:
    DomainResourceSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainResourceSpecArgs:
    def __init__(__self__, *,
                 instance_type: Optional[pulumi.Input['DomainResourceSpecInstanceType']] = None,
                 lifecycle_config_arn: Optional[pulumi.Input[str]] = None,
                 sage_maker_image_arn: Optional[pulumi.Input[str]] = None,
                 sage_maker_image_version_arn: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['DomainResourceSpecInstanceType'] instance_type: The instance type that the image version runs on.
        :param pulumi.Input[str] lifecycle_config_arn: The Amazon Resource Name (ARN) of the Lifecycle Configuration to attach to the Resource.
        :param pulumi.Input[str] sage_maker_image_arn: The Amazon Resource Name (ARN) of the SageMaker image that the image version belongs to.
        :param pulumi.Input[str] sage_maker_image_version_arn: The Amazon Resource Name (ARN) of the image version created on the instance.
        """
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if lifecycle_config_arn is not None:
            pulumi.set(__self__, "lifecycle_config_arn", lifecycle_config_arn)
        if sage_maker_image_arn is not None:
            pulumi.set(__self__, "sage_maker_image_arn", sage_maker_image_arn)
        if sage_maker_image_version_arn is not None:
            pulumi.set(__self__, "sage_maker_image_version_arn", sage_maker_image_version_arn)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[pulumi.Input['DomainResourceSpecInstanceType']]:
        """
        The instance type that the image version runs on.
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: Optional[pulumi.Input['DomainResourceSpecInstanceType']]):
        pulumi.set(self, "instance_type", value)

    @property
    @pulumi.getter(name="lifecycleConfigArn")
    def lifecycle_config_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon Resource Name (ARN) of the Lifecycle Configuration to attach to the Resource.
        """
        return pulumi.get(self, "lifecycle_config_arn")

    @lifecycle_config_arn.setter
    def lifecycle_config_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_config_arn", value)

    @property
    @pulumi.getter(name="sageMakerImageArn")
    def sage_maker_image_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon Resource Name (ARN) of the SageMaker image that the image version belongs to.
        """
        return pulumi.get(self, "sage_maker_image_arn")

    @sage_maker_image_arn.setter
    def sage_maker_image_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sage_maker_image_arn", value)

    @property
    @pulumi.getter(name="sageMakerImageVersionArn")
    def sage_maker_image_version_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon Resource Name (ARN) of the image version created on the instance.
        """
        return pulumi.get(self, "sage_maker_image_version_arn")

    @sage_maker_image_version_arn.setter
    def sage_maker_image_version_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sage_maker_image_version_arn", value)


if not MYPY:
    class DomainSettingsArgsDict(TypedDict):
        """
        A collection of Domain settings.
        """
        docker_settings: NotRequired[pulumi.Input['DomainDockerSettingsArgsDict']]
        """
        A collection of settings that configure the domain's Docker interaction.
        """
        execution_role_identity_config: NotRequired[pulumi.Input['DomainSettingsExecutionRoleIdentityConfig']]
        """
        The configuration for attaching a SageMaker user profile name to the execution role as a sts:SourceIdentity key.
        """
        r_studio_server_pro_domain_settings: NotRequired[pulumi.Input['DomainRStudioServerProDomainSettingsArgsDict']]
        """
        A collection of settings that configure the `RStudioServerPro` Domain-level app.
        """
        security_group_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The security groups for the Amazon Virtual Private Cloud that the Domain uses for communication between Domain-level apps and user apps.
        """
elif False:
    DomainSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainSettingsArgs:
    def __init__(__self__, *,
                 docker_settings: Optional[pulumi.Input['DomainDockerSettingsArgs']] = None,
                 execution_role_identity_config: Optional[pulumi.Input['DomainSettingsExecutionRoleIdentityConfig']] = None,
                 r_studio_server_pro_domain_settings: Optional[pulumi.Input['DomainRStudioServerProDomainSettingsArgs']] = None,
                 security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        A collection of Domain settings.
        :param pulumi.Input['DomainDockerSettingsArgs'] docker_settings: A collection of settings that configure the domain's Docker interaction.
        :param pulumi.Input['DomainSettingsExecutionRoleIdentityConfig'] execution_role_identity_config: The configuration for attaching a SageMaker user profile name to the execution role as a sts:SourceIdentity key.
        :param pulumi.Input['DomainRStudioServerProDomainSettingsArgs'] r_studio_server_pro_domain_settings: A collection of settings that configure the `RStudioServerPro` Domain-level app.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_group_ids: The security groups for the Amazon Virtual Private Cloud that the Domain uses for communication between Domain-level apps and user apps.
        """
        if docker_settings is not None:
            pulumi.set(__self__, "docker_settings", docker_settings)
        if execution_role_identity_config is not None:
            pulumi.set(__self__, "execution_role_identity_config", execution_role_identity_config)
        if r_studio_server_pro_domain_settings is not None:
            pulumi.set(__self__, "r_studio_server_pro_domain_settings", r_studio_server_pro_domain_settings)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)

    @property
    @pulumi.getter(name="dockerSettings")
    def docker_settings(self) -> Optional[pulumi.Input['DomainDockerSettingsArgs']]:
        """
        A collection of settings that configure the domain's Docker interaction.
        """
        return pulumi.get(self, "docker_settings")

    @docker_settings.setter
    def docker_settings(self, value: Optional[pulumi.Input['DomainDockerSettingsArgs']]):
        pulumi.set(self, "docker_settings", value)

    @property
    @pulumi.getter(name="executionRoleIdentityConfig")
    def execution_role_identity_config(self) -> Optional[pulumi.Input['DomainSettingsExecutionRoleIdentityConfig']]:
        """
        The configuration for attaching a SageMaker user profile name to the execution role as a sts:SourceIdentity key.
        """
        return pulumi.get(self, "execution_role_identity_config")

    @execution_role_identity_config.setter
    def execution_role_identity_config(self, value: Optional[pulumi.Input['DomainSettingsExecutionRoleIdentityConfig']]):
        pulumi.set(self, "execution_role_identity_config", value)

    @property
    @pulumi.getter(name="rStudioServerProDomainSettings")
    def r_studio_server_pro_domain_settings(self) -> Optional[pulumi.Input['DomainRStudioServerProDomainSettingsArgs']]:
        """
        A collection of settings that configure the `RStudioServerPro` Domain-level app.
        """
        return pulumi.get(self, "r_studio_server_pro_domain_settings")

    @r_studio_server_pro_domain_settings.setter
    def r_studio_server_pro_domain_settings(self, value: Optional[pulumi.Input['DomainRStudioServerProDomainSettingsArgs']]):
        pulumi.set(self, "r_studio_server_pro_domain_settings", value)

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The security groups for the Amazon Virtual Private Cloud that the Domain uses for communication between Domain-level apps and user apps.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_group_ids", value)


if not MYPY:
    class DomainSharingSettingsArgsDict(TypedDict):
        """
        Specifies options when sharing an Amazon SageMaker Studio notebook. These settings are specified as part of DefaultUserSettings when the CreateDomain API is called, and as part of UserSettings when the CreateUserProfile API is called.
        """
        notebook_output_option: NotRequired[pulumi.Input['DomainSharingSettingsNotebookOutputOption']]
        """
        Whether to include the notebook cell output when sharing the notebook. The default is Disabled.
        """
        s3_kms_key_id: NotRequired[pulumi.Input[str]]
        """
        When NotebookOutputOption is Allowed, the AWS Key Management Service (KMS) encryption key ID used to encrypt the notebook cell output in the Amazon S3 bucket.
        """
        s3_output_path: NotRequired[pulumi.Input[str]]
        """
        When NotebookOutputOption is Allowed, the Amazon S3 bucket used to store the shared notebook snapshots.
        """
elif False:
    DomainSharingSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainSharingSettingsArgs:
    def __init__(__self__, *,
                 notebook_output_option: Optional[pulumi.Input['DomainSharingSettingsNotebookOutputOption']] = None,
                 s3_kms_key_id: Optional[pulumi.Input[str]] = None,
                 s3_output_path: Optional[pulumi.Input[str]] = None):
        """
        Specifies options when sharing an Amazon SageMaker Studio notebook. These settings are specified as part of DefaultUserSettings when the CreateDomain API is called, and as part of UserSettings when the CreateUserProfile API is called.
        :param pulumi.Input['DomainSharingSettingsNotebookOutputOption'] notebook_output_option: Whether to include the notebook cell output when sharing the notebook. The default is Disabled.
        :param pulumi.Input[str] s3_kms_key_id: When NotebookOutputOption is Allowed, the AWS Key Management Service (KMS) encryption key ID used to encrypt the notebook cell output in the Amazon S3 bucket.
        :param pulumi.Input[str] s3_output_path: When NotebookOutputOption is Allowed, the Amazon S3 bucket used to store the shared notebook snapshots.
        """
        if notebook_output_option is not None:
            pulumi.set(__self__, "notebook_output_option", notebook_output_option)
        if s3_kms_key_id is not None:
            pulumi.set(__self__, "s3_kms_key_id", s3_kms_key_id)
        if s3_output_path is not None:
            pulumi.set(__self__, "s3_output_path", s3_output_path)

    @property
    @pulumi.getter(name="notebookOutputOption")
    def notebook_output_option(self) -> Optional[pulumi.Input['DomainSharingSettingsNotebookOutputOption']]:
        """
        Whether to include the notebook cell output when sharing the notebook. The default is Disabled.
        """
        return pulumi.get(self, "notebook_output_option")

    @notebook_output_option.setter
    def notebook_output_option(self, value: Optional[pulumi.Input['DomainSharingSettingsNotebookOutputOption']]):
        pulumi.set(self, "notebook_output_option", value)

    @property
    @pulumi.getter(name="s3KmsKeyId")
    def s3_kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        When NotebookOutputOption is Allowed, the AWS Key Management Service (KMS) encryption key ID used to encrypt the notebook cell output in the Amazon S3 bucket.
        """
        return pulumi.get(self, "s3_kms_key_id")

    @s3_kms_key_id.setter
    def s3_kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_kms_key_id", value)

    @property
    @pulumi.getter(name="s3OutputPath")
    def s3_output_path(self) -> Optional[pulumi.Input[str]]:
        """
        When NotebookOutputOption is Allowed, the Amazon S3 bucket used to store the shared notebook snapshots.
        """
        return pulumi.get(self, "s3_output_path")

    @s3_output_path.setter
    def s3_output_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_output_path", value)


if not MYPY:
    class DomainStudioWebPortalSettingsArgsDict(TypedDict):
        """
        Studio settings. If these settings are applied on a user level, they take priority over the settings applied on a domain level.
        """
        hidden_app_types: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainAppType']]]]
        """
        Applications supported in Studio that are hidden from the Studio left navigation pane.
        """
        hidden_ml_tools: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainMlTools']]]]
        """
        The machine learning tools that are hidden from the Studio left navigation pane.
        """
elif False:
    DomainStudioWebPortalSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainStudioWebPortalSettingsArgs:
    def __init__(__self__, *,
                 hidden_app_types: Optional[pulumi.Input[Sequence[pulumi.Input['DomainAppType']]]] = None,
                 hidden_ml_tools: Optional[pulumi.Input[Sequence[pulumi.Input['DomainMlTools']]]] = None):
        """
        Studio settings. If these settings are applied on a user level, they take priority over the settings applied on a domain level.
        :param pulumi.Input[Sequence[pulumi.Input['DomainAppType']]] hidden_app_types: Applications supported in Studio that are hidden from the Studio left navigation pane.
        :param pulumi.Input[Sequence[pulumi.Input['DomainMlTools']]] hidden_ml_tools: The machine learning tools that are hidden from the Studio left navigation pane.
        """
        if hidden_app_types is not None:
            pulumi.set(__self__, "hidden_app_types", hidden_app_types)
        if hidden_ml_tools is not None:
            pulumi.set(__self__, "hidden_ml_tools", hidden_ml_tools)

    @property
    @pulumi.getter(name="hiddenAppTypes")
    def hidden_app_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainAppType']]]]:
        """
        Applications supported in Studio that are hidden from the Studio left navigation pane.
        """
        return pulumi.get(self, "hidden_app_types")

    @hidden_app_types.setter
    def hidden_app_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainAppType']]]]):
        pulumi.set(self, "hidden_app_types", value)

    @property
    @pulumi.getter(name="hiddenMlTools")
    def hidden_ml_tools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainMlTools']]]]:
        """
        The machine learning tools that are hidden from the Studio left navigation pane.
        """
        return pulumi.get(self, "hidden_ml_tools")

    @hidden_ml_tools.setter
    def hidden_ml_tools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainMlTools']]]]):
        pulumi.set(self, "hidden_ml_tools", value)


if not MYPY:
    class DomainUserSettingsArgsDict(TypedDict):
        """
        A collection of settings that apply to users of Amazon SageMaker Studio. These settings are specified when the CreateUserProfile API is called, and as DefaultUserSettings when the CreateDomain API is called.
        """
        execution_role: pulumi.Input[str]
        """
        The execution role for the user.
        """
        code_editor_app_settings: NotRequired[pulumi.Input['DomainCodeEditorAppSettingsArgsDict']]
        """
        The Code Editor application settings.

        SageMaker applies these settings only to private spaces that the user creates in the domain. SageMaker doesn't apply these settings to shared spaces.
        """
        custom_file_system_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainCustomFileSystemConfigArgsDict']]]]
        """
        The settings for assigning a custom file system to a user profile. Permitted users can access this file system in Amazon SageMaker Studio.

        SageMaker applies these settings only to private spaces that the user creates in the domain. SageMaker doesn't apply these settings to shared spaces.
        """
        custom_posix_user_config: NotRequired[pulumi.Input['DomainCustomPosixUserConfigArgsDict']]
        """
        Details about the POSIX identity that is used for file system operations.

        SageMaker applies these settings only to private spaces that the user creates in the domain. SageMaker doesn't apply these settings to shared spaces.
        """
        default_landing_uri: NotRequired[pulumi.Input[str]]
        """
        Defines which Amazon SageMaker application users are directed to by default.
        """
        jupyter_lab_app_settings: NotRequired[pulumi.Input['DomainJupyterLabAppSettingsArgsDict']]
        """
        The settings for the JupyterLab application.

        SageMaker applies these settings only to private spaces that the user creates in the domain. SageMaker doesn't apply these settings to shared spaces.
        """
        jupyter_server_app_settings: NotRequired[pulumi.Input['DomainJupyterServerAppSettingsArgsDict']]
        """
        The Jupyter server's app settings.
        """
        kernel_gateway_app_settings: NotRequired[pulumi.Input['DomainKernelGatewayAppSettingsArgsDict']]
        """
        The kernel gateway app settings.
        """
        r_session_app_settings: NotRequired[pulumi.Input['DomainRSessionAppSettingsArgsDict']]
        """
        A collection of settings that configure the `RSessionGateway` app.
        """
        r_studio_server_pro_app_settings: NotRequired[pulumi.Input['DomainRStudioServerProAppSettingsArgsDict']]
        """
        A collection of settings that configure user interaction with the `RStudioServerPro` app.
        """
        security_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The security groups for the Amazon Virtual Private Cloud (VPC) that Studio uses for communication.
        """
        sharing_settings: NotRequired[pulumi.Input['DomainSharingSettingsArgsDict']]
        """
        The sharing settings.
        """
        space_storage_settings: NotRequired[pulumi.Input['DomainDefaultSpaceStorageSettingsArgsDict']]
        """
        The storage settings for a space.

        SageMaker applies these settings only to private spaces that the user creates in the domain. SageMaker doesn't apply these settings to shared spaces.
        """
        studio_web_portal: NotRequired[pulumi.Input['DomainUserSettingsStudioWebPortal']]
        """
        Indicates whether the Studio experience is available to users. If not, users cannot access Studio.
        """
        studio_web_portal_settings: NotRequired[pulumi.Input['DomainStudioWebPortalSettingsArgsDict']]
        """
        Studio settings. If these settings are applied on a user level, they take priority over the settings applied on a domain level.
        """
elif False:
    DomainUserSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainUserSettingsArgs:
    def __init__(__self__, *,
                 execution_role: pulumi.Input[str],
                 code_editor_app_settings: Optional[pulumi.Input['DomainCodeEditorAppSettingsArgs']] = None,
                 custom_file_system_configs: Optional[pulumi.Input[Sequence[pulumi.Input['DomainCustomFileSystemConfigArgs']]]] = None,
                 custom_posix_user_config: Optional[pulumi.Input['DomainCustomPosixUserConfigArgs']] = None,
                 default_landing_uri: Optional[pulumi.Input[str]] = None,
                 jupyter_lab_app_settings: Optional[pulumi.Input['DomainJupyterLabAppSettingsArgs']] = None,
                 jupyter_server_app_settings: Optional[pulumi.Input['DomainJupyterServerAppSettingsArgs']] = None,
                 kernel_gateway_app_settings: Optional[pulumi.Input['DomainKernelGatewayAppSettingsArgs']] = None,
                 r_session_app_settings: Optional[pulumi.Input['DomainRSessionAppSettingsArgs']] = None,
                 r_studio_server_pro_app_settings: Optional[pulumi.Input['DomainRStudioServerProAppSettingsArgs']] = None,
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 sharing_settings: Optional[pulumi.Input['DomainSharingSettingsArgs']] = None,
                 space_storage_settings: Optional[pulumi.Input['DomainDefaultSpaceStorageSettingsArgs']] = None,
                 studio_web_portal: Optional[pulumi.Input['DomainUserSettingsStudioWebPortal']] = None,
                 studio_web_portal_settings: Optional[pulumi.Input['DomainStudioWebPortalSettingsArgs']] = None):
        """
        A collection of settings that apply to users of Amazon SageMaker Studio. These settings are specified when the CreateUserProfile API is called, and as DefaultUserSettings when the CreateDomain API is called.
        :param pulumi.Input[str] execution_role: The execution role for the user.
        :param pulumi.Input['DomainCodeEditorAppSettingsArgs'] code_editor_app_settings: The Code Editor application settings.
               
               SageMaker applies these settings only to private spaces that the user creates in the domain. SageMaker doesn't apply these settings to shared spaces.
        :param pulumi.Input[Sequence[pulumi.Input['DomainCustomFileSystemConfigArgs']]] custom_file_system_configs: The settings for assigning a custom file system to a user profile. Permitted users can access this file system in Amazon SageMaker Studio.
               
               SageMaker applies these settings only to private spaces that the user creates in the domain. SageMaker doesn't apply these settings to shared spaces.
        :param pulumi.Input['DomainCustomPosixUserConfigArgs'] custom_posix_user_config: Details about the POSIX identity that is used for file system operations.
               
               SageMaker applies these settings only to private spaces that the user creates in the domain. SageMaker doesn't apply these settings to shared spaces.
        :param pulumi.Input[str] default_landing_uri: Defines which Amazon SageMaker application users are directed to by default.
        :param pulumi.Input['DomainJupyterLabAppSettingsArgs'] jupyter_lab_app_settings: The settings for the JupyterLab application.
               
               SageMaker applies these settings only to private spaces that the user creates in the domain. SageMaker doesn't apply these settings to shared spaces.
        :param pulumi.Input['DomainJupyterServerAppSettingsArgs'] jupyter_server_app_settings: The Jupyter server's app settings.
        :param pulumi.Input['DomainKernelGatewayAppSettingsArgs'] kernel_gateway_app_settings: The kernel gateway app settings.
        :param pulumi.Input['DomainRSessionAppSettingsArgs'] r_session_app_settings: A collection of settings that configure the `RSessionGateway` app.
        :param pulumi.Input['DomainRStudioServerProAppSettingsArgs'] r_studio_server_pro_app_settings: A collection of settings that configure user interaction with the `RStudioServerPro` app.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_groups: The security groups for the Amazon Virtual Private Cloud (VPC) that Studio uses for communication.
        :param pulumi.Input['DomainSharingSettingsArgs'] sharing_settings: The sharing settings.
        :param pulumi.Input['DomainDefaultSpaceStorageSettingsArgs'] space_storage_settings: The storage settings for a space.
               
               SageMaker applies these settings only to private spaces that the user creates in the domain. SageMaker doesn't apply these settings to shared spaces.
        :param pulumi.Input['DomainUserSettingsStudioWebPortal'] studio_web_portal: Indicates whether the Studio experience is available to users. If not, users cannot access Studio.
        :param pulumi.Input['DomainStudioWebPortalSettingsArgs'] studio_web_portal_settings: Studio settings. If these settings are applied on a user level, they take priority over the settings applied on a domain level.
        """
        pulumi.set(__self__, "execution_role", execution_role)
        if code_editor_app_settings is not None:
            pulumi.set(__self__, "code_editor_app_settings", code_editor_app_settings)
        if custom_file_system_configs is not None:
            pulumi.set(__self__, "custom_file_system_configs", custom_file_system_configs)
        if custom_posix_user_config is not None:
            pulumi.set(__self__, "custom_posix_user_config", custom_posix_user_config)
        if default_landing_uri is not None:
            pulumi.set(__self__, "default_landing_uri", default_landing_uri)
        if jupyter_lab_app_settings is not None:
            pulumi.set(__self__, "jupyter_lab_app_settings", jupyter_lab_app_settings)
        if jupyter_server_app_settings is not None:
            pulumi.set(__self__, "jupyter_server_app_settings", jupyter_server_app_settings)
        if kernel_gateway_app_settings is not None:
            pulumi.set(__self__, "kernel_gateway_app_settings", kernel_gateway_app_settings)
        if r_session_app_settings is not None:
            pulumi.set(__self__, "r_session_app_settings", r_session_app_settings)
        if r_studio_server_pro_app_settings is not None:
            pulumi.set(__self__, "r_studio_server_pro_app_settings", r_studio_server_pro_app_settings)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if sharing_settings is not None:
            pulumi.set(__self__, "sharing_settings", sharing_settings)
        if space_storage_settings is not None:
            pulumi.set(__self__, "space_storage_settings", space_storage_settings)
        if studio_web_portal is not None:
            pulumi.set(__self__, "studio_web_portal", studio_web_portal)
        if studio_web_portal_settings is not None:
            pulumi.set(__self__, "studio_web_portal_settings", studio_web_portal_settings)

    @property
    @pulumi.getter(name="executionRole")
    def execution_role(self) -> pulumi.Input[str]:
        """
        The execution role for the user.
        """
        return pulumi.get(self, "execution_role")

    @execution_role.setter
    def execution_role(self, value: pulumi.Input[str]):
        pulumi.set(self, "execution_role", value)

    @property
    @pulumi.getter(name="codeEditorAppSettings")
    def code_editor_app_settings(self) -> Optional[pulumi.Input['DomainCodeEditorAppSettingsArgs']]:
        """
        The Code Editor application settings.

        SageMaker applies these settings only to private spaces that the user creates in the domain. SageMaker doesn't apply these settings to shared spaces.
        """
        return pulumi.get(self, "code_editor_app_settings")

    @code_editor_app_settings.setter
    def code_editor_app_settings(self, value: Optional[pulumi.Input['DomainCodeEditorAppSettingsArgs']]):
        pulumi.set(self, "code_editor_app_settings", value)

    @property
    @pulumi.getter(name="customFileSystemConfigs")
    def custom_file_system_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainCustomFileSystemConfigArgs']]]]:
        """
        The settings for assigning a custom file system to a user profile. Permitted users can access this file system in Amazon SageMaker Studio.

        SageMaker applies these settings only to private spaces that the user creates in the domain. SageMaker doesn't apply these settings to shared spaces.
        """
        return pulumi.get(self, "custom_file_system_configs")

    @custom_file_system_configs.setter
    def custom_file_system_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainCustomFileSystemConfigArgs']]]]):
        pulumi.set(self, "custom_file_system_configs", value)

    @property
    @pulumi.getter(name="customPosixUserConfig")
    def custom_posix_user_config(self) -> Optional[pulumi.Input['DomainCustomPosixUserConfigArgs']]:
        """
        Details about the POSIX identity that is used for file system operations.

        SageMaker applies these settings only to private spaces that the user creates in the domain. SageMaker doesn't apply these settings to shared spaces.
        """
        return pulumi.get(self, "custom_posix_user_config")

    @custom_posix_user_config.setter
    def custom_posix_user_config(self, value: Optional[pulumi.Input['DomainCustomPosixUserConfigArgs']]):
        pulumi.set(self, "custom_posix_user_config", value)

    @property
    @pulumi.getter(name="defaultLandingUri")
    def default_landing_uri(self) -> Optional[pulumi.Input[str]]:
        """
        Defines which Amazon SageMaker application users are directed to by default.
        """
        return pulumi.get(self, "default_landing_uri")

    @default_landing_uri.setter
    def default_landing_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_landing_uri", value)

    @property
    @pulumi.getter(name="jupyterLabAppSettings")
    def jupyter_lab_app_settings(self) -> Optional[pulumi.Input['DomainJupyterLabAppSettingsArgs']]:
        """
        The settings for the JupyterLab application.

        SageMaker applies these settings only to private spaces that the user creates in the domain. SageMaker doesn't apply these settings to shared spaces.
        """
        return pulumi.get(self, "jupyter_lab_app_settings")

    @jupyter_lab_app_settings.setter
    def jupyter_lab_app_settings(self, value: Optional[pulumi.Input['DomainJupyterLabAppSettingsArgs']]):
        pulumi.set(self, "jupyter_lab_app_settings", value)

    @property
    @pulumi.getter(name="jupyterServerAppSettings")
    def jupyter_server_app_settings(self) -> Optional[pulumi.Input['DomainJupyterServerAppSettingsArgs']]:
        """
        The Jupyter server's app settings.
        """
        return pulumi.get(self, "jupyter_server_app_settings")

    @jupyter_server_app_settings.setter
    def jupyter_server_app_settings(self, value: Optional[pulumi.Input['DomainJupyterServerAppSettingsArgs']]):
        pulumi.set(self, "jupyter_server_app_settings", value)

    @property
    @pulumi.getter(name="kernelGatewayAppSettings")
    def kernel_gateway_app_settings(self) -> Optional[pulumi.Input['DomainKernelGatewayAppSettingsArgs']]:
        """
        The kernel gateway app settings.
        """
        return pulumi.get(self, "kernel_gateway_app_settings")

    @kernel_gateway_app_settings.setter
    def kernel_gateway_app_settings(self, value: Optional[pulumi.Input['DomainKernelGatewayAppSettingsArgs']]):
        pulumi.set(self, "kernel_gateway_app_settings", value)

    @property
    @pulumi.getter(name="rSessionAppSettings")
    def r_session_app_settings(self) -> Optional[pulumi.Input['DomainRSessionAppSettingsArgs']]:
        """
        A collection of settings that configure the `RSessionGateway` app.
        """
        return pulumi.get(self, "r_session_app_settings")

    @r_session_app_settings.setter
    def r_session_app_settings(self, value: Optional[pulumi.Input['DomainRSessionAppSettingsArgs']]):
        pulumi.set(self, "r_session_app_settings", value)

    @property
    @pulumi.getter(name="rStudioServerProAppSettings")
    def r_studio_server_pro_app_settings(self) -> Optional[pulumi.Input['DomainRStudioServerProAppSettingsArgs']]:
        """
        A collection of settings that configure user interaction with the `RStudioServerPro` app.
        """
        return pulumi.get(self, "r_studio_server_pro_app_settings")

    @r_studio_server_pro_app_settings.setter
    def r_studio_server_pro_app_settings(self, value: Optional[pulumi.Input['DomainRStudioServerProAppSettingsArgs']]):
        pulumi.set(self, "r_studio_server_pro_app_settings", value)

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The security groups for the Amazon Virtual Private Cloud (VPC) that Studio uses for communication.
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_groups", value)

    @property
    @pulumi.getter(name="sharingSettings")
    def sharing_settings(self) -> Optional[pulumi.Input['DomainSharingSettingsArgs']]:
        """
        The sharing settings.
        """
        return pulumi.get(self, "sharing_settings")

    @sharing_settings.setter
    def sharing_settings(self, value: Optional[pulumi.Input['DomainSharingSettingsArgs']]):
        pulumi.set(self, "sharing_settings", value)

    @property
    @pulumi.getter(name="spaceStorageSettings")
    def space_storage_settings(self) -> Optional[pulumi.Input['DomainDefaultSpaceStorageSettingsArgs']]:
        """
        The storage settings for a space.

        SageMaker applies these settings only to private spaces that the user creates in the domain. SageMaker doesn't apply these settings to shared spaces.
        """
        return pulumi.get(self, "space_storage_settings")

    @space_storage_settings.setter
    def space_storage_settings(self, value: Optional[pulumi.Input['DomainDefaultSpaceStorageSettingsArgs']]):
        pulumi.set(self, "space_storage_settings", value)

    @property
    @pulumi.getter(name="studioWebPortal")
    def studio_web_portal(self) -> Optional[pulumi.Input['DomainUserSettingsStudioWebPortal']]:
        """
        Indicates whether the Studio experience is available to users. If not, users cannot access Studio.
        """
        return pulumi.get(self, "studio_web_portal")

    @studio_web_portal.setter
    def studio_web_portal(self, value: Optional[pulumi.Input['DomainUserSettingsStudioWebPortal']]):
        pulumi.set(self, "studio_web_portal", value)

    @property
    @pulumi.getter(name="studioWebPortalSettings")
    def studio_web_portal_settings(self) -> Optional[pulumi.Input['DomainStudioWebPortalSettingsArgs']]:
        """
        Studio settings. If these settings are applied on a user level, they take priority over the settings applied on a domain level.
        """
        return pulumi.get(self, "studio_web_portal_settings")

    @studio_web_portal_settings.setter
    def studio_web_portal_settings(self, value: Optional[pulumi.Input['DomainStudioWebPortalSettingsArgs']]):
        pulumi.set(self, "studio_web_portal_settings", value)


if not MYPY:
    class EndpointAlarmArgsDict(TypedDict):
        alarm_name: pulumi.Input[str]
        """
        The name of the CloudWatch alarm.
        """
elif False:
    EndpointAlarmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointAlarmArgs:
    def __init__(__self__, *,
                 alarm_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] alarm_name: The name of the CloudWatch alarm.
        """
        pulumi.set(__self__, "alarm_name", alarm_name)

    @property
    @pulumi.getter(name="alarmName")
    def alarm_name(self) -> pulumi.Input[str]:
        """
        The name of the CloudWatch alarm.
        """
        return pulumi.get(self, "alarm_name")

    @alarm_name.setter
    def alarm_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "alarm_name", value)


if not MYPY:
    class EndpointAutoRollbackConfigArgsDict(TypedDict):
        alarms: pulumi.Input[Sequence[pulumi.Input['EndpointAlarmArgsDict']]]
        """
        List of CloudWatch alarms to monitor during the deployment. If any alarm goes off, the deployment is rolled back.
        """
elif False:
    EndpointAutoRollbackConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointAutoRollbackConfigArgs:
    def __init__(__self__, *,
                 alarms: pulumi.Input[Sequence[pulumi.Input['EndpointAlarmArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['EndpointAlarmArgs']]] alarms: List of CloudWatch alarms to monitor during the deployment. If any alarm goes off, the deployment is rolled back.
        """
        pulumi.set(__self__, "alarms", alarms)

    @property
    @pulumi.getter
    def alarms(self) -> pulumi.Input[Sequence[pulumi.Input['EndpointAlarmArgs']]]:
        """
        List of CloudWatch alarms to monitor during the deployment. If any alarm goes off, the deployment is rolled back.
        """
        return pulumi.get(self, "alarms")

    @alarms.setter
    def alarms(self, value: pulumi.Input[Sequence[pulumi.Input['EndpointAlarmArgs']]]):
        pulumi.set(self, "alarms", value)


if not MYPY:
    class EndpointBlueGreenUpdatePolicyArgsDict(TypedDict):
        traffic_routing_configuration: pulumi.Input['EndpointTrafficRoutingConfigArgsDict']
        """
        The traffic routing configuration for the blue/green deployment.
        """
        maximum_execution_timeout_in_seconds: NotRequired[pulumi.Input[int]]
        """
        The maximum time allowed for the blue/green update, in seconds.
        """
        termination_wait_in_seconds: NotRequired[pulumi.Input[int]]
        """
        The wait time before terminating the old endpoint during a blue/green deployment.
        """
elif False:
    EndpointBlueGreenUpdatePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointBlueGreenUpdatePolicyArgs:
    def __init__(__self__, *,
                 traffic_routing_configuration: pulumi.Input['EndpointTrafficRoutingConfigArgs'],
                 maximum_execution_timeout_in_seconds: Optional[pulumi.Input[int]] = None,
                 termination_wait_in_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input['EndpointTrafficRoutingConfigArgs'] traffic_routing_configuration: The traffic routing configuration for the blue/green deployment.
        :param pulumi.Input[int] maximum_execution_timeout_in_seconds: The maximum time allowed for the blue/green update, in seconds.
        :param pulumi.Input[int] termination_wait_in_seconds: The wait time before terminating the old endpoint during a blue/green deployment.
        """
        pulumi.set(__self__, "traffic_routing_configuration", traffic_routing_configuration)
        if maximum_execution_timeout_in_seconds is not None:
            pulumi.set(__self__, "maximum_execution_timeout_in_seconds", maximum_execution_timeout_in_seconds)
        if termination_wait_in_seconds is not None:
            pulumi.set(__self__, "termination_wait_in_seconds", termination_wait_in_seconds)

    @property
    @pulumi.getter(name="trafficRoutingConfiguration")
    def traffic_routing_configuration(self) -> pulumi.Input['EndpointTrafficRoutingConfigArgs']:
        """
        The traffic routing configuration for the blue/green deployment.
        """
        return pulumi.get(self, "traffic_routing_configuration")

    @traffic_routing_configuration.setter
    def traffic_routing_configuration(self, value: pulumi.Input['EndpointTrafficRoutingConfigArgs']):
        pulumi.set(self, "traffic_routing_configuration", value)

    @property
    @pulumi.getter(name="maximumExecutionTimeoutInSeconds")
    def maximum_execution_timeout_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum time allowed for the blue/green update, in seconds.
        """
        return pulumi.get(self, "maximum_execution_timeout_in_seconds")

    @maximum_execution_timeout_in_seconds.setter
    def maximum_execution_timeout_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "maximum_execution_timeout_in_seconds", value)

    @property
    @pulumi.getter(name="terminationWaitInSeconds")
    def termination_wait_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The wait time before terminating the old endpoint during a blue/green deployment.
        """
        return pulumi.get(self, "termination_wait_in_seconds")

    @termination_wait_in_seconds.setter
    def termination_wait_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "termination_wait_in_seconds", value)


if not MYPY:
    class EndpointCapacitySizeArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Specifies whether the `Value` is an instance count or a capacity unit.
        """
        value: pulumi.Input[int]
        """
        The value representing either the number of instances or the number of capacity units.
        """
elif False:
    EndpointCapacitySizeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointCapacitySizeArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 value: pulumi.Input[int]):
        """
        :param pulumi.Input[str] type: Specifies whether the `Value` is an instance count or a capacity unit.
        :param pulumi.Input[int] value: The value representing either the number of instances or the number of capacity units.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies whether the `Value` is an instance count or a capacity unit.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[int]:
        """
        The value representing either the number of instances or the number of capacity units.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[int]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EndpointDeploymentConfigArgsDict(TypedDict):
        auto_rollback_configuration: NotRequired[pulumi.Input['EndpointAutoRollbackConfigArgsDict']]
        """
        Configuration for automatic rollback if an error occurs during deployment.
        """
        blue_green_update_policy: NotRequired[pulumi.Input['EndpointBlueGreenUpdatePolicyArgsDict']]
        """
        Configuration for blue-green update deployment policies.
        """
        rolling_update_policy: NotRequired[pulumi.Input['EndpointRollingUpdatePolicyArgsDict']]
        """
        Configuration for rolling update deployment policies.
        """
elif False:
    EndpointDeploymentConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointDeploymentConfigArgs:
    def __init__(__self__, *,
                 auto_rollback_configuration: Optional[pulumi.Input['EndpointAutoRollbackConfigArgs']] = None,
                 blue_green_update_policy: Optional[pulumi.Input['EndpointBlueGreenUpdatePolicyArgs']] = None,
                 rolling_update_policy: Optional[pulumi.Input['EndpointRollingUpdatePolicyArgs']] = None):
        """
        :param pulumi.Input['EndpointAutoRollbackConfigArgs'] auto_rollback_configuration: Configuration for automatic rollback if an error occurs during deployment.
        :param pulumi.Input['EndpointBlueGreenUpdatePolicyArgs'] blue_green_update_policy: Configuration for blue-green update deployment policies.
        :param pulumi.Input['EndpointRollingUpdatePolicyArgs'] rolling_update_policy: Configuration for rolling update deployment policies.
        """
        if auto_rollback_configuration is not None:
            pulumi.set(__self__, "auto_rollback_configuration", auto_rollback_configuration)
        if blue_green_update_policy is not None:
            pulumi.set(__self__, "blue_green_update_policy", blue_green_update_policy)
        if rolling_update_policy is not None:
            pulumi.set(__self__, "rolling_update_policy", rolling_update_policy)

    @property
    @pulumi.getter(name="autoRollbackConfiguration")
    def auto_rollback_configuration(self) -> Optional[pulumi.Input['EndpointAutoRollbackConfigArgs']]:
        """
        Configuration for automatic rollback if an error occurs during deployment.
        """
        return pulumi.get(self, "auto_rollback_configuration")

    @auto_rollback_configuration.setter
    def auto_rollback_configuration(self, value: Optional[pulumi.Input['EndpointAutoRollbackConfigArgs']]):
        pulumi.set(self, "auto_rollback_configuration", value)

    @property
    @pulumi.getter(name="blueGreenUpdatePolicy")
    def blue_green_update_policy(self) -> Optional[pulumi.Input['EndpointBlueGreenUpdatePolicyArgs']]:
        """
        Configuration for blue-green update deployment policies.
        """
        return pulumi.get(self, "blue_green_update_policy")

    @blue_green_update_policy.setter
    def blue_green_update_policy(self, value: Optional[pulumi.Input['EndpointBlueGreenUpdatePolicyArgs']]):
        pulumi.set(self, "blue_green_update_policy", value)

    @property
    @pulumi.getter(name="rollingUpdatePolicy")
    def rolling_update_policy(self) -> Optional[pulumi.Input['EndpointRollingUpdatePolicyArgs']]:
        """
        Configuration for rolling update deployment policies.
        """
        return pulumi.get(self, "rolling_update_policy")

    @rolling_update_policy.setter
    def rolling_update_policy(self, value: Optional[pulumi.Input['EndpointRollingUpdatePolicyArgs']]):
        pulumi.set(self, "rolling_update_policy", value)


if not MYPY:
    class EndpointRollingUpdatePolicyArgsDict(TypedDict):
        maximum_batch_size: pulumi.Input['EndpointCapacitySizeArgsDict']
        """
        Specifies the maximum batch size for each rolling update.
        """
        wait_interval_in_seconds: pulumi.Input[int]
        """
        The time to wait between steps during the rolling update, in seconds.
        """
        maximum_execution_timeout_in_seconds: NotRequired[pulumi.Input[int]]
        """
        The maximum time allowed for the rolling update, in seconds.
        """
        rollback_maximum_batch_size: NotRequired[pulumi.Input['EndpointCapacitySizeArgsDict']]
        """
        The maximum batch size for rollback during an update failure.
        """
elif False:
    EndpointRollingUpdatePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointRollingUpdatePolicyArgs:
    def __init__(__self__, *,
                 maximum_batch_size: pulumi.Input['EndpointCapacitySizeArgs'],
                 wait_interval_in_seconds: pulumi.Input[int],
                 maximum_execution_timeout_in_seconds: Optional[pulumi.Input[int]] = None,
                 rollback_maximum_batch_size: Optional[pulumi.Input['EndpointCapacitySizeArgs']] = None):
        """
        :param pulumi.Input['EndpointCapacitySizeArgs'] maximum_batch_size: Specifies the maximum batch size for each rolling update.
        :param pulumi.Input[int] wait_interval_in_seconds: The time to wait between steps during the rolling update, in seconds.
        :param pulumi.Input[int] maximum_execution_timeout_in_seconds: The maximum time allowed for the rolling update, in seconds.
        :param pulumi.Input['EndpointCapacitySizeArgs'] rollback_maximum_batch_size: The maximum batch size for rollback during an update failure.
        """
        pulumi.set(__self__, "maximum_batch_size", maximum_batch_size)
        pulumi.set(__self__, "wait_interval_in_seconds", wait_interval_in_seconds)
        if maximum_execution_timeout_in_seconds is not None:
            pulumi.set(__self__, "maximum_execution_timeout_in_seconds", maximum_execution_timeout_in_seconds)
        if rollback_maximum_batch_size is not None:
            pulumi.set(__self__, "rollback_maximum_batch_size", rollback_maximum_batch_size)

    @property
    @pulumi.getter(name="maximumBatchSize")
    def maximum_batch_size(self) -> pulumi.Input['EndpointCapacitySizeArgs']:
        """
        Specifies the maximum batch size for each rolling update.
        """
        return pulumi.get(self, "maximum_batch_size")

    @maximum_batch_size.setter
    def maximum_batch_size(self, value: pulumi.Input['EndpointCapacitySizeArgs']):
        pulumi.set(self, "maximum_batch_size", value)

    @property
    @pulumi.getter(name="waitIntervalInSeconds")
    def wait_interval_in_seconds(self) -> pulumi.Input[int]:
        """
        The time to wait between steps during the rolling update, in seconds.
        """
        return pulumi.get(self, "wait_interval_in_seconds")

    @wait_interval_in_seconds.setter
    def wait_interval_in_seconds(self, value: pulumi.Input[int]):
        pulumi.set(self, "wait_interval_in_seconds", value)

    @property
    @pulumi.getter(name="maximumExecutionTimeoutInSeconds")
    def maximum_execution_timeout_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum time allowed for the rolling update, in seconds.
        """
        return pulumi.get(self, "maximum_execution_timeout_in_seconds")

    @maximum_execution_timeout_in_seconds.setter
    def maximum_execution_timeout_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "maximum_execution_timeout_in_seconds", value)

    @property
    @pulumi.getter(name="rollbackMaximumBatchSize")
    def rollback_maximum_batch_size(self) -> Optional[pulumi.Input['EndpointCapacitySizeArgs']]:
        """
        The maximum batch size for rollback during an update failure.
        """
        return pulumi.get(self, "rollback_maximum_batch_size")

    @rollback_maximum_batch_size.setter
    def rollback_maximum_batch_size(self, value: Optional[pulumi.Input['EndpointCapacitySizeArgs']]):
        pulumi.set(self, "rollback_maximum_batch_size", value)


if not MYPY:
    class EndpointTrafficRoutingConfigArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Specifies the type of traffic routing (e.g., 'AllAtOnce', 'Canary', 'Linear').
        """
        canary_size: NotRequired[pulumi.Input['EndpointCapacitySizeArgsDict']]
        """
        Specifies the size of the canary traffic in a canary deployment.
        """
        linear_step_size: NotRequired[pulumi.Input['EndpointCapacitySizeArgsDict']]
        """
        Specifies the step size for linear traffic routing.
        """
        wait_interval_in_seconds: NotRequired[pulumi.Input[int]]
        """
        Specifies the wait interval between traffic shifts, in seconds.
        """
elif False:
    EndpointTrafficRoutingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointTrafficRoutingConfigArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 canary_size: Optional[pulumi.Input['EndpointCapacitySizeArgs']] = None,
                 linear_step_size: Optional[pulumi.Input['EndpointCapacitySizeArgs']] = None,
                 wait_interval_in_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] type: Specifies the type of traffic routing (e.g., 'AllAtOnce', 'Canary', 'Linear').
        :param pulumi.Input['EndpointCapacitySizeArgs'] canary_size: Specifies the size of the canary traffic in a canary deployment.
        :param pulumi.Input['EndpointCapacitySizeArgs'] linear_step_size: Specifies the step size for linear traffic routing.
        :param pulumi.Input[int] wait_interval_in_seconds: Specifies the wait interval between traffic shifts, in seconds.
        """
        pulumi.set(__self__, "type", type)
        if canary_size is not None:
            pulumi.set(__self__, "canary_size", canary_size)
        if linear_step_size is not None:
            pulumi.set(__self__, "linear_step_size", linear_step_size)
        if wait_interval_in_seconds is not None:
            pulumi.set(__self__, "wait_interval_in_seconds", wait_interval_in_seconds)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Specifies the type of traffic routing (e.g., 'AllAtOnce', 'Canary', 'Linear').
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="canarySize")
    def canary_size(self) -> Optional[pulumi.Input['EndpointCapacitySizeArgs']]:
        """
        Specifies the size of the canary traffic in a canary deployment.
        """
        return pulumi.get(self, "canary_size")

    @canary_size.setter
    def canary_size(self, value: Optional[pulumi.Input['EndpointCapacitySizeArgs']]):
        pulumi.set(self, "canary_size", value)

    @property
    @pulumi.getter(name="linearStepSize")
    def linear_step_size(self) -> Optional[pulumi.Input['EndpointCapacitySizeArgs']]:
        """
        Specifies the step size for linear traffic routing.
        """
        return pulumi.get(self, "linear_step_size")

    @linear_step_size.setter
    def linear_step_size(self, value: Optional[pulumi.Input['EndpointCapacitySizeArgs']]):
        pulumi.set(self, "linear_step_size", value)

    @property
    @pulumi.getter(name="waitIntervalInSeconds")
    def wait_interval_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the wait interval between traffic shifts, in seconds.
        """
        return pulumi.get(self, "wait_interval_in_seconds")

    @wait_interval_in_seconds.setter
    def wait_interval_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "wait_interval_in_seconds", value)


if not MYPY:
    class EndpointVariantPropertyArgsDict(TypedDict):
        variant_property_type: NotRequired[pulumi.Input[str]]
        """
        The type of variant property (e.g., 'DesiredInstanceCount', 'DesiredWeight', 'DataCaptureConfig').
        """
elif False:
    EndpointVariantPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EndpointVariantPropertyArgs:
    def __init__(__self__, *,
                 variant_property_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] variant_property_type: The type of variant property (e.g., 'DesiredInstanceCount', 'DesiredWeight', 'DataCaptureConfig').
        """
        if variant_property_type is not None:
            pulumi.set(__self__, "variant_property_type", variant_property_type)

    @property
    @pulumi.getter(name="variantPropertyType")
    def variant_property_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of variant property (e.g., 'DesiredInstanceCount', 'DesiredWeight', 'DataCaptureConfig').
        """
        return pulumi.get(self, "variant_property_type")

    @variant_property_type.setter
    def variant_property_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "variant_property_type", value)


if not MYPY:
    class FeatureGroupDataCatalogConfigArgsDict(TypedDict):
        catalog: pulumi.Input[str]
        """
        The name of the Glue table catalog.
        """
        database: pulumi.Input[str]
        """
        The name of the Glue table database.
        """
        table_name: pulumi.Input[str]
        """
        The name of the Glue table.
        """
elif False:
    FeatureGroupDataCatalogConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureGroupDataCatalogConfigArgs:
    def __init__(__self__, *,
                 catalog: pulumi.Input[str],
                 database: pulumi.Input[str],
                 table_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] catalog: The name of the Glue table catalog.
        :param pulumi.Input[str] database: The name of the Glue table database.
        :param pulumi.Input[str] table_name: The name of the Glue table.
        """
        pulumi.set(__self__, "catalog", catalog)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter
    def catalog(self) -> pulumi.Input[str]:
        """
        The name of the Glue table catalog.
        """
        return pulumi.get(self, "catalog")

    @catalog.setter
    def catalog(self, value: pulumi.Input[str]):
        pulumi.set(self, "catalog", value)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[str]:
        """
        The name of the Glue table database.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[str]:
        """
        The name of the Glue table.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "table_name", value)


if not MYPY:
    class FeatureGroupFeatureDefinitionArgsDict(TypedDict):
        feature_name: pulumi.Input[str]
        """
        The name of a feature. The type must be a string. `FeatureName` cannot be any of the following: `is_deleted` , `write_time` , `api_invocation_time` .

        The name:

        - Must start with an alphanumeric character.
        - Can only include alphanumeric characters, underscores, and hyphens. Spaces are not allowed.
        """
        feature_type: pulumi.Input['FeatureGroupFeatureDefinitionFeatureType']
        """
        The value type of a feature. Valid values are Integral, Fractional, or String.
        """
elif False:
    FeatureGroupFeatureDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureGroupFeatureDefinitionArgs:
    def __init__(__self__, *,
                 feature_name: pulumi.Input[str],
                 feature_type: pulumi.Input['FeatureGroupFeatureDefinitionFeatureType']):
        """
        :param pulumi.Input[str] feature_name: The name of a feature. The type must be a string. `FeatureName` cannot be any of the following: `is_deleted` , `write_time` , `api_invocation_time` .
               
               The name:
               
               - Must start with an alphanumeric character.
               - Can only include alphanumeric characters, underscores, and hyphens. Spaces are not allowed.
        :param pulumi.Input['FeatureGroupFeatureDefinitionFeatureType'] feature_type: The value type of a feature. Valid values are Integral, Fractional, or String.
        """
        pulumi.set(__self__, "feature_name", feature_name)
        pulumi.set(__self__, "feature_type", feature_type)

    @property
    @pulumi.getter(name="featureName")
    def feature_name(self) -> pulumi.Input[str]:
        """
        The name of a feature. The type must be a string. `FeatureName` cannot be any of the following: `is_deleted` , `write_time` , `api_invocation_time` .

        The name:

        - Must start with an alphanumeric character.
        - Can only include alphanumeric characters, underscores, and hyphens. Spaces are not allowed.
        """
        return pulumi.get(self, "feature_name")

    @feature_name.setter
    def feature_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "feature_name", value)

    @property
    @pulumi.getter(name="featureType")
    def feature_type(self) -> pulumi.Input['FeatureGroupFeatureDefinitionFeatureType']:
        """
        The value type of a feature. Valid values are Integral, Fractional, or String.
        """
        return pulumi.get(self, "feature_type")

    @feature_type.setter
    def feature_type(self, value: pulumi.Input['FeatureGroupFeatureDefinitionFeatureType']):
        pulumi.set(self, "feature_type", value)


if not MYPY:
    class FeatureGroupOnlineStoreSecurityConfigArgsDict(TypedDict):
        kms_key_id: NotRequired[pulumi.Input[str]]
        """
        The AWS Key Management Service (KMS) key ARN that SageMaker Feature Store uses to encrypt the Amazon S3 objects at rest using Amazon S3 server-side encryption.

        The caller (either user or IAM role) of `CreateFeatureGroup` must have below permissions to the `OnlineStore` `KmsKeyId` :

        - `"kms:Encrypt"`
        - `"kms:Decrypt"`
        - `"kms:DescribeKey"`
        - `"kms:CreateGrant"`
        - `"kms:RetireGrant"`
        - `"kms:ReEncryptFrom"`
        - `"kms:ReEncryptTo"`
        - `"kms:GenerateDataKey"`
        - `"kms:ListAliases"`
        - `"kms:ListGrants"`
        - `"kms:RevokeGrant"`

        The caller (either user or IAM role) to all DataPlane operations ( `PutRecord` , `GetRecord` , `DeleteRecord` ) must have the following permissions to the `KmsKeyId` :

        - `"kms:Decrypt"`
        """
elif False:
    FeatureGroupOnlineStoreSecurityConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureGroupOnlineStoreSecurityConfigArgs:
    def __init__(__self__, *,
                 kms_key_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kms_key_id: The AWS Key Management Service (KMS) key ARN that SageMaker Feature Store uses to encrypt the Amazon S3 objects at rest using Amazon S3 server-side encryption.
               
               The caller (either user or IAM role) of `CreateFeatureGroup` must have below permissions to the `OnlineStore` `KmsKeyId` :
               
               - `"kms:Encrypt"`
               - `"kms:Decrypt"`
               - `"kms:DescribeKey"`
               - `"kms:CreateGrant"`
               - `"kms:RetireGrant"`
               - `"kms:ReEncryptFrom"`
               - `"kms:ReEncryptTo"`
               - `"kms:GenerateDataKey"`
               - `"kms:ListAliases"`
               - `"kms:ListGrants"`
               - `"kms:RevokeGrant"`
               
               The caller (either user or IAM role) to all DataPlane operations ( `PutRecord` , `GetRecord` , `DeleteRecord` ) must have the following permissions to the `KmsKeyId` :
               
               - `"kms:Decrypt"`
        """
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The AWS Key Management Service (KMS) key ARN that SageMaker Feature Store uses to encrypt the Amazon S3 objects at rest using Amazon S3 server-side encryption.

        The caller (either user or IAM role) of `CreateFeatureGroup` must have below permissions to the `OnlineStore` `KmsKeyId` :

        - `"kms:Encrypt"`
        - `"kms:Decrypt"`
        - `"kms:DescribeKey"`
        - `"kms:CreateGrant"`
        - `"kms:RetireGrant"`
        - `"kms:ReEncryptFrom"`
        - `"kms:ReEncryptTo"`
        - `"kms:GenerateDataKey"`
        - `"kms:ListAliases"`
        - `"kms:ListGrants"`
        - `"kms:RevokeGrant"`

        The caller (either user or IAM role) to all DataPlane operations ( `PutRecord` , `GetRecord` , `DeleteRecord` ) must have the following permissions to the `KmsKeyId` :

        - `"kms:Decrypt"`
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)


if not MYPY:
    class FeatureGroupS3StorageConfigArgsDict(TypedDict):
        s3_uri: pulumi.Input[str]
        """
        The S3 URI, or location in Amazon S3, of `OfflineStore` .

        S3 URIs have a format similar to the following: `s3://example-bucket/prefix/` .
        """
        kms_key_id: NotRequired[pulumi.Input[str]]
        """
        The AWS Key Management Service (KMS) key ARN of the key used to encrypt any objects written into the `OfflineStore` S3 location.

        The IAM `roleARN` that is passed as a parameter to `CreateFeatureGroup` must have below permissions to the `KmsKeyId` :

        - `"kms:GenerateDataKey"`
        """
elif False:
    FeatureGroupS3StorageConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureGroupS3StorageConfigArgs:
    def __init__(__self__, *,
                 s3_uri: pulumi.Input[str],
                 kms_key_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] s3_uri: The S3 URI, or location in Amazon S3, of `OfflineStore` .
               
               S3 URIs have a format similar to the following: `s3://example-bucket/prefix/` .
        :param pulumi.Input[str] kms_key_id: The AWS Key Management Service (KMS) key ARN of the key used to encrypt any objects written into the `OfflineStore` S3 location.
               
               The IAM `roleARN` that is passed as a parameter to `CreateFeatureGroup` must have below permissions to the `KmsKeyId` :
               
               - `"kms:GenerateDataKey"`
        """
        pulumi.set(__self__, "s3_uri", s3_uri)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)

    @property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> pulumi.Input[str]:
        """
        The S3 URI, or location in Amazon S3, of `OfflineStore` .

        S3 URIs have a format similar to the following: `s3://example-bucket/prefix/` .
        """
        return pulumi.get(self, "s3_uri")

    @s3_uri.setter
    def s3_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_uri", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The AWS Key Management Service (KMS) key ARN of the key used to encrypt any objects written into the `OfflineStore` S3 location.

        The IAM `roleARN` that is passed as a parameter to `CreateFeatureGroup` must have below permissions to the `KmsKeyId` :

        - `"kms:GenerateDataKey"`
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)


if not MYPY:
    class FeatureGroupThroughputConfigArgsDict(TypedDict):
        throughput_mode: pulumi.Input['FeatureGroupThroughputMode']
        """
        The mode used for your feature group throughput: `ON_DEMAND` or `PROVISIONED` .
        """
        provisioned_read_capacity_units: NotRequired[pulumi.Input[int]]
        """
        For provisioned feature groups with online store enabled, this indicates the read throughput you are billed for and can consume without throttling.
        """
        provisioned_write_capacity_units: NotRequired[pulumi.Input[int]]
        """
        For provisioned feature groups, this indicates the write throughput you are billed for and can consume without throttling.
        """
elif False:
    FeatureGroupThroughputConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureGroupThroughputConfigArgs:
    def __init__(__self__, *,
                 throughput_mode: pulumi.Input['FeatureGroupThroughputMode'],
                 provisioned_read_capacity_units: Optional[pulumi.Input[int]] = None,
                 provisioned_write_capacity_units: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input['FeatureGroupThroughputMode'] throughput_mode: The mode used for your feature group throughput: `ON_DEMAND` or `PROVISIONED` .
        :param pulumi.Input[int] provisioned_read_capacity_units: For provisioned feature groups with online store enabled, this indicates the read throughput you are billed for and can consume without throttling.
        :param pulumi.Input[int] provisioned_write_capacity_units: For provisioned feature groups, this indicates the write throughput you are billed for and can consume without throttling.
        """
        pulumi.set(__self__, "throughput_mode", throughput_mode)
        if provisioned_read_capacity_units is not None:
            pulumi.set(__self__, "provisioned_read_capacity_units", provisioned_read_capacity_units)
        if provisioned_write_capacity_units is not None:
            pulumi.set(__self__, "provisioned_write_capacity_units", provisioned_write_capacity_units)

    @property
    @pulumi.getter(name="throughputMode")
    def throughput_mode(self) -> pulumi.Input['FeatureGroupThroughputMode']:
        """
        The mode used for your feature group throughput: `ON_DEMAND` or `PROVISIONED` .
        """
        return pulumi.get(self, "throughput_mode")

    @throughput_mode.setter
    def throughput_mode(self, value: pulumi.Input['FeatureGroupThroughputMode']):
        pulumi.set(self, "throughput_mode", value)

    @property
    @pulumi.getter(name="provisionedReadCapacityUnits")
    def provisioned_read_capacity_units(self) -> Optional[pulumi.Input[int]]:
        """
        For provisioned feature groups with online store enabled, this indicates the read throughput you are billed for and can consume without throttling.
        """
        return pulumi.get(self, "provisioned_read_capacity_units")

    @provisioned_read_capacity_units.setter
    def provisioned_read_capacity_units(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "provisioned_read_capacity_units", value)

    @property
    @pulumi.getter(name="provisionedWriteCapacityUnits")
    def provisioned_write_capacity_units(self) -> Optional[pulumi.Input[int]]:
        """
        For provisioned feature groups, this indicates the write throughput you are billed for and can consume without throttling.
        """
        return pulumi.get(self, "provisioned_write_capacity_units")

    @provisioned_write_capacity_units.setter
    def provisioned_write_capacity_units(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "provisioned_write_capacity_units", value)


if not MYPY:
    class FeatureGroupTtlDurationArgsDict(TypedDict):
        """
        TTL configuration of the feature group
        """
        unit: NotRequired[pulumi.Input['FeatureGroupUnit']]
        """
        `TtlDuration` time unit.
        """
        value: NotRequired[pulumi.Input[int]]
        """
        `TtlDuration` time value.
        """
elif False:
    FeatureGroupTtlDurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureGroupTtlDurationArgs:
    def __init__(__self__, *,
                 unit: Optional[pulumi.Input['FeatureGroupUnit']] = None,
                 value: Optional[pulumi.Input[int]] = None):
        """
        TTL configuration of the feature group
        :param pulumi.Input['FeatureGroupUnit'] unit: `TtlDuration` time unit.
        :param pulumi.Input[int] value: `TtlDuration` time value.
        """
        if unit is not None:
            pulumi.set(__self__, "unit", unit)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input['FeatureGroupUnit']]:
        """
        `TtlDuration` time unit.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input['FeatureGroupUnit']]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[int]]:
        """
        `TtlDuration` time value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class InferenceComponentComputeResourceRequirementsArgsDict(TypedDict):
        max_memory_required_in_mb: NotRequired[pulumi.Input[int]]
        """
        The maximum MB of memory to allocate to run a model that you assign to an inference component.
        """
        min_memory_required_in_mb: NotRequired[pulumi.Input[int]]
        """
        The minimum MB of memory to allocate to run a model that you assign to an inference component.
        """
        number_of_accelerator_devices_required: NotRequired[pulumi.Input[float]]
        """
        The number of accelerators to allocate to run a model that you assign to an inference component. Accelerators include GPUs and AWS Inferentia.
        """
        number_of_cpu_cores_required: NotRequired[pulumi.Input[float]]
        """
        The number of CPU cores to allocate to run a model that you assign to an inference component.
        """
elif False:
    InferenceComponentComputeResourceRequirementsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InferenceComponentComputeResourceRequirementsArgs:
    def __init__(__self__, *,
                 max_memory_required_in_mb: Optional[pulumi.Input[int]] = None,
                 min_memory_required_in_mb: Optional[pulumi.Input[int]] = None,
                 number_of_accelerator_devices_required: Optional[pulumi.Input[float]] = None,
                 number_of_cpu_cores_required: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[int] max_memory_required_in_mb: The maximum MB of memory to allocate to run a model that you assign to an inference component.
        :param pulumi.Input[int] min_memory_required_in_mb: The minimum MB of memory to allocate to run a model that you assign to an inference component.
        :param pulumi.Input[float] number_of_accelerator_devices_required: The number of accelerators to allocate to run a model that you assign to an inference component. Accelerators include GPUs and AWS Inferentia.
        :param pulumi.Input[float] number_of_cpu_cores_required: The number of CPU cores to allocate to run a model that you assign to an inference component.
        """
        if max_memory_required_in_mb is not None:
            pulumi.set(__self__, "max_memory_required_in_mb", max_memory_required_in_mb)
        if min_memory_required_in_mb is not None:
            pulumi.set(__self__, "min_memory_required_in_mb", min_memory_required_in_mb)
        if number_of_accelerator_devices_required is not None:
            pulumi.set(__self__, "number_of_accelerator_devices_required", number_of_accelerator_devices_required)
        if number_of_cpu_cores_required is not None:
            pulumi.set(__self__, "number_of_cpu_cores_required", number_of_cpu_cores_required)

    @property
    @pulumi.getter(name="maxMemoryRequiredInMb")
    def max_memory_required_in_mb(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum MB of memory to allocate to run a model that you assign to an inference component.
        """
        return pulumi.get(self, "max_memory_required_in_mb")

    @max_memory_required_in_mb.setter
    def max_memory_required_in_mb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_memory_required_in_mb", value)

    @property
    @pulumi.getter(name="minMemoryRequiredInMb")
    def min_memory_required_in_mb(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum MB of memory to allocate to run a model that you assign to an inference component.
        """
        return pulumi.get(self, "min_memory_required_in_mb")

    @min_memory_required_in_mb.setter
    def min_memory_required_in_mb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_memory_required_in_mb", value)

    @property
    @pulumi.getter(name="numberOfAcceleratorDevicesRequired")
    def number_of_accelerator_devices_required(self) -> Optional[pulumi.Input[float]]:
        """
        The number of accelerators to allocate to run a model that you assign to an inference component. Accelerators include GPUs and AWS Inferentia.
        """
        return pulumi.get(self, "number_of_accelerator_devices_required")

    @number_of_accelerator_devices_required.setter
    def number_of_accelerator_devices_required(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "number_of_accelerator_devices_required", value)

    @property
    @pulumi.getter(name="numberOfCpuCoresRequired")
    def number_of_cpu_cores_required(self) -> Optional[pulumi.Input[float]]:
        """
        The number of CPU cores to allocate to run a model that you assign to an inference component.
        """
        return pulumi.get(self, "number_of_cpu_cores_required")

    @number_of_cpu_cores_required.setter
    def number_of_cpu_cores_required(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "number_of_cpu_cores_required", value)


if not MYPY:
    class InferenceComponentContainerSpecificationArgsDict(TypedDict):
        artifact_url: NotRequired[pulumi.Input[str]]
        """
        The Amazon S3 path where the model artifacts, which result from model training, are stored. This path must point to a single gzip compressed tar archive (.tar.gz suffix).
        """
        deployed_image: NotRequired[pulumi.Input['InferenceComponentDeployedImageArgsDict']]
        environment: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        The environment variables to set in the Docker container. Each key and value in the Environment string-to-string map can have length of up to 1024. We support up to 16 entries in the map.
        """
        image: NotRequired[pulumi.Input[str]]
        """
        The Amazon Elastic Container Registry (Amazon ECR) path where the Docker image for the model is stored.
        """
elif False:
    InferenceComponentContainerSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InferenceComponentContainerSpecificationArgs:
    def __init__(__self__, *,
                 artifact_url: Optional[pulumi.Input[str]] = None,
                 deployed_image: Optional[pulumi.Input['InferenceComponentDeployedImageArgs']] = None,
                 environment: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 image: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] artifact_url: The Amazon S3 path where the model artifacts, which result from model training, are stored. This path must point to a single gzip compressed tar archive (.tar.gz suffix).
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] environment: The environment variables to set in the Docker container. Each key and value in the Environment string-to-string map can have length of up to 1024. We support up to 16 entries in the map.
        :param pulumi.Input[str] image: The Amazon Elastic Container Registry (Amazon ECR) path where the Docker image for the model is stored.
        """
        if artifact_url is not None:
            pulumi.set(__self__, "artifact_url", artifact_url)
        if deployed_image is not None:
            pulumi.set(__self__, "deployed_image", deployed_image)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if image is not None:
            pulumi.set(__self__, "image", image)

    @property
    @pulumi.getter(name="artifactUrl")
    def artifact_url(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon S3 path where the model artifacts, which result from model training, are stored. This path must point to a single gzip compressed tar archive (.tar.gz suffix).
        """
        return pulumi.get(self, "artifact_url")

    @artifact_url.setter
    def artifact_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "artifact_url", value)

    @property
    @pulumi.getter(name="deployedImage")
    def deployed_image(self) -> Optional[pulumi.Input['InferenceComponentDeployedImageArgs']]:
        return pulumi.get(self, "deployed_image")

    @deployed_image.setter
    def deployed_image(self, value: Optional[pulumi.Input['InferenceComponentDeployedImageArgs']]):
        pulumi.set(self, "deployed_image", value)

    @property
    @pulumi.getter
    def environment(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The environment variables to set in the Docker container. Each key and value in the Environment string-to-string map can have length of up to 1024. We support up to 16 entries in the map.
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "environment", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon Elastic Container Registry (Amazon ECR) path where the Docker image for the model is stored.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)


if not MYPY:
    class InferenceComponentDeployedImageArgsDict(TypedDict):
        resolution_time: NotRequired[pulumi.Input[str]]
        """
        The date and time when the image path for the model resolved to the `ResolvedImage`
        """
        resolved_image: NotRequired[pulumi.Input[str]]
        """
        The specific digest path of the image hosted in this `ProductionVariant` .
        """
        specified_image: NotRequired[pulumi.Input[str]]
        """
        The image path you specified when you created the model.
        """
elif False:
    InferenceComponentDeployedImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InferenceComponentDeployedImageArgs:
    def __init__(__self__, *,
                 resolution_time: Optional[pulumi.Input[str]] = None,
                 resolved_image: Optional[pulumi.Input[str]] = None,
                 specified_image: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] resolution_time: The date and time when the image path for the model resolved to the `ResolvedImage`
        :param pulumi.Input[str] resolved_image: The specific digest path of the image hosted in this `ProductionVariant` .
        :param pulumi.Input[str] specified_image: The image path you specified when you created the model.
        """
        if resolution_time is not None:
            pulumi.set(__self__, "resolution_time", resolution_time)
        if resolved_image is not None:
            pulumi.set(__self__, "resolved_image", resolved_image)
        if specified_image is not None:
            pulumi.set(__self__, "specified_image", specified_image)

    @property
    @pulumi.getter(name="resolutionTime")
    def resolution_time(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time when the image path for the model resolved to the `ResolvedImage`
        """
        return pulumi.get(self, "resolution_time")

    @resolution_time.setter
    def resolution_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resolution_time", value)

    @property
    @pulumi.getter(name="resolvedImage")
    def resolved_image(self) -> Optional[pulumi.Input[str]]:
        """
        The specific digest path of the image hosted in this `ProductionVariant` .
        """
        return pulumi.get(self, "resolved_image")

    @resolved_image.setter
    def resolved_image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resolved_image", value)

    @property
    @pulumi.getter(name="specifiedImage")
    def specified_image(self) -> Optional[pulumi.Input[str]]:
        """
        The image path you specified when you created the model.
        """
        return pulumi.get(self, "specified_image")

    @specified_image.setter
    def specified_image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "specified_image", value)


if not MYPY:
    class InferenceComponentRuntimeConfigArgsDict(TypedDict):
        """
        The runtime config for the inference component
        """
        copy_count: NotRequired[pulumi.Input[int]]
        """
        The number of runtime copies of the model container to deploy with the inference component. Each copy can serve inference requests.
        """
        current_copy_count: NotRequired[pulumi.Input[int]]
        desired_copy_count: NotRequired[pulumi.Input[int]]
elif False:
    InferenceComponentRuntimeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InferenceComponentRuntimeConfigArgs:
    def __init__(__self__, *,
                 copy_count: Optional[pulumi.Input[int]] = None,
                 current_copy_count: Optional[pulumi.Input[int]] = None,
                 desired_copy_count: Optional[pulumi.Input[int]] = None):
        """
        The runtime config for the inference component
        :param pulumi.Input[int] copy_count: The number of runtime copies of the model container to deploy with the inference component. Each copy can serve inference requests.
        """
        if copy_count is not None:
            pulumi.set(__self__, "copy_count", copy_count)
        if current_copy_count is not None:
            pulumi.set(__self__, "current_copy_count", current_copy_count)
        if desired_copy_count is not None:
            pulumi.set(__self__, "desired_copy_count", desired_copy_count)

    @property
    @pulumi.getter(name="copyCount")
    def copy_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of runtime copies of the model container to deploy with the inference component. Each copy can serve inference requests.
        """
        return pulumi.get(self, "copy_count")

    @copy_count.setter
    def copy_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "copy_count", value)

    @property
    @pulumi.getter(name="currentCopyCount")
    def current_copy_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "current_copy_count")

    @current_copy_count.setter
    def current_copy_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "current_copy_count", value)

    @property
    @pulumi.getter(name="desiredCopyCount")
    def desired_copy_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "desired_copy_count")

    @desired_copy_count.setter
    def desired_copy_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "desired_copy_count", value)


if not MYPY:
    class InferenceComponentSpecificationArgsDict(TypedDict):
        """
        The specification for the inference component
        """
        base_inference_component_name: NotRequired[pulumi.Input[str]]
        """
        The name of an existing inference component that is to contain the inference component that you're creating with your request.

        Specify this parameter only if your request is meant to create an adapter inference component. An adapter inference component contains the path to an adapter model. The purpose of the adapter model is to tailor the inference output of a base foundation model, which is hosted by the base inference component. The adapter inference component uses the compute resources that you assigned to the base inference component.

        When you create an adapter inference component, use the `Container` parameter to specify the location of the adapter artifacts. In the parameter value, use the `ArtifactUrl` parameter of the `InferenceComponentContainerSpecification` data type.

        Before you can create an adapter inference component, you must have an existing inference component that contains the foundation model that you want to adapt.
        """
        compute_resource_requirements: NotRequired[pulumi.Input['InferenceComponentComputeResourceRequirementsArgsDict']]
        """
        The compute resources allocated to run the model, plus any adapter models, that you assign to the inference component.

        Omit this parameter if your request is meant to create an adapter inference component. An adapter inference component is loaded by a base inference component, and it uses the compute resources of the base inference component.
        """
        container: NotRequired[pulumi.Input['InferenceComponentContainerSpecificationArgsDict']]
        """
        Defines a container that provides the runtime environment for a model that you deploy with an inference component.
        """
        model_name: NotRequired[pulumi.Input[str]]
        """
        The name of an existing SageMaker model object in your account that you want to deploy with the inference component.
        """
        startup_parameters: NotRequired[pulumi.Input['InferenceComponentStartupParametersArgsDict']]
        """
        Settings that take effect while the model container starts up.
        """
elif False:
    InferenceComponentSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InferenceComponentSpecificationArgs:
    def __init__(__self__, *,
                 base_inference_component_name: Optional[pulumi.Input[str]] = None,
                 compute_resource_requirements: Optional[pulumi.Input['InferenceComponentComputeResourceRequirementsArgs']] = None,
                 container: Optional[pulumi.Input['InferenceComponentContainerSpecificationArgs']] = None,
                 model_name: Optional[pulumi.Input[str]] = None,
                 startup_parameters: Optional[pulumi.Input['InferenceComponentStartupParametersArgs']] = None):
        """
        The specification for the inference component
        :param pulumi.Input[str] base_inference_component_name: The name of an existing inference component that is to contain the inference component that you're creating with your request.
               
               Specify this parameter only if your request is meant to create an adapter inference component. An adapter inference component contains the path to an adapter model. The purpose of the adapter model is to tailor the inference output of a base foundation model, which is hosted by the base inference component. The adapter inference component uses the compute resources that you assigned to the base inference component.
               
               When you create an adapter inference component, use the `Container` parameter to specify the location of the adapter artifacts. In the parameter value, use the `ArtifactUrl` parameter of the `InferenceComponentContainerSpecification` data type.
               
               Before you can create an adapter inference component, you must have an existing inference component that contains the foundation model that you want to adapt.
        :param pulumi.Input['InferenceComponentComputeResourceRequirementsArgs'] compute_resource_requirements: The compute resources allocated to run the model, plus any adapter models, that you assign to the inference component.
               
               Omit this parameter if your request is meant to create an adapter inference component. An adapter inference component is loaded by a base inference component, and it uses the compute resources of the base inference component.
        :param pulumi.Input['InferenceComponentContainerSpecificationArgs'] container: Defines a container that provides the runtime environment for a model that you deploy with an inference component.
        :param pulumi.Input[str] model_name: The name of an existing SageMaker model object in your account that you want to deploy with the inference component.
        :param pulumi.Input['InferenceComponentStartupParametersArgs'] startup_parameters: Settings that take effect while the model container starts up.
        """
        if base_inference_component_name is not None:
            pulumi.set(__self__, "base_inference_component_name", base_inference_component_name)
        if compute_resource_requirements is not None:
            pulumi.set(__self__, "compute_resource_requirements", compute_resource_requirements)
        if container is not None:
            pulumi.set(__self__, "container", container)
        if model_name is not None:
            pulumi.set(__self__, "model_name", model_name)
        if startup_parameters is not None:
            pulumi.set(__self__, "startup_parameters", startup_parameters)

    @property
    @pulumi.getter(name="baseInferenceComponentName")
    def base_inference_component_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of an existing inference component that is to contain the inference component that you're creating with your request.

        Specify this parameter only if your request is meant to create an adapter inference component. An adapter inference component contains the path to an adapter model. The purpose of the adapter model is to tailor the inference output of a base foundation model, which is hosted by the base inference component. The adapter inference component uses the compute resources that you assigned to the base inference component.

        When you create an adapter inference component, use the `Container` parameter to specify the location of the adapter artifacts. In the parameter value, use the `ArtifactUrl` parameter of the `InferenceComponentContainerSpecification` data type.

        Before you can create an adapter inference component, you must have an existing inference component that contains the foundation model that you want to adapt.
        """
        return pulumi.get(self, "base_inference_component_name")

    @base_inference_component_name.setter
    def base_inference_component_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "base_inference_component_name", value)

    @property
    @pulumi.getter(name="computeResourceRequirements")
    def compute_resource_requirements(self) -> Optional[pulumi.Input['InferenceComponentComputeResourceRequirementsArgs']]:
        """
        The compute resources allocated to run the model, plus any adapter models, that you assign to the inference component.

        Omit this parameter if your request is meant to create an adapter inference component. An adapter inference component is loaded by a base inference component, and it uses the compute resources of the base inference component.
        """
        return pulumi.get(self, "compute_resource_requirements")

    @compute_resource_requirements.setter
    def compute_resource_requirements(self, value: Optional[pulumi.Input['InferenceComponentComputeResourceRequirementsArgs']]):
        pulumi.set(self, "compute_resource_requirements", value)

    @property
    @pulumi.getter
    def container(self) -> Optional[pulumi.Input['InferenceComponentContainerSpecificationArgs']]:
        """
        Defines a container that provides the runtime environment for a model that you deploy with an inference component.
        """
        return pulumi.get(self, "container")

    @container.setter
    def container(self, value: Optional[pulumi.Input['InferenceComponentContainerSpecificationArgs']]):
        pulumi.set(self, "container", value)

    @property
    @pulumi.getter(name="modelName")
    def model_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of an existing SageMaker model object in your account that you want to deploy with the inference component.
        """
        return pulumi.get(self, "model_name")

    @model_name.setter
    def model_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "model_name", value)

    @property
    @pulumi.getter(name="startupParameters")
    def startup_parameters(self) -> Optional[pulumi.Input['InferenceComponentStartupParametersArgs']]:
        """
        Settings that take effect while the model container starts up.
        """
        return pulumi.get(self, "startup_parameters")

    @startup_parameters.setter
    def startup_parameters(self, value: Optional[pulumi.Input['InferenceComponentStartupParametersArgs']]):
        pulumi.set(self, "startup_parameters", value)


if not MYPY:
    class InferenceComponentStartupParametersArgsDict(TypedDict):
        container_startup_health_check_timeout_in_seconds: NotRequired[pulumi.Input[int]]
        """
        The timeout value, in seconds, for your inference container to pass health check by Amazon S3 Hosting. For more information about health check, see [How Your Container Should Respond to Health Check (Ping) Requests](https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms-inference-code.html#your-algorithms-inference-algo-ping-requests) .
        """
        model_data_download_timeout_in_seconds: NotRequired[pulumi.Input[int]]
        """
        The timeout value, in seconds, to download and extract the model that you want to host from Amazon S3 to the individual inference instance associated with this inference component.
        """
elif False:
    InferenceComponentStartupParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InferenceComponentStartupParametersArgs:
    def __init__(__self__, *,
                 container_startup_health_check_timeout_in_seconds: Optional[pulumi.Input[int]] = None,
                 model_data_download_timeout_in_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] container_startup_health_check_timeout_in_seconds: The timeout value, in seconds, for your inference container to pass health check by Amazon S3 Hosting. For more information about health check, see [How Your Container Should Respond to Health Check (Ping) Requests](https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms-inference-code.html#your-algorithms-inference-algo-ping-requests) .
        :param pulumi.Input[int] model_data_download_timeout_in_seconds: The timeout value, in seconds, to download and extract the model that you want to host from Amazon S3 to the individual inference instance associated with this inference component.
        """
        if container_startup_health_check_timeout_in_seconds is not None:
            pulumi.set(__self__, "container_startup_health_check_timeout_in_seconds", container_startup_health_check_timeout_in_seconds)
        if model_data_download_timeout_in_seconds is not None:
            pulumi.set(__self__, "model_data_download_timeout_in_seconds", model_data_download_timeout_in_seconds)

    @property
    @pulumi.getter(name="containerStartupHealthCheckTimeoutInSeconds")
    def container_startup_health_check_timeout_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout value, in seconds, for your inference container to pass health check by Amazon S3 Hosting. For more information about health check, see [How Your Container Should Respond to Health Check (Ping) Requests](https://docs.aws.amazon.com/sagemaker/latest/dg/your-algorithms-inference-code.html#your-algorithms-inference-algo-ping-requests) .
        """
        return pulumi.get(self, "container_startup_health_check_timeout_in_seconds")

    @container_startup_health_check_timeout_in_seconds.setter
    def container_startup_health_check_timeout_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "container_startup_health_check_timeout_in_seconds", value)

    @property
    @pulumi.getter(name="modelDataDownloadTimeoutInSeconds")
    def model_data_download_timeout_in_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The timeout value, in seconds, to download and extract the model that you want to host from Amazon S3 to the individual inference instance associated with this inference component.
        """
        return pulumi.get(self, "model_data_download_timeout_in_seconds")

    @model_data_download_timeout_in_seconds.setter
    def model_data_download_timeout_in_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "model_data_download_timeout_in_seconds", value)


if not MYPY:
    class InferenceExperimentCaptureContentTypeHeaderArgsDict(TypedDict):
        """
        Configuration specifying how to treat different headers. If no headers are specified SageMaker will by default base64 encode when capturing the data.
        """
        csv_content_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of all content type headers that SageMaker will treat as CSV and capture accordingly.
        """
        json_content_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The list of all content type headers that SageMaker will treat as JSON and capture accordingly.
        """
elif False:
    InferenceExperimentCaptureContentTypeHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InferenceExperimentCaptureContentTypeHeaderArgs:
    def __init__(__self__, *,
                 csv_content_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 json_content_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Configuration specifying how to treat different headers. If no headers are specified SageMaker will by default base64 encode when capturing the data.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] csv_content_types: The list of all content type headers that SageMaker will treat as CSV and capture accordingly.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] json_content_types: The list of all content type headers that SageMaker will treat as JSON and capture accordingly.
        """
        if csv_content_types is not None:
            pulumi.set(__self__, "csv_content_types", csv_content_types)
        if json_content_types is not None:
            pulumi.set(__self__, "json_content_types", json_content_types)

    @property
    @pulumi.getter(name="csvContentTypes")
    def csv_content_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of all content type headers that SageMaker will treat as CSV and capture accordingly.
        """
        return pulumi.get(self, "csv_content_types")

    @csv_content_types.setter
    def csv_content_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "csv_content_types", value)

    @property
    @pulumi.getter(name="jsonContentTypes")
    def json_content_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of all content type headers that SageMaker will treat as JSON and capture accordingly.
        """
        return pulumi.get(self, "json_content_types")

    @json_content_types.setter
    def json_content_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "json_content_types", value)


if not MYPY:
    class InferenceExperimentDataStorageConfigArgsDict(TypedDict):
        """
        The Amazon S3 location and configuration for storing inference request and response data.
        """
        destination: pulumi.Input[str]
        """
        The Amazon S3 bucket where the inference request and response data is stored.
        """
        content_type: NotRequired[pulumi.Input['InferenceExperimentCaptureContentTypeHeaderArgsDict']]
        """
        Configuration specifying how to treat different headers. If no headers are specified SageMaker will by default base64 encode when capturing the data.
        """
        kms_key: NotRequired[pulumi.Input[str]]
        """
        The AWS Key Management Service key that Amazon SageMaker uses to encrypt captured data at rest using Amazon S3 server-side encryption.
        """
elif False:
    InferenceExperimentDataStorageConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InferenceExperimentDataStorageConfigArgs:
    def __init__(__self__, *,
                 destination: pulumi.Input[str],
                 content_type: Optional[pulumi.Input['InferenceExperimentCaptureContentTypeHeaderArgs']] = None,
                 kms_key: Optional[pulumi.Input[str]] = None):
        """
        The Amazon S3 location and configuration for storing inference request and response data.
        :param pulumi.Input[str] destination: The Amazon S3 bucket where the inference request and response data is stored.
        :param pulumi.Input['InferenceExperimentCaptureContentTypeHeaderArgs'] content_type: Configuration specifying how to treat different headers. If no headers are specified SageMaker will by default base64 encode when capturing the data.
        :param pulumi.Input[str] kms_key: The AWS Key Management Service key that Amazon SageMaker uses to encrypt captured data at rest using Amazon S3 server-side encryption.
        """
        pulumi.set(__self__, "destination", destination)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)

    @property
    @pulumi.getter
    def destination(self) -> pulumi.Input[str]:
        """
        The Amazon S3 bucket where the inference request and response data is stored.
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input['InferenceExperimentCaptureContentTypeHeaderArgs']]:
        """
        Configuration specifying how to treat different headers. If no headers are specified SageMaker will by default base64 encode when capturing the data.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input['InferenceExperimentCaptureContentTypeHeaderArgs']]):
        pulumi.set(self, "content_type", value)

    @property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[pulumi.Input[str]]:
        """
        The AWS Key Management Service key that Amazon SageMaker uses to encrypt captured data at rest using Amazon S3 server-side encryption.
        """
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key", value)


if not MYPY:
    class InferenceExperimentModelInfrastructureConfigArgsDict(TypedDict):
        """
        The configuration for the infrastructure that the model will be deployed to.
        """
        infrastructure_type: pulumi.Input['InferenceExperimentModelInfrastructureConfigInfrastructureType']
        """
        The type of the inference experiment that you want to run.
        """
        real_time_inference_config: pulumi.Input['InferenceExperimentRealTimeInferenceConfigArgsDict']
        """
        The infrastructure configuration for deploying the model to real-time inference.
        """
elif False:
    InferenceExperimentModelInfrastructureConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InferenceExperimentModelInfrastructureConfigArgs:
    def __init__(__self__, *,
                 infrastructure_type: pulumi.Input['InferenceExperimentModelInfrastructureConfigInfrastructureType'],
                 real_time_inference_config: pulumi.Input['InferenceExperimentRealTimeInferenceConfigArgs']):
        """
        The configuration for the infrastructure that the model will be deployed to.
        :param pulumi.Input['InferenceExperimentModelInfrastructureConfigInfrastructureType'] infrastructure_type: The type of the inference experiment that you want to run.
        :param pulumi.Input['InferenceExperimentRealTimeInferenceConfigArgs'] real_time_inference_config: The infrastructure configuration for deploying the model to real-time inference.
        """
        pulumi.set(__self__, "infrastructure_type", infrastructure_type)
        pulumi.set(__self__, "real_time_inference_config", real_time_inference_config)

    @property
    @pulumi.getter(name="infrastructureType")
    def infrastructure_type(self) -> pulumi.Input['InferenceExperimentModelInfrastructureConfigInfrastructureType']:
        """
        The type of the inference experiment that you want to run.
        """
        return pulumi.get(self, "infrastructure_type")

    @infrastructure_type.setter
    def infrastructure_type(self, value: pulumi.Input['InferenceExperimentModelInfrastructureConfigInfrastructureType']):
        pulumi.set(self, "infrastructure_type", value)

    @property
    @pulumi.getter(name="realTimeInferenceConfig")
    def real_time_inference_config(self) -> pulumi.Input['InferenceExperimentRealTimeInferenceConfigArgs']:
        """
        The infrastructure configuration for deploying the model to real-time inference.
        """
        return pulumi.get(self, "real_time_inference_config")

    @real_time_inference_config.setter
    def real_time_inference_config(self, value: pulumi.Input['InferenceExperimentRealTimeInferenceConfigArgs']):
        pulumi.set(self, "real_time_inference_config", value)


if not MYPY:
    class InferenceExperimentModelVariantConfigArgsDict(TypedDict):
        """
        Contains information about the deployment options of a model.
        """
        infrastructure_config: pulumi.Input['InferenceExperimentModelInfrastructureConfigArgsDict']
        """
        The configuration for the infrastructure that the model will be deployed to.
        """
        model_name: pulumi.Input[str]
        """
        The name of the Amazon SageMaker Model entity.
        """
        variant_name: pulumi.Input[str]
        """
        The name of the variant.
        """
elif False:
    InferenceExperimentModelVariantConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InferenceExperimentModelVariantConfigArgs:
    def __init__(__self__, *,
                 infrastructure_config: pulumi.Input['InferenceExperimentModelInfrastructureConfigArgs'],
                 model_name: pulumi.Input[str],
                 variant_name: pulumi.Input[str]):
        """
        Contains information about the deployment options of a model.
        :param pulumi.Input['InferenceExperimentModelInfrastructureConfigArgs'] infrastructure_config: The configuration for the infrastructure that the model will be deployed to.
        :param pulumi.Input[str] model_name: The name of the Amazon SageMaker Model entity.
        :param pulumi.Input[str] variant_name: The name of the variant.
        """
        pulumi.set(__self__, "infrastructure_config", infrastructure_config)
        pulumi.set(__self__, "model_name", model_name)
        pulumi.set(__self__, "variant_name", variant_name)

    @property
    @pulumi.getter(name="infrastructureConfig")
    def infrastructure_config(self) -> pulumi.Input['InferenceExperimentModelInfrastructureConfigArgs']:
        """
        The configuration for the infrastructure that the model will be deployed to.
        """
        return pulumi.get(self, "infrastructure_config")

    @infrastructure_config.setter
    def infrastructure_config(self, value: pulumi.Input['InferenceExperimentModelInfrastructureConfigArgs']):
        pulumi.set(self, "infrastructure_config", value)

    @property
    @pulumi.getter(name="modelName")
    def model_name(self) -> pulumi.Input[str]:
        """
        The name of the Amazon SageMaker Model entity.
        """
        return pulumi.get(self, "model_name")

    @model_name.setter
    def model_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "model_name", value)

    @property
    @pulumi.getter(name="variantName")
    def variant_name(self) -> pulumi.Input[str]:
        """
        The name of the variant.
        """
        return pulumi.get(self, "variant_name")

    @variant_name.setter
    def variant_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "variant_name", value)


if not MYPY:
    class InferenceExperimentRealTimeInferenceConfigArgsDict(TypedDict):
        """
        The infrastructure configuration for deploying the model to a real-time inference endpoint.
        """
        instance_count: pulumi.Input[int]
        """
        The number of instances of the type specified by InstanceType.
        """
        instance_type: pulumi.Input[str]
        """
        The instance type the model is deployed to.
        """
elif False:
    InferenceExperimentRealTimeInferenceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InferenceExperimentRealTimeInferenceConfigArgs:
    def __init__(__self__, *,
                 instance_count: pulumi.Input[int],
                 instance_type: pulumi.Input[str]):
        """
        The infrastructure configuration for deploying the model to a real-time inference endpoint.
        :param pulumi.Input[int] instance_count: The number of instances of the type specified by InstanceType.
        :param pulumi.Input[str] instance_type: The instance type the model is deployed to.
        """
        pulumi.set(__self__, "instance_count", instance_count)
        pulumi.set(__self__, "instance_type", instance_type)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> pulumi.Input[int]:
        """
        The number of instances of the type specified by InstanceType.
        """
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "instance_count", value)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> pulumi.Input[str]:
        """
        The instance type the model is deployed to.
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance_type", value)


if not MYPY:
    class InferenceExperimentScheduleArgsDict(TypedDict):
        """
        The duration for which you want the inference experiment to run.
        """
        end_time: NotRequired[pulumi.Input[str]]
        """
        The timestamp at which the inference experiment ended or will end.
        """
        start_time: NotRequired[pulumi.Input[str]]
        """
        The timestamp at which the inference experiment started or will start.
        """
elif False:
    InferenceExperimentScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InferenceExperimentScheduleArgs:
    def __init__(__self__, *,
                 end_time: Optional[pulumi.Input[str]] = None,
                 start_time: Optional[pulumi.Input[str]] = None):
        """
        The duration for which you want the inference experiment to run.
        :param pulumi.Input[str] end_time: The timestamp at which the inference experiment ended or will end.
        :param pulumi.Input[str] start_time: The timestamp at which the inference experiment started or will start.
        """
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[str]]:
        """
        The timestamp at which the inference experiment ended or will end.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        The timestamp at which the inference experiment started or will start.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class InferenceExperimentShadowModeConfigArgsDict(TypedDict):
        """
        The configuration of ShadowMode inference experiment type. Use this field to specify a production variant which takes all the inference requests, and a shadow variant to which Amazon SageMaker replicates a percentage of the inference requests. For the shadow variant also specify the percentage of requests that Amazon SageMaker replicates.
        """
        shadow_model_variants: pulumi.Input[Sequence[pulumi.Input['InferenceExperimentShadowModelVariantConfigArgsDict']]]
        """
        List of shadow variant configurations.
        """
        source_model_variant_name: pulumi.Input[str]
        """
        The name of the production variant, which takes all the inference requests.
        """
elif False:
    InferenceExperimentShadowModeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InferenceExperimentShadowModeConfigArgs:
    def __init__(__self__, *,
                 shadow_model_variants: pulumi.Input[Sequence[pulumi.Input['InferenceExperimentShadowModelVariantConfigArgs']]],
                 source_model_variant_name: pulumi.Input[str]):
        """
        The configuration of ShadowMode inference experiment type. Use this field to specify a production variant which takes all the inference requests, and a shadow variant to which Amazon SageMaker replicates a percentage of the inference requests. For the shadow variant also specify the percentage of requests that Amazon SageMaker replicates.
        :param pulumi.Input[Sequence[pulumi.Input['InferenceExperimentShadowModelVariantConfigArgs']]] shadow_model_variants: List of shadow variant configurations.
        :param pulumi.Input[str] source_model_variant_name: The name of the production variant, which takes all the inference requests.
        """
        pulumi.set(__self__, "shadow_model_variants", shadow_model_variants)
        pulumi.set(__self__, "source_model_variant_name", source_model_variant_name)

    @property
    @pulumi.getter(name="shadowModelVariants")
    def shadow_model_variants(self) -> pulumi.Input[Sequence[pulumi.Input['InferenceExperimentShadowModelVariantConfigArgs']]]:
        """
        List of shadow variant configurations.
        """
        return pulumi.get(self, "shadow_model_variants")

    @shadow_model_variants.setter
    def shadow_model_variants(self, value: pulumi.Input[Sequence[pulumi.Input['InferenceExperimentShadowModelVariantConfigArgs']]]):
        pulumi.set(self, "shadow_model_variants", value)

    @property
    @pulumi.getter(name="sourceModelVariantName")
    def source_model_variant_name(self) -> pulumi.Input[str]:
        """
        The name of the production variant, which takes all the inference requests.
        """
        return pulumi.get(self, "source_model_variant_name")

    @source_model_variant_name.setter
    def source_model_variant_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_model_variant_name", value)


if not MYPY:
    class InferenceExperimentShadowModelVariantConfigArgsDict(TypedDict):
        """
        The name and sampling percentage of a shadow variant.
        """
        sampling_percentage: pulumi.Input[int]
        """
        The percentage of inference requests that Amazon SageMaker replicates from the production variant to the shadow variant.
        """
        shadow_model_variant_name: pulumi.Input[str]
        """
        The name of the shadow variant.
        """
elif False:
    InferenceExperimentShadowModelVariantConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InferenceExperimentShadowModelVariantConfigArgs:
    def __init__(__self__, *,
                 sampling_percentage: pulumi.Input[int],
                 shadow_model_variant_name: pulumi.Input[str]):
        """
        The name and sampling percentage of a shadow variant.
        :param pulumi.Input[int] sampling_percentage: The percentage of inference requests that Amazon SageMaker replicates from the production variant to the shadow variant.
        :param pulumi.Input[str] shadow_model_variant_name: The name of the shadow variant.
        """
        pulumi.set(__self__, "sampling_percentage", sampling_percentage)
        pulumi.set(__self__, "shadow_model_variant_name", shadow_model_variant_name)

    @property
    @pulumi.getter(name="samplingPercentage")
    def sampling_percentage(self) -> pulumi.Input[int]:
        """
        The percentage of inference requests that Amazon SageMaker replicates from the production variant to the shadow variant.
        """
        return pulumi.get(self, "sampling_percentage")

    @sampling_percentage.setter
    def sampling_percentage(self, value: pulumi.Input[int]):
        pulumi.set(self, "sampling_percentage", value)

    @property
    @pulumi.getter(name="shadowModelVariantName")
    def shadow_model_variant_name(self) -> pulumi.Input[str]:
        """
        The name of the shadow variant.
        """
        return pulumi.get(self, "shadow_model_variant_name")

    @shadow_model_variant_name.setter
    def shadow_model_variant_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "shadow_model_variant_name", value)


if not MYPY:
    class ModelBiasJobDefinitionBatchTransformInputArgsDict(TypedDict):
        """
        The batch transform input for a monitoring job.
        """
        data_captured_destination_s3_uri: pulumi.Input[str]
        """
        A URI that identifies the Amazon S3 storage location where Batch Transform Job captures data.
        """
        dataset_format: pulumi.Input['ModelBiasJobDefinitionDatasetFormatArgsDict']
        """
        The dataset format for your batch transform job.
        """
        local_path: pulumi.Input[str]
        """
        Path to the filesystem where the endpoint data is available to the container.
        """
        end_time_offset: NotRequired[pulumi.Input[str]]
        """
        Monitoring end time offset, e.g. PT0H
        """
        features_attribute: NotRequired[pulumi.Input[str]]
        """
        JSONpath to locate features in JSONlines dataset
        """
        inference_attribute: NotRequired[pulumi.Input[str]]
        """
        Index or JSONpath to locate predicted label(s)
        """
        probability_attribute: NotRequired[pulumi.Input[str]]
        """
        Index or JSONpath to locate probabilities
        """
        probability_threshold_attribute: NotRequired[pulumi.Input[float]]
        """
        The threshold for the class probability to be evaluated as a positive result.
        """
        s3_data_distribution_type: NotRequired[pulumi.Input['ModelBiasJobDefinitionBatchTransformInputS3DataDistributionType']]
        """
        Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
        """
        s3_input_mode: NotRequired[pulumi.Input['ModelBiasJobDefinitionBatchTransformInputS3InputMode']]
        """
        Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
        """
        start_time_offset: NotRequired[pulumi.Input[str]]
        """
        Monitoring start time offset, e.g. -PT1H
        """
elif False:
    ModelBiasJobDefinitionBatchTransformInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelBiasJobDefinitionBatchTransformInputArgs:
    def __init__(__self__, *,
                 data_captured_destination_s3_uri: pulumi.Input[str],
                 dataset_format: pulumi.Input['ModelBiasJobDefinitionDatasetFormatArgs'],
                 local_path: pulumi.Input[str],
                 end_time_offset: Optional[pulumi.Input[str]] = None,
                 features_attribute: Optional[pulumi.Input[str]] = None,
                 inference_attribute: Optional[pulumi.Input[str]] = None,
                 probability_attribute: Optional[pulumi.Input[str]] = None,
                 probability_threshold_attribute: Optional[pulumi.Input[float]] = None,
                 s3_data_distribution_type: Optional[pulumi.Input['ModelBiasJobDefinitionBatchTransformInputS3DataDistributionType']] = None,
                 s3_input_mode: Optional[pulumi.Input['ModelBiasJobDefinitionBatchTransformInputS3InputMode']] = None,
                 start_time_offset: Optional[pulumi.Input[str]] = None):
        """
        The batch transform input for a monitoring job.
        :param pulumi.Input[str] data_captured_destination_s3_uri: A URI that identifies the Amazon S3 storage location where Batch Transform Job captures data.
        :param pulumi.Input['ModelBiasJobDefinitionDatasetFormatArgs'] dataset_format: The dataset format for your batch transform job.
        :param pulumi.Input[str] local_path: Path to the filesystem where the endpoint data is available to the container.
        :param pulumi.Input[str] end_time_offset: Monitoring end time offset, e.g. PT0H
        :param pulumi.Input[str] features_attribute: JSONpath to locate features in JSONlines dataset
        :param pulumi.Input[str] inference_attribute: Index or JSONpath to locate predicted label(s)
        :param pulumi.Input[str] probability_attribute: Index or JSONpath to locate probabilities
        :param pulumi.Input[float] probability_threshold_attribute: The threshold for the class probability to be evaluated as a positive result.
        :param pulumi.Input['ModelBiasJobDefinitionBatchTransformInputS3DataDistributionType'] s3_data_distribution_type: Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
        :param pulumi.Input['ModelBiasJobDefinitionBatchTransformInputS3InputMode'] s3_input_mode: Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
        :param pulumi.Input[str] start_time_offset: Monitoring start time offset, e.g. -PT1H
        """
        pulumi.set(__self__, "data_captured_destination_s3_uri", data_captured_destination_s3_uri)
        pulumi.set(__self__, "dataset_format", dataset_format)
        pulumi.set(__self__, "local_path", local_path)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if features_attribute is not None:
            pulumi.set(__self__, "features_attribute", features_attribute)
        if inference_attribute is not None:
            pulumi.set(__self__, "inference_attribute", inference_attribute)
        if probability_attribute is not None:
            pulumi.set(__self__, "probability_attribute", probability_attribute)
        if probability_threshold_attribute is not None:
            pulumi.set(__self__, "probability_threshold_attribute", probability_threshold_attribute)
        if s3_data_distribution_type is not None:
            pulumi.set(__self__, "s3_data_distribution_type", s3_data_distribution_type)
        if s3_input_mode is not None:
            pulumi.set(__self__, "s3_input_mode", s3_input_mode)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)

    @property
    @pulumi.getter(name="dataCapturedDestinationS3Uri")
    def data_captured_destination_s3_uri(self) -> pulumi.Input[str]:
        """
        A URI that identifies the Amazon S3 storage location where Batch Transform Job captures data.
        """
        return pulumi.get(self, "data_captured_destination_s3_uri")

    @data_captured_destination_s3_uri.setter
    def data_captured_destination_s3_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_captured_destination_s3_uri", value)

    @property
    @pulumi.getter(name="datasetFormat")
    def dataset_format(self) -> pulumi.Input['ModelBiasJobDefinitionDatasetFormatArgs']:
        """
        The dataset format for your batch transform job.
        """
        return pulumi.get(self, "dataset_format")

    @dataset_format.setter
    def dataset_format(self, value: pulumi.Input['ModelBiasJobDefinitionDatasetFormatArgs']):
        pulumi.set(self, "dataset_format", value)

    @property
    @pulumi.getter(name="localPath")
    def local_path(self) -> pulumi.Input[str]:
        """
        Path to the filesystem where the endpoint data is available to the container.
        """
        return pulumi.get(self, "local_path")

    @local_path.setter
    def local_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "local_path", value)

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[pulumi.Input[str]]:
        """
        Monitoring end time offset, e.g. PT0H
        """
        return pulumi.get(self, "end_time_offset")

    @end_time_offset.setter
    def end_time_offset(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_time_offset", value)

    @property
    @pulumi.getter(name="featuresAttribute")
    def features_attribute(self) -> Optional[pulumi.Input[str]]:
        """
        JSONpath to locate features in JSONlines dataset
        """
        return pulumi.get(self, "features_attribute")

    @features_attribute.setter
    def features_attribute(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "features_attribute", value)

    @property
    @pulumi.getter(name="inferenceAttribute")
    def inference_attribute(self) -> Optional[pulumi.Input[str]]:
        """
        Index or JSONpath to locate predicted label(s)
        """
        return pulumi.get(self, "inference_attribute")

    @inference_attribute.setter
    def inference_attribute(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "inference_attribute", value)

    @property
    @pulumi.getter(name="probabilityAttribute")
    def probability_attribute(self) -> Optional[pulumi.Input[str]]:
        """
        Index or JSONpath to locate probabilities
        """
        return pulumi.get(self, "probability_attribute")

    @probability_attribute.setter
    def probability_attribute(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "probability_attribute", value)

    @property
    @pulumi.getter(name="probabilityThresholdAttribute")
    def probability_threshold_attribute(self) -> Optional[pulumi.Input[float]]:
        """
        The threshold for the class probability to be evaluated as a positive result.
        """
        return pulumi.get(self, "probability_threshold_attribute")

    @probability_threshold_attribute.setter
    def probability_threshold_attribute(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "probability_threshold_attribute", value)

    @property
    @pulumi.getter(name="s3DataDistributionType")
    def s3_data_distribution_type(self) -> Optional[pulumi.Input['ModelBiasJobDefinitionBatchTransformInputS3DataDistributionType']]:
        """
        Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
        """
        return pulumi.get(self, "s3_data_distribution_type")

    @s3_data_distribution_type.setter
    def s3_data_distribution_type(self, value: Optional[pulumi.Input['ModelBiasJobDefinitionBatchTransformInputS3DataDistributionType']]):
        pulumi.set(self, "s3_data_distribution_type", value)

    @property
    @pulumi.getter(name="s3InputMode")
    def s3_input_mode(self) -> Optional[pulumi.Input['ModelBiasJobDefinitionBatchTransformInputS3InputMode']]:
        """
        Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
        """
        return pulumi.get(self, "s3_input_mode")

    @s3_input_mode.setter
    def s3_input_mode(self, value: Optional[pulumi.Input['ModelBiasJobDefinitionBatchTransformInputS3InputMode']]):
        pulumi.set(self, "s3_input_mode", value)

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[pulumi.Input[str]]:
        """
        Monitoring start time offset, e.g. -PT1H
        """
        return pulumi.get(self, "start_time_offset")

    @start_time_offset.setter
    def start_time_offset(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time_offset", value)


if not MYPY:
    class ModelBiasJobDefinitionClusterConfigArgsDict(TypedDict):
        """
        Configuration for the cluster used to run model monitoring jobs.
        """
        instance_count: pulumi.Input[int]
        """
        The number of ML compute instances to use in the model monitoring job. For distributed processing jobs, specify a value greater than 1. The default value is 1.
        """
        instance_type: pulumi.Input[str]
        """
        The ML compute instance type for the processing job.
        """
        volume_size_in_gb: pulumi.Input[int]
        """
        The size of the ML storage volume, in gigabytes, that you want to provision. You must specify sufficient ML storage for your scenario.
        """
        volume_kms_key_id: NotRequired[pulumi.Input[str]]
        """
        The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the model monitoring job.
        """
elif False:
    ModelBiasJobDefinitionClusterConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelBiasJobDefinitionClusterConfigArgs:
    def __init__(__self__, *,
                 instance_count: pulumi.Input[int],
                 instance_type: pulumi.Input[str],
                 volume_size_in_gb: pulumi.Input[int],
                 volume_kms_key_id: Optional[pulumi.Input[str]] = None):
        """
        Configuration for the cluster used to run model monitoring jobs.
        :param pulumi.Input[int] instance_count: The number of ML compute instances to use in the model monitoring job. For distributed processing jobs, specify a value greater than 1. The default value is 1.
        :param pulumi.Input[str] instance_type: The ML compute instance type for the processing job.
        :param pulumi.Input[int] volume_size_in_gb: The size of the ML storage volume, in gigabytes, that you want to provision. You must specify sufficient ML storage for your scenario.
        :param pulumi.Input[str] volume_kms_key_id: The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the model monitoring job.
        """
        pulumi.set(__self__, "instance_count", instance_count)
        pulumi.set(__self__, "instance_type", instance_type)
        pulumi.set(__self__, "volume_size_in_gb", volume_size_in_gb)
        if volume_kms_key_id is not None:
            pulumi.set(__self__, "volume_kms_key_id", volume_kms_key_id)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> pulumi.Input[int]:
        """
        The number of ML compute instances to use in the model monitoring job. For distributed processing jobs, specify a value greater than 1. The default value is 1.
        """
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "instance_count", value)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> pulumi.Input[str]:
        """
        The ML compute instance type for the processing job.
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance_type", value)

    @property
    @pulumi.getter(name="volumeSizeInGb")
    def volume_size_in_gb(self) -> pulumi.Input[int]:
        """
        The size of the ML storage volume, in gigabytes, that you want to provision. You must specify sufficient ML storage for your scenario.
        """
        return pulumi.get(self, "volume_size_in_gb")

    @volume_size_in_gb.setter
    def volume_size_in_gb(self, value: pulumi.Input[int]):
        pulumi.set(self, "volume_size_in_gb", value)

    @property
    @pulumi.getter(name="volumeKmsKeyId")
    def volume_kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the model monitoring job.
        """
        return pulumi.get(self, "volume_kms_key_id")

    @volume_kms_key_id.setter
    def volume_kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_kms_key_id", value)


if not MYPY:
    class ModelBiasJobDefinitionConstraintsResourceArgsDict(TypedDict):
        """
        The baseline constraints resource for a monitoring job.
        """
        s3_uri: NotRequired[pulumi.Input[str]]
        """
        The Amazon S3 URI for baseline constraint file in Amazon S3 that the current monitoring job should validated against.
        """
elif False:
    ModelBiasJobDefinitionConstraintsResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelBiasJobDefinitionConstraintsResourceArgs:
    def __init__(__self__, *,
                 s3_uri: Optional[pulumi.Input[str]] = None):
        """
        The baseline constraints resource for a monitoring job.
        :param pulumi.Input[str] s3_uri: The Amazon S3 URI for baseline constraint file in Amazon S3 that the current monitoring job should validated against.
        """
        if s3_uri is not None:
            pulumi.set(__self__, "s3_uri", s3_uri)

    @property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon S3 URI for baseline constraint file in Amazon S3 that the current monitoring job should validated against.
        """
        return pulumi.get(self, "s3_uri")

    @s3_uri.setter
    def s3_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_uri", value)


if not MYPY:
    class ModelBiasJobDefinitionCsvArgsDict(TypedDict):
        """
        The CSV format
        """
        header: NotRequired[pulumi.Input[bool]]
        """
        A boolean flag indicating if given CSV has header
        """
elif False:
    ModelBiasJobDefinitionCsvArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelBiasJobDefinitionCsvArgs:
    def __init__(__self__, *,
                 header: Optional[pulumi.Input[bool]] = None):
        """
        The CSV format
        :param pulumi.Input[bool] header: A boolean flag indicating if given CSV has header
        """
        if header is not None:
            pulumi.set(__self__, "header", header)

    @property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean flag indicating if given CSV has header
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "header", value)


if not MYPY:
    class ModelBiasJobDefinitionDatasetFormatArgsDict(TypedDict):
        """
        The dataset format of the data to monitor
        """
        csv: NotRequired[pulumi.Input['ModelBiasJobDefinitionCsvArgsDict']]
        json: NotRequired[pulumi.Input['ModelBiasJobDefinitionJsonArgsDict']]
        parquet: NotRequired[pulumi.Input[bool]]
elif False:
    ModelBiasJobDefinitionDatasetFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelBiasJobDefinitionDatasetFormatArgs:
    def __init__(__self__, *,
                 csv: Optional[pulumi.Input['ModelBiasJobDefinitionCsvArgs']] = None,
                 json: Optional[pulumi.Input['ModelBiasJobDefinitionJsonArgs']] = None,
                 parquet: Optional[pulumi.Input[bool]] = None):
        """
        The dataset format of the data to monitor
        """
        if csv is not None:
            pulumi.set(__self__, "csv", csv)
        if json is not None:
            pulumi.set(__self__, "json", json)
        if parquet is not None:
            pulumi.set(__self__, "parquet", parquet)

    @property
    @pulumi.getter
    def csv(self) -> Optional[pulumi.Input['ModelBiasJobDefinitionCsvArgs']]:
        return pulumi.get(self, "csv")

    @csv.setter
    def csv(self, value: Optional[pulumi.Input['ModelBiasJobDefinitionCsvArgs']]):
        pulumi.set(self, "csv", value)

    @property
    @pulumi.getter
    def json(self) -> Optional[pulumi.Input['ModelBiasJobDefinitionJsonArgs']]:
        return pulumi.get(self, "json")

    @json.setter
    def json(self, value: Optional[pulumi.Input['ModelBiasJobDefinitionJsonArgs']]):
        pulumi.set(self, "json", value)

    @property
    @pulumi.getter
    def parquet(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "parquet")

    @parquet.setter
    def parquet(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "parquet", value)


if not MYPY:
    class ModelBiasJobDefinitionEndpointInputArgsDict(TypedDict):
        """
        The endpoint for a monitoring job.
        """
        endpoint_name: pulumi.Input[str]
        """
        An endpoint in customer's account which has enabled `DataCaptureConfig` enabled.
        """
        local_path: pulumi.Input[str]
        """
        Path to the filesystem where the endpoint data is available to the container.
        """
        end_time_offset: NotRequired[pulumi.Input[str]]
        """
        Monitoring end time offset, e.g. PT0H
        """
        features_attribute: NotRequired[pulumi.Input[str]]
        """
        JSONpath to locate features in JSONlines dataset
        """
        inference_attribute: NotRequired[pulumi.Input[str]]
        """
        Index or JSONpath to locate predicted label(s)
        """
        probability_attribute: NotRequired[pulumi.Input[str]]
        """
        Index or JSONpath to locate probabilities
        """
        probability_threshold_attribute: NotRequired[pulumi.Input[float]]
        """
        The threshold for the class probability to be evaluated as a positive result.
        """
        s3_data_distribution_type: NotRequired[pulumi.Input['ModelBiasJobDefinitionEndpointInputS3DataDistributionType']]
        """
        Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
        """
        s3_input_mode: NotRequired[pulumi.Input['ModelBiasJobDefinitionEndpointInputS3InputMode']]
        """
        Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
        """
        start_time_offset: NotRequired[pulumi.Input[str]]
        """
        Monitoring start time offset, e.g. -PT1H
        """
elif False:
    ModelBiasJobDefinitionEndpointInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelBiasJobDefinitionEndpointInputArgs:
    def __init__(__self__, *,
                 endpoint_name: pulumi.Input[str],
                 local_path: pulumi.Input[str],
                 end_time_offset: Optional[pulumi.Input[str]] = None,
                 features_attribute: Optional[pulumi.Input[str]] = None,
                 inference_attribute: Optional[pulumi.Input[str]] = None,
                 probability_attribute: Optional[pulumi.Input[str]] = None,
                 probability_threshold_attribute: Optional[pulumi.Input[float]] = None,
                 s3_data_distribution_type: Optional[pulumi.Input['ModelBiasJobDefinitionEndpointInputS3DataDistributionType']] = None,
                 s3_input_mode: Optional[pulumi.Input['ModelBiasJobDefinitionEndpointInputS3InputMode']] = None,
                 start_time_offset: Optional[pulumi.Input[str]] = None):
        """
        The endpoint for a monitoring job.
        :param pulumi.Input[str] endpoint_name: An endpoint in customer's account which has enabled `DataCaptureConfig` enabled.
        :param pulumi.Input[str] local_path: Path to the filesystem where the endpoint data is available to the container.
        :param pulumi.Input[str] end_time_offset: Monitoring end time offset, e.g. PT0H
        :param pulumi.Input[str] features_attribute: JSONpath to locate features in JSONlines dataset
        :param pulumi.Input[str] inference_attribute: Index or JSONpath to locate predicted label(s)
        :param pulumi.Input[str] probability_attribute: Index or JSONpath to locate probabilities
        :param pulumi.Input[float] probability_threshold_attribute: The threshold for the class probability to be evaluated as a positive result.
        :param pulumi.Input['ModelBiasJobDefinitionEndpointInputS3DataDistributionType'] s3_data_distribution_type: Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
        :param pulumi.Input['ModelBiasJobDefinitionEndpointInputS3InputMode'] s3_input_mode: Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
        :param pulumi.Input[str] start_time_offset: Monitoring start time offset, e.g. -PT1H
        """
        pulumi.set(__self__, "endpoint_name", endpoint_name)
        pulumi.set(__self__, "local_path", local_path)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if features_attribute is not None:
            pulumi.set(__self__, "features_attribute", features_attribute)
        if inference_attribute is not None:
            pulumi.set(__self__, "inference_attribute", inference_attribute)
        if probability_attribute is not None:
            pulumi.set(__self__, "probability_attribute", probability_attribute)
        if probability_threshold_attribute is not None:
            pulumi.set(__self__, "probability_threshold_attribute", probability_threshold_attribute)
        if s3_data_distribution_type is not None:
            pulumi.set(__self__, "s3_data_distribution_type", s3_data_distribution_type)
        if s3_input_mode is not None:
            pulumi.set(__self__, "s3_input_mode", s3_input_mode)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)

    @property
    @pulumi.getter(name="endpointName")
    def endpoint_name(self) -> pulumi.Input[str]:
        """
        An endpoint in customer's account which has enabled `DataCaptureConfig` enabled.
        """
        return pulumi.get(self, "endpoint_name")

    @endpoint_name.setter
    def endpoint_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint_name", value)

    @property
    @pulumi.getter(name="localPath")
    def local_path(self) -> pulumi.Input[str]:
        """
        Path to the filesystem where the endpoint data is available to the container.
        """
        return pulumi.get(self, "local_path")

    @local_path.setter
    def local_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "local_path", value)

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[pulumi.Input[str]]:
        """
        Monitoring end time offset, e.g. PT0H
        """
        return pulumi.get(self, "end_time_offset")

    @end_time_offset.setter
    def end_time_offset(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_time_offset", value)

    @property
    @pulumi.getter(name="featuresAttribute")
    def features_attribute(self) -> Optional[pulumi.Input[str]]:
        """
        JSONpath to locate features in JSONlines dataset
        """
        return pulumi.get(self, "features_attribute")

    @features_attribute.setter
    def features_attribute(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "features_attribute", value)

    @property
    @pulumi.getter(name="inferenceAttribute")
    def inference_attribute(self) -> Optional[pulumi.Input[str]]:
        """
        Index or JSONpath to locate predicted label(s)
        """
        return pulumi.get(self, "inference_attribute")

    @inference_attribute.setter
    def inference_attribute(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "inference_attribute", value)

    @property
    @pulumi.getter(name="probabilityAttribute")
    def probability_attribute(self) -> Optional[pulumi.Input[str]]:
        """
        Index or JSONpath to locate probabilities
        """
        return pulumi.get(self, "probability_attribute")

    @probability_attribute.setter
    def probability_attribute(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "probability_attribute", value)

    @property
    @pulumi.getter(name="probabilityThresholdAttribute")
    def probability_threshold_attribute(self) -> Optional[pulumi.Input[float]]:
        """
        The threshold for the class probability to be evaluated as a positive result.
        """
        return pulumi.get(self, "probability_threshold_attribute")

    @probability_threshold_attribute.setter
    def probability_threshold_attribute(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "probability_threshold_attribute", value)

    @property
    @pulumi.getter(name="s3DataDistributionType")
    def s3_data_distribution_type(self) -> Optional[pulumi.Input['ModelBiasJobDefinitionEndpointInputS3DataDistributionType']]:
        """
        Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
        """
        return pulumi.get(self, "s3_data_distribution_type")

    @s3_data_distribution_type.setter
    def s3_data_distribution_type(self, value: Optional[pulumi.Input['ModelBiasJobDefinitionEndpointInputS3DataDistributionType']]):
        pulumi.set(self, "s3_data_distribution_type", value)

    @property
    @pulumi.getter(name="s3InputMode")
    def s3_input_mode(self) -> Optional[pulumi.Input['ModelBiasJobDefinitionEndpointInputS3InputMode']]:
        """
        Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
        """
        return pulumi.get(self, "s3_input_mode")

    @s3_input_mode.setter
    def s3_input_mode(self, value: Optional[pulumi.Input['ModelBiasJobDefinitionEndpointInputS3InputMode']]):
        pulumi.set(self, "s3_input_mode", value)

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[pulumi.Input[str]]:
        """
        Monitoring start time offset, e.g. -PT1H
        """
        return pulumi.get(self, "start_time_offset")

    @start_time_offset.setter
    def start_time_offset(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time_offset", value)


if not MYPY:
    class ModelBiasJobDefinitionJsonArgsDict(TypedDict):
        """
        The Json format
        """
        line: NotRequired[pulumi.Input[bool]]
        """
        A boolean flag indicating if it is JSON line format
        """
elif False:
    ModelBiasJobDefinitionJsonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelBiasJobDefinitionJsonArgs:
    def __init__(__self__, *,
                 line: Optional[pulumi.Input[bool]] = None):
        """
        The Json format
        :param pulumi.Input[bool] line: A boolean flag indicating if it is JSON line format
        """
        if line is not None:
            pulumi.set(__self__, "line", line)

    @property
    @pulumi.getter
    def line(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean flag indicating if it is JSON line format
        """
        return pulumi.get(self, "line")

    @line.setter
    def line(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "line", value)


if not MYPY:
    class ModelBiasJobDefinitionModelBiasAppSpecificationArgsDict(TypedDict):
        """
        Container image configuration object for the monitoring job.
        """
        config_uri: pulumi.Input[str]
        """
        The S3 URI to an analysis configuration file
        """
        image_uri: pulumi.Input[str]
        """
        The container image to be run by the monitoring job.
        """
        environment: NotRequired[Any]
        """
        Sets the environment variables in the Docker container
        """
elif False:
    ModelBiasJobDefinitionModelBiasAppSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelBiasJobDefinitionModelBiasAppSpecificationArgs:
    def __init__(__self__, *,
                 config_uri: pulumi.Input[str],
                 image_uri: pulumi.Input[str],
                 environment: Optional[Any] = None):
        """
        Container image configuration object for the monitoring job.
        :param pulumi.Input[str] config_uri: The S3 URI to an analysis configuration file
        :param pulumi.Input[str] image_uri: The container image to be run by the monitoring job.
        :param Any environment: Sets the environment variables in the Docker container
        """
        pulumi.set(__self__, "config_uri", config_uri)
        pulumi.set(__self__, "image_uri", image_uri)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)

    @property
    @pulumi.getter(name="configUri")
    def config_uri(self) -> pulumi.Input[str]:
        """
        The S3 URI to an analysis configuration file
        """
        return pulumi.get(self, "config_uri")

    @config_uri.setter
    def config_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "config_uri", value)

    @property
    @pulumi.getter(name="imageUri")
    def image_uri(self) -> pulumi.Input[str]:
        """
        The container image to be run by the monitoring job.
        """
        return pulumi.get(self, "image_uri")

    @image_uri.setter
    def image_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "image_uri", value)

    @property
    @pulumi.getter
    def environment(self) -> Optional[Any]:
        """
        Sets the environment variables in the Docker container
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[Any]):
        pulumi.set(self, "environment", value)


if not MYPY:
    class ModelBiasJobDefinitionModelBiasBaselineConfigArgsDict(TypedDict):
        """
        Baseline configuration used to validate that the data conforms to the specified constraints and statistics.
        """
        baselining_job_name: NotRequired[pulumi.Input[str]]
        """
        The name of the baseline model bias job.
        """
        constraints_resource: NotRequired[pulumi.Input['ModelBiasJobDefinitionConstraintsResourceArgsDict']]
        """
        The constraints resource for a monitoring job.
        """
elif False:
    ModelBiasJobDefinitionModelBiasBaselineConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelBiasJobDefinitionModelBiasBaselineConfigArgs:
    def __init__(__self__, *,
                 baselining_job_name: Optional[pulumi.Input[str]] = None,
                 constraints_resource: Optional[pulumi.Input['ModelBiasJobDefinitionConstraintsResourceArgs']] = None):
        """
        Baseline configuration used to validate that the data conforms to the specified constraints and statistics.
        :param pulumi.Input[str] baselining_job_name: The name of the baseline model bias job.
        :param pulumi.Input['ModelBiasJobDefinitionConstraintsResourceArgs'] constraints_resource: The constraints resource for a monitoring job.
        """
        if baselining_job_name is not None:
            pulumi.set(__self__, "baselining_job_name", baselining_job_name)
        if constraints_resource is not None:
            pulumi.set(__self__, "constraints_resource", constraints_resource)

    @property
    @pulumi.getter(name="baseliningJobName")
    def baselining_job_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the baseline model bias job.
        """
        return pulumi.get(self, "baselining_job_name")

    @baselining_job_name.setter
    def baselining_job_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "baselining_job_name", value)

    @property
    @pulumi.getter(name="constraintsResource")
    def constraints_resource(self) -> Optional[pulumi.Input['ModelBiasJobDefinitionConstraintsResourceArgs']]:
        """
        The constraints resource for a monitoring job.
        """
        return pulumi.get(self, "constraints_resource")

    @constraints_resource.setter
    def constraints_resource(self, value: Optional[pulumi.Input['ModelBiasJobDefinitionConstraintsResourceArgs']]):
        pulumi.set(self, "constraints_resource", value)


if not MYPY:
    class ModelBiasJobDefinitionModelBiasJobInputArgsDict(TypedDict):
        """
        The inputs for a monitoring job.
        """
        ground_truth_s3_input: pulumi.Input['ModelBiasJobDefinitionMonitoringGroundTruthS3InputArgsDict']
        """
        Location of ground truth labels to use in model bias job.
        """
        batch_transform_input: NotRequired[pulumi.Input['ModelBiasJobDefinitionBatchTransformInputArgsDict']]
        """
        Input object for the batch transform job.
        """
        endpoint_input: NotRequired[pulumi.Input['ModelBiasJobDefinitionEndpointInputArgsDict']]
        """
        Input object for the endpoint
        """
elif False:
    ModelBiasJobDefinitionModelBiasJobInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelBiasJobDefinitionModelBiasJobInputArgs:
    def __init__(__self__, *,
                 ground_truth_s3_input: pulumi.Input['ModelBiasJobDefinitionMonitoringGroundTruthS3InputArgs'],
                 batch_transform_input: Optional[pulumi.Input['ModelBiasJobDefinitionBatchTransformInputArgs']] = None,
                 endpoint_input: Optional[pulumi.Input['ModelBiasJobDefinitionEndpointInputArgs']] = None):
        """
        The inputs for a monitoring job.
        :param pulumi.Input['ModelBiasJobDefinitionMonitoringGroundTruthS3InputArgs'] ground_truth_s3_input: Location of ground truth labels to use in model bias job.
        :param pulumi.Input['ModelBiasJobDefinitionBatchTransformInputArgs'] batch_transform_input: Input object for the batch transform job.
        :param pulumi.Input['ModelBiasJobDefinitionEndpointInputArgs'] endpoint_input: Input object for the endpoint
        """
        pulumi.set(__self__, "ground_truth_s3_input", ground_truth_s3_input)
        if batch_transform_input is not None:
            pulumi.set(__self__, "batch_transform_input", batch_transform_input)
        if endpoint_input is not None:
            pulumi.set(__self__, "endpoint_input", endpoint_input)

    @property
    @pulumi.getter(name="groundTruthS3Input")
    def ground_truth_s3_input(self) -> pulumi.Input['ModelBiasJobDefinitionMonitoringGroundTruthS3InputArgs']:
        """
        Location of ground truth labels to use in model bias job.
        """
        return pulumi.get(self, "ground_truth_s3_input")

    @ground_truth_s3_input.setter
    def ground_truth_s3_input(self, value: pulumi.Input['ModelBiasJobDefinitionMonitoringGroundTruthS3InputArgs']):
        pulumi.set(self, "ground_truth_s3_input", value)

    @property
    @pulumi.getter(name="batchTransformInput")
    def batch_transform_input(self) -> Optional[pulumi.Input['ModelBiasJobDefinitionBatchTransformInputArgs']]:
        """
        Input object for the batch transform job.
        """
        return pulumi.get(self, "batch_transform_input")

    @batch_transform_input.setter
    def batch_transform_input(self, value: Optional[pulumi.Input['ModelBiasJobDefinitionBatchTransformInputArgs']]):
        pulumi.set(self, "batch_transform_input", value)

    @property
    @pulumi.getter(name="endpointInput")
    def endpoint_input(self) -> Optional[pulumi.Input['ModelBiasJobDefinitionEndpointInputArgs']]:
        """
        Input object for the endpoint
        """
        return pulumi.get(self, "endpoint_input")

    @endpoint_input.setter
    def endpoint_input(self, value: Optional[pulumi.Input['ModelBiasJobDefinitionEndpointInputArgs']]):
        pulumi.set(self, "endpoint_input", value)


if not MYPY:
    class ModelBiasJobDefinitionMonitoringGroundTruthS3InputArgsDict(TypedDict):
        """
        Ground truth input provided in S3 
        """
        s3_uri: pulumi.Input[str]
        """
        A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
        """
elif False:
    ModelBiasJobDefinitionMonitoringGroundTruthS3InputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelBiasJobDefinitionMonitoringGroundTruthS3InputArgs:
    def __init__(__self__, *,
                 s3_uri: pulumi.Input[str]):
        """
        Ground truth input provided in S3 
        :param pulumi.Input[str] s3_uri: A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
        """
        pulumi.set(__self__, "s3_uri", s3_uri)

    @property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> pulumi.Input[str]:
        """
        A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
        """
        return pulumi.get(self, "s3_uri")

    @s3_uri.setter
    def s3_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_uri", value)


if not MYPY:
    class ModelBiasJobDefinitionMonitoringOutputConfigArgsDict(TypedDict):
        """
        The output configuration for monitoring jobs.
        """
        monitoring_outputs: pulumi.Input[Sequence[pulumi.Input['ModelBiasJobDefinitionMonitoringOutputArgsDict']]]
        """
        Monitoring outputs for monitoring jobs. This is where the output of the periodic monitoring jobs is uploaded.
        """
        kms_key_id: NotRequired[pulumi.Input[str]]
        """
        The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.
        """
elif False:
    ModelBiasJobDefinitionMonitoringOutputConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelBiasJobDefinitionMonitoringOutputConfigArgs:
    def __init__(__self__, *,
                 monitoring_outputs: pulumi.Input[Sequence[pulumi.Input['ModelBiasJobDefinitionMonitoringOutputArgs']]],
                 kms_key_id: Optional[pulumi.Input[str]] = None):
        """
        The output configuration for monitoring jobs.
        :param pulumi.Input[Sequence[pulumi.Input['ModelBiasJobDefinitionMonitoringOutputArgs']]] monitoring_outputs: Monitoring outputs for monitoring jobs. This is where the output of the periodic monitoring jobs is uploaded.
        :param pulumi.Input[str] kms_key_id: The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.
        """
        pulumi.set(__self__, "monitoring_outputs", monitoring_outputs)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)

    @property
    @pulumi.getter(name="monitoringOutputs")
    def monitoring_outputs(self) -> pulumi.Input[Sequence[pulumi.Input['ModelBiasJobDefinitionMonitoringOutputArgs']]]:
        """
        Monitoring outputs for monitoring jobs. This is where the output of the periodic monitoring jobs is uploaded.
        """
        return pulumi.get(self, "monitoring_outputs")

    @monitoring_outputs.setter
    def monitoring_outputs(self, value: pulumi.Input[Sequence[pulumi.Input['ModelBiasJobDefinitionMonitoringOutputArgs']]]):
        pulumi.set(self, "monitoring_outputs", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)


if not MYPY:
    class ModelBiasJobDefinitionMonitoringOutputArgsDict(TypedDict):
        """
        The output object for a monitoring job.
        """
        s3_output: pulumi.Input['ModelBiasJobDefinitionS3OutputArgsDict']
        """
        The Amazon S3 storage location where the results of a monitoring job are saved.
        """
elif False:
    ModelBiasJobDefinitionMonitoringOutputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelBiasJobDefinitionMonitoringOutputArgs:
    def __init__(__self__, *,
                 s3_output: pulumi.Input['ModelBiasJobDefinitionS3OutputArgs']):
        """
        The output object for a monitoring job.
        :param pulumi.Input['ModelBiasJobDefinitionS3OutputArgs'] s3_output: The Amazon S3 storage location where the results of a monitoring job are saved.
        """
        pulumi.set(__self__, "s3_output", s3_output)

    @property
    @pulumi.getter(name="s3Output")
    def s3_output(self) -> pulumi.Input['ModelBiasJobDefinitionS3OutputArgs']:
        """
        The Amazon S3 storage location where the results of a monitoring job are saved.
        """
        return pulumi.get(self, "s3_output")

    @s3_output.setter
    def s3_output(self, value: pulumi.Input['ModelBiasJobDefinitionS3OutputArgs']):
        pulumi.set(self, "s3_output", value)


if not MYPY:
    class ModelBiasJobDefinitionMonitoringResourcesArgsDict(TypedDict):
        """
        Identifies the resources to deploy for a monitoring job.
        """
        cluster_config: pulumi.Input['ModelBiasJobDefinitionClusterConfigArgsDict']
        """
        The configuration for the cluster resources used to run the processing job.
        """
elif False:
    ModelBiasJobDefinitionMonitoringResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelBiasJobDefinitionMonitoringResourcesArgs:
    def __init__(__self__, *,
                 cluster_config: pulumi.Input['ModelBiasJobDefinitionClusterConfigArgs']):
        """
        Identifies the resources to deploy for a monitoring job.
        :param pulumi.Input['ModelBiasJobDefinitionClusterConfigArgs'] cluster_config: The configuration for the cluster resources used to run the processing job.
        """
        pulumi.set(__self__, "cluster_config", cluster_config)

    @property
    @pulumi.getter(name="clusterConfig")
    def cluster_config(self) -> pulumi.Input['ModelBiasJobDefinitionClusterConfigArgs']:
        """
        The configuration for the cluster resources used to run the processing job.
        """
        return pulumi.get(self, "cluster_config")

    @cluster_config.setter
    def cluster_config(self, value: pulumi.Input['ModelBiasJobDefinitionClusterConfigArgs']):
        pulumi.set(self, "cluster_config", value)


if not MYPY:
    class ModelBiasJobDefinitionNetworkConfigArgsDict(TypedDict):
        """
        Networking options for a job, such as network traffic encryption between containers, whether to allow inbound and outbound network calls to and from containers, and the VPC subnets and security groups to use for VPC-enabled jobs.
        """
        enable_inter_container_traffic_encryption: NotRequired[pulumi.Input[bool]]
        """
        Whether to encrypt all communications between distributed processing jobs. Choose True to encrypt communications. Encryption provides greater security for distributed processing jobs, but the processing might take longer.
        """
        enable_network_isolation: NotRequired[pulumi.Input[bool]]
        """
        Whether to allow inbound and outbound network calls to and from the containers used for the processing job.
        """
        vpc_config: NotRequired[pulumi.Input['ModelBiasJobDefinitionVpcConfigArgsDict']]
        """
        Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC.
        """
elif False:
    ModelBiasJobDefinitionNetworkConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelBiasJobDefinitionNetworkConfigArgs:
    def __init__(__self__, *,
                 enable_inter_container_traffic_encryption: Optional[pulumi.Input[bool]] = None,
                 enable_network_isolation: Optional[pulumi.Input[bool]] = None,
                 vpc_config: Optional[pulumi.Input['ModelBiasJobDefinitionVpcConfigArgs']] = None):
        """
        Networking options for a job, such as network traffic encryption between containers, whether to allow inbound and outbound network calls to and from containers, and the VPC subnets and security groups to use for VPC-enabled jobs.
        :param pulumi.Input[bool] enable_inter_container_traffic_encryption: Whether to encrypt all communications between distributed processing jobs. Choose True to encrypt communications. Encryption provides greater security for distributed processing jobs, but the processing might take longer.
        :param pulumi.Input[bool] enable_network_isolation: Whether to allow inbound and outbound network calls to and from the containers used for the processing job.
        :param pulumi.Input['ModelBiasJobDefinitionVpcConfigArgs'] vpc_config: Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC.
        """
        if enable_inter_container_traffic_encryption is not None:
            pulumi.set(__self__, "enable_inter_container_traffic_encryption", enable_inter_container_traffic_encryption)
        if enable_network_isolation is not None:
            pulumi.set(__self__, "enable_network_isolation", enable_network_isolation)
        if vpc_config is not None:
            pulumi.set(__self__, "vpc_config", vpc_config)

    @property
    @pulumi.getter(name="enableInterContainerTrafficEncryption")
    def enable_inter_container_traffic_encryption(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to encrypt all communications between distributed processing jobs. Choose True to encrypt communications. Encryption provides greater security for distributed processing jobs, but the processing might take longer.
        """
        return pulumi.get(self, "enable_inter_container_traffic_encryption")

    @enable_inter_container_traffic_encryption.setter
    def enable_inter_container_traffic_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_inter_container_traffic_encryption", value)

    @property
    @pulumi.getter(name="enableNetworkIsolation")
    def enable_network_isolation(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to allow inbound and outbound network calls to and from the containers used for the processing job.
        """
        return pulumi.get(self, "enable_network_isolation")

    @enable_network_isolation.setter
    def enable_network_isolation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_network_isolation", value)

    @property
    @pulumi.getter(name="vpcConfig")
    def vpc_config(self) -> Optional[pulumi.Input['ModelBiasJobDefinitionVpcConfigArgs']]:
        """
        Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC.
        """
        return pulumi.get(self, "vpc_config")

    @vpc_config.setter
    def vpc_config(self, value: Optional[pulumi.Input['ModelBiasJobDefinitionVpcConfigArgs']]):
        pulumi.set(self, "vpc_config", value)


if not MYPY:
    class ModelBiasJobDefinitionS3OutputArgsDict(TypedDict):
        """
        Information about where and how to store the results of a monitoring job.
        """
        local_path: pulumi.Input[str]
        """
        The local path to the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job. LocalPath is an absolute path for the output data.
        """
        s3_uri: pulumi.Input[str]
        """
        A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
        """
        s3_upload_mode: NotRequired[pulumi.Input['ModelBiasJobDefinitionS3OutputS3UploadMode']]
        """
        Whether to upload the results of the monitoring job continuously or after the job completes.
        """
elif False:
    ModelBiasJobDefinitionS3OutputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelBiasJobDefinitionS3OutputArgs:
    def __init__(__self__, *,
                 local_path: pulumi.Input[str],
                 s3_uri: pulumi.Input[str],
                 s3_upload_mode: Optional[pulumi.Input['ModelBiasJobDefinitionS3OutputS3UploadMode']] = None):
        """
        Information about where and how to store the results of a monitoring job.
        :param pulumi.Input[str] local_path: The local path to the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job. LocalPath is an absolute path for the output data.
        :param pulumi.Input[str] s3_uri: A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
        :param pulumi.Input['ModelBiasJobDefinitionS3OutputS3UploadMode'] s3_upload_mode: Whether to upload the results of the monitoring job continuously or after the job completes.
        """
        pulumi.set(__self__, "local_path", local_path)
        pulumi.set(__self__, "s3_uri", s3_uri)
        if s3_upload_mode is not None:
            pulumi.set(__self__, "s3_upload_mode", s3_upload_mode)

    @property
    @pulumi.getter(name="localPath")
    def local_path(self) -> pulumi.Input[str]:
        """
        The local path to the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job. LocalPath is an absolute path for the output data.
        """
        return pulumi.get(self, "local_path")

    @local_path.setter
    def local_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "local_path", value)

    @property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> pulumi.Input[str]:
        """
        A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
        """
        return pulumi.get(self, "s3_uri")

    @s3_uri.setter
    def s3_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_uri", value)

    @property
    @pulumi.getter(name="s3UploadMode")
    def s3_upload_mode(self) -> Optional[pulumi.Input['ModelBiasJobDefinitionS3OutputS3UploadMode']]:
        """
        Whether to upload the results of the monitoring job continuously or after the job completes.
        """
        return pulumi.get(self, "s3_upload_mode")

    @s3_upload_mode.setter
    def s3_upload_mode(self, value: Optional[pulumi.Input['ModelBiasJobDefinitionS3OutputS3UploadMode']]):
        pulumi.set(self, "s3_upload_mode", value)


if not MYPY:
    class ModelBiasJobDefinitionStoppingConditionArgsDict(TypedDict):
        """
        Specifies a time limit for how long the monitoring job is allowed to run.
        """
        max_runtime_in_seconds: pulumi.Input[int]
        """
        The maximum runtime allowed in seconds.
        """
elif False:
    ModelBiasJobDefinitionStoppingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelBiasJobDefinitionStoppingConditionArgs:
    def __init__(__self__, *,
                 max_runtime_in_seconds: pulumi.Input[int]):
        """
        Specifies a time limit for how long the monitoring job is allowed to run.
        :param pulumi.Input[int] max_runtime_in_seconds: The maximum runtime allowed in seconds.
        """
        pulumi.set(__self__, "max_runtime_in_seconds", max_runtime_in_seconds)

    @property
    @pulumi.getter(name="maxRuntimeInSeconds")
    def max_runtime_in_seconds(self) -> pulumi.Input[int]:
        """
        The maximum runtime allowed in seconds.
        """
        return pulumi.get(self, "max_runtime_in_seconds")

    @max_runtime_in_seconds.setter
    def max_runtime_in_seconds(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_runtime_in_seconds", value)


if not MYPY:
    class ModelBiasJobDefinitionVpcConfigArgsDict(TypedDict):
        """
        Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC.
        """
        security_group_ids: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the Subnets field.
        """
        subnets: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The ID of the subnets in the VPC to which you want to connect to your monitoring jobs.
        """
elif False:
    ModelBiasJobDefinitionVpcConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelBiasJobDefinitionVpcConfigArgs:
    def __init__(__self__, *,
                 security_group_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 subnets: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_group_ids: The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the Subnets field.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subnets: The ID of the subnets in the VPC to which you want to connect to your monitoring jobs.
        """
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnets", subnets)

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the Subnets field.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "security_group_ids", value)

    @property
    @pulumi.getter
    def subnets(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The ID of the subnets in the VPC to which you want to connect to your monitoring jobs.
        """
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "subnets", value)


if not MYPY:
    class ModelCardAdditionalInformationArgsDict(TypedDict):
        caveats_and_recommendations: NotRequired[pulumi.Input[str]]
        """
        Caveats and recommendations for people who might use this model in their applications.
        """
        custom_details: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        customer details.
        """
        ethical_considerations: NotRequired[pulumi.Input[str]]
        """
        Any ethical considerations that the author wants to provide.
        """
elif False:
    ModelCardAdditionalInformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelCardAdditionalInformationArgs:
    def __init__(__self__, *,
                 caveats_and_recommendations: Optional[pulumi.Input[str]] = None,
                 custom_details: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 ethical_considerations: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] caveats_and_recommendations: Caveats and recommendations for people who might use this model in their applications.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] custom_details: customer details.
        :param pulumi.Input[str] ethical_considerations: Any ethical considerations that the author wants to provide.
        """
        if caveats_and_recommendations is not None:
            pulumi.set(__self__, "caveats_and_recommendations", caveats_and_recommendations)
        if custom_details is not None:
            pulumi.set(__self__, "custom_details", custom_details)
        if ethical_considerations is not None:
            pulumi.set(__self__, "ethical_considerations", ethical_considerations)

    @property
    @pulumi.getter(name="caveatsAndRecommendations")
    def caveats_and_recommendations(self) -> Optional[pulumi.Input[str]]:
        """
        Caveats and recommendations for people who might use this model in their applications.
        """
        return pulumi.get(self, "caveats_and_recommendations")

    @caveats_and_recommendations.setter
    def caveats_and_recommendations(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "caveats_and_recommendations", value)

    @property
    @pulumi.getter(name="customDetails")
    def custom_details(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        customer details.
        """
        return pulumi.get(self, "custom_details")

    @custom_details.setter
    def custom_details(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "custom_details", value)

    @property
    @pulumi.getter(name="ethicalConsiderations")
    def ethical_considerations(self) -> Optional[pulumi.Input[str]]:
        """
        Any ethical considerations that the author wants to provide.
        """
        return pulumi.get(self, "ethical_considerations")

    @ethical_considerations.setter
    def ethical_considerations(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ethical_considerations", value)


if not MYPY:
    class ModelCardBarChartMetricArgsDict(TypedDict):
        name: pulumi.Input[str]
        type: pulumi.Input['ModelCardBarChartMetricType']
        value: pulumi.Input[Sequence[pulumi.Input[float]]]
        notes: NotRequired[pulumi.Input[str]]
        x_axis_name: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        y_axis_name: NotRequired[pulumi.Input[str]]
elif False:
    ModelCardBarChartMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelCardBarChartMetricArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input['ModelCardBarChartMetricType'],
                 value: pulumi.Input[Sequence[pulumi.Input[float]]],
                 notes: Optional[pulumi.Input[str]] = None,
                 x_axis_name: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 y_axis_name: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)
        if notes is not None:
            pulumi.set(__self__, "notes", notes)
        if x_axis_name is not None:
            pulumi.set(__self__, "x_axis_name", x_axis_name)
        if y_axis_name is not None:
            pulumi.set(__self__, "y_axis_name", y_axis_name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input['ModelCardBarChartMetricType']:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['ModelCardBarChartMetricType']):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[Sequence[pulumi.Input[float]]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[Sequence[pulumi.Input[float]]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def notes(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "notes")

    @notes.setter
    def notes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "notes", value)

    @property
    @pulumi.getter(name="xAxisName")
    def x_axis_name(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "x_axis_name")

    @x_axis_name.setter
    def x_axis_name(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_axis_name", value)

    @property
    @pulumi.getter(name="yAxisName")
    def y_axis_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "y_axis_name")

    @y_axis_name.setter
    def y_axis_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "y_axis_name", value)


if not MYPY:
    class ModelCardBusinessDetailsArgsDict(TypedDict):
        """
        Business details.
        """
        business_problem: NotRequired[pulumi.Input[str]]
        """
        What business problem does the model solve?
        """
        business_stakeholders: NotRequired[pulumi.Input[str]]
        """
        Business stakeholders.
        """
        line_of_business: NotRequired[pulumi.Input[str]]
        """
        Line of business.
        """
elif False:
    ModelCardBusinessDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelCardBusinessDetailsArgs:
    def __init__(__self__, *,
                 business_problem: Optional[pulumi.Input[str]] = None,
                 business_stakeholders: Optional[pulumi.Input[str]] = None,
                 line_of_business: Optional[pulumi.Input[str]] = None):
        """
        Business details.
        :param pulumi.Input[str] business_problem: What business problem does the model solve?
        :param pulumi.Input[str] business_stakeholders: Business stakeholders.
        :param pulumi.Input[str] line_of_business: Line of business.
        """
        if business_problem is not None:
            pulumi.set(__self__, "business_problem", business_problem)
        if business_stakeholders is not None:
            pulumi.set(__self__, "business_stakeholders", business_stakeholders)
        if line_of_business is not None:
            pulumi.set(__self__, "line_of_business", line_of_business)

    @property
    @pulumi.getter(name="businessProblem")
    def business_problem(self) -> Optional[pulumi.Input[str]]:
        """
        What business problem does the model solve?
        """
        return pulumi.get(self, "business_problem")

    @business_problem.setter
    def business_problem(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "business_problem", value)

    @property
    @pulumi.getter(name="businessStakeholders")
    def business_stakeholders(self) -> Optional[pulumi.Input[str]]:
        """
        Business stakeholders.
        """
        return pulumi.get(self, "business_stakeholders")

    @business_stakeholders.setter
    def business_stakeholders(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "business_stakeholders", value)

    @property
    @pulumi.getter(name="lineOfBusiness")
    def line_of_business(self) -> Optional[pulumi.Input[str]]:
        """
        Line of business.
        """
        return pulumi.get(self, "line_of_business")

    @line_of_business.setter
    def line_of_business(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "line_of_business", value)


if not MYPY:
    class ModelCardContainerArgsDict(TypedDict):
        image: pulumi.Input[str]
        """
        Inference environment path. The Amazon EC2 Container Registry (Amazon ECR) path where inference code is stored.
        """
        model_data_url: NotRequired[pulumi.Input[str]]
        """
        The Amazon S3 path where the model artifacts, which result from model training, are stored.
        """
        nearest_model_name: NotRequired[pulumi.Input[str]]
        """
        The name of a pre-trained machine learning benchmarked by Amazon SageMaker Inference Recommender model that matches your model.
        """
elif False:
    ModelCardContainerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelCardContainerArgs:
    def __init__(__self__, *,
                 image: pulumi.Input[str],
                 model_data_url: Optional[pulumi.Input[str]] = None,
                 nearest_model_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] image: Inference environment path. The Amazon EC2 Container Registry (Amazon ECR) path where inference code is stored.
        :param pulumi.Input[str] model_data_url: The Amazon S3 path where the model artifacts, which result from model training, are stored.
        :param pulumi.Input[str] nearest_model_name: The name of a pre-trained machine learning benchmarked by Amazon SageMaker Inference Recommender model that matches your model.
        """
        pulumi.set(__self__, "image", image)
        if model_data_url is not None:
            pulumi.set(__self__, "model_data_url", model_data_url)
        if nearest_model_name is not None:
            pulumi.set(__self__, "nearest_model_name", nearest_model_name)

    @property
    @pulumi.getter
    def image(self) -> pulumi.Input[str]:
        """
        Inference environment path. The Amazon EC2 Container Registry (Amazon ECR) path where inference code is stored.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: pulumi.Input[str]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="modelDataUrl")
    def model_data_url(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon S3 path where the model artifacts, which result from model training, are stored.
        """
        return pulumi.get(self, "model_data_url")

    @model_data_url.setter
    def model_data_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "model_data_url", value)

    @property
    @pulumi.getter(name="nearestModelName")
    def nearest_model_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of a pre-trained machine learning benchmarked by Amazon SageMaker Inference Recommender model that matches your model.
        """
        return pulumi.get(self, "nearest_model_name")

    @nearest_model_name.setter
    def nearest_model_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nearest_model_name", value)


if not MYPY:
    class ModelCardContentArgsDict(TypedDict):
        """
        The content of the model card.
        """
        additional_information: NotRequired[pulumi.Input['ModelCardAdditionalInformationArgsDict']]
        """
        Additional information about the model.
        """
        business_details: NotRequired[pulumi.Input['ModelCardBusinessDetailsArgsDict']]
        """
        Information about how the model supports business goals.
        """
        evaluation_details: NotRequired[pulumi.Input[Sequence[pulumi.Input['ModelCardEvaluationDetailArgsDict']]]]
        """
        An overview about the model's evaluation.
        """
        intended_uses: NotRequired[pulumi.Input['ModelCardIntendedUsesArgsDict']]
        """
        The intended usage of the model.
        """
        model_overview: NotRequired[pulumi.Input['ModelCardModelOverviewArgsDict']]
        """
        An overview about the model
        """
        model_package_details: NotRequired[pulumi.Input['ModelCardModelPackageDetailsArgsDict']]
        training_details: NotRequired[pulumi.Input['ModelCardTrainingDetailsArgsDict']]
        """
        An overview about model training.
        """
elif False:
    ModelCardContentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelCardContentArgs:
    def __init__(__self__, *,
                 additional_information: Optional[pulumi.Input['ModelCardAdditionalInformationArgs']] = None,
                 business_details: Optional[pulumi.Input['ModelCardBusinessDetailsArgs']] = None,
                 evaluation_details: Optional[pulumi.Input[Sequence[pulumi.Input['ModelCardEvaluationDetailArgs']]]] = None,
                 intended_uses: Optional[pulumi.Input['ModelCardIntendedUsesArgs']] = None,
                 model_overview: Optional[pulumi.Input['ModelCardModelOverviewArgs']] = None,
                 model_package_details: Optional[pulumi.Input['ModelCardModelPackageDetailsArgs']] = None,
                 training_details: Optional[pulumi.Input['ModelCardTrainingDetailsArgs']] = None):
        """
        The content of the model card.
        :param pulumi.Input['ModelCardAdditionalInformationArgs'] additional_information: Additional information about the model.
        :param pulumi.Input['ModelCardBusinessDetailsArgs'] business_details: Information about how the model supports business goals.
        :param pulumi.Input[Sequence[pulumi.Input['ModelCardEvaluationDetailArgs']]] evaluation_details: An overview about the model's evaluation.
        :param pulumi.Input['ModelCardIntendedUsesArgs'] intended_uses: The intended usage of the model.
        :param pulumi.Input['ModelCardModelOverviewArgs'] model_overview: An overview about the model
        :param pulumi.Input['ModelCardTrainingDetailsArgs'] training_details: An overview about model training.
        """
        if additional_information is not None:
            pulumi.set(__self__, "additional_information", additional_information)
        if business_details is not None:
            pulumi.set(__self__, "business_details", business_details)
        if evaluation_details is not None:
            pulumi.set(__self__, "evaluation_details", evaluation_details)
        if intended_uses is not None:
            pulumi.set(__self__, "intended_uses", intended_uses)
        if model_overview is not None:
            pulumi.set(__self__, "model_overview", model_overview)
        if model_package_details is not None:
            pulumi.set(__self__, "model_package_details", model_package_details)
        if training_details is not None:
            pulumi.set(__self__, "training_details", training_details)

    @property
    @pulumi.getter(name="additionalInformation")
    def additional_information(self) -> Optional[pulumi.Input['ModelCardAdditionalInformationArgs']]:
        """
        Additional information about the model.
        """
        return pulumi.get(self, "additional_information")

    @additional_information.setter
    def additional_information(self, value: Optional[pulumi.Input['ModelCardAdditionalInformationArgs']]):
        pulumi.set(self, "additional_information", value)

    @property
    @pulumi.getter(name="businessDetails")
    def business_details(self) -> Optional[pulumi.Input['ModelCardBusinessDetailsArgs']]:
        """
        Information about how the model supports business goals.
        """
        return pulumi.get(self, "business_details")

    @business_details.setter
    def business_details(self, value: Optional[pulumi.Input['ModelCardBusinessDetailsArgs']]):
        pulumi.set(self, "business_details", value)

    @property
    @pulumi.getter(name="evaluationDetails")
    def evaluation_details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ModelCardEvaluationDetailArgs']]]]:
        """
        An overview about the model's evaluation.
        """
        return pulumi.get(self, "evaluation_details")

    @evaluation_details.setter
    def evaluation_details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ModelCardEvaluationDetailArgs']]]]):
        pulumi.set(self, "evaluation_details", value)

    @property
    @pulumi.getter(name="intendedUses")
    def intended_uses(self) -> Optional[pulumi.Input['ModelCardIntendedUsesArgs']]:
        """
        The intended usage of the model.
        """
        return pulumi.get(self, "intended_uses")

    @intended_uses.setter
    def intended_uses(self, value: Optional[pulumi.Input['ModelCardIntendedUsesArgs']]):
        pulumi.set(self, "intended_uses", value)

    @property
    @pulumi.getter(name="modelOverview")
    def model_overview(self) -> Optional[pulumi.Input['ModelCardModelOverviewArgs']]:
        """
        An overview about the model
        """
        return pulumi.get(self, "model_overview")

    @model_overview.setter
    def model_overview(self, value: Optional[pulumi.Input['ModelCardModelOverviewArgs']]):
        pulumi.set(self, "model_overview", value)

    @property
    @pulumi.getter(name="modelPackageDetails")
    def model_package_details(self) -> Optional[pulumi.Input['ModelCardModelPackageDetailsArgs']]:
        return pulumi.get(self, "model_package_details")

    @model_package_details.setter
    def model_package_details(self, value: Optional[pulumi.Input['ModelCardModelPackageDetailsArgs']]):
        pulumi.set(self, "model_package_details", value)

    @property
    @pulumi.getter(name="trainingDetails")
    def training_details(self) -> Optional[pulumi.Input['ModelCardTrainingDetailsArgs']]:
        """
        An overview about model training.
        """
        return pulumi.get(self, "training_details")

    @training_details.setter
    def training_details(self, value: Optional[pulumi.Input['ModelCardTrainingDetailsArgs']]):
        pulumi.set(self, "training_details", value)


if not MYPY:
    class ModelCardEvaluationDetailArgsDict(TypedDict):
        """
        item of evaluation details
        """
        name: pulumi.Input[str]
        datasets: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        evaluation_job_arn: NotRequired[pulumi.Input[str]]
        evaluation_observation: NotRequired[pulumi.Input[str]]
        metadata: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        additional attributes associated with the evaluation results.
        """
        metric_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input['ModelCardMetricGroupArgsDict']]]]
elif False:
    ModelCardEvaluationDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelCardEvaluationDetailArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 datasets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 evaluation_job_arn: Optional[pulumi.Input[str]] = None,
                 evaluation_observation: Optional[pulumi.Input[str]] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 metric_groups: Optional[pulumi.Input[Sequence[pulumi.Input['ModelCardMetricGroupArgs']]]] = None):
        """
        item of evaluation details
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] metadata: additional attributes associated with the evaluation results.
        """
        pulumi.set(__self__, "name", name)
        if datasets is not None:
            pulumi.set(__self__, "datasets", datasets)
        if evaluation_job_arn is not None:
            pulumi.set(__self__, "evaluation_job_arn", evaluation_job_arn)
        if evaluation_observation is not None:
            pulumi.set(__self__, "evaluation_observation", evaluation_observation)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if metric_groups is not None:
            pulumi.set(__self__, "metric_groups", metric_groups)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def datasets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "datasets")

    @datasets.setter
    def datasets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "datasets", value)

    @property
    @pulumi.getter(name="evaluationJobArn")
    def evaluation_job_arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "evaluation_job_arn")

    @evaluation_job_arn.setter
    def evaluation_job_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "evaluation_job_arn", value)

    @property
    @pulumi.getter(name="evaluationObservation")
    def evaluation_observation(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "evaluation_observation")

    @evaluation_observation.setter
    def evaluation_observation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "evaluation_observation", value)

    @property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        additional attributes associated with the evaluation results.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "metadata", value)

    @property
    @pulumi.getter(name="metricGroups")
    def metric_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ModelCardMetricGroupArgs']]]]:
        return pulumi.get(self, "metric_groups")

    @metric_groups.setter
    def metric_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ModelCardMetricGroupArgs']]]]):
        pulumi.set(self, "metric_groups", value)


if not MYPY:
    class ModelCardInferenceSpecificationArgsDict(TypedDict):
        containers: pulumi.Input[Sequence[pulumi.Input['ModelCardContainerArgsDict']]]
        """
        Contains inference related information which were used to create model package.
        """
elif False:
    ModelCardInferenceSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelCardInferenceSpecificationArgs:
    def __init__(__self__, *,
                 containers: pulumi.Input[Sequence[pulumi.Input['ModelCardContainerArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ModelCardContainerArgs']]] containers: Contains inference related information which were used to create model package.
        """
        pulumi.set(__self__, "containers", containers)

    @property
    @pulumi.getter
    def containers(self) -> pulumi.Input[Sequence[pulumi.Input['ModelCardContainerArgs']]]:
        """
        Contains inference related information which were used to create model package.
        """
        return pulumi.get(self, "containers")

    @containers.setter
    def containers(self, value: pulumi.Input[Sequence[pulumi.Input['ModelCardContainerArgs']]]):
        pulumi.set(self, "containers", value)


if not MYPY:
    class ModelCardIntendedUsesArgsDict(TypedDict):
        """
        Intended usage of model.
        """
        explanations_for_risk_rating: NotRequired[pulumi.Input[str]]
        """
        An explanation of why your organization categorizes the model with its risk rating.
        """
        factors_affecting_model_efficiency: NotRequired[pulumi.Input[str]]
        """
        Factors affecting model efficacy.
        """
        intended_uses: NotRequired[pulumi.Input[str]]
        """
        intended use cases.
        """
        purpose_of_model: NotRequired[pulumi.Input[str]]
        """
        Why the model was developed?
        """
        risk_rating: NotRequired[pulumi.Input['ModelCardRiskRating']]
        """
        Your organization's risk rating. You can specify one the following values as the risk rating:

        - High
        - Medium
        - Low
        - Unknown
        """
elif False:
    ModelCardIntendedUsesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelCardIntendedUsesArgs:
    def __init__(__self__, *,
                 explanations_for_risk_rating: Optional[pulumi.Input[str]] = None,
                 factors_affecting_model_efficiency: Optional[pulumi.Input[str]] = None,
                 intended_uses: Optional[pulumi.Input[str]] = None,
                 purpose_of_model: Optional[pulumi.Input[str]] = None,
                 risk_rating: Optional[pulumi.Input['ModelCardRiskRating']] = None):
        """
        Intended usage of model.
        :param pulumi.Input[str] explanations_for_risk_rating: An explanation of why your organization categorizes the model with its risk rating.
        :param pulumi.Input[str] factors_affecting_model_efficiency: Factors affecting model efficacy.
        :param pulumi.Input[str] intended_uses: intended use cases.
        :param pulumi.Input[str] purpose_of_model: Why the model was developed?
        :param pulumi.Input['ModelCardRiskRating'] risk_rating: Your organization's risk rating. You can specify one the following values as the risk rating:
               
               - High
               - Medium
               - Low
               - Unknown
        """
        if explanations_for_risk_rating is not None:
            pulumi.set(__self__, "explanations_for_risk_rating", explanations_for_risk_rating)
        if factors_affecting_model_efficiency is not None:
            pulumi.set(__self__, "factors_affecting_model_efficiency", factors_affecting_model_efficiency)
        if intended_uses is not None:
            pulumi.set(__self__, "intended_uses", intended_uses)
        if purpose_of_model is not None:
            pulumi.set(__self__, "purpose_of_model", purpose_of_model)
        if risk_rating is not None:
            pulumi.set(__self__, "risk_rating", risk_rating)

    @property
    @pulumi.getter(name="explanationsForRiskRating")
    def explanations_for_risk_rating(self) -> Optional[pulumi.Input[str]]:
        """
        An explanation of why your organization categorizes the model with its risk rating.
        """
        return pulumi.get(self, "explanations_for_risk_rating")

    @explanations_for_risk_rating.setter
    def explanations_for_risk_rating(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "explanations_for_risk_rating", value)

    @property
    @pulumi.getter(name="factorsAffectingModelEfficiency")
    def factors_affecting_model_efficiency(self) -> Optional[pulumi.Input[str]]:
        """
        Factors affecting model efficacy.
        """
        return pulumi.get(self, "factors_affecting_model_efficiency")

    @factors_affecting_model_efficiency.setter
    def factors_affecting_model_efficiency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "factors_affecting_model_efficiency", value)

    @property
    @pulumi.getter(name="intendedUses")
    def intended_uses(self) -> Optional[pulumi.Input[str]]:
        """
        intended use cases.
        """
        return pulumi.get(self, "intended_uses")

    @intended_uses.setter
    def intended_uses(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "intended_uses", value)

    @property
    @pulumi.getter(name="purposeOfModel")
    def purpose_of_model(self) -> Optional[pulumi.Input[str]]:
        """
        Why the model was developed?
        """
        return pulumi.get(self, "purpose_of_model")

    @purpose_of_model.setter
    def purpose_of_model(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "purpose_of_model", value)

    @property
    @pulumi.getter(name="riskRating")
    def risk_rating(self) -> Optional[pulumi.Input['ModelCardRiskRating']]:
        """
        Your organization's risk rating. You can specify one the following values as the risk rating:

        - High
        - Medium
        - Low
        - Unknown
        """
        return pulumi.get(self, "risk_rating")

    @risk_rating.setter
    def risk_rating(self, value: Optional[pulumi.Input['ModelCardRiskRating']]):
        pulumi.set(self, "risk_rating", value)


if not MYPY:
    class ModelCardLinearGraphMetricArgsDict(TypedDict):
        """
        Linear graph metric.
        """
        name: pulumi.Input[str]
        type: pulumi.Input['ModelCardLinearGraphMetricType']
        value: pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]]
        notes: NotRequired[pulumi.Input[str]]
        x_axis_name: NotRequired[pulumi.Input[str]]
        y_axis_name: NotRequired[pulumi.Input[str]]
elif False:
    ModelCardLinearGraphMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelCardLinearGraphMetricArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input['ModelCardLinearGraphMetricType'],
                 value: pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]],
                 notes: Optional[pulumi.Input[str]] = None,
                 x_axis_name: Optional[pulumi.Input[str]] = None,
                 y_axis_name: Optional[pulumi.Input[str]] = None):
        """
        Linear graph metric.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)
        if notes is not None:
            pulumi.set(__self__, "notes", notes)
        if x_axis_name is not None:
            pulumi.set(__self__, "x_axis_name", x_axis_name)
        if y_axis_name is not None:
            pulumi.set(__self__, "y_axis_name", y_axis_name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input['ModelCardLinearGraphMetricType']:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['ModelCardLinearGraphMetricType']):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def notes(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "notes")

    @notes.setter
    def notes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "notes", value)

    @property
    @pulumi.getter(name="xAxisName")
    def x_axis_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "x_axis_name")

    @x_axis_name.setter
    def x_axis_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_axis_name", value)

    @property
    @pulumi.getter(name="yAxisName")
    def y_axis_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "y_axis_name")

    @y_axis_name.setter
    def y_axis_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "y_axis_name", value)


if not MYPY:
    class ModelCardMatrixMetricArgsDict(TypedDict):
        name: pulumi.Input[str]
        type: pulumi.Input['ModelCardMatrixMetricType']
        value: pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]]
        notes: NotRequired[pulumi.Input[str]]
        x_axis_name: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        y_axis_name: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
elif False:
    ModelCardMatrixMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelCardMatrixMetricArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input['ModelCardMatrixMetricType'],
                 value: pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]],
                 notes: Optional[pulumi.Input[str]] = None,
                 x_axis_name: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 y_axis_name: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)
        if notes is not None:
            pulumi.set(__self__, "notes", notes)
        if x_axis_name is not None:
            pulumi.set(__self__, "x_axis_name", x_axis_name)
        if y_axis_name is not None:
            pulumi.set(__self__, "y_axis_name", y_axis_name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input['ModelCardMatrixMetricType']:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['ModelCardMatrixMetricType']):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[Sequence[pulumi.Input[Sequence[pulumi.Input[float]]]]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def notes(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "notes")

    @notes.setter
    def notes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "notes", value)

    @property
    @pulumi.getter(name="xAxisName")
    def x_axis_name(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "x_axis_name")

    @x_axis_name.setter
    def x_axis_name(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "x_axis_name", value)

    @property
    @pulumi.getter(name="yAxisName")
    def y_axis_name(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "y_axis_name")

    @y_axis_name.setter
    def y_axis_name(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "y_axis_name", value)


if not MYPY:
    class ModelCardMetricGroupArgsDict(TypedDict):
        """
        item in metric groups
        """
        metric_data: pulumi.Input[Sequence[pulumi.Input[Union['ModelCardSimpleMetricArgsDict', 'ModelCardLinearGraphMetricArgsDict', 'ModelCardBarChartMetricArgsDict', 'ModelCardMatrixMetricArgsDict']]]]
        name: pulumi.Input[str]
elif False:
    ModelCardMetricGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelCardMetricGroupArgs:
    def __init__(__self__, *,
                 metric_data: pulumi.Input[Sequence[pulumi.Input[Union['ModelCardSimpleMetricArgs', 'ModelCardLinearGraphMetricArgs', 'ModelCardBarChartMetricArgs', 'ModelCardMatrixMetricArgs']]]],
                 name: pulumi.Input[str]):
        """
        item in metric groups
        """
        pulumi.set(__self__, "metric_data", metric_data)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="metricData")
    def metric_data(self) -> pulumi.Input[Sequence[pulumi.Input[Union['ModelCardSimpleMetricArgs', 'ModelCardLinearGraphMetricArgs', 'ModelCardBarChartMetricArgs', 'ModelCardMatrixMetricArgs']]]]:
        return pulumi.get(self, "metric_data")

    @metric_data.setter
    def metric_data(self, value: pulumi.Input[Sequence[pulumi.Input[Union['ModelCardSimpleMetricArgs', 'ModelCardLinearGraphMetricArgs', 'ModelCardBarChartMetricArgs', 'ModelCardMatrixMetricArgs']]]]):
        pulumi.set(self, "metric_data", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ModelCardModelOverviewInferenceEnvironmentPropertiesArgsDict(TypedDict):
        """
        Overview about the inference.
        """
        container_image: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        SageMaker inference image uri.
        """
elif False:
    ModelCardModelOverviewInferenceEnvironmentPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelCardModelOverviewInferenceEnvironmentPropertiesArgs:
    def __init__(__self__, *,
                 container_image: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Overview about the inference.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] container_image: SageMaker inference image uri.
        """
        if container_image is not None:
            pulumi.set(__self__, "container_image", container_image)

    @property
    @pulumi.getter(name="containerImage")
    def container_image(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        SageMaker inference image uri.
        """
        return pulumi.get(self, "container_image")

    @container_image.setter
    def container_image(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "container_image", value)


if not MYPY:
    class ModelCardModelOverviewArgsDict(TypedDict):
        """
        Overview about the model.
        """
        algorithm_type: NotRequired[pulumi.Input[str]]
        """
        Algorithm used to solve the problem.
        """
        inference_environment: NotRequired[pulumi.Input['ModelCardModelOverviewInferenceEnvironmentPropertiesArgsDict']]
        """
        Overview about the inference.
        """
        model_artifact: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Location of the model artifact.
        """
        model_creator: NotRequired[pulumi.Input[str]]
        """
        Creator of model.
        """
        model_description: NotRequired[pulumi.Input[str]]
        """
        description of model.
        """
        model_id: NotRequired[pulumi.Input[str]]
        """
        SageMaker Model Arn or Non SageMaker Model id.
        """
        model_name: NotRequired[pulumi.Input[str]]
        """
        Name of the model.
        """
        model_owner: NotRequired[pulumi.Input[str]]
        """
        Owner of model.
        """
        model_version: NotRequired[pulumi.Input[float]]
        """
        Version of the model.
        """
        problem_type: NotRequired[pulumi.Input[str]]
        """
        Problem being solved with the model.
        """
elif False:
    ModelCardModelOverviewArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelCardModelOverviewArgs:
    def __init__(__self__, *,
                 algorithm_type: Optional[pulumi.Input[str]] = None,
                 inference_environment: Optional[pulumi.Input['ModelCardModelOverviewInferenceEnvironmentPropertiesArgs']] = None,
                 model_artifact: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 model_creator: Optional[pulumi.Input[str]] = None,
                 model_description: Optional[pulumi.Input[str]] = None,
                 model_id: Optional[pulumi.Input[str]] = None,
                 model_name: Optional[pulumi.Input[str]] = None,
                 model_owner: Optional[pulumi.Input[str]] = None,
                 model_version: Optional[pulumi.Input[float]] = None,
                 problem_type: Optional[pulumi.Input[str]] = None):
        """
        Overview about the model.
        :param pulumi.Input[str] algorithm_type: Algorithm used to solve the problem.
        :param pulumi.Input['ModelCardModelOverviewInferenceEnvironmentPropertiesArgs'] inference_environment: Overview about the inference.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] model_artifact: Location of the model artifact.
        :param pulumi.Input[str] model_creator: Creator of model.
        :param pulumi.Input[str] model_description: description of model.
        :param pulumi.Input[str] model_id: SageMaker Model Arn or Non SageMaker Model id.
        :param pulumi.Input[str] model_name: Name of the model.
        :param pulumi.Input[str] model_owner: Owner of model.
        :param pulumi.Input[float] model_version: Version of the model.
        :param pulumi.Input[str] problem_type: Problem being solved with the model.
        """
        if algorithm_type is not None:
            pulumi.set(__self__, "algorithm_type", algorithm_type)
        if inference_environment is not None:
            pulumi.set(__self__, "inference_environment", inference_environment)
        if model_artifact is not None:
            pulumi.set(__self__, "model_artifact", model_artifact)
        if model_creator is not None:
            pulumi.set(__self__, "model_creator", model_creator)
        if model_description is not None:
            pulumi.set(__self__, "model_description", model_description)
        if model_id is not None:
            pulumi.set(__self__, "model_id", model_id)
        if model_name is not None:
            pulumi.set(__self__, "model_name", model_name)
        if model_owner is not None:
            pulumi.set(__self__, "model_owner", model_owner)
        if model_version is not None:
            pulumi.set(__self__, "model_version", model_version)
        if problem_type is not None:
            pulumi.set(__self__, "problem_type", problem_type)

    @property
    @pulumi.getter(name="algorithmType")
    def algorithm_type(self) -> Optional[pulumi.Input[str]]:
        """
        Algorithm used to solve the problem.
        """
        return pulumi.get(self, "algorithm_type")

    @algorithm_type.setter
    def algorithm_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "algorithm_type", value)

    @property
    @pulumi.getter(name="inferenceEnvironment")
    def inference_environment(self) -> Optional[pulumi.Input['ModelCardModelOverviewInferenceEnvironmentPropertiesArgs']]:
        """
        Overview about the inference.
        """
        return pulumi.get(self, "inference_environment")

    @inference_environment.setter
    def inference_environment(self, value: Optional[pulumi.Input['ModelCardModelOverviewInferenceEnvironmentPropertiesArgs']]):
        pulumi.set(self, "inference_environment", value)

    @property
    @pulumi.getter(name="modelArtifact")
    def model_artifact(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Location of the model artifact.
        """
        return pulumi.get(self, "model_artifact")

    @model_artifact.setter
    def model_artifact(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "model_artifact", value)

    @property
    @pulumi.getter(name="modelCreator")
    def model_creator(self) -> Optional[pulumi.Input[str]]:
        """
        Creator of model.
        """
        return pulumi.get(self, "model_creator")

    @model_creator.setter
    def model_creator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "model_creator", value)

    @property
    @pulumi.getter(name="modelDescription")
    def model_description(self) -> Optional[pulumi.Input[str]]:
        """
        description of model.
        """
        return pulumi.get(self, "model_description")

    @model_description.setter
    def model_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "model_description", value)

    @property
    @pulumi.getter(name="modelId")
    def model_id(self) -> Optional[pulumi.Input[str]]:
        """
        SageMaker Model Arn or Non SageMaker Model id.
        """
        return pulumi.get(self, "model_id")

    @model_id.setter
    def model_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "model_id", value)

    @property
    @pulumi.getter(name="modelName")
    def model_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the model.
        """
        return pulumi.get(self, "model_name")

    @model_name.setter
    def model_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "model_name", value)

    @property
    @pulumi.getter(name="modelOwner")
    def model_owner(self) -> Optional[pulumi.Input[str]]:
        """
        Owner of model.
        """
        return pulumi.get(self, "model_owner")

    @model_owner.setter
    def model_owner(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "model_owner", value)

    @property
    @pulumi.getter(name="modelVersion")
    def model_version(self) -> Optional[pulumi.Input[float]]:
        """
        Version of the model.
        """
        return pulumi.get(self, "model_version")

    @model_version.setter
    def model_version(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "model_version", value)

    @property
    @pulumi.getter(name="problemType")
    def problem_type(self) -> Optional[pulumi.Input[str]]:
        """
        Problem being solved with the model.
        """
        return pulumi.get(self, "problem_type")

    @problem_type.setter
    def problem_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "problem_type", value)


if not MYPY:
    class ModelCardModelPackageCreatorArgsDict(TypedDict):
        user_profile_name: NotRequired[pulumi.Input[str]]
        """
        The name of the user's profile in Studio
        """
elif False:
    ModelCardModelPackageCreatorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelCardModelPackageCreatorArgs:
    def __init__(__self__, *,
                 user_profile_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] user_profile_name: The name of the user's profile in Studio
        """
        if user_profile_name is not None:
            pulumi.set(__self__, "user_profile_name", user_profile_name)

    @property
    @pulumi.getter(name="userProfileName")
    def user_profile_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the user's profile in Studio
        """
        return pulumi.get(self, "user_profile_name")

    @user_profile_name.setter
    def user_profile_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_profile_name", value)


if not MYPY:
    class ModelCardModelPackageDetailsArgsDict(TypedDict):
        """
        Metadata information related to model package version
        """
        approval_description: NotRequired[pulumi.Input[str]]
        """
        A description provided for the model approval
        """
        created_by: NotRequired[pulumi.Input['ModelCardModelPackageCreatorArgsDict']]
        """
        Information about the user who created model package.
        """
        domain: NotRequired[pulumi.Input[str]]
        """
        The machine learning domain of the model package you specified. Common machine learning domains include computer vision and natural language processing.
        """
        inference_specification: NotRequired[pulumi.Input['ModelCardInferenceSpecificationArgsDict']]
        """
        Details about inference jobs that can be run with models based on this model package.
        """
        model_approval_status: NotRequired[pulumi.Input['ModelCardModelPackageDetailsModelApprovalStatus']]
        """
        Current approval status of model package
        """
        model_package_arn: NotRequired[pulumi.Input[str]]
        """
        The Amazon Resource Name (ARN) of the model package
        """
        model_package_description: NotRequired[pulumi.Input[str]]
        """
        A brief summary of the model package
        """
        model_package_group_name: NotRequired[pulumi.Input[str]]
        """
        If the model is a versioned model, the name of the model group that the versioned model belongs to.
        """
        model_package_name: NotRequired[pulumi.Input[str]]
        """
        Name of the model package
        """
        model_package_status: NotRequired[pulumi.Input['ModelCardModelPackageDetailsModelPackageStatus']]
        """
        Current status of model package
        """
        model_package_version: NotRequired[pulumi.Input[float]]
        """
        Version of the model package
        """
        source_algorithms: NotRequired[pulumi.Input[Sequence[pulumi.Input['ModelCardSourceAlgorithmArgsDict']]]]
        """
        A list of algorithms that were used to create a model package.
        """
        task: NotRequired[pulumi.Input[str]]
        """
        The machine learning task you specified that your model package accomplishes. Common machine learning tasks include object detection and image classification.
        """
elif False:
    ModelCardModelPackageDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelCardModelPackageDetailsArgs:
    def __init__(__self__, *,
                 approval_description: Optional[pulumi.Input[str]] = None,
                 created_by: Optional[pulumi.Input['ModelCardModelPackageCreatorArgs']] = None,
                 domain: Optional[pulumi.Input[str]] = None,
                 inference_specification: Optional[pulumi.Input['ModelCardInferenceSpecificationArgs']] = None,
                 model_approval_status: Optional[pulumi.Input['ModelCardModelPackageDetailsModelApprovalStatus']] = None,
                 model_package_arn: Optional[pulumi.Input[str]] = None,
                 model_package_description: Optional[pulumi.Input[str]] = None,
                 model_package_group_name: Optional[pulumi.Input[str]] = None,
                 model_package_name: Optional[pulumi.Input[str]] = None,
                 model_package_status: Optional[pulumi.Input['ModelCardModelPackageDetailsModelPackageStatus']] = None,
                 model_package_version: Optional[pulumi.Input[float]] = None,
                 source_algorithms: Optional[pulumi.Input[Sequence[pulumi.Input['ModelCardSourceAlgorithmArgs']]]] = None,
                 task: Optional[pulumi.Input[str]] = None):
        """
        Metadata information related to model package version
        :param pulumi.Input[str] approval_description: A description provided for the model approval
        :param pulumi.Input['ModelCardModelPackageCreatorArgs'] created_by: Information about the user who created model package.
        :param pulumi.Input[str] domain: The machine learning domain of the model package you specified. Common machine learning domains include computer vision and natural language processing.
        :param pulumi.Input['ModelCardInferenceSpecificationArgs'] inference_specification: Details about inference jobs that can be run with models based on this model package.
        :param pulumi.Input['ModelCardModelPackageDetailsModelApprovalStatus'] model_approval_status: Current approval status of model package
        :param pulumi.Input[str] model_package_arn: The Amazon Resource Name (ARN) of the model package
        :param pulumi.Input[str] model_package_description: A brief summary of the model package
        :param pulumi.Input[str] model_package_group_name: If the model is a versioned model, the name of the model group that the versioned model belongs to.
        :param pulumi.Input[str] model_package_name: Name of the model package
        :param pulumi.Input['ModelCardModelPackageDetailsModelPackageStatus'] model_package_status: Current status of model package
        :param pulumi.Input[float] model_package_version: Version of the model package
        :param pulumi.Input[Sequence[pulumi.Input['ModelCardSourceAlgorithmArgs']]] source_algorithms: A list of algorithms that were used to create a model package.
        :param pulumi.Input[str] task: The machine learning task you specified that your model package accomplishes. Common machine learning tasks include object detection and image classification.
        """
        if approval_description is not None:
            pulumi.set(__self__, "approval_description", approval_description)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if inference_specification is not None:
            pulumi.set(__self__, "inference_specification", inference_specification)
        if model_approval_status is not None:
            pulumi.set(__self__, "model_approval_status", model_approval_status)
        if model_package_arn is not None:
            pulumi.set(__self__, "model_package_arn", model_package_arn)
        if model_package_description is not None:
            pulumi.set(__self__, "model_package_description", model_package_description)
        if model_package_group_name is not None:
            pulumi.set(__self__, "model_package_group_name", model_package_group_name)
        if model_package_name is not None:
            pulumi.set(__self__, "model_package_name", model_package_name)
        if model_package_status is not None:
            pulumi.set(__self__, "model_package_status", model_package_status)
        if model_package_version is not None:
            pulumi.set(__self__, "model_package_version", model_package_version)
        if source_algorithms is not None:
            pulumi.set(__self__, "source_algorithms", source_algorithms)
        if task is not None:
            pulumi.set(__self__, "task", task)

    @property
    @pulumi.getter(name="approvalDescription")
    def approval_description(self) -> Optional[pulumi.Input[str]]:
        """
        A description provided for the model approval
        """
        return pulumi.get(self, "approval_description")

    @approval_description.setter
    def approval_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "approval_description", value)

    @property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[pulumi.Input['ModelCardModelPackageCreatorArgs']]:
        """
        Information about the user who created model package.
        """
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: Optional[pulumi.Input['ModelCardModelPackageCreatorArgs']]):
        pulumi.set(self, "created_by", value)

    @property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[str]]:
        """
        The machine learning domain of the model package you specified. Common machine learning domains include computer vision and natural language processing.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter(name="inferenceSpecification")
    def inference_specification(self) -> Optional[pulumi.Input['ModelCardInferenceSpecificationArgs']]:
        """
        Details about inference jobs that can be run with models based on this model package.
        """
        return pulumi.get(self, "inference_specification")

    @inference_specification.setter
    def inference_specification(self, value: Optional[pulumi.Input['ModelCardInferenceSpecificationArgs']]):
        pulumi.set(self, "inference_specification", value)

    @property
    @pulumi.getter(name="modelApprovalStatus")
    def model_approval_status(self) -> Optional[pulumi.Input['ModelCardModelPackageDetailsModelApprovalStatus']]:
        """
        Current approval status of model package
        """
        return pulumi.get(self, "model_approval_status")

    @model_approval_status.setter
    def model_approval_status(self, value: Optional[pulumi.Input['ModelCardModelPackageDetailsModelApprovalStatus']]):
        pulumi.set(self, "model_approval_status", value)

    @property
    @pulumi.getter(name="modelPackageArn")
    def model_package_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon Resource Name (ARN) of the model package
        """
        return pulumi.get(self, "model_package_arn")

    @model_package_arn.setter
    def model_package_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "model_package_arn", value)

    @property
    @pulumi.getter(name="modelPackageDescription")
    def model_package_description(self) -> Optional[pulumi.Input[str]]:
        """
        A brief summary of the model package
        """
        return pulumi.get(self, "model_package_description")

    @model_package_description.setter
    def model_package_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "model_package_description", value)

    @property
    @pulumi.getter(name="modelPackageGroupName")
    def model_package_group_name(self) -> Optional[pulumi.Input[str]]:
        """
        If the model is a versioned model, the name of the model group that the versioned model belongs to.
        """
        return pulumi.get(self, "model_package_group_name")

    @model_package_group_name.setter
    def model_package_group_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "model_package_group_name", value)

    @property
    @pulumi.getter(name="modelPackageName")
    def model_package_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the model package
        """
        return pulumi.get(self, "model_package_name")

    @model_package_name.setter
    def model_package_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "model_package_name", value)

    @property
    @pulumi.getter(name="modelPackageStatus")
    def model_package_status(self) -> Optional[pulumi.Input['ModelCardModelPackageDetailsModelPackageStatus']]:
        """
        Current status of model package
        """
        return pulumi.get(self, "model_package_status")

    @model_package_status.setter
    def model_package_status(self, value: Optional[pulumi.Input['ModelCardModelPackageDetailsModelPackageStatus']]):
        pulumi.set(self, "model_package_status", value)

    @property
    @pulumi.getter(name="modelPackageVersion")
    def model_package_version(self) -> Optional[pulumi.Input[float]]:
        """
        Version of the model package
        """
        return pulumi.get(self, "model_package_version")

    @model_package_version.setter
    def model_package_version(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "model_package_version", value)

    @property
    @pulumi.getter(name="sourceAlgorithms")
    def source_algorithms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ModelCardSourceAlgorithmArgs']]]]:
        """
        A list of algorithms that were used to create a model package.
        """
        return pulumi.get(self, "source_algorithms")

    @source_algorithms.setter
    def source_algorithms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ModelCardSourceAlgorithmArgs']]]]):
        pulumi.set(self, "source_algorithms", value)

    @property
    @pulumi.getter
    def task(self) -> Optional[pulumi.Input[str]]:
        """
        The machine learning task you specified that your model package accomplishes. Common machine learning tasks include object detection and image classification.
        """
        return pulumi.get(self, "task")

    @task.setter
    def task(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "task", value)


if not MYPY:
    class ModelCardObjectiveFunctionFunctionPropertiesArgsDict(TypedDict):
        """
        objective function that training job is optimized for.
        """
        condition: NotRequired[pulumi.Input[str]]
        facet: NotRequired[pulumi.Input[str]]
        function: NotRequired[pulumi.Input['ModelCardObjectiveFunctionFunctionPropertiesFunction']]
elif False:
    ModelCardObjectiveFunctionFunctionPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelCardObjectiveFunctionFunctionPropertiesArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input[str]] = None,
                 facet: Optional[pulumi.Input[str]] = None,
                 function: Optional[pulumi.Input['ModelCardObjectiveFunctionFunctionPropertiesFunction']] = None):
        """
        objective function that training job is optimized for.
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if function is not None:
            pulumi.set(__self__, "function", function)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def facet(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "facet")

    @facet.setter
    def facet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "facet", value)

    @property
    @pulumi.getter
    def function(self) -> Optional[pulumi.Input['ModelCardObjectiveFunctionFunctionPropertiesFunction']]:
        return pulumi.get(self, "function")

    @function.setter
    def function(self, value: Optional[pulumi.Input['ModelCardObjectiveFunctionFunctionPropertiesFunction']]):
        pulumi.set(self, "function", value)


if not MYPY:
    class ModelCardObjectiveFunctionArgsDict(TypedDict):
        """
        the objective function the model will optimize for.
        """
        function: NotRequired[pulumi.Input['ModelCardObjectiveFunctionFunctionPropertiesArgsDict']]
        """
        objective function that training job is optimized for.
        """
        notes: NotRequired[pulumi.Input[str]]
        """
        Notes about the object function, including other considerations for possible objective functions.
        """
elif False:
    ModelCardObjectiveFunctionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelCardObjectiveFunctionArgs:
    def __init__(__self__, *,
                 function: Optional[pulumi.Input['ModelCardObjectiveFunctionFunctionPropertiesArgs']] = None,
                 notes: Optional[pulumi.Input[str]] = None):
        """
        the objective function the model will optimize for.
        :param pulumi.Input['ModelCardObjectiveFunctionFunctionPropertiesArgs'] function: objective function that training job is optimized for.
        :param pulumi.Input[str] notes: Notes about the object function, including other considerations for possible objective functions.
        """
        if function is not None:
            pulumi.set(__self__, "function", function)
        if notes is not None:
            pulumi.set(__self__, "notes", notes)

    @property
    @pulumi.getter
    def function(self) -> Optional[pulumi.Input['ModelCardObjectiveFunctionFunctionPropertiesArgs']]:
        """
        objective function that training job is optimized for.
        """
        return pulumi.get(self, "function")

    @function.setter
    def function(self, value: Optional[pulumi.Input['ModelCardObjectiveFunctionFunctionPropertiesArgs']]):
        pulumi.set(self, "function", value)

    @property
    @pulumi.getter
    def notes(self) -> Optional[pulumi.Input[str]]:
        """
        Notes about the object function, including other considerations for possible objective functions.
        """
        return pulumi.get(self, "notes")

    @notes.setter
    def notes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "notes", value)


if not MYPY:
    class ModelCardSecurityConfigArgsDict(TypedDict):
        """
        An optional Key Management Service key to encrypt, decrypt, and re-encrypt model card content for regulated workloads with highly sensitive data.
        """
        kms_key_id: NotRequired[pulumi.Input[str]]
        """
        A Key Management Service key ID to use for encrypting a model card.
        """
elif False:
    ModelCardSecurityConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelCardSecurityConfigArgs:
    def __init__(__self__, *,
                 kms_key_id: Optional[pulumi.Input[str]] = None):
        """
        An optional Key Management Service key to encrypt, decrypt, and re-encrypt model card content for regulated workloads with highly sensitive data.


        :param pulumi.Input[str] kms_key_id: A Key Management Service key ID to use for encrypting a model card.
        """
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        A Key Management Service key ID to use for encrypting a model card.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)


if not MYPY:
    class ModelCardSimpleMetricArgsDict(TypedDict):
        """
        metric data
        """
        name: pulumi.Input[str]
        type: pulumi.Input['ModelCardSimpleMetricType']
        value: pulumi.Input[Union[float, str, bool]]
        notes: NotRequired[pulumi.Input[str]]
        x_axis_name: NotRequired[pulumi.Input[str]]
        y_axis_name: NotRequired[pulumi.Input[str]]
elif False:
    ModelCardSimpleMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelCardSimpleMetricArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input['ModelCardSimpleMetricType'],
                 value: pulumi.Input[Union[float, str, bool]],
                 notes: Optional[pulumi.Input[str]] = None,
                 x_axis_name: Optional[pulumi.Input[str]] = None,
                 y_axis_name: Optional[pulumi.Input[str]] = None):
        """
        metric data
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)
        if notes is not None:
            pulumi.set(__self__, "notes", notes)
        if x_axis_name is not None:
            pulumi.set(__self__, "x_axis_name", x_axis_name)
        if y_axis_name is not None:
            pulumi.set(__self__, "y_axis_name", y_axis_name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input['ModelCardSimpleMetricType']:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['ModelCardSimpleMetricType']):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[Union[float, str, bool]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[Union[float, str, bool]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def notes(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "notes")

    @notes.setter
    def notes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "notes", value)

    @property
    @pulumi.getter(name="xAxisName")
    def x_axis_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "x_axis_name")

    @x_axis_name.setter
    def x_axis_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x_axis_name", value)

    @property
    @pulumi.getter(name="yAxisName")
    def y_axis_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "y_axis_name")

    @y_axis_name.setter
    def y_axis_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "y_axis_name", value)


if not MYPY:
    class ModelCardSourceAlgorithmArgsDict(TypedDict):
        algorithm_name: pulumi.Input[str]
        """
        The name of an algorithm that was used to create the model package. The algorithm must be either an algorithm resource in your SageMaker account or an algorithm in AWS Marketplace that you are subscribed to.
        """
        model_data_url: NotRequired[pulumi.Input[str]]
        """
        The Amazon S3 path where the model artifacts, which result from model training, are stored.
        """
elif False:
    ModelCardSourceAlgorithmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelCardSourceAlgorithmArgs:
    def __init__(__self__, *,
                 algorithm_name: pulumi.Input[str],
                 model_data_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] algorithm_name: The name of an algorithm that was used to create the model package. The algorithm must be either an algorithm resource in your SageMaker account or an algorithm in AWS Marketplace that you are subscribed to.
        :param pulumi.Input[str] model_data_url: The Amazon S3 path where the model artifacts, which result from model training, are stored.
        """
        pulumi.set(__self__, "algorithm_name", algorithm_name)
        if model_data_url is not None:
            pulumi.set(__self__, "model_data_url", model_data_url)

    @property
    @pulumi.getter(name="algorithmName")
    def algorithm_name(self) -> pulumi.Input[str]:
        """
        The name of an algorithm that was used to create the model package. The algorithm must be either an algorithm resource in your SageMaker account or an algorithm in AWS Marketplace that you are subscribed to.
        """
        return pulumi.get(self, "algorithm_name")

    @algorithm_name.setter
    def algorithm_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "algorithm_name", value)

    @property
    @pulumi.getter(name="modelDataUrl")
    def model_data_url(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon S3 path where the model artifacts, which result from model training, are stored.
        """
        return pulumi.get(self, "model_data_url")

    @model_data_url.setter
    def model_data_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "model_data_url", value)


if not MYPY:
    class ModelCardTrainingDetailsTrainingJobDetailsPropertiesTrainingEnvironmentPropertiesArgsDict(TypedDict):
        container_image: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        SageMaker training image uri.
        """
elif False:
    ModelCardTrainingDetailsTrainingJobDetailsPropertiesTrainingEnvironmentPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelCardTrainingDetailsTrainingJobDetailsPropertiesTrainingEnvironmentPropertiesArgs:
    def __init__(__self__, *,
                 container_image: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] container_image: SageMaker training image uri.
        """
        if container_image is not None:
            pulumi.set(__self__, "container_image", container_image)

    @property
    @pulumi.getter(name="containerImage")
    def container_image(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        SageMaker training image uri.
        """
        return pulumi.get(self, "container_image")

    @container_image.setter
    def container_image(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "container_image", value)


if not MYPY:
    class ModelCardTrainingDetailsTrainingJobDetailsPropertiesArgsDict(TypedDict):
        """
        Details about any associated training jobs.
        """
        hyper_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['ModelCardTrainingHyperParameterArgsDict']]]]
        training_arn: NotRequired[pulumi.Input[str]]
        """
        SageMaker Training job arn.
        """
        training_datasets: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Location of the model datasets.
        """
        training_environment: NotRequired[pulumi.Input['ModelCardTrainingDetailsTrainingJobDetailsPropertiesTrainingEnvironmentPropertiesArgsDict']]
        training_metrics: NotRequired[pulumi.Input[Sequence[pulumi.Input['ModelCardTrainingMetricArgsDict']]]]
        user_provided_hyper_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['ModelCardTrainingHyperParameterArgsDict']]]]
        user_provided_training_metrics: NotRequired[pulumi.Input[Sequence[pulumi.Input['ModelCardTrainingMetricArgsDict']]]]
elif False:
    ModelCardTrainingDetailsTrainingJobDetailsPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelCardTrainingDetailsTrainingJobDetailsPropertiesArgs:
    def __init__(__self__, *,
                 hyper_parameters: Optional[pulumi.Input[Sequence[pulumi.Input['ModelCardTrainingHyperParameterArgs']]]] = None,
                 training_arn: Optional[pulumi.Input[str]] = None,
                 training_datasets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 training_environment: Optional[pulumi.Input['ModelCardTrainingDetailsTrainingJobDetailsPropertiesTrainingEnvironmentPropertiesArgs']] = None,
                 training_metrics: Optional[pulumi.Input[Sequence[pulumi.Input['ModelCardTrainingMetricArgs']]]] = None,
                 user_provided_hyper_parameters: Optional[pulumi.Input[Sequence[pulumi.Input['ModelCardTrainingHyperParameterArgs']]]] = None,
                 user_provided_training_metrics: Optional[pulumi.Input[Sequence[pulumi.Input['ModelCardTrainingMetricArgs']]]] = None):
        """
        Details about any associated training jobs.
        :param pulumi.Input[str] training_arn: SageMaker Training job arn.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] training_datasets: Location of the model datasets.
        """
        if hyper_parameters is not None:
            pulumi.set(__self__, "hyper_parameters", hyper_parameters)
        if training_arn is not None:
            pulumi.set(__self__, "training_arn", training_arn)
        if training_datasets is not None:
            pulumi.set(__self__, "training_datasets", training_datasets)
        if training_environment is not None:
            pulumi.set(__self__, "training_environment", training_environment)
        if training_metrics is not None:
            pulumi.set(__self__, "training_metrics", training_metrics)
        if user_provided_hyper_parameters is not None:
            pulumi.set(__self__, "user_provided_hyper_parameters", user_provided_hyper_parameters)
        if user_provided_training_metrics is not None:
            pulumi.set(__self__, "user_provided_training_metrics", user_provided_training_metrics)

    @property
    @pulumi.getter(name="hyperParameters")
    def hyper_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ModelCardTrainingHyperParameterArgs']]]]:
        return pulumi.get(self, "hyper_parameters")

    @hyper_parameters.setter
    def hyper_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ModelCardTrainingHyperParameterArgs']]]]):
        pulumi.set(self, "hyper_parameters", value)

    @property
    @pulumi.getter(name="trainingArn")
    def training_arn(self) -> Optional[pulumi.Input[str]]:
        """
        SageMaker Training job arn.
        """
        return pulumi.get(self, "training_arn")

    @training_arn.setter
    def training_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "training_arn", value)

    @property
    @pulumi.getter(name="trainingDatasets")
    def training_datasets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Location of the model datasets.
        """
        return pulumi.get(self, "training_datasets")

    @training_datasets.setter
    def training_datasets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "training_datasets", value)

    @property
    @pulumi.getter(name="trainingEnvironment")
    def training_environment(self) -> Optional[pulumi.Input['ModelCardTrainingDetailsTrainingJobDetailsPropertiesTrainingEnvironmentPropertiesArgs']]:
        return pulumi.get(self, "training_environment")

    @training_environment.setter
    def training_environment(self, value: Optional[pulumi.Input['ModelCardTrainingDetailsTrainingJobDetailsPropertiesTrainingEnvironmentPropertiesArgs']]):
        pulumi.set(self, "training_environment", value)

    @property
    @pulumi.getter(name="trainingMetrics")
    def training_metrics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ModelCardTrainingMetricArgs']]]]:
        return pulumi.get(self, "training_metrics")

    @training_metrics.setter
    def training_metrics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ModelCardTrainingMetricArgs']]]]):
        pulumi.set(self, "training_metrics", value)

    @property
    @pulumi.getter(name="userProvidedHyperParameters")
    def user_provided_hyper_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ModelCardTrainingHyperParameterArgs']]]]:
        return pulumi.get(self, "user_provided_hyper_parameters")

    @user_provided_hyper_parameters.setter
    def user_provided_hyper_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ModelCardTrainingHyperParameterArgs']]]]):
        pulumi.set(self, "user_provided_hyper_parameters", value)

    @property
    @pulumi.getter(name="userProvidedTrainingMetrics")
    def user_provided_training_metrics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ModelCardTrainingMetricArgs']]]]:
        return pulumi.get(self, "user_provided_training_metrics")

    @user_provided_training_metrics.setter
    def user_provided_training_metrics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ModelCardTrainingMetricArgs']]]]):
        pulumi.set(self, "user_provided_training_metrics", value)


if not MYPY:
    class ModelCardTrainingDetailsArgsDict(TypedDict):
        """
        Overview about the training.
        """
        objective_function: NotRequired[pulumi.Input['ModelCardObjectiveFunctionArgsDict']]
        """
        The function that is optimized during model training.
        """
        training_job_details: NotRequired[pulumi.Input['ModelCardTrainingDetailsTrainingJobDetailsPropertiesArgsDict']]
        """
        Details about any associated training jobs.
        """
        training_observations: NotRequired[pulumi.Input[str]]
        """
        Any observations about training.
        """
elif False:
    ModelCardTrainingDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelCardTrainingDetailsArgs:
    def __init__(__self__, *,
                 objective_function: Optional[pulumi.Input['ModelCardObjectiveFunctionArgs']] = None,
                 training_job_details: Optional[pulumi.Input['ModelCardTrainingDetailsTrainingJobDetailsPropertiesArgs']] = None,
                 training_observations: Optional[pulumi.Input[str]] = None):
        """
        Overview about the training.
        :param pulumi.Input['ModelCardObjectiveFunctionArgs'] objective_function: The function that is optimized during model training.
        :param pulumi.Input['ModelCardTrainingDetailsTrainingJobDetailsPropertiesArgs'] training_job_details: Details about any associated training jobs.
        :param pulumi.Input[str] training_observations: Any observations about training.
        """
        if objective_function is not None:
            pulumi.set(__self__, "objective_function", objective_function)
        if training_job_details is not None:
            pulumi.set(__self__, "training_job_details", training_job_details)
        if training_observations is not None:
            pulumi.set(__self__, "training_observations", training_observations)

    @property
    @pulumi.getter(name="objectiveFunction")
    def objective_function(self) -> Optional[pulumi.Input['ModelCardObjectiveFunctionArgs']]:
        """
        The function that is optimized during model training.
        """
        return pulumi.get(self, "objective_function")

    @objective_function.setter
    def objective_function(self, value: Optional[pulumi.Input['ModelCardObjectiveFunctionArgs']]):
        pulumi.set(self, "objective_function", value)

    @property
    @pulumi.getter(name="trainingJobDetails")
    def training_job_details(self) -> Optional[pulumi.Input['ModelCardTrainingDetailsTrainingJobDetailsPropertiesArgs']]:
        """
        Details about any associated training jobs.
        """
        return pulumi.get(self, "training_job_details")

    @training_job_details.setter
    def training_job_details(self, value: Optional[pulumi.Input['ModelCardTrainingDetailsTrainingJobDetailsPropertiesArgs']]):
        pulumi.set(self, "training_job_details", value)

    @property
    @pulumi.getter(name="trainingObservations")
    def training_observations(self) -> Optional[pulumi.Input[str]]:
        """
        Any observations about training.
        """
        return pulumi.get(self, "training_observations")

    @training_observations.setter
    def training_observations(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "training_observations", value)


if not MYPY:
    class ModelCardTrainingHyperParameterArgsDict(TypedDict):
        """
        training hyper parameter
        """
        name: pulumi.Input[str]
        """
        The name of the hyper parameter.
        """
        value: pulumi.Input[str]
        """
        The value specified for the hyper parameter.
        """
elif False:
    ModelCardTrainingHyperParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelCardTrainingHyperParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        training hyper parameter
        :param pulumi.Input[str] name: The name of the hyper parameter.
        :param pulumi.Input[str] value: The value specified for the hyper parameter.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the hyper parameter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value specified for the hyper parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ModelCardTrainingMetricArgsDict(TypedDict):
        """
        training metric data.
        """
        name: pulumi.Input[str]
        """
        The name of the result from the SageMaker training job.
        """
        value: pulumi.Input[float]
        """
        The value of a result from the SageMaker training job.
        """
        notes: NotRequired[pulumi.Input[str]]
        """
        Any additional notes describing the result of the training job.
        """
elif False:
    ModelCardTrainingMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelCardTrainingMetricArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[float],
                 notes: Optional[pulumi.Input[str]] = None):
        """
        training metric data.
        :param pulumi.Input[str] name: The name of the result from the SageMaker training job.
        :param pulumi.Input[float] value: The value of a result from the SageMaker training job.
        :param pulumi.Input[str] notes: Any additional notes describing the result of the training job.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if notes is not None:
            pulumi.set(__self__, "notes", notes)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the result from the SageMaker training job.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        The value of a result from the SageMaker training job.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def notes(self) -> Optional[pulumi.Input[str]]:
        """
        Any additional notes describing the result of the training job.
        """
        return pulumi.get(self, "notes")

    @notes.setter
    def notes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "notes", value)


if not MYPY:
    class ModelCardUserContextArgsDict(TypedDict):
        """
        Information about the user who created or modified an experiment, trial, trial component, lineage group, project, or model card.
        """
        domain_id: NotRequired[pulumi.Input[str]]
        """
        The domain associated with the user.
        """
        user_profile_arn: NotRequired[pulumi.Input[str]]
        """
        The Amazon Resource Name (ARN) of the user's profile.
        """
        user_profile_name: NotRequired[pulumi.Input[str]]
        """
        The name of the user's profile.
        """
elif False:
    ModelCardUserContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelCardUserContextArgs:
    def __init__(__self__, *,
                 domain_id: Optional[pulumi.Input[str]] = None,
                 user_profile_arn: Optional[pulumi.Input[str]] = None,
                 user_profile_name: Optional[pulumi.Input[str]] = None):
        """
        Information about the user who created or modified an experiment, trial, trial component, lineage group, project, or model card.
        :param pulumi.Input[str] domain_id: The domain associated with the user.
        :param pulumi.Input[str] user_profile_arn: The Amazon Resource Name (ARN) of the user's profile.
        :param pulumi.Input[str] user_profile_name: The name of the user's profile.
        """
        if domain_id is not None:
            pulumi.set(__self__, "domain_id", domain_id)
        if user_profile_arn is not None:
            pulumi.set(__self__, "user_profile_arn", user_profile_arn)
        if user_profile_name is not None:
            pulumi.set(__self__, "user_profile_name", user_profile_name)

    @property
    @pulumi.getter(name="domainId")
    def domain_id(self) -> Optional[pulumi.Input[str]]:
        """
        The domain associated with the user.
        """
        return pulumi.get(self, "domain_id")

    @domain_id.setter
    def domain_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain_id", value)

    @property
    @pulumi.getter(name="userProfileArn")
    def user_profile_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon Resource Name (ARN) of the user's profile.
        """
        return pulumi.get(self, "user_profile_arn")

    @user_profile_arn.setter
    def user_profile_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_profile_arn", value)

    @property
    @pulumi.getter(name="userProfileName")
    def user_profile_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the user's profile.
        """
        return pulumi.get(self, "user_profile_name")

    @user_profile_name.setter
    def user_profile_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_profile_name", value)


if not MYPY:
    class ModelExplainabilityJobDefinitionBatchTransformInputArgsDict(TypedDict):
        """
        The batch transform input for a monitoring job.
        """
        data_captured_destination_s3_uri: pulumi.Input[str]
        """
        A URI that identifies the Amazon S3 storage location where Batch Transform Job captures data.
        """
        dataset_format: pulumi.Input['ModelExplainabilityJobDefinitionDatasetFormatArgsDict']
        """
        The dataset format for your batch transform job.
        """
        local_path: pulumi.Input[str]
        """
        Path to the filesystem where the endpoint data is available to the container.
        """
        features_attribute: NotRequired[pulumi.Input[str]]
        """
        JSONpath to locate features in JSONlines dataset
        """
        inference_attribute: NotRequired[pulumi.Input[str]]
        """
        Index or JSONpath to locate predicted label(s)
        """
        probability_attribute: NotRequired[pulumi.Input[str]]
        """
        Index or JSONpath to locate probabilities
        """
        s3_data_distribution_type: NotRequired[pulumi.Input['ModelExplainabilityJobDefinitionBatchTransformInputS3DataDistributionType']]
        """
        Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
        """
        s3_input_mode: NotRequired[pulumi.Input['ModelExplainabilityJobDefinitionBatchTransformInputS3InputMode']]
        """
        Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
        """
elif False:
    ModelExplainabilityJobDefinitionBatchTransformInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelExplainabilityJobDefinitionBatchTransformInputArgs:
    def __init__(__self__, *,
                 data_captured_destination_s3_uri: pulumi.Input[str],
                 dataset_format: pulumi.Input['ModelExplainabilityJobDefinitionDatasetFormatArgs'],
                 local_path: pulumi.Input[str],
                 features_attribute: Optional[pulumi.Input[str]] = None,
                 inference_attribute: Optional[pulumi.Input[str]] = None,
                 probability_attribute: Optional[pulumi.Input[str]] = None,
                 s3_data_distribution_type: Optional[pulumi.Input['ModelExplainabilityJobDefinitionBatchTransformInputS3DataDistributionType']] = None,
                 s3_input_mode: Optional[pulumi.Input['ModelExplainabilityJobDefinitionBatchTransformInputS3InputMode']] = None):
        """
        The batch transform input for a monitoring job.
        :param pulumi.Input[str] data_captured_destination_s3_uri: A URI that identifies the Amazon S3 storage location where Batch Transform Job captures data.
        :param pulumi.Input['ModelExplainabilityJobDefinitionDatasetFormatArgs'] dataset_format: The dataset format for your batch transform job.
        :param pulumi.Input[str] local_path: Path to the filesystem where the endpoint data is available to the container.
        :param pulumi.Input[str] features_attribute: JSONpath to locate features in JSONlines dataset
        :param pulumi.Input[str] inference_attribute: Index or JSONpath to locate predicted label(s)
        :param pulumi.Input[str] probability_attribute: Index or JSONpath to locate probabilities
        :param pulumi.Input['ModelExplainabilityJobDefinitionBatchTransformInputS3DataDistributionType'] s3_data_distribution_type: Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
        :param pulumi.Input['ModelExplainabilityJobDefinitionBatchTransformInputS3InputMode'] s3_input_mode: Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
        """
        pulumi.set(__self__, "data_captured_destination_s3_uri", data_captured_destination_s3_uri)
        pulumi.set(__self__, "dataset_format", dataset_format)
        pulumi.set(__self__, "local_path", local_path)
        if features_attribute is not None:
            pulumi.set(__self__, "features_attribute", features_attribute)
        if inference_attribute is not None:
            pulumi.set(__self__, "inference_attribute", inference_attribute)
        if probability_attribute is not None:
            pulumi.set(__self__, "probability_attribute", probability_attribute)
        if s3_data_distribution_type is not None:
            pulumi.set(__self__, "s3_data_distribution_type", s3_data_distribution_type)
        if s3_input_mode is not None:
            pulumi.set(__self__, "s3_input_mode", s3_input_mode)

    @property
    @pulumi.getter(name="dataCapturedDestinationS3Uri")
    def data_captured_destination_s3_uri(self) -> pulumi.Input[str]:
        """
        A URI that identifies the Amazon S3 storage location where Batch Transform Job captures data.
        """
        return pulumi.get(self, "data_captured_destination_s3_uri")

    @data_captured_destination_s3_uri.setter
    def data_captured_destination_s3_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_captured_destination_s3_uri", value)

    @property
    @pulumi.getter(name="datasetFormat")
    def dataset_format(self) -> pulumi.Input['ModelExplainabilityJobDefinitionDatasetFormatArgs']:
        """
        The dataset format for your batch transform job.
        """
        return pulumi.get(self, "dataset_format")

    @dataset_format.setter
    def dataset_format(self, value: pulumi.Input['ModelExplainabilityJobDefinitionDatasetFormatArgs']):
        pulumi.set(self, "dataset_format", value)

    @property
    @pulumi.getter(name="localPath")
    def local_path(self) -> pulumi.Input[str]:
        """
        Path to the filesystem where the endpoint data is available to the container.
        """
        return pulumi.get(self, "local_path")

    @local_path.setter
    def local_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "local_path", value)

    @property
    @pulumi.getter(name="featuresAttribute")
    def features_attribute(self) -> Optional[pulumi.Input[str]]:
        """
        JSONpath to locate features in JSONlines dataset
        """
        return pulumi.get(self, "features_attribute")

    @features_attribute.setter
    def features_attribute(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "features_attribute", value)

    @property
    @pulumi.getter(name="inferenceAttribute")
    def inference_attribute(self) -> Optional[pulumi.Input[str]]:
        """
        Index or JSONpath to locate predicted label(s)
        """
        return pulumi.get(self, "inference_attribute")

    @inference_attribute.setter
    def inference_attribute(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "inference_attribute", value)

    @property
    @pulumi.getter(name="probabilityAttribute")
    def probability_attribute(self) -> Optional[pulumi.Input[str]]:
        """
        Index or JSONpath to locate probabilities
        """
        return pulumi.get(self, "probability_attribute")

    @probability_attribute.setter
    def probability_attribute(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "probability_attribute", value)

    @property
    @pulumi.getter(name="s3DataDistributionType")
    def s3_data_distribution_type(self) -> Optional[pulumi.Input['ModelExplainabilityJobDefinitionBatchTransformInputS3DataDistributionType']]:
        """
        Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
        """
        return pulumi.get(self, "s3_data_distribution_type")

    @s3_data_distribution_type.setter
    def s3_data_distribution_type(self, value: Optional[pulumi.Input['ModelExplainabilityJobDefinitionBatchTransformInputS3DataDistributionType']]):
        pulumi.set(self, "s3_data_distribution_type", value)

    @property
    @pulumi.getter(name="s3InputMode")
    def s3_input_mode(self) -> Optional[pulumi.Input['ModelExplainabilityJobDefinitionBatchTransformInputS3InputMode']]:
        """
        Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
        """
        return pulumi.get(self, "s3_input_mode")

    @s3_input_mode.setter
    def s3_input_mode(self, value: Optional[pulumi.Input['ModelExplainabilityJobDefinitionBatchTransformInputS3InputMode']]):
        pulumi.set(self, "s3_input_mode", value)


if not MYPY:
    class ModelExplainabilityJobDefinitionClusterConfigArgsDict(TypedDict):
        """
        Configuration for the cluster used to run model monitoring jobs.
        """
        instance_count: pulumi.Input[int]
        """
        The number of ML compute instances to use in the model monitoring job. For distributed processing jobs, specify a value greater than 1. The default value is 1.
        """
        instance_type: pulumi.Input[str]
        """
        The ML compute instance type for the processing job.
        """
        volume_size_in_gb: pulumi.Input[int]
        """
        The size of the ML storage volume, in gigabytes, that you want to provision. You must specify sufficient ML storage for your scenario.
        """
        volume_kms_key_id: NotRequired[pulumi.Input[str]]
        """
        The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the model monitoring job.
        """
elif False:
    ModelExplainabilityJobDefinitionClusterConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelExplainabilityJobDefinitionClusterConfigArgs:
    def __init__(__self__, *,
                 instance_count: pulumi.Input[int],
                 instance_type: pulumi.Input[str],
                 volume_size_in_gb: pulumi.Input[int],
                 volume_kms_key_id: Optional[pulumi.Input[str]] = None):
        """
        Configuration for the cluster used to run model monitoring jobs.
        :param pulumi.Input[int] instance_count: The number of ML compute instances to use in the model monitoring job. For distributed processing jobs, specify a value greater than 1. The default value is 1.
        :param pulumi.Input[str] instance_type: The ML compute instance type for the processing job.
        :param pulumi.Input[int] volume_size_in_gb: The size of the ML storage volume, in gigabytes, that you want to provision. You must specify sufficient ML storage for your scenario.
        :param pulumi.Input[str] volume_kms_key_id: The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the model monitoring job.
        """
        pulumi.set(__self__, "instance_count", instance_count)
        pulumi.set(__self__, "instance_type", instance_type)
        pulumi.set(__self__, "volume_size_in_gb", volume_size_in_gb)
        if volume_kms_key_id is not None:
            pulumi.set(__self__, "volume_kms_key_id", volume_kms_key_id)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> pulumi.Input[int]:
        """
        The number of ML compute instances to use in the model monitoring job. For distributed processing jobs, specify a value greater than 1. The default value is 1.
        """
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "instance_count", value)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> pulumi.Input[str]:
        """
        The ML compute instance type for the processing job.
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance_type", value)

    @property
    @pulumi.getter(name="volumeSizeInGb")
    def volume_size_in_gb(self) -> pulumi.Input[int]:
        """
        The size of the ML storage volume, in gigabytes, that you want to provision. You must specify sufficient ML storage for your scenario.
        """
        return pulumi.get(self, "volume_size_in_gb")

    @volume_size_in_gb.setter
    def volume_size_in_gb(self, value: pulumi.Input[int]):
        pulumi.set(self, "volume_size_in_gb", value)

    @property
    @pulumi.getter(name="volumeKmsKeyId")
    def volume_kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the model monitoring job.
        """
        return pulumi.get(self, "volume_kms_key_id")

    @volume_kms_key_id.setter
    def volume_kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_kms_key_id", value)


if not MYPY:
    class ModelExplainabilityJobDefinitionConstraintsResourceArgsDict(TypedDict):
        """
        The baseline constraints resource for a monitoring job.
        """
        s3_uri: NotRequired[pulumi.Input[str]]
        """
        The Amazon S3 URI for baseline constraint file in Amazon S3 that the current monitoring job should validated against.
        """
elif False:
    ModelExplainabilityJobDefinitionConstraintsResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelExplainabilityJobDefinitionConstraintsResourceArgs:
    def __init__(__self__, *,
                 s3_uri: Optional[pulumi.Input[str]] = None):
        """
        The baseline constraints resource for a monitoring job.
        :param pulumi.Input[str] s3_uri: The Amazon S3 URI for baseline constraint file in Amazon S3 that the current monitoring job should validated against.
        """
        if s3_uri is not None:
            pulumi.set(__self__, "s3_uri", s3_uri)

    @property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon S3 URI for baseline constraint file in Amazon S3 that the current monitoring job should validated against.
        """
        return pulumi.get(self, "s3_uri")

    @s3_uri.setter
    def s3_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_uri", value)


if not MYPY:
    class ModelExplainabilityJobDefinitionCsvArgsDict(TypedDict):
        """
        The CSV format
        """
        header: NotRequired[pulumi.Input[bool]]
        """
        A boolean flag indicating if given CSV has header
        """
elif False:
    ModelExplainabilityJobDefinitionCsvArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelExplainabilityJobDefinitionCsvArgs:
    def __init__(__self__, *,
                 header: Optional[pulumi.Input[bool]] = None):
        """
        The CSV format
        :param pulumi.Input[bool] header: A boolean flag indicating if given CSV has header
        """
        if header is not None:
            pulumi.set(__self__, "header", header)

    @property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean flag indicating if given CSV has header
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "header", value)


if not MYPY:
    class ModelExplainabilityJobDefinitionDatasetFormatArgsDict(TypedDict):
        """
        The dataset format of the data to monitor
        """
        csv: NotRequired[pulumi.Input['ModelExplainabilityJobDefinitionCsvArgsDict']]
        json: NotRequired[pulumi.Input['ModelExplainabilityJobDefinitionJsonArgsDict']]
        parquet: NotRequired[pulumi.Input[bool]]
elif False:
    ModelExplainabilityJobDefinitionDatasetFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelExplainabilityJobDefinitionDatasetFormatArgs:
    def __init__(__self__, *,
                 csv: Optional[pulumi.Input['ModelExplainabilityJobDefinitionCsvArgs']] = None,
                 json: Optional[pulumi.Input['ModelExplainabilityJobDefinitionJsonArgs']] = None,
                 parquet: Optional[pulumi.Input[bool]] = None):
        """
        The dataset format of the data to monitor
        """
        if csv is not None:
            pulumi.set(__self__, "csv", csv)
        if json is not None:
            pulumi.set(__self__, "json", json)
        if parquet is not None:
            pulumi.set(__self__, "parquet", parquet)

    @property
    @pulumi.getter
    def csv(self) -> Optional[pulumi.Input['ModelExplainabilityJobDefinitionCsvArgs']]:
        return pulumi.get(self, "csv")

    @csv.setter
    def csv(self, value: Optional[pulumi.Input['ModelExplainabilityJobDefinitionCsvArgs']]):
        pulumi.set(self, "csv", value)

    @property
    @pulumi.getter
    def json(self) -> Optional[pulumi.Input['ModelExplainabilityJobDefinitionJsonArgs']]:
        return pulumi.get(self, "json")

    @json.setter
    def json(self, value: Optional[pulumi.Input['ModelExplainabilityJobDefinitionJsonArgs']]):
        pulumi.set(self, "json", value)

    @property
    @pulumi.getter
    def parquet(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "parquet")

    @parquet.setter
    def parquet(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "parquet", value)


if not MYPY:
    class ModelExplainabilityJobDefinitionEndpointInputArgsDict(TypedDict):
        """
        The endpoint for a monitoring job.
        """
        endpoint_name: pulumi.Input[str]
        """
        An endpoint in customer's account which has enabled `DataCaptureConfig` enabled.
        """
        local_path: pulumi.Input[str]
        """
        Path to the filesystem where the endpoint data is available to the container.
        """
        features_attribute: NotRequired[pulumi.Input[str]]
        """
        JSONpath to locate features in JSONlines dataset
        """
        inference_attribute: NotRequired[pulumi.Input[str]]
        """
        Index or JSONpath to locate predicted label(s)
        """
        probability_attribute: NotRequired[pulumi.Input[str]]
        """
        Index or JSONpath to locate probabilities
        """
        s3_data_distribution_type: NotRequired[pulumi.Input['ModelExplainabilityJobDefinitionEndpointInputS3DataDistributionType']]
        """
        Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
        """
        s3_input_mode: NotRequired[pulumi.Input['ModelExplainabilityJobDefinitionEndpointInputS3InputMode']]
        """
        Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
        """
elif False:
    ModelExplainabilityJobDefinitionEndpointInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelExplainabilityJobDefinitionEndpointInputArgs:
    def __init__(__self__, *,
                 endpoint_name: pulumi.Input[str],
                 local_path: pulumi.Input[str],
                 features_attribute: Optional[pulumi.Input[str]] = None,
                 inference_attribute: Optional[pulumi.Input[str]] = None,
                 probability_attribute: Optional[pulumi.Input[str]] = None,
                 s3_data_distribution_type: Optional[pulumi.Input['ModelExplainabilityJobDefinitionEndpointInputS3DataDistributionType']] = None,
                 s3_input_mode: Optional[pulumi.Input['ModelExplainabilityJobDefinitionEndpointInputS3InputMode']] = None):
        """
        The endpoint for a monitoring job.
        :param pulumi.Input[str] endpoint_name: An endpoint in customer's account which has enabled `DataCaptureConfig` enabled.
        :param pulumi.Input[str] local_path: Path to the filesystem where the endpoint data is available to the container.
        :param pulumi.Input[str] features_attribute: JSONpath to locate features in JSONlines dataset
        :param pulumi.Input[str] inference_attribute: Index or JSONpath to locate predicted label(s)
        :param pulumi.Input[str] probability_attribute: Index or JSONpath to locate probabilities
        :param pulumi.Input['ModelExplainabilityJobDefinitionEndpointInputS3DataDistributionType'] s3_data_distribution_type: Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
        :param pulumi.Input['ModelExplainabilityJobDefinitionEndpointInputS3InputMode'] s3_input_mode: Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
        """
        pulumi.set(__self__, "endpoint_name", endpoint_name)
        pulumi.set(__self__, "local_path", local_path)
        if features_attribute is not None:
            pulumi.set(__self__, "features_attribute", features_attribute)
        if inference_attribute is not None:
            pulumi.set(__self__, "inference_attribute", inference_attribute)
        if probability_attribute is not None:
            pulumi.set(__self__, "probability_attribute", probability_attribute)
        if s3_data_distribution_type is not None:
            pulumi.set(__self__, "s3_data_distribution_type", s3_data_distribution_type)
        if s3_input_mode is not None:
            pulumi.set(__self__, "s3_input_mode", s3_input_mode)

    @property
    @pulumi.getter(name="endpointName")
    def endpoint_name(self) -> pulumi.Input[str]:
        """
        An endpoint in customer's account which has enabled `DataCaptureConfig` enabled.
        """
        return pulumi.get(self, "endpoint_name")

    @endpoint_name.setter
    def endpoint_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint_name", value)

    @property
    @pulumi.getter(name="localPath")
    def local_path(self) -> pulumi.Input[str]:
        """
        Path to the filesystem where the endpoint data is available to the container.
        """
        return pulumi.get(self, "local_path")

    @local_path.setter
    def local_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "local_path", value)

    @property
    @pulumi.getter(name="featuresAttribute")
    def features_attribute(self) -> Optional[pulumi.Input[str]]:
        """
        JSONpath to locate features in JSONlines dataset
        """
        return pulumi.get(self, "features_attribute")

    @features_attribute.setter
    def features_attribute(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "features_attribute", value)

    @property
    @pulumi.getter(name="inferenceAttribute")
    def inference_attribute(self) -> Optional[pulumi.Input[str]]:
        """
        Index or JSONpath to locate predicted label(s)
        """
        return pulumi.get(self, "inference_attribute")

    @inference_attribute.setter
    def inference_attribute(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "inference_attribute", value)

    @property
    @pulumi.getter(name="probabilityAttribute")
    def probability_attribute(self) -> Optional[pulumi.Input[str]]:
        """
        Index or JSONpath to locate probabilities
        """
        return pulumi.get(self, "probability_attribute")

    @probability_attribute.setter
    def probability_attribute(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "probability_attribute", value)

    @property
    @pulumi.getter(name="s3DataDistributionType")
    def s3_data_distribution_type(self) -> Optional[pulumi.Input['ModelExplainabilityJobDefinitionEndpointInputS3DataDistributionType']]:
        """
        Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
        """
        return pulumi.get(self, "s3_data_distribution_type")

    @s3_data_distribution_type.setter
    def s3_data_distribution_type(self, value: Optional[pulumi.Input['ModelExplainabilityJobDefinitionEndpointInputS3DataDistributionType']]):
        pulumi.set(self, "s3_data_distribution_type", value)

    @property
    @pulumi.getter(name="s3InputMode")
    def s3_input_mode(self) -> Optional[pulumi.Input['ModelExplainabilityJobDefinitionEndpointInputS3InputMode']]:
        """
        Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
        """
        return pulumi.get(self, "s3_input_mode")

    @s3_input_mode.setter
    def s3_input_mode(self, value: Optional[pulumi.Input['ModelExplainabilityJobDefinitionEndpointInputS3InputMode']]):
        pulumi.set(self, "s3_input_mode", value)


if not MYPY:
    class ModelExplainabilityJobDefinitionJsonArgsDict(TypedDict):
        """
        The Json format
        """
        line: NotRequired[pulumi.Input[bool]]
        """
        A boolean flag indicating if it is JSON line format
        """
elif False:
    ModelExplainabilityJobDefinitionJsonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelExplainabilityJobDefinitionJsonArgs:
    def __init__(__self__, *,
                 line: Optional[pulumi.Input[bool]] = None):
        """
        The Json format
        :param pulumi.Input[bool] line: A boolean flag indicating if it is JSON line format
        """
        if line is not None:
            pulumi.set(__self__, "line", line)

    @property
    @pulumi.getter
    def line(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean flag indicating if it is JSON line format
        """
        return pulumi.get(self, "line")

    @line.setter
    def line(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "line", value)


if not MYPY:
    class ModelExplainabilityJobDefinitionModelExplainabilityAppSpecificationArgsDict(TypedDict):
        """
        Container image configuration object for the monitoring job.
        """
        config_uri: pulumi.Input[str]
        """
        The S3 URI to an analysis configuration file
        """
        image_uri: pulumi.Input[str]
        """
        The container image to be run by the monitoring job.
        """
        environment: NotRequired[Any]
        """
        Sets the environment variables in the Docker container
        """
elif False:
    ModelExplainabilityJobDefinitionModelExplainabilityAppSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelExplainabilityJobDefinitionModelExplainabilityAppSpecificationArgs:
    def __init__(__self__, *,
                 config_uri: pulumi.Input[str],
                 image_uri: pulumi.Input[str],
                 environment: Optional[Any] = None):
        """
        Container image configuration object for the monitoring job.
        :param pulumi.Input[str] config_uri: The S3 URI to an analysis configuration file
        :param pulumi.Input[str] image_uri: The container image to be run by the monitoring job.
        :param Any environment: Sets the environment variables in the Docker container
        """
        pulumi.set(__self__, "config_uri", config_uri)
        pulumi.set(__self__, "image_uri", image_uri)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)

    @property
    @pulumi.getter(name="configUri")
    def config_uri(self) -> pulumi.Input[str]:
        """
        The S3 URI to an analysis configuration file
        """
        return pulumi.get(self, "config_uri")

    @config_uri.setter
    def config_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "config_uri", value)

    @property
    @pulumi.getter(name="imageUri")
    def image_uri(self) -> pulumi.Input[str]:
        """
        The container image to be run by the monitoring job.
        """
        return pulumi.get(self, "image_uri")

    @image_uri.setter
    def image_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "image_uri", value)

    @property
    @pulumi.getter
    def environment(self) -> Optional[Any]:
        """
        Sets the environment variables in the Docker container
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[Any]):
        pulumi.set(self, "environment", value)


if not MYPY:
    class ModelExplainabilityJobDefinitionModelExplainabilityBaselineConfigArgsDict(TypedDict):
        """
        Baseline configuration used to validate that the data conforms to the specified constraints and statistics.
        """
        baselining_job_name: NotRequired[pulumi.Input[str]]
        """
        The name of the baseline model explainability job.
        """
        constraints_resource: NotRequired[pulumi.Input['ModelExplainabilityJobDefinitionConstraintsResourceArgsDict']]
        """
        The constraints resource for a model explainability job.
        """
elif False:
    ModelExplainabilityJobDefinitionModelExplainabilityBaselineConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelExplainabilityJobDefinitionModelExplainabilityBaselineConfigArgs:
    def __init__(__self__, *,
                 baselining_job_name: Optional[pulumi.Input[str]] = None,
                 constraints_resource: Optional[pulumi.Input['ModelExplainabilityJobDefinitionConstraintsResourceArgs']] = None):
        """
        Baseline configuration used to validate that the data conforms to the specified constraints and statistics.
        :param pulumi.Input[str] baselining_job_name: The name of the baseline model explainability job.
        :param pulumi.Input['ModelExplainabilityJobDefinitionConstraintsResourceArgs'] constraints_resource: The constraints resource for a model explainability job.
        """
        if baselining_job_name is not None:
            pulumi.set(__self__, "baselining_job_name", baselining_job_name)
        if constraints_resource is not None:
            pulumi.set(__self__, "constraints_resource", constraints_resource)

    @property
    @pulumi.getter(name="baseliningJobName")
    def baselining_job_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the baseline model explainability job.
        """
        return pulumi.get(self, "baselining_job_name")

    @baselining_job_name.setter
    def baselining_job_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "baselining_job_name", value)

    @property
    @pulumi.getter(name="constraintsResource")
    def constraints_resource(self) -> Optional[pulumi.Input['ModelExplainabilityJobDefinitionConstraintsResourceArgs']]:
        """
        The constraints resource for a model explainability job.
        """
        return pulumi.get(self, "constraints_resource")

    @constraints_resource.setter
    def constraints_resource(self, value: Optional[pulumi.Input['ModelExplainabilityJobDefinitionConstraintsResourceArgs']]):
        pulumi.set(self, "constraints_resource", value)


if not MYPY:
    class ModelExplainabilityJobDefinitionModelExplainabilityJobInputArgsDict(TypedDict):
        """
        The inputs for a monitoring job.
        """
        batch_transform_input: NotRequired[pulumi.Input['ModelExplainabilityJobDefinitionBatchTransformInputArgsDict']]
        """
        Input object for the batch transform job.
        """
        endpoint_input: NotRequired[pulumi.Input['ModelExplainabilityJobDefinitionEndpointInputArgsDict']]
        """
        Input object for the endpoint
        """
elif False:
    ModelExplainabilityJobDefinitionModelExplainabilityJobInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelExplainabilityJobDefinitionModelExplainabilityJobInputArgs:
    def __init__(__self__, *,
                 batch_transform_input: Optional[pulumi.Input['ModelExplainabilityJobDefinitionBatchTransformInputArgs']] = None,
                 endpoint_input: Optional[pulumi.Input['ModelExplainabilityJobDefinitionEndpointInputArgs']] = None):
        """
        The inputs for a monitoring job.
        :param pulumi.Input['ModelExplainabilityJobDefinitionBatchTransformInputArgs'] batch_transform_input: Input object for the batch transform job.
        :param pulumi.Input['ModelExplainabilityJobDefinitionEndpointInputArgs'] endpoint_input: Input object for the endpoint
        """
        if batch_transform_input is not None:
            pulumi.set(__self__, "batch_transform_input", batch_transform_input)
        if endpoint_input is not None:
            pulumi.set(__self__, "endpoint_input", endpoint_input)

    @property
    @pulumi.getter(name="batchTransformInput")
    def batch_transform_input(self) -> Optional[pulumi.Input['ModelExplainabilityJobDefinitionBatchTransformInputArgs']]:
        """
        Input object for the batch transform job.
        """
        return pulumi.get(self, "batch_transform_input")

    @batch_transform_input.setter
    def batch_transform_input(self, value: Optional[pulumi.Input['ModelExplainabilityJobDefinitionBatchTransformInputArgs']]):
        pulumi.set(self, "batch_transform_input", value)

    @property
    @pulumi.getter(name="endpointInput")
    def endpoint_input(self) -> Optional[pulumi.Input['ModelExplainabilityJobDefinitionEndpointInputArgs']]:
        """
        Input object for the endpoint
        """
        return pulumi.get(self, "endpoint_input")

    @endpoint_input.setter
    def endpoint_input(self, value: Optional[pulumi.Input['ModelExplainabilityJobDefinitionEndpointInputArgs']]):
        pulumi.set(self, "endpoint_input", value)


if not MYPY:
    class ModelExplainabilityJobDefinitionMonitoringOutputConfigArgsDict(TypedDict):
        """
        The output configuration for monitoring jobs.
        """
        monitoring_outputs: pulumi.Input[Sequence[pulumi.Input['ModelExplainabilityJobDefinitionMonitoringOutputArgsDict']]]
        """
        Monitoring outputs for monitoring jobs. This is where the output of the periodic monitoring jobs is uploaded.
        """
        kms_key_id: NotRequired[pulumi.Input[str]]
        """
        The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.
        """
elif False:
    ModelExplainabilityJobDefinitionMonitoringOutputConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelExplainabilityJobDefinitionMonitoringOutputConfigArgs:
    def __init__(__self__, *,
                 monitoring_outputs: pulumi.Input[Sequence[pulumi.Input['ModelExplainabilityJobDefinitionMonitoringOutputArgs']]],
                 kms_key_id: Optional[pulumi.Input[str]] = None):
        """
        The output configuration for monitoring jobs.
        :param pulumi.Input[Sequence[pulumi.Input['ModelExplainabilityJobDefinitionMonitoringOutputArgs']]] monitoring_outputs: Monitoring outputs for monitoring jobs. This is where the output of the periodic monitoring jobs is uploaded.
        :param pulumi.Input[str] kms_key_id: The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.
        """
        pulumi.set(__self__, "monitoring_outputs", monitoring_outputs)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)

    @property
    @pulumi.getter(name="monitoringOutputs")
    def monitoring_outputs(self) -> pulumi.Input[Sequence[pulumi.Input['ModelExplainabilityJobDefinitionMonitoringOutputArgs']]]:
        """
        Monitoring outputs for monitoring jobs. This is where the output of the periodic monitoring jobs is uploaded.
        """
        return pulumi.get(self, "monitoring_outputs")

    @monitoring_outputs.setter
    def monitoring_outputs(self, value: pulumi.Input[Sequence[pulumi.Input['ModelExplainabilityJobDefinitionMonitoringOutputArgs']]]):
        pulumi.set(self, "monitoring_outputs", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)


if not MYPY:
    class ModelExplainabilityJobDefinitionMonitoringOutputArgsDict(TypedDict):
        """
        The output object for a monitoring job.
        """
        s3_output: pulumi.Input['ModelExplainabilityJobDefinitionS3OutputArgsDict']
        """
        The Amazon S3 storage location where the results of a monitoring job are saved.
        """
elif False:
    ModelExplainabilityJobDefinitionMonitoringOutputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelExplainabilityJobDefinitionMonitoringOutputArgs:
    def __init__(__self__, *,
                 s3_output: pulumi.Input['ModelExplainabilityJobDefinitionS3OutputArgs']):
        """
        The output object for a monitoring job.
        :param pulumi.Input['ModelExplainabilityJobDefinitionS3OutputArgs'] s3_output: The Amazon S3 storage location where the results of a monitoring job are saved.
        """
        pulumi.set(__self__, "s3_output", s3_output)

    @property
    @pulumi.getter(name="s3Output")
    def s3_output(self) -> pulumi.Input['ModelExplainabilityJobDefinitionS3OutputArgs']:
        """
        The Amazon S3 storage location where the results of a monitoring job are saved.
        """
        return pulumi.get(self, "s3_output")

    @s3_output.setter
    def s3_output(self, value: pulumi.Input['ModelExplainabilityJobDefinitionS3OutputArgs']):
        pulumi.set(self, "s3_output", value)


if not MYPY:
    class ModelExplainabilityJobDefinitionMonitoringResourcesArgsDict(TypedDict):
        """
        Identifies the resources to deploy for a monitoring job.
        """
        cluster_config: pulumi.Input['ModelExplainabilityJobDefinitionClusterConfigArgsDict']
        """
        The configuration for the cluster resources used to run the processing job.
        """
elif False:
    ModelExplainabilityJobDefinitionMonitoringResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelExplainabilityJobDefinitionMonitoringResourcesArgs:
    def __init__(__self__, *,
                 cluster_config: pulumi.Input['ModelExplainabilityJobDefinitionClusterConfigArgs']):
        """
        Identifies the resources to deploy for a monitoring job.
        :param pulumi.Input['ModelExplainabilityJobDefinitionClusterConfigArgs'] cluster_config: The configuration for the cluster resources used to run the processing job.
        """
        pulumi.set(__self__, "cluster_config", cluster_config)

    @property
    @pulumi.getter(name="clusterConfig")
    def cluster_config(self) -> pulumi.Input['ModelExplainabilityJobDefinitionClusterConfigArgs']:
        """
        The configuration for the cluster resources used to run the processing job.
        """
        return pulumi.get(self, "cluster_config")

    @cluster_config.setter
    def cluster_config(self, value: pulumi.Input['ModelExplainabilityJobDefinitionClusterConfigArgs']):
        pulumi.set(self, "cluster_config", value)


if not MYPY:
    class ModelExplainabilityJobDefinitionNetworkConfigArgsDict(TypedDict):
        """
        Networking options for a job, such as network traffic encryption between containers, whether to allow inbound and outbound network calls to and from containers, and the VPC subnets and security groups to use for VPC-enabled jobs.
        """
        enable_inter_container_traffic_encryption: NotRequired[pulumi.Input[bool]]
        """
        Whether to encrypt all communications between distributed processing jobs. Choose True to encrypt communications. Encryption provides greater security for distributed processing jobs, but the processing might take longer.
        """
        enable_network_isolation: NotRequired[pulumi.Input[bool]]
        """
        Whether to allow inbound and outbound network calls to and from the containers used for the processing job.
        """
        vpc_config: NotRequired[pulumi.Input['ModelExplainabilityJobDefinitionVpcConfigArgsDict']]
        """
        Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC.
        """
elif False:
    ModelExplainabilityJobDefinitionNetworkConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelExplainabilityJobDefinitionNetworkConfigArgs:
    def __init__(__self__, *,
                 enable_inter_container_traffic_encryption: Optional[pulumi.Input[bool]] = None,
                 enable_network_isolation: Optional[pulumi.Input[bool]] = None,
                 vpc_config: Optional[pulumi.Input['ModelExplainabilityJobDefinitionVpcConfigArgs']] = None):
        """
        Networking options for a job, such as network traffic encryption between containers, whether to allow inbound and outbound network calls to and from containers, and the VPC subnets and security groups to use for VPC-enabled jobs.
        :param pulumi.Input[bool] enable_inter_container_traffic_encryption: Whether to encrypt all communications between distributed processing jobs. Choose True to encrypt communications. Encryption provides greater security for distributed processing jobs, but the processing might take longer.
        :param pulumi.Input[bool] enable_network_isolation: Whether to allow inbound and outbound network calls to and from the containers used for the processing job.
        :param pulumi.Input['ModelExplainabilityJobDefinitionVpcConfigArgs'] vpc_config: Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC.
        """
        if enable_inter_container_traffic_encryption is not None:
            pulumi.set(__self__, "enable_inter_container_traffic_encryption", enable_inter_container_traffic_encryption)
        if enable_network_isolation is not None:
            pulumi.set(__self__, "enable_network_isolation", enable_network_isolation)
        if vpc_config is not None:
            pulumi.set(__self__, "vpc_config", vpc_config)

    @property
    @pulumi.getter(name="enableInterContainerTrafficEncryption")
    def enable_inter_container_traffic_encryption(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to encrypt all communications between distributed processing jobs. Choose True to encrypt communications. Encryption provides greater security for distributed processing jobs, but the processing might take longer.
        """
        return pulumi.get(self, "enable_inter_container_traffic_encryption")

    @enable_inter_container_traffic_encryption.setter
    def enable_inter_container_traffic_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_inter_container_traffic_encryption", value)

    @property
    @pulumi.getter(name="enableNetworkIsolation")
    def enable_network_isolation(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to allow inbound and outbound network calls to and from the containers used for the processing job.
        """
        return pulumi.get(self, "enable_network_isolation")

    @enable_network_isolation.setter
    def enable_network_isolation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_network_isolation", value)

    @property
    @pulumi.getter(name="vpcConfig")
    def vpc_config(self) -> Optional[pulumi.Input['ModelExplainabilityJobDefinitionVpcConfigArgs']]:
        """
        Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC.
        """
        return pulumi.get(self, "vpc_config")

    @vpc_config.setter
    def vpc_config(self, value: Optional[pulumi.Input['ModelExplainabilityJobDefinitionVpcConfigArgs']]):
        pulumi.set(self, "vpc_config", value)


if not MYPY:
    class ModelExplainabilityJobDefinitionS3OutputArgsDict(TypedDict):
        """
        Information about where and how to store the results of a monitoring job.
        """
        local_path: pulumi.Input[str]
        """
        The local path to the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job. LocalPath is an absolute path for the output data.
        """
        s3_uri: pulumi.Input[str]
        """
        A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
        """
        s3_upload_mode: NotRequired[pulumi.Input['ModelExplainabilityJobDefinitionS3OutputS3UploadMode']]
        """
        Whether to upload the results of the monitoring job continuously or after the job completes.
        """
elif False:
    ModelExplainabilityJobDefinitionS3OutputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelExplainabilityJobDefinitionS3OutputArgs:
    def __init__(__self__, *,
                 local_path: pulumi.Input[str],
                 s3_uri: pulumi.Input[str],
                 s3_upload_mode: Optional[pulumi.Input['ModelExplainabilityJobDefinitionS3OutputS3UploadMode']] = None):
        """
        Information about where and how to store the results of a monitoring job.
        :param pulumi.Input[str] local_path: The local path to the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job. LocalPath is an absolute path for the output data.
        :param pulumi.Input[str] s3_uri: A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
        :param pulumi.Input['ModelExplainabilityJobDefinitionS3OutputS3UploadMode'] s3_upload_mode: Whether to upload the results of the monitoring job continuously or after the job completes.
        """
        pulumi.set(__self__, "local_path", local_path)
        pulumi.set(__self__, "s3_uri", s3_uri)
        if s3_upload_mode is not None:
            pulumi.set(__self__, "s3_upload_mode", s3_upload_mode)

    @property
    @pulumi.getter(name="localPath")
    def local_path(self) -> pulumi.Input[str]:
        """
        The local path to the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job. LocalPath is an absolute path for the output data.
        """
        return pulumi.get(self, "local_path")

    @local_path.setter
    def local_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "local_path", value)

    @property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> pulumi.Input[str]:
        """
        A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
        """
        return pulumi.get(self, "s3_uri")

    @s3_uri.setter
    def s3_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_uri", value)

    @property
    @pulumi.getter(name="s3UploadMode")
    def s3_upload_mode(self) -> Optional[pulumi.Input['ModelExplainabilityJobDefinitionS3OutputS3UploadMode']]:
        """
        Whether to upload the results of the monitoring job continuously or after the job completes.
        """
        return pulumi.get(self, "s3_upload_mode")

    @s3_upload_mode.setter
    def s3_upload_mode(self, value: Optional[pulumi.Input['ModelExplainabilityJobDefinitionS3OutputS3UploadMode']]):
        pulumi.set(self, "s3_upload_mode", value)


if not MYPY:
    class ModelExplainabilityJobDefinitionStoppingConditionArgsDict(TypedDict):
        """
        Specifies a time limit for how long the monitoring job is allowed to run.
        """
        max_runtime_in_seconds: pulumi.Input[int]
        """
        The maximum runtime allowed in seconds.
        """
elif False:
    ModelExplainabilityJobDefinitionStoppingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelExplainabilityJobDefinitionStoppingConditionArgs:
    def __init__(__self__, *,
                 max_runtime_in_seconds: pulumi.Input[int]):
        """
        Specifies a time limit for how long the monitoring job is allowed to run.
        :param pulumi.Input[int] max_runtime_in_seconds: The maximum runtime allowed in seconds.
        """
        pulumi.set(__self__, "max_runtime_in_seconds", max_runtime_in_seconds)

    @property
    @pulumi.getter(name="maxRuntimeInSeconds")
    def max_runtime_in_seconds(self) -> pulumi.Input[int]:
        """
        The maximum runtime allowed in seconds.
        """
        return pulumi.get(self, "max_runtime_in_seconds")

    @max_runtime_in_seconds.setter
    def max_runtime_in_seconds(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_runtime_in_seconds", value)


if not MYPY:
    class ModelExplainabilityJobDefinitionVpcConfigArgsDict(TypedDict):
        """
        Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC.
        """
        security_group_ids: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the Subnets field.
        """
        subnets: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The ID of the subnets in the VPC to which you want to connect to your monitoring jobs.
        """
elif False:
    ModelExplainabilityJobDefinitionVpcConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelExplainabilityJobDefinitionVpcConfigArgs:
    def __init__(__self__, *,
                 security_group_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 subnets: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_group_ids: The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the Subnets field.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subnets: The ID of the subnets in the VPC to which you want to connect to your monitoring jobs.
        """
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnets", subnets)

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the Subnets field.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "security_group_ids", value)

    @property
    @pulumi.getter
    def subnets(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The ID of the subnets in the VPC to which you want to connect to your monitoring jobs.
        """
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "subnets", value)


if not MYPY:
    class ModelPackageAdditionalInferenceSpecificationDefinitionArgsDict(TypedDict):
        """
        Additional Inference Specification specifies details about inference jobs that can be run with models based on this model package.AdditionalInferenceSpecifications can be added to existing model packages using AdditionalInferenceSpecificationsToAdd.
        """
        containers: pulumi.Input[Sequence[pulumi.Input['ModelPackageContainerDefinitionArgsDict']]]
        """
        The Amazon ECR registry path of the Docker image that contains the inference code.
        """
        name: pulumi.Input[str]
        """
        A unique name to identify the additional inference specification. The name must be unique within the list of your additional inference specifications for a particular model package.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        A description of the additional Inference specification.
        """
        supported_content_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The supported MIME types for the input data.
        """
        supported_realtime_inference_instance_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of the instance types that are used to generate inferences in real-time
        """
        supported_response_mime_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The supported MIME types for the output data.
        """
        supported_transform_instance_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of the instance types on which a transformation job can be run or on which an endpoint can be deployed.
        """
elif False:
    ModelPackageAdditionalInferenceSpecificationDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelPackageAdditionalInferenceSpecificationDefinitionArgs:
    def __init__(__self__, *,
                 containers: pulumi.Input[Sequence[pulumi.Input['ModelPackageContainerDefinitionArgs']]],
                 name: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 supported_content_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 supported_realtime_inference_instance_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 supported_response_mime_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 supported_transform_instance_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Additional Inference Specification specifies details about inference jobs that can be run with models based on this model package.AdditionalInferenceSpecifications can be added to existing model packages using AdditionalInferenceSpecificationsToAdd.
        :param pulumi.Input[Sequence[pulumi.Input['ModelPackageContainerDefinitionArgs']]] containers: The Amazon ECR registry path of the Docker image that contains the inference code.
        :param pulumi.Input[str] name: A unique name to identify the additional inference specification. The name must be unique within the list of your additional inference specifications for a particular model package.
        :param pulumi.Input[str] description: A description of the additional Inference specification.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] supported_content_types: The supported MIME types for the input data.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] supported_realtime_inference_instance_types: A list of the instance types that are used to generate inferences in real-time
        :param pulumi.Input[Sequence[pulumi.Input[str]]] supported_response_mime_types: The supported MIME types for the output data.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] supported_transform_instance_types: A list of the instance types on which a transformation job can be run or on which an endpoint can be deployed.
        """
        pulumi.set(__self__, "containers", containers)
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if supported_content_types is not None:
            pulumi.set(__self__, "supported_content_types", supported_content_types)
        if supported_realtime_inference_instance_types is not None:
            pulumi.set(__self__, "supported_realtime_inference_instance_types", supported_realtime_inference_instance_types)
        if supported_response_mime_types is not None:
            pulumi.set(__self__, "supported_response_mime_types", supported_response_mime_types)
        if supported_transform_instance_types is not None:
            pulumi.set(__self__, "supported_transform_instance_types", supported_transform_instance_types)

    @property
    @pulumi.getter
    def containers(self) -> pulumi.Input[Sequence[pulumi.Input['ModelPackageContainerDefinitionArgs']]]:
        """
        The Amazon ECR registry path of the Docker image that contains the inference code.
        """
        return pulumi.get(self, "containers")

    @containers.setter
    def containers(self, value: pulumi.Input[Sequence[pulumi.Input['ModelPackageContainerDefinitionArgs']]]):
        pulumi.set(self, "containers", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        A unique name to identify the additional inference specification. The name must be unique within the list of your additional inference specifications for a particular model package.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A description of the additional Inference specification.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="supportedContentTypes")
    def supported_content_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The supported MIME types for the input data.
        """
        return pulumi.get(self, "supported_content_types")

    @supported_content_types.setter
    def supported_content_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "supported_content_types", value)

    @property
    @pulumi.getter(name="supportedRealtimeInferenceInstanceTypes")
    def supported_realtime_inference_instance_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of the instance types that are used to generate inferences in real-time
        """
        return pulumi.get(self, "supported_realtime_inference_instance_types")

    @supported_realtime_inference_instance_types.setter
    def supported_realtime_inference_instance_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "supported_realtime_inference_instance_types", value)

    @property
    @pulumi.getter(name="supportedResponseMimeTypes")
    def supported_response_mime_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The supported MIME types for the output data.
        """
        return pulumi.get(self, "supported_response_mime_types")

    @supported_response_mime_types.setter
    def supported_response_mime_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "supported_response_mime_types", value)

    @property
    @pulumi.getter(name="supportedTransformInstanceTypes")
    def supported_transform_instance_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of the instance types on which a transformation job can be run or on which an endpoint can be deployed.
        """
        return pulumi.get(self, "supported_transform_instance_types")

    @supported_transform_instance_types.setter
    def supported_transform_instance_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "supported_transform_instance_types", value)


if not MYPY:
    class ModelPackageBiasArgsDict(TypedDict):
        """
        Contains bias metrics for a model.
        """
        post_training_report: NotRequired[pulumi.Input['ModelPackageMetricsSourceArgsDict']]
        """
        The post-training bias report for a model.
        """
        pre_training_report: NotRequired[pulumi.Input['ModelPackageMetricsSourceArgsDict']]
        """
        The pre-training bias report for a model.
        """
        report: NotRequired[pulumi.Input['ModelPackageMetricsSourceArgsDict']]
        """
        The bias report for a model
        """
elif False:
    ModelPackageBiasArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelPackageBiasArgs:
    def __init__(__self__, *,
                 post_training_report: Optional[pulumi.Input['ModelPackageMetricsSourceArgs']] = None,
                 pre_training_report: Optional[pulumi.Input['ModelPackageMetricsSourceArgs']] = None,
                 report: Optional[pulumi.Input['ModelPackageMetricsSourceArgs']] = None):
        """
        Contains bias metrics for a model.
        :param pulumi.Input['ModelPackageMetricsSourceArgs'] post_training_report: The post-training bias report for a model.
        :param pulumi.Input['ModelPackageMetricsSourceArgs'] pre_training_report: The pre-training bias report for a model.
        :param pulumi.Input['ModelPackageMetricsSourceArgs'] report: The bias report for a model
        """
        if post_training_report is not None:
            pulumi.set(__self__, "post_training_report", post_training_report)
        if pre_training_report is not None:
            pulumi.set(__self__, "pre_training_report", pre_training_report)
        if report is not None:
            pulumi.set(__self__, "report", report)

    @property
    @pulumi.getter(name="postTrainingReport")
    def post_training_report(self) -> Optional[pulumi.Input['ModelPackageMetricsSourceArgs']]:
        """
        The post-training bias report for a model.
        """
        return pulumi.get(self, "post_training_report")

    @post_training_report.setter
    def post_training_report(self, value: Optional[pulumi.Input['ModelPackageMetricsSourceArgs']]):
        pulumi.set(self, "post_training_report", value)

    @property
    @pulumi.getter(name="preTrainingReport")
    def pre_training_report(self) -> Optional[pulumi.Input['ModelPackageMetricsSourceArgs']]:
        """
        The pre-training bias report for a model.
        """
        return pulumi.get(self, "pre_training_report")

    @pre_training_report.setter
    def pre_training_report(self, value: Optional[pulumi.Input['ModelPackageMetricsSourceArgs']]):
        pulumi.set(self, "pre_training_report", value)

    @property
    @pulumi.getter
    def report(self) -> Optional[pulumi.Input['ModelPackageMetricsSourceArgs']]:
        """
        The bias report for a model
        """
        return pulumi.get(self, "report")

    @report.setter
    def report(self, value: Optional[pulumi.Input['ModelPackageMetricsSourceArgs']]):
        pulumi.set(self, "report", value)


if not MYPY:
    class ModelPackageContainerDefinitionModelInputPropertiesArgsDict(TypedDict):
        data_input_config: pulumi.Input[str]
        """
        The input configuration object for the model.
        """
elif False:
    ModelPackageContainerDefinitionModelInputPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelPackageContainerDefinitionModelInputPropertiesArgs:
    def __init__(__self__, *,
                 data_input_config: pulumi.Input[str]):
        """
        :param pulumi.Input[str] data_input_config: The input configuration object for the model.
        """
        pulumi.set(__self__, "data_input_config", data_input_config)

    @property
    @pulumi.getter(name="dataInputConfig")
    def data_input_config(self) -> pulumi.Input[str]:
        """
        The input configuration object for the model.
        """
        return pulumi.get(self, "data_input_config")

    @data_input_config.setter
    def data_input_config(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_input_config", value)


if not MYPY:
    class ModelPackageContainerDefinitionArgsDict(TypedDict):
        """
        Describes the Docker container for the model package.
        """
        image: pulumi.Input[str]
        """
        The Amazon EC2 Container Registry (Amazon ECR) path where inference code is stored.
        """
        container_hostname: NotRequired[pulumi.Input[str]]
        """
        The DNS host name for the Docker container.
        """
        environment: NotRequired[pulumi.Input['ModelPackageEnvironmentArgsDict']]
        framework: NotRequired[pulumi.Input[str]]
        """
        The machine learning framework of the model package container image.
        """
        framework_version: NotRequired[pulumi.Input[str]]
        """
        The framework version of the Model Package Container Image.
        """
        image_digest: NotRequired[pulumi.Input[str]]
        """
        An MD5 hash of the training algorithm that identifies the Docker image used for training.
        """
        model_data_source: NotRequired[pulumi.Input['ModelPackageModelDataSourceArgsDict']]
        model_data_url: NotRequired[pulumi.Input[str]]
        """
        A structure with Model Input details.
        """
        model_input: NotRequired[pulumi.Input['ModelPackageContainerDefinitionModelInputPropertiesArgsDict']]
        nearest_model_name: NotRequired[pulumi.Input[str]]
        """
        The name of a pre-trained machine learning benchmarked by Amazon SageMaker Inference Recommender model that matches your model.
        """
elif False:
    ModelPackageContainerDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelPackageContainerDefinitionArgs:
    def __init__(__self__, *,
                 image: pulumi.Input[str],
                 container_hostname: Optional[pulumi.Input[str]] = None,
                 environment: Optional[pulumi.Input['ModelPackageEnvironmentArgs']] = None,
                 framework: Optional[pulumi.Input[str]] = None,
                 framework_version: Optional[pulumi.Input[str]] = None,
                 image_digest: Optional[pulumi.Input[str]] = None,
                 model_data_source: Optional[pulumi.Input['ModelPackageModelDataSourceArgs']] = None,
                 model_data_url: Optional[pulumi.Input[str]] = None,
                 model_input: Optional[pulumi.Input['ModelPackageContainerDefinitionModelInputPropertiesArgs']] = None,
                 nearest_model_name: Optional[pulumi.Input[str]] = None):
        """
        Describes the Docker container for the model package.
        :param pulumi.Input[str] image: The Amazon EC2 Container Registry (Amazon ECR) path where inference code is stored.
        :param pulumi.Input[str] container_hostname: The DNS host name for the Docker container.
        :param pulumi.Input[str] framework: The machine learning framework of the model package container image.
        :param pulumi.Input[str] framework_version: The framework version of the Model Package Container Image.
        :param pulumi.Input[str] image_digest: An MD5 hash of the training algorithm that identifies the Docker image used for training.
        :param pulumi.Input[str] model_data_url: A structure with Model Input details.
        :param pulumi.Input[str] nearest_model_name: The name of a pre-trained machine learning benchmarked by Amazon SageMaker Inference Recommender model that matches your model.
        """
        pulumi.set(__self__, "image", image)
        if container_hostname is not None:
            pulumi.set(__self__, "container_hostname", container_hostname)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if framework is not None:
            pulumi.set(__self__, "framework", framework)
        if framework_version is not None:
            pulumi.set(__self__, "framework_version", framework_version)
        if image_digest is not None:
            pulumi.set(__self__, "image_digest", image_digest)
        if model_data_source is not None:
            pulumi.set(__self__, "model_data_source", model_data_source)
        if model_data_url is not None:
            pulumi.set(__self__, "model_data_url", model_data_url)
        if model_input is not None:
            pulumi.set(__self__, "model_input", model_input)
        if nearest_model_name is not None:
            pulumi.set(__self__, "nearest_model_name", nearest_model_name)

    @property
    @pulumi.getter
    def image(self) -> pulumi.Input[str]:
        """
        The Amazon EC2 Container Registry (Amazon ECR) path where inference code is stored.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: pulumi.Input[str]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="containerHostname")
    def container_hostname(self) -> Optional[pulumi.Input[str]]:
        """
        The DNS host name for the Docker container.
        """
        return pulumi.get(self, "container_hostname")

    @container_hostname.setter
    def container_hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "container_hostname", value)

    @property
    @pulumi.getter
    def environment(self) -> Optional[pulumi.Input['ModelPackageEnvironmentArgs']]:
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[pulumi.Input['ModelPackageEnvironmentArgs']]):
        pulumi.set(self, "environment", value)

    @property
    @pulumi.getter
    def framework(self) -> Optional[pulumi.Input[str]]:
        """
        The machine learning framework of the model package container image.
        """
        return pulumi.get(self, "framework")

    @framework.setter
    def framework(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "framework", value)

    @property
    @pulumi.getter(name="frameworkVersion")
    def framework_version(self) -> Optional[pulumi.Input[str]]:
        """
        The framework version of the Model Package Container Image.
        """
        return pulumi.get(self, "framework_version")

    @framework_version.setter
    def framework_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "framework_version", value)

    @property
    @pulumi.getter(name="imageDigest")
    def image_digest(self) -> Optional[pulumi.Input[str]]:
        """
        An MD5 hash of the training algorithm that identifies the Docker image used for training.
        """
        return pulumi.get(self, "image_digest")

    @image_digest.setter
    def image_digest(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_digest", value)

    @property
    @pulumi.getter(name="modelDataSource")
    def model_data_source(self) -> Optional[pulumi.Input['ModelPackageModelDataSourceArgs']]:
        return pulumi.get(self, "model_data_source")

    @model_data_source.setter
    def model_data_source(self, value: Optional[pulumi.Input['ModelPackageModelDataSourceArgs']]):
        pulumi.set(self, "model_data_source", value)

    @property
    @pulumi.getter(name="modelDataUrl")
    def model_data_url(self) -> Optional[pulumi.Input[str]]:
        """
        A structure with Model Input details.
        """
        return pulumi.get(self, "model_data_url")

    @model_data_url.setter
    def model_data_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "model_data_url", value)

    @property
    @pulumi.getter(name="modelInput")
    def model_input(self) -> Optional[pulumi.Input['ModelPackageContainerDefinitionModelInputPropertiesArgs']]:
        return pulumi.get(self, "model_input")

    @model_input.setter
    def model_input(self, value: Optional[pulumi.Input['ModelPackageContainerDefinitionModelInputPropertiesArgs']]):
        pulumi.set(self, "model_input", value)

    @property
    @pulumi.getter(name="nearestModelName")
    def nearest_model_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of a pre-trained machine learning benchmarked by Amazon SageMaker Inference Recommender model that matches your model.
        """
        return pulumi.get(self, "nearest_model_name")

    @nearest_model_name.setter
    def nearest_model_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nearest_model_name", value)


if not MYPY:
    class ModelPackageCustomerMetadataPropertiesArgsDict(TypedDict):
        """
        The metadata properties associated with the model package versions.
        """
        pass
elif False:
    ModelPackageCustomerMetadataPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelPackageCustomerMetadataPropertiesArgs:
    def __init__(__self__):
        """
        The metadata properties associated with the model package versions.
        """
        pass


if not MYPY:
    class ModelPackageDataSourceArgsDict(TypedDict):
        """
        Describes the input source of a transform job and the way the transform job consumes it.
        """
        s3_data_source: pulumi.Input['ModelPackageS3DataSourceArgsDict']
        """
        The S3 location of the data source that is associated with a channel.
        """
elif False:
    ModelPackageDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelPackageDataSourceArgs:
    def __init__(__self__, *,
                 s3_data_source: pulumi.Input['ModelPackageS3DataSourceArgs']):
        """
        Describes the input source of a transform job and the way the transform job consumes it.
        :param pulumi.Input['ModelPackageS3DataSourceArgs'] s3_data_source: The S3 location of the data source that is associated with a channel.
        """
        pulumi.set(__self__, "s3_data_source", s3_data_source)

    @property
    @pulumi.getter(name="s3DataSource")
    def s3_data_source(self) -> pulumi.Input['ModelPackageS3DataSourceArgs']:
        """
        The S3 location of the data source that is associated with a channel.
        """
        return pulumi.get(self, "s3_data_source")

    @s3_data_source.setter
    def s3_data_source(self, value: pulumi.Input['ModelPackageS3DataSourceArgs']):
        pulumi.set(self, "s3_data_source", value)


if not MYPY:
    class ModelPackageDriftCheckBaselinesArgsDict(TypedDict):
        """
        Represents the drift check baselines that can be used when the model monitor is set using the model package.
        """
        bias: NotRequired[pulumi.Input['ModelPackageDriftCheckBiasArgsDict']]
        """
        Represents the drift check bias baselines that can be used when the model monitor is set using the model package.
        """
        explainability: NotRequired[pulumi.Input['ModelPackageDriftCheckExplainabilityArgsDict']]
        """
        Represents the drift check explainability baselines that can be used when the model monitor is set using the model package.
        """
        model_data_quality: NotRequired[pulumi.Input['ModelPackageDriftCheckModelDataQualityArgsDict']]
        """
        Represents the drift check model data quality baselines that can be used when the model monitor is set using the model package.
        """
        model_quality: NotRequired[pulumi.Input['ModelPackageDriftCheckModelQualityArgsDict']]
        """
        Represents the drift check model quality baselines that can be used when the model monitor is set using the model package.
        """
elif False:
    ModelPackageDriftCheckBaselinesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelPackageDriftCheckBaselinesArgs:
    def __init__(__self__, *,
                 bias: Optional[pulumi.Input['ModelPackageDriftCheckBiasArgs']] = None,
                 explainability: Optional[pulumi.Input['ModelPackageDriftCheckExplainabilityArgs']] = None,
                 model_data_quality: Optional[pulumi.Input['ModelPackageDriftCheckModelDataQualityArgs']] = None,
                 model_quality: Optional[pulumi.Input['ModelPackageDriftCheckModelQualityArgs']] = None):
        """
        Represents the drift check baselines that can be used when the model monitor is set using the model package.
        :param pulumi.Input['ModelPackageDriftCheckBiasArgs'] bias: Represents the drift check bias baselines that can be used when the model monitor is set using the model package.
        :param pulumi.Input['ModelPackageDriftCheckExplainabilityArgs'] explainability: Represents the drift check explainability baselines that can be used when the model monitor is set using the model package.
        :param pulumi.Input['ModelPackageDriftCheckModelDataQualityArgs'] model_data_quality: Represents the drift check model data quality baselines that can be used when the model monitor is set using the model package.
        :param pulumi.Input['ModelPackageDriftCheckModelQualityArgs'] model_quality: Represents the drift check model quality baselines that can be used when the model monitor is set using the model package.
        """
        if bias is not None:
            pulumi.set(__self__, "bias", bias)
        if explainability is not None:
            pulumi.set(__self__, "explainability", explainability)
        if model_data_quality is not None:
            pulumi.set(__self__, "model_data_quality", model_data_quality)
        if model_quality is not None:
            pulumi.set(__self__, "model_quality", model_quality)

    @property
    @pulumi.getter
    def bias(self) -> Optional[pulumi.Input['ModelPackageDriftCheckBiasArgs']]:
        """
        Represents the drift check bias baselines that can be used when the model monitor is set using the model package.
        """
        return pulumi.get(self, "bias")

    @bias.setter
    def bias(self, value: Optional[pulumi.Input['ModelPackageDriftCheckBiasArgs']]):
        pulumi.set(self, "bias", value)

    @property
    @pulumi.getter
    def explainability(self) -> Optional[pulumi.Input['ModelPackageDriftCheckExplainabilityArgs']]:
        """
        Represents the drift check explainability baselines that can be used when the model monitor is set using the model package.
        """
        return pulumi.get(self, "explainability")

    @explainability.setter
    def explainability(self, value: Optional[pulumi.Input['ModelPackageDriftCheckExplainabilityArgs']]):
        pulumi.set(self, "explainability", value)

    @property
    @pulumi.getter(name="modelDataQuality")
    def model_data_quality(self) -> Optional[pulumi.Input['ModelPackageDriftCheckModelDataQualityArgs']]:
        """
        Represents the drift check model data quality baselines that can be used when the model monitor is set using the model package.
        """
        return pulumi.get(self, "model_data_quality")

    @model_data_quality.setter
    def model_data_quality(self, value: Optional[pulumi.Input['ModelPackageDriftCheckModelDataQualityArgs']]):
        pulumi.set(self, "model_data_quality", value)

    @property
    @pulumi.getter(name="modelQuality")
    def model_quality(self) -> Optional[pulumi.Input['ModelPackageDriftCheckModelQualityArgs']]:
        """
        Represents the drift check model quality baselines that can be used when the model monitor is set using the model package.
        """
        return pulumi.get(self, "model_quality")

    @model_quality.setter
    def model_quality(self, value: Optional[pulumi.Input['ModelPackageDriftCheckModelQualityArgs']]):
        pulumi.set(self, "model_quality", value)


if not MYPY:
    class ModelPackageDriftCheckBiasArgsDict(TypedDict):
        """
        Represents the drift check bias baselines that can be used when the model monitor is set using the model package.
        """
        config_file: NotRequired[pulumi.Input['ModelPackageFileSourceArgsDict']]
        """
        The bias config file for a model.
        """
        post_training_constraints: NotRequired[pulumi.Input['ModelPackageMetricsSourceArgsDict']]
        """
        The post-training constraints.
        """
        pre_training_constraints: NotRequired[pulumi.Input['ModelPackageMetricsSourceArgsDict']]
        """
        The pre-training constraints.
        """
elif False:
    ModelPackageDriftCheckBiasArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelPackageDriftCheckBiasArgs:
    def __init__(__self__, *,
                 config_file: Optional[pulumi.Input['ModelPackageFileSourceArgs']] = None,
                 post_training_constraints: Optional[pulumi.Input['ModelPackageMetricsSourceArgs']] = None,
                 pre_training_constraints: Optional[pulumi.Input['ModelPackageMetricsSourceArgs']] = None):
        """
        Represents the drift check bias baselines that can be used when the model monitor is set using the model package.
        :param pulumi.Input['ModelPackageFileSourceArgs'] config_file: The bias config file for a model.
        :param pulumi.Input['ModelPackageMetricsSourceArgs'] post_training_constraints: The post-training constraints.
        :param pulumi.Input['ModelPackageMetricsSourceArgs'] pre_training_constraints: The pre-training constraints.
        """
        if config_file is not None:
            pulumi.set(__self__, "config_file", config_file)
        if post_training_constraints is not None:
            pulumi.set(__self__, "post_training_constraints", post_training_constraints)
        if pre_training_constraints is not None:
            pulumi.set(__self__, "pre_training_constraints", pre_training_constraints)

    @property
    @pulumi.getter(name="configFile")
    def config_file(self) -> Optional[pulumi.Input['ModelPackageFileSourceArgs']]:
        """
        The bias config file for a model.
        """
        return pulumi.get(self, "config_file")

    @config_file.setter
    def config_file(self, value: Optional[pulumi.Input['ModelPackageFileSourceArgs']]):
        pulumi.set(self, "config_file", value)

    @property
    @pulumi.getter(name="postTrainingConstraints")
    def post_training_constraints(self) -> Optional[pulumi.Input['ModelPackageMetricsSourceArgs']]:
        """
        The post-training constraints.
        """
        return pulumi.get(self, "post_training_constraints")

    @post_training_constraints.setter
    def post_training_constraints(self, value: Optional[pulumi.Input['ModelPackageMetricsSourceArgs']]):
        pulumi.set(self, "post_training_constraints", value)

    @property
    @pulumi.getter(name="preTrainingConstraints")
    def pre_training_constraints(self) -> Optional[pulumi.Input['ModelPackageMetricsSourceArgs']]:
        """
        The pre-training constraints.
        """
        return pulumi.get(self, "pre_training_constraints")

    @pre_training_constraints.setter
    def pre_training_constraints(self, value: Optional[pulumi.Input['ModelPackageMetricsSourceArgs']]):
        pulumi.set(self, "pre_training_constraints", value)


if not MYPY:
    class ModelPackageDriftCheckExplainabilityArgsDict(TypedDict):
        """
        Contains explainability metrics for a model.
        """
        config_file: NotRequired[pulumi.Input['ModelPackageFileSourceArgsDict']]
        """
        The explainability config file for the model.
        """
        constraints: NotRequired[pulumi.Input['ModelPackageMetricsSourceArgsDict']]
        """
        The drift check explainability constraints.
        """
elif False:
    ModelPackageDriftCheckExplainabilityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelPackageDriftCheckExplainabilityArgs:
    def __init__(__self__, *,
                 config_file: Optional[pulumi.Input['ModelPackageFileSourceArgs']] = None,
                 constraints: Optional[pulumi.Input['ModelPackageMetricsSourceArgs']] = None):
        """
        Contains explainability metrics for a model.
        :param pulumi.Input['ModelPackageFileSourceArgs'] config_file: The explainability config file for the model.
        :param pulumi.Input['ModelPackageMetricsSourceArgs'] constraints: The drift check explainability constraints.
        """
        if config_file is not None:
            pulumi.set(__self__, "config_file", config_file)
        if constraints is not None:
            pulumi.set(__self__, "constraints", constraints)

    @property
    @pulumi.getter(name="configFile")
    def config_file(self) -> Optional[pulumi.Input['ModelPackageFileSourceArgs']]:
        """
        The explainability config file for the model.
        """
        return pulumi.get(self, "config_file")

    @config_file.setter
    def config_file(self, value: Optional[pulumi.Input['ModelPackageFileSourceArgs']]):
        pulumi.set(self, "config_file", value)

    @property
    @pulumi.getter
    def constraints(self) -> Optional[pulumi.Input['ModelPackageMetricsSourceArgs']]:
        """
        The drift check explainability constraints.
        """
        return pulumi.get(self, "constraints")

    @constraints.setter
    def constraints(self, value: Optional[pulumi.Input['ModelPackageMetricsSourceArgs']]):
        pulumi.set(self, "constraints", value)


if not MYPY:
    class ModelPackageDriftCheckModelDataQualityArgsDict(TypedDict):
        """
        Represents the drift check data quality baselines that can be used when the model monitor is set using the model package.
        """
        constraints: NotRequired[pulumi.Input['ModelPackageMetricsSourceArgsDict']]
        """
        The drift check model data quality constraints.
        """
        statistics: NotRequired[pulumi.Input['ModelPackageMetricsSourceArgsDict']]
        """
        The drift check model data quality statistics.
        """
elif False:
    ModelPackageDriftCheckModelDataQualityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelPackageDriftCheckModelDataQualityArgs:
    def __init__(__self__, *,
                 constraints: Optional[pulumi.Input['ModelPackageMetricsSourceArgs']] = None,
                 statistics: Optional[pulumi.Input['ModelPackageMetricsSourceArgs']] = None):
        """
        Represents the drift check data quality baselines that can be used when the model monitor is set using the model package.
        :param pulumi.Input['ModelPackageMetricsSourceArgs'] constraints: The drift check model data quality constraints.
        :param pulumi.Input['ModelPackageMetricsSourceArgs'] statistics: The drift check model data quality statistics.
        """
        if constraints is not None:
            pulumi.set(__self__, "constraints", constraints)
        if statistics is not None:
            pulumi.set(__self__, "statistics", statistics)

    @property
    @pulumi.getter
    def constraints(self) -> Optional[pulumi.Input['ModelPackageMetricsSourceArgs']]:
        """
        The drift check model data quality constraints.
        """
        return pulumi.get(self, "constraints")

    @constraints.setter
    def constraints(self, value: Optional[pulumi.Input['ModelPackageMetricsSourceArgs']]):
        pulumi.set(self, "constraints", value)

    @property
    @pulumi.getter
    def statistics(self) -> Optional[pulumi.Input['ModelPackageMetricsSourceArgs']]:
        """
        The drift check model data quality statistics.
        """
        return pulumi.get(self, "statistics")

    @statistics.setter
    def statistics(self, value: Optional[pulumi.Input['ModelPackageMetricsSourceArgs']]):
        pulumi.set(self, "statistics", value)


if not MYPY:
    class ModelPackageDriftCheckModelQualityArgsDict(TypedDict):
        """
        Represents the drift check model quality baselines that can be used when the model monitor is set using the model package.
        """
        constraints: NotRequired[pulumi.Input['ModelPackageMetricsSourceArgsDict']]
        """
        The drift check model quality constraints.
        """
        statistics: NotRequired[pulumi.Input['ModelPackageMetricsSourceArgsDict']]
        """
        The drift check model quality statistics.
        """
elif False:
    ModelPackageDriftCheckModelQualityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelPackageDriftCheckModelQualityArgs:
    def __init__(__self__, *,
                 constraints: Optional[pulumi.Input['ModelPackageMetricsSourceArgs']] = None,
                 statistics: Optional[pulumi.Input['ModelPackageMetricsSourceArgs']] = None):
        """
        Represents the drift check model quality baselines that can be used when the model monitor is set using the model package.
        :param pulumi.Input['ModelPackageMetricsSourceArgs'] constraints: The drift check model quality constraints.
        :param pulumi.Input['ModelPackageMetricsSourceArgs'] statistics: The drift check model quality statistics.
        """
        if constraints is not None:
            pulumi.set(__self__, "constraints", constraints)
        if statistics is not None:
            pulumi.set(__self__, "statistics", statistics)

    @property
    @pulumi.getter
    def constraints(self) -> Optional[pulumi.Input['ModelPackageMetricsSourceArgs']]:
        """
        The drift check model quality constraints.
        """
        return pulumi.get(self, "constraints")

    @constraints.setter
    def constraints(self, value: Optional[pulumi.Input['ModelPackageMetricsSourceArgs']]):
        pulumi.set(self, "constraints", value)

    @property
    @pulumi.getter
    def statistics(self) -> Optional[pulumi.Input['ModelPackageMetricsSourceArgs']]:
        """
        The drift check model quality statistics.
        """
        return pulumi.get(self, "statistics")

    @statistics.setter
    def statistics(self, value: Optional[pulumi.Input['ModelPackageMetricsSourceArgs']]):
        pulumi.set(self, "statistics", value)


if not MYPY:
    class ModelPackageEnvironmentArgsDict(TypedDict):
        """
        Sets the environment variables in the Docker container
        """
        pass
elif False:
    ModelPackageEnvironmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelPackageEnvironmentArgs:
    def __init__(__self__):
        """
        Sets the environment variables in the Docker container
        """
        pass


if not MYPY:
    class ModelPackageExplainabilityArgsDict(TypedDict):
        """
        Contains explainability metrics for a model.
        """
        report: NotRequired[pulumi.Input['ModelPackageMetricsSourceArgsDict']]
        """
        The explainability report for a model.
        """
elif False:
    ModelPackageExplainabilityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelPackageExplainabilityArgs:
    def __init__(__self__, *,
                 report: Optional[pulumi.Input['ModelPackageMetricsSourceArgs']] = None):
        """
        Contains explainability metrics for a model.
        :param pulumi.Input['ModelPackageMetricsSourceArgs'] report: The explainability report for a model.
        """
        if report is not None:
            pulumi.set(__self__, "report", report)

    @property
    @pulumi.getter
    def report(self) -> Optional[pulumi.Input['ModelPackageMetricsSourceArgs']]:
        """
        The explainability report for a model.
        """
        return pulumi.get(self, "report")

    @report.setter
    def report(self, value: Optional[pulumi.Input['ModelPackageMetricsSourceArgs']]):
        pulumi.set(self, "report", value)


if not MYPY:
    class ModelPackageFileSourceArgsDict(TypedDict):
        """
        Represents a File Source Object.
        """
        s3_uri: pulumi.Input[str]
        """
        The Amazon S3 URI for the file source.
        """
        content_digest: NotRequired[pulumi.Input[str]]
        """
        The digest of the file source.
        """
        content_type: NotRequired[pulumi.Input[str]]
        """
        The type of content stored in the file source.
        """
elif False:
    ModelPackageFileSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelPackageFileSourceArgs:
    def __init__(__self__, *,
                 s3_uri: pulumi.Input[str],
                 content_digest: Optional[pulumi.Input[str]] = None,
                 content_type: Optional[pulumi.Input[str]] = None):
        """
        Represents a File Source Object.
        :param pulumi.Input[str] s3_uri: The Amazon S3 URI for the file source.
        :param pulumi.Input[str] content_digest: The digest of the file source.
        :param pulumi.Input[str] content_type: The type of content stored in the file source.
        """
        pulumi.set(__self__, "s3_uri", s3_uri)
        if content_digest is not None:
            pulumi.set(__self__, "content_digest", content_digest)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)

    @property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> pulumi.Input[str]:
        """
        The Amazon S3 URI for the file source.
        """
        return pulumi.get(self, "s3_uri")

    @s3_uri.setter
    def s3_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_uri", value)

    @property
    @pulumi.getter(name="contentDigest")
    def content_digest(self) -> Optional[pulumi.Input[str]]:
        """
        The digest of the file source.
        """
        return pulumi.get(self, "content_digest")

    @content_digest.setter
    def content_digest(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_digest", value)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of content stored in the file source.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_type", value)


if not MYPY:
    class ModelPackageInferenceSpecificationArgsDict(TypedDict):
        """
        Details about inference jobs that can be run with models based on this model package.
        """
        containers: pulumi.Input[Sequence[pulumi.Input['ModelPackageContainerDefinitionArgsDict']]]
        """
        The Amazon ECR registry path of the Docker image that contains the inference code.
        """
        supported_content_types: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The supported MIME types for the input data.
        """
        supported_response_mime_types: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The supported MIME types for the output data.
        """
        supported_realtime_inference_instance_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of the instance types that are used to generate inferences in real-time
        """
        supported_transform_instance_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of the instance types on which a transformation job can be run or on which an endpoint can be deployed.
        """
elif False:
    ModelPackageInferenceSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelPackageInferenceSpecificationArgs:
    def __init__(__self__, *,
                 containers: pulumi.Input[Sequence[pulumi.Input['ModelPackageContainerDefinitionArgs']]],
                 supported_content_types: pulumi.Input[Sequence[pulumi.Input[str]]],
                 supported_response_mime_types: pulumi.Input[Sequence[pulumi.Input[str]]],
                 supported_realtime_inference_instance_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 supported_transform_instance_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Details about inference jobs that can be run with models based on this model package.
        :param pulumi.Input[Sequence[pulumi.Input['ModelPackageContainerDefinitionArgs']]] containers: The Amazon ECR registry path of the Docker image that contains the inference code.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] supported_content_types: The supported MIME types for the input data.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] supported_response_mime_types: The supported MIME types for the output data.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] supported_realtime_inference_instance_types: A list of the instance types that are used to generate inferences in real-time
        :param pulumi.Input[Sequence[pulumi.Input[str]]] supported_transform_instance_types: A list of the instance types on which a transformation job can be run or on which an endpoint can be deployed.
        """
        pulumi.set(__self__, "containers", containers)
        pulumi.set(__self__, "supported_content_types", supported_content_types)
        pulumi.set(__self__, "supported_response_mime_types", supported_response_mime_types)
        if supported_realtime_inference_instance_types is not None:
            pulumi.set(__self__, "supported_realtime_inference_instance_types", supported_realtime_inference_instance_types)
        if supported_transform_instance_types is not None:
            pulumi.set(__self__, "supported_transform_instance_types", supported_transform_instance_types)

    @property
    @pulumi.getter
    def containers(self) -> pulumi.Input[Sequence[pulumi.Input['ModelPackageContainerDefinitionArgs']]]:
        """
        The Amazon ECR registry path of the Docker image that contains the inference code.
        """
        return pulumi.get(self, "containers")

    @containers.setter
    def containers(self, value: pulumi.Input[Sequence[pulumi.Input['ModelPackageContainerDefinitionArgs']]]):
        pulumi.set(self, "containers", value)

    @property
    @pulumi.getter(name="supportedContentTypes")
    def supported_content_types(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The supported MIME types for the input data.
        """
        return pulumi.get(self, "supported_content_types")

    @supported_content_types.setter
    def supported_content_types(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "supported_content_types", value)

    @property
    @pulumi.getter(name="supportedResponseMimeTypes")
    def supported_response_mime_types(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The supported MIME types for the output data.
        """
        return pulumi.get(self, "supported_response_mime_types")

    @supported_response_mime_types.setter
    def supported_response_mime_types(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "supported_response_mime_types", value)

    @property
    @pulumi.getter(name="supportedRealtimeInferenceInstanceTypes")
    def supported_realtime_inference_instance_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of the instance types that are used to generate inferences in real-time
        """
        return pulumi.get(self, "supported_realtime_inference_instance_types")

    @supported_realtime_inference_instance_types.setter
    def supported_realtime_inference_instance_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "supported_realtime_inference_instance_types", value)

    @property
    @pulumi.getter(name="supportedTransformInstanceTypes")
    def supported_transform_instance_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of the instance types on which a transformation job can be run or on which an endpoint can be deployed.
        """
        return pulumi.get(self, "supported_transform_instance_types")

    @supported_transform_instance_types.setter
    def supported_transform_instance_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "supported_transform_instance_types", value)


if not MYPY:
    class ModelPackageMetadataPropertiesArgsDict(TypedDict):
        """
        Metadata properties of the tracking entity, trial, or trial component.
        """
        commit_id: NotRequired[pulumi.Input[str]]
        """
        The commit ID.
        """
        generated_by: NotRequired[pulumi.Input[str]]
        """
        The entity this entity was generated by.
        """
        project_id: NotRequired[pulumi.Input[str]]
        """
        The project ID metadata.
        """
        repository: NotRequired[pulumi.Input[str]]
        """
        The repository metadata.
        """
elif False:
    ModelPackageMetadataPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelPackageMetadataPropertiesArgs:
    def __init__(__self__, *,
                 commit_id: Optional[pulumi.Input[str]] = None,
                 generated_by: Optional[pulumi.Input[str]] = None,
                 project_id: Optional[pulumi.Input[str]] = None,
                 repository: Optional[pulumi.Input[str]] = None):
        """
        Metadata properties of the tracking entity, trial, or trial component.
        :param pulumi.Input[str] commit_id: The commit ID.
        :param pulumi.Input[str] generated_by: The entity this entity was generated by.
        :param pulumi.Input[str] project_id: The project ID metadata.
        :param pulumi.Input[str] repository: The repository metadata.
        """
        if commit_id is not None:
            pulumi.set(__self__, "commit_id", commit_id)
        if generated_by is not None:
            pulumi.set(__self__, "generated_by", generated_by)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if repository is not None:
            pulumi.set(__self__, "repository", repository)

    @property
    @pulumi.getter(name="commitId")
    def commit_id(self) -> Optional[pulumi.Input[str]]:
        """
        The commit ID.
        """
        return pulumi.get(self, "commit_id")

    @commit_id.setter
    def commit_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "commit_id", value)

    @property
    @pulumi.getter(name="generatedBy")
    def generated_by(self) -> Optional[pulumi.Input[str]]:
        """
        The entity this entity was generated by.
        """
        return pulumi.get(self, "generated_by")

    @generated_by.setter
    def generated_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "generated_by", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[str]]:
        """
        The project ID metadata.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter
    def repository(self) -> Optional[pulumi.Input[str]]:
        """
        The repository metadata.
        """
        return pulumi.get(self, "repository")

    @repository.setter
    def repository(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repository", value)


if not MYPY:
    class ModelPackageMetricsSourceArgsDict(TypedDict):
        """
        Represents a Metric Source Object.
        """
        content_type: pulumi.Input[str]
        """
        The type of content stored in the metric source.
        """
        s3_uri: pulumi.Input[str]
        """
        The Amazon S3 URI for the metric source.
        """
        content_digest: NotRequired[pulumi.Input[str]]
        """
        The digest of the metric source.
        """
elif False:
    ModelPackageMetricsSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelPackageMetricsSourceArgs:
    def __init__(__self__, *,
                 content_type: pulumi.Input[str],
                 s3_uri: pulumi.Input[str],
                 content_digest: Optional[pulumi.Input[str]] = None):
        """
        Represents a Metric Source Object.
        :param pulumi.Input[str] content_type: The type of content stored in the metric source.
        :param pulumi.Input[str] s3_uri: The Amazon S3 URI for the metric source.
        :param pulumi.Input[str] content_digest: The digest of the metric source.
        """
        pulumi.set(__self__, "content_type", content_type)
        pulumi.set(__self__, "s3_uri", s3_uri)
        if content_digest is not None:
            pulumi.set(__self__, "content_digest", content_digest)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> pulumi.Input[str]:
        """
        The type of content stored in the metric source.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "content_type", value)

    @property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> pulumi.Input[str]:
        """
        The Amazon S3 URI for the metric source.
        """
        return pulumi.get(self, "s3_uri")

    @s3_uri.setter
    def s3_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_uri", value)

    @property
    @pulumi.getter(name="contentDigest")
    def content_digest(self) -> Optional[pulumi.Input[str]]:
        """
        The digest of the metric source.
        """
        return pulumi.get(self, "content_digest")

    @content_digest.setter
    def content_digest(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_digest", value)


if not MYPY:
    class ModelPackageModelAccessConfigArgsDict(TypedDict):
        """
        Specifies the access configuration file for the ML model.
        """
        accept_eula: pulumi.Input[bool]
        """
        Specifies agreement to the model end-user license agreement (EULA).
        """
elif False:
    ModelPackageModelAccessConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelPackageModelAccessConfigArgs:
    def __init__(__self__, *,
                 accept_eula: pulumi.Input[bool]):
        """
        Specifies the access configuration file for the ML model.
        :param pulumi.Input[bool] accept_eula: Specifies agreement to the model end-user license agreement (EULA).
        """
        pulumi.set(__self__, "accept_eula", accept_eula)

    @property
    @pulumi.getter(name="acceptEula")
    def accept_eula(self) -> pulumi.Input[bool]:
        """
        Specifies agreement to the model end-user license agreement (EULA).
        """
        return pulumi.get(self, "accept_eula")

    @accept_eula.setter
    def accept_eula(self, value: pulumi.Input[bool]):
        pulumi.set(self, "accept_eula", value)


if not MYPY:
    class ModelPackageModelCardArgsDict(TypedDict):
        """
        The model card associated with the model package.
        """
        model_card_content: pulumi.Input[str]
        """
        The content of the model card.
        """
        model_card_status: pulumi.Input['ModelPackageModelCardModelCardStatus']
        """
        The approval status of the model card within your organization.
        """
elif False:
    ModelPackageModelCardArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelPackageModelCardArgs:
    def __init__(__self__, *,
                 model_card_content: pulumi.Input[str],
                 model_card_status: pulumi.Input['ModelPackageModelCardModelCardStatus']):
        """
        The model card associated with the model package.
        :param pulumi.Input[str] model_card_content: The content of the model card.
        :param pulumi.Input['ModelPackageModelCardModelCardStatus'] model_card_status: The approval status of the model card within your organization.
        """
        pulumi.set(__self__, "model_card_content", model_card_content)
        pulumi.set(__self__, "model_card_status", model_card_status)

    @property
    @pulumi.getter(name="modelCardContent")
    def model_card_content(self) -> pulumi.Input[str]:
        """
        The content of the model card.
        """
        return pulumi.get(self, "model_card_content")

    @model_card_content.setter
    def model_card_content(self, value: pulumi.Input[str]):
        pulumi.set(self, "model_card_content", value)

    @property
    @pulumi.getter(name="modelCardStatus")
    def model_card_status(self) -> pulumi.Input['ModelPackageModelCardModelCardStatus']:
        """
        The approval status of the model card within your organization.
        """
        return pulumi.get(self, "model_card_status")

    @model_card_status.setter
    def model_card_status(self, value: pulumi.Input['ModelPackageModelCardModelCardStatus']):
        pulumi.set(self, "model_card_status", value)


if not MYPY:
    class ModelPackageModelDataQualityArgsDict(TypedDict):
        """
        Metrics that measure the quality of the input data for a model.
        """
        constraints: NotRequired[pulumi.Input['ModelPackageMetricsSourceArgsDict']]
        """
        Data quality constraints for a model.
        """
        statistics: NotRequired[pulumi.Input['ModelPackageMetricsSourceArgsDict']]
        """
        Data quality statistics for a model.
        """
elif False:
    ModelPackageModelDataQualityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelPackageModelDataQualityArgs:
    def __init__(__self__, *,
                 constraints: Optional[pulumi.Input['ModelPackageMetricsSourceArgs']] = None,
                 statistics: Optional[pulumi.Input['ModelPackageMetricsSourceArgs']] = None):
        """
        Metrics that measure the quality of the input data for a model.
        :param pulumi.Input['ModelPackageMetricsSourceArgs'] constraints: Data quality constraints for a model.
        :param pulumi.Input['ModelPackageMetricsSourceArgs'] statistics: Data quality statistics for a model.
        """
        if constraints is not None:
            pulumi.set(__self__, "constraints", constraints)
        if statistics is not None:
            pulumi.set(__self__, "statistics", statistics)

    @property
    @pulumi.getter
    def constraints(self) -> Optional[pulumi.Input['ModelPackageMetricsSourceArgs']]:
        """
        Data quality constraints for a model.
        """
        return pulumi.get(self, "constraints")

    @constraints.setter
    def constraints(self, value: Optional[pulumi.Input['ModelPackageMetricsSourceArgs']]):
        pulumi.set(self, "constraints", value)

    @property
    @pulumi.getter
    def statistics(self) -> Optional[pulumi.Input['ModelPackageMetricsSourceArgs']]:
        """
        Data quality statistics for a model.
        """
        return pulumi.get(self, "statistics")

    @statistics.setter
    def statistics(self, value: Optional[pulumi.Input['ModelPackageMetricsSourceArgs']]):
        pulumi.set(self, "statistics", value)


if not MYPY:
    class ModelPackageModelDataSourceArgsDict(TypedDict):
        """
        Specifies the location of ML model data to deploy during endpoint creation.
        """
        s3_data_source: NotRequired[pulumi.Input['ModelPackageS3ModelDataSourceArgsDict']]
elif False:
    ModelPackageModelDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelPackageModelDataSourceArgs:
    def __init__(__self__, *,
                 s3_data_source: Optional[pulumi.Input['ModelPackageS3ModelDataSourceArgs']] = None):
        """
        Specifies the location of ML model data to deploy during endpoint creation.
        """
        if s3_data_source is not None:
            pulumi.set(__self__, "s3_data_source", s3_data_source)

    @property
    @pulumi.getter(name="s3DataSource")
    def s3_data_source(self) -> Optional[pulumi.Input['ModelPackageS3ModelDataSourceArgs']]:
        return pulumi.get(self, "s3_data_source")

    @s3_data_source.setter
    def s3_data_source(self, value: Optional[pulumi.Input['ModelPackageS3ModelDataSourceArgs']]):
        pulumi.set(self, "s3_data_source", value)


if not MYPY:
    class ModelPackageModelMetricsArgsDict(TypedDict):
        """
        A structure that contains model metrics reports.
        """
        bias: NotRequired[pulumi.Input['ModelPackageBiasArgsDict']]
        """
        Metrics that measure bias in a model.
        """
        explainability: NotRequired[pulumi.Input['ModelPackageExplainabilityArgsDict']]
        """
        Metrics that help explain a model.
        """
        model_data_quality: NotRequired[pulumi.Input['ModelPackageModelDataQualityArgsDict']]
        """
        Metrics that measure the quality of the input data for a model.
        """
        model_quality: NotRequired[pulumi.Input['ModelPackageModelQualityArgsDict']]
        """
        Metrics that measure the quality of a model.
        """
elif False:
    ModelPackageModelMetricsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelPackageModelMetricsArgs:
    def __init__(__self__, *,
                 bias: Optional[pulumi.Input['ModelPackageBiasArgs']] = None,
                 explainability: Optional[pulumi.Input['ModelPackageExplainabilityArgs']] = None,
                 model_data_quality: Optional[pulumi.Input['ModelPackageModelDataQualityArgs']] = None,
                 model_quality: Optional[pulumi.Input['ModelPackageModelQualityArgs']] = None):
        """
        A structure that contains model metrics reports.
        :param pulumi.Input['ModelPackageBiasArgs'] bias: Metrics that measure bias in a model.
        :param pulumi.Input['ModelPackageExplainabilityArgs'] explainability: Metrics that help explain a model.
        :param pulumi.Input['ModelPackageModelDataQualityArgs'] model_data_quality: Metrics that measure the quality of the input data for a model.
        :param pulumi.Input['ModelPackageModelQualityArgs'] model_quality: Metrics that measure the quality of a model.
        """
        if bias is not None:
            pulumi.set(__self__, "bias", bias)
        if explainability is not None:
            pulumi.set(__self__, "explainability", explainability)
        if model_data_quality is not None:
            pulumi.set(__self__, "model_data_quality", model_data_quality)
        if model_quality is not None:
            pulumi.set(__self__, "model_quality", model_quality)

    @property
    @pulumi.getter
    def bias(self) -> Optional[pulumi.Input['ModelPackageBiasArgs']]:
        """
        Metrics that measure bias in a model.
        """
        return pulumi.get(self, "bias")

    @bias.setter
    def bias(self, value: Optional[pulumi.Input['ModelPackageBiasArgs']]):
        pulumi.set(self, "bias", value)

    @property
    @pulumi.getter
    def explainability(self) -> Optional[pulumi.Input['ModelPackageExplainabilityArgs']]:
        """
        Metrics that help explain a model.
        """
        return pulumi.get(self, "explainability")

    @explainability.setter
    def explainability(self, value: Optional[pulumi.Input['ModelPackageExplainabilityArgs']]):
        pulumi.set(self, "explainability", value)

    @property
    @pulumi.getter(name="modelDataQuality")
    def model_data_quality(self) -> Optional[pulumi.Input['ModelPackageModelDataQualityArgs']]:
        """
        Metrics that measure the quality of the input data for a model.
        """
        return pulumi.get(self, "model_data_quality")

    @model_data_quality.setter
    def model_data_quality(self, value: Optional[pulumi.Input['ModelPackageModelDataQualityArgs']]):
        pulumi.set(self, "model_data_quality", value)

    @property
    @pulumi.getter(name="modelQuality")
    def model_quality(self) -> Optional[pulumi.Input['ModelPackageModelQualityArgs']]:
        """
        Metrics that measure the quality of a model.
        """
        return pulumi.get(self, "model_quality")

    @model_quality.setter
    def model_quality(self, value: Optional[pulumi.Input['ModelPackageModelQualityArgs']]):
        pulumi.set(self, "model_quality", value)


if not MYPY:
    class ModelPackageModelQualityArgsDict(TypedDict):
        """
        Metrics that measure the quality of a model.
        """
        constraints: NotRequired[pulumi.Input['ModelPackageMetricsSourceArgsDict']]
        """
        Model quality constraints.
        """
        statistics: NotRequired[pulumi.Input['ModelPackageMetricsSourceArgsDict']]
        """
        Model quality statistics.
        """
elif False:
    ModelPackageModelQualityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelPackageModelQualityArgs:
    def __init__(__self__, *,
                 constraints: Optional[pulumi.Input['ModelPackageMetricsSourceArgs']] = None,
                 statistics: Optional[pulumi.Input['ModelPackageMetricsSourceArgs']] = None):
        """
        Metrics that measure the quality of a model.
        :param pulumi.Input['ModelPackageMetricsSourceArgs'] constraints: Model quality constraints.
        :param pulumi.Input['ModelPackageMetricsSourceArgs'] statistics: Model quality statistics.
        """
        if constraints is not None:
            pulumi.set(__self__, "constraints", constraints)
        if statistics is not None:
            pulumi.set(__self__, "statistics", statistics)

    @property
    @pulumi.getter
    def constraints(self) -> Optional[pulumi.Input['ModelPackageMetricsSourceArgs']]:
        """
        Model quality constraints.
        """
        return pulumi.get(self, "constraints")

    @constraints.setter
    def constraints(self, value: Optional[pulumi.Input['ModelPackageMetricsSourceArgs']]):
        pulumi.set(self, "constraints", value)

    @property
    @pulumi.getter
    def statistics(self) -> Optional[pulumi.Input['ModelPackageMetricsSourceArgs']]:
        """
        Model quality statistics.
        """
        return pulumi.get(self, "statistics")

    @statistics.setter
    def statistics(self, value: Optional[pulumi.Input['ModelPackageMetricsSourceArgs']]):
        pulumi.set(self, "statistics", value)


if not MYPY:
    class ModelPackageS3DataSourceArgsDict(TypedDict):
        """
        Describes the S3 data source.
        """
        s3_data_type: pulumi.Input['ModelPackageS3DataSourceS3DataType']
        """
        The S3 Data Source Type
        """
        s3_uri: pulumi.Input[str]
        """
        Depending on the value specified for the S3DataType, identifies either a key name prefix or a manifest.
        """
elif False:
    ModelPackageS3DataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelPackageS3DataSourceArgs:
    def __init__(__self__, *,
                 s3_data_type: pulumi.Input['ModelPackageS3DataSourceS3DataType'],
                 s3_uri: pulumi.Input[str]):
        """
        Describes the S3 data source.
        :param pulumi.Input['ModelPackageS3DataSourceS3DataType'] s3_data_type: The S3 Data Source Type
        :param pulumi.Input[str] s3_uri: Depending on the value specified for the S3DataType, identifies either a key name prefix or a manifest.
        """
        pulumi.set(__self__, "s3_data_type", s3_data_type)
        pulumi.set(__self__, "s3_uri", s3_uri)

    @property
    @pulumi.getter(name="s3DataType")
    def s3_data_type(self) -> pulumi.Input['ModelPackageS3DataSourceS3DataType']:
        """
        The S3 Data Source Type
        """
        return pulumi.get(self, "s3_data_type")

    @s3_data_type.setter
    def s3_data_type(self, value: pulumi.Input['ModelPackageS3DataSourceS3DataType']):
        pulumi.set(self, "s3_data_type", value)

    @property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> pulumi.Input[str]:
        """
        Depending on the value specified for the S3DataType, identifies either a key name prefix or a manifest.
        """
        return pulumi.get(self, "s3_uri")

    @s3_uri.setter
    def s3_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_uri", value)


if not MYPY:
    class ModelPackageS3ModelDataSourceArgsDict(TypedDict):
        """
        Specifies the S3 location of ML model data to deploy.
        """
        compression_type: pulumi.Input['ModelPackageS3ModelDataSourceCompressionType']
        """
        Specifies how the ML model data is prepared.
        """
        s3_data_type: pulumi.Input['ModelPackageS3ModelDataSourceS3DataType']
        """
        Specifies the type of ML model data to deploy.
        """
        s3_uri: pulumi.Input[str]
        """
        Specifies the S3 path of ML model data to deploy.
        """
        model_access_config: NotRequired[pulumi.Input['ModelPackageModelAccessConfigArgsDict']]
elif False:
    ModelPackageS3ModelDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelPackageS3ModelDataSourceArgs:
    def __init__(__self__, *,
                 compression_type: pulumi.Input['ModelPackageS3ModelDataSourceCompressionType'],
                 s3_data_type: pulumi.Input['ModelPackageS3ModelDataSourceS3DataType'],
                 s3_uri: pulumi.Input[str],
                 model_access_config: Optional[pulumi.Input['ModelPackageModelAccessConfigArgs']] = None):
        """
        Specifies the S3 location of ML model data to deploy.
        :param pulumi.Input['ModelPackageS3ModelDataSourceCompressionType'] compression_type: Specifies how the ML model data is prepared.
        :param pulumi.Input['ModelPackageS3ModelDataSourceS3DataType'] s3_data_type: Specifies the type of ML model data to deploy.
        :param pulumi.Input[str] s3_uri: Specifies the S3 path of ML model data to deploy.
        """
        pulumi.set(__self__, "compression_type", compression_type)
        pulumi.set(__self__, "s3_data_type", s3_data_type)
        pulumi.set(__self__, "s3_uri", s3_uri)
        if model_access_config is not None:
            pulumi.set(__self__, "model_access_config", model_access_config)

    @property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> pulumi.Input['ModelPackageS3ModelDataSourceCompressionType']:
        """
        Specifies how the ML model data is prepared.
        """
        return pulumi.get(self, "compression_type")

    @compression_type.setter
    def compression_type(self, value: pulumi.Input['ModelPackageS3ModelDataSourceCompressionType']):
        pulumi.set(self, "compression_type", value)

    @property
    @pulumi.getter(name="s3DataType")
    def s3_data_type(self) -> pulumi.Input['ModelPackageS3ModelDataSourceS3DataType']:
        """
        Specifies the type of ML model data to deploy.
        """
        return pulumi.get(self, "s3_data_type")

    @s3_data_type.setter
    def s3_data_type(self, value: pulumi.Input['ModelPackageS3ModelDataSourceS3DataType']):
        pulumi.set(self, "s3_data_type", value)

    @property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> pulumi.Input[str]:
        """
        Specifies the S3 path of ML model data to deploy.
        """
        return pulumi.get(self, "s3_uri")

    @s3_uri.setter
    def s3_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_uri", value)

    @property
    @pulumi.getter(name="modelAccessConfig")
    def model_access_config(self) -> Optional[pulumi.Input['ModelPackageModelAccessConfigArgs']]:
        return pulumi.get(self, "model_access_config")

    @model_access_config.setter
    def model_access_config(self, value: Optional[pulumi.Input['ModelPackageModelAccessConfigArgs']]):
        pulumi.set(self, "model_access_config", value)


if not MYPY:
    class ModelPackageSecurityConfigArgsDict(TypedDict):
        """
        An optional AWS Key Management Service key to encrypt, decrypt, and re-encrypt model package information for regulated workloads with highly sensitive data.
        """
        kms_key_id: pulumi.Input[str]
        """
        The AWS KMS Key ID (KMSKeyId) used for encryption of model package information.
        """
elif False:
    ModelPackageSecurityConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelPackageSecurityConfigArgs:
    def __init__(__self__, *,
                 kms_key_id: pulumi.Input[str]):
        """
        An optional AWS Key Management Service key to encrypt, decrypt, and re-encrypt model package information for regulated workloads with highly sensitive data.
        :param pulumi.Input[str] kms_key_id: The AWS KMS Key ID (KMSKeyId) used for encryption of model package information.
        """
        pulumi.set(__self__, "kms_key_id", kms_key_id)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> pulumi.Input[str]:
        """
        The AWS KMS Key ID (KMSKeyId) used for encryption of model package information.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "kms_key_id", value)


if not MYPY:
    class ModelPackageSourceAlgorithmSpecificationArgsDict(TypedDict):
        """
        Details about the algorithm that was used to create the model package.
        """
        source_algorithms: pulumi.Input[Sequence[pulumi.Input['ModelPackageSourceAlgorithmArgsDict']]]
        """
        A list of algorithms that were used to create a model package.
        """
elif False:
    ModelPackageSourceAlgorithmSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelPackageSourceAlgorithmSpecificationArgs:
    def __init__(__self__, *,
                 source_algorithms: pulumi.Input[Sequence[pulumi.Input['ModelPackageSourceAlgorithmArgs']]]):
        """
        Details about the algorithm that was used to create the model package.
        :param pulumi.Input[Sequence[pulumi.Input['ModelPackageSourceAlgorithmArgs']]] source_algorithms: A list of algorithms that were used to create a model package.
        """
        pulumi.set(__self__, "source_algorithms", source_algorithms)

    @property
    @pulumi.getter(name="sourceAlgorithms")
    def source_algorithms(self) -> pulumi.Input[Sequence[pulumi.Input['ModelPackageSourceAlgorithmArgs']]]:
        """
        A list of algorithms that were used to create a model package.
        """
        return pulumi.get(self, "source_algorithms")

    @source_algorithms.setter
    def source_algorithms(self, value: pulumi.Input[Sequence[pulumi.Input['ModelPackageSourceAlgorithmArgs']]]):
        pulumi.set(self, "source_algorithms", value)


if not MYPY:
    class ModelPackageSourceAlgorithmArgsDict(TypedDict):
        """
        Specifies an algorithm that was used to create the model package. The algorithm must be either an algorithm resource in your Amazon SageMaker account or an algorithm in AWS Marketplace that you are subscribed to.
        """
        algorithm_name: pulumi.Input[str]
        """
        The name of an algorithm that was used to create the model package. The algorithm must be either an algorithm resource in your Amazon SageMaker account or an algorithm in AWS Marketplace that you are subscribed to.
        """
        model_data_url: NotRequired[pulumi.Input[str]]
        """
        The Amazon S3 path where the model artifacts, which result from model training, are stored. This path must point to a single gzip compressed tar archive (.tar.gz suffix).
        """
elif False:
    ModelPackageSourceAlgorithmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelPackageSourceAlgorithmArgs:
    def __init__(__self__, *,
                 algorithm_name: pulumi.Input[str],
                 model_data_url: Optional[pulumi.Input[str]] = None):
        """
        Specifies an algorithm that was used to create the model package. The algorithm must be either an algorithm resource in your Amazon SageMaker account or an algorithm in AWS Marketplace that you are subscribed to.
        :param pulumi.Input[str] algorithm_name: The name of an algorithm that was used to create the model package. The algorithm must be either an algorithm resource in your Amazon SageMaker account or an algorithm in AWS Marketplace that you are subscribed to.
        :param pulumi.Input[str] model_data_url: The Amazon S3 path where the model artifacts, which result from model training, are stored. This path must point to a single gzip compressed tar archive (.tar.gz suffix).
        """
        pulumi.set(__self__, "algorithm_name", algorithm_name)
        if model_data_url is not None:
            pulumi.set(__self__, "model_data_url", model_data_url)

    @property
    @pulumi.getter(name="algorithmName")
    def algorithm_name(self) -> pulumi.Input[str]:
        """
        The name of an algorithm that was used to create the model package. The algorithm must be either an algorithm resource in your Amazon SageMaker account or an algorithm in AWS Marketplace that you are subscribed to.
        """
        return pulumi.get(self, "algorithm_name")

    @algorithm_name.setter
    def algorithm_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "algorithm_name", value)

    @property
    @pulumi.getter(name="modelDataUrl")
    def model_data_url(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon S3 path where the model artifacts, which result from model training, are stored. This path must point to a single gzip compressed tar archive (.tar.gz suffix).
        """
        return pulumi.get(self, "model_data_url")

    @model_data_url.setter
    def model_data_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "model_data_url", value)


if not MYPY:
    class ModelPackageStatusDetailsArgsDict(TypedDict):
        """
        Details about the current status of the model package.
        """
        validation_statuses: NotRequired[pulumi.Input[Sequence[pulumi.Input['ModelPackageStatusItemArgsDict']]]]
        """
        The validation status of the model package.
        """
elif False:
    ModelPackageStatusDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelPackageStatusDetailsArgs:
    def __init__(__self__, *,
                 validation_statuses: Optional[pulumi.Input[Sequence[pulumi.Input['ModelPackageStatusItemArgs']]]] = None):
        """
        Details about the current status of the model package.
        :param pulumi.Input[Sequence[pulumi.Input['ModelPackageStatusItemArgs']]] validation_statuses: The validation status of the model package.
        """
        if validation_statuses is not None:
            pulumi.set(__self__, "validation_statuses", validation_statuses)

    @property
    @pulumi.getter(name="validationStatuses")
    def validation_statuses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ModelPackageStatusItemArgs']]]]:
        """
        The validation status of the model package.
        """
        return pulumi.get(self, "validation_statuses")

    @validation_statuses.setter
    def validation_statuses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ModelPackageStatusItemArgs']]]]):
        pulumi.set(self, "validation_statuses", value)


if not MYPY:
    class ModelPackageStatusItemArgsDict(TypedDict):
        """
        Represents the overall status of a model package.
        """
        name: pulumi.Input[str]
        """
        The name of the model package for which the overall status is being reported.
        """
        status: pulumi.Input['ModelPackageStatusItemStatus']
        """
        The current status.
        """
        failure_reason: NotRequired[pulumi.Input[str]]
        """
        If the overall status is Failed, the reason for the failure.
        """
elif False:
    ModelPackageStatusItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelPackageStatusItemArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 status: pulumi.Input['ModelPackageStatusItemStatus'],
                 failure_reason: Optional[pulumi.Input[str]] = None):
        """
        Represents the overall status of a model package.
        :param pulumi.Input[str] name: The name of the model package for which the overall status is being reported.
        :param pulumi.Input['ModelPackageStatusItemStatus'] status: The current status.
        :param pulumi.Input[str] failure_reason: If the overall status is Failed, the reason for the failure.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "status", status)
        if failure_reason is not None:
            pulumi.set(__self__, "failure_reason", failure_reason)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the model package for which the overall status is being reported.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def status(self) -> pulumi.Input['ModelPackageStatusItemStatus']:
        """
        The current status.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input['ModelPackageStatusItemStatus']):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="failureReason")
    def failure_reason(self) -> Optional[pulumi.Input[str]]:
        """
        If the overall status is Failed, the reason for the failure.
        """
        return pulumi.get(self, "failure_reason")

    @failure_reason.setter
    def failure_reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "failure_reason", value)


if not MYPY:
    class ModelPackageTransformInputArgsDict(TypedDict):
        """
        Describes the input source of a transform job and the way the transform job consumes it.
        """
        data_source: pulumi.Input['ModelPackageDataSourceArgsDict']
        """
        Describes the location of the channel data, which is, the S3 location of the input data that the model can consume.
        """
        compression_type: NotRequired[pulumi.Input['ModelPackageTransformInputCompressionType']]
        """
        If your transform data is compressed, specify the compression type. Amazon SageMaker automatically decompresses the data for the transform job accordingly. The default value is None.
        """
        content_type: NotRequired[pulumi.Input[str]]
        """
        The multipurpose internet mail extension (MIME) type of the data. Amazon SageMaker uses the MIME type with each http call to transfer data to the transform job.
        """
        split_type: NotRequired[pulumi.Input['ModelPackageTransformInputSplitType']]
        """
        The method to use to split the transform job's data files into smaller batches. 
        """
elif False:
    ModelPackageTransformInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelPackageTransformInputArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input['ModelPackageDataSourceArgs'],
                 compression_type: Optional[pulumi.Input['ModelPackageTransformInputCompressionType']] = None,
                 content_type: Optional[pulumi.Input[str]] = None,
                 split_type: Optional[pulumi.Input['ModelPackageTransformInputSplitType']] = None):
        """
        Describes the input source of a transform job and the way the transform job consumes it.
        :param pulumi.Input['ModelPackageDataSourceArgs'] data_source: Describes the location of the channel data, which is, the S3 location of the input data that the model can consume.
        :param pulumi.Input['ModelPackageTransformInputCompressionType'] compression_type: If your transform data is compressed, specify the compression type. Amazon SageMaker automatically decompresses the data for the transform job accordingly. The default value is None.
        :param pulumi.Input[str] content_type: The multipurpose internet mail extension (MIME) type of the data. Amazon SageMaker uses the MIME type with each http call to transfer data to the transform job.
        :param pulumi.Input['ModelPackageTransformInputSplitType'] split_type: The method to use to split the transform job's data files into smaller batches. 
        """
        pulumi.set(__self__, "data_source", data_source)
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if split_type is not None:
            pulumi.set(__self__, "split_type", split_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input['ModelPackageDataSourceArgs']:
        """
        Describes the location of the channel data, which is, the S3 location of the input data that the model can consume.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input['ModelPackageDataSourceArgs']):
        pulumi.set(self, "data_source", value)

    @property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[pulumi.Input['ModelPackageTransformInputCompressionType']]:
        """
        If your transform data is compressed, specify the compression type. Amazon SageMaker automatically decompresses the data for the transform job accordingly. The default value is None.
        """
        return pulumi.get(self, "compression_type")

    @compression_type.setter
    def compression_type(self, value: Optional[pulumi.Input['ModelPackageTransformInputCompressionType']]):
        pulumi.set(self, "compression_type", value)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[str]]:
        """
        The multipurpose internet mail extension (MIME) type of the data. Amazon SageMaker uses the MIME type with each http call to transfer data to the transform job.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_type", value)

    @property
    @pulumi.getter(name="splitType")
    def split_type(self) -> Optional[pulumi.Input['ModelPackageTransformInputSplitType']]:
        """
        The method to use to split the transform job's data files into smaller batches. 
        """
        return pulumi.get(self, "split_type")

    @split_type.setter
    def split_type(self, value: Optional[pulumi.Input['ModelPackageTransformInputSplitType']]):
        pulumi.set(self, "split_type", value)


if not MYPY:
    class ModelPackageTransformJobDefinitionArgsDict(TypedDict):
        """
        Defines the input needed to run a transform job using the inference specification specified in the algorithm.
        """
        transform_input: pulumi.Input['ModelPackageTransformInputArgsDict']
        """
        A description of the input source and the way the transform job consumes it.
        """
        transform_output: pulumi.Input['ModelPackageTransformOutputArgsDict']
        """
        Identifies the Amazon S3 location where you want Amazon SageMaker to save the results from the transform job.
        """
        transform_resources: pulumi.Input['ModelPackageTransformResourcesArgsDict']
        """
        Identifies the ML compute instances for the transform job.
        """
        batch_strategy: NotRequired[pulumi.Input['ModelPackageTransformJobDefinitionBatchStrategy']]
        """
        A string that determines the number of records included in a single mini-batch.
        """
        environment: NotRequired[pulumi.Input['ModelPackageEnvironmentArgsDict']]
        """
        The environment variables to set in the Docker container. We support up to 16 key and values entries in the map.
        """
        max_concurrent_transforms: NotRequired[pulumi.Input[int]]
        """
        The maximum number of parallel requests that can be sent to each instance in a transform job. The default value is 1.
        """
        max_payload_in_mb: NotRequired[pulumi.Input[int]]
        """
        The maximum payload size allowed, in MB. A payload is the data portion of a record (without metadata).
        """
elif False:
    ModelPackageTransformJobDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelPackageTransformJobDefinitionArgs:
    def __init__(__self__, *,
                 transform_input: pulumi.Input['ModelPackageTransformInputArgs'],
                 transform_output: pulumi.Input['ModelPackageTransformOutputArgs'],
                 transform_resources: pulumi.Input['ModelPackageTransformResourcesArgs'],
                 batch_strategy: Optional[pulumi.Input['ModelPackageTransformJobDefinitionBatchStrategy']] = None,
                 environment: Optional[pulumi.Input['ModelPackageEnvironmentArgs']] = None,
                 max_concurrent_transforms: Optional[pulumi.Input[int]] = None,
                 max_payload_in_mb: Optional[pulumi.Input[int]] = None):
        """
        Defines the input needed to run a transform job using the inference specification specified in the algorithm.
        :param pulumi.Input['ModelPackageTransformInputArgs'] transform_input: A description of the input source and the way the transform job consumes it.
        :param pulumi.Input['ModelPackageTransformOutputArgs'] transform_output: Identifies the Amazon S3 location where you want Amazon SageMaker to save the results from the transform job.
        :param pulumi.Input['ModelPackageTransformResourcesArgs'] transform_resources: Identifies the ML compute instances for the transform job.
        :param pulumi.Input['ModelPackageTransformJobDefinitionBatchStrategy'] batch_strategy: A string that determines the number of records included in a single mini-batch.
        :param pulumi.Input['ModelPackageEnvironmentArgs'] environment: The environment variables to set in the Docker container. We support up to 16 key and values entries in the map.
        :param pulumi.Input[int] max_concurrent_transforms: The maximum number of parallel requests that can be sent to each instance in a transform job. The default value is 1.
        :param pulumi.Input[int] max_payload_in_mb: The maximum payload size allowed, in MB. A payload is the data portion of a record (without metadata).
        """
        pulumi.set(__self__, "transform_input", transform_input)
        pulumi.set(__self__, "transform_output", transform_output)
        pulumi.set(__self__, "transform_resources", transform_resources)
        if batch_strategy is not None:
            pulumi.set(__self__, "batch_strategy", batch_strategy)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if max_concurrent_transforms is not None:
            pulumi.set(__self__, "max_concurrent_transforms", max_concurrent_transforms)
        if max_payload_in_mb is not None:
            pulumi.set(__self__, "max_payload_in_mb", max_payload_in_mb)

    @property
    @pulumi.getter(name="transformInput")
    def transform_input(self) -> pulumi.Input['ModelPackageTransformInputArgs']:
        """
        A description of the input source and the way the transform job consumes it.
        """
        return pulumi.get(self, "transform_input")

    @transform_input.setter
    def transform_input(self, value: pulumi.Input['ModelPackageTransformInputArgs']):
        pulumi.set(self, "transform_input", value)

    @property
    @pulumi.getter(name="transformOutput")
    def transform_output(self) -> pulumi.Input['ModelPackageTransformOutputArgs']:
        """
        Identifies the Amazon S3 location where you want Amazon SageMaker to save the results from the transform job.
        """
        return pulumi.get(self, "transform_output")

    @transform_output.setter
    def transform_output(self, value: pulumi.Input['ModelPackageTransformOutputArgs']):
        pulumi.set(self, "transform_output", value)

    @property
    @pulumi.getter(name="transformResources")
    def transform_resources(self) -> pulumi.Input['ModelPackageTransformResourcesArgs']:
        """
        Identifies the ML compute instances for the transform job.
        """
        return pulumi.get(self, "transform_resources")

    @transform_resources.setter
    def transform_resources(self, value: pulumi.Input['ModelPackageTransformResourcesArgs']):
        pulumi.set(self, "transform_resources", value)

    @property
    @pulumi.getter(name="batchStrategy")
    def batch_strategy(self) -> Optional[pulumi.Input['ModelPackageTransformJobDefinitionBatchStrategy']]:
        """
        A string that determines the number of records included in a single mini-batch.
        """
        return pulumi.get(self, "batch_strategy")

    @batch_strategy.setter
    def batch_strategy(self, value: Optional[pulumi.Input['ModelPackageTransformJobDefinitionBatchStrategy']]):
        pulumi.set(self, "batch_strategy", value)

    @property
    @pulumi.getter
    def environment(self) -> Optional[pulumi.Input['ModelPackageEnvironmentArgs']]:
        """
        The environment variables to set in the Docker container. We support up to 16 key and values entries in the map.
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[pulumi.Input['ModelPackageEnvironmentArgs']]):
        pulumi.set(self, "environment", value)

    @property
    @pulumi.getter(name="maxConcurrentTransforms")
    def max_concurrent_transforms(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of parallel requests that can be sent to each instance in a transform job. The default value is 1.
        """
        return pulumi.get(self, "max_concurrent_transforms")

    @max_concurrent_transforms.setter
    def max_concurrent_transforms(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_concurrent_transforms", value)

    @property
    @pulumi.getter(name="maxPayloadInMb")
    def max_payload_in_mb(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum payload size allowed, in MB. A payload is the data portion of a record (without metadata).
        """
        return pulumi.get(self, "max_payload_in_mb")

    @max_payload_in_mb.setter
    def max_payload_in_mb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_payload_in_mb", value)


if not MYPY:
    class ModelPackageTransformOutputArgsDict(TypedDict):
        """
        Describes the results of a transform job.
        """
        s3_output_path: pulumi.Input[str]
        """
        The Amazon S3 path where you want Amazon SageMaker to store the results of the transform job.
        """
        accept: NotRequired[pulumi.Input[str]]
        """
        The MIME type used to specify the output data. Amazon SageMaker uses the MIME type with each http call to transfer data from the transform job.
        """
        assemble_with: NotRequired[pulumi.Input['ModelPackageTransformOutputAssembleWith']]
        """
        Defines how to assemble the results of the transform job as a single S3 object.
        """
        kms_key_id: NotRequired[pulumi.Input[str]]
        """
        The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.
        """
elif False:
    ModelPackageTransformOutputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelPackageTransformOutputArgs:
    def __init__(__self__, *,
                 s3_output_path: pulumi.Input[str],
                 accept: Optional[pulumi.Input[str]] = None,
                 assemble_with: Optional[pulumi.Input['ModelPackageTransformOutputAssembleWith']] = None,
                 kms_key_id: Optional[pulumi.Input[str]] = None):
        """
        Describes the results of a transform job.
        :param pulumi.Input[str] s3_output_path: The Amazon S3 path where you want Amazon SageMaker to store the results of the transform job.
        :param pulumi.Input[str] accept: The MIME type used to specify the output data. Amazon SageMaker uses the MIME type with each http call to transfer data from the transform job.
        :param pulumi.Input['ModelPackageTransformOutputAssembleWith'] assemble_with: Defines how to assemble the results of the transform job as a single S3 object.
        :param pulumi.Input[str] kms_key_id: The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.
        """
        pulumi.set(__self__, "s3_output_path", s3_output_path)
        if accept is not None:
            pulumi.set(__self__, "accept", accept)
        if assemble_with is not None:
            pulumi.set(__self__, "assemble_with", assemble_with)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)

    @property
    @pulumi.getter(name="s3OutputPath")
    def s3_output_path(self) -> pulumi.Input[str]:
        """
        The Amazon S3 path where you want Amazon SageMaker to store the results of the transform job.
        """
        return pulumi.get(self, "s3_output_path")

    @s3_output_path.setter
    def s3_output_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_output_path", value)

    @property
    @pulumi.getter
    def accept(self) -> Optional[pulumi.Input[str]]:
        """
        The MIME type used to specify the output data. Amazon SageMaker uses the MIME type with each http call to transfer data from the transform job.
        """
        return pulumi.get(self, "accept")

    @accept.setter
    def accept(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "accept", value)

    @property
    @pulumi.getter(name="assembleWith")
    def assemble_with(self) -> Optional[pulumi.Input['ModelPackageTransformOutputAssembleWith']]:
        """
        Defines how to assemble the results of the transform job as a single S3 object.
        """
        return pulumi.get(self, "assemble_with")

    @assemble_with.setter
    def assemble_with(self, value: Optional[pulumi.Input['ModelPackageTransformOutputAssembleWith']]):
        pulumi.set(self, "assemble_with", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)


if not MYPY:
    class ModelPackageTransformResourcesArgsDict(TypedDict):
        """
        Describes the resources, including ML instance types and ML instance count, to use for transform job.
        """
        instance_count: pulumi.Input[int]
        """
        The number of ML compute instances to use in the transform job. For distributed transform jobs, specify a value greater than 1. The default value is 1.
        """
        instance_type: pulumi.Input[str]
        """
        The ML compute instance type for the transform job.
        """
        volume_kms_key_id: NotRequired[pulumi.Input[str]]
        """
        The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt model data on the storage volume attached to the ML compute instance(s) that run the batch transform job.
        """
elif False:
    ModelPackageTransformResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelPackageTransformResourcesArgs:
    def __init__(__self__, *,
                 instance_count: pulumi.Input[int],
                 instance_type: pulumi.Input[str],
                 volume_kms_key_id: Optional[pulumi.Input[str]] = None):
        """
        Describes the resources, including ML instance types and ML instance count, to use for transform job.
        :param pulumi.Input[int] instance_count: The number of ML compute instances to use in the transform job. For distributed transform jobs, specify a value greater than 1. The default value is 1.
        :param pulumi.Input[str] instance_type: The ML compute instance type for the transform job.
        :param pulumi.Input[str] volume_kms_key_id: The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt model data on the storage volume attached to the ML compute instance(s) that run the batch transform job.
        """
        pulumi.set(__self__, "instance_count", instance_count)
        pulumi.set(__self__, "instance_type", instance_type)
        if volume_kms_key_id is not None:
            pulumi.set(__self__, "volume_kms_key_id", volume_kms_key_id)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> pulumi.Input[int]:
        """
        The number of ML compute instances to use in the transform job. For distributed transform jobs, specify a value greater than 1. The default value is 1.
        """
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "instance_count", value)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> pulumi.Input[str]:
        """
        The ML compute instance type for the transform job.
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance_type", value)

    @property
    @pulumi.getter(name="volumeKmsKeyId")
    def volume_kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt model data on the storage volume attached to the ML compute instance(s) that run the batch transform job.
        """
        return pulumi.get(self, "volume_kms_key_id")

    @volume_kms_key_id.setter
    def volume_kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_kms_key_id", value)


if not MYPY:
    class ModelPackageValidationProfileArgsDict(TypedDict):
        """
        Contains data, such as the inputs and targeted instance types that are used in the process of validating the model package.
        """
        profile_name: pulumi.Input[str]
        """
        The name of the profile for the model package.
        """
        transform_job_definition: pulumi.Input['ModelPackageTransformJobDefinitionArgsDict']
        """
        The `TransformJobDefinition` object that describes the transform job used for the validation of the model package.
        """
elif False:
    ModelPackageValidationProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelPackageValidationProfileArgs:
    def __init__(__self__, *,
                 profile_name: pulumi.Input[str],
                 transform_job_definition: pulumi.Input['ModelPackageTransformJobDefinitionArgs']):
        """
        Contains data, such as the inputs and targeted instance types that are used in the process of validating the model package.
        :param pulumi.Input[str] profile_name: The name of the profile for the model package.
        :param pulumi.Input['ModelPackageTransformJobDefinitionArgs'] transform_job_definition: The `TransformJobDefinition` object that describes the transform job used for the validation of the model package.
        """
        pulumi.set(__self__, "profile_name", profile_name)
        pulumi.set(__self__, "transform_job_definition", transform_job_definition)

    @property
    @pulumi.getter(name="profileName")
    def profile_name(self) -> pulumi.Input[str]:
        """
        The name of the profile for the model package.
        """
        return pulumi.get(self, "profile_name")

    @profile_name.setter
    def profile_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "profile_name", value)

    @property
    @pulumi.getter(name="transformJobDefinition")
    def transform_job_definition(self) -> pulumi.Input['ModelPackageTransformJobDefinitionArgs']:
        """
        The `TransformJobDefinition` object that describes the transform job used for the validation of the model package.
        """
        return pulumi.get(self, "transform_job_definition")

    @transform_job_definition.setter
    def transform_job_definition(self, value: pulumi.Input['ModelPackageTransformJobDefinitionArgs']):
        pulumi.set(self, "transform_job_definition", value)


if not MYPY:
    class ModelPackageValidationSpecificationArgsDict(TypedDict):
        """
        Specifies configurations for one or more transform jobs that Amazon SageMaker runs to test the model package.
        """
        validation_profiles: pulumi.Input[Sequence[pulumi.Input['ModelPackageValidationProfileArgsDict']]]
        """
        An array of `ModelPackageValidationProfile` objects, each of which specifies a batch transform job that SageMaker runs to validate your model package.
        """
        validation_role: pulumi.Input[str]
        """
        The IAM roles to be used for the validation of the model package.
        """
elif False:
    ModelPackageValidationSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelPackageValidationSpecificationArgs:
    def __init__(__self__, *,
                 validation_profiles: pulumi.Input[Sequence[pulumi.Input['ModelPackageValidationProfileArgs']]],
                 validation_role: pulumi.Input[str]):
        """
        Specifies configurations for one or more transform jobs that Amazon SageMaker runs to test the model package.
        :param pulumi.Input[Sequence[pulumi.Input['ModelPackageValidationProfileArgs']]] validation_profiles: An array of `ModelPackageValidationProfile` objects, each of which specifies a batch transform job that SageMaker runs to validate your model package.
        :param pulumi.Input[str] validation_role: The IAM roles to be used for the validation of the model package.
        """
        pulumi.set(__self__, "validation_profiles", validation_profiles)
        pulumi.set(__self__, "validation_role", validation_role)

    @property
    @pulumi.getter(name="validationProfiles")
    def validation_profiles(self) -> pulumi.Input[Sequence[pulumi.Input['ModelPackageValidationProfileArgs']]]:
        """
        An array of `ModelPackageValidationProfile` objects, each of which specifies a batch transform job that SageMaker runs to validate your model package.
        """
        return pulumi.get(self, "validation_profiles")

    @validation_profiles.setter
    def validation_profiles(self, value: pulumi.Input[Sequence[pulumi.Input['ModelPackageValidationProfileArgs']]]):
        pulumi.set(self, "validation_profiles", value)

    @property
    @pulumi.getter(name="validationRole")
    def validation_role(self) -> pulumi.Input[str]:
        """
        The IAM roles to be used for the validation of the model package.
        """
        return pulumi.get(self, "validation_role")

    @validation_role.setter
    def validation_role(self, value: pulumi.Input[str]):
        pulumi.set(self, "validation_role", value)


if not MYPY:
    class ModelQualityJobDefinitionBatchTransformInputArgsDict(TypedDict):
        """
        The batch transform input for a monitoring job.
        """
        data_captured_destination_s3_uri: pulumi.Input[str]
        """
        A URI that identifies the Amazon S3 storage location where Batch Transform Job captures data.
        """
        dataset_format: pulumi.Input['ModelQualityJobDefinitionDatasetFormatArgsDict']
        """
        The dataset format for your batch transform job.
        """
        local_path: pulumi.Input[str]
        """
        Path to the filesystem where the endpoint data is available to the container.
        """
        end_time_offset: NotRequired[pulumi.Input[str]]
        """
        Monitoring end time offset, e.g. PT0H
        """
        inference_attribute: NotRequired[pulumi.Input[str]]
        """
        Index or JSONpath to locate predicted label(s)
        """
        probability_attribute: NotRequired[pulumi.Input[str]]
        """
        Index or JSONpath to locate probabilities
        """
        probability_threshold_attribute: NotRequired[pulumi.Input[float]]
        """
        The threshold for the class probability to be evaluated as a positive result.
        """
        s3_data_distribution_type: NotRequired[pulumi.Input['ModelQualityJobDefinitionBatchTransformInputS3DataDistributionType']]
        """
        Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
        """
        s3_input_mode: NotRequired[pulumi.Input['ModelQualityJobDefinitionBatchTransformInputS3InputMode']]
        """
        Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
        """
        start_time_offset: NotRequired[pulumi.Input[str]]
        """
        Monitoring start time offset, e.g. -PT1H
        """
elif False:
    ModelQualityJobDefinitionBatchTransformInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelQualityJobDefinitionBatchTransformInputArgs:
    def __init__(__self__, *,
                 data_captured_destination_s3_uri: pulumi.Input[str],
                 dataset_format: pulumi.Input['ModelQualityJobDefinitionDatasetFormatArgs'],
                 local_path: pulumi.Input[str],
                 end_time_offset: Optional[pulumi.Input[str]] = None,
                 inference_attribute: Optional[pulumi.Input[str]] = None,
                 probability_attribute: Optional[pulumi.Input[str]] = None,
                 probability_threshold_attribute: Optional[pulumi.Input[float]] = None,
                 s3_data_distribution_type: Optional[pulumi.Input['ModelQualityJobDefinitionBatchTransformInputS3DataDistributionType']] = None,
                 s3_input_mode: Optional[pulumi.Input['ModelQualityJobDefinitionBatchTransformInputS3InputMode']] = None,
                 start_time_offset: Optional[pulumi.Input[str]] = None):
        """
        The batch transform input for a monitoring job.
        :param pulumi.Input[str] data_captured_destination_s3_uri: A URI that identifies the Amazon S3 storage location where Batch Transform Job captures data.
        :param pulumi.Input['ModelQualityJobDefinitionDatasetFormatArgs'] dataset_format: The dataset format for your batch transform job.
        :param pulumi.Input[str] local_path: Path to the filesystem where the endpoint data is available to the container.
        :param pulumi.Input[str] end_time_offset: Monitoring end time offset, e.g. PT0H
        :param pulumi.Input[str] inference_attribute: Index or JSONpath to locate predicted label(s)
        :param pulumi.Input[str] probability_attribute: Index or JSONpath to locate probabilities
        :param pulumi.Input[float] probability_threshold_attribute: The threshold for the class probability to be evaluated as a positive result.
        :param pulumi.Input['ModelQualityJobDefinitionBatchTransformInputS3DataDistributionType'] s3_data_distribution_type: Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
        :param pulumi.Input['ModelQualityJobDefinitionBatchTransformInputS3InputMode'] s3_input_mode: Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
        :param pulumi.Input[str] start_time_offset: Monitoring start time offset, e.g. -PT1H
        """
        pulumi.set(__self__, "data_captured_destination_s3_uri", data_captured_destination_s3_uri)
        pulumi.set(__self__, "dataset_format", dataset_format)
        pulumi.set(__self__, "local_path", local_path)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if inference_attribute is not None:
            pulumi.set(__self__, "inference_attribute", inference_attribute)
        if probability_attribute is not None:
            pulumi.set(__self__, "probability_attribute", probability_attribute)
        if probability_threshold_attribute is not None:
            pulumi.set(__self__, "probability_threshold_attribute", probability_threshold_attribute)
        if s3_data_distribution_type is not None:
            pulumi.set(__self__, "s3_data_distribution_type", s3_data_distribution_type)
        if s3_input_mode is not None:
            pulumi.set(__self__, "s3_input_mode", s3_input_mode)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)

    @property
    @pulumi.getter(name="dataCapturedDestinationS3Uri")
    def data_captured_destination_s3_uri(self) -> pulumi.Input[str]:
        """
        A URI that identifies the Amazon S3 storage location where Batch Transform Job captures data.
        """
        return pulumi.get(self, "data_captured_destination_s3_uri")

    @data_captured_destination_s3_uri.setter
    def data_captured_destination_s3_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_captured_destination_s3_uri", value)

    @property
    @pulumi.getter(name="datasetFormat")
    def dataset_format(self) -> pulumi.Input['ModelQualityJobDefinitionDatasetFormatArgs']:
        """
        The dataset format for your batch transform job.
        """
        return pulumi.get(self, "dataset_format")

    @dataset_format.setter
    def dataset_format(self, value: pulumi.Input['ModelQualityJobDefinitionDatasetFormatArgs']):
        pulumi.set(self, "dataset_format", value)

    @property
    @pulumi.getter(name="localPath")
    def local_path(self) -> pulumi.Input[str]:
        """
        Path to the filesystem where the endpoint data is available to the container.
        """
        return pulumi.get(self, "local_path")

    @local_path.setter
    def local_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "local_path", value)

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[pulumi.Input[str]]:
        """
        Monitoring end time offset, e.g. PT0H
        """
        return pulumi.get(self, "end_time_offset")

    @end_time_offset.setter
    def end_time_offset(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_time_offset", value)

    @property
    @pulumi.getter(name="inferenceAttribute")
    def inference_attribute(self) -> Optional[pulumi.Input[str]]:
        """
        Index or JSONpath to locate predicted label(s)
        """
        return pulumi.get(self, "inference_attribute")

    @inference_attribute.setter
    def inference_attribute(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "inference_attribute", value)

    @property
    @pulumi.getter(name="probabilityAttribute")
    def probability_attribute(self) -> Optional[pulumi.Input[str]]:
        """
        Index or JSONpath to locate probabilities
        """
        return pulumi.get(self, "probability_attribute")

    @probability_attribute.setter
    def probability_attribute(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "probability_attribute", value)

    @property
    @pulumi.getter(name="probabilityThresholdAttribute")
    def probability_threshold_attribute(self) -> Optional[pulumi.Input[float]]:
        """
        The threshold for the class probability to be evaluated as a positive result.
        """
        return pulumi.get(self, "probability_threshold_attribute")

    @probability_threshold_attribute.setter
    def probability_threshold_attribute(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "probability_threshold_attribute", value)

    @property
    @pulumi.getter(name="s3DataDistributionType")
    def s3_data_distribution_type(self) -> Optional[pulumi.Input['ModelQualityJobDefinitionBatchTransformInputS3DataDistributionType']]:
        """
        Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
        """
        return pulumi.get(self, "s3_data_distribution_type")

    @s3_data_distribution_type.setter
    def s3_data_distribution_type(self, value: Optional[pulumi.Input['ModelQualityJobDefinitionBatchTransformInputS3DataDistributionType']]):
        pulumi.set(self, "s3_data_distribution_type", value)

    @property
    @pulumi.getter(name="s3InputMode")
    def s3_input_mode(self) -> Optional[pulumi.Input['ModelQualityJobDefinitionBatchTransformInputS3InputMode']]:
        """
        Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
        """
        return pulumi.get(self, "s3_input_mode")

    @s3_input_mode.setter
    def s3_input_mode(self, value: Optional[pulumi.Input['ModelQualityJobDefinitionBatchTransformInputS3InputMode']]):
        pulumi.set(self, "s3_input_mode", value)

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[pulumi.Input[str]]:
        """
        Monitoring start time offset, e.g. -PT1H
        """
        return pulumi.get(self, "start_time_offset")

    @start_time_offset.setter
    def start_time_offset(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time_offset", value)


if not MYPY:
    class ModelQualityJobDefinitionClusterConfigArgsDict(TypedDict):
        """
        Configuration for the cluster used to run model monitoring jobs.
        """
        instance_count: pulumi.Input[int]
        """
        The number of ML compute instances to use in the model monitoring job. For distributed processing jobs, specify a value greater than 1. The default value is 1.
        """
        instance_type: pulumi.Input[str]
        """
        The ML compute instance type for the processing job.
        """
        volume_size_in_gb: pulumi.Input[int]
        """
        The size of the ML storage volume, in gigabytes, that you want to provision. You must specify sufficient ML storage for your scenario.
        """
        volume_kms_key_id: NotRequired[pulumi.Input[str]]
        """
        The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the model monitoring job.
        """
elif False:
    ModelQualityJobDefinitionClusterConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelQualityJobDefinitionClusterConfigArgs:
    def __init__(__self__, *,
                 instance_count: pulumi.Input[int],
                 instance_type: pulumi.Input[str],
                 volume_size_in_gb: pulumi.Input[int],
                 volume_kms_key_id: Optional[pulumi.Input[str]] = None):
        """
        Configuration for the cluster used to run model monitoring jobs.
        :param pulumi.Input[int] instance_count: The number of ML compute instances to use in the model monitoring job. For distributed processing jobs, specify a value greater than 1. The default value is 1.
        :param pulumi.Input[str] instance_type: The ML compute instance type for the processing job.
        :param pulumi.Input[int] volume_size_in_gb: The size of the ML storage volume, in gigabytes, that you want to provision. You must specify sufficient ML storage for your scenario.
        :param pulumi.Input[str] volume_kms_key_id: The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the model monitoring job.
        """
        pulumi.set(__self__, "instance_count", instance_count)
        pulumi.set(__self__, "instance_type", instance_type)
        pulumi.set(__self__, "volume_size_in_gb", volume_size_in_gb)
        if volume_kms_key_id is not None:
            pulumi.set(__self__, "volume_kms_key_id", volume_kms_key_id)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> pulumi.Input[int]:
        """
        The number of ML compute instances to use in the model monitoring job. For distributed processing jobs, specify a value greater than 1. The default value is 1.
        """
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "instance_count", value)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> pulumi.Input[str]:
        """
        The ML compute instance type for the processing job.
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance_type", value)

    @property
    @pulumi.getter(name="volumeSizeInGb")
    def volume_size_in_gb(self) -> pulumi.Input[int]:
        """
        The size of the ML storage volume, in gigabytes, that you want to provision. You must specify sufficient ML storage for your scenario.
        """
        return pulumi.get(self, "volume_size_in_gb")

    @volume_size_in_gb.setter
    def volume_size_in_gb(self, value: pulumi.Input[int]):
        pulumi.set(self, "volume_size_in_gb", value)

    @property
    @pulumi.getter(name="volumeKmsKeyId")
    def volume_kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the model monitoring job.
        """
        return pulumi.get(self, "volume_kms_key_id")

    @volume_kms_key_id.setter
    def volume_kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_kms_key_id", value)


if not MYPY:
    class ModelQualityJobDefinitionConstraintsResourceArgsDict(TypedDict):
        """
        The baseline constraints resource for a monitoring job.
        """
        s3_uri: NotRequired[pulumi.Input[str]]
        """
        The Amazon S3 URI for baseline constraint file in Amazon S3 that the current monitoring job should validated against.
        """
elif False:
    ModelQualityJobDefinitionConstraintsResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelQualityJobDefinitionConstraintsResourceArgs:
    def __init__(__self__, *,
                 s3_uri: Optional[pulumi.Input[str]] = None):
        """
        The baseline constraints resource for a monitoring job.
        :param pulumi.Input[str] s3_uri: The Amazon S3 URI for baseline constraint file in Amazon S3 that the current monitoring job should validated against.
        """
        if s3_uri is not None:
            pulumi.set(__self__, "s3_uri", s3_uri)

    @property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon S3 URI for baseline constraint file in Amazon S3 that the current monitoring job should validated against.
        """
        return pulumi.get(self, "s3_uri")

    @s3_uri.setter
    def s3_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_uri", value)


if not MYPY:
    class ModelQualityJobDefinitionCsvArgsDict(TypedDict):
        """
        The CSV format
        """
        header: NotRequired[pulumi.Input[bool]]
        """
        A boolean flag indicating if given CSV has header
        """
elif False:
    ModelQualityJobDefinitionCsvArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelQualityJobDefinitionCsvArgs:
    def __init__(__self__, *,
                 header: Optional[pulumi.Input[bool]] = None):
        """
        The CSV format
        :param pulumi.Input[bool] header: A boolean flag indicating if given CSV has header
        """
        if header is not None:
            pulumi.set(__self__, "header", header)

    @property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean flag indicating if given CSV has header
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "header", value)


if not MYPY:
    class ModelQualityJobDefinitionDatasetFormatArgsDict(TypedDict):
        """
        The dataset format of the data to monitor
        """
        csv: NotRequired[pulumi.Input['ModelQualityJobDefinitionCsvArgsDict']]
        json: NotRequired[pulumi.Input['ModelQualityJobDefinitionJsonArgsDict']]
        parquet: NotRequired[pulumi.Input[bool]]
elif False:
    ModelQualityJobDefinitionDatasetFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelQualityJobDefinitionDatasetFormatArgs:
    def __init__(__self__, *,
                 csv: Optional[pulumi.Input['ModelQualityJobDefinitionCsvArgs']] = None,
                 json: Optional[pulumi.Input['ModelQualityJobDefinitionJsonArgs']] = None,
                 parquet: Optional[pulumi.Input[bool]] = None):
        """
        The dataset format of the data to monitor
        """
        if csv is not None:
            pulumi.set(__self__, "csv", csv)
        if json is not None:
            pulumi.set(__self__, "json", json)
        if parquet is not None:
            pulumi.set(__self__, "parquet", parquet)

    @property
    @pulumi.getter
    def csv(self) -> Optional[pulumi.Input['ModelQualityJobDefinitionCsvArgs']]:
        return pulumi.get(self, "csv")

    @csv.setter
    def csv(self, value: Optional[pulumi.Input['ModelQualityJobDefinitionCsvArgs']]):
        pulumi.set(self, "csv", value)

    @property
    @pulumi.getter
    def json(self) -> Optional[pulumi.Input['ModelQualityJobDefinitionJsonArgs']]:
        return pulumi.get(self, "json")

    @json.setter
    def json(self, value: Optional[pulumi.Input['ModelQualityJobDefinitionJsonArgs']]):
        pulumi.set(self, "json", value)

    @property
    @pulumi.getter
    def parquet(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "parquet")

    @parquet.setter
    def parquet(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "parquet", value)


if not MYPY:
    class ModelQualityJobDefinitionEndpointInputArgsDict(TypedDict):
        """
        The endpoint for a monitoring job.
        """
        endpoint_name: pulumi.Input[str]
        """
        An endpoint in customer's account which has enabled `DataCaptureConfig` enabled.
        """
        local_path: pulumi.Input[str]
        """
        Path to the filesystem where the endpoint data is available to the container.
        """
        end_time_offset: NotRequired[pulumi.Input[str]]
        """
        Monitoring end time offset, e.g. PT0H
        """
        inference_attribute: NotRequired[pulumi.Input[str]]
        """
        Index or JSONpath to locate predicted label(s)
        """
        probability_attribute: NotRequired[pulumi.Input[str]]
        """
        Index or JSONpath to locate probabilities
        """
        probability_threshold_attribute: NotRequired[pulumi.Input[float]]
        """
        The threshold for the class probability to be evaluated as a positive result.
        """
        s3_data_distribution_type: NotRequired[pulumi.Input['ModelQualityJobDefinitionEndpointInputS3DataDistributionType']]
        """
        Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
        """
        s3_input_mode: NotRequired[pulumi.Input['ModelQualityJobDefinitionEndpointInputS3InputMode']]
        """
        Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
        """
        start_time_offset: NotRequired[pulumi.Input[str]]
        """
        Monitoring start time offset, e.g. -PT1H
        """
elif False:
    ModelQualityJobDefinitionEndpointInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelQualityJobDefinitionEndpointInputArgs:
    def __init__(__self__, *,
                 endpoint_name: pulumi.Input[str],
                 local_path: pulumi.Input[str],
                 end_time_offset: Optional[pulumi.Input[str]] = None,
                 inference_attribute: Optional[pulumi.Input[str]] = None,
                 probability_attribute: Optional[pulumi.Input[str]] = None,
                 probability_threshold_attribute: Optional[pulumi.Input[float]] = None,
                 s3_data_distribution_type: Optional[pulumi.Input['ModelQualityJobDefinitionEndpointInputS3DataDistributionType']] = None,
                 s3_input_mode: Optional[pulumi.Input['ModelQualityJobDefinitionEndpointInputS3InputMode']] = None,
                 start_time_offset: Optional[pulumi.Input[str]] = None):
        """
        The endpoint for a monitoring job.
        :param pulumi.Input[str] endpoint_name: An endpoint in customer's account which has enabled `DataCaptureConfig` enabled.
        :param pulumi.Input[str] local_path: Path to the filesystem where the endpoint data is available to the container.
        :param pulumi.Input[str] end_time_offset: Monitoring end time offset, e.g. PT0H
        :param pulumi.Input[str] inference_attribute: Index or JSONpath to locate predicted label(s)
        :param pulumi.Input[str] probability_attribute: Index or JSONpath to locate probabilities
        :param pulumi.Input[float] probability_threshold_attribute: The threshold for the class probability to be evaluated as a positive result.
        :param pulumi.Input['ModelQualityJobDefinitionEndpointInputS3DataDistributionType'] s3_data_distribution_type: Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
        :param pulumi.Input['ModelQualityJobDefinitionEndpointInputS3InputMode'] s3_input_mode: Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
        :param pulumi.Input[str] start_time_offset: Monitoring start time offset, e.g. -PT1H
        """
        pulumi.set(__self__, "endpoint_name", endpoint_name)
        pulumi.set(__self__, "local_path", local_path)
        if end_time_offset is not None:
            pulumi.set(__self__, "end_time_offset", end_time_offset)
        if inference_attribute is not None:
            pulumi.set(__self__, "inference_attribute", inference_attribute)
        if probability_attribute is not None:
            pulumi.set(__self__, "probability_attribute", probability_attribute)
        if probability_threshold_attribute is not None:
            pulumi.set(__self__, "probability_threshold_attribute", probability_threshold_attribute)
        if s3_data_distribution_type is not None:
            pulumi.set(__self__, "s3_data_distribution_type", s3_data_distribution_type)
        if s3_input_mode is not None:
            pulumi.set(__self__, "s3_input_mode", s3_input_mode)
        if start_time_offset is not None:
            pulumi.set(__self__, "start_time_offset", start_time_offset)

    @property
    @pulumi.getter(name="endpointName")
    def endpoint_name(self) -> pulumi.Input[str]:
        """
        An endpoint in customer's account which has enabled `DataCaptureConfig` enabled.
        """
        return pulumi.get(self, "endpoint_name")

    @endpoint_name.setter
    def endpoint_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint_name", value)

    @property
    @pulumi.getter(name="localPath")
    def local_path(self) -> pulumi.Input[str]:
        """
        Path to the filesystem where the endpoint data is available to the container.
        """
        return pulumi.get(self, "local_path")

    @local_path.setter
    def local_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "local_path", value)

    @property
    @pulumi.getter(name="endTimeOffset")
    def end_time_offset(self) -> Optional[pulumi.Input[str]]:
        """
        Monitoring end time offset, e.g. PT0H
        """
        return pulumi.get(self, "end_time_offset")

    @end_time_offset.setter
    def end_time_offset(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_time_offset", value)

    @property
    @pulumi.getter(name="inferenceAttribute")
    def inference_attribute(self) -> Optional[pulumi.Input[str]]:
        """
        Index or JSONpath to locate predicted label(s)
        """
        return pulumi.get(self, "inference_attribute")

    @inference_attribute.setter
    def inference_attribute(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "inference_attribute", value)

    @property
    @pulumi.getter(name="probabilityAttribute")
    def probability_attribute(self) -> Optional[pulumi.Input[str]]:
        """
        Index or JSONpath to locate probabilities
        """
        return pulumi.get(self, "probability_attribute")

    @probability_attribute.setter
    def probability_attribute(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "probability_attribute", value)

    @property
    @pulumi.getter(name="probabilityThresholdAttribute")
    def probability_threshold_attribute(self) -> Optional[pulumi.Input[float]]:
        """
        The threshold for the class probability to be evaluated as a positive result.
        """
        return pulumi.get(self, "probability_threshold_attribute")

    @probability_threshold_attribute.setter
    def probability_threshold_attribute(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "probability_threshold_attribute", value)

    @property
    @pulumi.getter(name="s3DataDistributionType")
    def s3_data_distribution_type(self) -> Optional[pulumi.Input['ModelQualityJobDefinitionEndpointInputS3DataDistributionType']]:
        """
        Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
        """
        return pulumi.get(self, "s3_data_distribution_type")

    @s3_data_distribution_type.setter
    def s3_data_distribution_type(self, value: Optional[pulumi.Input['ModelQualityJobDefinitionEndpointInputS3DataDistributionType']]):
        pulumi.set(self, "s3_data_distribution_type", value)

    @property
    @pulumi.getter(name="s3InputMode")
    def s3_input_mode(self) -> Optional[pulumi.Input['ModelQualityJobDefinitionEndpointInputS3InputMode']]:
        """
        Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
        """
        return pulumi.get(self, "s3_input_mode")

    @s3_input_mode.setter
    def s3_input_mode(self, value: Optional[pulumi.Input['ModelQualityJobDefinitionEndpointInputS3InputMode']]):
        pulumi.set(self, "s3_input_mode", value)

    @property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[pulumi.Input[str]]:
        """
        Monitoring start time offset, e.g. -PT1H
        """
        return pulumi.get(self, "start_time_offset")

    @start_time_offset.setter
    def start_time_offset(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time_offset", value)


if not MYPY:
    class ModelQualityJobDefinitionJsonArgsDict(TypedDict):
        """
        The Json format
        """
        line: NotRequired[pulumi.Input[bool]]
        """
        A boolean flag indicating if it is JSON line format
        """
elif False:
    ModelQualityJobDefinitionJsonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelQualityJobDefinitionJsonArgs:
    def __init__(__self__, *,
                 line: Optional[pulumi.Input[bool]] = None):
        """
        The Json format
        :param pulumi.Input[bool] line: A boolean flag indicating if it is JSON line format
        """
        if line is not None:
            pulumi.set(__self__, "line", line)

    @property
    @pulumi.getter
    def line(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean flag indicating if it is JSON line format
        """
        return pulumi.get(self, "line")

    @line.setter
    def line(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "line", value)


if not MYPY:
    class ModelQualityJobDefinitionModelQualityAppSpecificationArgsDict(TypedDict):
        """
        Container image configuration object for the monitoring job.
        """
        image_uri: pulumi.Input[str]
        """
        The container image to be run by the monitoring job.
        """
        problem_type: pulumi.Input['ModelQualityJobDefinitionProblemType']
        """
        The machine learning problem type of the model that the monitoring job monitors.
        """
        container_arguments: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of arguments for the container used to run the monitoring job.
        """
        container_entrypoint: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies the entrypoint for a container used to run the monitoring job.
        """
        environment: NotRequired[Any]
        """
        Sets the environment variables in the Docker container
        """
        post_analytics_processor_source_uri: NotRequired[pulumi.Input[str]]
        """
        An Amazon S3 URI to a script that is called after analysis has been performed. Applicable only for the built-in (first party) containers.
        """
        record_preprocessor_source_uri: NotRequired[pulumi.Input[str]]
        """
        An Amazon S3 URI to a script that is called per row prior to running analysis. It can base64 decode the payload and convert it into a flatted json so that the built-in container can use the converted data. Applicable only for the built-in (first party) containers
        """
elif False:
    ModelQualityJobDefinitionModelQualityAppSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelQualityJobDefinitionModelQualityAppSpecificationArgs:
    def __init__(__self__, *,
                 image_uri: pulumi.Input[str],
                 problem_type: pulumi.Input['ModelQualityJobDefinitionProblemType'],
                 container_arguments: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 container_entrypoint: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 environment: Optional[Any] = None,
                 post_analytics_processor_source_uri: Optional[pulumi.Input[str]] = None,
                 record_preprocessor_source_uri: Optional[pulumi.Input[str]] = None):
        """
        Container image configuration object for the monitoring job.
        :param pulumi.Input[str] image_uri: The container image to be run by the monitoring job.
        :param pulumi.Input['ModelQualityJobDefinitionProblemType'] problem_type: The machine learning problem type of the model that the monitoring job monitors.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] container_arguments: An array of arguments for the container used to run the monitoring job.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] container_entrypoint: Specifies the entrypoint for a container used to run the monitoring job.
        :param Any environment: Sets the environment variables in the Docker container
        :param pulumi.Input[str] post_analytics_processor_source_uri: An Amazon S3 URI to a script that is called after analysis has been performed. Applicable only for the built-in (first party) containers.
        :param pulumi.Input[str] record_preprocessor_source_uri: An Amazon S3 URI to a script that is called per row prior to running analysis. It can base64 decode the payload and convert it into a flatted json so that the built-in container can use the converted data. Applicable only for the built-in (first party) containers
        """
        pulumi.set(__self__, "image_uri", image_uri)
        pulumi.set(__self__, "problem_type", problem_type)
        if container_arguments is not None:
            pulumi.set(__self__, "container_arguments", container_arguments)
        if container_entrypoint is not None:
            pulumi.set(__self__, "container_entrypoint", container_entrypoint)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if post_analytics_processor_source_uri is not None:
            pulumi.set(__self__, "post_analytics_processor_source_uri", post_analytics_processor_source_uri)
        if record_preprocessor_source_uri is not None:
            pulumi.set(__self__, "record_preprocessor_source_uri", record_preprocessor_source_uri)

    @property
    @pulumi.getter(name="imageUri")
    def image_uri(self) -> pulumi.Input[str]:
        """
        The container image to be run by the monitoring job.
        """
        return pulumi.get(self, "image_uri")

    @image_uri.setter
    def image_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "image_uri", value)

    @property
    @pulumi.getter(name="problemType")
    def problem_type(self) -> pulumi.Input['ModelQualityJobDefinitionProblemType']:
        """
        The machine learning problem type of the model that the monitoring job monitors.
        """
        return pulumi.get(self, "problem_type")

    @problem_type.setter
    def problem_type(self, value: pulumi.Input['ModelQualityJobDefinitionProblemType']):
        pulumi.set(self, "problem_type", value)

    @property
    @pulumi.getter(name="containerArguments")
    def container_arguments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of arguments for the container used to run the monitoring job.
        """
        return pulumi.get(self, "container_arguments")

    @container_arguments.setter
    def container_arguments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "container_arguments", value)

    @property
    @pulumi.getter(name="containerEntrypoint")
    def container_entrypoint(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies the entrypoint for a container used to run the monitoring job.
        """
        return pulumi.get(self, "container_entrypoint")

    @container_entrypoint.setter
    def container_entrypoint(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "container_entrypoint", value)

    @property
    @pulumi.getter
    def environment(self) -> Optional[Any]:
        """
        Sets the environment variables in the Docker container
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[Any]):
        pulumi.set(self, "environment", value)

    @property
    @pulumi.getter(name="postAnalyticsProcessorSourceUri")
    def post_analytics_processor_source_uri(self) -> Optional[pulumi.Input[str]]:
        """
        An Amazon S3 URI to a script that is called after analysis has been performed. Applicable only for the built-in (first party) containers.
        """
        return pulumi.get(self, "post_analytics_processor_source_uri")

    @post_analytics_processor_source_uri.setter
    def post_analytics_processor_source_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "post_analytics_processor_source_uri", value)

    @property
    @pulumi.getter(name="recordPreprocessorSourceUri")
    def record_preprocessor_source_uri(self) -> Optional[pulumi.Input[str]]:
        """
        An Amazon S3 URI to a script that is called per row prior to running analysis. It can base64 decode the payload and convert it into a flatted json so that the built-in container can use the converted data. Applicable only for the built-in (first party) containers
        """
        return pulumi.get(self, "record_preprocessor_source_uri")

    @record_preprocessor_source_uri.setter
    def record_preprocessor_source_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "record_preprocessor_source_uri", value)


if not MYPY:
    class ModelQualityJobDefinitionModelQualityBaselineConfigArgsDict(TypedDict):
        """
        Baseline configuration used to validate that the data conforms to the specified constraints and statistics.
        """
        baselining_job_name: NotRequired[pulumi.Input[str]]
        """
        The name of the job that performs baselining for the monitoring job.
        """
        constraints_resource: NotRequired[pulumi.Input['ModelQualityJobDefinitionConstraintsResourceArgsDict']]
        """
        The constraints resource for a monitoring job.
        """
elif False:
    ModelQualityJobDefinitionModelQualityBaselineConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelQualityJobDefinitionModelQualityBaselineConfigArgs:
    def __init__(__self__, *,
                 baselining_job_name: Optional[pulumi.Input[str]] = None,
                 constraints_resource: Optional[pulumi.Input['ModelQualityJobDefinitionConstraintsResourceArgs']] = None):
        """
        Baseline configuration used to validate that the data conforms to the specified constraints and statistics.
        :param pulumi.Input[str] baselining_job_name: The name of the job that performs baselining for the monitoring job.
        :param pulumi.Input['ModelQualityJobDefinitionConstraintsResourceArgs'] constraints_resource: The constraints resource for a monitoring job.
        """
        if baselining_job_name is not None:
            pulumi.set(__self__, "baselining_job_name", baselining_job_name)
        if constraints_resource is not None:
            pulumi.set(__self__, "constraints_resource", constraints_resource)

    @property
    @pulumi.getter(name="baseliningJobName")
    def baselining_job_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the job that performs baselining for the monitoring job.
        """
        return pulumi.get(self, "baselining_job_name")

    @baselining_job_name.setter
    def baselining_job_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "baselining_job_name", value)

    @property
    @pulumi.getter(name="constraintsResource")
    def constraints_resource(self) -> Optional[pulumi.Input['ModelQualityJobDefinitionConstraintsResourceArgs']]:
        """
        The constraints resource for a monitoring job.
        """
        return pulumi.get(self, "constraints_resource")

    @constraints_resource.setter
    def constraints_resource(self, value: Optional[pulumi.Input['ModelQualityJobDefinitionConstraintsResourceArgs']]):
        pulumi.set(self, "constraints_resource", value)


if not MYPY:
    class ModelQualityJobDefinitionModelQualityJobInputArgsDict(TypedDict):
        """
        The inputs for a monitoring job.
        """
        ground_truth_s3_input: pulumi.Input['ModelQualityJobDefinitionMonitoringGroundTruthS3InputArgsDict']
        """
        The ground truth label provided for the model.
        """
        batch_transform_input: NotRequired[pulumi.Input['ModelQualityJobDefinitionBatchTransformInputArgsDict']]
        """
        Input object for the batch transform job.
        """
        endpoint_input: NotRequired[pulumi.Input['ModelQualityJobDefinitionEndpointInputArgsDict']]
        """
        Input object for the endpoint
        """
elif False:
    ModelQualityJobDefinitionModelQualityJobInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelQualityJobDefinitionModelQualityJobInputArgs:
    def __init__(__self__, *,
                 ground_truth_s3_input: pulumi.Input['ModelQualityJobDefinitionMonitoringGroundTruthS3InputArgs'],
                 batch_transform_input: Optional[pulumi.Input['ModelQualityJobDefinitionBatchTransformInputArgs']] = None,
                 endpoint_input: Optional[pulumi.Input['ModelQualityJobDefinitionEndpointInputArgs']] = None):
        """
        The inputs for a monitoring job.
        :param pulumi.Input['ModelQualityJobDefinitionMonitoringGroundTruthS3InputArgs'] ground_truth_s3_input: The ground truth label provided for the model.
        :param pulumi.Input['ModelQualityJobDefinitionBatchTransformInputArgs'] batch_transform_input: Input object for the batch transform job.
        :param pulumi.Input['ModelQualityJobDefinitionEndpointInputArgs'] endpoint_input: Input object for the endpoint
        """
        pulumi.set(__self__, "ground_truth_s3_input", ground_truth_s3_input)
        if batch_transform_input is not None:
            pulumi.set(__self__, "batch_transform_input", batch_transform_input)
        if endpoint_input is not None:
            pulumi.set(__self__, "endpoint_input", endpoint_input)

    @property
    @pulumi.getter(name="groundTruthS3Input")
    def ground_truth_s3_input(self) -> pulumi.Input['ModelQualityJobDefinitionMonitoringGroundTruthS3InputArgs']:
        """
        The ground truth label provided for the model.
        """
        return pulumi.get(self, "ground_truth_s3_input")

    @ground_truth_s3_input.setter
    def ground_truth_s3_input(self, value: pulumi.Input['ModelQualityJobDefinitionMonitoringGroundTruthS3InputArgs']):
        pulumi.set(self, "ground_truth_s3_input", value)

    @property
    @pulumi.getter(name="batchTransformInput")
    def batch_transform_input(self) -> Optional[pulumi.Input['ModelQualityJobDefinitionBatchTransformInputArgs']]:
        """
        Input object for the batch transform job.
        """
        return pulumi.get(self, "batch_transform_input")

    @batch_transform_input.setter
    def batch_transform_input(self, value: Optional[pulumi.Input['ModelQualityJobDefinitionBatchTransformInputArgs']]):
        pulumi.set(self, "batch_transform_input", value)

    @property
    @pulumi.getter(name="endpointInput")
    def endpoint_input(self) -> Optional[pulumi.Input['ModelQualityJobDefinitionEndpointInputArgs']]:
        """
        Input object for the endpoint
        """
        return pulumi.get(self, "endpoint_input")

    @endpoint_input.setter
    def endpoint_input(self, value: Optional[pulumi.Input['ModelQualityJobDefinitionEndpointInputArgs']]):
        pulumi.set(self, "endpoint_input", value)


if not MYPY:
    class ModelQualityJobDefinitionMonitoringGroundTruthS3InputArgsDict(TypedDict):
        """
        Ground truth input provided in S3 
        """
        s3_uri: pulumi.Input[str]
        """
        A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
        """
elif False:
    ModelQualityJobDefinitionMonitoringGroundTruthS3InputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelQualityJobDefinitionMonitoringGroundTruthS3InputArgs:
    def __init__(__self__, *,
                 s3_uri: pulumi.Input[str]):
        """
        Ground truth input provided in S3 
        :param pulumi.Input[str] s3_uri: A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
        """
        pulumi.set(__self__, "s3_uri", s3_uri)

    @property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> pulumi.Input[str]:
        """
        A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
        """
        return pulumi.get(self, "s3_uri")

    @s3_uri.setter
    def s3_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_uri", value)


if not MYPY:
    class ModelQualityJobDefinitionMonitoringOutputConfigArgsDict(TypedDict):
        """
        The output configuration for monitoring jobs.
        """
        monitoring_outputs: pulumi.Input[Sequence[pulumi.Input['ModelQualityJobDefinitionMonitoringOutputArgsDict']]]
        """
        Monitoring outputs for monitoring jobs. This is where the output of the periodic monitoring jobs is uploaded.
        """
        kms_key_id: NotRequired[pulumi.Input[str]]
        """
        The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.
        """
elif False:
    ModelQualityJobDefinitionMonitoringOutputConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelQualityJobDefinitionMonitoringOutputConfigArgs:
    def __init__(__self__, *,
                 monitoring_outputs: pulumi.Input[Sequence[pulumi.Input['ModelQualityJobDefinitionMonitoringOutputArgs']]],
                 kms_key_id: Optional[pulumi.Input[str]] = None):
        """
        The output configuration for monitoring jobs.
        :param pulumi.Input[Sequence[pulumi.Input['ModelQualityJobDefinitionMonitoringOutputArgs']]] monitoring_outputs: Monitoring outputs for monitoring jobs. This is where the output of the periodic monitoring jobs is uploaded.
        :param pulumi.Input[str] kms_key_id: The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.
        """
        pulumi.set(__self__, "monitoring_outputs", monitoring_outputs)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)

    @property
    @pulumi.getter(name="monitoringOutputs")
    def monitoring_outputs(self) -> pulumi.Input[Sequence[pulumi.Input['ModelQualityJobDefinitionMonitoringOutputArgs']]]:
        """
        Monitoring outputs for monitoring jobs. This is where the output of the periodic monitoring jobs is uploaded.
        """
        return pulumi.get(self, "monitoring_outputs")

    @monitoring_outputs.setter
    def monitoring_outputs(self, value: pulumi.Input[Sequence[pulumi.Input['ModelQualityJobDefinitionMonitoringOutputArgs']]]):
        pulumi.set(self, "monitoring_outputs", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)


if not MYPY:
    class ModelQualityJobDefinitionMonitoringOutputArgsDict(TypedDict):
        """
        The output object for a monitoring job.
        """
        s3_output: pulumi.Input['ModelQualityJobDefinitionS3OutputArgsDict']
        """
        The Amazon S3 storage location where the results of a monitoring job are saved.
        """
elif False:
    ModelQualityJobDefinitionMonitoringOutputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelQualityJobDefinitionMonitoringOutputArgs:
    def __init__(__self__, *,
                 s3_output: pulumi.Input['ModelQualityJobDefinitionS3OutputArgs']):
        """
        The output object for a monitoring job.
        :param pulumi.Input['ModelQualityJobDefinitionS3OutputArgs'] s3_output: The Amazon S3 storage location where the results of a monitoring job are saved.
        """
        pulumi.set(__self__, "s3_output", s3_output)

    @property
    @pulumi.getter(name="s3Output")
    def s3_output(self) -> pulumi.Input['ModelQualityJobDefinitionS3OutputArgs']:
        """
        The Amazon S3 storage location where the results of a monitoring job are saved.
        """
        return pulumi.get(self, "s3_output")

    @s3_output.setter
    def s3_output(self, value: pulumi.Input['ModelQualityJobDefinitionS3OutputArgs']):
        pulumi.set(self, "s3_output", value)


if not MYPY:
    class ModelQualityJobDefinitionMonitoringResourcesArgsDict(TypedDict):
        """
        Identifies the resources to deploy for a monitoring job.
        """
        cluster_config: pulumi.Input['ModelQualityJobDefinitionClusterConfigArgsDict']
        """
        The configuration for the cluster resources used to run the processing job.
        """
elif False:
    ModelQualityJobDefinitionMonitoringResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelQualityJobDefinitionMonitoringResourcesArgs:
    def __init__(__self__, *,
                 cluster_config: pulumi.Input['ModelQualityJobDefinitionClusterConfigArgs']):
        """
        Identifies the resources to deploy for a monitoring job.
        :param pulumi.Input['ModelQualityJobDefinitionClusterConfigArgs'] cluster_config: The configuration for the cluster resources used to run the processing job.
        """
        pulumi.set(__self__, "cluster_config", cluster_config)

    @property
    @pulumi.getter(name="clusterConfig")
    def cluster_config(self) -> pulumi.Input['ModelQualityJobDefinitionClusterConfigArgs']:
        """
        The configuration for the cluster resources used to run the processing job.
        """
        return pulumi.get(self, "cluster_config")

    @cluster_config.setter
    def cluster_config(self, value: pulumi.Input['ModelQualityJobDefinitionClusterConfigArgs']):
        pulumi.set(self, "cluster_config", value)


if not MYPY:
    class ModelQualityJobDefinitionNetworkConfigArgsDict(TypedDict):
        """
        Networking options for a job, such as network traffic encryption between containers, whether to allow inbound and outbound network calls to and from containers, and the VPC subnets and security groups to use for VPC-enabled jobs.
        """
        enable_inter_container_traffic_encryption: NotRequired[pulumi.Input[bool]]
        """
        Whether to encrypt all communications between distributed processing jobs. Choose True to encrypt communications. Encryption provides greater security for distributed processing jobs, but the processing might take longer.
        """
        enable_network_isolation: NotRequired[pulumi.Input[bool]]
        """
        Whether to allow inbound and outbound network calls to and from the containers used for the processing job.
        """
        vpc_config: NotRequired[pulumi.Input['ModelQualityJobDefinitionVpcConfigArgsDict']]
        """
        Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC.
        """
elif False:
    ModelQualityJobDefinitionNetworkConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelQualityJobDefinitionNetworkConfigArgs:
    def __init__(__self__, *,
                 enable_inter_container_traffic_encryption: Optional[pulumi.Input[bool]] = None,
                 enable_network_isolation: Optional[pulumi.Input[bool]] = None,
                 vpc_config: Optional[pulumi.Input['ModelQualityJobDefinitionVpcConfigArgs']] = None):
        """
        Networking options for a job, such as network traffic encryption between containers, whether to allow inbound and outbound network calls to and from containers, and the VPC subnets and security groups to use for VPC-enabled jobs.
        :param pulumi.Input[bool] enable_inter_container_traffic_encryption: Whether to encrypt all communications between distributed processing jobs. Choose True to encrypt communications. Encryption provides greater security for distributed processing jobs, but the processing might take longer.
        :param pulumi.Input[bool] enable_network_isolation: Whether to allow inbound and outbound network calls to and from the containers used for the processing job.
        :param pulumi.Input['ModelQualityJobDefinitionVpcConfigArgs'] vpc_config: Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC.
        """
        if enable_inter_container_traffic_encryption is not None:
            pulumi.set(__self__, "enable_inter_container_traffic_encryption", enable_inter_container_traffic_encryption)
        if enable_network_isolation is not None:
            pulumi.set(__self__, "enable_network_isolation", enable_network_isolation)
        if vpc_config is not None:
            pulumi.set(__self__, "vpc_config", vpc_config)

    @property
    @pulumi.getter(name="enableInterContainerTrafficEncryption")
    def enable_inter_container_traffic_encryption(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to encrypt all communications between distributed processing jobs. Choose True to encrypt communications. Encryption provides greater security for distributed processing jobs, but the processing might take longer.
        """
        return pulumi.get(self, "enable_inter_container_traffic_encryption")

    @enable_inter_container_traffic_encryption.setter
    def enable_inter_container_traffic_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_inter_container_traffic_encryption", value)

    @property
    @pulumi.getter(name="enableNetworkIsolation")
    def enable_network_isolation(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to allow inbound and outbound network calls to and from the containers used for the processing job.
        """
        return pulumi.get(self, "enable_network_isolation")

    @enable_network_isolation.setter
    def enable_network_isolation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_network_isolation", value)

    @property
    @pulumi.getter(name="vpcConfig")
    def vpc_config(self) -> Optional[pulumi.Input['ModelQualityJobDefinitionVpcConfigArgs']]:
        """
        Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC.
        """
        return pulumi.get(self, "vpc_config")

    @vpc_config.setter
    def vpc_config(self, value: Optional[pulumi.Input['ModelQualityJobDefinitionVpcConfigArgs']]):
        pulumi.set(self, "vpc_config", value)


if not MYPY:
    class ModelQualityJobDefinitionS3OutputArgsDict(TypedDict):
        """
        Information about where and how to store the results of a monitoring job.
        """
        local_path: pulumi.Input[str]
        """
        The local path to the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job. LocalPath is an absolute path for the output data.
        """
        s3_uri: pulumi.Input[str]
        """
        A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
        """
        s3_upload_mode: NotRequired[pulumi.Input['ModelQualityJobDefinitionS3OutputS3UploadMode']]
        """
        Whether to upload the results of the monitoring job continuously or after the job completes.
        """
elif False:
    ModelQualityJobDefinitionS3OutputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelQualityJobDefinitionS3OutputArgs:
    def __init__(__self__, *,
                 local_path: pulumi.Input[str],
                 s3_uri: pulumi.Input[str],
                 s3_upload_mode: Optional[pulumi.Input['ModelQualityJobDefinitionS3OutputS3UploadMode']] = None):
        """
        Information about where and how to store the results of a monitoring job.
        :param pulumi.Input[str] local_path: The local path to the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job. LocalPath is an absolute path for the output data.
        :param pulumi.Input[str] s3_uri: A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
        :param pulumi.Input['ModelQualityJobDefinitionS3OutputS3UploadMode'] s3_upload_mode: Whether to upload the results of the monitoring job continuously or after the job completes.
        """
        pulumi.set(__self__, "local_path", local_path)
        pulumi.set(__self__, "s3_uri", s3_uri)
        if s3_upload_mode is not None:
            pulumi.set(__self__, "s3_upload_mode", s3_upload_mode)

    @property
    @pulumi.getter(name="localPath")
    def local_path(self) -> pulumi.Input[str]:
        """
        The local path to the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job. LocalPath is an absolute path for the output data.
        """
        return pulumi.get(self, "local_path")

    @local_path.setter
    def local_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "local_path", value)

    @property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> pulumi.Input[str]:
        """
        A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
        """
        return pulumi.get(self, "s3_uri")

    @s3_uri.setter
    def s3_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_uri", value)

    @property
    @pulumi.getter(name="s3UploadMode")
    def s3_upload_mode(self) -> Optional[pulumi.Input['ModelQualityJobDefinitionS3OutputS3UploadMode']]:
        """
        Whether to upload the results of the monitoring job continuously or after the job completes.
        """
        return pulumi.get(self, "s3_upload_mode")

    @s3_upload_mode.setter
    def s3_upload_mode(self, value: Optional[pulumi.Input['ModelQualityJobDefinitionS3OutputS3UploadMode']]):
        pulumi.set(self, "s3_upload_mode", value)


if not MYPY:
    class ModelQualityJobDefinitionStoppingConditionArgsDict(TypedDict):
        """
        Specifies a time limit for how long the monitoring job is allowed to run.
        """
        max_runtime_in_seconds: pulumi.Input[int]
        """
        The maximum runtime allowed in seconds.
        """
elif False:
    ModelQualityJobDefinitionStoppingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelQualityJobDefinitionStoppingConditionArgs:
    def __init__(__self__, *,
                 max_runtime_in_seconds: pulumi.Input[int]):
        """
        Specifies a time limit for how long the monitoring job is allowed to run.
        :param pulumi.Input[int] max_runtime_in_seconds: The maximum runtime allowed in seconds.
        """
        pulumi.set(__self__, "max_runtime_in_seconds", max_runtime_in_seconds)

    @property
    @pulumi.getter(name="maxRuntimeInSeconds")
    def max_runtime_in_seconds(self) -> pulumi.Input[int]:
        """
        The maximum runtime allowed in seconds.
        """
        return pulumi.get(self, "max_runtime_in_seconds")

    @max_runtime_in_seconds.setter
    def max_runtime_in_seconds(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_runtime_in_seconds", value)


if not MYPY:
    class ModelQualityJobDefinitionVpcConfigArgsDict(TypedDict):
        """
        Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC.
        """
        security_group_ids: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the Subnets field.
        """
        subnets: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The ID of the subnets in the VPC to which you want to connect to your monitoring jobs.
        """
elif False:
    ModelQualityJobDefinitionVpcConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ModelQualityJobDefinitionVpcConfigArgs:
    def __init__(__self__, *,
                 security_group_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 subnets: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_group_ids: The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the Subnets field.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subnets: The ID of the subnets in the VPC to which you want to connect to your monitoring jobs.
        """
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnets", subnets)

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the Subnets field.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "security_group_ids", value)

    @property
    @pulumi.getter
    def subnets(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The ID of the subnets in the VPC to which you want to connect to your monitoring jobs.
        """
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "subnets", value)


if not MYPY:
    class MonitoringScheduleBaselineConfigArgsDict(TypedDict):
        """
        Baseline configuration used to validate that the data conforms to the specified constraints and statistics.
        """
        constraints_resource: NotRequired[pulumi.Input['MonitoringScheduleConstraintsResourceArgsDict']]
        """
        The Amazon S3 URI for the constraints resource.
        """
        statistics_resource: NotRequired[pulumi.Input['MonitoringScheduleStatisticsResourceArgsDict']]
        """
        The baseline statistics file in Amazon S3 that the current monitoring job should be validated against.
        """
elif False:
    MonitoringScheduleBaselineConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringScheduleBaselineConfigArgs:
    def __init__(__self__, *,
                 constraints_resource: Optional[pulumi.Input['MonitoringScheduleConstraintsResourceArgs']] = None,
                 statistics_resource: Optional[pulumi.Input['MonitoringScheduleStatisticsResourceArgs']] = None):
        """
        Baseline configuration used to validate that the data conforms to the specified constraints and statistics.
        :param pulumi.Input['MonitoringScheduleConstraintsResourceArgs'] constraints_resource: The Amazon S3 URI for the constraints resource.
        :param pulumi.Input['MonitoringScheduleStatisticsResourceArgs'] statistics_resource: The baseline statistics file in Amazon S3 that the current monitoring job should be validated against.
        """
        if constraints_resource is not None:
            pulumi.set(__self__, "constraints_resource", constraints_resource)
        if statistics_resource is not None:
            pulumi.set(__self__, "statistics_resource", statistics_resource)

    @property
    @pulumi.getter(name="constraintsResource")
    def constraints_resource(self) -> Optional[pulumi.Input['MonitoringScheduleConstraintsResourceArgs']]:
        """
        The Amazon S3 URI for the constraints resource.
        """
        return pulumi.get(self, "constraints_resource")

    @constraints_resource.setter
    def constraints_resource(self, value: Optional[pulumi.Input['MonitoringScheduleConstraintsResourceArgs']]):
        pulumi.set(self, "constraints_resource", value)

    @property
    @pulumi.getter(name="statisticsResource")
    def statistics_resource(self) -> Optional[pulumi.Input['MonitoringScheduleStatisticsResourceArgs']]:
        """
        The baseline statistics file in Amazon S3 that the current monitoring job should be validated against.
        """
        return pulumi.get(self, "statistics_resource")

    @statistics_resource.setter
    def statistics_resource(self, value: Optional[pulumi.Input['MonitoringScheduleStatisticsResourceArgs']]):
        pulumi.set(self, "statistics_resource", value)


if not MYPY:
    class MonitoringScheduleBatchTransformInputArgsDict(TypedDict):
        """
        The batch transform input for a monitoring job.
        """
        data_captured_destination_s3_uri: pulumi.Input[str]
        """
        A URI that identifies the Amazon S3 storage location where Batch Transform Job captures data.
        """
        dataset_format: pulumi.Input['MonitoringScheduleDatasetFormatArgsDict']
        local_path: pulumi.Input[str]
        """
        Path to the filesystem where the endpoint data is available to the container.
        """
        exclude_features_attribute: NotRequired[pulumi.Input[str]]
        """
        Indexes or names of the features to be excluded from analysis
        """
        s3_data_distribution_type: NotRequired[pulumi.Input['MonitoringScheduleBatchTransformInputS3DataDistributionType']]
        """
        Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
        """
        s3_input_mode: NotRequired[pulumi.Input['MonitoringScheduleBatchTransformInputS3InputMode']]
        """
        Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
        """
elif False:
    MonitoringScheduleBatchTransformInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringScheduleBatchTransformInputArgs:
    def __init__(__self__, *,
                 data_captured_destination_s3_uri: pulumi.Input[str],
                 dataset_format: pulumi.Input['MonitoringScheduleDatasetFormatArgs'],
                 local_path: pulumi.Input[str],
                 exclude_features_attribute: Optional[pulumi.Input[str]] = None,
                 s3_data_distribution_type: Optional[pulumi.Input['MonitoringScheduleBatchTransformInputS3DataDistributionType']] = None,
                 s3_input_mode: Optional[pulumi.Input['MonitoringScheduleBatchTransformInputS3InputMode']] = None):
        """
        The batch transform input for a monitoring job.
        :param pulumi.Input[str] data_captured_destination_s3_uri: A URI that identifies the Amazon S3 storage location where Batch Transform Job captures data.
        :param pulumi.Input[str] local_path: Path to the filesystem where the endpoint data is available to the container.
        :param pulumi.Input[str] exclude_features_attribute: Indexes or names of the features to be excluded from analysis
        :param pulumi.Input['MonitoringScheduleBatchTransformInputS3DataDistributionType'] s3_data_distribution_type: Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
        :param pulumi.Input['MonitoringScheduleBatchTransformInputS3InputMode'] s3_input_mode: Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
        """
        pulumi.set(__self__, "data_captured_destination_s3_uri", data_captured_destination_s3_uri)
        pulumi.set(__self__, "dataset_format", dataset_format)
        pulumi.set(__self__, "local_path", local_path)
        if exclude_features_attribute is not None:
            pulumi.set(__self__, "exclude_features_attribute", exclude_features_attribute)
        if s3_data_distribution_type is not None:
            pulumi.set(__self__, "s3_data_distribution_type", s3_data_distribution_type)
        if s3_input_mode is not None:
            pulumi.set(__self__, "s3_input_mode", s3_input_mode)

    @property
    @pulumi.getter(name="dataCapturedDestinationS3Uri")
    def data_captured_destination_s3_uri(self) -> pulumi.Input[str]:
        """
        A URI that identifies the Amazon S3 storage location where Batch Transform Job captures data.
        """
        return pulumi.get(self, "data_captured_destination_s3_uri")

    @data_captured_destination_s3_uri.setter
    def data_captured_destination_s3_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_captured_destination_s3_uri", value)

    @property
    @pulumi.getter(name="datasetFormat")
    def dataset_format(self) -> pulumi.Input['MonitoringScheduleDatasetFormatArgs']:
        return pulumi.get(self, "dataset_format")

    @dataset_format.setter
    def dataset_format(self, value: pulumi.Input['MonitoringScheduleDatasetFormatArgs']):
        pulumi.set(self, "dataset_format", value)

    @property
    @pulumi.getter(name="localPath")
    def local_path(self) -> pulumi.Input[str]:
        """
        Path to the filesystem where the endpoint data is available to the container.
        """
        return pulumi.get(self, "local_path")

    @local_path.setter
    def local_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "local_path", value)

    @property
    @pulumi.getter(name="excludeFeaturesAttribute")
    def exclude_features_attribute(self) -> Optional[pulumi.Input[str]]:
        """
        Indexes or names of the features to be excluded from analysis
        """
        return pulumi.get(self, "exclude_features_attribute")

    @exclude_features_attribute.setter
    def exclude_features_attribute(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exclude_features_attribute", value)

    @property
    @pulumi.getter(name="s3DataDistributionType")
    def s3_data_distribution_type(self) -> Optional[pulumi.Input['MonitoringScheduleBatchTransformInputS3DataDistributionType']]:
        """
        Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
        """
        return pulumi.get(self, "s3_data_distribution_type")

    @s3_data_distribution_type.setter
    def s3_data_distribution_type(self, value: Optional[pulumi.Input['MonitoringScheduleBatchTransformInputS3DataDistributionType']]):
        pulumi.set(self, "s3_data_distribution_type", value)

    @property
    @pulumi.getter(name="s3InputMode")
    def s3_input_mode(self) -> Optional[pulumi.Input['MonitoringScheduleBatchTransformInputS3InputMode']]:
        """
        Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
        """
        return pulumi.get(self, "s3_input_mode")

    @s3_input_mode.setter
    def s3_input_mode(self, value: Optional[pulumi.Input['MonitoringScheduleBatchTransformInputS3InputMode']]):
        pulumi.set(self, "s3_input_mode", value)


if not MYPY:
    class MonitoringScheduleClusterConfigArgsDict(TypedDict):
        """
        Configuration for the cluster used to run model monitoring jobs.
        """
        instance_count: pulumi.Input[int]
        """
        The number of ML compute instances to use in the model monitoring job. For distributed processing jobs, specify a value greater than 1. The default value is 1.
        """
        instance_type: pulumi.Input[str]
        """
        The ML compute instance type for the processing job.
        """
        volume_size_in_gb: pulumi.Input[int]
        """
        The size of the ML storage volume, in gigabytes, that you want to provision. You must specify sufficient ML storage for your scenario.
        """
        volume_kms_key_id: NotRequired[pulumi.Input[str]]
        """
        The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the model monitoring job.
        """
elif False:
    MonitoringScheduleClusterConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringScheduleClusterConfigArgs:
    def __init__(__self__, *,
                 instance_count: pulumi.Input[int],
                 instance_type: pulumi.Input[str],
                 volume_size_in_gb: pulumi.Input[int],
                 volume_kms_key_id: Optional[pulumi.Input[str]] = None):
        """
        Configuration for the cluster used to run model monitoring jobs.
        :param pulumi.Input[int] instance_count: The number of ML compute instances to use in the model monitoring job. For distributed processing jobs, specify a value greater than 1. The default value is 1.
        :param pulumi.Input[str] instance_type: The ML compute instance type for the processing job.
        :param pulumi.Input[int] volume_size_in_gb: The size of the ML storage volume, in gigabytes, that you want to provision. You must specify sufficient ML storage for your scenario.
        :param pulumi.Input[str] volume_kms_key_id: The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the model monitoring job.
        """
        pulumi.set(__self__, "instance_count", instance_count)
        pulumi.set(__self__, "instance_type", instance_type)
        pulumi.set(__self__, "volume_size_in_gb", volume_size_in_gb)
        if volume_kms_key_id is not None:
            pulumi.set(__self__, "volume_kms_key_id", volume_kms_key_id)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> pulumi.Input[int]:
        """
        The number of ML compute instances to use in the model monitoring job. For distributed processing jobs, specify a value greater than 1. The default value is 1.
        """
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "instance_count", value)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> pulumi.Input[str]:
        """
        The ML compute instance type for the processing job.
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance_type", value)

    @property
    @pulumi.getter(name="volumeSizeInGb")
    def volume_size_in_gb(self) -> pulumi.Input[int]:
        """
        The size of the ML storage volume, in gigabytes, that you want to provision. You must specify sufficient ML storage for your scenario.
        """
        return pulumi.get(self, "volume_size_in_gb")

    @volume_size_in_gb.setter
    def volume_size_in_gb(self, value: pulumi.Input[int]):
        pulumi.set(self, "volume_size_in_gb", value)

    @property
    @pulumi.getter(name="volumeKmsKeyId")
    def volume_kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt data on the storage volume attached to the ML compute instance(s) that run the model monitoring job.
        """
        return pulumi.get(self, "volume_kms_key_id")

    @volume_kms_key_id.setter
    def volume_kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_kms_key_id", value)


if not MYPY:
    class MonitoringScheduleConfigArgsDict(TypedDict):
        """
        The configuration object that specifies the monitoring schedule and defines the monitoring job.
        """
        monitoring_job_definition: NotRequired[pulumi.Input['MonitoringScheduleMonitoringJobDefinitionArgsDict']]
        """
        Defines the monitoring job.
        """
        monitoring_job_definition_name: NotRequired[pulumi.Input[str]]
        """
        Name of the job definition
        """
        monitoring_type: NotRequired[pulumi.Input['MonitoringScheduleMonitoringType']]
        """
        The type of the monitoring job definition to schedule.
        """
        schedule_config: NotRequired[pulumi.Input['MonitoringScheduleScheduleConfigArgsDict']]
        """
        Configures the monitoring schedule.
        """
elif False:
    MonitoringScheduleConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringScheduleConfigArgs:
    def __init__(__self__, *,
                 monitoring_job_definition: Optional[pulumi.Input['MonitoringScheduleMonitoringJobDefinitionArgs']] = None,
                 monitoring_job_definition_name: Optional[pulumi.Input[str]] = None,
                 monitoring_type: Optional[pulumi.Input['MonitoringScheduleMonitoringType']] = None,
                 schedule_config: Optional[pulumi.Input['MonitoringScheduleScheduleConfigArgs']] = None):
        """
        The configuration object that specifies the monitoring schedule and defines the monitoring job.
        :param pulumi.Input['MonitoringScheduleMonitoringJobDefinitionArgs'] monitoring_job_definition: Defines the monitoring job.
        :param pulumi.Input[str] monitoring_job_definition_name: Name of the job definition
        :param pulumi.Input['MonitoringScheduleMonitoringType'] monitoring_type: The type of the monitoring job definition to schedule.
        :param pulumi.Input['MonitoringScheduleScheduleConfigArgs'] schedule_config: Configures the monitoring schedule.
        """
        if monitoring_job_definition is not None:
            pulumi.set(__self__, "monitoring_job_definition", monitoring_job_definition)
        if monitoring_job_definition_name is not None:
            pulumi.set(__self__, "monitoring_job_definition_name", monitoring_job_definition_name)
        if monitoring_type is not None:
            pulumi.set(__self__, "monitoring_type", monitoring_type)
        if schedule_config is not None:
            pulumi.set(__self__, "schedule_config", schedule_config)

    @property
    @pulumi.getter(name="monitoringJobDefinition")
    def monitoring_job_definition(self) -> Optional[pulumi.Input['MonitoringScheduleMonitoringJobDefinitionArgs']]:
        """
        Defines the monitoring job.
        """
        return pulumi.get(self, "monitoring_job_definition")

    @monitoring_job_definition.setter
    def monitoring_job_definition(self, value: Optional[pulumi.Input['MonitoringScheduleMonitoringJobDefinitionArgs']]):
        pulumi.set(self, "monitoring_job_definition", value)

    @property
    @pulumi.getter(name="monitoringJobDefinitionName")
    def monitoring_job_definition_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the job definition
        """
        return pulumi.get(self, "monitoring_job_definition_name")

    @monitoring_job_definition_name.setter
    def monitoring_job_definition_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "monitoring_job_definition_name", value)

    @property
    @pulumi.getter(name="monitoringType")
    def monitoring_type(self) -> Optional[pulumi.Input['MonitoringScheduleMonitoringType']]:
        """
        The type of the monitoring job definition to schedule.
        """
        return pulumi.get(self, "monitoring_type")

    @monitoring_type.setter
    def monitoring_type(self, value: Optional[pulumi.Input['MonitoringScheduleMonitoringType']]):
        pulumi.set(self, "monitoring_type", value)

    @property
    @pulumi.getter(name="scheduleConfig")
    def schedule_config(self) -> Optional[pulumi.Input['MonitoringScheduleScheduleConfigArgs']]:
        """
        Configures the monitoring schedule.
        """
        return pulumi.get(self, "schedule_config")

    @schedule_config.setter
    def schedule_config(self, value: Optional[pulumi.Input['MonitoringScheduleScheduleConfigArgs']]):
        pulumi.set(self, "schedule_config", value)


if not MYPY:
    class MonitoringScheduleConstraintsResourceArgsDict(TypedDict):
        """
        The baseline constraints resource for a monitoring job.
        """
        s3_uri: NotRequired[pulumi.Input[str]]
        """
        The Amazon S3 URI for baseline constraint file in Amazon S3 that the current monitoring job should validated against.
        """
elif False:
    MonitoringScheduleConstraintsResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringScheduleConstraintsResourceArgs:
    def __init__(__self__, *,
                 s3_uri: Optional[pulumi.Input[str]] = None):
        """
        The baseline constraints resource for a monitoring job.
        :param pulumi.Input[str] s3_uri: The Amazon S3 URI for baseline constraint file in Amazon S3 that the current monitoring job should validated against.
        """
        if s3_uri is not None:
            pulumi.set(__self__, "s3_uri", s3_uri)

    @property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon S3 URI for baseline constraint file in Amazon S3 that the current monitoring job should validated against.
        """
        return pulumi.get(self, "s3_uri")

    @s3_uri.setter
    def s3_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_uri", value)


if not MYPY:
    class MonitoringScheduleCsvArgsDict(TypedDict):
        """
        The CSV format
        """
        header: NotRequired[pulumi.Input[bool]]
        """
        A boolean flag indicating if given CSV has header
        """
elif False:
    MonitoringScheduleCsvArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringScheduleCsvArgs:
    def __init__(__self__, *,
                 header: Optional[pulumi.Input[bool]] = None):
        """
        The CSV format
        :param pulumi.Input[bool] header: A boolean flag indicating if given CSV has header
        """
        if header is not None:
            pulumi.set(__self__, "header", header)

    @property
    @pulumi.getter
    def header(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean flag indicating if given CSV has header
        """
        return pulumi.get(self, "header")

    @header.setter
    def header(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "header", value)


if not MYPY:
    class MonitoringScheduleDatasetFormatArgsDict(TypedDict):
        """
        The dataset format of the data to monitor
        """
        csv: NotRequired[pulumi.Input['MonitoringScheduleCsvArgsDict']]
        json: NotRequired[pulumi.Input['MonitoringScheduleJsonArgsDict']]
        parquet: NotRequired[pulumi.Input[bool]]
elif False:
    MonitoringScheduleDatasetFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringScheduleDatasetFormatArgs:
    def __init__(__self__, *,
                 csv: Optional[pulumi.Input['MonitoringScheduleCsvArgs']] = None,
                 json: Optional[pulumi.Input['MonitoringScheduleJsonArgs']] = None,
                 parquet: Optional[pulumi.Input[bool]] = None):
        """
        The dataset format of the data to monitor
        """
        if csv is not None:
            pulumi.set(__self__, "csv", csv)
        if json is not None:
            pulumi.set(__self__, "json", json)
        if parquet is not None:
            pulumi.set(__self__, "parquet", parquet)

    @property
    @pulumi.getter
    def csv(self) -> Optional[pulumi.Input['MonitoringScheduleCsvArgs']]:
        return pulumi.get(self, "csv")

    @csv.setter
    def csv(self, value: Optional[pulumi.Input['MonitoringScheduleCsvArgs']]):
        pulumi.set(self, "csv", value)

    @property
    @pulumi.getter
    def json(self) -> Optional[pulumi.Input['MonitoringScheduleJsonArgs']]:
        return pulumi.get(self, "json")

    @json.setter
    def json(self, value: Optional[pulumi.Input['MonitoringScheduleJsonArgs']]):
        pulumi.set(self, "json", value)

    @property
    @pulumi.getter
    def parquet(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "parquet")

    @parquet.setter
    def parquet(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "parquet", value)


if not MYPY:
    class MonitoringScheduleEndpointInputArgsDict(TypedDict):
        """
        The endpoint for a monitoring job.
        """
        endpoint_name: pulumi.Input[str]
        local_path: pulumi.Input[str]
        """
        Path to the filesystem where the endpoint data is available to the container.
        """
        exclude_features_attribute: NotRequired[pulumi.Input[str]]
        """
        Indexes or names of the features to be excluded from analysis
        """
        s3_data_distribution_type: NotRequired[pulumi.Input['MonitoringScheduleEndpointInputS3DataDistributionType']]
        """
        Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
        """
        s3_input_mode: NotRequired[pulumi.Input['MonitoringScheduleEndpointInputS3InputMode']]
        """
        Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
        """
elif False:
    MonitoringScheduleEndpointInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringScheduleEndpointInputArgs:
    def __init__(__self__, *,
                 endpoint_name: pulumi.Input[str],
                 local_path: pulumi.Input[str],
                 exclude_features_attribute: Optional[pulumi.Input[str]] = None,
                 s3_data_distribution_type: Optional[pulumi.Input['MonitoringScheduleEndpointInputS3DataDistributionType']] = None,
                 s3_input_mode: Optional[pulumi.Input['MonitoringScheduleEndpointInputS3InputMode']] = None):
        """
        The endpoint for a monitoring job.
        :param pulumi.Input[str] local_path: Path to the filesystem where the endpoint data is available to the container.
        :param pulumi.Input[str] exclude_features_attribute: Indexes or names of the features to be excluded from analysis
        :param pulumi.Input['MonitoringScheduleEndpointInputS3DataDistributionType'] s3_data_distribution_type: Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
        :param pulumi.Input['MonitoringScheduleEndpointInputS3InputMode'] s3_input_mode: Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
        """
        pulumi.set(__self__, "endpoint_name", endpoint_name)
        pulumi.set(__self__, "local_path", local_path)
        if exclude_features_attribute is not None:
            pulumi.set(__self__, "exclude_features_attribute", exclude_features_attribute)
        if s3_data_distribution_type is not None:
            pulumi.set(__self__, "s3_data_distribution_type", s3_data_distribution_type)
        if s3_input_mode is not None:
            pulumi.set(__self__, "s3_input_mode", s3_input_mode)

    @property
    @pulumi.getter(name="endpointName")
    def endpoint_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "endpoint_name")

    @endpoint_name.setter
    def endpoint_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint_name", value)

    @property
    @pulumi.getter(name="localPath")
    def local_path(self) -> pulumi.Input[str]:
        """
        Path to the filesystem where the endpoint data is available to the container.
        """
        return pulumi.get(self, "local_path")

    @local_path.setter
    def local_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "local_path", value)

    @property
    @pulumi.getter(name="excludeFeaturesAttribute")
    def exclude_features_attribute(self) -> Optional[pulumi.Input[str]]:
        """
        Indexes or names of the features to be excluded from analysis
        """
        return pulumi.get(self, "exclude_features_attribute")

    @exclude_features_attribute.setter
    def exclude_features_attribute(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exclude_features_attribute", value)

    @property
    @pulumi.getter(name="s3DataDistributionType")
    def s3_data_distribution_type(self) -> Optional[pulumi.Input['MonitoringScheduleEndpointInputS3DataDistributionType']]:
        """
        Whether input data distributed in Amazon S3 is fully replicated or sharded by an S3 key. Defauts to FullyReplicated
        """
        return pulumi.get(self, "s3_data_distribution_type")

    @s3_data_distribution_type.setter
    def s3_data_distribution_type(self, value: Optional[pulumi.Input['MonitoringScheduleEndpointInputS3DataDistributionType']]):
        pulumi.set(self, "s3_data_distribution_type", value)

    @property
    @pulumi.getter(name="s3InputMode")
    def s3_input_mode(self) -> Optional[pulumi.Input['MonitoringScheduleEndpointInputS3InputMode']]:
        """
        Whether the Pipe or File is used as the input mode for transfering data for the monitoring job. Pipe mode is recommended for large datasets. File mode is useful for small files that fit in memory. Defaults to File.
        """
        return pulumi.get(self, "s3_input_mode")

    @s3_input_mode.setter
    def s3_input_mode(self, value: Optional[pulumi.Input['MonitoringScheduleEndpointInputS3InputMode']]):
        pulumi.set(self, "s3_input_mode", value)


if not MYPY:
    class MonitoringScheduleJsonArgsDict(TypedDict):
        """
        The Json format
        """
        line: NotRequired[pulumi.Input[bool]]
        """
        A boolean flag indicating if it is JSON line format
        """
elif False:
    MonitoringScheduleJsonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringScheduleJsonArgs:
    def __init__(__self__, *,
                 line: Optional[pulumi.Input[bool]] = None):
        """
        The Json format
        :param pulumi.Input[bool] line: A boolean flag indicating if it is JSON line format
        """
        if line is not None:
            pulumi.set(__self__, "line", line)

    @property
    @pulumi.getter
    def line(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean flag indicating if it is JSON line format
        """
        return pulumi.get(self, "line")

    @line.setter
    def line(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "line", value)


if not MYPY:
    class MonitoringScheduleMonitoringAppSpecificationArgsDict(TypedDict):
        """
        Container image configuration object for the monitoring job.
        """
        image_uri: pulumi.Input[str]
        """
        The container image to be run by the monitoring job.
        """
        container_arguments: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of arguments for the container used to run the monitoring job.
        """
        container_entrypoint: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Specifies the entrypoint for a container used to run the monitoring job.
        """
        post_analytics_processor_source_uri: NotRequired[pulumi.Input[str]]
        """
        An Amazon S3 URI to a script that is called after analysis has been performed. Applicable only for the built-in (first party) containers.
        """
        record_preprocessor_source_uri: NotRequired[pulumi.Input[str]]
        """
        An Amazon S3 URI to a script that is called per row prior to running analysis. It can base64 decode the payload and convert it into a flatted json so that the built-in container can use the converted data. Applicable only for the built-in (first party) containers
        """
elif False:
    MonitoringScheduleMonitoringAppSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringScheduleMonitoringAppSpecificationArgs:
    def __init__(__self__, *,
                 image_uri: pulumi.Input[str],
                 container_arguments: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 container_entrypoint: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 post_analytics_processor_source_uri: Optional[pulumi.Input[str]] = None,
                 record_preprocessor_source_uri: Optional[pulumi.Input[str]] = None):
        """
        Container image configuration object for the monitoring job.
        :param pulumi.Input[str] image_uri: The container image to be run by the monitoring job.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] container_arguments: An array of arguments for the container used to run the monitoring job.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] container_entrypoint: Specifies the entrypoint for a container used to run the monitoring job.
        :param pulumi.Input[str] post_analytics_processor_source_uri: An Amazon S3 URI to a script that is called after analysis has been performed. Applicable only for the built-in (first party) containers.
        :param pulumi.Input[str] record_preprocessor_source_uri: An Amazon S3 URI to a script that is called per row prior to running analysis. It can base64 decode the payload and convert it into a flatted json so that the built-in container can use the converted data. Applicable only for the built-in (first party) containers
        """
        pulumi.set(__self__, "image_uri", image_uri)
        if container_arguments is not None:
            pulumi.set(__self__, "container_arguments", container_arguments)
        if container_entrypoint is not None:
            pulumi.set(__self__, "container_entrypoint", container_entrypoint)
        if post_analytics_processor_source_uri is not None:
            pulumi.set(__self__, "post_analytics_processor_source_uri", post_analytics_processor_source_uri)
        if record_preprocessor_source_uri is not None:
            pulumi.set(__self__, "record_preprocessor_source_uri", record_preprocessor_source_uri)

    @property
    @pulumi.getter(name="imageUri")
    def image_uri(self) -> pulumi.Input[str]:
        """
        The container image to be run by the monitoring job.
        """
        return pulumi.get(self, "image_uri")

    @image_uri.setter
    def image_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "image_uri", value)

    @property
    @pulumi.getter(name="containerArguments")
    def container_arguments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of arguments for the container used to run the monitoring job.
        """
        return pulumi.get(self, "container_arguments")

    @container_arguments.setter
    def container_arguments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "container_arguments", value)

    @property
    @pulumi.getter(name="containerEntrypoint")
    def container_entrypoint(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies the entrypoint for a container used to run the monitoring job.
        """
        return pulumi.get(self, "container_entrypoint")

    @container_entrypoint.setter
    def container_entrypoint(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "container_entrypoint", value)

    @property
    @pulumi.getter(name="postAnalyticsProcessorSourceUri")
    def post_analytics_processor_source_uri(self) -> Optional[pulumi.Input[str]]:
        """
        An Amazon S3 URI to a script that is called after analysis has been performed. Applicable only for the built-in (first party) containers.
        """
        return pulumi.get(self, "post_analytics_processor_source_uri")

    @post_analytics_processor_source_uri.setter
    def post_analytics_processor_source_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "post_analytics_processor_source_uri", value)

    @property
    @pulumi.getter(name="recordPreprocessorSourceUri")
    def record_preprocessor_source_uri(self) -> Optional[pulumi.Input[str]]:
        """
        An Amazon S3 URI to a script that is called per row prior to running analysis. It can base64 decode the payload and convert it into a flatted json so that the built-in container can use the converted data. Applicable only for the built-in (first party) containers
        """
        return pulumi.get(self, "record_preprocessor_source_uri")

    @record_preprocessor_source_uri.setter
    def record_preprocessor_source_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "record_preprocessor_source_uri", value)


if not MYPY:
    class MonitoringScheduleMonitoringExecutionSummaryArgsDict(TypedDict):
        """
        Summary of information about monitoring job
        """
        creation_time: pulumi.Input[str]
        """
        The time at which the monitoring job was created.
        """
        last_modified_time: pulumi.Input[str]
        """
        A timestamp that indicates the last time the monitoring job was modified.
        """
        monitoring_execution_status: pulumi.Input['MonitoringScheduleMonitoringExecutionSummaryMonitoringExecutionStatus']
        """
        The status of the monitoring job.
        """
        monitoring_schedule_name: pulumi.Input[str]
        """
        The name of the monitoring schedule.
        """
        scheduled_time: pulumi.Input[str]
        """
        The time the monitoring job was scheduled.
        """
        endpoint_name: NotRequired[pulumi.Input[str]]
        """
        The name of the endpoint used to run the monitoring job.
        """
        failure_reason: NotRequired[pulumi.Input[str]]
        """
        Contains the reason a monitoring job failed, if it failed.
        """
        processing_job_arn: NotRequired[pulumi.Input[str]]
        """
        The Amazon Resource Name (ARN) of the monitoring job.
        """
elif False:
    MonitoringScheduleMonitoringExecutionSummaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringScheduleMonitoringExecutionSummaryArgs:
    def __init__(__self__, *,
                 creation_time: pulumi.Input[str],
                 last_modified_time: pulumi.Input[str],
                 monitoring_execution_status: pulumi.Input['MonitoringScheduleMonitoringExecutionSummaryMonitoringExecutionStatus'],
                 monitoring_schedule_name: pulumi.Input[str],
                 scheduled_time: pulumi.Input[str],
                 endpoint_name: Optional[pulumi.Input[str]] = None,
                 failure_reason: Optional[pulumi.Input[str]] = None,
                 processing_job_arn: Optional[pulumi.Input[str]] = None):
        """
        Summary of information about monitoring job
        :param pulumi.Input[str] creation_time: The time at which the monitoring job was created.
        :param pulumi.Input[str] last_modified_time: A timestamp that indicates the last time the monitoring job was modified.
        :param pulumi.Input['MonitoringScheduleMonitoringExecutionSummaryMonitoringExecutionStatus'] monitoring_execution_status: The status of the monitoring job.
        :param pulumi.Input[str] monitoring_schedule_name: The name of the monitoring schedule.
        :param pulumi.Input[str] scheduled_time: The time the monitoring job was scheduled.
        :param pulumi.Input[str] endpoint_name: The name of the endpoint used to run the monitoring job.
        :param pulumi.Input[str] failure_reason: Contains the reason a monitoring job failed, if it failed.
        :param pulumi.Input[str] processing_job_arn: The Amazon Resource Name (ARN) of the monitoring job.
        """
        pulumi.set(__self__, "creation_time", creation_time)
        pulumi.set(__self__, "last_modified_time", last_modified_time)
        pulumi.set(__self__, "monitoring_execution_status", monitoring_execution_status)
        pulumi.set(__self__, "monitoring_schedule_name", monitoring_schedule_name)
        pulumi.set(__self__, "scheduled_time", scheduled_time)
        if endpoint_name is not None:
            pulumi.set(__self__, "endpoint_name", endpoint_name)
        if failure_reason is not None:
            pulumi.set(__self__, "failure_reason", failure_reason)
        if processing_job_arn is not None:
            pulumi.set(__self__, "processing_job_arn", processing_job_arn)

    @property
    @pulumi.getter(name="creationTime")
    def creation_time(self) -> pulumi.Input[str]:
        """
        The time at which the monitoring job was created.
        """
        return pulumi.get(self, "creation_time")

    @creation_time.setter
    def creation_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "creation_time", value)

    @property
    @pulumi.getter(name="lastModifiedTime")
    def last_modified_time(self) -> pulumi.Input[str]:
        """
        A timestamp that indicates the last time the monitoring job was modified.
        """
        return pulumi.get(self, "last_modified_time")

    @last_modified_time.setter
    def last_modified_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "last_modified_time", value)

    @property
    @pulumi.getter(name="monitoringExecutionStatus")
    def monitoring_execution_status(self) -> pulumi.Input['MonitoringScheduleMonitoringExecutionSummaryMonitoringExecutionStatus']:
        """
        The status of the monitoring job.
        """
        return pulumi.get(self, "monitoring_execution_status")

    @monitoring_execution_status.setter
    def monitoring_execution_status(self, value: pulumi.Input['MonitoringScheduleMonitoringExecutionSummaryMonitoringExecutionStatus']):
        pulumi.set(self, "monitoring_execution_status", value)

    @property
    @pulumi.getter(name="monitoringScheduleName")
    def monitoring_schedule_name(self) -> pulumi.Input[str]:
        """
        The name of the monitoring schedule.
        """
        return pulumi.get(self, "monitoring_schedule_name")

    @monitoring_schedule_name.setter
    def monitoring_schedule_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "monitoring_schedule_name", value)

    @property
    @pulumi.getter(name="scheduledTime")
    def scheduled_time(self) -> pulumi.Input[str]:
        """
        The time the monitoring job was scheduled.
        """
        return pulumi.get(self, "scheduled_time")

    @scheduled_time.setter
    def scheduled_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "scheduled_time", value)

    @property
    @pulumi.getter(name="endpointName")
    def endpoint_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the endpoint used to run the monitoring job.
        """
        return pulumi.get(self, "endpoint_name")

    @endpoint_name.setter
    def endpoint_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint_name", value)

    @property
    @pulumi.getter(name="failureReason")
    def failure_reason(self) -> Optional[pulumi.Input[str]]:
        """
        Contains the reason a monitoring job failed, if it failed.
        """
        return pulumi.get(self, "failure_reason")

    @failure_reason.setter
    def failure_reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "failure_reason", value)

    @property
    @pulumi.getter(name="processingJobArn")
    def processing_job_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon Resource Name (ARN) of the monitoring job.
        """
        return pulumi.get(self, "processing_job_arn")

    @processing_job_arn.setter
    def processing_job_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "processing_job_arn", value)


if not MYPY:
    class MonitoringScheduleMonitoringInputArgsDict(TypedDict):
        """
        The inputs for a monitoring job.
        """
        batch_transform_input: NotRequired[pulumi.Input['MonitoringScheduleBatchTransformInputArgsDict']]
        endpoint_input: NotRequired[pulumi.Input['MonitoringScheduleEndpointInputArgsDict']]
elif False:
    MonitoringScheduleMonitoringInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringScheduleMonitoringInputArgs:
    def __init__(__self__, *,
                 batch_transform_input: Optional[pulumi.Input['MonitoringScheduleBatchTransformInputArgs']] = None,
                 endpoint_input: Optional[pulumi.Input['MonitoringScheduleEndpointInputArgs']] = None):
        """
        The inputs for a monitoring job.
        """
        if batch_transform_input is not None:
            pulumi.set(__self__, "batch_transform_input", batch_transform_input)
        if endpoint_input is not None:
            pulumi.set(__self__, "endpoint_input", endpoint_input)

    @property
    @pulumi.getter(name="batchTransformInput")
    def batch_transform_input(self) -> Optional[pulumi.Input['MonitoringScheduleBatchTransformInputArgs']]:
        return pulumi.get(self, "batch_transform_input")

    @batch_transform_input.setter
    def batch_transform_input(self, value: Optional[pulumi.Input['MonitoringScheduleBatchTransformInputArgs']]):
        pulumi.set(self, "batch_transform_input", value)

    @property
    @pulumi.getter(name="endpointInput")
    def endpoint_input(self) -> Optional[pulumi.Input['MonitoringScheduleEndpointInputArgs']]:
        return pulumi.get(self, "endpoint_input")

    @endpoint_input.setter
    def endpoint_input(self, value: Optional[pulumi.Input['MonitoringScheduleEndpointInputArgs']]):
        pulumi.set(self, "endpoint_input", value)


if not MYPY:
    class MonitoringScheduleMonitoringJobDefinitionArgsDict(TypedDict):
        """
        Defines the monitoring job.
        """
        monitoring_app_specification: pulumi.Input['MonitoringScheduleMonitoringAppSpecificationArgsDict']
        """
        Configures the monitoring job to run a specified Docker container image.
        """
        monitoring_inputs: pulumi.Input[Sequence[pulumi.Input['MonitoringScheduleMonitoringInputArgsDict']]]
        """
        The array of inputs for the monitoring job. Currently we support monitoring an Amazon SageMaker Endpoint.
        """
        monitoring_output_config: pulumi.Input['MonitoringScheduleMonitoringOutputConfigArgsDict']
        """
        The array of outputs from the monitoring job to be uploaded to Amazon S3.
        """
        monitoring_resources: pulumi.Input['MonitoringScheduleMonitoringResourcesArgsDict']
        """
        Identifies the resources, ML compute instances, and ML storage volumes to deploy for a monitoring job. In distributed processing, you specify more than one instance.
        """
        role_arn: pulumi.Input[str]
        """
        The Amazon Resource Name (ARN) of an IAM role that Amazon SageMaker can assume to perform tasks on your behalf.
        """
        baseline_config: NotRequired[pulumi.Input['MonitoringScheduleBaselineConfigArgsDict']]
        """
        Baseline configuration used to validate that the data conforms to the specified constraints and statistics
        """
        environment: NotRequired[Any]
        """
        Sets the environment variables in the Docker container
        """
        network_config: NotRequired[pulumi.Input['MonitoringScheduleNetworkConfigArgsDict']]
        """
        Specifies networking options for an monitoring job.
        """
        stopping_condition: NotRequired[pulumi.Input['MonitoringScheduleStoppingConditionArgsDict']]
        """
        Specifies a time limit for how long the monitoring job is allowed to run.
        """
elif False:
    MonitoringScheduleMonitoringJobDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringScheduleMonitoringJobDefinitionArgs:
    def __init__(__self__, *,
                 monitoring_app_specification: pulumi.Input['MonitoringScheduleMonitoringAppSpecificationArgs'],
                 monitoring_inputs: pulumi.Input[Sequence[pulumi.Input['MonitoringScheduleMonitoringInputArgs']]],
                 monitoring_output_config: pulumi.Input['MonitoringScheduleMonitoringOutputConfigArgs'],
                 monitoring_resources: pulumi.Input['MonitoringScheduleMonitoringResourcesArgs'],
                 role_arn: pulumi.Input[str],
                 baseline_config: Optional[pulumi.Input['MonitoringScheduleBaselineConfigArgs']] = None,
                 environment: Optional[Any] = None,
                 network_config: Optional[pulumi.Input['MonitoringScheduleNetworkConfigArgs']] = None,
                 stopping_condition: Optional[pulumi.Input['MonitoringScheduleStoppingConditionArgs']] = None):
        """
        Defines the monitoring job.
        :param pulumi.Input['MonitoringScheduleMonitoringAppSpecificationArgs'] monitoring_app_specification: Configures the monitoring job to run a specified Docker container image.
        :param pulumi.Input[Sequence[pulumi.Input['MonitoringScheduleMonitoringInputArgs']]] monitoring_inputs: The array of inputs for the monitoring job. Currently we support monitoring an Amazon SageMaker Endpoint.
        :param pulumi.Input['MonitoringScheduleMonitoringOutputConfigArgs'] monitoring_output_config: The array of outputs from the monitoring job to be uploaded to Amazon S3.
        :param pulumi.Input['MonitoringScheduleMonitoringResourcesArgs'] monitoring_resources: Identifies the resources, ML compute instances, and ML storage volumes to deploy for a monitoring job. In distributed processing, you specify more than one instance.
        :param pulumi.Input[str] role_arn: The Amazon Resource Name (ARN) of an IAM role that Amazon SageMaker can assume to perform tasks on your behalf.
        :param pulumi.Input['MonitoringScheduleBaselineConfigArgs'] baseline_config: Baseline configuration used to validate that the data conforms to the specified constraints and statistics
        :param Any environment: Sets the environment variables in the Docker container
        :param pulumi.Input['MonitoringScheduleNetworkConfigArgs'] network_config: Specifies networking options for an monitoring job.
        :param pulumi.Input['MonitoringScheduleStoppingConditionArgs'] stopping_condition: Specifies a time limit for how long the monitoring job is allowed to run.
        """
        pulumi.set(__self__, "monitoring_app_specification", monitoring_app_specification)
        pulumi.set(__self__, "monitoring_inputs", monitoring_inputs)
        pulumi.set(__self__, "monitoring_output_config", monitoring_output_config)
        pulumi.set(__self__, "monitoring_resources", monitoring_resources)
        pulumi.set(__self__, "role_arn", role_arn)
        if baseline_config is not None:
            pulumi.set(__self__, "baseline_config", baseline_config)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if network_config is not None:
            pulumi.set(__self__, "network_config", network_config)
        if stopping_condition is not None:
            pulumi.set(__self__, "stopping_condition", stopping_condition)

    @property
    @pulumi.getter(name="monitoringAppSpecification")
    def monitoring_app_specification(self) -> pulumi.Input['MonitoringScheduleMonitoringAppSpecificationArgs']:
        """
        Configures the monitoring job to run a specified Docker container image.
        """
        return pulumi.get(self, "monitoring_app_specification")

    @monitoring_app_specification.setter
    def monitoring_app_specification(self, value: pulumi.Input['MonitoringScheduleMonitoringAppSpecificationArgs']):
        pulumi.set(self, "monitoring_app_specification", value)

    @property
    @pulumi.getter(name="monitoringInputs")
    def monitoring_inputs(self) -> pulumi.Input[Sequence[pulumi.Input['MonitoringScheduleMonitoringInputArgs']]]:
        """
        The array of inputs for the monitoring job. Currently we support monitoring an Amazon SageMaker Endpoint.
        """
        return pulumi.get(self, "monitoring_inputs")

    @monitoring_inputs.setter
    def monitoring_inputs(self, value: pulumi.Input[Sequence[pulumi.Input['MonitoringScheduleMonitoringInputArgs']]]):
        pulumi.set(self, "monitoring_inputs", value)

    @property
    @pulumi.getter(name="monitoringOutputConfig")
    def monitoring_output_config(self) -> pulumi.Input['MonitoringScheduleMonitoringOutputConfigArgs']:
        """
        The array of outputs from the monitoring job to be uploaded to Amazon S3.
        """
        return pulumi.get(self, "monitoring_output_config")

    @monitoring_output_config.setter
    def monitoring_output_config(self, value: pulumi.Input['MonitoringScheduleMonitoringOutputConfigArgs']):
        pulumi.set(self, "monitoring_output_config", value)

    @property
    @pulumi.getter(name="monitoringResources")
    def monitoring_resources(self) -> pulumi.Input['MonitoringScheduleMonitoringResourcesArgs']:
        """
        Identifies the resources, ML compute instances, and ML storage volumes to deploy for a monitoring job. In distributed processing, you specify more than one instance.
        """
        return pulumi.get(self, "monitoring_resources")

    @monitoring_resources.setter
    def monitoring_resources(self, value: pulumi.Input['MonitoringScheduleMonitoringResourcesArgs']):
        pulumi.set(self, "monitoring_resources", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of an IAM role that Amazon SageMaker can assume to perform tasks on your behalf.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="baselineConfig")
    def baseline_config(self) -> Optional[pulumi.Input['MonitoringScheduleBaselineConfigArgs']]:
        """
        Baseline configuration used to validate that the data conforms to the specified constraints and statistics
        """
        return pulumi.get(self, "baseline_config")

    @baseline_config.setter
    def baseline_config(self, value: Optional[pulumi.Input['MonitoringScheduleBaselineConfigArgs']]):
        pulumi.set(self, "baseline_config", value)

    @property
    @pulumi.getter
    def environment(self) -> Optional[Any]:
        """
        Sets the environment variables in the Docker container
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[Any]):
        pulumi.set(self, "environment", value)

    @property
    @pulumi.getter(name="networkConfig")
    def network_config(self) -> Optional[pulumi.Input['MonitoringScheduleNetworkConfigArgs']]:
        """
        Specifies networking options for an monitoring job.
        """
        return pulumi.get(self, "network_config")

    @network_config.setter
    def network_config(self, value: Optional[pulumi.Input['MonitoringScheduleNetworkConfigArgs']]):
        pulumi.set(self, "network_config", value)

    @property
    @pulumi.getter(name="stoppingCondition")
    def stopping_condition(self) -> Optional[pulumi.Input['MonitoringScheduleStoppingConditionArgs']]:
        """
        Specifies a time limit for how long the monitoring job is allowed to run.
        """
        return pulumi.get(self, "stopping_condition")

    @stopping_condition.setter
    def stopping_condition(self, value: Optional[pulumi.Input['MonitoringScheduleStoppingConditionArgs']]):
        pulumi.set(self, "stopping_condition", value)


if not MYPY:
    class MonitoringScheduleMonitoringOutputConfigArgsDict(TypedDict):
        """
        The output configuration for monitoring jobs.
        """
        monitoring_outputs: pulumi.Input[Sequence[pulumi.Input['MonitoringScheduleMonitoringOutputArgsDict']]]
        """
        Monitoring outputs for monitoring jobs. This is where the output of the periodic monitoring jobs is uploaded.
        """
        kms_key_id: NotRequired[pulumi.Input[str]]
        """
        The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.
        """
elif False:
    MonitoringScheduleMonitoringOutputConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringScheduleMonitoringOutputConfigArgs:
    def __init__(__self__, *,
                 monitoring_outputs: pulumi.Input[Sequence[pulumi.Input['MonitoringScheduleMonitoringOutputArgs']]],
                 kms_key_id: Optional[pulumi.Input[str]] = None):
        """
        The output configuration for monitoring jobs.
        :param pulumi.Input[Sequence[pulumi.Input['MonitoringScheduleMonitoringOutputArgs']]] monitoring_outputs: Monitoring outputs for monitoring jobs. This is where the output of the periodic monitoring jobs is uploaded.
        :param pulumi.Input[str] kms_key_id: The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.
        """
        pulumi.set(__self__, "monitoring_outputs", monitoring_outputs)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)

    @property
    @pulumi.getter(name="monitoringOutputs")
    def monitoring_outputs(self) -> pulumi.Input[Sequence[pulumi.Input['MonitoringScheduleMonitoringOutputArgs']]]:
        """
        Monitoring outputs for monitoring jobs. This is where the output of the periodic monitoring jobs is uploaded.
        """
        return pulumi.get(self, "monitoring_outputs")

    @monitoring_outputs.setter
    def monitoring_outputs(self, value: pulumi.Input[Sequence[pulumi.Input['MonitoringScheduleMonitoringOutputArgs']]]):
        pulumi.set(self, "monitoring_outputs", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        The AWS Key Management Service (AWS KMS) key that Amazon SageMaker uses to encrypt the model artifacts at rest using Amazon S3 server-side encryption.
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)


if not MYPY:
    class MonitoringScheduleMonitoringOutputArgsDict(TypedDict):
        """
        The output object for a monitoring job.
        """
        s3_output: pulumi.Input['MonitoringScheduleS3OutputArgsDict']
        """
        The Amazon S3 storage location where the results of a monitoring job are saved.
        """
elif False:
    MonitoringScheduleMonitoringOutputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringScheduleMonitoringOutputArgs:
    def __init__(__self__, *,
                 s3_output: pulumi.Input['MonitoringScheduleS3OutputArgs']):
        """
        The output object for a monitoring job.
        :param pulumi.Input['MonitoringScheduleS3OutputArgs'] s3_output: The Amazon S3 storage location where the results of a monitoring job are saved.
        """
        pulumi.set(__self__, "s3_output", s3_output)

    @property
    @pulumi.getter(name="s3Output")
    def s3_output(self) -> pulumi.Input['MonitoringScheduleS3OutputArgs']:
        """
        The Amazon S3 storage location where the results of a monitoring job are saved.
        """
        return pulumi.get(self, "s3_output")

    @s3_output.setter
    def s3_output(self, value: pulumi.Input['MonitoringScheduleS3OutputArgs']):
        pulumi.set(self, "s3_output", value)


if not MYPY:
    class MonitoringScheduleMonitoringResourcesArgsDict(TypedDict):
        """
        Identifies the resources to deploy for a monitoring job.
        """
        cluster_config: pulumi.Input['MonitoringScheduleClusterConfigArgsDict']
        """
        The configuration for the cluster resources used to run the processing job.
        """
elif False:
    MonitoringScheduleMonitoringResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringScheduleMonitoringResourcesArgs:
    def __init__(__self__, *,
                 cluster_config: pulumi.Input['MonitoringScheduleClusterConfigArgs']):
        """
        Identifies the resources to deploy for a monitoring job.
        :param pulumi.Input['MonitoringScheduleClusterConfigArgs'] cluster_config: The configuration for the cluster resources used to run the processing job.
        """
        pulumi.set(__self__, "cluster_config", cluster_config)

    @property
    @pulumi.getter(name="clusterConfig")
    def cluster_config(self) -> pulumi.Input['MonitoringScheduleClusterConfigArgs']:
        """
        The configuration for the cluster resources used to run the processing job.
        """
        return pulumi.get(self, "cluster_config")

    @cluster_config.setter
    def cluster_config(self, value: pulumi.Input['MonitoringScheduleClusterConfigArgs']):
        pulumi.set(self, "cluster_config", value)


if not MYPY:
    class MonitoringScheduleNetworkConfigArgsDict(TypedDict):
        """
        Networking options for a job, such as network traffic encryption between containers, whether to allow inbound and outbound network calls to and from containers, and the VPC subnets and security groups to use for VPC-enabled jobs.
        """
        enable_inter_container_traffic_encryption: NotRequired[pulumi.Input[bool]]
        """
        Whether to encrypt all communications between distributed processing jobs. Choose True to encrypt communications. Encryption provides greater security for distributed processing jobs, but the processing might take longer.
        """
        enable_network_isolation: NotRequired[pulumi.Input[bool]]
        """
        Whether to allow inbound and outbound network calls to and from the containers used for the processing job.
        """
        vpc_config: NotRequired[pulumi.Input['MonitoringScheduleVpcConfigArgsDict']]
        """
        Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC. For more information, see [Protect Endpoints by Using an Amazon Virtual Private Cloud](https://docs.aws.amazon.com/sagemaker/latest/dg/host-vpc.html) and [Protect Training Jobs by Using an Amazon Virtual Private Cloud](https://docs.aws.amazon.com/sagemaker/latest/dg/train-vpc.html) .
        """
elif False:
    MonitoringScheduleNetworkConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringScheduleNetworkConfigArgs:
    def __init__(__self__, *,
                 enable_inter_container_traffic_encryption: Optional[pulumi.Input[bool]] = None,
                 enable_network_isolation: Optional[pulumi.Input[bool]] = None,
                 vpc_config: Optional[pulumi.Input['MonitoringScheduleVpcConfigArgs']] = None):
        """
        Networking options for a job, such as network traffic encryption between containers, whether to allow inbound and outbound network calls to and from containers, and the VPC subnets and security groups to use for VPC-enabled jobs.
        :param pulumi.Input[bool] enable_inter_container_traffic_encryption: Whether to encrypt all communications between distributed processing jobs. Choose True to encrypt communications. Encryption provides greater security for distributed processing jobs, but the processing might take longer.
        :param pulumi.Input[bool] enable_network_isolation: Whether to allow inbound and outbound network calls to and from the containers used for the processing job.
        :param pulumi.Input['MonitoringScheduleVpcConfigArgs'] vpc_config: Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC. For more information, see [Protect Endpoints by Using an Amazon Virtual Private Cloud](https://docs.aws.amazon.com/sagemaker/latest/dg/host-vpc.html) and [Protect Training Jobs by Using an Amazon Virtual Private Cloud](https://docs.aws.amazon.com/sagemaker/latest/dg/train-vpc.html) .
        """
        if enable_inter_container_traffic_encryption is not None:
            pulumi.set(__self__, "enable_inter_container_traffic_encryption", enable_inter_container_traffic_encryption)
        if enable_network_isolation is not None:
            pulumi.set(__self__, "enable_network_isolation", enable_network_isolation)
        if vpc_config is not None:
            pulumi.set(__self__, "vpc_config", vpc_config)

    @property
    @pulumi.getter(name="enableInterContainerTrafficEncryption")
    def enable_inter_container_traffic_encryption(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to encrypt all communications between distributed processing jobs. Choose True to encrypt communications. Encryption provides greater security for distributed processing jobs, but the processing might take longer.
        """
        return pulumi.get(self, "enable_inter_container_traffic_encryption")

    @enable_inter_container_traffic_encryption.setter
    def enable_inter_container_traffic_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_inter_container_traffic_encryption", value)

    @property
    @pulumi.getter(name="enableNetworkIsolation")
    def enable_network_isolation(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to allow inbound and outbound network calls to and from the containers used for the processing job.
        """
        return pulumi.get(self, "enable_network_isolation")

    @enable_network_isolation.setter
    def enable_network_isolation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_network_isolation", value)

    @property
    @pulumi.getter(name="vpcConfig")
    def vpc_config(self) -> Optional[pulumi.Input['MonitoringScheduleVpcConfigArgs']]:
        """
        Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC. For more information, see [Protect Endpoints by Using an Amazon Virtual Private Cloud](https://docs.aws.amazon.com/sagemaker/latest/dg/host-vpc.html) and [Protect Training Jobs by Using an Amazon Virtual Private Cloud](https://docs.aws.amazon.com/sagemaker/latest/dg/train-vpc.html) .
        """
        return pulumi.get(self, "vpc_config")

    @vpc_config.setter
    def vpc_config(self, value: Optional[pulumi.Input['MonitoringScheduleVpcConfigArgs']]):
        pulumi.set(self, "vpc_config", value)


if not MYPY:
    class MonitoringScheduleS3OutputArgsDict(TypedDict):
        """
        Information about where and how to store the results of a monitoring job.
        """
        local_path: pulumi.Input[str]
        """
        The local path to the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job. LocalPath is an absolute path for the output data.
        """
        s3_uri: pulumi.Input[str]
        """
        A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
        """
        s3_upload_mode: NotRequired[pulumi.Input['MonitoringScheduleS3OutputS3UploadMode']]
        """
        Whether to upload the results of the monitoring job continuously or after the job completes.
        """
elif False:
    MonitoringScheduleS3OutputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringScheduleS3OutputArgs:
    def __init__(__self__, *,
                 local_path: pulumi.Input[str],
                 s3_uri: pulumi.Input[str],
                 s3_upload_mode: Optional[pulumi.Input['MonitoringScheduleS3OutputS3UploadMode']] = None):
        """
        Information about where and how to store the results of a monitoring job.
        :param pulumi.Input[str] local_path: The local path to the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job. LocalPath is an absolute path for the output data.
        :param pulumi.Input[str] s3_uri: A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
        :param pulumi.Input['MonitoringScheduleS3OutputS3UploadMode'] s3_upload_mode: Whether to upload the results of the monitoring job continuously or after the job completes.
        """
        pulumi.set(__self__, "local_path", local_path)
        pulumi.set(__self__, "s3_uri", s3_uri)
        if s3_upload_mode is not None:
            pulumi.set(__self__, "s3_upload_mode", s3_upload_mode)

    @property
    @pulumi.getter(name="localPath")
    def local_path(self) -> pulumi.Input[str]:
        """
        The local path to the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job. LocalPath is an absolute path for the output data.
        """
        return pulumi.get(self, "local_path")

    @local_path.setter
    def local_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "local_path", value)

    @property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> pulumi.Input[str]:
        """
        A URI that identifies the Amazon S3 storage location where Amazon SageMaker saves the results of a monitoring job.
        """
        return pulumi.get(self, "s3_uri")

    @s3_uri.setter
    def s3_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "s3_uri", value)

    @property
    @pulumi.getter(name="s3UploadMode")
    def s3_upload_mode(self) -> Optional[pulumi.Input['MonitoringScheduleS3OutputS3UploadMode']]:
        """
        Whether to upload the results of the monitoring job continuously or after the job completes.
        """
        return pulumi.get(self, "s3_upload_mode")

    @s3_upload_mode.setter
    def s3_upload_mode(self, value: Optional[pulumi.Input['MonitoringScheduleS3OutputS3UploadMode']]):
        pulumi.set(self, "s3_upload_mode", value)


if not MYPY:
    class MonitoringScheduleScheduleConfigArgsDict(TypedDict):
        """
        Configuration details about the monitoring schedule.
        """
        schedule_expression: pulumi.Input[str]
        """
        A cron expression or 'NOW' that describes details about the monitoring schedule.
        """
        data_analysis_end_time: NotRequired[pulumi.Input[str]]
        """
        Data Analysis end time, e.g. PT0H
        """
        data_analysis_start_time: NotRequired[pulumi.Input[str]]
        """
        Data Analysis start time, e.g. -PT1H
        """
elif False:
    MonitoringScheduleScheduleConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringScheduleScheduleConfigArgs:
    def __init__(__self__, *,
                 schedule_expression: pulumi.Input[str],
                 data_analysis_end_time: Optional[pulumi.Input[str]] = None,
                 data_analysis_start_time: Optional[pulumi.Input[str]] = None):
        """
        Configuration details about the monitoring schedule.
        :param pulumi.Input[str] schedule_expression: A cron expression or 'NOW' that describes details about the monitoring schedule.
        :param pulumi.Input[str] data_analysis_end_time: Data Analysis end time, e.g. PT0H
        :param pulumi.Input[str] data_analysis_start_time: Data Analysis start time, e.g. -PT1H
        """
        pulumi.set(__self__, "schedule_expression", schedule_expression)
        if data_analysis_end_time is not None:
            pulumi.set(__self__, "data_analysis_end_time", data_analysis_end_time)
        if data_analysis_start_time is not None:
            pulumi.set(__self__, "data_analysis_start_time", data_analysis_start_time)

    @property
    @pulumi.getter(name="scheduleExpression")
    def schedule_expression(self) -> pulumi.Input[str]:
        """
        A cron expression or 'NOW' that describes details about the monitoring schedule.
        """
        return pulumi.get(self, "schedule_expression")

    @schedule_expression.setter
    def schedule_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "schedule_expression", value)

    @property
    @pulumi.getter(name="dataAnalysisEndTime")
    def data_analysis_end_time(self) -> Optional[pulumi.Input[str]]:
        """
        Data Analysis end time, e.g. PT0H
        """
        return pulumi.get(self, "data_analysis_end_time")

    @data_analysis_end_time.setter
    def data_analysis_end_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_analysis_end_time", value)

    @property
    @pulumi.getter(name="dataAnalysisStartTime")
    def data_analysis_start_time(self) -> Optional[pulumi.Input[str]]:
        """
        Data Analysis start time, e.g. -PT1H
        """
        return pulumi.get(self, "data_analysis_start_time")

    @data_analysis_start_time.setter
    def data_analysis_start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_analysis_start_time", value)


if not MYPY:
    class MonitoringScheduleStatisticsResourceArgsDict(TypedDict):
        """
        The baseline statistics resource for a monitoring job.
        """
        s3_uri: NotRequired[pulumi.Input[str]]
        """
        The Amazon S3 URI for the baseline statistics file in Amazon S3 that the current monitoring job should be validated against.
        """
elif False:
    MonitoringScheduleStatisticsResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringScheduleStatisticsResourceArgs:
    def __init__(__self__, *,
                 s3_uri: Optional[pulumi.Input[str]] = None):
        """
        The baseline statistics resource for a monitoring job.
        :param pulumi.Input[str] s3_uri: The Amazon S3 URI for the baseline statistics file in Amazon S3 that the current monitoring job should be validated against.
        """
        if s3_uri is not None:
            pulumi.set(__self__, "s3_uri", s3_uri)

    @property
    @pulumi.getter(name="s3Uri")
    def s3_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon S3 URI for the baseline statistics file in Amazon S3 that the current monitoring job should be validated against.
        """
        return pulumi.get(self, "s3_uri")

    @s3_uri.setter
    def s3_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_uri", value)


if not MYPY:
    class MonitoringScheduleStoppingConditionArgsDict(TypedDict):
        """
        Specifies a time limit for how long the monitoring job is allowed to run.
        """
        max_runtime_in_seconds: pulumi.Input[int]
        """
        The maximum runtime allowed in seconds.
        """
elif False:
    MonitoringScheduleStoppingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringScheduleStoppingConditionArgs:
    def __init__(__self__, *,
                 max_runtime_in_seconds: pulumi.Input[int]):
        """
        Specifies a time limit for how long the monitoring job is allowed to run.
        :param pulumi.Input[int] max_runtime_in_seconds: The maximum runtime allowed in seconds.
        """
        pulumi.set(__self__, "max_runtime_in_seconds", max_runtime_in_seconds)

    @property
    @pulumi.getter(name="maxRuntimeInSeconds")
    def max_runtime_in_seconds(self) -> pulumi.Input[int]:
        """
        The maximum runtime allowed in seconds.
        """
        return pulumi.get(self, "max_runtime_in_seconds")

    @max_runtime_in_seconds.setter
    def max_runtime_in_seconds(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_runtime_in_seconds", value)


if not MYPY:
    class MonitoringScheduleVpcConfigArgsDict(TypedDict):
        """
        Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC.
        """
        security_group_ids: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the Subnets field.
        """
        subnets: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The ID of the subnets in the VPC to which you want to connect to your monitoring jobs.
        """
elif False:
    MonitoringScheduleVpcConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoringScheduleVpcConfigArgs:
    def __init__(__self__, *,
                 security_group_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 subnets: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        Specifies a VPC that your training jobs and hosted models have access to. Control access to and from your training and model containers by configuring the VPC.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_group_ids: The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the Subnets field.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subnets: The ID of the subnets in the VPC to which you want to connect to your monitoring jobs.
        """
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnets", subnets)

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The VPC security group IDs, in the form sg-xxxxxxxx. Specify the security groups for the VPC that is specified in the Subnets field.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "security_group_ids", value)

    @property
    @pulumi.getter
    def subnets(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The ID of the subnets in the VPC to which you want to connect to your monitoring jobs.
        """
        return pulumi.get(self, "subnets")

    @subnets.setter
    def subnets(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "subnets", value)


if not MYPY:
    class OfflineStoreConfigPropertiesArgsDict(TypedDict):
        """
        The configuration of an `OfflineStore` .
        """
        s3_storage_config: pulumi.Input['FeatureGroupS3StorageConfigArgsDict']
        """
        The Amazon Simple Storage (Amazon S3) location of `OfflineStore` .
        """
        data_catalog_config: NotRequired[pulumi.Input['FeatureGroupDataCatalogConfigArgsDict']]
        """
        The meta data of the Glue table that is autogenerated when an `OfflineStore` is created.
        """
        disable_glue_table_creation: NotRequired[pulumi.Input[bool]]
        """
        Set to `True` to disable the automatic creation of an AWS Glue table when configuring an `OfflineStore` . If set to `False` , Feature Store will name the `OfflineStore` Glue table following [Athena's naming recommendations](https://docs.aws.amazon.com/athena/latest/ug/tables-databases-columns-names.html) .

        The default value is `False` .
        """
        table_format: NotRequired[pulumi.Input['FeatureGroupTableFormat']]
        """
        Format for the offline store table. Supported formats are Glue (Default) and [Apache Iceberg](https://docs.aws.amazon.com/https://iceberg.apache.org/) .
        """
elif False:
    OfflineStoreConfigPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OfflineStoreConfigPropertiesArgs:
    def __init__(__self__, *,
                 s3_storage_config: pulumi.Input['FeatureGroupS3StorageConfigArgs'],
                 data_catalog_config: Optional[pulumi.Input['FeatureGroupDataCatalogConfigArgs']] = None,
                 disable_glue_table_creation: Optional[pulumi.Input[bool]] = None,
                 table_format: Optional[pulumi.Input['FeatureGroupTableFormat']] = None):
        """
        The configuration of an `OfflineStore` .
        :param pulumi.Input['FeatureGroupS3StorageConfigArgs'] s3_storage_config: The Amazon Simple Storage (Amazon S3) location of `OfflineStore` .
        :param pulumi.Input['FeatureGroupDataCatalogConfigArgs'] data_catalog_config: The meta data of the Glue table that is autogenerated when an `OfflineStore` is created.
        :param pulumi.Input[bool] disable_glue_table_creation: Set to `True` to disable the automatic creation of an AWS Glue table when configuring an `OfflineStore` . If set to `False` , Feature Store will name the `OfflineStore` Glue table following [Athena's naming recommendations](https://docs.aws.amazon.com/athena/latest/ug/tables-databases-columns-names.html) .
               
               The default value is `False` .
        :param pulumi.Input['FeatureGroupTableFormat'] table_format: Format for the offline store table. Supported formats are Glue (Default) and [Apache Iceberg](https://docs.aws.amazon.com/https://iceberg.apache.org/) .
        """
        pulumi.set(__self__, "s3_storage_config", s3_storage_config)
        if data_catalog_config is not None:
            pulumi.set(__self__, "data_catalog_config", data_catalog_config)
        if disable_glue_table_creation is not None:
            pulumi.set(__self__, "disable_glue_table_creation", disable_glue_table_creation)
        if table_format is not None:
            pulumi.set(__self__, "table_format", table_format)

    @property
    @pulumi.getter(name="s3StorageConfig")
    def s3_storage_config(self) -> pulumi.Input['FeatureGroupS3StorageConfigArgs']:
        """
        The Amazon Simple Storage (Amazon S3) location of `OfflineStore` .
        """
        return pulumi.get(self, "s3_storage_config")

    @s3_storage_config.setter
    def s3_storage_config(self, value: pulumi.Input['FeatureGroupS3StorageConfigArgs']):
        pulumi.set(self, "s3_storage_config", value)

    @property
    @pulumi.getter(name="dataCatalogConfig")
    def data_catalog_config(self) -> Optional[pulumi.Input['FeatureGroupDataCatalogConfigArgs']]:
        """
        The meta data of the Glue table that is autogenerated when an `OfflineStore` is created.
        """
        return pulumi.get(self, "data_catalog_config")

    @data_catalog_config.setter
    def data_catalog_config(self, value: Optional[pulumi.Input['FeatureGroupDataCatalogConfigArgs']]):
        pulumi.set(self, "data_catalog_config", value)

    @property
    @pulumi.getter(name="disableGlueTableCreation")
    def disable_glue_table_creation(self) -> Optional[pulumi.Input[bool]]:
        """
        Set to `True` to disable the automatic creation of an AWS Glue table when configuring an `OfflineStore` . If set to `False` , Feature Store will name the `OfflineStore` Glue table following [Athena's naming recommendations](https://docs.aws.amazon.com/athena/latest/ug/tables-databases-columns-names.html) .

        The default value is `False` .
        """
        return pulumi.get(self, "disable_glue_table_creation")

    @disable_glue_table_creation.setter
    def disable_glue_table_creation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_glue_table_creation", value)

    @property
    @pulumi.getter(name="tableFormat")
    def table_format(self) -> Optional[pulumi.Input['FeatureGroupTableFormat']]:
        """
        Format for the offline store table. Supported formats are Glue (Default) and [Apache Iceberg](https://docs.aws.amazon.com/https://iceberg.apache.org/) .
        """
        return pulumi.get(self, "table_format")

    @table_format.setter
    def table_format(self, value: Optional[pulumi.Input['FeatureGroupTableFormat']]):
        pulumi.set(self, "table_format", value)


if not MYPY:
    class OnlineStoreConfigPropertiesArgsDict(TypedDict):
        """
        The configuration of an `OnlineStore` .
        """
        enable_online_store: NotRequired[pulumi.Input[bool]]
        """
        Turn `OnlineStore` off by specifying `False` for the `EnableOnlineStore` flag. Turn `OnlineStore` on by specifying `True` for the `EnableOnlineStore` flag.

        The default value is `False` .
        """
        security_config: NotRequired[pulumi.Input['FeatureGroupOnlineStoreSecurityConfigArgsDict']]
        """
        Use to specify KMS Key ID ( `KMSKeyId` ) for at-rest encryption of your `OnlineStore` .
        """
        storage_type: NotRequired[pulumi.Input['FeatureGroupStorageType']]
        """
        Option for different tiers of low latency storage for real-time data retrieval.

        - `Standard` : A managed low latency data store for feature groups.
        - `InMemory` : A managed data store for feature groups that supports very low latency retrieval.
        """
        ttl_duration: NotRequired[pulumi.Input['FeatureGroupTtlDurationArgsDict']]
        """
        Time to live duration, where the record is hard deleted after the expiration time is reached; `ExpiresAt` = `EventTime` + `TtlDuration` . For information on HardDelete, see the [DeleteRecord](https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_feature_store_DeleteRecord.html) API in the Amazon SageMaker API Reference guide.
        """
elif False:
    OnlineStoreConfigPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OnlineStoreConfigPropertiesArgs:
    def __init__(__self__, *,
                 enable_online_store: Optional[pulumi.Input[bool]] = None,
                 security_config: Optional[pulumi.Input['FeatureGroupOnlineStoreSecurityConfigArgs']] = None,
                 storage_type: Optional[pulumi.Input['FeatureGroupStorageType']] = None,
                 ttl_duration: Optional[pulumi.Input['FeatureGroupTtlDurationArgs']] = None):
        """
        The configuration of an `OnlineStore` .
        :param pulumi.Input[bool] enable_online_store: Turn `OnlineStore` off by specifying `False` for the `EnableOnlineStore` flag. Turn `OnlineStore` on by specifying `True` for the `EnableOnlineStore` flag.
               
               The default value is `False` .
        :param pulumi.Input['FeatureGroupOnlineStoreSecurityConfigArgs'] security_config: Use to specify KMS Key ID ( `KMSKeyId` ) for at-rest encryption of your `OnlineStore` .
        :param pulumi.Input['FeatureGroupStorageType'] storage_type: Option for different tiers of low latency storage for real-time data retrieval.
               
               - `Standard` : A managed low latency data store for feature groups.
               - `InMemory` : A managed data store for feature groups that supports very low latency retrieval.
        :param pulumi.Input['FeatureGroupTtlDurationArgs'] ttl_duration: Time to live duration, where the record is hard deleted after the expiration time is reached; `ExpiresAt` = `EventTime` + `TtlDuration` . For information on HardDelete, see the [DeleteRecord](https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_feature_store_DeleteRecord.html) API in the Amazon SageMaker API Reference guide.
        """
        if enable_online_store is not None:
            pulumi.set(__self__, "enable_online_store", enable_online_store)
        if security_config is not None:
            pulumi.set(__self__, "security_config", security_config)
        if storage_type is not None:
            pulumi.set(__self__, "storage_type", storage_type)
        if ttl_duration is not None:
            pulumi.set(__self__, "ttl_duration", ttl_duration)

    @property
    @pulumi.getter(name="enableOnlineStore")
    def enable_online_store(self) -> Optional[pulumi.Input[bool]]:
        """
        Turn `OnlineStore` off by specifying `False` for the `EnableOnlineStore` flag. Turn `OnlineStore` on by specifying `True` for the `EnableOnlineStore` flag.

        The default value is `False` .
        """
        return pulumi.get(self, "enable_online_store")

    @enable_online_store.setter
    def enable_online_store(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_online_store", value)

    @property
    @pulumi.getter(name="securityConfig")
    def security_config(self) -> Optional[pulumi.Input['FeatureGroupOnlineStoreSecurityConfigArgs']]:
        """
        Use to specify KMS Key ID ( `KMSKeyId` ) for at-rest encryption of your `OnlineStore` .
        """
        return pulumi.get(self, "security_config")

    @security_config.setter
    def security_config(self, value: Optional[pulumi.Input['FeatureGroupOnlineStoreSecurityConfigArgs']]):
        pulumi.set(self, "security_config", value)

    @property
    @pulumi.getter(name="storageType")
    def storage_type(self) -> Optional[pulumi.Input['FeatureGroupStorageType']]:
        """
        Option for different tiers of low latency storage for real-time data retrieval.

        - `Standard` : A managed low latency data store for feature groups.
        - `InMemory` : A managed data store for feature groups that supports very low latency retrieval.
        """
        return pulumi.get(self, "storage_type")

    @storage_type.setter
    def storage_type(self, value: Optional[pulumi.Input['FeatureGroupStorageType']]):
        pulumi.set(self, "storage_type", value)

    @property
    @pulumi.getter(name="ttlDuration")
    def ttl_duration(self) -> Optional[pulumi.Input['FeatureGroupTtlDurationArgs']]:
        """
        Time to live duration, where the record is hard deleted after the expiration time is reached; `ExpiresAt` = `EventTime` + `TtlDuration` . For information on HardDelete, see the [DeleteRecord](https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_feature_store_DeleteRecord.html) API in the Amazon SageMaker API Reference guide.
        """
        return pulumi.get(self, "ttl_duration")

    @ttl_duration.setter
    def ttl_duration(self, value: Optional[pulumi.Input['FeatureGroupTtlDurationArgs']]):
        pulumi.set(self, "ttl_duration", value)


if not MYPY:
    class ParallelismConfigurationPropertiesArgsDict(TypedDict):
        """
        The parallelism configuration applied to the pipeline.
        """
        max_parallel_execution_steps: pulumi.Input[int]
        """
        Maximum parallel execution steps
        """
elif False:
    ParallelismConfigurationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ParallelismConfigurationPropertiesArgs:
    def __init__(__self__, *,
                 max_parallel_execution_steps: pulumi.Input[int]):
        """
        The parallelism configuration applied to the pipeline.
        :param pulumi.Input[int] max_parallel_execution_steps: Maximum parallel execution steps
        """
        pulumi.set(__self__, "max_parallel_execution_steps", max_parallel_execution_steps)

    @property
    @pulumi.getter(name="maxParallelExecutionSteps")
    def max_parallel_execution_steps(self) -> pulumi.Input[int]:
        """
        Maximum parallel execution steps
        """
        return pulumi.get(self, "max_parallel_execution_steps")

    @max_parallel_execution_steps.setter
    def max_parallel_execution_steps(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_parallel_execution_steps", value)


if not MYPY:
    class PipelineDefinition0PropertiesArgsDict(TypedDict):
        """
        The definition of the pipeline. This can be either a JSON string or an Amazon S3 location.
        """
        pipeline_definition_body: pulumi.Input[str]
        """
        A specification that defines the pipeline in JSON format.
        """
elif False:
    PipelineDefinition0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineDefinition0PropertiesArgs:
    def __init__(__self__, *,
                 pipeline_definition_body: pulumi.Input[str]):
        """
        The definition of the pipeline. This can be either a JSON string or an Amazon S3 location.
        :param pulumi.Input[str] pipeline_definition_body: A specification that defines the pipeline in JSON format.
        """
        pulumi.set(__self__, "pipeline_definition_body", pipeline_definition_body)

    @property
    @pulumi.getter(name="pipelineDefinitionBody")
    def pipeline_definition_body(self) -> pulumi.Input[str]:
        """
        A specification that defines the pipeline in JSON format.
        """
        return pulumi.get(self, "pipeline_definition_body")

    @pipeline_definition_body.setter
    def pipeline_definition_body(self, value: pulumi.Input[str]):
        pulumi.set(self, "pipeline_definition_body", value)


if not MYPY:
    class PipelineDefinition1PropertiesArgsDict(TypedDict):
        """
        The definition of the pipeline. This can be either a JSON string or an Amazon S3 location.
        """
        pipeline_definition_s3_location: pulumi.Input['PipelineS3LocationArgsDict']
elif False:
    PipelineDefinition1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineDefinition1PropertiesArgs:
    def __init__(__self__, *,
                 pipeline_definition_s3_location: pulumi.Input['PipelineS3LocationArgs']):
        """
        The definition of the pipeline. This can be either a JSON string or an Amazon S3 location.
        """
        pulumi.set(__self__, "pipeline_definition_s3_location", pipeline_definition_s3_location)

    @property
    @pulumi.getter(name="pipelineDefinitionS3Location")
    def pipeline_definition_s3_location(self) -> pulumi.Input['PipelineS3LocationArgs']:
        return pulumi.get(self, "pipeline_definition_s3_location")

    @pipeline_definition_s3_location.setter
    def pipeline_definition_s3_location(self, value: pulumi.Input['PipelineS3LocationArgs']):
        pulumi.set(self, "pipeline_definition_s3_location", value)


if not MYPY:
    class PipelineS3LocationArgsDict(TypedDict):
        bucket: pulumi.Input[str]
        """
        The name of the S3 bucket where the PipelineDefinition file is stored.
        """
        key: pulumi.Input[str]
        """
        The file name of the PipelineDefinition file (Amazon S3 object name).
        """
        e_tag: NotRequired[pulumi.Input[str]]
        """
        The Amazon S3 ETag (a file checksum) of the PipelineDefinition file. If you don't specify a value, SageMaker skips ETag validation of your PipelineDefinition file.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        For versioning-enabled buckets, a specific version of the PipelineDefinition file.
        """
elif False:
    PipelineS3LocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineS3LocationArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 key: pulumi.Input[str],
                 e_tag: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bucket: The name of the S3 bucket where the PipelineDefinition file is stored.
        :param pulumi.Input[str] key: The file name of the PipelineDefinition file (Amazon S3 object name).
        :param pulumi.Input[str] e_tag: The Amazon S3 ETag (a file checksum) of the PipelineDefinition file. If you don't specify a value, SageMaker skips ETag validation of your PipelineDefinition file.
        :param pulumi.Input[str] version: For versioning-enabled buckets, a specific version of the PipelineDefinition file.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "key", key)
        if e_tag is not None:
            pulumi.set(__self__, "e_tag", e_tag)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        The name of the S3 bucket where the PipelineDefinition file is stored.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The file name of the PipelineDefinition file (Amazon S3 object name).
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="eTag")
    def e_tag(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon S3 ETag (a file checksum) of the PipelineDefinition file. If you don't specify a value, SageMaker skips ETag validation of your PipelineDefinition file.
        """
        return pulumi.get(self, "e_tag")

    @e_tag.setter
    def e_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "e_tag", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        For versioning-enabled buckets, a specific version of the PipelineDefinition file.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class ProjectProvisioningParameterArgsDict(TypedDict):
        """
        Information about a parameter used to provision a product.
        """
        key: pulumi.Input[str]
        """
        The parameter key.
        """
        value: pulumi.Input[str]
        """
        The parameter value.
        """
elif False:
    ProjectProvisioningParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProjectProvisioningParameterArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        Information about a parameter used to provision a product.
        :param pulumi.Input[str] key: The parameter key.
        :param pulumi.Input[str] value: The parameter value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The parameter key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The parameter value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ServiceCatalogProvisionedProductDetailsPropertiesArgsDict(TypedDict):
        """
        Provisioned ServiceCatalog  Details
        """
        provisioned_product_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the provisioned product.
        """
        provisioned_product_status_message: NotRequired[pulumi.Input[str]]
        """
        The current status of the product.

        - `AVAILABLE` - Stable state, ready to perform any operation. The most recent operation succeeded and completed.
        - `UNDER_CHANGE` - Transitive state. Operations performed might not have valid results. Wait for an AVAILABLE status before performing operations.
        - `TAINTED` - Stable state, ready to perform any operation. The stack has completed the requested operation but is not exactly what was requested. For example, a request to update to a new version failed and the stack rolled back to the current version.
        - `ERROR` - An unexpected error occurred. The provisioned product exists but the stack is not running. For example, CloudFormation received a parameter value that was not valid and could not launch the stack.
        - `PLAN_IN_PROGRESS` - Transitive state. The plan operations were performed to provision a new product, but resources have not yet been created. After reviewing the list of resources to be created, execute the plan. Wait for an AVAILABLE status before performing operations.
        """
elif False:
    ServiceCatalogProvisionedProductDetailsPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceCatalogProvisionedProductDetailsPropertiesArgs:
    def __init__(__self__, *,
                 provisioned_product_id: Optional[pulumi.Input[str]] = None,
                 provisioned_product_status_message: Optional[pulumi.Input[str]] = None):
        """
        Provisioned ServiceCatalog  Details
        :param pulumi.Input[str] provisioned_product_id: The ID of the provisioned product.
        :param pulumi.Input[str] provisioned_product_status_message: The current status of the product.
               
               - `AVAILABLE` - Stable state, ready to perform any operation. The most recent operation succeeded and completed.
               - `UNDER_CHANGE` - Transitive state. Operations performed might not have valid results. Wait for an AVAILABLE status before performing operations.
               - `TAINTED` - Stable state, ready to perform any operation. The stack has completed the requested operation but is not exactly what was requested. For example, a request to update to a new version failed and the stack rolled back to the current version.
               - `ERROR` - An unexpected error occurred. The provisioned product exists but the stack is not running. For example, CloudFormation received a parameter value that was not valid and could not launch the stack.
               - `PLAN_IN_PROGRESS` - Transitive state. The plan operations were performed to provision a new product, but resources have not yet been created. After reviewing the list of resources to be created, execute the plan. Wait for an AVAILABLE status before performing operations.
        """
        if provisioned_product_id is not None:
            pulumi.set(__self__, "provisioned_product_id", provisioned_product_id)
        if provisioned_product_status_message is not None:
            pulumi.set(__self__, "provisioned_product_status_message", provisioned_product_status_message)

    @property
    @pulumi.getter(name="provisionedProductId")
    def provisioned_product_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the provisioned product.
        """
        return pulumi.get(self, "provisioned_product_id")

    @provisioned_product_id.setter
    def provisioned_product_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "provisioned_product_id", value)

    @property
    @pulumi.getter(name="provisionedProductStatusMessage")
    def provisioned_product_status_message(self) -> Optional[pulumi.Input[str]]:
        """
        The current status of the product.

        - `AVAILABLE` - Stable state, ready to perform any operation. The most recent operation succeeded and completed.
        - `UNDER_CHANGE` - Transitive state. Operations performed might not have valid results. Wait for an AVAILABLE status before performing operations.
        - `TAINTED` - Stable state, ready to perform any operation. The stack has completed the requested operation but is not exactly what was requested. For example, a request to update to a new version failed and the stack rolled back to the current version.
        - `ERROR` - An unexpected error occurred. The provisioned product exists but the stack is not running. For example, CloudFormation received a parameter value that was not valid and could not launch the stack.
        - `PLAN_IN_PROGRESS` - Transitive state. The plan operations were performed to provision a new product, but resources have not yet been created. After reviewing the list of resources to be created, execute the plan. Wait for an AVAILABLE status before performing operations.
        """
        return pulumi.get(self, "provisioned_product_status_message")

    @provisioned_product_status_message.setter
    def provisioned_product_status_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "provisioned_product_status_message", value)


if not MYPY:
    class ServiceCatalogProvisioningDetailsPropertiesArgsDict(TypedDict):
        """
        Input ServiceCatalog Provisioning Details
        """
        product_id: pulumi.Input[str]
        """
        The ID of the product to provision.
        """
        path_id: NotRequired[pulumi.Input[str]]
        """
        The path identifier of the product. This value is optional if the product has a default path, and required if the product has more than one path.
        """
        provisioning_artifact_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the provisioning artifact.
        """
        provisioning_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['ProjectProvisioningParameterArgsDict']]]]
        """
        Parameters specified by the administrator that are required for provisioning the product.
        """
elif False:
    ServiceCatalogProvisioningDetailsPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceCatalogProvisioningDetailsPropertiesArgs:
    def __init__(__self__, *,
                 product_id: pulumi.Input[str],
                 path_id: Optional[pulumi.Input[str]] = None,
                 provisioning_artifact_id: Optional[pulumi.Input[str]] = None,
                 provisioning_parameters: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectProvisioningParameterArgs']]]] = None):
        """
        Input ServiceCatalog Provisioning Details
        :param pulumi.Input[str] product_id: The ID of the product to provision.
        :param pulumi.Input[str] path_id: The path identifier of the product. This value is optional if the product has a default path, and required if the product has more than one path.
        :param pulumi.Input[str] provisioning_artifact_id: The ID of the provisioning artifact.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectProvisioningParameterArgs']]] provisioning_parameters: Parameters specified by the administrator that are required for provisioning the product.
        """
        pulumi.set(__self__, "product_id", product_id)
        if path_id is not None:
            pulumi.set(__self__, "path_id", path_id)
        if provisioning_artifact_id is not None:
            pulumi.set(__self__, "provisioning_artifact_id", provisioning_artifact_id)
        if provisioning_parameters is not None:
            pulumi.set(__self__, "provisioning_parameters", provisioning_parameters)

    @property
    @pulumi.getter(name="productId")
    def product_id(self) -> pulumi.Input[str]:
        """
        The ID of the product to provision.
        """
        return pulumi.get(self, "product_id")

    @product_id.setter
    def product_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "product_id", value)

    @property
    @pulumi.getter(name="pathId")
    def path_id(self) -> Optional[pulumi.Input[str]]:
        """
        The path identifier of the product. This value is optional if the product has a default path, and required if the product has more than one path.
        """
        return pulumi.get(self, "path_id")

    @path_id.setter
    def path_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path_id", value)

    @property
    @pulumi.getter(name="provisioningArtifactId")
    def provisioning_artifact_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the provisioning artifact.
        """
        return pulumi.get(self, "provisioning_artifact_id")

    @provisioning_artifact_id.setter
    def provisioning_artifact_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "provisioning_artifact_id", value)

    @property
    @pulumi.getter(name="provisioningParameters")
    def provisioning_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectProvisioningParameterArgs']]]]:
        """
        Parameters specified by the administrator that are required for provisioning the product.
        """
        return pulumi.get(self, "provisioning_parameters")

    @provisioning_parameters.setter
    def provisioning_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectProvisioningParameterArgs']]]]):
        pulumi.set(self, "provisioning_parameters", value)


if not MYPY:
    class SpaceAppLifecycleManagementArgsDict(TypedDict):
        idle_settings: NotRequired[pulumi.Input['SpaceIdleSettingsArgsDict']]
        """
        Settings related to idle shutdown of Studio applications.
        """
elif False:
    SpaceAppLifecycleManagementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpaceAppLifecycleManagementArgs:
    def __init__(__self__, *,
                 idle_settings: Optional[pulumi.Input['SpaceIdleSettingsArgs']] = None):
        """
        :param pulumi.Input['SpaceIdleSettingsArgs'] idle_settings: Settings related to idle shutdown of Studio applications.
        """
        if idle_settings is not None:
            pulumi.set(__self__, "idle_settings", idle_settings)

    @property
    @pulumi.getter(name="idleSettings")
    def idle_settings(self) -> Optional[pulumi.Input['SpaceIdleSettingsArgs']]:
        """
        Settings related to idle shutdown of Studio applications.
        """
        return pulumi.get(self, "idle_settings")

    @idle_settings.setter
    def idle_settings(self, value: Optional[pulumi.Input['SpaceIdleSettingsArgs']]):
        pulumi.set(self, "idle_settings", value)


if not MYPY:
    class SpaceCodeEditorAppSettingsArgsDict(TypedDict):
        """
        The CodeEditor app settings.
        """
        app_lifecycle_management: NotRequired[pulumi.Input['SpaceAppLifecycleManagementArgsDict']]
        """
        Settings that are used to configure and manage the lifecycle of CodeEditor applications in a space.
        """
        default_resource_spec: NotRequired[pulumi.Input['SpaceResourceSpecArgsDict']]
        """
        Specifies the ARNs of a SageMaker image and SageMaker image version, and the instance type that the version runs on.
        """
elif False:
    SpaceCodeEditorAppSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpaceCodeEditorAppSettingsArgs:
    def __init__(__self__, *,
                 app_lifecycle_management: Optional[pulumi.Input['SpaceAppLifecycleManagementArgs']] = None,
                 default_resource_spec: Optional[pulumi.Input['SpaceResourceSpecArgs']] = None):
        """
        The CodeEditor app settings.
        :param pulumi.Input['SpaceAppLifecycleManagementArgs'] app_lifecycle_management: Settings that are used to configure and manage the lifecycle of CodeEditor applications in a space.
        :param pulumi.Input['SpaceResourceSpecArgs'] default_resource_spec: Specifies the ARNs of a SageMaker image and SageMaker image version, and the instance type that the version runs on.
        """
        if app_lifecycle_management is not None:
            pulumi.set(__self__, "app_lifecycle_management", app_lifecycle_management)
        if default_resource_spec is not None:
            pulumi.set(__self__, "default_resource_spec", default_resource_spec)

    @property
    @pulumi.getter(name="appLifecycleManagement")
    def app_lifecycle_management(self) -> Optional[pulumi.Input['SpaceAppLifecycleManagementArgs']]:
        """
        Settings that are used to configure and manage the lifecycle of CodeEditor applications in a space.
        """
        return pulumi.get(self, "app_lifecycle_management")

    @app_lifecycle_management.setter
    def app_lifecycle_management(self, value: Optional[pulumi.Input['SpaceAppLifecycleManagementArgs']]):
        pulumi.set(self, "app_lifecycle_management", value)

    @property
    @pulumi.getter(name="defaultResourceSpec")
    def default_resource_spec(self) -> Optional[pulumi.Input['SpaceResourceSpecArgs']]:
        """
        Specifies the ARNs of a SageMaker image and SageMaker image version, and the instance type that the version runs on.
        """
        return pulumi.get(self, "default_resource_spec")

    @default_resource_spec.setter
    def default_resource_spec(self, value: Optional[pulumi.Input['SpaceResourceSpecArgs']]):
        pulumi.set(self, "default_resource_spec", value)


if not MYPY:
    class SpaceCodeRepositoryArgsDict(TypedDict):
        repository_url: pulumi.Input[str]
        """
        A CodeRepository (valid URL) to be used within Jupyter's Git extension.
        """
elif False:
    SpaceCodeRepositoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpaceCodeRepositoryArgs:
    def __init__(__self__, *,
                 repository_url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] repository_url: A CodeRepository (valid URL) to be used within Jupyter's Git extension.
        """
        pulumi.set(__self__, "repository_url", repository_url)

    @property
    @pulumi.getter(name="repositoryUrl")
    def repository_url(self) -> pulumi.Input[str]:
        """
        A CodeRepository (valid URL) to be used within Jupyter's Git extension.
        """
        return pulumi.get(self, "repository_url")

    @repository_url.setter
    def repository_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "repository_url", value)


if not MYPY:
    class SpaceCustomFileSystemArgsDict(TypedDict):
        efs_file_system: NotRequired[pulumi.Input['SpaceEfsFileSystemArgsDict']]
elif False:
    SpaceCustomFileSystemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpaceCustomFileSystemArgs:
    def __init__(__self__, *,
                 efs_file_system: Optional[pulumi.Input['SpaceEfsFileSystemArgs']] = None):
        if efs_file_system is not None:
            pulumi.set(__self__, "efs_file_system", efs_file_system)

    @property
    @pulumi.getter(name="efsFileSystem")
    def efs_file_system(self) -> Optional[pulumi.Input['SpaceEfsFileSystemArgs']]:
        return pulumi.get(self, "efs_file_system")

    @efs_file_system.setter
    def efs_file_system(self, value: Optional[pulumi.Input['SpaceEfsFileSystemArgs']]):
        pulumi.set(self, "efs_file_system", value)


if not MYPY:
    class SpaceCustomImageArgsDict(TypedDict):
        """
        A custom SageMaker image.
        """
        app_image_config_name: pulumi.Input[str]
        """
        The Name of the AppImageConfig.
        """
        image_name: pulumi.Input[str]
        """
        The name of the CustomImage. Must be unique to your account.
        """
        image_version_number: NotRequired[pulumi.Input[int]]
        """
        The version number of the CustomImage.
        """
elif False:
    SpaceCustomImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpaceCustomImageArgs:
    def __init__(__self__, *,
                 app_image_config_name: pulumi.Input[str],
                 image_name: pulumi.Input[str],
                 image_version_number: Optional[pulumi.Input[int]] = None):
        """
        A custom SageMaker image.
        :param pulumi.Input[str] app_image_config_name: The Name of the AppImageConfig.
        :param pulumi.Input[str] image_name: The name of the CustomImage. Must be unique to your account.
        :param pulumi.Input[int] image_version_number: The version number of the CustomImage.
        """
        pulumi.set(__self__, "app_image_config_name", app_image_config_name)
        pulumi.set(__self__, "image_name", image_name)
        if image_version_number is not None:
            pulumi.set(__self__, "image_version_number", image_version_number)

    @property
    @pulumi.getter(name="appImageConfigName")
    def app_image_config_name(self) -> pulumi.Input[str]:
        """
        The Name of the AppImageConfig.
        """
        return pulumi.get(self, "app_image_config_name")

    @app_image_config_name.setter
    def app_image_config_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_image_config_name", value)

    @property
    @pulumi.getter(name="imageName")
    def image_name(self) -> pulumi.Input[str]:
        """
        The name of the CustomImage. Must be unique to your account.
        """
        return pulumi.get(self, "image_name")

    @image_name.setter
    def image_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "image_name", value)

    @property
    @pulumi.getter(name="imageVersionNumber")
    def image_version_number(self) -> Optional[pulumi.Input[int]]:
        """
        The version number of the CustomImage.
        """
        return pulumi.get(self, "image_version_number")

    @image_version_number.setter
    def image_version_number(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "image_version_number", value)


if not MYPY:
    class SpaceEbsStorageSettingsArgsDict(TypedDict):
        """
        Properties related to the space's Amazon Elastic Block Store volume.
        """
        ebs_volume_size_in_gb: pulumi.Input[int]
        """
        Size of the Amazon EBS volume in Gb
        """
elif False:
    SpaceEbsStorageSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpaceEbsStorageSettingsArgs:
    def __init__(__self__, *,
                 ebs_volume_size_in_gb: pulumi.Input[int]):
        """
        Properties related to the space's Amazon Elastic Block Store volume.
        :param pulumi.Input[int] ebs_volume_size_in_gb: Size of the Amazon EBS volume in Gb
        """
        pulumi.set(__self__, "ebs_volume_size_in_gb", ebs_volume_size_in_gb)

    @property
    @pulumi.getter(name="ebsVolumeSizeInGb")
    def ebs_volume_size_in_gb(self) -> pulumi.Input[int]:
        """
        Size of the Amazon EBS volume in Gb
        """
        return pulumi.get(self, "ebs_volume_size_in_gb")

    @ebs_volume_size_in_gb.setter
    def ebs_volume_size_in_gb(self, value: pulumi.Input[int]):
        pulumi.set(self, "ebs_volume_size_in_gb", value)


if not MYPY:
    class SpaceEfsFileSystemArgsDict(TypedDict):
        file_system_id: pulumi.Input[str]
elif False:
    SpaceEfsFileSystemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpaceEfsFileSystemArgs:
    def __init__(__self__, *,
                 file_system_id: pulumi.Input[str]):
        pulumi.set(__self__, "file_system_id", file_system_id)

    @property
    @pulumi.getter(name="fileSystemId")
    def file_system_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "file_system_id")

    @file_system_id.setter
    def file_system_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "file_system_id", value)


if not MYPY:
    class SpaceIdleSettingsArgsDict(TypedDict):
        idle_timeout_in_minutes: NotRequired[pulumi.Input[int]]
        """
        The space idle timeout value set in minutes
        """
elif False:
    SpaceIdleSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpaceIdleSettingsArgs:
    def __init__(__self__, *,
                 idle_timeout_in_minutes: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] idle_timeout_in_minutes: The space idle timeout value set in minutes
        """
        if idle_timeout_in_minutes is not None:
            pulumi.set(__self__, "idle_timeout_in_minutes", idle_timeout_in_minutes)

    @property
    @pulumi.getter(name="idleTimeoutInMinutes")
    def idle_timeout_in_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        The space idle timeout value set in minutes
        """
        return pulumi.get(self, "idle_timeout_in_minutes")

    @idle_timeout_in_minutes.setter
    def idle_timeout_in_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "idle_timeout_in_minutes", value)


if not MYPY:
    class SpaceJupyterLabAppSettingsArgsDict(TypedDict):
        """
        The JupyterServer app settings.
        """
        app_lifecycle_management: NotRequired[pulumi.Input['SpaceAppLifecycleManagementArgsDict']]
        """
        Settings that are used to configure and manage the lifecycle of JupyterLab applications in a space.
        """
        code_repositories: NotRequired[pulumi.Input[Sequence[pulumi.Input['SpaceCodeRepositoryArgsDict']]]]
        """
        A list of CodeRepositories available for use with JupyterLab apps.
        """
        default_resource_spec: NotRequired[pulumi.Input['SpaceResourceSpecArgsDict']]
        """
        Specifies the ARNs of a SageMaker image and SageMaker image version, and the instance type that the version runs on.
        """
elif False:
    SpaceJupyterLabAppSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpaceJupyterLabAppSettingsArgs:
    def __init__(__self__, *,
                 app_lifecycle_management: Optional[pulumi.Input['SpaceAppLifecycleManagementArgs']] = None,
                 code_repositories: Optional[pulumi.Input[Sequence[pulumi.Input['SpaceCodeRepositoryArgs']]]] = None,
                 default_resource_spec: Optional[pulumi.Input['SpaceResourceSpecArgs']] = None):
        """
        The JupyterServer app settings.
        :param pulumi.Input['SpaceAppLifecycleManagementArgs'] app_lifecycle_management: Settings that are used to configure and manage the lifecycle of JupyterLab applications in a space.
        :param pulumi.Input[Sequence[pulumi.Input['SpaceCodeRepositoryArgs']]] code_repositories: A list of CodeRepositories available for use with JupyterLab apps.
        :param pulumi.Input['SpaceResourceSpecArgs'] default_resource_spec: Specifies the ARNs of a SageMaker image and SageMaker image version, and the instance type that the version runs on.
        """
        if app_lifecycle_management is not None:
            pulumi.set(__self__, "app_lifecycle_management", app_lifecycle_management)
        if code_repositories is not None:
            pulumi.set(__self__, "code_repositories", code_repositories)
        if default_resource_spec is not None:
            pulumi.set(__self__, "default_resource_spec", default_resource_spec)

    @property
    @pulumi.getter(name="appLifecycleManagement")
    def app_lifecycle_management(self) -> Optional[pulumi.Input['SpaceAppLifecycleManagementArgs']]:
        """
        Settings that are used to configure and manage the lifecycle of JupyterLab applications in a space.
        """
        return pulumi.get(self, "app_lifecycle_management")

    @app_lifecycle_management.setter
    def app_lifecycle_management(self, value: Optional[pulumi.Input['SpaceAppLifecycleManagementArgs']]):
        pulumi.set(self, "app_lifecycle_management", value)

    @property
    @pulumi.getter(name="codeRepositories")
    def code_repositories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SpaceCodeRepositoryArgs']]]]:
        """
        A list of CodeRepositories available for use with JupyterLab apps.
        """
        return pulumi.get(self, "code_repositories")

    @code_repositories.setter
    def code_repositories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SpaceCodeRepositoryArgs']]]]):
        pulumi.set(self, "code_repositories", value)

    @property
    @pulumi.getter(name="defaultResourceSpec")
    def default_resource_spec(self) -> Optional[pulumi.Input['SpaceResourceSpecArgs']]:
        """
        Specifies the ARNs of a SageMaker image and SageMaker image version, and the instance type that the version runs on.
        """
        return pulumi.get(self, "default_resource_spec")

    @default_resource_spec.setter
    def default_resource_spec(self, value: Optional[pulumi.Input['SpaceResourceSpecArgs']]):
        pulumi.set(self, "default_resource_spec", value)


if not MYPY:
    class SpaceJupyterServerAppSettingsArgsDict(TypedDict):
        """
        The JupyterServer app settings.
        """
        default_resource_spec: NotRequired[pulumi.Input['SpaceResourceSpecArgsDict']]
        """
        The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the JupyterServer app. If you use the `LifecycleConfigArns` parameter, then this parameter is also required.
        """
        lifecycle_config_arns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of LifecycleConfigArns available for use with JupyterServer apps.
        """
elif False:
    SpaceJupyterServerAppSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpaceJupyterServerAppSettingsArgs:
    def __init__(__self__, *,
                 default_resource_spec: Optional[pulumi.Input['SpaceResourceSpecArgs']] = None,
                 lifecycle_config_arns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The JupyterServer app settings.
        :param pulumi.Input['SpaceResourceSpecArgs'] default_resource_spec: The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the JupyterServer app. If you use the `LifecycleConfigArns` parameter, then this parameter is also required.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] lifecycle_config_arns: A list of LifecycleConfigArns available for use with JupyterServer apps.
        """
        if default_resource_spec is not None:
            pulumi.set(__self__, "default_resource_spec", default_resource_spec)
        if lifecycle_config_arns is not None:
            pulumi.set(__self__, "lifecycle_config_arns", lifecycle_config_arns)

    @property
    @pulumi.getter(name="defaultResourceSpec")
    def default_resource_spec(self) -> Optional[pulumi.Input['SpaceResourceSpecArgs']]:
        """
        The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the JupyterServer app. If you use the `LifecycleConfigArns` parameter, then this parameter is also required.
        """
        return pulumi.get(self, "default_resource_spec")

    @default_resource_spec.setter
    def default_resource_spec(self, value: Optional[pulumi.Input['SpaceResourceSpecArgs']]):
        pulumi.set(self, "default_resource_spec", value)

    @property
    @pulumi.getter(name="lifecycleConfigArns")
    def lifecycle_config_arns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of LifecycleConfigArns available for use with JupyterServer apps.
        """
        return pulumi.get(self, "lifecycle_config_arns")

    @lifecycle_config_arns.setter
    def lifecycle_config_arns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "lifecycle_config_arns", value)


if not MYPY:
    class SpaceKernelGatewayAppSettingsArgsDict(TypedDict):
        """
        The kernel gateway app settings.
        """
        custom_images: NotRequired[pulumi.Input[Sequence[pulumi.Input['SpaceCustomImageArgsDict']]]]
        """
        A list of custom SageMaker images that are configured to run as a KernelGateway app.
        """
        default_resource_spec: NotRequired[pulumi.Input['SpaceResourceSpecArgsDict']]
        """
        The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the KernelGateway app.
        """
        lifecycle_config_arns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of LifecycleConfigArns available for use with KernelGateway apps.
        """
elif False:
    SpaceKernelGatewayAppSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpaceKernelGatewayAppSettingsArgs:
    def __init__(__self__, *,
                 custom_images: Optional[pulumi.Input[Sequence[pulumi.Input['SpaceCustomImageArgs']]]] = None,
                 default_resource_spec: Optional[pulumi.Input['SpaceResourceSpecArgs']] = None,
                 lifecycle_config_arns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The kernel gateway app settings.
        :param pulumi.Input[Sequence[pulumi.Input['SpaceCustomImageArgs']]] custom_images: A list of custom SageMaker images that are configured to run as a KernelGateway app.
        :param pulumi.Input['SpaceResourceSpecArgs'] default_resource_spec: The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the KernelGateway app.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] lifecycle_config_arns: A list of LifecycleConfigArns available for use with KernelGateway apps.
        """
        if custom_images is not None:
            pulumi.set(__self__, "custom_images", custom_images)
        if default_resource_spec is not None:
            pulumi.set(__self__, "default_resource_spec", default_resource_spec)
        if lifecycle_config_arns is not None:
            pulumi.set(__self__, "lifecycle_config_arns", lifecycle_config_arns)

    @property
    @pulumi.getter(name="customImages")
    def custom_images(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SpaceCustomImageArgs']]]]:
        """
        A list of custom SageMaker images that are configured to run as a KernelGateway app.
        """
        return pulumi.get(self, "custom_images")

    @custom_images.setter
    def custom_images(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SpaceCustomImageArgs']]]]):
        pulumi.set(self, "custom_images", value)

    @property
    @pulumi.getter(name="defaultResourceSpec")
    def default_resource_spec(self) -> Optional[pulumi.Input['SpaceResourceSpecArgs']]:
        """
        The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the KernelGateway app.
        """
        return pulumi.get(self, "default_resource_spec")

    @default_resource_spec.setter
    def default_resource_spec(self, value: Optional[pulumi.Input['SpaceResourceSpecArgs']]):
        pulumi.set(self, "default_resource_spec", value)

    @property
    @pulumi.getter(name="lifecycleConfigArns")
    def lifecycle_config_arns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of LifecycleConfigArns available for use with KernelGateway apps.
        """
        return pulumi.get(self, "lifecycle_config_arns")

    @lifecycle_config_arns.setter
    def lifecycle_config_arns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "lifecycle_config_arns", value)


if not MYPY:
    class SpaceOwnershipSettingsArgsDict(TypedDict):
        owner_user_profile_name: pulumi.Input[str]
        """
        The user profile who is the owner of the space.
        """
elif False:
    SpaceOwnershipSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpaceOwnershipSettingsArgs:
    def __init__(__self__, *,
                 owner_user_profile_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] owner_user_profile_name: The user profile who is the owner of the space.
        """
        pulumi.set(__self__, "owner_user_profile_name", owner_user_profile_name)

    @property
    @pulumi.getter(name="ownerUserProfileName")
    def owner_user_profile_name(self) -> pulumi.Input[str]:
        """
        The user profile who is the owner of the space.
        """
        return pulumi.get(self, "owner_user_profile_name")

    @owner_user_profile_name.setter
    def owner_user_profile_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "owner_user_profile_name", value)


if not MYPY:
    class SpaceResourceSpecArgsDict(TypedDict):
        instance_type: NotRequired[pulumi.Input['SpaceResourceSpecInstanceType']]
        """
        The instance type that the image version runs on.
        """
        lifecycle_config_arn: NotRequired[pulumi.Input[str]]
        """
        The Amazon Resource Name (ARN) of the Lifecycle Configuration to attach to the Resource.
        """
        sage_maker_image_arn: NotRequired[pulumi.Input[str]]
        """
        The ARN of the SageMaker image that the image version belongs to.
        """
        sage_maker_image_version_arn: NotRequired[pulumi.Input[str]]
        """
        The ARN of the image version created on the instance.
        """
elif False:
    SpaceResourceSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpaceResourceSpecArgs:
    def __init__(__self__, *,
                 instance_type: Optional[pulumi.Input['SpaceResourceSpecInstanceType']] = None,
                 lifecycle_config_arn: Optional[pulumi.Input[str]] = None,
                 sage_maker_image_arn: Optional[pulumi.Input[str]] = None,
                 sage_maker_image_version_arn: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['SpaceResourceSpecInstanceType'] instance_type: The instance type that the image version runs on.
        :param pulumi.Input[str] lifecycle_config_arn: The Amazon Resource Name (ARN) of the Lifecycle Configuration to attach to the Resource.
        :param pulumi.Input[str] sage_maker_image_arn: The ARN of the SageMaker image that the image version belongs to.
        :param pulumi.Input[str] sage_maker_image_version_arn: The ARN of the image version created on the instance.
        """
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if lifecycle_config_arn is not None:
            pulumi.set(__self__, "lifecycle_config_arn", lifecycle_config_arn)
        if sage_maker_image_arn is not None:
            pulumi.set(__self__, "sage_maker_image_arn", sage_maker_image_arn)
        if sage_maker_image_version_arn is not None:
            pulumi.set(__self__, "sage_maker_image_version_arn", sage_maker_image_version_arn)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[pulumi.Input['SpaceResourceSpecInstanceType']]:
        """
        The instance type that the image version runs on.
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: Optional[pulumi.Input['SpaceResourceSpecInstanceType']]):
        pulumi.set(self, "instance_type", value)

    @property
    @pulumi.getter(name="lifecycleConfigArn")
    def lifecycle_config_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon Resource Name (ARN) of the Lifecycle Configuration to attach to the Resource.
        """
        return pulumi.get(self, "lifecycle_config_arn")

    @lifecycle_config_arn.setter
    def lifecycle_config_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_config_arn", value)

    @property
    @pulumi.getter(name="sageMakerImageArn")
    def sage_maker_image_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The ARN of the SageMaker image that the image version belongs to.
        """
        return pulumi.get(self, "sage_maker_image_arn")

    @sage_maker_image_arn.setter
    def sage_maker_image_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sage_maker_image_arn", value)

    @property
    @pulumi.getter(name="sageMakerImageVersionArn")
    def sage_maker_image_version_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The ARN of the image version created on the instance.
        """
        return pulumi.get(self, "sage_maker_image_version_arn")

    @sage_maker_image_version_arn.setter
    def sage_maker_image_version_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sage_maker_image_version_arn", value)


if not MYPY:
    class SpaceSettingsArgsDict(TypedDict):
        """
        A collection of settings that apply to spaces of Amazon SageMaker Studio. These settings are specified when the CreateSpace API is called.
        """
        app_type: NotRequired[pulumi.Input['SpaceAppType']]
        """
        The type of app created within the space.
        """
        code_editor_app_settings: NotRequired[pulumi.Input['SpaceCodeEditorAppSettingsArgsDict']]
        """
        The CodeEditor app settings.
        """
        custom_file_systems: NotRequired[pulumi.Input[Sequence[pulumi.Input['SpaceCustomFileSystemArgsDict']]]]
        """
        A file system, created by you, that you assign to a space for an Amazon SageMaker Domain. Permitted users can access this file system in Amazon SageMaker Studio.
        """
        jupyter_lab_app_settings: NotRequired[pulumi.Input['SpaceJupyterLabAppSettingsArgsDict']]
        """
        The JupyterLab app settings.
        """
        jupyter_server_app_settings: NotRequired[pulumi.Input['SpaceJupyterServerAppSettingsArgsDict']]
        """
        The Jupyter server's app settings.
        """
        kernel_gateway_app_settings: NotRequired[pulumi.Input['SpaceKernelGatewayAppSettingsArgsDict']]
        """
        The kernel gateway app settings.
        """
        space_storage_settings: NotRequired[pulumi.Input['SpaceStorageSettingsArgsDict']]
        """
        Default storage settings for a space.
        """
elif False:
    SpaceSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpaceSettingsArgs:
    def __init__(__self__, *,
                 app_type: Optional[pulumi.Input['SpaceAppType']] = None,
                 code_editor_app_settings: Optional[pulumi.Input['SpaceCodeEditorAppSettingsArgs']] = None,
                 custom_file_systems: Optional[pulumi.Input[Sequence[pulumi.Input['SpaceCustomFileSystemArgs']]]] = None,
                 jupyter_lab_app_settings: Optional[pulumi.Input['SpaceJupyterLabAppSettingsArgs']] = None,
                 jupyter_server_app_settings: Optional[pulumi.Input['SpaceJupyterServerAppSettingsArgs']] = None,
                 kernel_gateway_app_settings: Optional[pulumi.Input['SpaceKernelGatewayAppSettingsArgs']] = None,
                 space_storage_settings: Optional[pulumi.Input['SpaceStorageSettingsArgs']] = None):
        """
        A collection of settings that apply to spaces of Amazon SageMaker Studio. These settings are specified when the CreateSpace API is called.
        :param pulumi.Input['SpaceAppType'] app_type: The type of app created within the space.
        :param pulumi.Input['SpaceCodeEditorAppSettingsArgs'] code_editor_app_settings: The CodeEditor app settings.
        :param pulumi.Input[Sequence[pulumi.Input['SpaceCustomFileSystemArgs']]] custom_file_systems: A file system, created by you, that you assign to a space for an Amazon SageMaker Domain. Permitted users can access this file system in Amazon SageMaker Studio.
        :param pulumi.Input['SpaceJupyterLabAppSettingsArgs'] jupyter_lab_app_settings: The JupyterLab app settings.
        :param pulumi.Input['SpaceJupyterServerAppSettingsArgs'] jupyter_server_app_settings: The Jupyter server's app settings.
        :param pulumi.Input['SpaceKernelGatewayAppSettingsArgs'] kernel_gateway_app_settings: The kernel gateway app settings.
        :param pulumi.Input['SpaceStorageSettingsArgs'] space_storage_settings: Default storage settings for a space.
        """
        if app_type is not None:
            pulumi.set(__self__, "app_type", app_type)
        if code_editor_app_settings is not None:
            pulumi.set(__self__, "code_editor_app_settings", code_editor_app_settings)
        if custom_file_systems is not None:
            pulumi.set(__self__, "custom_file_systems", custom_file_systems)
        if jupyter_lab_app_settings is not None:
            pulumi.set(__self__, "jupyter_lab_app_settings", jupyter_lab_app_settings)
        if jupyter_server_app_settings is not None:
            pulumi.set(__self__, "jupyter_server_app_settings", jupyter_server_app_settings)
        if kernel_gateway_app_settings is not None:
            pulumi.set(__self__, "kernel_gateway_app_settings", kernel_gateway_app_settings)
        if space_storage_settings is not None:
            pulumi.set(__self__, "space_storage_settings", space_storage_settings)

    @property
    @pulumi.getter(name="appType")
    def app_type(self) -> Optional[pulumi.Input['SpaceAppType']]:
        """
        The type of app created within the space.
        """
        return pulumi.get(self, "app_type")

    @app_type.setter
    def app_type(self, value: Optional[pulumi.Input['SpaceAppType']]):
        pulumi.set(self, "app_type", value)

    @property
    @pulumi.getter(name="codeEditorAppSettings")
    def code_editor_app_settings(self) -> Optional[pulumi.Input['SpaceCodeEditorAppSettingsArgs']]:
        """
        The CodeEditor app settings.
        """
        return pulumi.get(self, "code_editor_app_settings")

    @code_editor_app_settings.setter
    def code_editor_app_settings(self, value: Optional[pulumi.Input['SpaceCodeEditorAppSettingsArgs']]):
        pulumi.set(self, "code_editor_app_settings", value)

    @property
    @pulumi.getter(name="customFileSystems")
    def custom_file_systems(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SpaceCustomFileSystemArgs']]]]:
        """
        A file system, created by you, that you assign to a space for an Amazon SageMaker Domain. Permitted users can access this file system in Amazon SageMaker Studio.
        """
        return pulumi.get(self, "custom_file_systems")

    @custom_file_systems.setter
    def custom_file_systems(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SpaceCustomFileSystemArgs']]]]):
        pulumi.set(self, "custom_file_systems", value)

    @property
    @pulumi.getter(name="jupyterLabAppSettings")
    def jupyter_lab_app_settings(self) -> Optional[pulumi.Input['SpaceJupyterLabAppSettingsArgs']]:
        """
        The JupyterLab app settings.
        """
        return pulumi.get(self, "jupyter_lab_app_settings")

    @jupyter_lab_app_settings.setter
    def jupyter_lab_app_settings(self, value: Optional[pulumi.Input['SpaceJupyterLabAppSettingsArgs']]):
        pulumi.set(self, "jupyter_lab_app_settings", value)

    @property
    @pulumi.getter(name="jupyterServerAppSettings")
    def jupyter_server_app_settings(self) -> Optional[pulumi.Input['SpaceJupyterServerAppSettingsArgs']]:
        """
        The Jupyter server's app settings.
        """
        return pulumi.get(self, "jupyter_server_app_settings")

    @jupyter_server_app_settings.setter
    def jupyter_server_app_settings(self, value: Optional[pulumi.Input['SpaceJupyterServerAppSettingsArgs']]):
        pulumi.set(self, "jupyter_server_app_settings", value)

    @property
    @pulumi.getter(name="kernelGatewayAppSettings")
    def kernel_gateway_app_settings(self) -> Optional[pulumi.Input['SpaceKernelGatewayAppSettingsArgs']]:
        """
        The kernel gateway app settings.
        """
        return pulumi.get(self, "kernel_gateway_app_settings")

    @kernel_gateway_app_settings.setter
    def kernel_gateway_app_settings(self, value: Optional[pulumi.Input['SpaceKernelGatewayAppSettingsArgs']]):
        pulumi.set(self, "kernel_gateway_app_settings", value)

    @property
    @pulumi.getter(name="spaceStorageSettings")
    def space_storage_settings(self) -> Optional[pulumi.Input['SpaceStorageSettingsArgs']]:
        """
        Default storage settings for a space.
        """
        return pulumi.get(self, "space_storage_settings")

    @space_storage_settings.setter
    def space_storage_settings(self, value: Optional[pulumi.Input['SpaceStorageSettingsArgs']]):
        pulumi.set(self, "space_storage_settings", value)


if not MYPY:
    class SpaceSharingSettingsArgsDict(TypedDict):
        sharing_type: pulumi.Input['SpaceSharingSettingsSharingType']
        """
        Specifies the sharing type of the space.
        """
elif False:
    SpaceSharingSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpaceSharingSettingsArgs:
    def __init__(__self__, *,
                 sharing_type: pulumi.Input['SpaceSharingSettingsSharingType']):
        """
        :param pulumi.Input['SpaceSharingSettingsSharingType'] sharing_type: Specifies the sharing type of the space.
        """
        pulumi.set(__self__, "sharing_type", sharing_type)

    @property
    @pulumi.getter(name="sharingType")
    def sharing_type(self) -> pulumi.Input['SpaceSharingSettingsSharingType']:
        """
        Specifies the sharing type of the space.
        """
        return pulumi.get(self, "sharing_type")

    @sharing_type.setter
    def sharing_type(self, value: pulumi.Input['SpaceSharingSettingsSharingType']):
        pulumi.set(self, "sharing_type", value)


if not MYPY:
    class SpaceStorageSettingsArgsDict(TypedDict):
        ebs_storage_settings: NotRequired[pulumi.Input['SpaceEbsStorageSettingsArgsDict']]
        """
        A collection of EBS storage settings for a space.
        """
elif False:
    SpaceStorageSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpaceStorageSettingsArgs:
    def __init__(__self__, *,
                 ebs_storage_settings: Optional[pulumi.Input['SpaceEbsStorageSettingsArgs']] = None):
        """
        :param pulumi.Input['SpaceEbsStorageSettingsArgs'] ebs_storage_settings: A collection of EBS storage settings for a space.
        """
        if ebs_storage_settings is not None:
            pulumi.set(__self__, "ebs_storage_settings", ebs_storage_settings)

    @property
    @pulumi.getter(name="ebsStorageSettings")
    def ebs_storage_settings(self) -> Optional[pulumi.Input['SpaceEbsStorageSettingsArgs']]:
        """
        A collection of EBS storage settings for a space.
        """
        return pulumi.get(self, "ebs_storage_settings")

    @ebs_storage_settings.setter
    def ebs_storage_settings(self, value: Optional[pulumi.Input['SpaceEbsStorageSettingsArgs']]):
        pulumi.set(self, "ebs_storage_settings", value)


if not MYPY:
    class UserProfileAppLifecycleManagementArgsDict(TypedDict):
        idle_settings: NotRequired[pulumi.Input['UserProfileIdleSettingsArgsDict']]
        """
        Settings related to idle shutdown of Studio applications.
        """
elif False:
    UserProfileAppLifecycleManagementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserProfileAppLifecycleManagementArgs:
    def __init__(__self__, *,
                 idle_settings: Optional[pulumi.Input['UserProfileIdleSettingsArgs']] = None):
        """
        :param pulumi.Input['UserProfileIdleSettingsArgs'] idle_settings: Settings related to idle shutdown of Studio applications.
        """
        if idle_settings is not None:
            pulumi.set(__self__, "idle_settings", idle_settings)

    @property
    @pulumi.getter(name="idleSettings")
    def idle_settings(self) -> Optional[pulumi.Input['UserProfileIdleSettingsArgs']]:
        """
        Settings related to idle shutdown of Studio applications.
        """
        return pulumi.get(self, "idle_settings")

    @idle_settings.setter
    def idle_settings(self, value: Optional[pulumi.Input['UserProfileIdleSettingsArgs']]):
        pulumi.set(self, "idle_settings", value)


if not MYPY:
    class UserProfileCodeEditorAppSettingsArgsDict(TypedDict):
        """
        The CodeEditor app settings.
        """
        app_lifecycle_management: NotRequired[pulumi.Input['UserProfileAppLifecycleManagementArgsDict']]
        """
        Settings that are used to configure and manage the lifecycle of CodeEditor applications.
        """
        custom_images: NotRequired[pulumi.Input[Sequence[pulumi.Input['UserProfileCustomImageArgsDict']]]]
        """
        A list of custom images for use for CodeEditor apps.
        """
        default_resource_spec: NotRequired[pulumi.Input['UserProfileResourceSpecArgsDict']]
        """
        The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the CodeEditor app.
        """
        lifecycle_config_arns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of LifecycleConfigArns available for use with CodeEditor apps.
        """
elif False:
    UserProfileCodeEditorAppSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserProfileCodeEditorAppSettingsArgs:
    def __init__(__self__, *,
                 app_lifecycle_management: Optional[pulumi.Input['UserProfileAppLifecycleManagementArgs']] = None,
                 custom_images: Optional[pulumi.Input[Sequence[pulumi.Input['UserProfileCustomImageArgs']]]] = None,
                 default_resource_spec: Optional[pulumi.Input['UserProfileResourceSpecArgs']] = None,
                 lifecycle_config_arns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The CodeEditor app settings.
        :param pulumi.Input['UserProfileAppLifecycleManagementArgs'] app_lifecycle_management: Settings that are used to configure and manage the lifecycle of CodeEditor applications.
        :param pulumi.Input[Sequence[pulumi.Input['UserProfileCustomImageArgs']]] custom_images: A list of custom images for use for CodeEditor apps.
        :param pulumi.Input['UserProfileResourceSpecArgs'] default_resource_spec: The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the CodeEditor app.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] lifecycle_config_arns: A list of LifecycleConfigArns available for use with CodeEditor apps.
        """
        if app_lifecycle_management is not None:
            pulumi.set(__self__, "app_lifecycle_management", app_lifecycle_management)
        if custom_images is not None:
            pulumi.set(__self__, "custom_images", custom_images)
        if default_resource_spec is not None:
            pulumi.set(__self__, "default_resource_spec", default_resource_spec)
        if lifecycle_config_arns is not None:
            pulumi.set(__self__, "lifecycle_config_arns", lifecycle_config_arns)

    @property
    @pulumi.getter(name="appLifecycleManagement")
    def app_lifecycle_management(self) -> Optional[pulumi.Input['UserProfileAppLifecycleManagementArgs']]:
        """
        Settings that are used to configure and manage the lifecycle of CodeEditor applications.
        """
        return pulumi.get(self, "app_lifecycle_management")

    @app_lifecycle_management.setter
    def app_lifecycle_management(self, value: Optional[pulumi.Input['UserProfileAppLifecycleManagementArgs']]):
        pulumi.set(self, "app_lifecycle_management", value)

    @property
    @pulumi.getter(name="customImages")
    def custom_images(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserProfileCustomImageArgs']]]]:
        """
        A list of custom images for use for CodeEditor apps.
        """
        return pulumi.get(self, "custom_images")

    @custom_images.setter
    def custom_images(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserProfileCustomImageArgs']]]]):
        pulumi.set(self, "custom_images", value)

    @property
    @pulumi.getter(name="defaultResourceSpec")
    def default_resource_spec(self) -> Optional[pulumi.Input['UserProfileResourceSpecArgs']]:
        """
        The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the CodeEditor app.
        """
        return pulumi.get(self, "default_resource_spec")

    @default_resource_spec.setter
    def default_resource_spec(self, value: Optional[pulumi.Input['UserProfileResourceSpecArgs']]):
        pulumi.set(self, "default_resource_spec", value)

    @property
    @pulumi.getter(name="lifecycleConfigArns")
    def lifecycle_config_arns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of LifecycleConfigArns available for use with CodeEditor apps.
        """
        return pulumi.get(self, "lifecycle_config_arns")

    @lifecycle_config_arns.setter
    def lifecycle_config_arns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "lifecycle_config_arns", value)


if not MYPY:
    class UserProfileCodeRepositoryArgsDict(TypedDict):
        repository_url: pulumi.Input[str]
        """
        A CodeRepository (valid URL) to be used within Jupyter's Git extension.
        """
elif False:
    UserProfileCodeRepositoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserProfileCodeRepositoryArgs:
    def __init__(__self__, *,
                 repository_url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] repository_url: A CodeRepository (valid URL) to be used within Jupyter's Git extension.
        """
        pulumi.set(__self__, "repository_url", repository_url)

    @property
    @pulumi.getter(name="repositoryUrl")
    def repository_url(self) -> pulumi.Input[str]:
        """
        A CodeRepository (valid URL) to be used within Jupyter's Git extension.
        """
        return pulumi.get(self, "repository_url")

    @repository_url.setter
    def repository_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "repository_url", value)


if not MYPY:
    class UserProfileCustomFileSystemConfigArgsDict(TypedDict):
        efs_file_system_config: NotRequired[pulumi.Input['UserProfileEfsFileSystemConfigArgsDict']]
        """
        The settings for a custom Amazon EFS file system.
        """
elif False:
    UserProfileCustomFileSystemConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserProfileCustomFileSystemConfigArgs:
    def __init__(__self__, *,
                 efs_file_system_config: Optional[pulumi.Input['UserProfileEfsFileSystemConfigArgs']] = None):
        """
        :param pulumi.Input['UserProfileEfsFileSystemConfigArgs'] efs_file_system_config: The settings for a custom Amazon EFS file system.
        """
        if efs_file_system_config is not None:
            pulumi.set(__self__, "efs_file_system_config", efs_file_system_config)

    @property
    @pulumi.getter(name="efsFileSystemConfig")
    def efs_file_system_config(self) -> Optional[pulumi.Input['UserProfileEfsFileSystemConfigArgs']]:
        """
        The settings for a custom Amazon EFS file system.
        """
        return pulumi.get(self, "efs_file_system_config")

    @efs_file_system_config.setter
    def efs_file_system_config(self, value: Optional[pulumi.Input['UserProfileEfsFileSystemConfigArgs']]):
        pulumi.set(self, "efs_file_system_config", value)


if not MYPY:
    class UserProfileCustomImageArgsDict(TypedDict):
        """
        A custom SageMaker image.
        """
        app_image_config_name: pulumi.Input[str]
        """
        The Name of the AppImageConfig.
        """
        image_name: pulumi.Input[str]
        """
        The name of the CustomImage. Must be unique to your account.
        """
        image_version_number: NotRequired[pulumi.Input[int]]
        """
        The version number of the CustomImage.
        """
elif False:
    UserProfileCustomImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserProfileCustomImageArgs:
    def __init__(__self__, *,
                 app_image_config_name: pulumi.Input[str],
                 image_name: pulumi.Input[str],
                 image_version_number: Optional[pulumi.Input[int]] = None):
        """
        A custom SageMaker image.
        :param pulumi.Input[str] app_image_config_name: The Name of the AppImageConfig.
        :param pulumi.Input[str] image_name: The name of the CustomImage. Must be unique to your account.
        :param pulumi.Input[int] image_version_number: The version number of the CustomImage.
        """
        pulumi.set(__self__, "app_image_config_name", app_image_config_name)
        pulumi.set(__self__, "image_name", image_name)
        if image_version_number is not None:
            pulumi.set(__self__, "image_version_number", image_version_number)

    @property
    @pulumi.getter(name="appImageConfigName")
    def app_image_config_name(self) -> pulumi.Input[str]:
        """
        The Name of the AppImageConfig.
        """
        return pulumi.get(self, "app_image_config_name")

    @app_image_config_name.setter
    def app_image_config_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "app_image_config_name", value)

    @property
    @pulumi.getter(name="imageName")
    def image_name(self) -> pulumi.Input[str]:
        """
        The name of the CustomImage. Must be unique to your account.
        """
        return pulumi.get(self, "image_name")

    @image_name.setter
    def image_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "image_name", value)

    @property
    @pulumi.getter(name="imageVersionNumber")
    def image_version_number(self) -> Optional[pulumi.Input[int]]:
        """
        The version number of the CustomImage.
        """
        return pulumi.get(self, "image_version_number")

    @image_version_number.setter
    def image_version_number(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "image_version_number", value)


if not MYPY:
    class UserProfileCustomPosixUserConfigArgsDict(TypedDict):
        gid: pulumi.Input[int]
        """
        The POSIX group ID.
        """
        uid: pulumi.Input[int]
        """
        The POSIX user ID.
        """
elif False:
    UserProfileCustomPosixUserConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserProfileCustomPosixUserConfigArgs:
    def __init__(__self__, *,
                 gid: pulumi.Input[int],
                 uid: pulumi.Input[int]):
        """
        :param pulumi.Input[int] gid: The POSIX group ID.
        :param pulumi.Input[int] uid: The POSIX user ID.
        """
        pulumi.set(__self__, "gid", gid)
        pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def gid(self) -> pulumi.Input[int]:
        """
        The POSIX group ID.
        """
        return pulumi.get(self, "gid")

    @gid.setter
    def gid(self, value: pulumi.Input[int]):
        pulumi.set(self, "gid", value)

    @property
    @pulumi.getter
    def uid(self) -> pulumi.Input[int]:
        """
        The POSIX user ID.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: pulumi.Input[int]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class UserProfileDefaultEbsStorageSettingsArgsDict(TypedDict):
        """
        Properties related to the Amazon Elastic Block Store volume.
        """
        default_ebs_volume_size_in_gb: pulumi.Input[int]
        """
        Default size of the Amazon EBS volume in Gb
        """
        maximum_ebs_volume_size_in_gb: pulumi.Input[int]
        """
        Maximum size of the Amazon EBS volume in Gb. Must be greater than or equal to the DefaultEbsVolumeSizeInGb.
        """
elif False:
    UserProfileDefaultEbsStorageSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserProfileDefaultEbsStorageSettingsArgs:
    def __init__(__self__, *,
                 default_ebs_volume_size_in_gb: pulumi.Input[int],
                 maximum_ebs_volume_size_in_gb: pulumi.Input[int]):
        """
        Properties related to the Amazon Elastic Block Store volume.
        :param pulumi.Input[int] default_ebs_volume_size_in_gb: Default size of the Amazon EBS volume in Gb
        :param pulumi.Input[int] maximum_ebs_volume_size_in_gb: Maximum size of the Amazon EBS volume in Gb. Must be greater than or equal to the DefaultEbsVolumeSizeInGb.
        """
        pulumi.set(__self__, "default_ebs_volume_size_in_gb", default_ebs_volume_size_in_gb)
        pulumi.set(__self__, "maximum_ebs_volume_size_in_gb", maximum_ebs_volume_size_in_gb)

    @property
    @pulumi.getter(name="defaultEbsVolumeSizeInGb")
    def default_ebs_volume_size_in_gb(self) -> pulumi.Input[int]:
        """
        Default size of the Amazon EBS volume in Gb
        """
        return pulumi.get(self, "default_ebs_volume_size_in_gb")

    @default_ebs_volume_size_in_gb.setter
    def default_ebs_volume_size_in_gb(self, value: pulumi.Input[int]):
        pulumi.set(self, "default_ebs_volume_size_in_gb", value)

    @property
    @pulumi.getter(name="maximumEbsVolumeSizeInGb")
    def maximum_ebs_volume_size_in_gb(self) -> pulumi.Input[int]:
        """
        Maximum size of the Amazon EBS volume in Gb. Must be greater than or equal to the DefaultEbsVolumeSizeInGb.
        """
        return pulumi.get(self, "maximum_ebs_volume_size_in_gb")

    @maximum_ebs_volume_size_in_gb.setter
    def maximum_ebs_volume_size_in_gb(self, value: pulumi.Input[int]):
        pulumi.set(self, "maximum_ebs_volume_size_in_gb", value)


if not MYPY:
    class UserProfileDefaultSpaceStorageSettingsArgsDict(TypedDict):
        """
        Default storage settings for a space.
        """
        default_ebs_storage_settings: NotRequired[pulumi.Input['UserProfileDefaultEbsStorageSettingsArgsDict']]
        """
        The default EBS storage settings for a space.
        """
elif False:
    UserProfileDefaultSpaceStorageSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserProfileDefaultSpaceStorageSettingsArgs:
    def __init__(__self__, *,
                 default_ebs_storage_settings: Optional[pulumi.Input['UserProfileDefaultEbsStorageSettingsArgs']] = None):
        """
        Default storage settings for a space.
        :param pulumi.Input['UserProfileDefaultEbsStorageSettingsArgs'] default_ebs_storage_settings: The default EBS storage settings for a space.
        """
        if default_ebs_storage_settings is not None:
            pulumi.set(__self__, "default_ebs_storage_settings", default_ebs_storage_settings)

    @property
    @pulumi.getter(name="defaultEbsStorageSettings")
    def default_ebs_storage_settings(self) -> Optional[pulumi.Input['UserProfileDefaultEbsStorageSettingsArgs']]:
        """
        The default EBS storage settings for a space.
        """
        return pulumi.get(self, "default_ebs_storage_settings")

    @default_ebs_storage_settings.setter
    def default_ebs_storage_settings(self, value: Optional[pulumi.Input['UserProfileDefaultEbsStorageSettingsArgs']]):
        pulumi.set(self, "default_ebs_storage_settings", value)


if not MYPY:
    class UserProfileEfsFileSystemConfigArgsDict(TypedDict):
        file_system_id: pulumi.Input[str]
        """
        The ID of your Amazon EFS file system.
        """
        file_system_path: NotRequired[pulumi.Input[str]]
        """
        The path to the file system directory that is accessible in Amazon SageMaker Studio. Permitted users can access only this directory and below.
        """
elif False:
    UserProfileEfsFileSystemConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserProfileEfsFileSystemConfigArgs:
    def __init__(__self__, *,
                 file_system_id: pulumi.Input[str],
                 file_system_path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] file_system_id: The ID of your Amazon EFS file system.
        :param pulumi.Input[str] file_system_path: The path to the file system directory that is accessible in Amazon SageMaker Studio. Permitted users can access only this directory and below.
        """
        pulumi.set(__self__, "file_system_id", file_system_id)
        if file_system_path is not None:
            pulumi.set(__self__, "file_system_path", file_system_path)

    @property
    @pulumi.getter(name="fileSystemId")
    def file_system_id(self) -> pulumi.Input[str]:
        """
        The ID of your Amazon EFS file system.
        """
        return pulumi.get(self, "file_system_id")

    @file_system_id.setter
    def file_system_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "file_system_id", value)

    @property
    @pulumi.getter(name="fileSystemPath")
    def file_system_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the file system directory that is accessible in Amazon SageMaker Studio. Permitted users can access only this directory and below.
        """
        return pulumi.get(self, "file_system_path")

    @file_system_path.setter
    def file_system_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_system_path", value)


if not MYPY:
    class UserProfileIdleSettingsArgsDict(TypedDict):
        idle_timeout_in_minutes: NotRequired[pulumi.Input[int]]
        """
        The time that SageMaker waits after the application becomes idle before shutting it down.
        """
        lifecycle_management: NotRequired[pulumi.Input['UserProfileLifecycleManagement']]
        """
        Indicates whether idle shutdown is activated for the application type.
        """
        max_idle_timeout_in_minutes: NotRequired[pulumi.Input[int]]
        """
        The maximum value in minutes that custom idle shutdown can be set to by the user.
        """
        min_idle_timeout_in_minutes: NotRequired[pulumi.Input[int]]
        """
        The minimum value in minutes that custom idle shutdown can be set to by the user.
        """
elif False:
    UserProfileIdleSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserProfileIdleSettingsArgs:
    def __init__(__self__, *,
                 idle_timeout_in_minutes: Optional[pulumi.Input[int]] = None,
                 lifecycle_management: Optional[pulumi.Input['UserProfileLifecycleManagement']] = None,
                 max_idle_timeout_in_minutes: Optional[pulumi.Input[int]] = None,
                 min_idle_timeout_in_minutes: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] idle_timeout_in_minutes: The time that SageMaker waits after the application becomes idle before shutting it down.
        :param pulumi.Input['UserProfileLifecycleManagement'] lifecycle_management: Indicates whether idle shutdown is activated for the application type.
        :param pulumi.Input[int] max_idle_timeout_in_minutes: The maximum value in minutes that custom idle shutdown can be set to by the user.
        :param pulumi.Input[int] min_idle_timeout_in_minutes: The minimum value in minutes that custom idle shutdown can be set to by the user.
        """
        if idle_timeout_in_minutes is not None:
            pulumi.set(__self__, "idle_timeout_in_minutes", idle_timeout_in_minutes)
        if lifecycle_management is not None:
            pulumi.set(__self__, "lifecycle_management", lifecycle_management)
        if max_idle_timeout_in_minutes is not None:
            pulumi.set(__self__, "max_idle_timeout_in_minutes", max_idle_timeout_in_minutes)
        if min_idle_timeout_in_minutes is not None:
            pulumi.set(__self__, "min_idle_timeout_in_minutes", min_idle_timeout_in_minutes)

    @property
    @pulumi.getter(name="idleTimeoutInMinutes")
    def idle_timeout_in_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        The time that SageMaker waits after the application becomes idle before shutting it down.
        """
        return pulumi.get(self, "idle_timeout_in_minutes")

    @idle_timeout_in_minutes.setter
    def idle_timeout_in_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "idle_timeout_in_minutes", value)

    @property
    @pulumi.getter(name="lifecycleManagement")
    def lifecycle_management(self) -> Optional[pulumi.Input['UserProfileLifecycleManagement']]:
        """
        Indicates whether idle shutdown is activated for the application type.
        """
        return pulumi.get(self, "lifecycle_management")

    @lifecycle_management.setter
    def lifecycle_management(self, value: Optional[pulumi.Input['UserProfileLifecycleManagement']]):
        pulumi.set(self, "lifecycle_management", value)

    @property
    @pulumi.getter(name="maxIdleTimeoutInMinutes")
    def max_idle_timeout_in_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum value in minutes that custom idle shutdown can be set to by the user.
        """
        return pulumi.get(self, "max_idle_timeout_in_minutes")

    @max_idle_timeout_in_minutes.setter
    def max_idle_timeout_in_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_idle_timeout_in_minutes", value)

    @property
    @pulumi.getter(name="minIdleTimeoutInMinutes")
    def min_idle_timeout_in_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum value in minutes that custom idle shutdown can be set to by the user.
        """
        return pulumi.get(self, "min_idle_timeout_in_minutes")

    @min_idle_timeout_in_minutes.setter
    def min_idle_timeout_in_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_idle_timeout_in_minutes", value)


if not MYPY:
    class UserProfileJupyterLabAppSettingsArgsDict(TypedDict):
        """
        The JupyterLab app settings.
        """
        app_lifecycle_management: NotRequired[pulumi.Input['UserProfileAppLifecycleManagementArgsDict']]
        """
        Indicates whether idle shutdown is activated for JupyterLab applications.
        """
        code_repositories: NotRequired[pulumi.Input[Sequence[pulumi.Input['UserProfileCodeRepositoryArgsDict']]]]
        """
        A list of CodeRepositories available for use with JupyterLab apps.
        """
        custom_images: NotRequired[pulumi.Input[Sequence[pulumi.Input['UserProfileCustomImageArgsDict']]]]
        """
        A list of custom images available for use for JupyterLab apps
        """
        default_resource_spec: NotRequired[pulumi.Input['UserProfileResourceSpecArgsDict']]
        """
        The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the JupyterLab app.
        """
        lifecycle_config_arns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of LifecycleConfigArns available for use with JupyterLab apps.
        """
elif False:
    UserProfileJupyterLabAppSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserProfileJupyterLabAppSettingsArgs:
    def __init__(__self__, *,
                 app_lifecycle_management: Optional[pulumi.Input['UserProfileAppLifecycleManagementArgs']] = None,
                 code_repositories: Optional[pulumi.Input[Sequence[pulumi.Input['UserProfileCodeRepositoryArgs']]]] = None,
                 custom_images: Optional[pulumi.Input[Sequence[pulumi.Input['UserProfileCustomImageArgs']]]] = None,
                 default_resource_spec: Optional[pulumi.Input['UserProfileResourceSpecArgs']] = None,
                 lifecycle_config_arns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The JupyterLab app settings.
        :param pulumi.Input['UserProfileAppLifecycleManagementArgs'] app_lifecycle_management: Indicates whether idle shutdown is activated for JupyterLab applications.
        :param pulumi.Input[Sequence[pulumi.Input['UserProfileCodeRepositoryArgs']]] code_repositories: A list of CodeRepositories available for use with JupyterLab apps.
        :param pulumi.Input[Sequence[pulumi.Input['UserProfileCustomImageArgs']]] custom_images: A list of custom images available for use for JupyterLab apps
        :param pulumi.Input['UserProfileResourceSpecArgs'] default_resource_spec: The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the JupyterLab app.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] lifecycle_config_arns: A list of LifecycleConfigArns available for use with JupyterLab apps.
        """
        if app_lifecycle_management is not None:
            pulumi.set(__self__, "app_lifecycle_management", app_lifecycle_management)
        if code_repositories is not None:
            pulumi.set(__self__, "code_repositories", code_repositories)
        if custom_images is not None:
            pulumi.set(__self__, "custom_images", custom_images)
        if default_resource_spec is not None:
            pulumi.set(__self__, "default_resource_spec", default_resource_spec)
        if lifecycle_config_arns is not None:
            pulumi.set(__self__, "lifecycle_config_arns", lifecycle_config_arns)

    @property
    @pulumi.getter(name="appLifecycleManagement")
    def app_lifecycle_management(self) -> Optional[pulumi.Input['UserProfileAppLifecycleManagementArgs']]:
        """
        Indicates whether idle shutdown is activated for JupyterLab applications.
        """
        return pulumi.get(self, "app_lifecycle_management")

    @app_lifecycle_management.setter
    def app_lifecycle_management(self, value: Optional[pulumi.Input['UserProfileAppLifecycleManagementArgs']]):
        pulumi.set(self, "app_lifecycle_management", value)

    @property
    @pulumi.getter(name="codeRepositories")
    def code_repositories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserProfileCodeRepositoryArgs']]]]:
        """
        A list of CodeRepositories available for use with JupyterLab apps.
        """
        return pulumi.get(self, "code_repositories")

    @code_repositories.setter
    def code_repositories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserProfileCodeRepositoryArgs']]]]):
        pulumi.set(self, "code_repositories", value)

    @property
    @pulumi.getter(name="customImages")
    def custom_images(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserProfileCustomImageArgs']]]]:
        """
        A list of custom images available for use for JupyterLab apps
        """
        return pulumi.get(self, "custom_images")

    @custom_images.setter
    def custom_images(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserProfileCustomImageArgs']]]]):
        pulumi.set(self, "custom_images", value)

    @property
    @pulumi.getter(name="defaultResourceSpec")
    def default_resource_spec(self) -> Optional[pulumi.Input['UserProfileResourceSpecArgs']]:
        """
        The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the JupyterLab app.
        """
        return pulumi.get(self, "default_resource_spec")

    @default_resource_spec.setter
    def default_resource_spec(self, value: Optional[pulumi.Input['UserProfileResourceSpecArgs']]):
        pulumi.set(self, "default_resource_spec", value)

    @property
    @pulumi.getter(name="lifecycleConfigArns")
    def lifecycle_config_arns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of LifecycleConfigArns available for use with JupyterLab apps.
        """
        return pulumi.get(self, "lifecycle_config_arns")

    @lifecycle_config_arns.setter
    def lifecycle_config_arns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "lifecycle_config_arns", value)


if not MYPY:
    class UserProfileJupyterServerAppSettingsArgsDict(TypedDict):
        """
        The JupyterServer app settings.
        """
        default_resource_spec: NotRequired[pulumi.Input['UserProfileResourceSpecArgsDict']]
        """
        The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the JupyterServer app.
        """
        lifecycle_config_arns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of LifecycleConfigArns available for use with JupyterServer apps.
        """
elif False:
    UserProfileJupyterServerAppSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserProfileJupyterServerAppSettingsArgs:
    def __init__(__self__, *,
                 default_resource_spec: Optional[pulumi.Input['UserProfileResourceSpecArgs']] = None,
                 lifecycle_config_arns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The JupyterServer app settings.
        :param pulumi.Input['UserProfileResourceSpecArgs'] default_resource_spec: The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the JupyterServer app.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] lifecycle_config_arns: A list of LifecycleConfigArns available for use with JupyterServer apps.
        """
        if default_resource_spec is not None:
            pulumi.set(__self__, "default_resource_spec", default_resource_spec)
        if lifecycle_config_arns is not None:
            pulumi.set(__self__, "lifecycle_config_arns", lifecycle_config_arns)

    @property
    @pulumi.getter(name="defaultResourceSpec")
    def default_resource_spec(self) -> Optional[pulumi.Input['UserProfileResourceSpecArgs']]:
        """
        The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the JupyterServer app.
        """
        return pulumi.get(self, "default_resource_spec")

    @default_resource_spec.setter
    def default_resource_spec(self, value: Optional[pulumi.Input['UserProfileResourceSpecArgs']]):
        pulumi.set(self, "default_resource_spec", value)

    @property
    @pulumi.getter(name="lifecycleConfigArns")
    def lifecycle_config_arns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of LifecycleConfigArns available for use with JupyterServer apps.
        """
        return pulumi.get(self, "lifecycle_config_arns")

    @lifecycle_config_arns.setter
    def lifecycle_config_arns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "lifecycle_config_arns", value)


if not MYPY:
    class UserProfileKernelGatewayAppSettingsArgsDict(TypedDict):
        """
        The kernel gateway app settings.
        """
        custom_images: NotRequired[pulumi.Input[Sequence[pulumi.Input['UserProfileCustomImageArgsDict']]]]
        """
        A list of custom SageMaker images that are configured to run as a KernelGateway app.
        """
        default_resource_spec: NotRequired[pulumi.Input['UserProfileResourceSpecArgsDict']]
        """
        The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the KernelGateway app.
        """
        lifecycle_config_arns: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of LifecycleConfigArns available for use with KernelGateway apps.
        """
elif False:
    UserProfileKernelGatewayAppSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserProfileKernelGatewayAppSettingsArgs:
    def __init__(__self__, *,
                 custom_images: Optional[pulumi.Input[Sequence[pulumi.Input['UserProfileCustomImageArgs']]]] = None,
                 default_resource_spec: Optional[pulumi.Input['UserProfileResourceSpecArgs']] = None,
                 lifecycle_config_arns: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The kernel gateway app settings.
        :param pulumi.Input[Sequence[pulumi.Input['UserProfileCustomImageArgs']]] custom_images: A list of custom SageMaker images that are configured to run as a KernelGateway app.
        :param pulumi.Input['UserProfileResourceSpecArgs'] default_resource_spec: The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the KernelGateway app.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] lifecycle_config_arns: A list of LifecycleConfigArns available for use with KernelGateway apps.
        """
        if custom_images is not None:
            pulumi.set(__self__, "custom_images", custom_images)
        if default_resource_spec is not None:
            pulumi.set(__self__, "default_resource_spec", default_resource_spec)
        if lifecycle_config_arns is not None:
            pulumi.set(__self__, "lifecycle_config_arns", lifecycle_config_arns)

    @property
    @pulumi.getter(name="customImages")
    def custom_images(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserProfileCustomImageArgs']]]]:
        """
        A list of custom SageMaker images that are configured to run as a KernelGateway app.
        """
        return pulumi.get(self, "custom_images")

    @custom_images.setter
    def custom_images(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserProfileCustomImageArgs']]]]):
        pulumi.set(self, "custom_images", value)

    @property
    @pulumi.getter(name="defaultResourceSpec")
    def default_resource_spec(self) -> Optional[pulumi.Input['UserProfileResourceSpecArgs']]:
        """
        The default instance type and the Amazon Resource Name (ARN) of the default SageMaker image used by the KernelGateway app.
        """
        return pulumi.get(self, "default_resource_spec")

    @default_resource_spec.setter
    def default_resource_spec(self, value: Optional[pulumi.Input['UserProfileResourceSpecArgs']]):
        pulumi.set(self, "default_resource_spec", value)

    @property
    @pulumi.getter(name="lifecycleConfigArns")
    def lifecycle_config_arns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of LifecycleConfigArns available for use with KernelGateway apps.
        """
        return pulumi.get(self, "lifecycle_config_arns")

    @lifecycle_config_arns.setter
    def lifecycle_config_arns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "lifecycle_config_arns", value)


if not MYPY:
    class UserProfileRStudioServerProAppSettingsArgsDict(TypedDict):
        """
        A collection of settings that configure user interaction with the RStudioServerPro app.
        """
        access_status: NotRequired[pulumi.Input['UserProfileRStudioServerProAppSettingsAccessStatus']]
        """
        Indicates whether the current user has access to the RStudioServerPro app.
        """
        user_group: NotRequired[pulumi.Input['UserProfileRStudioServerProAppSettingsUserGroup']]
        """
        The level of permissions that the user has within the RStudioServerPro app. This value defaults to User. The Admin value allows the user access to the RStudio Administrative Dashboard.
        """
elif False:
    UserProfileRStudioServerProAppSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserProfileRStudioServerProAppSettingsArgs:
    def __init__(__self__, *,
                 access_status: Optional[pulumi.Input['UserProfileRStudioServerProAppSettingsAccessStatus']] = None,
                 user_group: Optional[pulumi.Input['UserProfileRStudioServerProAppSettingsUserGroup']] = None):
        """
        A collection of settings that configure user interaction with the RStudioServerPro app.
        :param pulumi.Input['UserProfileRStudioServerProAppSettingsAccessStatus'] access_status: Indicates whether the current user has access to the RStudioServerPro app.
        :param pulumi.Input['UserProfileRStudioServerProAppSettingsUserGroup'] user_group: The level of permissions that the user has within the RStudioServerPro app. This value defaults to User. The Admin value allows the user access to the RStudio Administrative Dashboard.
        """
        if access_status is not None:
            pulumi.set(__self__, "access_status", access_status)
        if user_group is not None:
            pulumi.set(__self__, "user_group", user_group)

    @property
    @pulumi.getter(name="accessStatus")
    def access_status(self) -> Optional[pulumi.Input['UserProfileRStudioServerProAppSettingsAccessStatus']]:
        """
        Indicates whether the current user has access to the RStudioServerPro app.
        """
        return pulumi.get(self, "access_status")

    @access_status.setter
    def access_status(self, value: Optional[pulumi.Input['UserProfileRStudioServerProAppSettingsAccessStatus']]):
        pulumi.set(self, "access_status", value)

    @property
    @pulumi.getter(name="userGroup")
    def user_group(self) -> Optional[pulumi.Input['UserProfileRStudioServerProAppSettingsUserGroup']]:
        """
        The level of permissions that the user has within the RStudioServerPro app. This value defaults to User. The Admin value allows the user access to the RStudio Administrative Dashboard.
        """
        return pulumi.get(self, "user_group")

    @user_group.setter
    def user_group(self, value: Optional[pulumi.Input['UserProfileRStudioServerProAppSettingsUserGroup']]):
        pulumi.set(self, "user_group", value)


if not MYPY:
    class UserProfileResourceSpecArgsDict(TypedDict):
        instance_type: NotRequired[pulumi.Input['UserProfileResourceSpecInstanceType']]
        """
        The instance type that the image version runs on.
        """
        lifecycle_config_arn: NotRequired[pulumi.Input[str]]
        """
        The Amazon Resource Name (ARN) of the Lifecycle Configuration to attach to the Resource.
        """
        sage_maker_image_arn: NotRequired[pulumi.Input[str]]
        """
        The ARN of the SageMaker image that the image version belongs to.
        """
        sage_maker_image_version_arn: NotRequired[pulumi.Input[str]]
        """
        The ARN of the image version created on the instance.
        """
elif False:
    UserProfileResourceSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserProfileResourceSpecArgs:
    def __init__(__self__, *,
                 instance_type: Optional[pulumi.Input['UserProfileResourceSpecInstanceType']] = None,
                 lifecycle_config_arn: Optional[pulumi.Input[str]] = None,
                 sage_maker_image_arn: Optional[pulumi.Input[str]] = None,
                 sage_maker_image_version_arn: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['UserProfileResourceSpecInstanceType'] instance_type: The instance type that the image version runs on.
        :param pulumi.Input[str] lifecycle_config_arn: The Amazon Resource Name (ARN) of the Lifecycle Configuration to attach to the Resource.
        :param pulumi.Input[str] sage_maker_image_arn: The ARN of the SageMaker image that the image version belongs to.
        :param pulumi.Input[str] sage_maker_image_version_arn: The ARN of the image version created on the instance.
        """
        if instance_type is not None:
            pulumi.set(__self__, "instance_type", instance_type)
        if lifecycle_config_arn is not None:
            pulumi.set(__self__, "lifecycle_config_arn", lifecycle_config_arn)
        if sage_maker_image_arn is not None:
            pulumi.set(__self__, "sage_maker_image_arn", sage_maker_image_arn)
        if sage_maker_image_version_arn is not None:
            pulumi.set(__self__, "sage_maker_image_version_arn", sage_maker_image_version_arn)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> Optional[pulumi.Input['UserProfileResourceSpecInstanceType']]:
        """
        The instance type that the image version runs on.
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: Optional[pulumi.Input['UserProfileResourceSpecInstanceType']]):
        pulumi.set(self, "instance_type", value)

    @property
    @pulumi.getter(name="lifecycleConfigArn")
    def lifecycle_config_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The Amazon Resource Name (ARN) of the Lifecycle Configuration to attach to the Resource.
        """
        return pulumi.get(self, "lifecycle_config_arn")

    @lifecycle_config_arn.setter
    def lifecycle_config_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lifecycle_config_arn", value)

    @property
    @pulumi.getter(name="sageMakerImageArn")
    def sage_maker_image_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The ARN of the SageMaker image that the image version belongs to.
        """
        return pulumi.get(self, "sage_maker_image_arn")

    @sage_maker_image_arn.setter
    def sage_maker_image_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sage_maker_image_arn", value)

    @property
    @pulumi.getter(name="sageMakerImageVersionArn")
    def sage_maker_image_version_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The ARN of the image version created on the instance.
        """
        return pulumi.get(self, "sage_maker_image_version_arn")

    @sage_maker_image_version_arn.setter
    def sage_maker_image_version_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sage_maker_image_version_arn", value)


if not MYPY:
    class UserProfileSharingSettingsArgsDict(TypedDict):
        """
        Specifies options when sharing an Amazon SageMaker Studio notebook. These settings are specified as part of DefaultUserSettings when the CreateDomain API is called, and as part of UserSettings when the CreateUserProfile API is called.
        """
        notebook_output_option: NotRequired[pulumi.Input['UserProfileSharingSettingsNotebookOutputOption']]
        """
        Whether to include the notebook cell output when sharing the notebook. The default is Disabled.
        """
        s3_kms_key_id: NotRequired[pulumi.Input[str]]
        """
        When NotebookOutputOption is Allowed, the AWS Key Management Service (KMS) encryption key ID used to encrypt the notebook cell output in the Amazon S3 bucket.
        """
        s3_output_path: NotRequired[pulumi.Input[str]]
        """
        When NotebookOutputOption is Allowed, the Amazon S3 bucket used to store the shared notebook snapshots.
        """
elif False:
    UserProfileSharingSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserProfileSharingSettingsArgs:
    def __init__(__self__, *,
                 notebook_output_option: Optional[pulumi.Input['UserProfileSharingSettingsNotebookOutputOption']] = None,
                 s3_kms_key_id: Optional[pulumi.Input[str]] = None,
                 s3_output_path: Optional[pulumi.Input[str]] = None):
        """
        Specifies options when sharing an Amazon SageMaker Studio notebook. These settings are specified as part of DefaultUserSettings when the CreateDomain API is called, and as part of UserSettings when the CreateUserProfile API is called.
        :param pulumi.Input['UserProfileSharingSettingsNotebookOutputOption'] notebook_output_option: Whether to include the notebook cell output when sharing the notebook. The default is Disabled.
        :param pulumi.Input[str] s3_kms_key_id: When NotebookOutputOption is Allowed, the AWS Key Management Service (KMS) encryption key ID used to encrypt the notebook cell output in the Amazon S3 bucket.
        :param pulumi.Input[str] s3_output_path: When NotebookOutputOption is Allowed, the Amazon S3 bucket used to store the shared notebook snapshots.
        """
        if notebook_output_option is not None:
            pulumi.set(__self__, "notebook_output_option", notebook_output_option)
        if s3_kms_key_id is not None:
            pulumi.set(__self__, "s3_kms_key_id", s3_kms_key_id)
        if s3_output_path is not None:
            pulumi.set(__self__, "s3_output_path", s3_output_path)

    @property
    @pulumi.getter(name="notebookOutputOption")
    def notebook_output_option(self) -> Optional[pulumi.Input['UserProfileSharingSettingsNotebookOutputOption']]:
        """
        Whether to include the notebook cell output when sharing the notebook. The default is Disabled.
        """
        return pulumi.get(self, "notebook_output_option")

    @notebook_output_option.setter
    def notebook_output_option(self, value: Optional[pulumi.Input['UserProfileSharingSettingsNotebookOutputOption']]):
        pulumi.set(self, "notebook_output_option", value)

    @property
    @pulumi.getter(name="s3KmsKeyId")
    def s3_kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        When NotebookOutputOption is Allowed, the AWS Key Management Service (KMS) encryption key ID used to encrypt the notebook cell output in the Amazon S3 bucket.
        """
        return pulumi.get(self, "s3_kms_key_id")

    @s3_kms_key_id.setter
    def s3_kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_kms_key_id", value)

    @property
    @pulumi.getter(name="s3OutputPath")
    def s3_output_path(self) -> Optional[pulumi.Input[str]]:
        """
        When NotebookOutputOption is Allowed, the Amazon S3 bucket used to store the shared notebook snapshots.
        """
        return pulumi.get(self, "s3_output_path")

    @s3_output_path.setter
    def s3_output_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_output_path", value)


if not MYPY:
    class UserProfileStudioWebPortalSettingsArgsDict(TypedDict):
        """
        Studio settings. If these settings are applied on a user level, they take priority over the settings applied on a domain level.
        """
        hidden_app_types: NotRequired[pulumi.Input[Sequence[pulumi.Input['UserProfileAppType']]]]
        """
        Applications supported in Studio that are hidden from the Studio left navigation pane.
        """
        hidden_ml_tools: NotRequired[pulumi.Input[Sequence[pulumi.Input['UserProfileMlTools']]]]
        """
        The machine learning tools that are hidden from the Studio left navigation pane.
        """
elif False:
    UserProfileStudioWebPortalSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserProfileStudioWebPortalSettingsArgs:
    def __init__(__self__, *,
                 hidden_app_types: Optional[pulumi.Input[Sequence[pulumi.Input['UserProfileAppType']]]] = None,
                 hidden_ml_tools: Optional[pulumi.Input[Sequence[pulumi.Input['UserProfileMlTools']]]] = None):
        """
        Studio settings. If these settings are applied on a user level, they take priority over the settings applied on a domain level.
        :param pulumi.Input[Sequence[pulumi.Input['UserProfileAppType']]] hidden_app_types: Applications supported in Studio that are hidden from the Studio left navigation pane.
        :param pulumi.Input[Sequence[pulumi.Input['UserProfileMlTools']]] hidden_ml_tools: The machine learning tools that are hidden from the Studio left navigation pane.
        """
        if hidden_app_types is not None:
            pulumi.set(__self__, "hidden_app_types", hidden_app_types)
        if hidden_ml_tools is not None:
            pulumi.set(__self__, "hidden_ml_tools", hidden_ml_tools)

    @property
    @pulumi.getter(name="hiddenAppTypes")
    def hidden_app_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserProfileAppType']]]]:
        """
        Applications supported in Studio that are hidden from the Studio left navigation pane.
        """
        return pulumi.get(self, "hidden_app_types")

    @hidden_app_types.setter
    def hidden_app_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserProfileAppType']]]]):
        pulumi.set(self, "hidden_app_types", value)

    @property
    @pulumi.getter(name="hiddenMlTools")
    def hidden_ml_tools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserProfileMlTools']]]]:
        """
        The machine learning tools that are hidden from the Studio left navigation pane.
        """
        return pulumi.get(self, "hidden_ml_tools")

    @hidden_ml_tools.setter
    def hidden_ml_tools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserProfileMlTools']]]]):
        pulumi.set(self, "hidden_ml_tools", value)


if not MYPY:
    class UserProfileUserSettingsArgsDict(TypedDict):
        """
        A collection of settings that apply to users of Amazon SageMaker Studio. These settings are specified when the CreateUserProfile API is called, and as DefaultUserSettings when the CreateDomain API is called.
        """
        code_editor_app_settings: NotRequired[pulumi.Input['UserProfileCodeEditorAppSettingsArgsDict']]
        """
        The Code Editor application settings.

        SageMaker applies these settings only to private spaces that the user creates in the domain. SageMaker doesn't apply these settings to shared spaces.
        """
        custom_file_system_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['UserProfileCustomFileSystemConfigArgsDict']]]]
        """
        The settings for assigning a custom file system to a user profile. Permitted users can access this file system in Amazon SageMaker Studio.

        SageMaker applies these settings only to private spaces that the user creates in the domain. SageMaker doesn't apply these settings to shared spaces.
        """
        custom_posix_user_config: NotRequired[pulumi.Input['UserProfileCustomPosixUserConfigArgsDict']]
        """
        Details about the POSIX identity that is used for file system operations.

        SageMaker applies these settings only to private spaces that the user creates in the domain. SageMaker doesn't apply these settings to shared spaces.
        """
        default_landing_uri: NotRequired[pulumi.Input[str]]
        """
        Defines which Amazon SageMaker application users are directed to by default.
        """
        execution_role: NotRequired[pulumi.Input[str]]
        """
        The user profile Amazon Resource Name (ARN).
        """
        jupyter_lab_app_settings: NotRequired[pulumi.Input['UserProfileJupyterLabAppSettingsArgsDict']]
        """
        The settings for the JupyterLab application.

        SageMaker applies these settings only to private spaces that the user creates in the domain. SageMaker doesn't apply these settings to shared spaces.
        """
        jupyter_server_app_settings: NotRequired[pulumi.Input['UserProfileJupyterServerAppSettingsArgsDict']]
        """
        The Jupyter server's app settings.
        """
        kernel_gateway_app_settings: NotRequired[pulumi.Input['UserProfileKernelGatewayAppSettingsArgsDict']]
        """
        The kernel gateway app settings.
        """
        r_studio_server_pro_app_settings: NotRequired[pulumi.Input['UserProfileRStudioServerProAppSettingsArgsDict']]
        """
        A collection of settings that configure user interaction with the `RStudioServerPro` app.
        """
        security_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The security groups for the Amazon Virtual Private Cloud (VPC) that Studio uses for communication.
        """
        sharing_settings: NotRequired[pulumi.Input['UserProfileSharingSettingsArgsDict']]
        """
        The sharing settings.
        """
        space_storage_settings: NotRequired[pulumi.Input['UserProfileDefaultSpaceStorageSettingsArgsDict']]
        """
        The storage settings for a space.

        SageMaker applies these settings only to private spaces that the user creates in the domain. SageMaker doesn't apply these settings to shared spaces.
        """
        studio_web_portal: NotRequired[pulumi.Input['UserProfileUserSettingsStudioWebPortal']]
        """
        Indicates whether the Studio experience is available to users. If not, users cannot access Studio.
        """
        studio_web_portal_settings: NotRequired[pulumi.Input['UserProfileStudioWebPortalSettingsArgsDict']]
        """
        Studio settings. If these settings are applied on a user level, they take priority over the settings applied on a domain level.
        """
elif False:
    UserProfileUserSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserProfileUserSettingsArgs:
    def __init__(__self__, *,
                 code_editor_app_settings: Optional[pulumi.Input['UserProfileCodeEditorAppSettingsArgs']] = None,
                 custom_file_system_configs: Optional[pulumi.Input[Sequence[pulumi.Input['UserProfileCustomFileSystemConfigArgs']]]] = None,
                 custom_posix_user_config: Optional[pulumi.Input['UserProfileCustomPosixUserConfigArgs']] = None,
                 default_landing_uri: Optional[pulumi.Input[str]] = None,
                 execution_role: Optional[pulumi.Input[str]] = None,
                 jupyter_lab_app_settings: Optional[pulumi.Input['UserProfileJupyterLabAppSettingsArgs']] = None,
                 jupyter_server_app_settings: Optional[pulumi.Input['UserProfileJupyterServerAppSettingsArgs']] = None,
                 kernel_gateway_app_settings: Optional[pulumi.Input['UserProfileKernelGatewayAppSettingsArgs']] = None,
                 r_studio_server_pro_app_settings: Optional[pulumi.Input['UserProfileRStudioServerProAppSettingsArgs']] = None,
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 sharing_settings: Optional[pulumi.Input['UserProfileSharingSettingsArgs']] = None,
                 space_storage_settings: Optional[pulumi.Input['UserProfileDefaultSpaceStorageSettingsArgs']] = None,
                 studio_web_portal: Optional[pulumi.Input['UserProfileUserSettingsStudioWebPortal']] = None,
                 studio_web_portal_settings: Optional[pulumi.Input['UserProfileStudioWebPortalSettingsArgs']] = None):
        """
        A collection of settings that apply to users of Amazon SageMaker Studio. These settings are specified when the CreateUserProfile API is called, and as DefaultUserSettings when the CreateDomain API is called.
        :param pulumi.Input['UserProfileCodeEditorAppSettingsArgs'] code_editor_app_settings: The Code Editor application settings.
               
               SageMaker applies these settings only to private spaces that the user creates in the domain. SageMaker doesn't apply these settings to shared spaces.
        :param pulumi.Input[Sequence[pulumi.Input['UserProfileCustomFileSystemConfigArgs']]] custom_file_system_configs: The settings for assigning a custom file system to a user profile. Permitted users can access this file system in Amazon SageMaker Studio.
               
               SageMaker applies these settings only to private spaces that the user creates in the domain. SageMaker doesn't apply these settings to shared spaces.
        :param pulumi.Input['UserProfileCustomPosixUserConfigArgs'] custom_posix_user_config: Details about the POSIX identity that is used for file system operations.
               
               SageMaker applies these settings only to private spaces that the user creates in the domain. SageMaker doesn't apply these settings to shared spaces.
        :param pulumi.Input[str] default_landing_uri: Defines which Amazon SageMaker application users are directed to by default.
        :param pulumi.Input[str] execution_role: The user profile Amazon Resource Name (ARN).
        :param pulumi.Input['UserProfileJupyterLabAppSettingsArgs'] jupyter_lab_app_settings: The settings for the JupyterLab application.
               
               SageMaker applies these settings only to private spaces that the user creates in the domain. SageMaker doesn't apply these settings to shared spaces.
        :param pulumi.Input['UserProfileJupyterServerAppSettingsArgs'] jupyter_server_app_settings: The Jupyter server's app settings.
        :param pulumi.Input['UserProfileKernelGatewayAppSettingsArgs'] kernel_gateway_app_settings: The kernel gateway app settings.
        :param pulumi.Input['UserProfileRStudioServerProAppSettingsArgs'] r_studio_server_pro_app_settings: A collection of settings that configure user interaction with the `RStudioServerPro` app.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_groups: The security groups for the Amazon Virtual Private Cloud (VPC) that Studio uses for communication.
        :param pulumi.Input['UserProfileSharingSettingsArgs'] sharing_settings: The sharing settings.
        :param pulumi.Input['UserProfileDefaultSpaceStorageSettingsArgs'] space_storage_settings: The storage settings for a space.
               
               SageMaker applies these settings only to private spaces that the user creates in the domain. SageMaker doesn't apply these settings to shared spaces.
        :param pulumi.Input['UserProfileUserSettingsStudioWebPortal'] studio_web_portal: Indicates whether the Studio experience is available to users. If not, users cannot access Studio.
        :param pulumi.Input['UserProfileStudioWebPortalSettingsArgs'] studio_web_portal_settings: Studio settings. If these settings are applied on a user level, they take priority over the settings applied on a domain level.
        """
        if code_editor_app_settings is not None:
            pulumi.set(__self__, "code_editor_app_settings", code_editor_app_settings)
        if custom_file_system_configs is not None:
            pulumi.set(__self__, "custom_file_system_configs", custom_file_system_configs)
        if custom_posix_user_config is not None:
            pulumi.set(__self__, "custom_posix_user_config", custom_posix_user_config)
        if default_landing_uri is not None:
            pulumi.set(__self__, "default_landing_uri", default_landing_uri)
        if execution_role is not None:
            pulumi.set(__self__, "execution_role", execution_role)
        if jupyter_lab_app_settings is not None:
            pulumi.set(__self__, "jupyter_lab_app_settings", jupyter_lab_app_settings)
        if jupyter_server_app_settings is not None:
            pulumi.set(__self__, "jupyter_server_app_settings", jupyter_server_app_settings)
        if kernel_gateway_app_settings is not None:
            pulumi.set(__self__, "kernel_gateway_app_settings", kernel_gateway_app_settings)
        if r_studio_server_pro_app_settings is not None:
            pulumi.set(__self__, "r_studio_server_pro_app_settings", r_studio_server_pro_app_settings)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if sharing_settings is not None:
            pulumi.set(__self__, "sharing_settings", sharing_settings)
        if space_storage_settings is not None:
            pulumi.set(__self__, "space_storage_settings", space_storage_settings)
        if studio_web_portal is not None:
            pulumi.set(__self__, "studio_web_portal", studio_web_portal)
        if studio_web_portal_settings is not None:
            pulumi.set(__self__, "studio_web_portal_settings", studio_web_portal_settings)

    @property
    @pulumi.getter(name="codeEditorAppSettings")
    def code_editor_app_settings(self) -> Optional[pulumi.Input['UserProfileCodeEditorAppSettingsArgs']]:
        """
        The Code Editor application settings.

        SageMaker applies these settings only to private spaces that the user creates in the domain. SageMaker doesn't apply these settings to shared spaces.
        """
        return pulumi.get(self, "code_editor_app_settings")

    @code_editor_app_settings.setter
    def code_editor_app_settings(self, value: Optional[pulumi.Input['UserProfileCodeEditorAppSettingsArgs']]):
        pulumi.set(self, "code_editor_app_settings", value)

    @property
    @pulumi.getter(name="customFileSystemConfigs")
    def custom_file_system_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserProfileCustomFileSystemConfigArgs']]]]:
        """
        The settings for assigning a custom file system to a user profile. Permitted users can access this file system in Amazon SageMaker Studio.

        SageMaker applies these settings only to private spaces that the user creates in the domain. SageMaker doesn't apply these settings to shared spaces.
        """
        return pulumi.get(self, "custom_file_system_configs")

    @custom_file_system_configs.setter
    def custom_file_system_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserProfileCustomFileSystemConfigArgs']]]]):
        pulumi.set(self, "custom_file_system_configs", value)

    @property
    @pulumi.getter(name="customPosixUserConfig")
    def custom_posix_user_config(self) -> Optional[pulumi.Input['UserProfileCustomPosixUserConfigArgs']]:
        """
        Details about the POSIX identity that is used for file system operations.

        SageMaker applies these settings only to private spaces that the user creates in the domain. SageMaker doesn't apply these settings to shared spaces.
        """
        return pulumi.get(self, "custom_posix_user_config")

    @custom_posix_user_config.setter
    def custom_posix_user_config(self, value: Optional[pulumi.Input['UserProfileCustomPosixUserConfigArgs']]):
        pulumi.set(self, "custom_posix_user_config", value)

    @property
    @pulumi.getter(name="defaultLandingUri")
    def default_landing_uri(self) -> Optional[pulumi.Input[str]]:
        """
        Defines which Amazon SageMaker application users are directed to by default.
        """
        return pulumi.get(self, "default_landing_uri")

    @default_landing_uri.setter
    def default_landing_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_landing_uri", value)

    @property
    @pulumi.getter(name="executionRole")
    def execution_role(self) -> Optional[pulumi.Input[str]]:
        """
        The user profile Amazon Resource Name (ARN).
        """
        return pulumi.get(self, "execution_role")

    @execution_role.setter
    def execution_role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "execution_role", value)

    @property
    @pulumi.getter(name="jupyterLabAppSettings")
    def jupyter_lab_app_settings(self) -> Optional[pulumi.Input['UserProfileJupyterLabAppSettingsArgs']]:
        """
        The settings for the JupyterLab application.

        SageMaker applies these settings only to private spaces that the user creates in the domain. SageMaker doesn't apply these settings to shared spaces.
        """
        return pulumi.get(self, "jupyter_lab_app_settings")

    @jupyter_lab_app_settings.setter
    def jupyter_lab_app_settings(self, value: Optional[pulumi.Input['UserProfileJupyterLabAppSettingsArgs']]):
        pulumi.set(self, "jupyter_lab_app_settings", value)

    @property
    @pulumi.getter(name="jupyterServerAppSettings")
    def jupyter_server_app_settings(self) -> Optional[pulumi.Input['UserProfileJupyterServerAppSettingsArgs']]:
        """
        The Jupyter server's app settings.
        """
        return pulumi.get(self, "jupyter_server_app_settings")

    @jupyter_server_app_settings.setter
    def jupyter_server_app_settings(self, value: Optional[pulumi.Input['UserProfileJupyterServerAppSettingsArgs']]):
        pulumi.set(self, "jupyter_server_app_settings", value)

    @property
    @pulumi.getter(name="kernelGatewayAppSettings")
    def kernel_gateway_app_settings(self) -> Optional[pulumi.Input['UserProfileKernelGatewayAppSettingsArgs']]:
        """
        The kernel gateway app settings.
        """
        return pulumi.get(self, "kernel_gateway_app_settings")

    @kernel_gateway_app_settings.setter
    def kernel_gateway_app_settings(self, value: Optional[pulumi.Input['UserProfileKernelGatewayAppSettingsArgs']]):
        pulumi.set(self, "kernel_gateway_app_settings", value)

    @property
    @pulumi.getter(name="rStudioServerProAppSettings")
    def r_studio_server_pro_app_settings(self) -> Optional[pulumi.Input['UserProfileRStudioServerProAppSettingsArgs']]:
        """
        A collection of settings that configure user interaction with the `RStudioServerPro` app.
        """
        return pulumi.get(self, "r_studio_server_pro_app_settings")

    @r_studio_server_pro_app_settings.setter
    def r_studio_server_pro_app_settings(self, value: Optional[pulumi.Input['UserProfileRStudioServerProAppSettingsArgs']]):
        pulumi.set(self, "r_studio_server_pro_app_settings", value)

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The security groups for the Amazon Virtual Private Cloud (VPC) that Studio uses for communication.
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_groups", value)

    @property
    @pulumi.getter(name="sharingSettings")
    def sharing_settings(self) -> Optional[pulumi.Input['UserProfileSharingSettingsArgs']]:
        """
        The sharing settings.
        """
        return pulumi.get(self, "sharing_settings")

    @sharing_settings.setter
    def sharing_settings(self, value: Optional[pulumi.Input['UserProfileSharingSettingsArgs']]):
        pulumi.set(self, "sharing_settings", value)

    @property
    @pulumi.getter(name="spaceStorageSettings")
    def space_storage_settings(self) -> Optional[pulumi.Input['UserProfileDefaultSpaceStorageSettingsArgs']]:
        """
        The storage settings for a space.

        SageMaker applies these settings only to private spaces that the user creates in the domain. SageMaker doesn't apply these settings to shared spaces.
        """
        return pulumi.get(self, "space_storage_settings")

    @space_storage_settings.setter
    def space_storage_settings(self, value: Optional[pulumi.Input['UserProfileDefaultSpaceStorageSettingsArgs']]):
        pulumi.set(self, "space_storage_settings", value)

    @property
    @pulumi.getter(name="studioWebPortal")
    def studio_web_portal(self) -> Optional[pulumi.Input['UserProfileUserSettingsStudioWebPortal']]:
        """
        Indicates whether the Studio experience is available to users. If not, users cannot access Studio.
        """
        return pulumi.get(self, "studio_web_portal")

    @studio_web_portal.setter
    def studio_web_portal(self, value: Optional[pulumi.Input['UserProfileUserSettingsStudioWebPortal']]):
        pulumi.set(self, "studio_web_portal", value)

    @property
    @pulumi.getter(name="studioWebPortalSettings")
    def studio_web_portal_settings(self) -> Optional[pulumi.Input['UserProfileStudioWebPortalSettingsArgs']]:
        """
        Studio settings. If these settings are applied on a user level, they take priority over the settings applied on a domain level.
        """
        return pulumi.get(self, "studio_web_portal_settings")

    @studio_web_portal_settings.setter
    def studio_web_portal_settings(self, value: Optional[pulumi.Input['UserProfileStudioWebPortalSettingsArgs']]):
        pulumi.set(self, "studio_web_portal_settings", value)


