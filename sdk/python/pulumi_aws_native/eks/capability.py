# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from .. import _inputs as _root_inputs
from .. import outputs as _root_outputs
from ._enums import *
from ._inputs import *

__all__ = ['CapabilityArgs', 'Capability']

@pulumi.input_type
class CapabilityArgs:
    def __init__(__self__, *,
                 cluster_name: pulumi.Input[_builtins.str],
                 delete_propagation_policy: pulumi.Input['CapabilityDeletePropagationPolicy'],
                 role_arn: pulumi.Input[_builtins.str],
                 type: pulumi.Input['CapabilityType'],
                 capability_name: Optional[pulumi.Input[_builtins.str]] = None,
                 configuration: Optional[pulumi.Input['CapabilityConfigurationArgs']] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['_root_inputs.TagArgs']]]] = None):
        """
        The set of arguments for constructing a Capability resource.
        :param pulumi.Input[_builtins.str] cluster_name: The name of the EKS cluster where you want to create the capability.
        :param pulumi.Input['CapabilityDeletePropagationPolicy'] delete_propagation_policy: Specifies how Kubernetes resources managed by the capability should be handled when the capability is deleted. Currently, the only supported value is RETAIN which retains all Kubernetes resources managed by the capability when the capability is deleted.
        :param pulumi.Input[_builtins.str] role_arn: The Amazon Resource Name (ARN) of the IAM role that the capability uses to interact with AWS services. This role must have a trust policy that allows the EKS service principal to assume it, and it must have the necessary permissions for the capability type you're creating.
        :param pulumi.Input['CapabilityType'] type: The type of capability to create. Valid values are: ACK (AWS Controllers for Kubernetes, which lets you manage AWS resources directly from Kubernetes), ARGOCD (Argo CD for GitOps-based continuous delivery), or KRO (Kube Resource Orchestrator for composing and managing custom Kubernetes resources).
        :param pulumi.Input[_builtins.str] capability_name: A unique name for the capability. The name must be unique within your cluster and can contain alphanumeric characters, hyphens, and underscores.
        :param pulumi.Input['CapabilityConfigurationArgs'] configuration: The configuration settings for the capability. The structure of this object varies depending on the capability type. For Argo CD capabilities, you can configure IAM Identity Center integration, RBAC role mappings, and network access settings.
        :param pulumi.Input[Sequence[pulumi.Input['_root_inputs.TagArgs']]] tags: An array of key-value pairs to apply to this resource.
        """
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "delete_propagation_policy", delete_propagation_policy)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "type", type)
        if capability_name is not None:
            pulumi.set(__self__, "capability_name", capability_name)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the EKS cluster where you want to create the capability.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cluster_name", value)

    @_builtins.property
    @pulumi.getter(name="deletePropagationPolicy")
    def delete_propagation_policy(self) -> pulumi.Input['CapabilityDeletePropagationPolicy']:
        """
        Specifies how Kubernetes resources managed by the capability should be handled when the capability is deleted. Currently, the only supported value is RETAIN which retains all Kubernetes resources managed by the capability when the capability is deleted.
        """
        return pulumi.get(self, "delete_propagation_policy")

    @delete_propagation_policy.setter
    def delete_propagation_policy(self, value: pulumi.Input['CapabilityDeletePropagationPolicy']):
        pulumi.set(self, "delete_propagation_policy", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the IAM role that the capability uses to interact with AWS services. This role must have a trust policy that allows the EKS service principal to assume it, and it must have the necessary permissions for the capability type you're creating.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['CapabilityType']:
        """
        The type of capability to create. Valid values are: ACK (AWS Controllers for Kubernetes, which lets you manage AWS resources directly from Kubernetes), ARGOCD (Argo CD for GitOps-based continuous delivery), or KRO (Kube Resource Orchestrator for composing and managing custom Kubernetes resources).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['CapabilityType']):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="capabilityName")
    def capability_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A unique name for the capability. The name must be unique within your cluster and can contain alphanumeric characters, hyphens, and underscores.
        """
        return pulumi.get(self, "capability_name")

    @capability_name.setter
    def capability_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "capability_name", value)

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> Optional[pulumi.Input['CapabilityConfigurationArgs']]:
        """
        The configuration settings for the capability. The structure of this object varies depending on the capability type. For Argo CD capabilities, you can configure IAM Identity Center integration, RBAC role mappings, and network access settings.
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[pulumi.Input['CapabilityConfigurationArgs']]):
        pulumi.set(self, "configuration", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['_root_inputs.TagArgs']]]]:
        """
        An array of key-value pairs to apply to this resource.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['_root_inputs.TagArgs']]]]):
        pulumi.set(self, "tags", value)


@pulumi.type_token("aws-native:eks:Capability")
class Capability(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 capability_name: Optional[pulumi.Input[_builtins.str]] = None,
                 cluster_name: Optional[pulumi.Input[_builtins.str]] = None,
                 configuration: Optional[pulumi.Input[Union['CapabilityConfigurationArgs', 'CapabilityConfigurationArgsDict']]] = None,
                 delete_propagation_policy: Optional[pulumi.Input['CapabilityDeletePropagationPolicy']] = None,
                 role_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[Union['_root_inputs.TagArgs', '_root_inputs.TagArgsDict']]]]] = None,
                 type: Optional[pulumi.Input['CapabilityType']] = None,
                 __props__=None):
        """
        Resource Type definition for EKS Capability.

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[_builtins.str] capability_name: A unique name for the capability. The name must be unique within your cluster and can contain alphanumeric characters, hyphens, and underscores.
        :param pulumi.Input[_builtins.str] cluster_name: The name of the EKS cluster where you want to create the capability.
        :param pulumi.Input[Union['CapabilityConfigurationArgs', 'CapabilityConfigurationArgsDict']] configuration: The configuration settings for the capability. The structure of this object varies depending on the capability type. For Argo CD capabilities, you can configure IAM Identity Center integration, RBAC role mappings, and network access settings.
        :param pulumi.Input['CapabilityDeletePropagationPolicy'] delete_propagation_policy: Specifies how Kubernetes resources managed by the capability should be handled when the capability is deleted. Currently, the only supported value is RETAIN which retains all Kubernetes resources managed by the capability when the capability is deleted.
        :param pulumi.Input[_builtins.str] role_arn: The Amazon Resource Name (ARN) of the IAM role that the capability uses to interact with AWS services. This role must have a trust policy that allows the EKS service principal to assume it, and it must have the necessary permissions for the capability type you're creating.
        :param pulumi.Input[Sequence[pulumi.Input[Union['_root_inputs.TagArgs', '_root_inputs.TagArgsDict']]]] tags: An array of key-value pairs to apply to this resource.
        :param pulumi.Input['CapabilityType'] type: The type of capability to create. Valid values are: ACK (AWS Controllers for Kubernetes, which lets you manage AWS resources directly from Kubernetes), ARGOCD (Argo CD for GitOps-based continuous delivery), or KRO (Kube Resource Orchestrator for composing and managing custom Kubernetes resources).
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: CapabilityArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        Resource Type definition for EKS Capability.

        :param str resource_name: The name of the resource.
        :param CapabilityArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(CapabilityArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 capability_name: Optional[pulumi.Input[_builtins.str]] = None,
                 cluster_name: Optional[pulumi.Input[_builtins.str]] = None,
                 configuration: Optional[pulumi.Input[Union['CapabilityConfigurationArgs', 'CapabilityConfigurationArgsDict']]] = None,
                 delete_propagation_policy: Optional[pulumi.Input['CapabilityDeletePropagationPolicy']] = None,
                 role_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[Union['_root_inputs.TagArgs', '_root_inputs.TagArgsDict']]]]] = None,
                 type: Optional[pulumi.Input['CapabilityType']] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = CapabilityArgs.__new__(CapabilityArgs)

            __props__.__dict__["capability_name"] = capability_name
            if cluster_name is None and not opts.urn:
                raise TypeError("Missing required property 'cluster_name'")
            __props__.__dict__["cluster_name"] = cluster_name
            __props__.__dict__["configuration"] = configuration
            if delete_propagation_policy is None and not opts.urn:
                raise TypeError("Missing required property 'delete_propagation_policy'")
            __props__.__dict__["delete_propagation_policy"] = delete_propagation_policy
            if role_arn is None and not opts.urn:
                raise TypeError("Missing required property 'role_arn'")
            __props__.__dict__["role_arn"] = role_arn
            __props__.__dict__["tags"] = tags
            if type is None and not opts.urn:
                raise TypeError("Missing required property 'type'")
            __props__.__dict__["type"] = type
            __props__.__dict__["arn"] = None
            __props__.__dict__["created_at"] = None
            __props__.__dict__["modified_at"] = None
            __props__.__dict__["status"] = None
            __props__.__dict__["version"] = None
        replace_on_changes = pulumi.ResourceOptions(replace_on_changes=["capabilityName", "clusterName", "configuration.argoCd.awsIdc", "configuration.argoCd.namespace", "type"])
        opts = pulumi.ResourceOptions.merge(opts, replace_on_changes)
        super(Capability, __self__).__init__(
            'aws-native:eks:Capability',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None) -> 'Capability':
        """
        Get an existing Capability resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = CapabilityArgs.__new__(CapabilityArgs)

        __props__.__dict__["arn"] = None
        __props__.__dict__["capability_name"] = None
        __props__.__dict__["cluster_name"] = None
        __props__.__dict__["configuration"] = None
        __props__.__dict__["created_at"] = None
        __props__.__dict__["delete_propagation_policy"] = None
        __props__.__dict__["modified_at"] = None
        __props__.__dict__["role_arn"] = None
        __props__.__dict__["status"] = None
        __props__.__dict__["tags"] = None
        __props__.__dict__["type"] = None
        __props__.__dict__["version"] = None
        return Capability(resource_name, opts=opts, __props__=__props__)

    @_builtins.property
    @pulumi.getter
    def arn(self) -> pulumi.Output[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the capability.
        """
        return pulumi.get(self, "arn")

    @_builtins.property
    @pulumi.getter(name="capabilityName")
    def capability_name(self) -> pulumi.Output[_builtins.str]:
        """
        A unique name for the capability. The name must be unique within your cluster and can contain alphanumeric characters, hyphens, and underscores.
        """
        return pulumi.get(self, "capability_name")

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> pulumi.Output[_builtins.str]:
        """
        The name of the EKS cluster where you want to create the capability.
        """
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> pulumi.Output[Optional['outputs.CapabilityConfiguration']]:
        """
        The configuration settings for the capability. The structure of this object varies depending on the capability type. For Argo CD capabilities, you can configure IAM Identity Center integration, RBAC role mappings, and network access settings.
        """
        return pulumi.get(self, "configuration")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> pulumi.Output[_builtins.str]:
        """
        The Unix epoch timestamp in seconds for when the capability was created.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="deletePropagationPolicy")
    def delete_propagation_policy(self) -> pulumi.Output['CapabilityDeletePropagationPolicy']:
        """
        Specifies how Kubernetes resources managed by the capability should be handled when the capability is deleted. Currently, the only supported value is RETAIN which retains all Kubernetes resources managed by the capability when the capability is deleted.
        """
        return pulumi.get(self, "delete_propagation_policy")

    @_builtins.property
    @pulumi.getter(name="modifiedAt")
    def modified_at(self) -> pulumi.Output[_builtins.str]:
        """
        The Unix epoch timestamp in seconds for when the capability was last modified.
        """
        return pulumi.get(self, "modified_at")

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Output[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the IAM role that the capability uses to interact with AWS services. This role must have a trust policy that allows the EKS service principal to assume it, and it must have the necessary permissions for the capability type you're creating.
        """
        return pulumi.get(self, "role_arn")

    @_builtins.property
    @pulumi.getter
    def status(self) -> pulumi.Output[_builtins.str]:
        """
        The current status of the capability. Valid values include: CREATING (the capability is being created), ACTIVE (the capability is running and available), UPDATING (the capability is being updated), DELETING (the capability is being deleted), CREATE_FAILED (the capability creation failed), UPDATE_FAILED (the capability update failed), or DELETE_FAILED (the capability deletion failed).
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> pulumi.Output[Optional[Sequence['_root_outputs.Tag']]]:
        """
        An array of key-value pairs to apply to this resource.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Output['CapabilityType']:
        """
        The type of capability to create. Valid values are: ACK (AWS Controllers for Kubernetes, which lets you manage AWS resources directly from Kubernetes), ARGOCD (Argo CD for GitOps-based continuous delivery), or KRO (Kube Resource Orchestrator for composing and managing custom Kubernetes resources).
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def version(self) -> pulumi.Output[_builtins.str]:
        """
        The version of the capability software that is currently running.
        """
        return pulumi.get(self, "version")

