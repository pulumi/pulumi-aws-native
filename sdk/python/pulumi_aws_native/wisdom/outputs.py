# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AiAgentAiAgentConfiguration0Properties',
    'AiAgentAiAgentConfiguration1Properties',
    'AiAgentAiAgentConfiguration2Properties',
    'AiAgentAnswerRecommendationAiAgentConfiguration',
    'AiAgentAssociationConfiguration',
    'AiAgentAssociationConfigurationDataProperties',
    'AiAgentKnowledgeBaseAssociationConfigurationData',
    'AiAgentManualSearchAiAgentConfiguration',
    'AiAgentOrCondition0Properties',
    'AiAgentOrCondition1Properties',
    'AiAgentSelfServiceAiAgentConfiguration',
    'AiAgentTagCondition',
    'AiAgentTagFilter0Properties',
    'AiAgentTagFilter1Properties',
    'AiAgentTagFilter2Properties',
    'AiGuardrailAiGuardrailContentPolicyConfig',
    'AiGuardrailAiGuardrailContextualGroundingPolicyConfig',
    'AiGuardrailAiGuardrailSensitiveInformationPolicyConfig',
    'AiGuardrailAiGuardrailTopicPolicyConfig',
    'AiGuardrailAiGuardrailWordPolicyConfig',
    'AiGuardrailGuardrailContentFilterConfig',
    'AiGuardrailGuardrailContextualGroundingFilterConfig',
    'AiGuardrailGuardrailManagedWordsConfig',
    'AiGuardrailGuardrailPiiEntityConfig',
    'AiGuardrailGuardrailRegexConfig',
    'AiGuardrailGuardrailTopicConfig',
    'AiGuardrailGuardrailWordConfig',
    'AiPromptAiPromptTemplateConfiguration',
    'AssistantAssociationAssociationData',
    'AssistantServerSideEncryptionConfiguration',
    'KnowledgeBaseAppIntegrationsConfiguration',
    'KnowledgeBaseBedrockFoundationModelConfiguration',
    'KnowledgeBaseBedrockFoundationModelConfigurationParsingPromptProperties',
    'KnowledgeBaseFixedSizeChunkingConfiguration',
    'KnowledgeBaseHierarchicalChunkingConfiguration',
    'KnowledgeBaseHierarchicalChunkingLevelConfiguration',
    'KnowledgeBaseManagedSourceConfigurationProperties',
    'KnowledgeBaseRenderingConfiguration',
    'KnowledgeBaseSeedUrl',
    'KnowledgeBaseSemanticChunkingConfiguration',
    'KnowledgeBaseServerSideEncryptionConfiguration',
    'KnowledgeBaseSourceConfiguration0Properties',
    'KnowledgeBaseSourceConfiguration1Properties',
    'KnowledgeBaseVectorIngestionConfiguration',
    'KnowledgeBaseVectorIngestionConfigurationChunkingConfigurationProperties',
    'KnowledgeBaseVectorIngestionConfigurationParsingConfigurationProperties',
    'KnowledgeBaseWebCrawlerConfiguration',
    'KnowledgeBaseWebCrawlerConfigurationCrawlerLimitsProperties',
    'KnowledgeBaseWebCrawlerConfigurationUrlConfigurationProperties',
    'MessageTemplateAgentAttributes',
    'MessageTemplateAttachment',
    'MessageTemplateAttributes',
    'MessageTemplateBodyContentProvider',
    'MessageTemplateContent',
    'MessageTemplateCustomerProfileAttributes',
    'MessageTemplateEmailMessageTemplateContent',
    'MessageTemplateEmailMessageTemplateContentBody',
    'MessageTemplateEmailMessageTemplateHeader',
    'MessageTemplateGroupingConfiguration',
    'MessageTemplateSmsMessageTemplateContent',
    'MessageTemplateSmsMessageTemplateContentBody',
    'MessageTemplateSystemAttributes',
    'MessageTemplateSystemEndpointAttributes',
    'QuickResponseContentProvider',
    'QuickResponseContents',
    'QuickResponseGroupingConfiguration',
]

@pulumi.output_type
class AiAgentAiAgentConfiguration0Properties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "manualSearchAiAgentConfiguration":
            suggest = "manual_search_ai_agent_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AiAgentAiAgentConfiguration0Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AiAgentAiAgentConfiguration0Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AiAgentAiAgentConfiguration0Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 manual_search_ai_agent_configuration: 'outputs.AiAgentManualSearchAiAgentConfiguration'):
        pulumi.set(__self__, "manual_search_ai_agent_configuration", manual_search_ai_agent_configuration)

    @_builtins.property
    @pulumi.getter(name="manualSearchAiAgentConfiguration")
    def manual_search_ai_agent_configuration(self) -> 'outputs.AiAgentManualSearchAiAgentConfiguration':
        return pulumi.get(self, "manual_search_ai_agent_configuration")


@pulumi.output_type
class AiAgentAiAgentConfiguration1Properties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "answerRecommendationAiAgentConfiguration":
            suggest = "answer_recommendation_ai_agent_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AiAgentAiAgentConfiguration1Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AiAgentAiAgentConfiguration1Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AiAgentAiAgentConfiguration1Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 answer_recommendation_ai_agent_configuration: 'outputs.AiAgentAnswerRecommendationAiAgentConfiguration'):
        pulumi.set(__self__, "answer_recommendation_ai_agent_configuration", answer_recommendation_ai_agent_configuration)

    @_builtins.property
    @pulumi.getter(name="answerRecommendationAiAgentConfiguration")
    def answer_recommendation_ai_agent_configuration(self) -> 'outputs.AiAgentAnswerRecommendationAiAgentConfiguration':
        return pulumi.get(self, "answer_recommendation_ai_agent_configuration")


@pulumi.output_type
class AiAgentAiAgentConfiguration2Properties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "selfServiceAiAgentConfiguration":
            suggest = "self_service_ai_agent_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AiAgentAiAgentConfiguration2Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AiAgentAiAgentConfiguration2Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AiAgentAiAgentConfiguration2Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 self_service_ai_agent_configuration: 'outputs.AiAgentSelfServiceAiAgentConfiguration'):
        pulumi.set(__self__, "self_service_ai_agent_configuration", self_service_ai_agent_configuration)

    @_builtins.property
    @pulumi.getter(name="selfServiceAiAgentConfiguration")
    def self_service_ai_agent_configuration(self) -> 'outputs.AiAgentSelfServiceAiAgentConfiguration':
        return pulumi.get(self, "self_service_ai_agent_configuration")


@pulumi.output_type
class AiAgentAnswerRecommendationAiAgentConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "answerGenerationAiGuardrailId":
            suggest = "answer_generation_ai_guardrail_id"
        elif key == "answerGenerationAiPromptId":
            suggest = "answer_generation_ai_prompt_id"
        elif key == "associationConfigurations":
            suggest = "association_configurations"
        elif key == "intentLabelingGenerationAiPromptId":
            suggest = "intent_labeling_generation_ai_prompt_id"
        elif key == "queryReformulationAiPromptId":
            suggest = "query_reformulation_ai_prompt_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AiAgentAnswerRecommendationAiAgentConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AiAgentAnswerRecommendationAiAgentConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AiAgentAnswerRecommendationAiAgentConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 answer_generation_ai_guardrail_id: Optional[_builtins.str] = None,
                 answer_generation_ai_prompt_id: Optional[_builtins.str] = None,
                 association_configurations: Optional[Sequence['outputs.AiAgentAssociationConfiguration']] = None,
                 intent_labeling_generation_ai_prompt_id: Optional[_builtins.str] = None,
                 locale: Optional[_builtins.str] = None,
                 query_reformulation_ai_prompt_id: Optional[_builtins.str] = None):
        if answer_generation_ai_guardrail_id is not None:
            pulumi.set(__self__, "answer_generation_ai_guardrail_id", answer_generation_ai_guardrail_id)
        if answer_generation_ai_prompt_id is not None:
            pulumi.set(__self__, "answer_generation_ai_prompt_id", answer_generation_ai_prompt_id)
        if association_configurations is not None:
            pulumi.set(__self__, "association_configurations", association_configurations)
        if intent_labeling_generation_ai_prompt_id is not None:
            pulumi.set(__self__, "intent_labeling_generation_ai_prompt_id", intent_labeling_generation_ai_prompt_id)
        if locale is not None:
            pulumi.set(__self__, "locale", locale)
        if query_reformulation_ai_prompt_id is not None:
            pulumi.set(__self__, "query_reformulation_ai_prompt_id", query_reformulation_ai_prompt_id)

    @_builtins.property
    @pulumi.getter(name="answerGenerationAiGuardrailId")
    def answer_generation_ai_guardrail_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "answer_generation_ai_guardrail_id")

    @_builtins.property
    @pulumi.getter(name="answerGenerationAiPromptId")
    def answer_generation_ai_prompt_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "answer_generation_ai_prompt_id")

    @_builtins.property
    @pulumi.getter(name="associationConfigurations")
    def association_configurations(self) -> Optional[Sequence['outputs.AiAgentAssociationConfiguration']]:
        return pulumi.get(self, "association_configurations")

    @_builtins.property
    @pulumi.getter(name="intentLabelingGenerationAiPromptId")
    def intent_labeling_generation_ai_prompt_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "intent_labeling_generation_ai_prompt_id")

    @_builtins.property
    @pulumi.getter
    def locale(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "locale")

    @_builtins.property
    @pulumi.getter(name="queryReformulationAiPromptId")
    def query_reformulation_ai_prompt_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "query_reformulation_ai_prompt_id")


@pulumi.output_type
class AiAgentAssociationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "associationConfigurationData":
            suggest = "association_configuration_data"
        elif key == "associationId":
            suggest = "association_id"
        elif key == "associationType":
            suggest = "association_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AiAgentAssociationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AiAgentAssociationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AiAgentAssociationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 association_configuration_data: Optional['outputs.AiAgentAssociationConfigurationDataProperties'] = None,
                 association_id: Optional[_builtins.str] = None,
                 association_type: Optional['AiAgentAiAgentAssociationConfigurationType'] = None):
        if association_configuration_data is not None:
            pulumi.set(__self__, "association_configuration_data", association_configuration_data)
        if association_id is not None:
            pulumi.set(__self__, "association_id", association_id)
        if association_type is not None:
            pulumi.set(__self__, "association_type", association_type)

    @_builtins.property
    @pulumi.getter(name="associationConfigurationData")
    def association_configuration_data(self) -> Optional['outputs.AiAgentAssociationConfigurationDataProperties']:
        return pulumi.get(self, "association_configuration_data")

    @_builtins.property
    @pulumi.getter(name="associationId")
    def association_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "association_id")

    @_builtins.property
    @pulumi.getter(name="associationType")
    def association_type(self) -> Optional['AiAgentAiAgentAssociationConfigurationType']:
        return pulumi.get(self, "association_type")


@pulumi.output_type
class AiAgentAssociationConfigurationDataProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "knowledgeBaseAssociationConfigurationData":
            suggest = "knowledge_base_association_configuration_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AiAgentAssociationConfigurationDataProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AiAgentAssociationConfigurationDataProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AiAgentAssociationConfigurationDataProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 knowledge_base_association_configuration_data: 'outputs.AiAgentKnowledgeBaseAssociationConfigurationData'):
        pulumi.set(__self__, "knowledge_base_association_configuration_data", knowledge_base_association_configuration_data)

    @_builtins.property
    @pulumi.getter(name="knowledgeBaseAssociationConfigurationData")
    def knowledge_base_association_configuration_data(self) -> 'outputs.AiAgentKnowledgeBaseAssociationConfigurationData':
        return pulumi.get(self, "knowledge_base_association_configuration_data")


@pulumi.output_type
class AiAgentKnowledgeBaseAssociationConfigurationData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentTagFilter":
            suggest = "content_tag_filter"
        elif key == "maxResults":
            suggest = "max_results"
        elif key == "overrideKnowledgeBaseSearchType":
            suggest = "override_knowledge_base_search_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AiAgentKnowledgeBaseAssociationConfigurationData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AiAgentKnowledgeBaseAssociationConfigurationData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AiAgentKnowledgeBaseAssociationConfigurationData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content_tag_filter: Optional[Any] = None,
                 max_results: Optional[_builtins.float] = None,
                 override_knowledge_base_search_type: Optional['AiAgentKnowledgeBaseSearchType'] = None):
        if content_tag_filter is not None:
            pulumi.set(__self__, "content_tag_filter", content_tag_filter)
        if max_results is not None:
            pulumi.set(__self__, "max_results", max_results)
        if override_knowledge_base_search_type is not None:
            pulumi.set(__self__, "override_knowledge_base_search_type", override_knowledge_base_search_type)

    @_builtins.property
    @pulumi.getter(name="contentTagFilter")
    def content_tag_filter(self) -> Optional[Any]:
        return pulumi.get(self, "content_tag_filter")

    @_builtins.property
    @pulumi.getter(name="maxResults")
    def max_results(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "max_results")

    @_builtins.property
    @pulumi.getter(name="overrideKnowledgeBaseSearchType")
    def override_knowledge_base_search_type(self) -> Optional['AiAgentKnowledgeBaseSearchType']:
        return pulumi.get(self, "override_knowledge_base_search_type")


@pulumi.output_type
class AiAgentManualSearchAiAgentConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "answerGenerationAiGuardrailId":
            suggest = "answer_generation_ai_guardrail_id"
        elif key == "answerGenerationAiPromptId":
            suggest = "answer_generation_ai_prompt_id"
        elif key == "associationConfigurations":
            suggest = "association_configurations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AiAgentManualSearchAiAgentConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AiAgentManualSearchAiAgentConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AiAgentManualSearchAiAgentConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 answer_generation_ai_guardrail_id: Optional[_builtins.str] = None,
                 answer_generation_ai_prompt_id: Optional[_builtins.str] = None,
                 association_configurations: Optional[Sequence['outputs.AiAgentAssociationConfiguration']] = None,
                 locale: Optional[_builtins.str] = None):
        if answer_generation_ai_guardrail_id is not None:
            pulumi.set(__self__, "answer_generation_ai_guardrail_id", answer_generation_ai_guardrail_id)
        if answer_generation_ai_prompt_id is not None:
            pulumi.set(__self__, "answer_generation_ai_prompt_id", answer_generation_ai_prompt_id)
        if association_configurations is not None:
            pulumi.set(__self__, "association_configurations", association_configurations)
        if locale is not None:
            pulumi.set(__self__, "locale", locale)

    @_builtins.property
    @pulumi.getter(name="answerGenerationAiGuardrailId")
    def answer_generation_ai_guardrail_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "answer_generation_ai_guardrail_id")

    @_builtins.property
    @pulumi.getter(name="answerGenerationAiPromptId")
    def answer_generation_ai_prompt_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "answer_generation_ai_prompt_id")

    @_builtins.property
    @pulumi.getter(name="associationConfigurations")
    def association_configurations(self) -> Optional[Sequence['outputs.AiAgentAssociationConfiguration']]:
        return pulumi.get(self, "association_configurations")

    @_builtins.property
    @pulumi.getter
    def locale(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "locale")


@pulumi.output_type
class AiAgentOrCondition0Properties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "andConditions":
            suggest = "and_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AiAgentOrCondition0Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AiAgentOrCondition0Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AiAgentOrCondition0Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 and_conditions: Sequence['outputs.AiAgentTagCondition']):
        pulumi.set(__self__, "and_conditions", and_conditions)

    @_builtins.property
    @pulumi.getter(name="andConditions")
    def and_conditions(self) -> Sequence['outputs.AiAgentTagCondition']:
        return pulumi.get(self, "and_conditions")


@pulumi.output_type
class AiAgentOrCondition1Properties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagCondition":
            suggest = "tag_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AiAgentOrCondition1Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AiAgentOrCondition1Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AiAgentOrCondition1Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tag_condition: 'outputs.AiAgentTagCondition'):
        pulumi.set(__self__, "tag_condition", tag_condition)

    @_builtins.property
    @pulumi.getter(name="tagCondition")
    def tag_condition(self) -> 'outputs.AiAgentTagCondition':
        return pulumi.get(self, "tag_condition")


@pulumi.output_type
class AiAgentSelfServiceAiAgentConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "associationConfigurations":
            suggest = "association_configurations"
        elif key == "selfServiceAiGuardrailId":
            suggest = "self_service_ai_guardrail_id"
        elif key == "selfServiceAnswerGenerationAiPromptId":
            suggest = "self_service_answer_generation_ai_prompt_id"
        elif key == "selfServicePreProcessingAiPromptId":
            suggest = "self_service_pre_processing_ai_prompt_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AiAgentSelfServiceAiAgentConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AiAgentSelfServiceAiAgentConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AiAgentSelfServiceAiAgentConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 association_configurations: Optional[Sequence['outputs.AiAgentAssociationConfiguration']] = None,
                 self_service_ai_guardrail_id: Optional[_builtins.str] = None,
                 self_service_answer_generation_ai_prompt_id: Optional[_builtins.str] = None,
                 self_service_pre_processing_ai_prompt_id: Optional[_builtins.str] = None):
        if association_configurations is not None:
            pulumi.set(__self__, "association_configurations", association_configurations)
        if self_service_ai_guardrail_id is not None:
            pulumi.set(__self__, "self_service_ai_guardrail_id", self_service_ai_guardrail_id)
        if self_service_answer_generation_ai_prompt_id is not None:
            pulumi.set(__self__, "self_service_answer_generation_ai_prompt_id", self_service_answer_generation_ai_prompt_id)
        if self_service_pre_processing_ai_prompt_id is not None:
            pulumi.set(__self__, "self_service_pre_processing_ai_prompt_id", self_service_pre_processing_ai_prompt_id)

    @_builtins.property
    @pulumi.getter(name="associationConfigurations")
    def association_configurations(self) -> Optional[Sequence['outputs.AiAgentAssociationConfiguration']]:
        return pulumi.get(self, "association_configurations")

    @_builtins.property
    @pulumi.getter(name="selfServiceAiGuardrailId")
    def self_service_ai_guardrail_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "self_service_ai_guardrail_id")

    @_builtins.property
    @pulumi.getter(name="selfServiceAnswerGenerationAiPromptId")
    def self_service_answer_generation_ai_prompt_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "self_service_answer_generation_ai_prompt_id")

    @_builtins.property
    @pulumi.getter(name="selfServicePreProcessingAiPromptId")
    def self_service_pre_processing_ai_prompt_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "self_service_pre_processing_ai_prompt_id")


@pulumi.output_type
class AiAgentTagCondition(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: Optional[_builtins.str] = None):
        pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class AiAgentTagFilter0Properties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagCondition":
            suggest = "tag_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AiAgentTagFilter0Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AiAgentTagFilter0Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AiAgentTagFilter0Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tag_condition: 'outputs.AiAgentTagCondition'):
        pulumi.set(__self__, "tag_condition", tag_condition)

    @_builtins.property
    @pulumi.getter(name="tagCondition")
    def tag_condition(self) -> 'outputs.AiAgentTagCondition':
        return pulumi.get(self, "tag_condition")


@pulumi.output_type
class AiAgentTagFilter1Properties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "andConditions":
            suggest = "and_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AiAgentTagFilter1Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AiAgentTagFilter1Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AiAgentTagFilter1Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 and_conditions: Sequence['outputs.AiAgentTagCondition']):
        pulumi.set(__self__, "and_conditions", and_conditions)

    @_builtins.property
    @pulumi.getter(name="andConditions")
    def and_conditions(self) -> Sequence['outputs.AiAgentTagCondition']:
        return pulumi.get(self, "and_conditions")


@pulumi.output_type
class AiAgentTagFilter2Properties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "orConditions":
            suggest = "or_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AiAgentTagFilter2Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AiAgentTagFilter2Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AiAgentTagFilter2Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 or_conditions: Sequence[Any]):
        pulumi.set(__self__, "or_conditions", or_conditions)

    @_builtins.property
    @pulumi.getter(name="orConditions")
    def or_conditions(self) -> Sequence[Any]:
        return pulumi.get(self, "or_conditions")


@pulumi.output_type
class AiGuardrailAiGuardrailContentPolicyConfig(dict):
    """
    Content policy config for a guardrail.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filtersConfig":
            suggest = "filters_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AiGuardrailAiGuardrailContentPolicyConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AiGuardrailAiGuardrailContentPolicyConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AiGuardrailAiGuardrailContentPolicyConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filters_config: Sequence['outputs.AiGuardrailGuardrailContentFilterConfig']):
        """
        Content policy config for a guardrail.
        :param Sequence['AiGuardrailGuardrailContentFilterConfig'] filters_config: List of content filter configs in content policy.
        """
        pulumi.set(__self__, "filters_config", filters_config)

    @_builtins.property
    @pulumi.getter(name="filtersConfig")
    def filters_config(self) -> Sequence['outputs.AiGuardrailGuardrailContentFilterConfig']:
        """
        List of content filter configs in content policy.
        """
        return pulumi.get(self, "filters_config")


@pulumi.output_type
class AiGuardrailAiGuardrailContextualGroundingPolicyConfig(dict):
    """
    Contextual grounding policy config for a guardrail.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filtersConfig":
            suggest = "filters_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AiGuardrailAiGuardrailContextualGroundingPolicyConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AiGuardrailAiGuardrailContextualGroundingPolicyConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AiGuardrailAiGuardrailContextualGroundingPolicyConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filters_config: Sequence['outputs.AiGuardrailGuardrailContextualGroundingFilterConfig']):
        """
        Contextual grounding policy config for a guardrail.
        :param Sequence['AiGuardrailGuardrailContextualGroundingFilterConfig'] filters_config: List of contextual grounding filter configs.
        """
        pulumi.set(__self__, "filters_config", filters_config)

    @_builtins.property
    @pulumi.getter(name="filtersConfig")
    def filters_config(self) -> Sequence['outputs.AiGuardrailGuardrailContextualGroundingFilterConfig']:
        """
        List of contextual grounding filter configs.
        """
        return pulumi.get(self, "filters_config")


@pulumi.output_type
class AiGuardrailAiGuardrailSensitiveInformationPolicyConfig(dict):
    """
    Sensitive information policy config for a guardrail.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "piiEntitiesConfig":
            suggest = "pii_entities_config"
        elif key == "regexesConfig":
            suggest = "regexes_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AiGuardrailAiGuardrailSensitiveInformationPolicyConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AiGuardrailAiGuardrailSensitiveInformationPolicyConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AiGuardrailAiGuardrailSensitiveInformationPolicyConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pii_entities_config: Optional[Sequence['outputs.AiGuardrailGuardrailPiiEntityConfig']] = None,
                 regexes_config: Optional[Sequence['outputs.AiGuardrailGuardrailRegexConfig']] = None):
        """
        Sensitive information policy config for a guardrail.
        :param Sequence['AiGuardrailGuardrailPiiEntityConfig'] pii_entities_config: List of entities.
        :param Sequence['AiGuardrailGuardrailRegexConfig'] regexes_config: List of regex.
        """
        if pii_entities_config is not None:
            pulumi.set(__self__, "pii_entities_config", pii_entities_config)
        if regexes_config is not None:
            pulumi.set(__self__, "regexes_config", regexes_config)

    @_builtins.property
    @pulumi.getter(name="piiEntitiesConfig")
    def pii_entities_config(self) -> Optional[Sequence['outputs.AiGuardrailGuardrailPiiEntityConfig']]:
        """
        List of entities.
        """
        return pulumi.get(self, "pii_entities_config")

    @_builtins.property
    @pulumi.getter(name="regexesConfig")
    def regexes_config(self) -> Optional[Sequence['outputs.AiGuardrailGuardrailRegexConfig']]:
        """
        List of regex.
        """
        return pulumi.get(self, "regexes_config")


@pulumi.output_type
class AiGuardrailAiGuardrailTopicPolicyConfig(dict):
    """
    Topic policy config for a guardrail.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "topicsConfig":
            suggest = "topics_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AiGuardrailAiGuardrailTopicPolicyConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AiGuardrailAiGuardrailTopicPolicyConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AiGuardrailAiGuardrailTopicPolicyConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 topics_config: Sequence['outputs.AiGuardrailGuardrailTopicConfig']):
        """
        Topic policy config for a guardrail.
        :param Sequence['AiGuardrailGuardrailTopicConfig'] topics_config: List of topic configs in topic policy.
        """
        pulumi.set(__self__, "topics_config", topics_config)

    @_builtins.property
    @pulumi.getter(name="topicsConfig")
    def topics_config(self) -> Sequence['outputs.AiGuardrailGuardrailTopicConfig']:
        """
        List of topic configs in topic policy.
        """
        return pulumi.get(self, "topics_config")


@pulumi.output_type
class AiGuardrailAiGuardrailWordPolicyConfig(dict):
    """
    Word policy config for a guardrail.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managedWordListsConfig":
            suggest = "managed_word_lists_config"
        elif key == "wordsConfig":
            suggest = "words_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AiGuardrailAiGuardrailWordPolicyConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AiGuardrailAiGuardrailWordPolicyConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AiGuardrailAiGuardrailWordPolicyConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 managed_word_lists_config: Optional[Sequence['outputs.AiGuardrailGuardrailManagedWordsConfig']] = None,
                 words_config: Optional[Sequence['outputs.AiGuardrailGuardrailWordConfig']] = None):
        """
        Word policy config for a guardrail.
        :param Sequence['AiGuardrailGuardrailManagedWordsConfig'] managed_word_lists_config: A config for the list of managed words.
        :param Sequence['AiGuardrailGuardrailWordConfig'] words_config: List of custom word configs.
        """
        if managed_word_lists_config is not None:
            pulumi.set(__self__, "managed_word_lists_config", managed_word_lists_config)
        if words_config is not None:
            pulumi.set(__self__, "words_config", words_config)

    @_builtins.property
    @pulumi.getter(name="managedWordListsConfig")
    def managed_word_lists_config(self) -> Optional[Sequence['outputs.AiGuardrailGuardrailManagedWordsConfig']]:
        """
        A config for the list of managed words.
        """
        return pulumi.get(self, "managed_word_lists_config")

    @_builtins.property
    @pulumi.getter(name="wordsConfig")
    def words_config(self) -> Optional[Sequence['outputs.AiGuardrailGuardrailWordConfig']]:
        """
        List of custom word configs.
        """
        return pulumi.get(self, "words_config")


@pulumi.output_type
class AiGuardrailGuardrailContentFilterConfig(dict):
    """
    Content filter config in content policy.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputStrength":
            suggest = "input_strength"
        elif key == "outputStrength":
            suggest = "output_strength"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AiGuardrailGuardrailContentFilterConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AiGuardrailGuardrailContentFilterConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AiGuardrailGuardrailContentFilterConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input_strength: 'AiGuardrailGuardrailFilterStrength',
                 output_strength: 'AiGuardrailGuardrailFilterStrength',
                 type: 'AiGuardrailGuardrailContentFilterType'):
        """
        Content filter config in content policy.
        :param 'AiGuardrailGuardrailFilterStrength' input_strength: The strength of the input for the guardrail content filter.
        :param 'AiGuardrailGuardrailFilterStrength' output_strength: The output strength of the guardrail content filter.
        :param 'AiGuardrailGuardrailContentFilterType' type: The type of the guardrail content filter.
        """
        pulumi.set(__self__, "input_strength", input_strength)
        pulumi.set(__self__, "output_strength", output_strength)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="inputStrength")
    def input_strength(self) -> 'AiGuardrailGuardrailFilterStrength':
        """
        The strength of the input for the guardrail content filter.
        """
        return pulumi.get(self, "input_strength")

    @_builtins.property
    @pulumi.getter(name="outputStrength")
    def output_strength(self) -> 'AiGuardrailGuardrailFilterStrength':
        """
        The output strength of the guardrail content filter.
        """
        return pulumi.get(self, "output_strength")

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'AiGuardrailGuardrailContentFilterType':
        """
        The type of the guardrail content filter.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class AiGuardrailGuardrailContextualGroundingFilterConfig(dict):
    """
    A config for grounding filter.
    """
    def __init__(__self__, *,
                 threshold: _builtins.float,
                 type: 'AiGuardrailGuardrailContextualGroundingFilterType'):
        """
        A config for grounding filter.
        :param _builtins.float threshold: The threshold for this filter.
        :param 'AiGuardrailGuardrailContextualGroundingFilterType' type: The type of this filter.
        """
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> _builtins.float:
        """
        The threshold for this filter.
        """
        return pulumi.get(self, "threshold")

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'AiGuardrailGuardrailContextualGroundingFilterType':
        """
        The type of this filter.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class AiGuardrailGuardrailManagedWordsConfig(dict):
    """
    A managed words config.
    """
    def __init__(__self__, *,
                 type: 'AiGuardrailGuardrailManagedWordsType'):
        """
        A managed words config.
        :param 'AiGuardrailGuardrailManagedWordsType' type: The type of guardrail managed words.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'AiGuardrailGuardrailManagedWordsType':
        """
        The type of guardrail managed words.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class AiGuardrailGuardrailPiiEntityConfig(dict):
    """
    Pii entity configuration.
    """
    def __init__(__self__, *,
                 action: 'AiGuardrailGuardrailSensitiveInformationAction',
                 type: 'AiGuardrailGuardrailPiiEntityType'):
        """
        Pii entity configuration.
        :param 'AiGuardrailGuardrailSensitiveInformationAction' action: The action of guardrail PII entity configuration.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def action(self) -> 'AiGuardrailGuardrailSensitiveInformationAction':
        """
        The action of guardrail PII entity configuration.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'AiGuardrailGuardrailPiiEntityType':
        return pulumi.get(self, "type")


@pulumi.output_type
class AiGuardrailGuardrailRegexConfig(dict):
    """
    A regex configuration.
    """
    def __init__(__self__, *,
                 action: 'AiGuardrailGuardrailSensitiveInformationAction',
                 name: _builtins.str,
                 pattern: _builtins.str,
                 description: Optional[_builtins.str] = None):
        """
        A regex configuration.
        :param 'AiGuardrailGuardrailSensitiveInformationAction' action: The action of the guardrail regex configuration.
        :param _builtins.str name: The regex name.
        :param _builtins.str pattern: The regex pattern.
        :param _builtins.str description: The regex description.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pattern", pattern)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def action(self) -> 'AiGuardrailGuardrailSensitiveInformationAction':
        """
        The action of the guardrail regex configuration.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The regex name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def pattern(self) -> _builtins.str:
        """
        The regex pattern.
        """
        return pulumi.get(self, "pattern")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The regex description.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class AiGuardrailGuardrailTopicConfig(dict):
    """
    Topic config in topic policy.
    """
    def __init__(__self__, *,
                 definition: _builtins.str,
                 name: _builtins.str,
                 type: 'AiGuardrailGuardrailTopicType',
                 examples: Optional[Sequence[_builtins.str]] = None):
        """
        Topic config in topic policy.
        :param _builtins.str definition: Definition of topic in topic policy
        :param _builtins.str name: Name of topic in topic policy
        :param 'AiGuardrailGuardrailTopicType' type: Type of topic in a policy.
        :param Sequence[_builtins.str] examples: List of text examples
        """
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if examples is not None:
            pulumi.set(__self__, "examples", examples)

    @_builtins.property
    @pulumi.getter
    def definition(self) -> _builtins.str:
        """
        Definition of topic in topic policy
        """
        return pulumi.get(self, "definition")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of topic in topic policy
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'AiGuardrailGuardrailTopicType':
        """
        Type of topic in a policy.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def examples(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of text examples
        """
        return pulumi.get(self, "examples")


@pulumi.output_type
class AiGuardrailGuardrailWordConfig(dict):
    """
    A custom word config.
    """
    def __init__(__self__, *,
                 text: _builtins.str):
        """
        A custom word config.
        :param _builtins.str text: The custom word text.
        """
        pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def text(self) -> _builtins.str:
        """
        The custom word text.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class AiPromptAiPromptTemplateConfiguration(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class AssistantAssociationAssociationData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "knowledgeBaseId":
            suggest = "knowledge_base_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AssistantAssociationAssociationData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AssistantAssociationAssociationData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AssistantAssociationAssociationData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 knowledge_base_id: _builtins.str):
        """
        :param _builtins.str knowledge_base_id: The identifier of the knowledge base.
        """
        pulumi.set(__self__, "knowledge_base_id", knowledge_base_id)

    @_builtins.property
    @pulumi.getter(name="knowledgeBaseId")
    def knowledge_base_id(self) -> _builtins.str:
        """
        The identifier of the knowledge base.
        """
        return pulumi.get(self, "knowledge_base_id")


@pulumi.output_type
class AssistantServerSideEncryptionConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeyId":
            suggest = "kms_key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AssistantServerSideEncryptionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AssistantServerSideEncryptionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AssistantServerSideEncryptionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str kms_key_id: The customer managed key used for encryption. The customer managed key must have a policy that allows `kms:CreateGrant` and `kms:DescribeKey` permissions to the IAM identity using the key to invoke Wisdom. To use Wisdom with chat, the key policy must also allow `kms:Decrypt` , `kms:GenerateDataKey*` , and `kms:DescribeKey` permissions to the `connect.amazonaws.com` service principal. For more information about setting up a customer managed key for Wisdom, see [Enable Amazon Connect Wisdom for your instance](https://docs.aws.amazon.com/connect/latest/adminguide/enable-wisdom.html) . For information about valid ID values, see [Key identifiers (KeyId)](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id) in the *AWS Key Management Service Developer Guide* .
        """
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        """
        The customer managed key used for encryption. The customer managed key must have a policy that allows `kms:CreateGrant` and `kms:DescribeKey` permissions to the IAM identity using the key to invoke Wisdom. To use Wisdom with chat, the key policy must also allow `kms:Decrypt` , `kms:GenerateDataKey*` , and `kms:DescribeKey` permissions to the `connect.amazonaws.com` service principal. For more information about setting up a customer managed key for Wisdom, see [Enable Amazon Connect Wisdom for your instance](https://docs.aws.amazon.com/connect/latest/adminguide/enable-wisdom.html) . For information about valid ID values, see [Key identifiers (KeyId)](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id) in the *AWS Key Management Service Developer Guide* .
        """
        return pulumi.get(self, "kms_key_id")


@pulumi.output_type
class KnowledgeBaseAppIntegrationsConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appIntegrationArn":
            suggest = "app_integration_arn"
        elif key == "objectFields":
            suggest = "object_fields"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseAppIntegrationsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseAppIntegrationsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseAppIntegrationsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_integration_arn: _builtins.str,
                 object_fields: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "app_integration_arn", app_integration_arn)
        if object_fields is not None:
            pulumi.set(__self__, "object_fields", object_fields)

    @_builtins.property
    @pulumi.getter(name="appIntegrationArn")
    def app_integration_arn(self) -> _builtins.str:
        return pulumi.get(self, "app_integration_arn")

    @_builtins.property
    @pulumi.getter(name="objectFields")
    def object_fields(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "object_fields")


@pulumi.output_type
class KnowledgeBaseBedrockFoundationModelConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "modelArn":
            suggest = "model_arn"
        elif key == "parsingPrompt":
            suggest = "parsing_prompt"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseBedrockFoundationModelConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseBedrockFoundationModelConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseBedrockFoundationModelConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 model_arn: _builtins.str,
                 parsing_prompt: Optional['outputs.KnowledgeBaseBedrockFoundationModelConfigurationParsingPromptProperties'] = None):
        """
        :param _builtins.str model_arn: The model ARN of the Bedrock foundation model.
        :param 'KnowledgeBaseBedrockFoundationModelConfigurationParsingPromptProperties' parsing_prompt: The parsing prompt of the Bedrock foundation model configuration.
        """
        pulumi.set(__self__, "model_arn", model_arn)
        if parsing_prompt is not None:
            pulumi.set(__self__, "parsing_prompt", parsing_prompt)

    @_builtins.property
    @pulumi.getter(name="modelArn")
    def model_arn(self) -> _builtins.str:
        """
        The model ARN of the Bedrock foundation model.
        """
        return pulumi.get(self, "model_arn")

    @_builtins.property
    @pulumi.getter(name="parsingPrompt")
    def parsing_prompt(self) -> Optional['outputs.KnowledgeBaseBedrockFoundationModelConfigurationParsingPromptProperties']:
        """
        The parsing prompt of the Bedrock foundation model configuration.
        """
        return pulumi.get(self, "parsing_prompt")


@pulumi.output_type
class KnowledgeBaseBedrockFoundationModelConfigurationParsingPromptProperties(dict):
    """
    The parsing prompt of the Bedrock foundation model configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parsingPromptText":
            suggest = "parsing_prompt_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseBedrockFoundationModelConfigurationParsingPromptProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseBedrockFoundationModelConfigurationParsingPromptProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseBedrockFoundationModelConfigurationParsingPromptProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parsing_prompt_text: _builtins.str):
        """
        The parsing prompt of the Bedrock foundation model configuration.
        """
        pulumi.set(__self__, "parsing_prompt_text", parsing_prompt_text)

    @_builtins.property
    @pulumi.getter(name="parsingPromptText")
    def parsing_prompt_text(self) -> _builtins.str:
        return pulumi.get(self, "parsing_prompt_text")


@pulumi.output_type
class KnowledgeBaseFixedSizeChunkingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxTokens":
            suggest = "max_tokens"
        elif key == "overlapPercentage":
            suggest = "overlap_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseFixedSizeChunkingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseFixedSizeChunkingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseFixedSizeChunkingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_tokens: _builtins.float,
                 overlap_percentage: _builtins.float):
        """
        :param _builtins.float max_tokens: The maximum number of tokens to include in a chunk.
        :param _builtins.float overlap_percentage: The percentage of overlap between adjacent chunks of a data source.
        """
        pulumi.set(__self__, "max_tokens", max_tokens)
        pulumi.set(__self__, "overlap_percentage", overlap_percentage)

    @_builtins.property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> _builtins.float:
        """
        The maximum number of tokens to include in a chunk.
        """
        return pulumi.get(self, "max_tokens")

    @_builtins.property
    @pulumi.getter(name="overlapPercentage")
    def overlap_percentage(self) -> _builtins.float:
        """
        The percentage of overlap between adjacent chunks of a data source.
        """
        return pulumi.get(self, "overlap_percentage")


@pulumi.output_type
class KnowledgeBaseHierarchicalChunkingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "levelConfigurations":
            suggest = "level_configurations"
        elif key == "overlapTokens":
            suggest = "overlap_tokens"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseHierarchicalChunkingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseHierarchicalChunkingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseHierarchicalChunkingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 level_configurations: Sequence['outputs.KnowledgeBaseHierarchicalChunkingLevelConfiguration'],
                 overlap_tokens: _builtins.float):
        """
        :param Sequence['KnowledgeBaseHierarchicalChunkingLevelConfiguration'] level_configurations: Token settings for each layer.
        :param _builtins.float overlap_tokens: The number of tokens to repeat across chunks in the same layer.
        """
        pulumi.set(__self__, "level_configurations", level_configurations)
        pulumi.set(__self__, "overlap_tokens", overlap_tokens)

    @_builtins.property
    @pulumi.getter(name="levelConfigurations")
    def level_configurations(self) -> Sequence['outputs.KnowledgeBaseHierarchicalChunkingLevelConfiguration']:
        """
        Token settings for each layer.
        """
        return pulumi.get(self, "level_configurations")

    @_builtins.property
    @pulumi.getter(name="overlapTokens")
    def overlap_tokens(self) -> _builtins.float:
        """
        The number of tokens to repeat across chunks in the same layer.
        """
        return pulumi.get(self, "overlap_tokens")


@pulumi.output_type
class KnowledgeBaseHierarchicalChunkingLevelConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxTokens":
            suggest = "max_tokens"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseHierarchicalChunkingLevelConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseHierarchicalChunkingLevelConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseHierarchicalChunkingLevelConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_tokens: _builtins.float):
        """
        :param _builtins.float max_tokens: The maximum number of tokens that a chunk can contain in this layer.
        """
        pulumi.set(__self__, "max_tokens", max_tokens)

    @_builtins.property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> _builtins.float:
        """
        The maximum number of tokens that a chunk can contain in this layer.
        """
        return pulumi.get(self, "max_tokens")


@pulumi.output_type
class KnowledgeBaseManagedSourceConfigurationProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "webCrawlerConfiguration":
            suggest = "web_crawler_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseManagedSourceConfigurationProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseManagedSourceConfigurationProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseManagedSourceConfigurationProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 web_crawler_configuration: 'outputs.KnowledgeBaseWebCrawlerConfiguration'):
        pulumi.set(__self__, "web_crawler_configuration", web_crawler_configuration)

    @_builtins.property
    @pulumi.getter(name="webCrawlerConfiguration")
    def web_crawler_configuration(self) -> 'outputs.KnowledgeBaseWebCrawlerConfiguration':
        return pulumi.get(self, "web_crawler_configuration")


@pulumi.output_type
class KnowledgeBaseRenderingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "templateUri":
            suggest = "template_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseRenderingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseRenderingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseRenderingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 template_uri: Optional[_builtins.str] = None):
        """
        :param _builtins.str template_uri: A URI template containing exactly one variable in `${variableName}` format. This can only be set for `EXTERNAL` knowledge bases. For Salesforce, ServiceNow, and Zendesk, the variable must be one of the following:
               
               - Salesforce: `Id` , `ArticleNumber` , `VersionNumber` , `Title` , `PublishStatus` , or `IsDeleted`
               - ServiceNow: `number` , `short_description` , `sys_mod_count` , `workflow_state` , or `active`
               - Zendesk: `id` , `title` , `updated_at` , or `draft`
               
               The variable is replaced with the actual value for a piece of content when calling [GetContent](https://docs.aws.amazon.com/amazon-q-connect/latest/APIReference/API_GetContent.html) .
        """
        if template_uri is not None:
            pulumi.set(__self__, "template_uri", template_uri)

    @_builtins.property
    @pulumi.getter(name="templateUri")
    def template_uri(self) -> Optional[_builtins.str]:
        """
        A URI template containing exactly one variable in `${variableName}` format. This can only be set for `EXTERNAL` knowledge bases. For Salesforce, ServiceNow, and Zendesk, the variable must be one of the following:

        - Salesforce: `Id` , `ArticleNumber` , `VersionNumber` , `Title` , `PublishStatus` , or `IsDeleted`
        - ServiceNow: `number` , `short_description` , `sys_mod_count` , `workflow_state` , or `active`
        - Zendesk: `id` , `title` , `updated_at` , or `draft`

        The variable is replaced with the actual value for a piece of content when calling [GetContent](https://docs.aws.amazon.com/amazon-q-connect/latest/APIReference/API_GetContent.html) .
        """
        return pulumi.get(self, "template_uri")


@pulumi.output_type
class KnowledgeBaseSeedUrl(dict):
    def __init__(__self__, *,
                 url: Optional[_builtins.str] = None):
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "url")


@pulumi.output_type
class KnowledgeBaseSemanticChunkingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "breakpointPercentileThreshold":
            suggest = "breakpoint_percentile_threshold"
        elif key == "bufferSize":
            suggest = "buffer_size"
        elif key == "maxTokens":
            suggest = "max_tokens"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseSemanticChunkingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseSemanticChunkingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseSemanticChunkingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 breakpoint_percentile_threshold: _builtins.float,
                 buffer_size: _builtins.float,
                 max_tokens: _builtins.float):
        """
        :param _builtins.float breakpoint_percentile_threshold: The dissimilarity threshold for splitting chunks.
        :param _builtins.float buffer_size: The buffer size.
        :param _builtins.float max_tokens: The maximum number of tokens that a chunk can contain.
        """
        pulumi.set(__self__, "breakpoint_percentile_threshold", breakpoint_percentile_threshold)
        pulumi.set(__self__, "buffer_size", buffer_size)
        pulumi.set(__self__, "max_tokens", max_tokens)

    @_builtins.property
    @pulumi.getter(name="breakpointPercentileThreshold")
    def breakpoint_percentile_threshold(self) -> _builtins.float:
        """
        The dissimilarity threshold for splitting chunks.
        """
        return pulumi.get(self, "breakpoint_percentile_threshold")

    @_builtins.property
    @pulumi.getter(name="bufferSize")
    def buffer_size(self) -> _builtins.float:
        """
        The buffer size.
        """
        return pulumi.get(self, "buffer_size")

    @_builtins.property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> _builtins.float:
        """
        The maximum number of tokens that a chunk can contain.
        """
        return pulumi.get(self, "max_tokens")


@pulumi.output_type
class KnowledgeBaseServerSideEncryptionConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeyId":
            suggest = "kms_key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseServerSideEncryptionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseServerSideEncryptionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseServerSideEncryptionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str kms_key_id: The customer managed key used for encryption.
               
               This customer managed key must have a policy that allows `kms:CreateGrant` and `kms:DescribeKey` permissions to the IAM identity using the key to invoke Wisdom.
               
               For more information about setting up a customer managed key for Wisdom, see [Enable Amazon Connect Wisdom for your instance](https://docs.aws.amazon.com/connect/latest/adminguide/enable-wisdom.html) . For information about valid ID values, see [Key identifiers (KeyId)](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id) .
        """
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)

    @_builtins.property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[_builtins.str]:
        """
        The customer managed key used for encryption.

        This customer managed key must have a policy that allows `kms:CreateGrant` and `kms:DescribeKey` permissions to the IAM identity using the key to invoke Wisdom.

        For more information about setting up a customer managed key for Wisdom, see [Enable Amazon Connect Wisdom for your instance](https://docs.aws.amazon.com/connect/latest/adminguide/enable-wisdom.html) . For information about valid ID values, see [Key identifiers (KeyId)](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id) .
        """
        return pulumi.get(self, "kms_key_id")


@pulumi.output_type
class KnowledgeBaseSourceConfiguration0Properties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appIntegrations":
            suggest = "app_integrations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseSourceConfiguration0Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseSourceConfiguration0Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseSourceConfiguration0Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 app_integrations: 'outputs.KnowledgeBaseAppIntegrationsConfiguration'):
        pulumi.set(__self__, "app_integrations", app_integrations)

    @_builtins.property
    @pulumi.getter(name="appIntegrations")
    def app_integrations(self) -> 'outputs.KnowledgeBaseAppIntegrationsConfiguration':
        return pulumi.get(self, "app_integrations")


@pulumi.output_type
class KnowledgeBaseSourceConfiguration1Properties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managedSourceConfiguration":
            suggest = "managed_source_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseSourceConfiguration1Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseSourceConfiguration1Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseSourceConfiguration1Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 managed_source_configuration: 'outputs.KnowledgeBaseManagedSourceConfigurationProperties'):
        pulumi.set(__self__, "managed_source_configuration", managed_source_configuration)

    @_builtins.property
    @pulumi.getter(name="managedSourceConfiguration")
    def managed_source_configuration(self) -> 'outputs.KnowledgeBaseManagedSourceConfigurationProperties':
        return pulumi.get(self, "managed_source_configuration")


@pulumi.output_type
class KnowledgeBaseVectorIngestionConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chunkingConfiguration":
            suggest = "chunking_configuration"
        elif key == "parsingConfiguration":
            suggest = "parsing_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseVectorIngestionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseVectorIngestionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseVectorIngestionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 chunking_configuration: Optional['outputs.KnowledgeBaseVectorIngestionConfigurationChunkingConfigurationProperties'] = None,
                 parsing_configuration: Optional['outputs.KnowledgeBaseVectorIngestionConfigurationParsingConfigurationProperties'] = None):
        """
        :param 'KnowledgeBaseVectorIngestionConfigurationChunkingConfigurationProperties' chunking_configuration: Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried.
        :param 'KnowledgeBaseVectorIngestionConfigurationParsingConfigurationProperties' parsing_configuration: A custom parser for data source documents.
        """
        if chunking_configuration is not None:
            pulumi.set(__self__, "chunking_configuration", chunking_configuration)
        if parsing_configuration is not None:
            pulumi.set(__self__, "parsing_configuration", parsing_configuration)

    @_builtins.property
    @pulumi.getter(name="chunkingConfiguration")
    def chunking_configuration(self) -> Optional['outputs.KnowledgeBaseVectorIngestionConfigurationChunkingConfigurationProperties']:
        """
        Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried.
        """
        return pulumi.get(self, "chunking_configuration")

    @_builtins.property
    @pulumi.getter(name="parsingConfiguration")
    def parsing_configuration(self) -> Optional['outputs.KnowledgeBaseVectorIngestionConfigurationParsingConfigurationProperties']:
        """
        A custom parser for data source documents.
        """
        return pulumi.get(self, "parsing_configuration")


@pulumi.output_type
class KnowledgeBaseVectorIngestionConfigurationChunkingConfigurationProperties(dict):
    """
    Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chunkingStrategy":
            suggest = "chunking_strategy"
        elif key == "fixedSizeChunkingConfiguration":
            suggest = "fixed_size_chunking_configuration"
        elif key == "hierarchicalChunkingConfiguration":
            suggest = "hierarchical_chunking_configuration"
        elif key == "semanticChunkingConfiguration":
            suggest = "semantic_chunking_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseVectorIngestionConfigurationChunkingConfigurationProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseVectorIngestionConfigurationChunkingConfigurationProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseVectorIngestionConfigurationChunkingConfigurationProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 chunking_strategy: 'KnowledgeBaseVectorIngestionConfigurationChunkingConfigurationPropertiesChunkingStrategy',
                 fixed_size_chunking_configuration: Optional['outputs.KnowledgeBaseFixedSizeChunkingConfiguration'] = None,
                 hierarchical_chunking_configuration: Optional['outputs.KnowledgeBaseHierarchicalChunkingConfiguration'] = None,
                 semantic_chunking_configuration: Optional['outputs.KnowledgeBaseSemanticChunkingConfiguration'] = None):
        """
        Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried.
        """
        pulumi.set(__self__, "chunking_strategy", chunking_strategy)
        if fixed_size_chunking_configuration is not None:
            pulumi.set(__self__, "fixed_size_chunking_configuration", fixed_size_chunking_configuration)
        if hierarchical_chunking_configuration is not None:
            pulumi.set(__self__, "hierarchical_chunking_configuration", hierarchical_chunking_configuration)
        if semantic_chunking_configuration is not None:
            pulumi.set(__self__, "semantic_chunking_configuration", semantic_chunking_configuration)

    @_builtins.property
    @pulumi.getter(name="chunkingStrategy")
    def chunking_strategy(self) -> 'KnowledgeBaseVectorIngestionConfigurationChunkingConfigurationPropertiesChunkingStrategy':
        return pulumi.get(self, "chunking_strategy")

    @_builtins.property
    @pulumi.getter(name="fixedSizeChunkingConfiguration")
    def fixed_size_chunking_configuration(self) -> Optional['outputs.KnowledgeBaseFixedSizeChunkingConfiguration']:
        return pulumi.get(self, "fixed_size_chunking_configuration")

    @_builtins.property
    @pulumi.getter(name="hierarchicalChunkingConfiguration")
    def hierarchical_chunking_configuration(self) -> Optional['outputs.KnowledgeBaseHierarchicalChunkingConfiguration']:
        return pulumi.get(self, "hierarchical_chunking_configuration")

    @_builtins.property
    @pulumi.getter(name="semanticChunkingConfiguration")
    def semantic_chunking_configuration(self) -> Optional['outputs.KnowledgeBaseSemanticChunkingConfiguration']:
        return pulumi.get(self, "semantic_chunking_configuration")


@pulumi.output_type
class KnowledgeBaseVectorIngestionConfigurationParsingConfigurationProperties(dict):
    """
    A custom parser for data source documents.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parsingStrategy":
            suggest = "parsing_strategy"
        elif key == "bedrockFoundationModelConfiguration":
            suggest = "bedrock_foundation_model_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseVectorIngestionConfigurationParsingConfigurationProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseVectorIngestionConfigurationParsingConfigurationProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseVectorIngestionConfigurationParsingConfigurationProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parsing_strategy: 'KnowledgeBaseVectorIngestionConfigurationParsingConfigurationPropertiesParsingStrategy',
                 bedrock_foundation_model_configuration: Optional['outputs.KnowledgeBaseBedrockFoundationModelConfiguration'] = None):
        """
        A custom parser for data source documents.
        """
        pulumi.set(__self__, "parsing_strategy", parsing_strategy)
        if bedrock_foundation_model_configuration is not None:
            pulumi.set(__self__, "bedrock_foundation_model_configuration", bedrock_foundation_model_configuration)

    @_builtins.property
    @pulumi.getter(name="parsingStrategy")
    def parsing_strategy(self) -> 'KnowledgeBaseVectorIngestionConfigurationParsingConfigurationPropertiesParsingStrategy':
        return pulumi.get(self, "parsing_strategy")

    @_builtins.property
    @pulumi.getter(name="bedrockFoundationModelConfiguration")
    def bedrock_foundation_model_configuration(self) -> Optional['outputs.KnowledgeBaseBedrockFoundationModelConfiguration']:
        return pulumi.get(self, "bedrock_foundation_model_configuration")


@pulumi.output_type
class KnowledgeBaseWebCrawlerConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "urlConfiguration":
            suggest = "url_configuration"
        elif key == "crawlerLimits":
            suggest = "crawler_limits"
        elif key == "exclusionFilters":
            suggest = "exclusion_filters"
        elif key == "inclusionFilters":
            suggest = "inclusion_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseWebCrawlerConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseWebCrawlerConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseWebCrawlerConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url_configuration: 'outputs.KnowledgeBaseWebCrawlerConfigurationUrlConfigurationProperties',
                 crawler_limits: Optional['outputs.KnowledgeBaseWebCrawlerConfigurationCrawlerLimitsProperties'] = None,
                 exclusion_filters: Optional[Sequence[_builtins.str]] = None,
                 inclusion_filters: Optional[Sequence[_builtins.str]] = None,
                 scope: Optional['KnowledgeBaseWebCrawlerConfigurationScope'] = None):
        pulumi.set(__self__, "url_configuration", url_configuration)
        if crawler_limits is not None:
            pulumi.set(__self__, "crawler_limits", crawler_limits)
        if exclusion_filters is not None:
            pulumi.set(__self__, "exclusion_filters", exclusion_filters)
        if inclusion_filters is not None:
            pulumi.set(__self__, "inclusion_filters", inclusion_filters)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @_builtins.property
    @pulumi.getter(name="urlConfiguration")
    def url_configuration(self) -> 'outputs.KnowledgeBaseWebCrawlerConfigurationUrlConfigurationProperties':
        return pulumi.get(self, "url_configuration")

    @_builtins.property
    @pulumi.getter(name="crawlerLimits")
    def crawler_limits(self) -> Optional['outputs.KnowledgeBaseWebCrawlerConfigurationCrawlerLimitsProperties']:
        return pulumi.get(self, "crawler_limits")

    @_builtins.property
    @pulumi.getter(name="exclusionFilters")
    def exclusion_filters(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "exclusion_filters")

    @_builtins.property
    @pulumi.getter(name="inclusionFilters")
    def inclusion_filters(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "inclusion_filters")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional['KnowledgeBaseWebCrawlerConfigurationScope']:
        return pulumi.get(self, "scope")


@pulumi.output_type
class KnowledgeBaseWebCrawlerConfigurationCrawlerLimitsProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rateLimit":
            suggest = "rate_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseWebCrawlerConfigurationCrawlerLimitsProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseWebCrawlerConfigurationCrawlerLimitsProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseWebCrawlerConfigurationCrawlerLimitsProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rate_limit: Optional[_builtins.float] = None):
        if rate_limit is not None:
            pulumi.set(__self__, "rate_limit", rate_limit)

    @_builtins.property
    @pulumi.getter(name="rateLimit")
    def rate_limit(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "rate_limit")


@pulumi.output_type
class KnowledgeBaseWebCrawlerConfigurationUrlConfigurationProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "seedUrls":
            suggest = "seed_urls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseWebCrawlerConfigurationUrlConfigurationProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseWebCrawlerConfigurationUrlConfigurationProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseWebCrawlerConfigurationUrlConfigurationProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 seed_urls: Optional[Sequence['outputs.KnowledgeBaseSeedUrl']] = None):
        if seed_urls is not None:
            pulumi.set(__self__, "seed_urls", seed_urls)

    @_builtins.property
    @pulumi.getter(name="seedUrls")
    def seed_urls(self) -> Optional[Sequence['outputs.KnowledgeBaseSeedUrl']]:
        return pulumi.get(self, "seed_urls")


@pulumi.output_type
class MessageTemplateAgentAttributes(dict):
    """
    The agent attributes that are used with the message template.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "firstName":
            suggest = "first_name"
        elif key == "lastName":
            suggest = "last_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MessageTemplateAgentAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MessageTemplateAgentAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MessageTemplateAgentAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 first_name: Optional[_builtins.str] = None,
                 last_name: Optional[_builtins.str] = None):
        """
        The agent attributes that are used with the message template.
        :param _builtins.str first_name: The agent’s first name as entered in their Amazon Connect user account.
        :param _builtins.str last_name: The agent’s last name as entered in their Amazon Connect user account.
        """
        if first_name is not None:
            pulumi.set(__self__, "first_name", first_name)
        if last_name is not None:
            pulumi.set(__self__, "last_name", last_name)

    @_builtins.property
    @pulumi.getter(name="firstName")
    def first_name(self) -> Optional[_builtins.str]:
        """
        The agent’s first name as entered in their Amazon Connect user account.
        """
        return pulumi.get(self, "first_name")

    @_builtins.property
    @pulumi.getter(name="lastName")
    def last_name(self) -> Optional[_builtins.str]:
        """
        The agent’s last name as entered in their Amazon Connect user account.
        """
        return pulumi.get(self, "last_name")


@pulumi.output_type
class MessageTemplateAttachment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attachmentName":
            suggest = "attachment_name"
        elif key == "s3PresignedUrl":
            suggest = "s3_presigned_url"
        elif key == "attachmentId":
            suggest = "attachment_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MessageTemplateAttachment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MessageTemplateAttachment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MessageTemplateAttachment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attachment_name: _builtins.str,
                 s3_presigned_url: _builtins.str,
                 attachment_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str attachment_name: The name of the attachment file being uploaded. The name should include the file extension.
        :param _builtins.str s3_presigned_url: The S3 Presigned URL for the attachment file. When generating the PreSignedUrl, please ensure that the expires-in time is set to 30 minutes. The URL can be generated through the AWS Console or through the AWS CLI. For more information, see [Sharing objects with presigned URLs](https://docs.aws.amazon.com/AmazonS3/latest/userguide/ShareObjectPreSignedURL.html) .
        :param _builtins.str attachment_id: The identifier of the attachment file.
        """
        pulumi.set(__self__, "attachment_name", attachment_name)
        pulumi.set(__self__, "s3_presigned_url", s3_presigned_url)
        if attachment_id is not None:
            pulumi.set(__self__, "attachment_id", attachment_id)

    @_builtins.property
    @pulumi.getter(name="attachmentName")
    def attachment_name(self) -> _builtins.str:
        """
        The name of the attachment file being uploaded. The name should include the file extension.
        """
        return pulumi.get(self, "attachment_name")

    @_builtins.property
    @pulumi.getter(name="s3PresignedUrl")
    def s3_presigned_url(self) -> _builtins.str:
        """
        The S3 Presigned URL for the attachment file. When generating the PreSignedUrl, please ensure that the expires-in time is set to 30 minutes. The URL can be generated through the AWS Console or through the AWS CLI. For more information, see [Sharing objects with presigned URLs](https://docs.aws.amazon.com/AmazonS3/latest/userguide/ShareObjectPreSignedURL.html) .
        """
        return pulumi.get(self, "s3_presigned_url")

    @_builtins.property
    @pulumi.getter(name="attachmentId")
    def attachment_id(self) -> Optional[_builtins.str]:
        """
        The identifier of the attachment file.
        """
        return pulumi.get(self, "attachment_id")


@pulumi.output_type
class MessageTemplateAttributes(dict):
    """
    An object that specifies the default values to use for variables in the message template. This object contains different categories of key-value pairs. Each key defines a variable or placeholder in the message template. The corresponding value defines the default value for that variable.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "agentAttributes":
            suggest = "agent_attributes"
        elif key == "customAttributes":
            suggest = "custom_attributes"
        elif key == "customerProfileAttributes":
            suggest = "customer_profile_attributes"
        elif key == "systemAttributes":
            suggest = "system_attributes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MessageTemplateAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MessageTemplateAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MessageTemplateAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 agent_attributes: Optional['outputs.MessageTemplateAgentAttributes'] = None,
                 custom_attributes: Optional[Mapping[str, _builtins.str]] = None,
                 customer_profile_attributes: Optional['outputs.MessageTemplateCustomerProfileAttributes'] = None,
                 system_attributes: Optional['outputs.MessageTemplateSystemAttributes'] = None):
        """
        An object that specifies the default values to use for variables in the message template. This object contains different categories of key-value pairs. Each key defines a variable or placeholder in the message template. The corresponding value defines the default value for that variable.
        :param 'MessageTemplateAgentAttributes' agent_attributes: The agent attributes that are used with the message template.
        :param Mapping[str, _builtins.str] custom_attributes: The custom attributes that are used with the message template.
        :param 'MessageTemplateCustomerProfileAttributes' customer_profile_attributes: The customer profile attributes that are used with the message template.
        :param 'MessageTemplateSystemAttributes' system_attributes: The system attributes that are used with the message template.
        """
        if agent_attributes is not None:
            pulumi.set(__self__, "agent_attributes", agent_attributes)
        if custom_attributes is not None:
            pulumi.set(__self__, "custom_attributes", custom_attributes)
        if customer_profile_attributes is not None:
            pulumi.set(__self__, "customer_profile_attributes", customer_profile_attributes)
        if system_attributes is not None:
            pulumi.set(__self__, "system_attributes", system_attributes)

    @_builtins.property
    @pulumi.getter(name="agentAttributes")
    def agent_attributes(self) -> Optional['outputs.MessageTemplateAgentAttributes']:
        """
        The agent attributes that are used with the message template.
        """
        return pulumi.get(self, "agent_attributes")

    @_builtins.property
    @pulumi.getter(name="customAttributes")
    def custom_attributes(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        The custom attributes that are used with the message template.
        """
        return pulumi.get(self, "custom_attributes")

    @_builtins.property
    @pulumi.getter(name="customerProfileAttributes")
    def customer_profile_attributes(self) -> Optional['outputs.MessageTemplateCustomerProfileAttributes']:
        """
        The customer profile attributes that are used with the message template.
        """
        return pulumi.get(self, "customer_profile_attributes")

    @_builtins.property
    @pulumi.getter(name="systemAttributes")
    def system_attributes(self) -> Optional['outputs.MessageTemplateSystemAttributes']:
        """
        The system attributes that are used with the message template.
        """
        return pulumi.get(self, "system_attributes")


@pulumi.output_type
class MessageTemplateBodyContentProvider(dict):
    """
    The container of message template body.
    """
    def __init__(__self__, *,
                 content: Optional[_builtins.str] = None):
        """
        The container of message template body.
        :param _builtins.str content: The content of the message template.
        """
        if content is not None:
            pulumi.set(__self__, "content", content)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[_builtins.str]:
        """
        The content of the message template.
        """
        return pulumi.get(self, "content")


@pulumi.output_type
class MessageTemplateContent(dict):
    """
    The content of the message template.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "emailMessageTemplateContent":
            suggest = "email_message_template_content"
        elif key == "smsMessageTemplateContent":
            suggest = "sms_message_template_content"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MessageTemplateContent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MessageTemplateContent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MessageTemplateContent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 email_message_template_content: Optional['outputs.MessageTemplateEmailMessageTemplateContent'] = None,
                 sms_message_template_content: Optional['outputs.MessageTemplateSmsMessageTemplateContent'] = None):
        """
        The content of the message template.
        :param 'MessageTemplateEmailMessageTemplateContent' email_message_template_content: The content of the message template that applies to the email channel subtype.
        :param 'MessageTemplateSmsMessageTemplateContent' sms_message_template_content: The content of message template that applies to SMS channel subtype.
        """
        if email_message_template_content is not None:
            pulumi.set(__self__, "email_message_template_content", email_message_template_content)
        if sms_message_template_content is not None:
            pulumi.set(__self__, "sms_message_template_content", sms_message_template_content)

    @_builtins.property
    @pulumi.getter(name="emailMessageTemplateContent")
    def email_message_template_content(self) -> Optional['outputs.MessageTemplateEmailMessageTemplateContent']:
        """
        The content of the message template that applies to the email channel subtype.
        """
        return pulumi.get(self, "email_message_template_content")

    @_builtins.property
    @pulumi.getter(name="smsMessageTemplateContent")
    def sms_message_template_content(self) -> Optional['outputs.MessageTemplateSmsMessageTemplateContent']:
        """
        The content of message template that applies to SMS channel subtype.
        """
        return pulumi.get(self, "sms_message_template_content")


@pulumi.output_type
class MessageTemplateCustomerProfileAttributes(dict):
    """
    The customer profile attributes that are used with the message template.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountNumber":
            suggest = "account_number"
        elif key == "additionalInformation":
            suggest = "additional_information"
        elif key == "billingAddress1":
            suggest = "billing_address1"
        elif key == "billingAddress2":
            suggest = "billing_address2"
        elif key == "billingAddress3":
            suggest = "billing_address3"
        elif key == "billingAddress4":
            suggest = "billing_address4"
        elif key == "billingCity":
            suggest = "billing_city"
        elif key == "billingCountry":
            suggest = "billing_country"
        elif key == "billingCounty":
            suggest = "billing_county"
        elif key == "billingPostalCode":
            suggest = "billing_postal_code"
        elif key == "billingProvince":
            suggest = "billing_province"
        elif key == "billingState":
            suggest = "billing_state"
        elif key == "birthDate":
            suggest = "birth_date"
        elif key == "businessEmailAddress":
            suggest = "business_email_address"
        elif key == "businessName":
            suggest = "business_name"
        elif key == "businessPhoneNumber":
            suggest = "business_phone_number"
        elif key == "emailAddress":
            suggest = "email_address"
        elif key == "firstName":
            suggest = "first_name"
        elif key == "homePhoneNumber":
            suggest = "home_phone_number"
        elif key == "lastName":
            suggest = "last_name"
        elif key == "mailingAddress1":
            suggest = "mailing_address1"
        elif key == "mailingAddress2":
            suggest = "mailing_address2"
        elif key == "mailingAddress3":
            suggest = "mailing_address3"
        elif key == "mailingAddress4":
            suggest = "mailing_address4"
        elif key == "mailingCity":
            suggest = "mailing_city"
        elif key == "mailingCountry":
            suggest = "mailing_country"
        elif key == "mailingCounty":
            suggest = "mailing_county"
        elif key == "mailingPostalCode":
            suggest = "mailing_postal_code"
        elif key == "mailingProvince":
            suggest = "mailing_province"
        elif key == "mailingState":
            suggest = "mailing_state"
        elif key == "middleName":
            suggest = "middle_name"
        elif key == "mobilePhoneNumber":
            suggest = "mobile_phone_number"
        elif key == "partyType":
            suggest = "party_type"
        elif key == "phoneNumber":
            suggest = "phone_number"
        elif key == "postalCode":
            suggest = "postal_code"
        elif key == "profileArn":
            suggest = "profile_arn"
        elif key == "profileId":
            suggest = "profile_id"
        elif key == "shippingAddress1":
            suggest = "shipping_address1"
        elif key == "shippingAddress2":
            suggest = "shipping_address2"
        elif key == "shippingAddress3":
            suggest = "shipping_address3"
        elif key == "shippingAddress4":
            suggest = "shipping_address4"
        elif key == "shippingCity":
            suggest = "shipping_city"
        elif key == "shippingCountry":
            suggest = "shipping_country"
        elif key == "shippingCounty":
            suggest = "shipping_county"
        elif key == "shippingPostalCode":
            suggest = "shipping_postal_code"
        elif key == "shippingProvince":
            suggest = "shipping_province"
        elif key == "shippingState":
            suggest = "shipping_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MessageTemplateCustomerProfileAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MessageTemplateCustomerProfileAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MessageTemplateCustomerProfileAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_number: Optional[_builtins.str] = None,
                 additional_information: Optional[_builtins.str] = None,
                 address1: Optional[_builtins.str] = None,
                 address2: Optional[_builtins.str] = None,
                 address3: Optional[_builtins.str] = None,
                 address4: Optional[_builtins.str] = None,
                 billing_address1: Optional[_builtins.str] = None,
                 billing_address2: Optional[_builtins.str] = None,
                 billing_address3: Optional[_builtins.str] = None,
                 billing_address4: Optional[_builtins.str] = None,
                 billing_city: Optional[_builtins.str] = None,
                 billing_country: Optional[_builtins.str] = None,
                 billing_county: Optional[_builtins.str] = None,
                 billing_postal_code: Optional[_builtins.str] = None,
                 billing_province: Optional[_builtins.str] = None,
                 billing_state: Optional[_builtins.str] = None,
                 birth_date: Optional[_builtins.str] = None,
                 business_email_address: Optional[_builtins.str] = None,
                 business_name: Optional[_builtins.str] = None,
                 business_phone_number: Optional[_builtins.str] = None,
                 city: Optional[_builtins.str] = None,
                 country: Optional[_builtins.str] = None,
                 county: Optional[_builtins.str] = None,
                 custom: Optional[Mapping[str, _builtins.str]] = None,
                 email_address: Optional[_builtins.str] = None,
                 first_name: Optional[_builtins.str] = None,
                 gender: Optional[_builtins.str] = None,
                 home_phone_number: Optional[_builtins.str] = None,
                 last_name: Optional[_builtins.str] = None,
                 mailing_address1: Optional[_builtins.str] = None,
                 mailing_address2: Optional[_builtins.str] = None,
                 mailing_address3: Optional[_builtins.str] = None,
                 mailing_address4: Optional[_builtins.str] = None,
                 mailing_city: Optional[_builtins.str] = None,
                 mailing_country: Optional[_builtins.str] = None,
                 mailing_county: Optional[_builtins.str] = None,
                 mailing_postal_code: Optional[_builtins.str] = None,
                 mailing_province: Optional[_builtins.str] = None,
                 mailing_state: Optional[_builtins.str] = None,
                 middle_name: Optional[_builtins.str] = None,
                 mobile_phone_number: Optional[_builtins.str] = None,
                 party_type: Optional[_builtins.str] = None,
                 phone_number: Optional[_builtins.str] = None,
                 postal_code: Optional[_builtins.str] = None,
                 profile_arn: Optional[_builtins.str] = None,
                 profile_id: Optional[_builtins.str] = None,
                 province: Optional[_builtins.str] = None,
                 shipping_address1: Optional[_builtins.str] = None,
                 shipping_address2: Optional[_builtins.str] = None,
                 shipping_address3: Optional[_builtins.str] = None,
                 shipping_address4: Optional[_builtins.str] = None,
                 shipping_city: Optional[_builtins.str] = None,
                 shipping_country: Optional[_builtins.str] = None,
                 shipping_county: Optional[_builtins.str] = None,
                 shipping_postal_code: Optional[_builtins.str] = None,
                 shipping_province: Optional[_builtins.str] = None,
                 shipping_state: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None):
        """
        The customer profile attributes that are used with the message template.
        :param _builtins.str account_number: A unique account number that you have given to the customer.
        :param _builtins.str additional_information: Any additional information relevant to the customer's profile.
        :param _builtins.str address1: The first line of a customer address.
        :param _builtins.str address2: The second line of a customer address.
        :param _builtins.str address3: The third line of a customer address.
        :param _builtins.str address4: The fourth line of a customer address.
        :param _builtins.str billing_address1: The first line of a customer’s billing address.
        :param _builtins.str billing_address2: The second line of a customer’s billing address.
        :param _builtins.str billing_address3: The third line of a customer’s billing address.
        :param _builtins.str billing_address4: The fourth line of a customer’s billing address.
        :param _builtins.str billing_city: The city of a customer’s billing address.
        :param _builtins.str billing_country: The country of a customer’s billing address.
        :param _builtins.str billing_county: The county of a customer’s billing address.
        :param _builtins.str billing_postal_code: The postal code of a customer’s billing address.
        :param _builtins.str billing_province: The province of a customer’s billing address.
        :param _builtins.str billing_state: The state of a customer’s billing address.
        :param _builtins.str birth_date: The customer's birth date.
        :param _builtins.str business_email_address: The customer's business email address.
        :param _builtins.str business_name: The name of the customer's business.
        :param _builtins.str business_phone_number: The customer's business phone number.
        :param _builtins.str city: The city in which a customer lives.
        :param _builtins.str country: The country in which a customer lives.
        :param _builtins.str county: The county in which a customer lives.
        :param Mapping[str, _builtins.str] custom: The custom attributes in customer profile attributes.
        :param _builtins.str email_address: The customer's email address, which has not been specified as a personal or business address.
        :param _builtins.str first_name: The customer's first name.
        :param _builtins.str gender: The customer's gender.
        :param _builtins.str home_phone_number: The customer's home phone number.
        :param _builtins.str last_name: The customer's last name.
        :param _builtins.str mailing_address1: The first line of a customer’s mailing address.
        :param _builtins.str mailing_address2: The second line of a customer’s mailing address.
        :param _builtins.str mailing_address3: The third line of a customer’s mailing address.
        :param _builtins.str mailing_address4: The fourth line of a customer’s mailing address.
        :param _builtins.str mailing_city: The city of a customer’s mailing address.
        :param _builtins.str mailing_country: The country of a customer’s mailing address.
        :param _builtins.str mailing_county: The county of a customer’s mailing address.
        :param _builtins.str mailing_postal_code: The postal code of a customer’s mailing address
        :param _builtins.str mailing_province: The province of a customer’s mailing address.
        :param _builtins.str mailing_state: The state of a customer’s mailing address.
        :param _builtins.str middle_name: The customer's middle name.
        :param _builtins.str mobile_phone_number: The customer's mobile phone number.
        :param _builtins.str party_type: The customer's party type.
        :param _builtins.str phone_number: The customer's phone number, which has not been specified as a mobile, home, or business number.
        :param _builtins.str postal_code: The postal code of a customer address.
        :param _builtins.str profile_arn: The ARN of a customer profile.
        :param _builtins.str profile_id: The unique identifier of a customer profile.
        :param _builtins.str province: The province in which a customer lives.
        :param _builtins.str shipping_address1: The first line of a customer’s shipping address.
        :param _builtins.str shipping_address2: The second line of a customer’s shipping address.
        :param _builtins.str shipping_address3: The third line of a customer’s shipping address.
        :param _builtins.str shipping_address4: The fourth line of a customer’s shipping address
        :param _builtins.str shipping_city: The city of a customer’s shipping address.
        :param _builtins.str shipping_country: The country of a customer’s shipping address.
        :param _builtins.str shipping_county: The county of a customer’s shipping address.
        :param _builtins.str shipping_postal_code: The postal code of a customer’s shipping address.
        :param _builtins.str shipping_province: The province of a customer’s shipping address.
        :param _builtins.str shipping_state: The state of a customer’s shipping address.
        :param _builtins.str state: The state in which a customer lives.
        """
        if account_number is not None:
            pulumi.set(__self__, "account_number", account_number)
        if additional_information is not None:
            pulumi.set(__self__, "additional_information", additional_information)
        if address1 is not None:
            pulumi.set(__self__, "address1", address1)
        if address2 is not None:
            pulumi.set(__self__, "address2", address2)
        if address3 is not None:
            pulumi.set(__self__, "address3", address3)
        if address4 is not None:
            pulumi.set(__self__, "address4", address4)
        if billing_address1 is not None:
            pulumi.set(__self__, "billing_address1", billing_address1)
        if billing_address2 is not None:
            pulumi.set(__self__, "billing_address2", billing_address2)
        if billing_address3 is not None:
            pulumi.set(__self__, "billing_address3", billing_address3)
        if billing_address4 is not None:
            pulumi.set(__self__, "billing_address4", billing_address4)
        if billing_city is not None:
            pulumi.set(__self__, "billing_city", billing_city)
        if billing_country is not None:
            pulumi.set(__self__, "billing_country", billing_country)
        if billing_county is not None:
            pulumi.set(__self__, "billing_county", billing_county)
        if billing_postal_code is not None:
            pulumi.set(__self__, "billing_postal_code", billing_postal_code)
        if billing_province is not None:
            pulumi.set(__self__, "billing_province", billing_province)
        if billing_state is not None:
            pulumi.set(__self__, "billing_state", billing_state)
        if birth_date is not None:
            pulumi.set(__self__, "birth_date", birth_date)
        if business_email_address is not None:
            pulumi.set(__self__, "business_email_address", business_email_address)
        if business_name is not None:
            pulumi.set(__self__, "business_name", business_name)
        if business_phone_number is not None:
            pulumi.set(__self__, "business_phone_number", business_phone_number)
        if city is not None:
            pulumi.set(__self__, "city", city)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if county is not None:
            pulumi.set(__self__, "county", county)
        if custom is not None:
            pulumi.set(__self__, "custom", custom)
        if email_address is not None:
            pulumi.set(__self__, "email_address", email_address)
        if first_name is not None:
            pulumi.set(__self__, "first_name", first_name)
        if gender is not None:
            pulumi.set(__self__, "gender", gender)
        if home_phone_number is not None:
            pulumi.set(__self__, "home_phone_number", home_phone_number)
        if last_name is not None:
            pulumi.set(__self__, "last_name", last_name)
        if mailing_address1 is not None:
            pulumi.set(__self__, "mailing_address1", mailing_address1)
        if mailing_address2 is not None:
            pulumi.set(__self__, "mailing_address2", mailing_address2)
        if mailing_address3 is not None:
            pulumi.set(__self__, "mailing_address3", mailing_address3)
        if mailing_address4 is not None:
            pulumi.set(__self__, "mailing_address4", mailing_address4)
        if mailing_city is not None:
            pulumi.set(__self__, "mailing_city", mailing_city)
        if mailing_country is not None:
            pulumi.set(__self__, "mailing_country", mailing_country)
        if mailing_county is not None:
            pulumi.set(__self__, "mailing_county", mailing_county)
        if mailing_postal_code is not None:
            pulumi.set(__self__, "mailing_postal_code", mailing_postal_code)
        if mailing_province is not None:
            pulumi.set(__self__, "mailing_province", mailing_province)
        if mailing_state is not None:
            pulumi.set(__self__, "mailing_state", mailing_state)
        if middle_name is not None:
            pulumi.set(__self__, "middle_name", middle_name)
        if mobile_phone_number is not None:
            pulumi.set(__self__, "mobile_phone_number", mobile_phone_number)
        if party_type is not None:
            pulumi.set(__self__, "party_type", party_type)
        if phone_number is not None:
            pulumi.set(__self__, "phone_number", phone_number)
        if postal_code is not None:
            pulumi.set(__self__, "postal_code", postal_code)
        if profile_arn is not None:
            pulumi.set(__self__, "profile_arn", profile_arn)
        if profile_id is not None:
            pulumi.set(__self__, "profile_id", profile_id)
        if province is not None:
            pulumi.set(__self__, "province", province)
        if shipping_address1 is not None:
            pulumi.set(__self__, "shipping_address1", shipping_address1)
        if shipping_address2 is not None:
            pulumi.set(__self__, "shipping_address2", shipping_address2)
        if shipping_address3 is not None:
            pulumi.set(__self__, "shipping_address3", shipping_address3)
        if shipping_address4 is not None:
            pulumi.set(__self__, "shipping_address4", shipping_address4)
        if shipping_city is not None:
            pulumi.set(__self__, "shipping_city", shipping_city)
        if shipping_country is not None:
            pulumi.set(__self__, "shipping_country", shipping_country)
        if shipping_county is not None:
            pulumi.set(__self__, "shipping_county", shipping_county)
        if shipping_postal_code is not None:
            pulumi.set(__self__, "shipping_postal_code", shipping_postal_code)
        if shipping_province is not None:
            pulumi.set(__self__, "shipping_province", shipping_province)
        if shipping_state is not None:
            pulumi.set(__self__, "shipping_state", shipping_state)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="accountNumber")
    def account_number(self) -> Optional[_builtins.str]:
        """
        A unique account number that you have given to the customer.
        """
        return pulumi.get(self, "account_number")

    @_builtins.property
    @pulumi.getter(name="additionalInformation")
    def additional_information(self) -> Optional[_builtins.str]:
        """
        Any additional information relevant to the customer's profile.
        """
        return pulumi.get(self, "additional_information")

    @_builtins.property
    @pulumi.getter
    def address1(self) -> Optional[_builtins.str]:
        """
        The first line of a customer address.
        """
        return pulumi.get(self, "address1")

    @_builtins.property
    @pulumi.getter
    def address2(self) -> Optional[_builtins.str]:
        """
        The second line of a customer address.
        """
        return pulumi.get(self, "address2")

    @_builtins.property
    @pulumi.getter
    def address3(self) -> Optional[_builtins.str]:
        """
        The third line of a customer address.
        """
        return pulumi.get(self, "address3")

    @_builtins.property
    @pulumi.getter
    def address4(self) -> Optional[_builtins.str]:
        """
        The fourth line of a customer address.
        """
        return pulumi.get(self, "address4")

    @_builtins.property
    @pulumi.getter(name="billingAddress1")
    def billing_address1(self) -> Optional[_builtins.str]:
        """
        The first line of a customer’s billing address.
        """
        return pulumi.get(self, "billing_address1")

    @_builtins.property
    @pulumi.getter(name="billingAddress2")
    def billing_address2(self) -> Optional[_builtins.str]:
        """
        The second line of a customer’s billing address.
        """
        return pulumi.get(self, "billing_address2")

    @_builtins.property
    @pulumi.getter(name="billingAddress3")
    def billing_address3(self) -> Optional[_builtins.str]:
        """
        The third line of a customer’s billing address.
        """
        return pulumi.get(self, "billing_address3")

    @_builtins.property
    @pulumi.getter(name="billingAddress4")
    def billing_address4(self) -> Optional[_builtins.str]:
        """
        The fourth line of a customer’s billing address.
        """
        return pulumi.get(self, "billing_address4")

    @_builtins.property
    @pulumi.getter(name="billingCity")
    def billing_city(self) -> Optional[_builtins.str]:
        """
        The city of a customer’s billing address.
        """
        return pulumi.get(self, "billing_city")

    @_builtins.property
    @pulumi.getter(name="billingCountry")
    def billing_country(self) -> Optional[_builtins.str]:
        """
        The country of a customer’s billing address.
        """
        return pulumi.get(self, "billing_country")

    @_builtins.property
    @pulumi.getter(name="billingCounty")
    def billing_county(self) -> Optional[_builtins.str]:
        """
        The county of a customer’s billing address.
        """
        return pulumi.get(self, "billing_county")

    @_builtins.property
    @pulumi.getter(name="billingPostalCode")
    def billing_postal_code(self) -> Optional[_builtins.str]:
        """
        The postal code of a customer’s billing address.
        """
        return pulumi.get(self, "billing_postal_code")

    @_builtins.property
    @pulumi.getter(name="billingProvince")
    def billing_province(self) -> Optional[_builtins.str]:
        """
        The province of a customer’s billing address.
        """
        return pulumi.get(self, "billing_province")

    @_builtins.property
    @pulumi.getter(name="billingState")
    def billing_state(self) -> Optional[_builtins.str]:
        """
        The state of a customer’s billing address.
        """
        return pulumi.get(self, "billing_state")

    @_builtins.property
    @pulumi.getter(name="birthDate")
    def birth_date(self) -> Optional[_builtins.str]:
        """
        The customer's birth date.
        """
        return pulumi.get(self, "birth_date")

    @_builtins.property
    @pulumi.getter(name="businessEmailAddress")
    def business_email_address(self) -> Optional[_builtins.str]:
        """
        The customer's business email address.
        """
        return pulumi.get(self, "business_email_address")

    @_builtins.property
    @pulumi.getter(name="businessName")
    def business_name(self) -> Optional[_builtins.str]:
        """
        The name of the customer's business.
        """
        return pulumi.get(self, "business_name")

    @_builtins.property
    @pulumi.getter(name="businessPhoneNumber")
    def business_phone_number(self) -> Optional[_builtins.str]:
        """
        The customer's business phone number.
        """
        return pulumi.get(self, "business_phone_number")

    @_builtins.property
    @pulumi.getter
    def city(self) -> Optional[_builtins.str]:
        """
        The city in which a customer lives.
        """
        return pulumi.get(self, "city")

    @_builtins.property
    @pulumi.getter
    def country(self) -> Optional[_builtins.str]:
        """
        The country in which a customer lives.
        """
        return pulumi.get(self, "country")

    @_builtins.property
    @pulumi.getter
    def county(self) -> Optional[_builtins.str]:
        """
        The county in which a customer lives.
        """
        return pulumi.get(self, "county")

    @_builtins.property
    @pulumi.getter
    def custom(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        The custom attributes in customer profile attributes.
        """
        return pulumi.get(self, "custom")

    @_builtins.property
    @pulumi.getter(name="emailAddress")
    def email_address(self) -> Optional[_builtins.str]:
        """
        The customer's email address, which has not been specified as a personal or business address.
        """
        return pulumi.get(self, "email_address")

    @_builtins.property
    @pulumi.getter(name="firstName")
    def first_name(self) -> Optional[_builtins.str]:
        """
        The customer's first name.
        """
        return pulumi.get(self, "first_name")

    @_builtins.property
    @pulumi.getter
    def gender(self) -> Optional[_builtins.str]:
        """
        The customer's gender.
        """
        return pulumi.get(self, "gender")

    @_builtins.property
    @pulumi.getter(name="homePhoneNumber")
    def home_phone_number(self) -> Optional[_builtins.str]:
        """
        The customer's home phone number.
        """
        return pulumi.get(self, "home_phone_number")

    @_builtins.property
    @pulumi.getter(name="lastName")
    def last_name(self) -> Optional[_builtins.str]:
        """
        The customer's last name.
        """
        return pulumi.get(self, "last_name")

    @_builtins.property
    @pulumi.getter(name="mailingAddress1")
    def mailing_address1(self) -> Optional[_builtins.str]:
        """
        The first line of a customer’s mailing address.
        """
        return pulumi.get(self, "mailing_address1")

    @_builtins.property
    @pulumi.getter(name="mailingAddress2")
    def mailing_address2(self) -> Optional[_builtins.str]:
        """
        The second line of a customer’s mailing address.
        """
        return pulumi.get(self, "mailing_address2")

    @_builtins.property
    @pulumi.getter(name="mailingAddress3")
    def mailing_address3(self) -> Optional[_builtins.str]:
        """
        The third line of a customer’s mailing address.
        """
        return pulumi.get(self, "mailing_address3")

    @_builtins.property
    @pulumi.getter(name="mailingAddress4")
    def mailing_address4(self) -> Optional[_builtins.str]:
        """
        The fourth line of a customer’s mailing address.
        """
        return pulumi.get(self, "mailing_address4")

    @_builtins.property
    @pulumi.getter(name="mailingCity")
    def mailing_city(self) -> Optional[_builtins.str]:
        """
        The city of a customer’s mailing address.
        """
        return pulumi.get(self, "mailing_city")

    @_builtins.property
    @pulumi.getter(name="mailingCountry")
    def mailing_country(self) -> Optional[_builtins.str]:
        """
        The country of a customer’s mailing address.
        """
        return pulumi.get(self, "mailing_country")

    @_builtins.property
    @pulumi.getter(name="mailingCounty")
    def mailing_county(self) -> Optional[_builtins.str]:
        """
        The county of a customer’s mailing address.
        """
        return pulumi.get(self, "mailing_county")

    @_builtins.property
    @pulumi.getter(name="mailingPostalCode")
    def mailing_postal_code(self) -> Optional[_builtins.str]:
        """
        The postal code of a customer’s mailing address
        """
        return pulumi.get(self, "mailing_postal_code")

    @_builtins.property
    @pulumi.getter(name="mailingProvince")
    def mailing_province(self) -> Optional[_builtins.str]:
        """
        The province of a customer’s mailing address.
        """
        return pulumi.get(self, "mailing_province")

    @_builtins.property
    @pulumi.getter(name="mailingState")
    def mailing_state(self) -> Optional[_builtins.str]:
        """
        The state of a customer’s mailing address.
        """
        return pulumi.get(self, "mailing_state")

    @_builtins.property
    @pulumi.getter(name="middleName")
    def middle_name(self) -> Optional[_builtins.str]:
        """
        The customer's middle name.
        """
        return pulumi.get(self, "middle_name")

    @_builtins.property
    @pulumi.getter(name="mobilePhoneNumber")
    def mobile_phone_number(self) -> Optional[_builtins.str]:
        """
        The customer's mobile phone number.
        """
        return pulumi.get(self, "mobile_phone_number")

    @_builtins.property
    @pulumi.getter(name="partyType")
    def party_type(self) -> Optional[_builtins.str]:
        """
        The customer's party type.
        """
        return pulumi.get(self, "party_type")

    @_builtins.property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> Optional[_builtins.str]:
        """
        The customer's phone number, which has not been specified as a mobile, home, or business number.
        """
        return pulumi.get(self, "phone_number")

    @_builtins.property
    @pulumi.getter(name="postalCode")
    def postal_code(self) -> Optional[_builtins.str]:
        """
        The postal code of a customer address.
        """
        return pulumi.get(self, "postal_code")

    @_builtins.property
    @pulumi.getter(name="profileArn")
    def profile_arn(self) -> Optional[_builtins.str]:
        """
        The ARN of a customer profile.
        """
        return pulumi.get(self, "profile_arn")

    @_builtins.property
    @pulumi.getter(name="profileId")
    def profile_id(self) -> Optional[_builtins.str]:
        """
        The unique identifier of a customer profile.
        """
        return pulumi.get(self, "profile_id")

    @_builtins.property
    @pulumi.getter
    def province(self) -> Optional[_builtins.str]:
        """
        The province in which a customer lives.
        """
        return pulumi.get(self, "province")

    @_builtins.property
    @pulumi.getter(name="shippingAddress1")
    def shipping_address1(self) -> Optional[_builtins.str]:
        """
        The first line of a customer’s shipping address.
        """
        return pulumi.get(self, "shipping_address1")

    @_builtins.property
    @pulumi.getter(name="shippingAddress2")
    def shipping_address2(self) -> Optional[_builtins.str]:
        """
        The second line of a customer’s shipping address.
        """
        return pulumi.get(self, "shipping_address2")

    @_builtins.property
    @pulumi.getter(name="shippingAddress3")
    def shipping_address3(self) -> Optional[_builtins.str]:
        """
        The third line of a customer’s shipping address.
        """
        return pulumi.get(self, "shipping_address3")

    @_builtins.property
    @pulumi.getter(name="shippingAddress4")
    def shipping_address4(self) -> Optional[_builtins.str]:
        """
        The fourth line of a customer’s shipping address
        """
        return pulumi.get(self, "shipping_address4")

    @_builtins.property
    @pulumi.getter(name="shippingCity")
    def shipping_city(self) -> Optional[_builtins.str]:
        """
        The city of a customer’s shipping address.
        """
        return pulumi.get(self, "shipping_city")

    @_builtins.property
    @pulumi.getter(name="shippingCountry")
    def shipping_country(self) -> Optional[_builtins.str]:
        """
        The country of a customer’s shipping address.
        """
        return pulumi.get(self, "shipping_country")

    @_builtins.property
    @pulumi.getter(name="shippingCounty")
    def shipping_county(self) -> Optional[_builtins.str]:
        """
        The county of a customer’s shipping address.
        """
        return pulumi.get(self, "shipping_county")

    @_builtins.property
    @pulumi.getter(name="shippingPostalCode")
    def shipping_postal_code(self) -> Optional[_builtins.str]:
        """
        The postal code of a customer’s shipping address.
        """
        return pulumi.get(self, "shipping_postal_code")

    @_builtins.property
    @pulumi.getter(name="shippingProvince")
    def shipping_province(self) -> Optional[_builtins.str]:
        """
        The province of a customer’s shipping address.
        """
        return pulumi.get(self, "shipping_province")

    @_builtins.property
    @pulumi.getter(name="shippingState")
    def shipping_state(self) -> Optional[_builtins.str]:
        """
        The state of a customer’s shipping address.
        """
        return pulumi.get(self, "shipping_state")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        The state in which a customer lives.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class MessageTemplateEmailMessageTemplateContent(dict):
    """
    The content of message template that applies to email channel subtype.
    """
    def __init__(__self__, *,
                 body: 'outputs.MessageTemplateEmailMessageTemplateContentBody',
                 headers: Sequence['outputs.MessageTemplateEmailMessageTemplateHeader'],
                 subject: _builtins.str):
        """
        The content of message template that applies to email channel subtype.
        :param 'MessageTemplateEmailMessageTemplateContentBody' body: The body to use in email messages.
        :param Sequence['MessageTemplateEmailMessageTemplateHeader'] headers: The email headers to include in email messages.
        :param _builtins.str subject: The subject line, or title, to use in email messages.
        """
        pulumi.set(__self__, "body", body)
        pulumi.set(__self__, "headers", headers)
        pulumi.set(__self__, "subject", subject)

    @_builtins.property
    @pulumi.getter
    def body(self) -> 'outputs.MessageTemplateEmailMessageTemplateContentBody':
        """
        The body to use in email messages.
        """
        return pulumi.get(self, "body")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Sequence['outputs.MessageTemplateEmailMessageTemplateHeader']:
        """
        The email headers to include in email messages.
        """
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter
    def subject(self) -> _builtins.str:
        """
        The subject line, or title, to use in email messages.
        """
        return pulumi.get(self, "subject")


@pulumi.output_type
class MessageTemplateEmailMessageTemplateContentBody(dict):
    """
    The body to use in email messages.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "plainText":
            suggest = "plain_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MessageTemplateEmailMessageTemplateContentBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MessageTemplateEmailMessageTemplateContentBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MessageTemplateEmailMessageTemplateContentBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 html: Optional['outputs.MessageTemplateBodyContentProvider'] = None,
                 plain_text: Optional['outputs.MessageTemplateBodyContentProvider'] = None):
        """
        The body to use in email messages.
        :param 'MessageTemplateBodyContentProvider' html: The message body, in HTML format, to use in email messages that are based on the message template. We recommend using HTML format for email clients that render HTML content. You can include links, formatted text, and more in an HTML message.
        :param 'MessageTemplateBodyContentProvider' plain_text: The message body, in plain text format, to use in email messages that are based on the message template. We recommend using plain text format for email clients that don't render HTML content and clients that are connected to high-latency networks, such as mobile devices.
        """
        if html is not None:
            pulumi.set(__self__, "html", html)
        if plain_text is not None:
            pulumi.set(__self__, "plain_text", plain_text)

    @_builtins.property
    @pulumi.getter
    def html(self) -> Optional['outputs.MessageTemplateBodyContentProvider']:
        """
        The message body, in HTML format, to use in email messages that are based on the message template. We recommend using HTML format for email clients that render HTML content. You can include links, formatted text, and more in an HTML message.
        """
        return pulumi.get(self, "html")

    @_builtins.property
    @pulumi.getter(name="plainText")
    def plain_text(self) -> Optional['outputs.MessageTemplateBodyContentProvider']:
        """
        The message body, in plain text format, to use in email messages that are based on the message template. We recommend using plain text format for email clients that don't render HTML content and clients that are connected to high-latency networks, such as mobile devices.
        """
        return pulumi.get(self, "plain_text")


@pulumi.output_type
class MessageTemplateEmailMessageTemplateHeader(dict):
    """
    The email header to include in email messages.
    """
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        The email header to include in email messages.
        :param _builtins.str name: The name of the email header.
        :param _builtins.str value: The value of the email header.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the email header.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The value of the email header.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class MessageTemplateGroupingConfiguration(dict):
    """
    The configuration information of the user groups that the message template is accessible to.
    """
    def __init__(__self__, *,
                 criteria: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        The configuration information of the user groups that the message template is accessible to.
        :param _builtins.str criteria: The criteria used for grouping Amazon Q in Connect users.
        :param Sequence[_builtins.str] values: The list of values that define different groups of Amazon Q in Connect users.
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def criteria(self) -> _builtins.str:
        """
        The criteria used for grouping Amazon Q in Connect users.
        """
        return pulumi.get(self, "criteria")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        The list of values that define different groups of Amazon Q in Connect users.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class MessageTemplateSmsMessageTemplateContent(dict):
    """
    The content of message template that applies to SMS channel subtype.
    """
    def __init__(__self__, *,
                 body: 'outputs.MessageTemplateSmsMessageTemplateContentBody'):
        """
        The content of message template that applies to SMS channel subtype.
        :param 'MessageTemplateSmsMessageTemplateContentBody' body: The body to use in SMS messages.
        """
        pulumi.set(__self__, "body", body)

    @_builtins.property
    @pulumi.getter
    def body(self) -> 'outputs.MessageTemplateSmsMessageTemplateContentBody':
        """
        The body to use in SMS messages.
        """
        return pulumi.get(self, "body")


@pulumi.output_type
class MessageTemplateSmsMessageTemplateContentBody(dict):
    """
    The body to use in SMS messages.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "plainText":
            suggest = "plain_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MessageTemplateSmsMessageTemplateContentBody. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MessageTemplateSmsMessageTemplateContentBody.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MessageTemplateSmsMessageTemplateContentBody.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 plain_text: Optional['outputs.MessageTemplateBodyContentProvider'] = None):
        """
        The body to use in SMS messages.
        :param 'MessageTemplateBodyContentProvider' plain_text: The message body to use in SMS messages.
        """
        if plain_text is not None:
            pulumi.set(__self__, "plain_text", plain_text)

    @_builtins.property
    @pulumi.getter(name="plainText")
    def plain_text(self) -> Optional['outputs.MessageTemplateBodyContentProvider']:
        """
        The message body to use in SMS messages.
        """
        return pulumi.get(self, "plain_text")


@pulumi.output_type
class MessageTemplateSystemAttributes(dict):
    """
    The system attributes that are used with the message template.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customerEndpoint":
            suggest = "customer_endpoint"
        elif key == "systemEndpoint":
            suggest = "system_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MessageTemplateSystemAttributes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MessageTemplateSystemAttributes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MessageTemplateSystemAttributes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 customer_endpoint: Optional['outputs.MessageTemplateSystemEndpointAttributes'] = None,
                 name: Optional[_builtins.str] = None,
                 system_endpoint: Optional['outputs.MessageTemplateSystemEndpointAttributes'] = None):
        """
        The system attributes that are used with the message template.
        :param 'MessageTemplateSystemEndpointAttributes' customer_endpoint: The CustomerEndpoint attribute.
        :param _builtins.str name: The name of the task.
        :param 'MessageTemplateSystemEndpointAttributes' system_endpoint: The SystemEndpoint attribute.
        """
        if customer_endpoint is not None:
            pulumi.set(__self__, "customer_endpoint", customer_endpoint)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if system_endpoint is not None:
            pulumi.set(__self__, "system_endpoint", system_endpoint)

    @_builtins.property
    @pulumi.getter(name="customerEndpoint")
    def customer_endpoint(self) -> Optional['outputs.MessageTemplateSystemEndpointAttributes']:
        """
        The CustomerEndpoint attribute.
        """
        return pulumi.get(self, "customer_endpoint")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the task.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="systemEndpoint")
    def system_endpoint(self) -> Optional['outputs.MessageTemplateSystemEndpointAttributes']:
        """
        The SystemEndpoint attribute.
        """
        return pulumi.get(self, "system_endpoint")


@pulumi.output_type
class MessageTemplateSystemEndpointAttributes(dict):
    """
    The system endpoint attributes that are used with the message template.
    """
    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None):
        """
        The system endpoint attributes that are used with the message template.
        :param _builtins.str address: The customer's phone number if used with customerEndpoint, or the number the customer dialed to call your contact center if used with systemEndpoint.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        The customer's phone number if used with customerEndpoint, or the number the customer dialed to call your contact center if used with systemEndpoint.
        """
        return pulumi.get(self, "address")


@pulumi.output_type
class QuickResponseContentProvider(dict):
    """
    The container of quick response content.
    """
    def __init__(__self__, *,
                 content: Optional[_builtins.str] = None):
        """
        The container of quick response content.
        :param _builtins.str content: The content of the quick response.
        """
        if content is not None:
            pulumi.set(__self__, "content", content)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[_builtins.str]:
        """
        The content of the quick response.
        """
        return pulumi.get(self, "content")


@pulumi.output_type
class QuickResponseContents(dict):
    """
    The content of the quick response stored in different media types.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "plainText":
            suggest = "plain_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QuickResponseContents. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QuickResponseContents.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QuickResponseContents.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 markdown: Optional['outputs.QuickResponseContentProvider'] = None,
                 plain_text: Optional['outputs.QuickResponseContentProvider'] = None):
        """
        The content of the quick response stored in different media types.
        :param 'QuickResponseContentProvider' markdown: The quick response content in markdown format.
        :param 'QuickResponseContentProvider' plain_text: The quick response content in plaintext format.
        """
        if markdown is not None:
            pulumi.set(__self__, "markdown", markdown)
        if plain_text is not None:
            pulumi.set(__self__, "plain_text", plain_text)

    @_builtins.property
    @pulumi.getter
    def markdown(self) -> Optional['outputs.QuickResponseContentProvider']:
        """
        The quick response content in markdown format.
        """
        return pulumi.get(self, "markdown")

    @_builtins.property
    @pulumi.getter(name="plainText")
    def plain_text(self) -> Optional['outputs.QuickResponseContentProvider']:
        """
        The quick response content in plaintext format.
        """
        return pulumi.get(self, "plain_text")


@pulumi.output_type
class QuickResponseGroupingConfiguration(dict):
    """
    The configuration information of the user groups that the quick response is accessible to.
    """
    def __init__(__self__, *,
                 criteria: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        The configuration information of the user groups that the quick response is accessible to.
        :param _builtins.str criteria: The criteria used for grouping Amazon Q in Connect users.
        :param Sequence[_builtins.str] values: The list of values that define different groups of Amazon Q in Connect users.
        """
        pulumi.set(__self__, "criteria", criteria)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def criteria(self) -> _builtins.str:
        """
        The criteria used for grouping Amazon Q in Connect users.
        """
        return pulumi.get(self, "criteria")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        The list of values that define different groups of Amazon Q in Connect users.
        """
        return pulumi.get(self, "values")


