# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from ._enums import *

__all__ = [
    'DatabaseTagArgs',
    'MagneticStoreWritePropertiesPropertiesMagneticStoreRejectedDataLocationPropertiesS3ConfigurationPropertiesArgs',
    'MagneticStoreWritePropertiesPropertiesMagneticStoreRejectedDataLocationPropertiesArgs',
    'MagneticStoreWritePropertiesPropertiesArgs',
    'RetentionPropertiesPropertiesArgs',
    'ScheduledQueryDimensionMappingArgs',
    'ScheduledQueryErrorReportConfigurationArgs',
    'ScheduledQueryMixedMeasureMappingArgs',
    'ScheduledQueryMultiMeasureAttributeMappingArgs',
    'ScheduledQueryMultiMeasureMappingsArgs',
    'ScheduledQueryNotificationConfigurationArgs',
    'ScheduledQueryS3ConfigurationArgs',
    'ScheduledQueryScheduleConfigurationArgs',
    'ScheduledQuerySnsConfigurationArgs',
    'ScheduledQueryTagArgs',
    'ScheduledQueryTargetConfigurationArgs',
    'ScheduledQueryTimestreamConfigurationArgs',
    'SchemaPropertiesArgs',
    'TablePartitionKeyArgs',
    'TableTagArgs',
]

@pulumi.input_type
class DatabaseTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        You can use the Resource Tags property to apply tags to resources, which can help you identify and categorize those resources.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class MagneticStoreWritePropertiesPropertiesMagneticStoreRejectedDataLocationPropertiesS3ConfigurationPropertiesArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[str],
                 encryption_option: pulumi.Input[str],
                 kms_key_id: Optional[pulumi.Input[str]] = None,
                 object_key_prefix: Optional[pulumi.Input[str]] = None):
        """
        S3 configuration for location to store rejections from magnetic store writes
        :param pulumi.Input[str] bucket_name: The bucket name used to store the data.
        :param pulumi.Input[str] encryption_option: Either SSE_KMS or SSE_S3.
        :param pulumi.Input[str] kms_key_id: Must be provided if SSE_KMS is specified as the encryption option
        :param pulumi.Input[str] object_key_prefix: String used to prefix all data in the bucket.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "encryption_option", encryption_option)
        if kms_key_id is not None:
            pulumi.set(__self__, "kms_key_id", kms_key_id)
        if object_key_prefix is not None:
            pulumi.set(__self__, "object_key_prefix", object_key_prefix)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[str]:
        """
        The bucket name used to store the data.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="encryptionOption")
    def encryption_option(self) -> pulumi.Input[str]:
        """
        Either SSE_KMS or SSE_S3.
        """
        return pulumi.get(self, "encryption_option")

    @encryption_option.setter
    def encryption_option(self, value: pulumi.Input[str]):
        pulumi.set(self, "encryption_option", value)

    @property
    @pulumi.getter(name="kmsKeyId")
    def kms_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        Must be provided if SSE_KMS is specified as the encryption option
        """
        return pulumi.get(self, "kms_key_id")

    @kms_key_id.setter
    def kms_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_id", value)

    @property
    @pulumi.getter(name="objectKeyPrefix")
    def object_key_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        String used to prefix all data in the bucket.
        """
        return pulumi.get(self, "object_key_prefix")

    @object_key_prefix.setter
    def object_key_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object_key_prefix", value)


@pulumi.input_type
class MagneticStoreWritePropertiesPropertiesMagneticStoreRejectedDataLocationPropertiesArgs:
    def __init__(__self__, *,
                 s3_configuration: Optional[pulumi.Input['MagneticStoreWritePropertiesPropertiesMagneticStoreRejectedDataLocationPropertiesS3ConfigurationPropertiesArgs']] = None):
        """
        Location to store information about records that were asynchronously rejected during magnetic store writes.
        :param pulumi.Input['MagneticStoreWritePropertiesPropertiesMagneticStoreRejectedDataLocationPropertiesS3ConfigurationPropertiesArgs'] s3_configuration: S3 configuration for location to store rejections from magnetic store writes
        """
        if s3_configuration is not None:
            pulumi.set(__self__, "s3_configuration", s3_configuration)

    @property
    @pulumi.getter(name="s3Configuration")
    def s3_configuration(self) -> Optional[pulumi.Input['MagneticStoreWritePropertiesPropertiesMagneticStoreRejectedDataLocationPropertiesS3ConfigurationPropertiesArgs']]:
        """
        S3 configuration for location to store rejections from magnetic store writes
        """
        return pulumi.get(self, "s3_configuration")

    @s3_configuration.setter
    def s3_configuration(self, value: Optional[pulumi.Input['MagneticStoreWritePropertiesPropertiesMagneticStoreRejectedDataLocationPropertiesS3ConfigurationPropertiesArgs']]):
        pulumi.set(self, "s3_configuration", value)


@pulumi.input_type
class MagneticStoreWritePropertiesPropertiesArgs:
    def __init__(__self__, *,
                 enable_magnetic_store_writes: pulumi.Input[bool],
                 magnetic_store_rejected_data_location: Optional[pulumi.Input['MagneticStoreWritePropertiesPropertiesMagneticStoreRejectedDataLocationPropertiesArgs']] = None):
        """
        The properties that determine whether magnetic store writes are enabled.
        :param pulumi.Input[bool] enable_magnetic_store_writes: Boolean flag indicating whether magnetic store writes are enabled.
        :param pulumi.Input['MagneticStoreWritePropertiesPropertiesMagneticStoreRejectedDataLocationPropertiesArgs'] magnetic_store_rejected_data_location: Location to store information about records that were asynchronously rejected during magnetic store writes.
        """
        pulumi.set(__self__, "enable_magnetic_store_writes", enable_magnetic_store_writes)
        if magnetic_store_rejected_data_location is not None:
            pulumi.set(__self__, "magnetic_store_rejected_data_location", magnetic_store_rejected_data_location)

    @property
    @pulumi.getter(name="enableMagneticStoreWrites")
    def enable_magnetic_store_writes(self) -> pulumi.Input[bool]:
        """
        Boolean flag indicating whether magnetic store writes are enabled.
        """
        return pulumi.get(self, "enable_magnetic_store_writes")

    @enable_magnetic_store_writes.setter
    def enable_magnetic_store_writes(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enable_magnetic_store_writes", value)

    @property
    @pulumi.getter(name="magneticStoreRejectedDataLocation")
    def magnetic_store_rejected_data_location(self) -> Optional[pulumi.Input['MagneticStoreWritePropertiesPropertiesMagneticStoreRejectedDataLocationPropertiesArgs']]:
        """
        Location to store information about records that were asynchronously rejected during magnetic store writes.
        """
        return pulumi.get(self, "magnetic_store_rejected_data_location")

    @magnetic_store_rejected_data_location.setter
    def magnetic_store_rejected_data_location(self, value: Optional[pulumi.Input['MagneticStoreWritePropertiesPropertiesMagneticStoreRejectedDataLocationPropertiesArgs']]):
        pulumi.set(self, "magnetic_store_rejected_data_location", value)


@pulumi.input_type
class RetentionPropertiesPropertiesArgs:
    def __init__(__self__, *,
                 magnetic_store_retention_period_in_days: Optional[pulumi.Input[str]] = None,
                 memory_store_retention_period_in_hours: Optional[pulumi.Input[str]] = None):
        """
        The retention duration of the memory store and the magnetic store.
        :param pulumi.Input[str] magnetic_store_retention_period_in_days: The duration for which data must be stored in the magnetic store.
        :param pulumi.Input[str] memory_store_retention_period_in_hours: The duration for which data must be stored in the memory store.
        """
        if magnetic_store_retention_period_in_days is not None:
            pulumi.set(__self__, "magnetic_store_retention_period_in_days", magnetic_store_retention_period_in_days)
        if memory_store_retention_period_in_hours is not None:
            pulumi.set(__self__, "memory_store_retention_period_in_hours", memory_store_retention_period_in_hours)

    @property
    @pulumi.getter(name="magneticStoreRetentionPeriodInDays")
    def magnetic_store_retention_period_in_days(self) -> Optional[pulumi.Input[str]]:
        """
        The duration for which data must be stored in the magnetic store.
        """
        return pulumi.get(self, "magnetic_store_retention_period_in_days")

    @magnetic_store_retention_period_in_days.setter
    def magnetic_store_retention_period_in_days(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "magnetic_store_retention_period_in_days", value)

    @property
    @pulumi.getter(name="memoryStoreRetentionPeriodInHours")
    def memory_store_retention_period_in_hours(self) -> Optional[pulumi.Input[str]]:
        """
        The duration for which data must be stored in the memory store.
        """
        return pulumi.get(self, "memory_store_retention_period_in_hours")

    @memory_store_retention_period_in_hours.setter
    def memory_store_retention_period_in_hours(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "memory_store_retention_period_in_hours", value)


@pulumi.input_type
class ScheduledQueryDimensionMappingArgs:
    def __init__(__self__, *,
                 dimension_value_type: pulumi.Input['ScheduledQueryDimensionValueType'],
                 name: pulumi.Input[str]):
        """
        This type is used to map column(s) from the query result to a dimension in the destination table.
        """
        pulumi.set(__self__, "dimension_value_type", dimension_value_type)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="dimensionValueType")
    def dimension_value_type(self) -> pulumi.Input['ScheduledQueryDimensionValueType']:
        return pulumi.get(self, "dimension_value_type")

    @dimension_value_type.setter
    def dimension_value_type(self, value: pulumi.Input['ScheduledQueryDimensionValueType']):
        pulumi.set(self, "dimension_value_type", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class ScheduledQueryErrorReportConfigurationArgs:
    def __init__(__self__, *,
                 s3_configuration: pulumi.Input['ScheduledQueryS3ConfigurationArgs']):
        """
        Configuration for error reporting. Error reports will be generated when a problem is encountered when writing the query results.
        """
        pulumi.set(__self__, "s3_configuration", s3_configuration)

    @property
    @pulumi.getter(name="s3Configuration")
    def s3_configuration(self) -> pulumi.Input['ScheduledQueryS3ConfigurationArgs']:
        return pulumi.get(self, "s3_configuration")

    @s3_configuration.setter
    def s3_configuration(self, value: pulumi.Input['ScheduledQueryS3ConfigurationArgs']):
        pulumi.set(self, "s3_configuration", value)


@pulumi.input_type
class ScheduledQueryMixedMeasureMappingArgs:
    def __init__(__self__, *,
                 measure_value_type: pulumi.Input['ScheduledQueryMixedMeasureMappingMeasureValueType'],
                 measure_name: Optional[pulumi.Input[str]] = None,
                 multi_measure_attribute_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryMultiMeasureAttributeMappingArgs']]]] = None,
                 source_column: Optional[pulumi.Input[str]] = None,
                 target_measure_name: Optional[pulumi.Input[str]] = None):
        """
        MixedMeasureMappings are mappings that can be used to ingest data into a mixture of narrow and multi measures in the derived table.
        """
        pulumi.set(__self__, "measure_value_type", measure_value_type)
        if measure_name is not None:
            pulumi.set(__self__, "measure_name", measure_name)
        if multi_measure_attribute_mappings is not None:
            pulumi.set(__self__, "multi_measure_attribute_mappings", multi_measure_attribute_mappings)
        if source_column is not None:
            pulumi.set(__self__, "source_column", source_column)
        if target_measure_name is not None:
            pulumi.set(__self__, "target_measure_name", target_measure_name)

    @property
    @pulumi.getter(name="measureValueType")
    def measure_value_type(self) -> pulumi.Input['ScheduledQueryMixedMeasureMappingMeasureValueType']:
        return pulumi.get(self, "measure_value_type")

    @measure_value_type.setter
    def measure_value_type(self, value: pulumi.Input['ScheduledQueryMixedMeasureMappingMeasureValueType']):
        pulumi.set(self, "measure_value_type", value)

    @property
    @pulumi.getter(name="measureName")
    def measure_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "measure_name")

    @measure_name.setter
    def measure_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "measure_name", value)

    @property
    @pulumi.getter(name="multiMeasureAttributeMappings")
    def multi_measure_attribute_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryMultiMeasureAttributeMappingArgs']]]]:
        return pulumi.get(self, "multi_measure_attribute_mappings")

    @multi_measure_attribute_mappings.setter
    def multi_measure_attribute_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryMultiMeasureAttributeMappingArgs']]]]):
        pulumi.set(self, "multi_measure_attribute_mappings", value)

    @property
    @pulumi.getter(name="sourceColumn")
    def source_column(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "source_column")

    @source_column.setter
    def source_column(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_column", value)

    @property
    @pulumi.getter(name="targetMeasureName")
    def target_measure_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "target_measure_name")

    @target_measure_name.setter
    def target_measure_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_measure_name", value)


@pulumi.input_type
class ScheduledQueryMultiMeasureAttributeMappingArgs:
    def __init__(__self__, *,
                 measure_value_type: pulumi.Input['ScheduledQueryMultiMeasureAttributeMappingMeasureValueType'],
                 source_column: pulumi.Input[str],
                 target_multi_measure_attribute_name: Optional[pulumi.Input[str]] = None):
        """
        An attribute mapping to be used for mapping query results to ingest data for multi-measure attributes.
        """
        pulumi.set(__self__, "measure_value_type", measure_value_type)
        pulumi.set(__self__, "source_column", source_column)
        if target_multi_measure_attribute_name is not None:
            pulumi.set(__self__, "target_multi_measure_attribute_name", target_multi_measure_attribute_name)

    @property
    @pulumi.getter(name="measureValueType")
    def measure_value_type(self) -> pulumi.Input['ScheduledQueryMultiMeasureAttributeMappingMeasureValueType']:
        return pulumi.get(self, "measure_value_type")

    @measure_value_type.setter
    def measure_value_type(self, value: pulumi.Input['ScheduledQueryMultiMeasureAttributeMappingMeasureValueType']):
        pulumi.set(self, "measure_value_type", value)

    @property
    @pulumi.getter(name="sourceColumn")
    def source_column(self) -> pulumi.Input[str]:
        return pulumi.get(self, "source_column")

    @source_column.setter
    def source_column(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_column", value)

    @property
    @pulumi.getter(name="targetMultiMeasureAttributeName")
    def target_multi_measure_attribute_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "target_multi_measure_attribute_name")

    @target_multi_measure_attribute_name.setter
    def target_multi_measure_attribute_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_multi_measure_attribute_name", value)


@pulumi.input_type
class ScheduledQueryMultiMeasureMappingsArgs:
    def __init__(__self__, *,
                 multi_measure_attribute_mappings: pulumi.Input[Sequence[pulumi.Input['ScheduledQueryMultiMeasureAttributeMappingArgs']]],
                 target_multi_measure_name: Optional[pulumi.Input[str]] = None):
        """
        Only one of MixedMeasureMappings or MultiMeasureMappings is to be provided. MultiMeasureMappings can be used to ingest data as multi measures in the derived table.
        """
        pulumi.set(__self__, "multi_measure_attribute_mappings", multi_measure_attribute_mappings)
        if target_multi_measure_name is not None:
            pulumi.set(__self__, "target_multi_measure_name", target_multi_measure_name)

    @property
    @pulumi.getter(name="multiMeasureAttributeMappings")
    def multi_measure_attribute_mappings(self) -> pulumi.Input[Sequence[pulumi.Input['ScheduledQueryMultiMeasureAttributeMappingArgs']]]:
        return pulumi.get(self, "multi_measure_attribute_mappings")

    @multi_measure_attribute_mappings.setter
    def multi_measure_attribute_mappings(self, value: pulumi.Input[Sequence[pulumi.Input['ScheduledQueryMultiMeasureAttributeMappingArgs']]]):
        pulumi.set(self, "multi_measure_attribute_mappings", value)

    @property
    @pulumi.getter(name="targetMultiMeasureName")
    def target_multi_measure_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "target_multi_measure_name")

    @target_multi_measure_name.setter
    def target_multi_measure_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_multi_measure_name", value)


@pulumi.input_type
class ScheduledQueryNotificationConfigurationArgs:
    def __init__(__self__, *,
                 sns_configuration: pulumi.Input['ScheduledQuerySnsConfigurationArgs']):
        """
        Notification configuration for the scheduled query. A notification is sent by Timestream when a query run finishes, when the state is updated or when you delete it.
        """
        pulumi.set(__self__, "sns_configuration", sns_configuration)

    @property
    @pulumi.getter(name="snsConfiguration")
    def sns_configuration(self) -> pulumi.Input['ScheduledQuerySnsConfigurationArgs']:
        return pulumi.get(self, "sns_configuration")

    @sns_configuration.setter
    def sns_configuration(self, value: pulumi.Input['ScheduledQuerySnsConfigurationArgs']):
        pulumi.set(self, "sns_configuration", value)


@pulumi.input_type
class ScheduledQueryS3ConfigurationArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[str],
                 encryption_option: Optional[pulumi.Input['ScheduledQueryEncryptionOption']] = None,
                 object_key_prefix: Optional[pulumi.Input[str]] = None):
        """
        Details on S3 location for error reports that result from running a query.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        if encryption_option is not None:
            pulumi.set(__self__, "encryption_option", encryption_option)
        if object_key_prefix is not None:
            pulumi.set(__self__, "object_key_prefix", object_key_prefix)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="encryptionOption")
    def encryption_option(self) -> Optional[pulumi.Input['ScheduledQueryEncryptionOption']]:
        return pulumi.get(self, "encryption_option")

    @encryption_option.setter
    def encryption_option(self, value: Optional[pulumi.Input['ScheduledQueryEncryptionOption']]):
        pulumi.set(self, "encryption_option", value)

    @property
    @pulumi.getter(name="objectKeyPrefix")
    def object_key_prefix(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "object_key_prefix")

    @object_key_prefix.setter
    def object_key_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object_key_prefix", value)


@pulumi.input_type
class ScheduledQueryScheduleConfigurationArgs:
    def __init__(__self__, *,
                 schedule_expression: pulumi.Input[str]):
        """
        Configuration for when the scheduled query is executed.
        """
        pulumi.set(__self__, "schedule_expression", schedule_expression)

    @property
    @pulumi.getter(name="scheduleExpression")
    def schedule_expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "schedule_expression")

    @schedule_expression.setter
    def schedule_expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "schedule_expression", value)


@pulumi.input_type
class ScheduledQuerySnsConfigurationArgs:
    def __init__(__self__, *,
                 topic_arn: pulumi.Input[str]):
        """
        SNS configuration for notification upon scheduled query execution.
        """
        pulumi.set(__self__, "topic_arn", topic_arn)

    @property
    @pulumi.getter(name="topicArn")
    def topic_arn(self) -> pulumi.Input[str]:
        return pulumi.get(self, "topic_arn")

    @topic_arn.setter
    def topic_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "topic_arn", value)


@pulumi.input_type
class ScheduledQueryTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        A key-value pair to label the scheduled query.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ScheduledQueryTargetConfigurationArgs:
    def __init__(__self__, *,
                 timestream_configuration: pulumi.Input['ScheduledQueryTimestreamConfigurationArgs']):
        """
        Configuration of target store where scheduled query results are written to.
        """
        pulumi.set(__self__, "timestream_configuration", timestream_configuration)

    @property
    @pulumi.getter(name="timestreamConfiguration")
    def timestream_configuration(self) -> pulumi.Input['ScheduledQueryTimestreamConfigurationArgs']:
        return pulumi.get(self, "timestream_configuration")

    @timestream_configuration.setter
    def timestream_configuration(self, value: pulumi.Input['ScheduledQueryTimestreamConfigurationArgs']):
        pulumi.set(self, "timestream_configuration", value)


@pulumi.input_type
class ScheduledQueryTimestreamConfigurationArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[str],
                 dimension_mappings: pulumi.Input[Sequence[pulumi.Input['ScheduledQueryDimensionMappingArgs']]],
                 table_name: pulumi.Input[str],
                 time_column: pulumi.Input[str],
                 measure_name_column: Optional[pulumi.Input[str]] = None,
                 mixed_measure_mappings: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryMixedMeasureMappingArgs']]]] = None,
                 multi_measure_mappings: Optional[pulumi.Input['ScheduledQueryMultiMeasureMappingsArgs']] = None):
        """
        Configuration needed to write data into the Timestream database and table.
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "dimension_mappings", dimension_mappings)
        pulumi.set(__self__, "table_name", table_name)
        pulumi.set(__self__, "time_column", time_column)
        if measure_name_column is not None:
            pulumi.set(__self__, "measure_name_column", measure_name_column)
        if mixed_measure_mappings is not None:
            pulumi.set(__self__, "mixed_measure_mappings", mixed_measure_mappings)
        if multi_measure_mappings is not None:
            pulumi.set(__self__, "multi_measure_mappings", multi_measure_mappings)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter(name="dimensionMappings")
    def dimension_mappings(self) -> pulumi.Input[Sequence[pulumi.Input['ScheduledQueryDimensionMappingArgs']]]:
        return pulumi.get(self, "dimension_mappings")

    @dimension_mappings.setter
    def dimension_mappings(self, value: pulumi.Input[Sequence[pulumi.Input['ScheduledQueryDimensionMappingArgs']]]):
        pulumi.set(self, "dimension_mappings", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "table_name", value)

    @property
    @pulumi.getter(name="timeColumn")
    def time_column(self) -> pulumi.Input[str]:
        return pulumi.get(self, "time_column")

    @time_column.setter
    def time_column(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_column", value)

    @property
    @pulumi.getter(name="measureNameColumn")
    def measure_name_column(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "measure_name_column")

    @measure_name_column.setter
    def measure_name_column(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "measure_name_column", value)

    @property
    @pulumi.getter(name="mixedMeasureMappings")
    def mixed_measure_mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryMixedMeasureMappingArgs']]]]:
        return pulumi.get(self, "mixed_measure_mappings")

    @mixed_measure_mappings.setter
    def mixed_measure_mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduledQueryMixedMeasureMappingArgs']]]]):
        pulumi.set(self, "mixed_measure_mappings", value)

    @property
    @pulumi.getter(name="multiMeasureMappings")
    def multi_measure_mappings(self) -> Optional[pulumi.Input['ScheduledQueryMultiMeasureMappingsArgs']]:
        return pulumi.get(self, "multi_measure_mappings")

    @multi_measure_mappings.setter
    def multi_measure_mappings(self, value: Optional[pulumi.Input['ScheduledQueryMultiMeasureMappingsArgs']]):
        pulumi.set(self, "multi_measure_mappings", value)


@pulumi.input_type
class SchemaPropertiesArgs:
    def __init__(__self__, *,
                 composite_partition_key: Optional[pulumi.Input[Sequence[pulumi.Input['TablePartitionKeyArgs']]]] = None):
        """
        A Schema specifies the expected data model of the table.
        """
        if composite_partition_key is not None:
            pulumi.set(__self__, "composite_partition_key", composite_partition_key)

    @property
    @pulumi.getter(name="compositePartitionKey")
    def composite_partition_key(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TablePartitionKeyArgs']]]]:
        return pulumi.get(self, "composite_partition_key")

    @composite_partition_key.setter
    def composite_partition_key(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TablePartitionKeyArgs']]]]):
        pulumi.set(self, "composite_partition_key", value)


@pulumi.input_type
class TablePartitionKeyArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['TablePartitionKeyType'],
                 enforcement_in_record: Optional[pulumi.Input['TablePartitionKeyEnforcementLevel']] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        An attribute used in partitioning data in a table. There are two types of partition keys: dimension keys and measure keys. A dimension key partitions data on a dimension name, while a measure key partitions data on the measure name.
        """
        pulumi.set(__self__, "type", type)
        if enforcement_in_record is not None:
            pulumi.set(__self__, "enforcement_in_record", enforcement_in_record)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input['TablePartitionKeyType']:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['TablePartitionKeyType']):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="enforcementInRecord")
    def enforcement_in_record(self) -> Optional[pulumi.Input['TablePartitionKeyEnforcementLevel']]:
        return pulumi.get(self, "enforcement_in_record")

    @enforcement_in_record.setter
    def enforcement_in_record(self, value: Optional[pulumi.Input['TablePartitionKeyEnforcementLevel']]):
        pulumi.set(self, "enforcement_in_record", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class TableTagArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        You can use the Resource Tags property to apply tags to resources, which can help you identify and categorize those resources.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


