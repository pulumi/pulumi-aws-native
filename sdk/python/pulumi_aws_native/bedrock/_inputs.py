# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'AgentActionGroupExecutor0PropertiesArgs',
    'AgentActionGroupExecutor0PropertiesArgsDict',
    'AgentActionGroupExecutor1PropertiesArgs',
    'AgentActionGroupExecutor1PropertiesArgsDict',
    'AgentActionGroupArgs',
    'AgentActionGroupArgsDict',
    'AgentAdditionalModelRequestFieldsArgs',
    'AgentAdditionalModelRequestFieldsArgsDict',
    'AgentAliasRoutingConfigurationListItemArgs',
    'AgentAliasRoutingConfigurationListItemArgsDict',
    'AgentApiSchema0PropertiesArgs',
    'AgentApiSchema0PropertiesArgsDict',
    'AgentApiSchema1PropertiesArgs',
    'AgentApiSchema1PropertiesArgsDict',
    'AgentCollaboratorAgentDescriptorPropertiesArgs',
    'AgentCollaboratorAgentDescriptorPropertiesArgsDict',
    'AgentCollaboratorArgs',
    'AgentCollaboratorArgsDict',
    'AgentCustomOrchestrationArgs',
    'AgentCustomOrchestrationArgsDict',
    'AgentFunctionSchemaArgs',
    'AgentFunctionSchemaArgsDict',
    'AgentFunctionArgs',
    'AgentFunctionArgsDict',
    'AgentGuardrailConfigurationArgs',
    'AgentGuardrailConfigurationArgsDict',
    'AgentInferenceConfigurationArgs',
    'AgentInferenceConfigurationArgsDict',
    'AgentKnowledgeBaseArgs',
    'AgentKnowledgeBaseArgsDict',
    'AgentMemoryConfigurationArgs',
    'AgentMemoryConfigurationArgsDict',
    'AgentOrchestrationExecutorArgs',
    'AgentOrchestrationExecutorArgsDict',
    'AgentParameterDetailArgs',
    'AgentParameterDetailArgsDict',
    'AgentPromptConfigurationArgs',
    'AgentPromptConfigurationArgsDict',
    'AgentPromptOverrideConfigurationArgs',
    'AgentPromptOverrideConfigurationArgsDict',
    'AgentS3IdentifierArgs',
    'AgentS3IdentifierArgsDict',
    'AgentSessionSummaryConfigurationArgs',
    'AgentSessionSummaryConfigurationArgsDict',
    'ApplicationInferenceProfileInferenceProfileModelSourcePropertiesArgs',
    'ApplicationInferenceProfileInferenceProfileModelSourcePropertiesArgsDict',
    'AutomatedReasoningPolicyPolicyDefinitionRuleArgs',
    'AutomatedReasoningPolicyPolicyDefinitionRuleArgsDict',
    'AutomatedReasoningPolicyPolicyDefinitionTypeValueArgs',
    'AutomatedReasoningPolicyPolicyDefinitionTypeValueArgsDict',
    'AutomatedReasoningPolicyPolicyDefinitionTypeArgs',
    'AutomatedReasoningPolicyPolicyDefinitionTypeArgsDict',
    'AutomatedReasoningPolicyPolicyDefinitionVariableArgs',
    'AutomatedReasoningPolicyPolicyDefinitionVariableArgsDict',
    'AutomatedReasoningPolicyPolicyDefinitionArgs',
    'AutomatedReasoningPolicyPolicyDefinitionArgsDict',
    'DataAutomationProjectAudioExtractionCategoryTypeConfigurationArgs',
    'DataAutomationProjectAudioExtractionCategoryTypeConfigurationArgsDict',
    'DataAutomationProjectAudioExtractionCategoryArgs',
    'DataAutomationProjectAudioExtractionCategoryArgsDict',
    'DataAutomationProjectAudioOverrideConfigurationArgs',
    'DataAutomationProjectAudioOverrideConfigurationArgsDict',
    'DataAutomationProjectAudioStandardExtractionArgs',
    'DataAutomationProjectAudioStandardExtractionArgsDict',
    'DataAutomationProjectAudioStandardGenerativeFieldArgs',
    'DataAutomationProjectAudioStandardGenerativeFieldArgsDict',
    'DataAutomationProjectAudioStandardOutputConfigurationArgs',
    'DataAutomationProjectAudioStandardOutputConfigurationArgsDict',
    'DataAutomationProjectBlueprintItemArgs',
    'DataAutomationProjectBlueprintItemArgsDict',
    'DataAutomationProjectChannelLabelingConfigurationArgs',
    'DataAutomationProjectChannelLabelingConfigurationArgsDict',
    'DataAutomationProjectCustomOutputConfigurationArgs',
    'DataAutomationProjectCustomOutputConfigurationArgsDict',
    'DataAutomationProjectDocumentBoundingBoxArgs',
    'DataAutomationProjectDocumentBoundingBoxArgsDict',
    'DataAutomationProjectDocumentExtractionGranularityArgs',
    'DataAutomationProjectDocumentExtractionGranularityArgsDict',
    'DataAutomationProjectDocumentOutputAdditionalFileFormatArgs',
    'DataAutomationProjectDocumentOutputAdditionalFileFormatArgsDict',
    'DataAutomationProjectDocumentOutputFormatArgs',
    'DataAutomationProjectDocumentOutputFormatArgsDict',
    'DataAutomationProjectDocumentOutputTextFormatArgs',
    'DataAutomationProjectDocumentOutputTextFormatArgsDict',
    'DataAutomationProjectDocumentOverrideConfigurationArgs',
    'DataAutomationProjectDocumentOverrideConfigurationArgsDict',
    'DataAutomationProjectDocumentStandardExtractionArgs',
    'DataAutomationProjectDocumentStandardExtractionArgsDict',
    'DataAutomationProjectDocumentStandardGenerativeFieldArgs',
    'DataAutomationProjectDocumentStandardGenerativeFieldArgsDict',
    'DataAutomationProjectDocumentStandardOutputConfigurationArgs',
    'DataAutomationProjectDocumentStandardOutputConfigurationArgsDict',
    'DataAutomationProjectImageBoundingBoxArgs',
    'DataAutomationProjectImageBoundingBoxArgsDict',
    'DataAutomationProjectImageExtractionCategoryArgs',
    'DataAutomationProjectImageExtractionCategoryArgsDict',
    'DataAutomationProjectImageOverrideConfigurationArgs',
    'DataAutomationProjectImageOverrideConfigurationArgsDict',
    'DataAutomationProjectImageStandardExtractionArgs',
    'DataAutomationProjectImageStandardExtractionArgsDict',
    'DataAutomationProjectImageStandardGenerativeFieldArgs',
    'DataAutomationProjectImageStandardGenerativeFieldArgsDict',
    'DataAutomationProjectImageStandardOutputConfigurationArgs',
    'DataAutomationProjectImageStandardOutputConfigurationArgsDict',
    'DataAutomationProjectModalityProcessingConfigurationArgs',
    'DataAutomationProjectModalityProcessingConfigurationArgsDict',
    'DataAutomationProjectModalityRoutingConfigurationArgs',
    'DataAutomationProjectModalityRoutingConfigurationArgsDict',
    'DataAutomationProjectOverrideConfigurationArgs',
    'DataAutomationProjectOverrideConfigurationArgsDict',
    'DataAutomationProjectSpeakerLabelingConfigurationArgs',
    'DataAutomationProjectSpeakerLabelingConfigurationArgsDict',
    'DataAutomationProjectSplitterConfigurationArgs',
    'DataAutomationProjectSplitterConfigurationArgsDict',
    'DataAutomationProjectStandardOutputConfigurationArgs',
    'DataAutomationProjectStandardOutputConfigurationArgsDict',
    'DataAutomationProjectTranscriptConfigurationArgs',
    'DataAutomationProjectTranscriptConfigurationArgsDict',
    'DataAutomationProjectVideoBoundingBoxArgs',
    'DataAutomationProjectVideoBoundingBoxArgsDict',
    'DataAutomationProjectVideoExtractionCategoryArgs',
    'DataAutomationProjectVideoExtractionCategoryArgsDict',
    'DataAutomationProjectVideoOverrideConfigurationArgs',
    'DataAutomationProjectVideoOverrideConfigurationArgsDict',
    'DataAutomationProjectVideoStandardExtractionArgs',
    'DataAutomationProjectVideoStandardExtractionArgsDict',
    'DataAutomationProjectVideoStandardGenerativeFieldArgs',
    'DataAutomationProjectVideoStandardGenerativeFieldArgsDict',
    'DataAutomationProjectVideoStandardOutputConfigurationArgs',
    'DataAutomationProjectVideoStandardOutputConfigurationArgsDict',
    'DataSourceBedrockDataAutomationConfigurationArgs',
    'DataSourceBedrockDataAutomationConfigurationArgsDict',
    'DataSourceBedrockFoundationModelConfigurationArgs',
    'DataSourceBedrockFoundationModelConfigurationArgsDict',
    'DataSourceBedrockFoundationModelContextEnrichmentConfigurationArgs',
    'DataSourceBedrockFoundationModelContextEnrichmentConfigurationArgsDict',
    'DataSourceChunkingConfigurationArgs',
    'DataSourceChunkingConfigurationArgsDict',
    'DataSourceConfigurationArgs',
    'DataSourceConfigurationArgsDict',
    'DataSourceConfluenceCrawlerConfigurationArgs',
    'DataSourceConfluenceCrawlerConfigurationArgsDict',
    'DataSourceConfluenceDataSourceConfigurationArgs',
    'DataSourceConfluenceDataSourceConfigurationArgsDict',
    'DataSourceConfluenceSourceConfigurationArgs',
    'DataSourceConfluenceSourceConfigurationArgsDict',
    'DataSourceContextEnrichmentConfigurationArgs',
    'DataSourceContextEnrichmentConfigurationArgsDict',
    'DataSourceCrawlFilterConfigurationArgs',
    'DataSourceCrawlFilterConfigurationArgsDict',
    'DataSourceCustomTransformationConfigurationArgs',
    'DataSourceCustomTransformationConfigurationArgsDict',
    'DataSourceEnrichmentStrategyConfigurationArgs',
    'DataSourceEnrichmentStrategyConfigurationArgsDict',
    'DataSourceFixedSizeChunkingConfigurationArgs',
    'DataSourceFixedSizeChunkingConfigurationArgsDict',
    'DataSourceHierarchicalChunkingConfigurationArgs',
    'DataSourceHierarchicalChunkingConfigurationArgsDict',
    'DataSourceHierarchicalChunkingLevelConfigurationArgs',
    'DataSourceHierarchicalChunkingLevelConfigurationArgsDict',
    'DataSourceIntermediateStorageArgs',
    'DataSourceIntermediateStorageArgsDict',
    'DataSourceParsingConfigurationArgs',
    'DataSourceParsingConfigurationArgsDict',
    'DataSourceParsingPromptArgs',
    'DataSourceParsingPromptArgsDict',
    'DataSourcePatternObjectFilterConfigurationArgs',
    'DataSourcePatternObjectFilterConfigurationArgsDict',
    'DataSourcePatternObjectFilterArgs',
    'DataSourcePatternObjectFilterArgsDict',
    'DataSourceS3DataSourceConfigurationArgs',
    'DataSourceS3DataSourceConfigurationArgsDict',
    'DataSourceS3LocationArgs',
    'DataSourceS3LocationArgsDict',
    'DataSourceSalesforceCrawlerConfigurationArgs',
    'DataSourceSalesforceCrawlerConfigurationArgsDict',
    'DataSourceSalesforceDataSourceConfigurationArgs',
    'DataSourceSalesforceDataSourceConfigurationArgsDict',
    'DataSourceSalesforceSourceConfigurationArgs',
    'DataSourceSalesforceSourceConfigurationArgsDict',
    'DataSourceSeedUrlArgs',
    'DataSourceSeedUrlArgsDict',
    'DataSourceSemanticChunkingConfigurationArgs',
    'DataSourceSemanticChunkingConfigurationArgsDict',
    'DataSourceServerSideEncryptionConfigurationArgs',
    'DataSourceServerSideEncryptionConfigurationArgsDict',
    'DataSourceSharePointCrawlerConfigurationArgs',
    'DataSourceSharePointCrawlerConfigurationArgsDict',
    'DataSourceSharePointDataSourceConfigurationArgs',
    'DataSourceSharePointDataSourceConfigurationArgsDict',
    'DataSourceSharePointSourceConfigurationArgs',
    'DataSourceSharePointSourceConfigurationArgsDict',
    'DataSourceTransformationFunctionArgs',
    'DataSourceTransformationFunctionArgsDict',
    'DataSourceTransformationLambdaConfigurationArgs',
    'DataSourceTransformationLambdaConfigurationArgsDict',
    'DataSourceTransformationArgs',
    'DataSourceTransformationArgsDict',
    'DataSourceUrlConfigurationArgs',
    'DataSourceUrlConfigurationArgsDict',
    'DataSourceVectorIngestionConfigurationArgs',
    'DataSourceVectorIngestionConfigurationArgsDict',
    'DataSourceWebCrawlerConfigurationArgs',
    'DataSourceWebCrawlerConfigurationArgsDict',
    'DataSourceWebCrawlerLimitsArgs',
    'DataSourceWebCrawlerLimitsArgsDict',
    'DataSourceWebDataSourceConfigurationArgs',
    'DataSourceWebDataSourceConfigurationArgsDict',
    'DataSourceWebSourceConfigurationArgs',
    'DataSourceWebSourceConfigurationArgsDict',
    'FlowAdditionalModelRequestFieldsArgs',
    'FlowAdditionalModelRequestFieldsArgsDict',
    'FlowAgentFlowNodeConfigurationArgs',
    'FlowAgentFlowNodeConfigurationArgsDict',
    'FlowAliasConcurrencyConfigurationArgs',
    'FlowAliasConcurrencyConfigurationArgsDict',
    'FlowAliasRoutingConfigurationListItemArgs',
    'FlowAliasRoutingConfigurationListItemArgsDict',
    'FlowCollectorFlowNodeConfigurationArgs',
    'FlowCollectorFlowNodeConfigurationArgsDict',
    'FlowConditionFlowNodeConfigurationArgs',
    'FlowConditionFlowNodeConfigurationArgsDict',
    'FlowConditionalConnectionConfigurationArgs',
    'FlowConditionalConnectionConfigurationArgsDict',
    'FlowConditionArgs',
    'FlowConditionArgsDict',
    'FlowConnectionConfiguration0PropertiesArgs',
    'FlowConnectionConfiguration0PropertiesArgsDict',
    'FlowConnectionConfiguration1PropertiesArgs',
    'FlowConnectionConfiguration1PropertiesArgsDict',
    'FlowConnectionArgs',
    'FlowConnectionArgsDict',
    'FlowDataConnectionConfigurationArgs',
    'FlowDataConnectionConfigurationArgsDict',
    'FlowDefinitionArgs',
    'FlowDefinitionArgsDict',
    'FlowFieldForRerankingArgs',
    'FlowFieldForRerankingArgsDict',
    'FlowGuardrailConfigurationArgs',
    'FlowGuardrailConfigurationArgsDict',
    'FlowInlineCodeFlowNodeConfigurationArgs',
    'FlowInlineCodeFlowNodeConfigurationArgsDict',
    'FlowInputFlowNodeConfigurationArgs',
    'FlowInputFlowNodeConfigurationArgsDict',
    'FlowIteratorFlowNodeConfigurationArgs',
    'FlowIteratorFlowNodeConfigurationArgsDict',
    'FlowKnowledgeBaseFlowNodeConfigurationArgs',
    'FlowKnowledgeBaseFlowNodeConfigurationArgsDict',
    'FlowKnowledgeBaseOrchestrationConfigurationArgs',
    'FlowKnowledgeBaseOrchestrationConfigurationArgsDict',
    'FlowKnowledgeBasePromptTemplatePropertiesArgs',
    'FlowKnowledgeBasePromptTemplatePropertiesArgsDict',
    'FlowLambdaFunctionFlowNodeConfigurationArgs',
    'FlowLambdaFunctionFlowNodeConfigurationArgsDict',
    'FlowLexFlowNodeConfigurationArgs',
    'FlowLexFlowNodeConfigurationArgsDict',
    'FlowLoopControllerFlowNodeConfigurationArgs',
    'FlowLoopControllerFlowNodeConfigurationArgsDict',
    'FlowLoopFlowNodeConfigurationArgs',
    'FlowLoopFlowNodeConfigurationArgsDict',
    'FlowLoopInputFlowNodeConfigurationArgs',
    'FlowLoopInputFlowNodeConfigurationArgsDict',
    'FlowMetadataConfigurationForRerankingArgs',
    'FlowMetadataConfigurationForRerankingArgsDict',
    'FlowNodeConfiguration0PropertiesArgs',
    'FlowNodeConfiguration0PropertiesArgsDict',
    'FlowNodeConfiguration10PropertiesArgs',
    'FlowNodeConfiguration10PropertiesArgsDict',
    'FlowNodeConfiguration11PropertiesArgs',
    'FlowNodeConfiguration11PropertiesArgsDict',
    'FlowNodeConfiguration12PropertiesArgs',
    'FlowNodeConfiguration12PropertiesArgsDict',
    'FlowNodeConfiguration13PropertiesArgs',
    'FlowNodeConfiguration13PropertiesArgsDict',
    'FlowNodeConfiguration14PropertiesArgs',
    'FlowNodeConfiguration14PropertiesArgsDict',
    'FlowNodeConfiguration15PropertiesArgs',
    'FlowNodeConfiguration15PropertiesArgsDict',
    'FlowNodeConfiguration1PropertiesArgs',
    'FlowNodeConfiguration1PropertiesArgsDict',
    'FlowNodeConfiguration2PropertiesArgs',
    'FlowNodeConfiguration2PropertiesArgsDict',
    'FlowNodeConfiguration3PropertiesArgs',
    'FlowNodeConfiguration3PropertiesArgsDict',
    'FlowNodeConfiguration4PropertiesArgs',
    'FlowNodeConfiguration4PropertiesArgsDict',
    'FlowNodeConfiguration5PropertiesArgs',
    'FlowNodeConfiguration5PropertiesArgsDict',
    'FlowNodeConfiguration6PropertiesArgs',
    'FlowNodeConfiguration6PropertiesArgsDict',
    'FlowNodeConfiguration7PropertiesArgs',
    'FlowNodeConfiguration7PropertiesArgsDict',
    'FlowNodeConfiguration8PropertiesArgs',
    'FlowNodeConfiguration8PropertiesArgsDict',
    'FlowNodeConfiguration9PropertiesArgs',
    'FlowNodeConfiguration9PropertiesArgsDict',
    'FlowNodeInputArgs',
    'FlowNodeInputArgsDict',
    'FlowNodeOutputArgs',
    'FlowNodeOutputArgsDict',
    'FlowNodeArgs',
    'FlowNodeArgsDict',
    'FlowOutputFlowNodeConfigurationArgs',
    'FlowOutputFlowNodeConfigurationArgsDict',
    'FlowPerformanceConfigurationArgs',
    'FlowPerformanceConfigurationArgsDict',
    'FlowPromptFlowNodeConfigurationArgs',
    'FlowPromptFlowNodeConfigurationArgsDict',
    'FlowPromptFlowNodeInlineConfigurationArgs',
    'FlowPromptFlowNodeInlineConfigurationArgsDict',
    'FlowPromptFlowNodeResourceConfigurationArgs',
    'FlowPromptFlowNodeResourceConfigurationArgsDict',
    'FlowPromptFlowNodeSourceConfiguration0PropertiesArgs',
    'FlowPromptFlowNodeSourceConfiguration0PropertiesArgsDict',
    'FlowPromptFlowNodeSourceConfiguration1PropertiesArgs',
    'FlowPromptFlowNodeSourceConfiguration1PropertiesArgsDict',
    'FlowPromptInferenceConfigurationPropertiesArgs',
    'FlowPromptInferenceConfigurationPropertiesArgsDict',
    'FlowPromptInputVariableArgs',
    'FlowPromptInputVariableArgsDict',
    'FlowPromptModelInferenceConfigurationArgs',
    'FlowPromptModelInferenceConfigurationArgsDict',
    'FlowPromptTemplateConfigurationPropertiesArgs',
    'FlowPromptTemplateConfigurationPropertiesArgsDict',
    'FlowRerankingMetadataSelectiveModeConfiguration0PropertiesArgs',
    'FlowRerankingMetadataSelectiveModeConfiguration0PropertiesArgsDict',
    'FlowRerankingMetadataSelectiveModeConfiguration1PropertiesArgs',
    'FlowRerankingMetadataSelectiveModeConfiguration1PropertiesArgsDict',
    'FlowRetrievalFlowNodeConfigurationArgs',
    'FlowRetrievalFlowNodeConfigurationArgsDict',
    'FlowRetrievalFlowNodeS3ConfigurationArgs',
    'FlowRetrievalFlowNodeS3ConfigurationArgsDict',
    'FlowRetrievalFlowNodeServiceConfigurationPropertiesArgs',
    'FlowRetrievalFlowNodeServiceConfigurationPropertiesArgsDict',
    'FlowS3LocationArgs',
    'FlowS3LocationArgsDict',
    'FlowStorageFlowNodeConfigurationArgs',
    'FlowStorageFlowNodeConfigurationArgsDict',
    'FlowStorageFlowNodeS3ConfigurationArgs',
    'FlowStorageFlowNodeS3ConfigurationArgsDict',
    'FlowStorageFlowNodeServiceConfigurationPropertiesArgs',
    'FlowStorageFlowNodeServiceConfigurationPropertiesArgsDict',
    'FlowTextPromptTemplateConfigurationArgs',
    'FlowTextPromptTemplateConfigurationArgsDict',
    'FlowVectorSearchBedrockRerankingConfigurationArgs',
    'FlowVectorSearchBedrockRerankingConfigurationArgsDict',
    'FlowVectorSearchBedrockRerankingModelConfigurationArgs',
    'FlowVectorSearchBedrockRerankingModelConfigurationArgsDict',
    'FlowVectorSearchRerankingConfigurationArgs',
    'FlowVectorSearchRerankingConfigurationArgsDict',
    'GuardrailAutomatedReasoningPolicyConfigArgs',
    'GuardrailAutomatedReasoningPolicyConfigArgsDict',
    'GuardrailContentFilterConfigArgs',
    'GuardrailContentFilterConfigArgsDict',
    'GuardrailContentPolicyConfigContentFiltersTierConfigPropertiesArgs',
    'GuardrailContentPolicyConfigContentFiltersTierConfigPropertiesArgsDict',
    'GuardrailContentPolicyConfigArgs',
    'GuardrailContentPolicyConfigArgsDict',
    'GuardrailContextualGroundingFilterConfigArgs',
    'GuardrailContextualGroundingFilterConfigArgsDict',
    'GuardrailContextualGroundingPolicyConfigArgs',
    'GuardrailContextualGroundingPolicyConfigArgsDict',
    'GuardrailCrossRegionConfigArgs',
    'GuardrailCrossRegionConfigArgsDict',
    'GuardrailManagedWordsConfigArgs',
    'GuardrailManagedWordsConfigArgsDict',
    'GuardrailPiiEntityConfigArgs',
    'GuardrailPiiEntityConfigArgsDict',
    'GuardrailRegexConfigArgs',
    'GuardrailRegexConfigArgsDict',
    'GuardrailSensitiveInformationPolicyConfigArgs',
    'GuardrailSensitiveInformationPolicyConfigArgsDict',
    'GuardrailTopicConfigArgs',
    'GuardrailTopicConfigArgsDict',
    'GuardrailTopicPolicyConfigTopicsTierConfigPropertiesArgs',
    'GuardrailTopicPolicyConfigTopicsTierConfigPropertiesArgsDict',
    'GuardrailTopicPolicyConfigArgs',
    'GuardrailTopicPolicyConfigArgsDict',
    'GuardrailWordConfigArgs',
    'GuardrailWordConfigArgsDict',
    'GuardrailWordPolicyConfigArgs',
    'GuardrailWordPolicyConfigArgsDict',
    'IntelligentPromptRouterPromptRouterTargetModelArgs',
    'IntelligentPromptRouterPromptRouterTargetModelArgsDict',
    'IntelligentPromptRouterRoutingCriteriaArgs',
    'IntelligentPromptRouterRoutingCriteriaArgsDict',
    'KnowledgeBaseBedrockEmbeddingModelConfigurationArgs',
    'KnowledgeBaseBedrockEmbeddingModelConfigurationArgsDict',
    'KnowledgeBaseConfigurationArgs',
    'KnowledgeBaseConfigurationArgsDict',
    'KnowledgeBaseCuratedQueryArgs',
    'KnowledgeBaseCuratedQueryArgsDict',
    'KnowledgeBaseEmbeddingModelConfigurationArgs',
    'KnowledgeBaseEmbeddingModelConfigurationArgsDict',
    'KnowledgeBaseKendraKnowledgeBaseConfigurationArgs',
    'KnowledgeBaseKendraKnowledgeBaseConfigurationArgsDict',
    'KnowledgeBaseMongoDbAtlasConfigurationArgs',
    'KnowledgeBaseMongoDbAtlasConfigurationArgsDict',
    'KnowledgeBaseMongoDbAtlasFieldMappingArgs',
    'KnowledgeBaseMongoDbAtlasFieldMappingArgsDict',
    'KnowledgeBaseNeptuneAnalyticsConfigurationArgs',
    'KnowledgeBaseNeptuneAnalyticsConfigurationArgsDict',
    'KnowledgeBaseNeptuneAnalyticsFieldMappingArgs',
    'KnowledgeBaseNeptuneAnalyticsFieldMappingArgsDict',
    'KnowledgeBaseOpenSearchManagedClusterConfigurationArgs',
    'KnowledgeBaseOpenSearchManagedClusterConfigurationArgsDict',
    'KnowledgeBaseOpenSearchManagedClusterFieldMappingArgs',
    'KnowledgeBaseOpenSearchManagedClusterFieldMappingArgsDict',
    'KnowledgeBaseOpenSearchServerlessConfigurationArgs',
    'KnowledgeBaseOpenSearchServerlessConfigurationArgsDict',
    'KnowledgeBaseOpenSearchServerlessFieldMappingArgs',
    'KnowledgeBaseOpenSearchServerlessFieldMappingArgsDict',
    'KnowledgeBasePineconeConfigurationArgs',
    'KnowledgeBasePineconeConfigurationArgsDict',
    'KnowledgeBasePineconeFieldMappingArgs',
    'KnowledgeBasePineconeFieldMappingArgsDict',
    'KnowledgeBaseQueryGenerationColumnArgs',
    'KnowledgeBaseQueryGenerationColumnArgsDict',
    'KnowledgeBaseQueryGenerationConfigurationArgs',
    'KnowledgeBaseQueryGenerationConfigurationArgsDict',
    'KnowledgeBaseQueryGenerationContextArgs',
    'KnowledgeBaseQueryGenerationContextArgsDict',
    'KnowledgeBaseQueryGenerationTableArgs',
    'KnowledgeBaseQueryGenerationTableArgsDict',
    'KnowledgeBaseRdsConfigurationArgs',
    'KnowledgeBaseRdsConfigurationArgsDict',
    'KnowledgeBaseRdsFieldMappingArgs',
    'KnowledgeBaseRdsFieldMappingArgsDict',
    'KnowledgeBaseRedshiftConfigurationArgs',
    'KnowledgeBaseRedshiftConfigurationArgsDict',
    'KnowledgeBaseRedshiftProvisionedAuthConfigurationArgs',
    'KnowledgeBaseRedshiftProvisionedAuthConfigurationArgsDict',
    'KnowledgeBaseRedshiftProvisionedConfigurationArgs',
    'KnowledgeBaseRedshiftProvisionedConfigurationArgsDict',
    'KnowledgeBaseRedshiftQueryEngineAwsDataCatalogStorageConfigurationArgs',
    'KnowledgeBaseRedshiftQueryEngineAwsDataCatalogStorageConfigurationArgsDict',
    'KnowledgeBaseRedshiftQueryEngineConfigurationArgs',
    'KnowledgeBaseRedshiftQueryEngineConfigurationArgsDict',
    'KnowledgeBaseRedshiftQueryEngineRedshiftStorageConfigurationArgs',
    'KnowledgeBaseRedshiftQueryEngineRedshiftStorageConfigurationArgsDict',
    'KnowledgeBaseRedshiftQueryEngineStorageConfigurationArgs',
    'KnowledgeBaseRedshiftQueryEngineStorageConfigurationArgsDict',
    'KnowledgeBaseRedshiftServerlessAuthConfigurationArgs',
    'KnowledgeBaseRedshiftServerlessAuthConfigurationArgsDict',
    'KnowledgeBaseRedshiftServerlessConfigurationArgs',
    'KnowledgeBaseRedshiftServerlessConfigurationArgsDict',
    'KnowledgeBaseS3LocationArgs',
    'KnowledgeBaseS3LocationArgsDict',
    'KnowledgeBaseSqlKnowledgeBaseConfigurationArgs',
    'KnowledgeBaseSqlKnowledgeBaseConfigurationArgsDict',
    'KnowledgeBaseStorageConfigurationArgs',
    'KnowledgeBaseStorageConfigurationArgsDict',
    'KnowledgeBaseSupplementalDataStorageConfigurationArgs',
    'KnowledgeBaseSupplementalDataStorageConfigurationArgsDict',
    'KnowledgeBaseSupplementalDataStorageLocationArgs',
    'KnowledgeBaseSupplementalDataStorageLocationArgsDict',
    'KnowledgeBaseVectorKnowledgeBaseConfigurationArgs',
    'KnowledgeBaseVectorKnowledgeBaseConfigurationArgsDict',
    'PromptAdditionalModelRequestFieldsArgs',
    'PromptAdditionalModelRequestFieldsArgsDict',
    'PromptAgentResourceArgs',
    'PromptAgentResourceArgsDict',
    'PromptAnyToolChoiceArgs',
    'PromptAnyToolChoiceArgsDict',
    'PromptAutoToolChoiceArgs',
    'PromptAutoToolChoiceArgsDict',
    'PromptCachePointBlockArgs',
    'PromptCachePointBlockArgsDict',
    'PromptChatPromptTemplateConfigurationArgs',
    'PromptChatPromptTemplateConfigurationArgsDict',
    'PromptContentBlock0PropertiesArgs',
    'PromptContentBlock0PropertiesArgsDict',
    'PromptContentBlock1PropertiesArgs',
    'PromptContentBlock1PropertiesArgsDict',
    'PromptGenAiResourcePropertiesArgs',
    'PromptGenAiResourcePropertiesArgsDict',
    'PromptInferenceConfigurationPropertiesArgs',
    'PromptInferenceConfigurationPropertiesArgsDict',
    'PromptInputVariableArgs',
    'PromptInputVariableArgsDict',
    'PromptMessageArgs',
    'PromptMessageArgsDict',
    'PromptMetadataEntryArgs',
    'PromptMetadataEntryArgsDict',
    'PromptModelInferenceConfigurationArgs',
    'PromptModelInferenceConfigurationArgsDict',
    'PromptSpecificToolChoiceArgs',
    'PromptSpecificToolChoiceArgsDict',
    'PromptSystemContentBlock0PropertiesArgs',
    'PromptSystemContentBlock0PropertiesArgsDict',
    'PromptSystemContentBlock1PropertiesArgs',
    'PromptSystemContentBlock1PropertiesArgsDict',
    'PromptTemplateConfiguration0PropertiesArgs',
    'PromptTemplateConfiguration0PropertiesArgsDict',
    'PromptTemplateConfiguration1PropertiesArgs',
    'PromptTemplateConfiguration1PropertiesArgsDict',
    'PromptTextPromptTemplateConfigurationArgs',
    'PromptTextPromptTemplateConfigurationArgsDict',
    'PromptTextS3LocationArgs',
    'PromptTextS3LocationArgsDict',
    'PromptTool0PropertiesArgs',
    'PromptTool0PropertiesArgsDict',
    'PromptTool1PropertiesArgs',
    'PromptTool1PropertiesArgsDict',
    'PromptToolChoice0PropertiesArgs',
    'PromptToolChoice0PropertiesArgsDict',
    'PromptToolChoice1PropertiesArgs',
    'PromptToolChoice1PropertiesArgsDict',
    'PromptToolChoice2PropertiesArgs',
    'PromptToolChoice2PropertiesArgsDict',
    'PromptToolConfigurationArgs',
    'PromptToolConfigurationArgsDict',
    'PromptToolInputSchemaPropertiesArgs',
    'PromptToolInputSchemaPropertiesArgsDict',
    'PromptToolSpecificationArgs',
    'PromptToolSpecificationArgsDict',
    'PromptVariantArgs',
    'PromptVariantArgsDict',
]

MYPY = False

if not MYPY:
    class AgentActionGroupExecutor0PropertiesArgsDict(TypedDict):
        """
        Type of Executors for an Action Group
        """
        lambda_: pulumi.Input[_builtins.str]
        """
        ARN of a Lambda.
        """
elif False:
    AgentActionGroupExecutor0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentActionGroupExecutor0PropertiesArgs:
    def __init__(__self__, *,
                 lambda_: pulumi.Input[_builtins.str]):
        """
        Type of Executors for an Action Group
        :param pulumi.Input[_builtins.str] lambda_: ARN of a Lambda.
        """
        pulumi.set(__self__, "lambda_", lambda_)

    @_builtins.property
    @pulumi.getter(name="lambda")
    def lambda_(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of a Lambda.
        """
        return pulumi.get(self, "lambda_")

    @lambda_.setter
    def lambda_(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "lambda_", value)


if not MYPY:
    class AgentActionGroupExecutor1PropertiesArgsDict(TypedDict):
        """
        Type of Executors for an Action Group
        """
        custom_control: pulumi.Input['AgentCustomControlMethod']
elif False:
    AgentActionGroupExecutor1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentActionGroupExecutor1PropertiesArgs:
    def __init__(__self__, *,
                 custom_control: pulumi.Input['AgentCustomControlMethod']):
        """
        Type of Executors for an Action Group
        """
        pulumi.set(__self__, "custom_control", custom_control)

    @_builtins.property
    @pulumi.getter(name="customControl")
    def custom_control(self) -> pulumi.Input['AgentCustomControlMethod']:
        return pulumi.get(self, "custom_control")

    @custom_control.setter
    def custom_control(self, value: pulumi.Input['AgentCustomControlMethod']):
        pulumi.set(self, "custom_control", value)


if not MYPY:
    class AgentActionGroupArgsDict(TypedDict):
        """
        Contains the information of an Agent Action Group
        """
        action_group_name: pulumi.Input[_builtins.str]
        """
        Name of the action group
        """
        action_group_executor: NotRequired[pulumi.Input[Union['AgentActionGroupExecutor0PropertiesArgsDict', 'AgentActionGroupExecutor1PropertiesArgsDict']]]
        """
        The Amazon Resource Name (ARN) of the Lambda function containing the business logic that is carried out upon invoking the action or the custom control method for handling the information elicited from the user.
        """
        action_group_state: NotRequired[pulumi.Input['AgentActionGroupState']]
        """
        Specifies whether the action group is available for the agent to invoke or not when sending an [InvokeAgent](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html) request.
        """
        api_schema: NotRequired[pulumi.Input[Union['AgentApiSchema0PropertiesArgsDict', 'AgentApiSchema1PropertiesArgsDict']]]
        """
        Contains either details about the S3 object containing the OpenAPI schema for the action group or the JSON or YAML-formatted payload defining the schema. For more information, see [Action group OpenAPI schemas](https://docs.aws.amazon.com//bedrock/latest/userguide/agents-api-schema.html) .
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of action group
        """
        function_schema: NotRequired[pulumi.Input['AgentFunctionSchemaArgsDict']]
        """
        Contains details about the function schema for the action group or the JSON or YAML-formatted payload defining the schema.
        """
        parent_action_group_signature: NotRequired[pulumi.Input['AgentActionGroupSignature']]
        """
        If this field is set as `AMAZON.UserInput` , the agent can request the user for additional information when trying to complete a task. The `description` , `apiSchema` , and `actionGroupExecutor` fields must be blank for this action group.

        During orchestration, if the agent determines that it needs to invoke an API in an action group, but doesn't have enough information to complete the API request, it will invoke this action group instead and return an [Observation](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Observation.html) reprompting the user for more information.
        """
        skip_resource_in_use_check_on_delete: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to allow deleting action group while it is in use.
        """
elif False:
    AgentActionGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentActionGroupArgs:
    def __init__(__self__, *,
                 action_group_name: pulumi.Input[_builtins.str],
                 action_group_executor: Optional[pulumi.Input[Union['AgentActionGroupExecutor0PropertiesArgs', 'AgentActionGroupExecutor1PropertiesArgs']]] = None,
                 action_group_state: Optional[pulumi.Input['AgentActionGroupState']] = None,
                 api_schema: Optional[pulumi.Input[Union['AgentApiSchema0PropertiesArgs', 'AgentApiSchema1PropertiesArgs']]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 function_schema: Optional[pulumi.Input['AgentFunctionSchemaArgs']] = None,
                 parent_action_group_signature: Optional[pulumi.Input['AgentActionGroupSignature']] = None,
                 skip_resource_in_use_check_on_delete: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        Contains the information of an Agent Action Group
        :param pulumi.Input[_builtins.str] action_group_name: Name of the action group
        :param pulumi.Input[Union['AgentActionGroupExecutor0PropertiesArgs', 'AgentActionGroupExecutor1PropertiesArgs']] action_group_executor: The Amazon Resource Name (ARN) of the Lambda function containing the business logic that is carried out upon invoking the action or the custom control method for handling the information elicited from the user.
        :param pulumi.Input['AgentActionGroupState'] action_group_state: Specifies whether the action group is available for the agent to invoke or not when sending an [InvokeAgent](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html) request.
        :param pulumi.Input[Union['AgentApiSchema0PropertiesArgs', 'AgentApiSchema1PropertiesArgs']] api_schema: Contains either details about the S3 object containing the OpenAPI schema for the action group or the JSON or YAML-formatted payload defining the schema. For more information, see [Action group OpenAPI schemas](https://docs.aws.amazon.com//bedrock/latest/userguide/agents-api-schema.html) .
        :param pulumi.Input[_builtins.str] description: Description of action group
        :param pulumi.Input['AgentFunctionSchemaArgs'] function_schema: Contains details about the function schema for the action group or the JSON or YAML-formatted payload defining the schema.
        :param pulumi.Input['AgentActionGroupSignature'] parent_action_group_signature: If this field is set as `AMAZON.UserInput` , the agent can request the user for additional information when trying to complete a task. The `description` , `apiSchema` , and `actionGroupExecutor` fields must be blank for this action group.
               
               During orchestration, if the agent determines that it needs to invoke an API in an action group, but doesn't have enough information to complete the API request, it will invoke this action group instead and return an [Observation](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Observation.html) reprompting the user for more information.
        :param pulumi.Input[_builtins.bool] skip_resource_in_use_check_on_delete: Specifies whether to allow deleting action group while it is in use.
        """
        pulumi.set(__self__, "action_group_name", action_group_name)
        if action_group_executor is not None:
            pulumi.set(__self__, "action_group_executor", action_group_executor)
        if action_group_state is not None:
            pulumi.set(__self__, "action_group_state", action_group_state)
        if api_schema is not None:
            pulumi.set(__self__, "api_schema", api_schema)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if function_schema is not None:
            pulumi.set(__self__, "function_schema", function_schema)
        if parent_action_group_signature is not None:
            pulumi.set(__self__, "parent_action_group_signature", parent_action_group_signature)
        if skip_resource_in_use_check_on_delete is not None:
            pulumi.set(__self__, "skip_resource_in_use_check_on_delete", skip_resource_in_use_check_on_delete)

    @_builtins.property
    @pulumi.getter(name="actionGroupName")
    def action_group_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the action group
        """
        return pulumi.get(self, "action_group_name")

    @action_group_name.setter
    def action_group_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action_group_name", value)

    @_builtins.property
    @pulumi.getter(name="actionGroupExecutor")
    def action_group_executor(self) -> Optional[pulumi.Input[Union['AgentActionGroupExecutor0PropertiesArgs', 'AgentActionGroupExecutor1PropertiesArgs']]]:
        """
        The Amazon Resource Name (ARN) of the Lambda function containing the business logic that is carried out upon invoking the action or the custom control method for handling the information elicited from the user.
        """
        return pulumi.get(self, "action_group_executor")

    @action_group_executor.setter
    def action_group_executor(self, value: Optional[pulumi.Input[Union['AgentActionGroupExecutor0PropertiesArgs', 'AgentActionGroupExecutor1PropertiesArgs']]]):
        pulumi.set(self, "action_group_executor", value)

    @_builtins.property
    @pulumi.getter(name="actionGroupState")
    def action_group_state(self) -> Optional[pulumi.Input['AgentActionGroupState']]:
        """
        Specifies whether the action group is available for the agent to invoke or not when sending an [InvokeAgent](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html) request.
        """
        return pulumi.get(self, "action_group_state")

    @action_group_state.setter
    def action_group_state(self, value: Optional[pulumi.Input['AgentActionGroupState']]):
        pulumi.set(self, "action_group_state", value)

    @_builtins.property
    @pulumi.getter(name="apiSchema")
    def api_schema(self) -> Optional[pulumi.Input[Union['AgentApiSchema0PropertiesArgs', 'AgentApiSchema1PropertiesArgs']]]:
        """
        Contains either details about the S3 object containing the OpenAPI schema for the action group or the JSON or YAML-formatted payload defining the schema. For more information, see [Action group OpenAPI schemas](https://docs.aws.amazon.com//bedrock/latest/userguide/agents-api-schema.html) .
        """
        return pulumi.get(self, "api_schema")

    @api_schema.setter
    def api_schema(self, value: Optional[pulumi.Input[Union['AgentApiSchema0PropertiesArgs', 'AgentApiSchema1PropertiesArgs']]]):
        pulumi.set(self, "api_schema", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of action group
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="functionSchema")
    def function_schema(self) -> Optional[pulumi.Input['AgentFunctionSchemaArgs']]:
        """
        Contains details about the function schema for the action group or the JSON or YAML-formatted payload defining the schema.
        """
        return pulumi.get(self, "function_schema")

    @function_schema.setter
    def function_schema(self, value: Optional[pulumi.Input['AgentFunctionSchemaArgs']]):
        pulumi.set(self, "function_schema", value)

    @_builtins.property
    @pulumi.getter(name="parentActionGroupSignature")
    def parent_action_group_signature(self) -> Optional[pulumi.Input['AgentActionGroupSignature']]:
        """
        If this field is set as `AMAZON.UserInput` , the agent can request the user for additional information when trying to complete a task. The `description` , `apiSchema` , and `actionGroupExecutor` fields must be blank for this action group.

        During orchestration, if the agent determines that it needs to invoke an API in an action group, but doesn't have enough information to complete the API request, it will invoke this action group instead and return an [Observation](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Observation.html) reprompting the user for more information.
        """
        return pulumi.get(self, "parent_action_group_signature")

    @parent_action_group_signature.setter
    def parent_action_group_signature(self, value: Optional[pulumi.Input['AgentActionGroupSignature']]):
        pulumi.set(self, "parent_action_group_signature", value)

    @_builtins.property
    @pulumi.getter(name="skipResourceInUseCheckOnDelete")
    def skip_resource_in_use_check_on_delete(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to allow deleting action group while it is in use.
        """
        return pulumi.get(self, "skip_resource_in_use_check_on_delete")

    @skip_resource_in_use_check_on_delete.setter
    def skip_resource_in_use_check_on_delete(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "skip_resource_in_use_check_on_delete", value)


if not MYPY:
    class AgentAdditionalModelRequestFieldsArgsDict(TypedDict):
        """
        Additional Model Request Fields for Prompt Configuration
        """
        pass
elif False:
    AgentAdditionalModelRequestFieldsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAdditionalModelRequestFieldsArgs:
    def __init__(__self__):
        """
        Additional Model Request Fields for Prompt Configuration
        """
        pass


if not MYPY:
    class AgentAliasRoutingConfigurationListItemArgsDict(TypedDict):
        """
        Details about the routing configuration for an Agent alias.
        """
        agent_version: pulumi.Input[_builtins.str]
        """
        Agent Version.
        """
elif False:
    AgentAliasRoutingConfigurationListItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAliasRoutingConfigurationListItemArgs:
    def __init__(__self__, *,
                 agent_version: pulumi.Input[_builtins.str]):
        """
        Details about the routing configuration for an Agent alias.
        :param pulumi.Input[_builtins.str] agent_version: Agent Version.
        """
        pulumi.set(__self__, "agent_version", agent_version)

    @_builtins.property
    @pulumi.getter(name="agentVersion")
    def agent_version(self) -> pulumi.Input[_builtins.str]:
        """
        Agent Version.
        """
        return pulumi.get(self, "agent_version")

    @agent_version.setter
    def agent_version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "agent_version", value)


if not MYPY:
    class AgentApiSchema0PropertiesArgsDict(TypedDict):
        """
        Contains information about the API Schema for the Action Group
        """
        s3: pulumi.Input['AgentS3IdentifierArgsDict']
elif False:
    AgentApiSchema0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentApiSchema0PropertiesArgs:
    def __init__(__self__, *,
                 s3: pulumi.Input['AgentS3IdentifierArgs']):
        """
        Contains information about the API Schema for the Action Group
        """
        pulumi.set(__self__, "s3", s3)

    @_builtins.property
    @pulumi.getter
    def s3(self) -> pulumi.Input['AgentS3IdentifierArgs']:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: pulumi.Input['AgentS3IdentifierArgs']):
        pulumi.set(self, "s3", value)


if not MYPY:
    class AgentApiSchema1PropertiesArgsDict(TypedDict):
        """
        Contains information about the API Schema for the Action Group
        """
        payload: pulumi.Input[_builtins.str]
        """
        String OpenAPI Payload
        """
elif False:
    AgentApiSchema1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentApiSchema1PropertiesArgs:
    def __init__(__self__, *,
                 payload: pulumi.Input[_builtins.str]):
        """
        Contains information about the API Schema for the Action Group
        :param pulumi.Input[_builtins.str] payload: String OpenAPI Payload
        """
        pulumi.set(__self__, "payload", payload)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> pulumi.Input[_builtins.str]:
        """
        String OpenAPI Payload
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "payload", value)


if not MYPY:
    class AgentCollaboratorAgentDescriptorPropertiesArgsDict(TypedDict):
        """
        Agent descriptor for agent collaborator
        """
        alias_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        Alias ARN for agent descriptor
        """
elif False:
    AgentCollaboratorAgentDescriptorPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentCollaboratorAgentDescriptorPropertiesArgs:
    def __init__(__self__, *,
                 alias_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Agent descriptor for agent collaborator
        :param pulumi.Input[_builtins.str] alias_arn: Alias ARN for agent descriptor
        """
        if alias_arn is not None:
            pulumi.set(__self__, "alias_arn", alias_arn)

    @_builtins.property
    @pulumi.getter(name="aliasArn")
    def alias_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Alias ARN for agent descriptor
        """
        return pulumi.get(self, "alias_arn")

    @alias_arn.setter
    def alias_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "alias_arn", value)


if not MYPY:
    class AgentCollaboratorArgsDict(TypedDict):
        """
        Agent Collaborator
        """
        agent_descriptor: pulumi.Input['AgentCollaboratorAgentDescriptorPropertiesArgsDict']
        """
        Agent descriptor for agent collaborator
        """
        collaboration_instruction: pulumi.Input[_builtins.str]
        """
        Agent collaborator instruction
        """
        collaborator_name: pulumi.Input[_builtins.str]
        """
        Agent collaborator name
        """
        relay_conversation_history: NotRequired[pulumi.Input['AgentRelayConversationHistory']]
        """
        The collaborator's relay conversation history.
        """
elif False:
    AgentCollaboratorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentCollaboratorArgs:
    def __init__(__self__, *,
                 agent_descriptor: pulumi.Input['AgentCollaboratorAgentDescriptorPropertiesArgs'],
                 collaboration_instruction: pulumi.Input[_builtins.str],
                 collaborator_name: pulumi.Input[_builtins.str],
                 relay_conversation_history: Optional[pulumi.Input['AgentRelayConversationHistory']] = None):
        """
        Agent Collaborator
        :param pulumi.Input['AgentCollaboratorAgentDescriptorPropertiesArgs'] agent_descriptor: Agent descriptor for agent collaborator
        :param pulumi.Input[_builtins.str] collaboration_instruction: Agent collaborator instruction
        :param pulumi.Input[_builtins.str] collaborator_name: Agent collaborator name
        :param pulumi.Input['AgentRelayConversationHistory'] relay_conversation_history: The collaborator's relay conversation history.
        """
        pulumi.set(__self__, "agent_descriptor", agent_descriptor)
        pulumi.set(__self__, "collaboration_instruction", collaboration_instruction)
        pulumi.set(__self__, "collaborator_name", collaborator_name)
        if relay_conversation_history is not None:
            pulumi.set(__self__, "relay_conversation_history", relay_conversation_history)

    @_builtins.property
    @pulumi.getter(name="agentDescriptor")
    def agent_descriptor(self) -> pulumi.Input['AgentCollaboratorAgentDescriptorPropertiesArgs']:
        """
        Agent descriptor for agent collaborator
        """
        return pulumi.get(self, "agent_descriptor")

    @agent_descriptor.setter
    def agent_descriptor(self, value: pulumi.Input['AgentCollaboratorAgentDescriptorPropertiesArgs']):
        pulumi.set(self, "agent_descriptor", value)

    @_builtins.property
    @pulumi.getter(name="collaborationInstruction")
    def collaboration_instruction(self) -> pulumi.Input[_builtins.str]:
        """
        Agent collaborator instruction
        """
        return pulumi.get(self, "collaboration_instruction")

    @collaboration_instruction.setter
    def collaboration_instruction(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "collaboration_instruction", value)

    @_builtins.property
    @pulumi.getter(name="collaboratorName")
    def collaborator_name(self) -> pulumi.Input[_builtins.str]:
        """
        Agent collaborator name
        """
        return pulumi.get(self, "collaborator_name")

    @collaborator_name.setter
    def collaborator_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "collaborator_name", value)

    @_builtins.property
    @pulumi.getter(name="relayConversationHistory")
    def relay_conversation_history(self) -> Optional[pulumi.Input['AgentRelayConversationHistory']]:
        """
        The collaborator's relay conversation history.
        """
        return pulumi.get(self, "relay_conversation_history")

    @relay_conversation_history.setter
    def relay_conversation_history(self, value: Optional[pulumi.Input['AgentRelayConversationHistory']]):
        pulumi.set(self, "relay_conversation_history", value)


if not MYPY:
    class AgentCustomOrchestrationArgsDict(TypedDict):
        """
        Structure for custom orchestration
        """
        executor: NotRequired[pulumi.Input['AgentOrchestrationExecutorArgsDict']]
        """
        The structure of the executor invoking the actions in custom orchestration.
        """
elif False:
    AgentCustomOrchestrationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentCustomOrchestrationArgs:
    def __init__(__self__, *,
                 executor: Optional[pulumi.Input['AgentOrchestrationExecutorArgs']] = None):
        """
        Structure for custom orchestration
        :param pulumi.Input['AgentOrchestrationExecutorArgs'] executor: The structure of the executor invoking the actions in custom orchestration.
        """
        if executor is not None:
            pulumi.set(__self__, "executor", executor)

    @_builtins.property
    @pulumi.getter
    def executor(self) -> Optional[pulumi.Input['AgentOrchestrationExecutorArgs']]:
        """
        The structure of the executor invoking the actions in custom orchestration.
        """
        return pulumi.get(self, "executor")

    @executor.setter
    def executor(self, value: Optional[pulumi.Input['AgentOrchestrationExecutorArgs']]):
        pulumi.set(self, "executor", value)


if not MYPY:
    class AgentFunctionSchemaArgsDict(TypedDict):
        """
        Schema of Functions
        """
        functions: pulumi.Input[Sequence[pulumi.Input['AgentFunctionArgsDict']]]
        """
        List of Function definitions
        """
elif False:
    AgentFunctionSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFunctionSchemaArgs:
    def __init__(__self__, *,
                 functions: pulumi.Input[Sequence[pulumi.Input['AgentFunctionArgs']]]):
        """
        Schema of Functions
        :param pulumi.Input[Sequence[pulumi.Input['AgentFunctionArgs']]] functions: List of Function definitions
        """
        pulumi.set(__self__, "functions", functions)

    @_builtins.property
    @pulumi.getter
    def functions(self) -> pulumi.Input[Sequence[pulumi.Input['AgentFunctionArgs']]]:
        """
        List of Function definitions
        """
        return pulumi.get(self, "functions")

    @functions.setter
    def functions(self, value: pulumi.Input[Sequence[pulumi.Input['AgentFunctionArgs']]]):
        pulumi.set(self, "functions", value)


if not MYPY:
    class AgentFunctionArgsDict(TypedDict):
        """
        Function definition
        """
        name: pulumi.Input[_builtins.str]
        """
        Name for a resource.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of function
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['AgentParameterDetailArgsDict']]]]
        """
        The parameters that the agent elicits from the user to fulfill the function.
        """
        require_confirmation: NotRequired[pulumi.Input['AgentRequireConfirmation']]
        """
        Contains information if user confirmation is required to invoke the function.
        """
elif False:
    AgentFunctionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentFunctionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['AgentParameterDetailArgs']]]] = None,
                 require_confirmation: Optional[pulumi.Input['AgentRequireConfirmation']] = None):
        """
        Function definition
        :param pulumi.Input[_builtins.str] name: Name for a resource.
        :param pulumi.Input[_builtins.str] description: Description of function
        :param pulumi.Input[Mapping[str, pulumi.Input['AgentParameterDetailArgs']]] parameters: The parameters that the agent elicits from the user to fulfill the function.
        :param pulumi.Input['AgentRequireConfirmation'] require_confirmation: Contains information if user confirmation is required to invoke the function.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if require_confirmation is not None:
            pulumi.set(__self__, "require_confirmation", require_confirmation)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name for a resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of function
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['AgentParameterDetailArgs']]]]:
        """
        The parameters that the agent elicits from the user to fulfill the function.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['AgentParameterDetailArgs']]]]):
        pulumi.set(self, "parameters", value)

    @_builtins.property
    @pulumi.getter(name="requireConfirmation")
    def require_confirmation(self) -> Optional[pulumi.Input['AgentRequireConfirmation']]:
        """
        Contains information if user confirmation is required to invoke the function.
        """
        return pulumi.get(self, "require_confirmation")

    @require_confirmation.setter
    def require_confirmation(self, value: Optional[pulumi.Input['AgentRequireConfirmation']]):
        pulumi.set(self, "require_confirmation", value)


if not MYPY:
    class AgentGuardrailConfigurationArgsDict(TypedDict):
        """
        Configuration for a guardrail.
        """
        guardrail_identifier: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identifier for the guardrail, could be the id or the arn
        """
        guardrail_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Version of the guardrail
        """
elif False:
    AgentGuardrailConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentGuardrailConfigurationArgs:
    def __init__(__self__, *,
                 guardrail_identifier: Optional[pulumi.Input[_builtins.str]] = None,
                 guardrail_version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Configuration for a guardrail.
        :param pulumi.Input[_builtins.str] guardrail_identifier: Identifier for the guardrail, could be the id or the arn
        :param pulumi.Input[_builtins.str] guardrail_version: Version of the guardrail
        """
        if guardrail_identifier is not None:
            pulumi.set(__self__, "guardrail_identifier", guardrail_identifier)
        if guardrail_version is not None:
            pulumi.set(__self__, "guardrail_version", guardrail_version)

    @_builtins.property
    @pulumi.getter(name="guardrailIdentifier")
    def guardrail_identifier(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifier for the guardrail, could be the id or the arn
        """
        return pulumi.get(self, "guardrail_identifier")

    @guardrail_identifier.setter
    def guardrail_identifier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "guardrail_identifier", value)

    @_builtins.property
    @pulumi.getter(name="guardrailVersion")
    def guardrail_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Version of the guardrail
        """
        return pulumi.get(self, "guardrail_version")

    @guardrail_version.setter
    def guardrail_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "guardrail_version", value)


if not MYPY:
    class AgentInferenceConfigurationArgsDict(TypedDict):
        """
        Configuration for inference in prompt configuration
        """
        maximum_length: NotRequired[pulumi.Input[_builtins.float]]
        """
        Maximum length of output
        """
        stop_sequences: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of stop sequences
        """
        temperature: NotRequired[pulumi.Input[_builtins.float]]
        """
        Controls randomness, higher values increase diversity
        """
        top_k: NotRequired[pulumi.Input[_builtins.float]]
        """
        Sample from the k most likely next tokens
        """
        top_p: NotRequired[pulumi.Input[_builtins.float]]
        """
        Cumulative probability cutoff for token selection
        """
elif False:
    AgentInferenceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentInferenceConfigurationArgs:
    def __init__(__self__, *,
                 maximum_length: Optional[pulumi.Input[_builtins.float]] = None,
                 stop_sequences: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 temperature: Optional[pulumi.Input[_builtins.float]] = None,
                 top_k: Optional[pulumi.Input[_builtins.float]] = None,
                 top_p: Optional[pulumi.Input[_builtins.float]] = None):
        """
        Configuration for inference in prompt configuration
        :param pulumi.Input[_builtins.float] maximum_length: Maximum length of output
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] stop_sequences: List of stop sequences
        :param pulumi.Input[_builtins.float] temperature: Controls randomness, higher values increase diversity
        :param pulumi.Input[_builtins.float] top_k: Sample from the k most likely next tokens
        :param pulumi.Input[_builtins.float] top_p: Cumulative probability cutoff for token selection
        """
        if maximum_length is not None:
            pulumi.set(__self__, "maximum_length", maximum_length)
        if stop_sequences is not None:
            pulumi.set(__self__, "stop_sequences", stop_sequences)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)
        if top_k is not None:
            pulumi.set(__self__, "top_k", top_k)
        if top_p is not None:
            pulumi.set(__self__, "top_p", top_p)

    @_builtins.property
    @pulumi.getter(name="maximumLength")
    def maximum_length(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Maximum length of output
        """
        return pulumi.get(self, "maximum_length")

    @maximum_length.setter
    def maximum_length(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "maximum_length", value)

    @_builtins.property
    @pulumi.getter(name="stopSequences")
    def stop_sequences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of stop sequences
        """
        return pulumi.get(self, "stop_sequences")

    @stop_sequences.setter
    def stop_sequences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "stop_sequences", value)

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Controls randomness, higher values increase diversity
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "temperature", value)

    @_builtins.property
    @pulumi.getter(name="topK")
    def top_k(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Sample from the k most likely next tokens
        """
        return pulumi.get(self, "top_k")

    @top_k.setter
    def top_k(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "top_k", value)

    @_builtins.property
    @pulumi.getter(name="topP")
    def top_p(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Cumulative probability cutoff for token selection
        """
        return pulumi.get(self, "top_p")

    @top_p.setter
    def top_p(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "top_p", value)


if not MYPY:
    class AgentKnowledgeBaseArgsDict(TypedDict):
        """
        Agent Knowledge Base
        """
        description: pulumi.Input[_builtins.str]
        """
        Description of the Resource.
        """
        knowledge_base_id: pulumi.Input[_builtins.str]
        """
        Identifier for a resource.
        """
        knowledge_base_state: NotRequired[pulumi.Input['AgentKnowledgeBaseState']]
        """
        Specifies whether to use the knowledge base or not when sending an [InvokeAgent](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html) request.
        """
elif False:
    AgentKnowledgeBaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentKnowledgeBaseArgs:
    def __init__(__self__, *,
                 description: pulumi.Input[_builtins.str],
                 knowledge_base_id: pulumi.Input[_builtins.str],
                 knowledge_base_state: Optional[pulumi.Input['AgentKnowledgeBaseState']] = None):
        """
        Agent Knowledge Base
        :param pulumi.Input[_builtins.str] description: Description of the Resource.
        :param pulumi.Input[_builtins.str] knowledge_base_id: Identifier for a resource.
        :param pulumi.Input['AgentKnowledgeBaseState'] knowledge_base_state: Specifies whether to use the knowledge base or not when sending an [InvokeAgent](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html) request.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "knowledge_base_id", knowledge_base_id)
        if knowledge_base_state is not None:
            pulumi.set(__self__, "knowledge_base_state", knowledge_base_state)

    @_builtins.property
    @pulumi.getter
    def description(self) -> pulumi.Input[_builtins.str]:
        """
        Description of the Resource.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="knowledgeBaseId")
    def knowledge_base_id(self) -> pulumi.Input[_builtins.str]:
        """
        Identifier for a resource.
        """
        return pulumi.get(self, "knowledge_base_id")

    @knowledge_base_id.setter
    def knowledge_base_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "knowledge_base_id", value)

    @_builtins.property
    @pulumi.getter(name="knowledgeBaseState")
    def knowledge_base_state(self) -> Optional[pulumi.Input['AgentKnowledgeBaseState']]:
        """
        Specifies whether to use the knowledge base or not when sending an [InvokeAgent](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html) request.
        """
        return pulumi.get(self, "knowledge_base_state")

    @knowledge_base_state.setter
    def knowledge_base_state(self, value: Optional[pulumi.Input['AgentKnowledgeBaseState']]):
        pulumi.set(self, "knowledge_base_state", value)


if not MYPY:
    class AgentMemoryConfigurationArgsDict(TypedDict):
        """
        Configuration for memory storage
        """
        enabled_memory_types: NotRequired[pulumi.Input[Sequence[pulumi.Input['AgentMemoryType']]]]
        """
        The type of memory that is stored.
        """
        session_summary_configuration: NotRequired[pulumi.Input['AgentSessionSummaryConfigurationArgsDict']]
        """
        Contains the configuration for SESSION_SUMMARY memory type enabled for the agent.
        """
        storage_days: NotRequired[pulumi.Input[_builtins.float]]
        """
        Maximum number of days to store session details
        """
elif False:
    AgentMemoryConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentMemoryConfigurationArgs:
    def __init__(__self__, *,
                 enabled_memory_types: Optional[pulumi.Input[Sequence[pulumi.Input['AgentMemoryType']]]] = None,
                 session_summary_configuration: Optional[pulumi.Input['AgentSessionSummaryConfigurationArgs']] = None,
                 storage_days: Optional[pulumi.Input[_builtins.float]] = None):
        """
        Configuration for memory storage
        :param pulumi.Input[Sequence[pulumi.Input['AgentMemoryType']]] enabled_memory_types: The type of memory that is stored.
        :param pulumi.Input['AgentSessionSummaryConfigurationArgs'] session_summary_configuration: Contains the configuration for SESSION_SUMMARY memory type enabled for the agent.
        :param pulumi.Input[_builtins.float] storage_days: Maximum number of days to store session details
        """
        if enabled_memory_types is not None:
            pulumi.set(__self__, "enabled_memory_types", enabled_memory_types)
        if session_summary_configuration is not None:
            pulumi.set(__self__, "session_summary_configuration", session_summary_configuration)
        if storage_days is not None:
            pulumi.set(__self__, "storage_days", storage_days)

    @_builtins.property
    @pulumi.getter(name="enabledMemoryTypes")
    def enabled_memory_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AgentMemoryType']]]]:
        """
        The type of memory that is stored.
        """
        return pulumi.get(self, "enabled_memory_types")

    @enabled_memory_types.setter
    def enabled_memory_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AgentMemoryType']]]]):
        pulumi.set(self, "enabled_memory_types", value)

    @_builtins.property
    @pulumi.getter(name="sessionSummaryConfiguration")
    def session_summary_configuration(self) -> Optional[pulumi.Input['AgentSessionSummaryConfigurationArgs']]:
        """
        Contains the configuration for SESSION_SUMMARY memory type enabled for the agent.
        """
        return pulumi.get(self, "session_summary_configuration")

    @session_summary_configuration.setter
    def session_summary_configuration(self, value: Optional[pulumi.Input['AgentSessionSummaryConfigurationArgs']]):
        pulumi.set(self, "session_summary_configuration", value)

    @_builtins.property
    @pulumi.getter(name="storageDays")
    def storage_days(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Maximum number of days to store session details
        """
        return pulumi.get(self, "storage_days")

    @storage_days.setter
    def storage_days(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "storage_days", value)


if not MYPY:
    class AgentOrchestrationExecutorArgsDict(TypedDict):
        """
        Types of executors for custom orchestration strategy
        """
        lambda_: pulumi.Input[_builtins.str]
        """
        ARN of a Lambda.
        """
elif False:
    AgentOrchestrationExecutorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentOrchestrationExecutorArgs:
    def __init__(__self__, *,
                 lambda_: pulumi.Input[_builtins.str]):
        """
        Types of executors for custom orchestration strategy
        :param pulumi.Input[_builtins.str] lambda_: ARN of a Lambda.
        """
        pulumi.set(__self__, "lambda_", lambda_)

    @_builtins.property
    @pulumi.getter(name="lambda")
    def lambda_(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of a Lambda.
        """
        return pulumi.get(self, "lambda_")

    @lambda_.setter
    def lambda_(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "lambda_", value)


if not MYPY:
    class AgentParameterDetailArgsDict(TypedDict):
        """
        Parameter detail
        """
        type: pulumi.Input['AgentType']
        """
        The data type of the parameter.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of function parameter.
        """
        required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Information about if a parameter is required for function call. Default to false.
        """
elif False:
    AgentParameterDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentParameterDetailArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['AgentType'],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 required: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        Parameter detail
        :param pulumi.Input['AgentType'] type: The data type of the parameter.
        :param pulumi.Input[_builtins.str] description: Description of function parameter.
        :param pulumi.Input[_builtins.bool] required: Information about if a parameter is required for function call. Default to false.
        """
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['AgentType']:
        """
        The data type of the parameter.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['AgentType']):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of function parameter.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Information about if a parameter is required for function call. Default to false.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "required", value)


if not MYPY:
    class AgentPromptConfigurationArgsDict(TypedDict):
        """
        BasePromptConfiguration per Prompt Type.
        """
        additional_model_request_fields: NotRequired[pulumi.Input['AgentAdditionalModelRequestFieldsArgsDict']]
        """
        If the Converse or ConverseStream operations support the model, `additionalModelRequestFields` contains additional inference parameters, beyond the base set of inference parameters in the `inferenceConfiguration` field.

        For more information, see [Inference request parameters and response fields for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html) .
        """
        base_prompt_template: NotRequired[pulumi.Input[_builtins.str]]
        """
        Base Prompt Template.
        """
        foundation_model: NotRequired[pulumi.Input[_builtins.str]]
        """
        The agent's foundation model.
        """
        inference_configuration: NotRequired[pulumi.Input['AgentInferenceConfigurationArgsDict']]
        """
        Contains inference parameters to use when the agent invokes a foundation model in the part of the agent sequence defined by the `promptType` . For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html) .
        """
        parser_mode: NotRequired[pulumi.Input['AgentCreationMode']]
        """
        Specifies whether to override the default parser Lambda function when parsing the raw foundation model output in the part of the agent sequence defined by the `promptType` . If you set the field as `OVERRIDDEN` , the `overrideLambda` field in the [PromptOverrideConfiguration](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PromptOverrideConfiguration.html) must be specified with the ARN of a Lambda function.
        """
        prompt_creation_mode: NotRequired[pulumi.Input['AgentCreationMode']]
        """
        Specifies whether to override the default prompt template for this `promptType` . Set this value to `OVERRIDDEN` to use the prompt that you provide in the `basePromptTemplate` . If you leave it as `DEFAULT` , the agent uses a default prompt template.
        """
        prompt_state: NotRequired[pulumi.Input['AgentPromptState']]
        """
        Specifies whether to allow the inline agent to carry out the step specified in the `promptType` . If you set this value to `DISABLED` , the agent skips that step. The default state for each `promptType` is as follows.

        - `PRE_PROCESSING`  `ENABLED`
        - `ORCHESTRATION`  `ENABLED`
        - `KNOWLEDGE_BASE_RESPONSE_GENERATION`  `ENABLED`
        - `POST_PROCESSING`  `DISABLED`
        """
        prompt_type: NotRequired[pulumi.Input['AgentPromptType']]
        """
        The step in the agent sequence that this prompt configuration applies to.
        """
elif False:
    AgentPromptConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptConfigurationArgs:
    def __init__(__self__, *,
                 additional_model_request_fields: Optional[pulumi.Input['AgentAdditionalModelRequestFieldsArgs']] = None,
                 base_prompt_template: Optional[pulumi.Input[_builtins.str]] = None,
                 foundation_model: Optional[pulumi.Input[_builtins.str]] = None,
                 inference_configuration: Optional[pulumi.Input['AgentInferenceConfigurationArgs']] = None,
                 parser_mode: Optional[pulumi.Input['AgentCreationMode']] = None,
                 prompt_creation_mode: Optional[pulumi.Input['AgentCreationMode']] = None,
                 prompt_state: Optional[pulumi.Input['AgentPromptState']] = None,
                 prompt_type: Optional[pulumi.Input['AgentPromptType']] = None):
        """
        BasePromptConfiguration per Prompt Type.
        :param pulumi.Input['AgentAdditionalModelRequestFieldsArgs'] additional_model_request_fields: If the Converse or ConverseStream operations support the model, `additionalModelRequestFields` contains additional inference parameters, beyond the base set of inference parameters in the `inferenceConfiguration` field.
               
               For more information, see [Inference request parameters and response fields for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html) .
        :param pulumi.Input[_builtins.str] base_prompt_template: Base Prompt Template.
        :param pulumi.Input[_builtins.str] foundation_model: The agent's foundation model.
        :param pulumi.Input['AgentInferenceConfigurationArgs'] inference_configuration: Contains inference parameters to use when the agent invokes a foundation model in the part of the agent sequence defined by the `promptType` . For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html) .
        :param pulumi.Input['AgentCreationMode'] parser_mode: Specifies whether to override the default parser Lambda function when parsing the raw foundation model output in the part of the agent sequence defined by the `promptType` . If you set the field as `OVERRIDDEN` , the `overrideLambda` field in the [PromptOverrideConfiguration](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PromptOverrideConfiguration.html) must be specified with the ARN of a Lambda function.
        :param pulumi.Input['AgentCreationMode'] prompt_creation_mode: Specifies whether to override the default prompt template for this `promptType` . Set this value to `OVERRIDDEN` to use the prompt that you provide in the `basePromptTemplate` . If you leave it as `DEFAULT` , the agent uses a default prompt template.
        :param pulumi.Input['AgentPromptState'] prompt_state: Specifies whether to allow the inline agent to carry out the step specified in the `promptType` . If you set this value to `DISABLED` , the agent skips that step. The default state for each `promptType` is as follows.
               
               - `PRE_PROCESSING`  `ENABLED`
               - `ORCHESTRATION`  `ENABLED`
               - `KNOWLEDGE_BASE_RESPONSE_GENERATION`  `ENABLED`
               - `POST_PROCESSING`  `DISABLED`
        :param pulumi.Input['AgentPromptType'] prompt_type: The step in the agent sequence that this prompt configuration applies to.
        """
        if additional_model_request_fields is not None:
            pulumi.set(__self__, "additional_model_request_fields", additional_model_request_fields)
        if base_prompt_template is not None:
            pulumi.set(__self__, "base_prompt_template", base_prompt_template)
        if foundation_model is not None:
            pulumi.set(__self__, "foundation_model", foundation_model)
        if inference_configuration is not None:
            pulumi.set(__self__, "inference_configuration", inference_configuration)
        if parser_mode is not None:
            pulumi.set(__self__, "parser_mode", parser_mode)
        if prompt_creation_mode is not None:
            pulumi.set(__self__, "prompt_creation_mode", prompt_creation_mode)
        if prompt_state is not None:
            pulumi.set(__self__, "prompt_state", prompt_state)
        if prompt_type is not None:
            pulumi.set(__self__, "prompt_type", prompt_type)

    @_builtins.property
    @pulumi.getter(name="additionalModelRequestFields")
    def additional_model_request_fields(self) -> Optional[pulumi.Input['AgentAdditionalModelRequestFieldsArgs']]:
        """
        If the Converse or ConverseStream operations support the model, `additionalModelRequestFields` contains additional inference parameters, beyond the base set of inference parameters in the `inferenceConfiguration` field.

        For more information, see [Inference request parameters and response fields for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html) .
        """
        return pulumi.get(self, "additional_model_request_fields")

    @additional_model_request_fields.setter
    def additional_model_request_fields(self, value: Optional[pulumi.Input['AgentAdditionalModelRequestFieldsArgs']]):
        pulumi.set(self, "additional_model_request_fields", value)

    @_builtins.property
    @pulumi.getter(name="basePromptTemplate")
    def base_prompt_template(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Base Prompt Template.
        """
        return pulumi.get(self, "base_prompt_template")

    @base_prompt_template.setter
    def base_prompt_template(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "base_prompt_template", value)

    @_builtins.property
    @pulumi.getter(name="foundationModel")
    def foundation_model(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The agent's foundation model.
        """
        return pulumi.get(self, "foundation_model")

    @foundation_model.setter
    def foundation_model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "foundation_model", value)

    @_builtins.property
    @pulumi.getter(name="inferenceConfiguration")
    def inference_configuration(self) -> Optional[pulumi.Input['AgentInferenceConfigurationArgs']]:
        """
        Contains inference parameters to use when the agent invokes a foundation model in the part of the agent sequence defined by the `promptType` . For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html) .
        """
        return pulumi.get(self, "inference_configuration")

    @inference_configuration.setter
    def inference_configuration(self, value: Optional[pulumi.Input['AgentInferenceConfigurationArgs']]):
        pulumi.set(self, "inference_configuration", value)

    @_builtins.property
    @pulumi.getter(name="parserMode")
    def parser_mode(self) -> Optional[pulumi.Input['AgentCreationMode']]:
        """
        Specifies whether to override the default parser Lambda function when parsing the raw foundation model output in the part of the agent sequence defined by the `promptType` . If you set the field as `OVERRIDDEN` , the `overrideLambda` field in the [PromptOverrideConfiguration](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PromptOverrideConfiguration.html) must be specified with the ARN of a Lambda function.
        """
        return pulumi.get(self, "parser_mode")

    @parser_mode.setter
    def parser_mode(self, value: Optional[pulumi.Input['AgentCreationMode']]):
        pulumi.set(self, "parser_mode", value)

    @_builtins.property
    @pulumi.getter(name="promptCreationMode")
    def prompt_creation_mode(self) -> Optional[pulumi.Input['AgentCreationMode']]:
        """
        Specifies whether to override the default prompt template for this `promptType` . Set this value to `OVERRIDDEN` to use the prompt that you provide in the `basePromptTemplate` . If you leave it as `DEFAULT` , the agent uses a default prompt template.
        """
        return pulumi.get(self, "prompt_creation_mode")

    @prompt_creation_mode.setter
    def prompt_creation_mode(self, value: Optional[pulumi.Input['AgentCreationMode']]):
        pulumi.set(self, "prompt_creation_mode", value)

    @_builtins.property
    @pulumi.getter(name="promptState")
    def prompt_state(self) -> Optional[pulumi.Input['AgentPromptState']]:
        """
        Specifies whether to allow the inline agent to carry out the step specified in the `promptType` . If you set this value to `DISABLED` , the agent skips that step. The default state for each `promptType` is as follows.

        - `PRE_PROCESSING`  `ENABLED`
        - `ORCHESTRATION`  `ENABLED`
        - `KNOWLEDGE_BASE_RESPONSE_GENERATION`  `ENABLED`
        - `POST_PROCESSING`  `DISABLED`
        """
        return pulumi.get(self, "prompt_state")

    @prompt_state.setter
    def prompt_state(self, value: Optional[pulumi.Input['AgentPromptState']]):
        pulumi.set(self, "prompt_state", value)

    @_builtins.property
    @pulumi.getter(name="promptType")
    def prompt_type(self) -> Optional[pulumi.Input['AgentPromptType']]:
        """
        The step in the agent sequence that this prompt configuration applies to.
        """
        return pulumi.get(self, "prompt_type")

    @prompt_type.setter
    def prompt_type(self, value: Optional[pulumi.Input['AgentPromptType']]):
        pulumi.set(self, "prompt_type", value)


if not MYPY:
    class AgentPromptOverrideConfigurationArgsDict(TypedDict):
        """
        Configuration for prompt override.
        """
        prompt_configurations: pulumi.Input[Sequence[pulumi.Input['AgentPromptConfigurationArgsDict']]]
        """
        List of BasePromptConfiguration
        """
        override_lambda: NotRequired[pulumi.Input[_builtins.str]]
        """
        ARN of a Lambda.
        """
elif False:
    AgentPromptOverrideConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentPromptOverrideConfigurationArgs:
    def __init__(__self__, *,
                 prompt_configurations: pulumi.Input[Sequence[pulumi.Input['AgentPromptConfigurationArgs']]],
                 override_lambda: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Configuration for prompt override.
        :param pulumi.Input[Sequence[pulumi.Input['AgentPromptConfigurationArgs']]] prompt_configurations: List of BasePromptConfiguration
        :param pulumi.Input[_builtins.str] override_lambda: ARN of a Lambda.
        """
        pulumi.set(__self__, "prompt_configurations", prompt_configurations)
        if override_lambda is not None:
            pulumi.set(__self__, "override_lambda", override_lambda)

    @_builtins.property
    @pulumi.getter(name="promptConfigurations")
    def prompt_configurations(self) -> pulumi.Input[Sequence[pulumi.Input['AgentPromptConfigurationArgs']]]:
        """
        List of BasePromptConfiguration
        """
        return pulumi.get(self, "prompt_configurations")

    @prompt_configurations.setter
    def prompt_configurations(self, value: pulumi.Input[Sequence[pulumi.Input['AgentPromptConfigurationArgs']]]):
        pulumi.set(self, "prompt_configurations", value)

    @_builtins.property
    @pulumi.getter(name="overrideLambda")
    def override_lambda(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ARN of a Lambda.
        """
        return pulumi.get(self, "override_lambda")

    @override_lambda.setter
    def override_lambda(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "override_lambda", value)


if not MYPY:
    class AgentS3IdentifierArgsDict(TypedDict):
        """
        The identifier for the S3 resource.
        """
        s3_bucket_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A bucket in S3.
        """
        s3_object_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        A object key in S3.
        """
elif False:
    AgentS3IdentifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentS3IdentifierArgs:
    def __init__(__self__, *,
                 s3_bucket_name: Optional[pulumi.Input[_builtins.str]] = None,
                 s3_object_key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The identifier for the S3 resource.
        :param pulumi.Input[_builtins.str] s3_bucket_name: A bucket in S3.
        :param pulumi.Input[_builtins.str] s3_object_key: A object key in S3.
        """
        if s3_bucket_name is not None:
            pulumi.set(__self__, "s3_bucket_name", s3_bucket_name)
        if s3_object_key is not None:
            pulumi.set(__self__, "s3_object_key", s3_object_key)

    @_builtins.property
    @pulumi.getter(name="s3BucketName")
    def s3_bucket_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A bucket in S3.
        """
        return pulumi.get(self, "s3_bucket_name")

    @s3_bucket_name.setter
    def s3_bucket_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "s3_bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="s3ObjectKey")
    def s3_object_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A object key in S3.
        """
        return pulumi.get(self, "s3_object_key")

    @s3_object_key.setter
    def s3_object_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "s3_object_key", value)


if not MYPY:
    class AgentSessionSummaryConfigurationArgsDict(TypedDict):
        """
        Configuration for Session Summarization
        """
        max_recent_sessions: NotRequired[pulumi.Input[_builtins.float]]
        """
        Maximum number of Sessions to Summarize
        """
elif False:
    AgentSessionSummaryConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentSessionSummaryConfigurationArgs:
    def __init__(__self__, *,
                 max_recent_sessions: Optional[pulumi.Input[_builtins.float]] = None):
        """
        Configuration for Session Summarization
        :param pulumi.Input[_builtins.float] max_recent_sessions: Maximum number of Sessions to Summarize
        """
        if max_recent_sessions is not None:
            pulumi.set(__self__, "max_recent_sessions", max_recent_sessions)

    @_builtins.property
    @pulumi.getter(name="maxRecentSessions")
    def max_recent_sessions(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Maximum number of Sessions to Summarize
        """
        return pulumi.get(self, "max_recent_sessions")

    @max_recent_sessions.setter
    def max_recent_sessions(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "max_recent_sessions", value)


if not MYPY:
    class ApplicationInferenceProfileInferenceProfileModelSourcePropertiesArgsDict(TypedDict):
        """
        Various ways to encode a list of models in a CreateInferenceProfile request
        """
        copy_from: pulumi.Input[_builtins.str]
        """
        Source arns for a custom inference profile to copy its regional load balancing config from. This
        can either be a foundation model or predefined inference profile ARN.
        """
elif False:
    ApplicationInferenceProfileInferenceProfileModelSourcePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApplicationInferenceProfileInferenceProfileModelSourcePropertiesArgs:
    def __init__(__self__, *,
                 copy_from: pulumi.Input[_builtins.str]):
        """
        Various ways to encode a list of models in a CreateInferenceProfile request
        :param pulumi.Input[_builtins.str] copy_from: Source arns for a custom inference profile to copy its regional load balancing config from. This
               can either be a foundation model or predefined inference profile ARN.
        """
        pulumi.set(__self__, "copy_from", copy_from)

    @_builtins.property
    @pulumi.getter(name="copyFrom")
    def copy_from(self) -> pulumi.Input[_builtins.str]:
        """
        Source arns for a custom inference profile to copy its regional load balancing config from. This
        can either be a foundation model or predefined inference profile ARN.
        """
        return pulumi.get(self, "copy_from")

    @copy_from.setter
    def copy_from(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "copy_from", value)


if not MYPY:
    class AutomatedReasoningPolicyPolicyDefinitionRuleArgsDict(TypedDict):
        expression: pulumi.Input[_builtins.str]
        """
        The SMT expression for this rule
        """
        id: pulumi.Input[_builtins.str]
        """
        A unique id within the PolicyDefinition
        """
        alternate_expression: NotRequired[pulumi.Input[_builtins.str]]
        """
        An alternate expression for this rule
        """
elif False:
    AutomatedReasoningPolicyPolicyDefinitionRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomatedReasoningPolicyPolicyDefinitionRuleArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[_builtins.str],
                 id: pulumi.Input[_builtins.str],
                 alternate_expression: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] expression: The SMT expression for this rule
        :param pulumi.Input[_builtins.str] id: A unique id within the PolicyDefinition
        :param pulumi.Input[_builtins.str] alternate_expression: An alternate expression for this rule
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "id", id)
        if alternate_expression is not None:
            pulumi.set(__self__, "alternate_expression", alternate_expression)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> pulumi.Input[_builtins.str]:
        """
        The SMT expression for this rule
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        A unique id within the PolicyDefinition
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="alternateExpression")
    def alternate_expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An alternate expression for this rule
        """
        return pulumi.get(self, "alternate_expression")

    @alternate_expression.setter
    def alternate_expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "alternate_expression", value)


if not MYPY:
    class AutomatedReasoningPolicyPolicyDefinitionTypeValueArgsDict(TypedDict):
        value: pulumi.Input[_builtins.str]
        """
        The value of the type value.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A natural language description of the type's value.
        """
elif False:
    AutomatedReasoningPolicyPolicyDefinitionTypeValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomatedReasoningPolicyPolicyDefinitionTypeValueArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] value: The value of the type value.
        :param pulumi.Input[_builtins.str] description: A natural language description of the type's value.
        """
        pulumi.set(__self__, "value", value)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        The value of the type value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A natural language description of the type's value.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class AutomatedReasoningPolicyPolicyDefinitionTypeArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A name for this type.
        """
        values: pulumi.Input[Sequence[pulumi.Input['AutomatedReasoningPolicyPolicyDefinitionTypeValueArgsDict']]]
        """
        A list of valid values for this type.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A natural language description of this type.
        """
elif False:
    AutomatedReasoningPolicyPolicyDefinitionTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomatedReasoningPolicyPolicyDefinitionTypeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input['AutomatedReasoningPolicyPolicyDefinitionTypeValueArgs']]],
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A name for this type.
        :param pulumi.Input[Sequence[pulumi.Input['AutomatedReasoningPolicyPolicyDefinitionTypeValueArgs']]] values: A list of valid values for this type.
        :param pulumi.Input[_builtins.str] description: A natural language description of this type.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A name for this type.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input['AutomatedReasoningPolicyPolicyDefinitionTypeValueArgs']]]:
        """
        A list of valid values for this type.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input['AutomatedReasoningPolicyPolicyDefinitionTypeValueArgs']]]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A natural language description of this type.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class AutomatedReasoningPolicyPolicyDefinitionVariableArgsDict(TypedDict):
        description: pulumi.Input[_builtins.str]
        """
        A natural language description of this variable.
        """
        name: pulumi.Input[_builtins.str]
        """
        A name from this variable.
        """
        type: pulumi.Input[_builtins.str]
        """
        A type for this variable.
        """
elif False:
    AutomatedReasoningPolicyPolicyDefinitionVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomatedReasoningPolicyPolicyDefinitionVariableArgs:
    def __init__(__self__, *,
                 description: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] description: A natural language description of this variable.
        :param pulumi.Input[_builtins.str] name: A name from this variable.
        :param pulumi.Input[_builtins.str] type: A type for this variable.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def description(self) -> pulumi.Input[_builtins.str]:
        """
        A natural language description of this variable.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A name from this variable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        A type for this variable.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AutomatedReasoningPolicyPolicyDefinitionArgsDict(TypedDict):
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['AutomatedReasoningPolicyPolicyDefinitionRuleArgsDict']]]]
        """
        The rules definition block of an AutomatedReasoningPolicyDefinition.
        """
        types: NotRequired[pulumi.Input[Sequence[pulumi.Input['AutomatedReasoningPolicyPolicyDefinitionTypeArgsDict']]]]
        """
        The types definition block of an AutomatedReasoningPolicyDefinition.
        """
        variables: NotRequired[pulumi.Input[Sequence[pulumi.Input['AutomatedReasoningPolicyPolicyDefinitionVariableArgsDict']]]]
        """
        The variables definition block of an AutomatedReasoningPolicyDefinition.
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The policy format version.
        """
elif False:
    AutomatedReasoningPolicyPolicyDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomatedReasoningPolicyPolicyDefinitionArgs:
    def __init__(__self__, *,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['AutomatedReasoningPolicyPolicyDefinitionRuleArgs']]]] = None,
                 types: Optional[pulumi.Input[Sequence[pulumi.Input['AutomatedReasoningPolicyPolicyDefinitionTypeArgs']]]] = None,
                 variables: Optional[pulumi.Input[Sequence[pulumi.Input['AutomatedReasoningPolicyPolicyDefinitionVariableArgs']]]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AutomatedReasoningPolicyPolicyDefinitionRuleArgs']]] rules: The rules definition block of an AutomatedReasoningPolicyDefinition.
        :param pulumi.Input[Sequence[pulumi.Input['AutomatedReasoningPolicyPolicyDefinitionTypeArgs']]] types: The types definition block of an AutomatedReasoningPolicyDefinition.
        :param pulumi.Input[Sequence[pulumi.Input['AutomatedReasoningPolicyPolicyDefinitionVariableArgs']]] variables: The variables definition block of an AutomatedReasoningPolicyDefinition.
        :param pulumi.Input[_builtins.str] version: The policy format version.
        """
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if types is not None:
            pulumi.set(__self__, "types", types)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutomatedReasoningPolicyPolicyDefinitionRuleArgs']]]]:
        """
        The rules definition block of an AutomatedReasoningPolicyDefinition.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutomatedReasoningPolicyPolicyDefinitionRuleArgs']]]]):
        pulumi.set(self, "rules", value)

    @_builtins.property
    @pulumi.getter
    def types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutomatedReasoningPolicyPolicyDefinitionTypeArgs']]]]:
        """
        The types definition block of an AutomatedReasoningPolicyDefinition.
        """
        return pulumi.get(self, "types")

    @types.setter
    def types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutomatedReasoningPolicyPolicyDefinitionTypeArgs']]]]):
        pulumi.set(self, "types", value)

    @_builtins.property
    @pulumi.getter
    def variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AutomatedReasoningPolicyPolicyDefinitionVariableArgs']]]]:
        """
        The variables definition block of an AutomatedReasoningPolicyDefinition.
        """
        return pulumi.get(self, "variables")

    @variables.setter
    def variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AutomatedReasoningPolicyPolicyDefinitionVariableArgs']]]]):
        pulumi.set(self, "variables", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The policy format version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class DataAutomationProjectAudioExtractionCategoryTypeConfigurationArgsDict(TypedDict):
        transcript: NotRequired[pulumi.Input['DataAutomationProjectTranscriptConfigurationArgsDict']]
        """
        This element allows you to configure different extractions for your transcript data, such as speaker and channel labeling.
        """
elif False:
    DataAutomationProjectAudioExtractionCategoryTypeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAutomationProjectAudioExtractionCategoryTypeConfigurationArgs:
    def __init__(__self__, *,
                 transcript: Optional[pulumi.Input['DataAutomationProjectTranscriptConfigurationArgs']] = None):
        """
        :param pulumi.Input['DataAutomationProjectTranscriptConfigurationArgs'] transcript: This element allows you to configure different extractions for your transcript data, such as speaker and channel labeling.
        """
        if transcript is not None:
            pulumi.set(__self__, "transcript", transcript)

    @_builtins.property
    @pulumi.getter
    def transcript(self) -> Optional[pulumi.Input['DataAutomationProjectTranscriptConfigurationArgs']]:
        """
        This element allows you to configure different extractions for your transcript data, such as speaker and channel labeling.
        """
        return pulumi.get(self, "transcript")

    @transcript.setter
    def transcript(self, value: Optional[pulumi.Input['DataAutomationProjectTranscriptConfigurationArgs']]):
        pulumi.set(self, "transcript", value)


if not MYPY:
    class DataAutomationProjectAudioExtractionCategoryArgsDict(TypedDict):
        state: pulumi.Input['DataAutomationProjectState']
        """
        Whether generating categorical data from audio is enabled.
        """
        type_configuration: NotRequired[pulumi.Input['DataAutomationProjectAudioExtractionCategoryTypeConfigurationArgsDict']]
        """
        This element contains information about extractions from different types. Used to enable speaker and channel labeling for transcripts.
        """
        types: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectAudioExtractionCategoryType']]]]
        """
        The types of data to generate.
        """
elif False:
    DataAutomationProjectAudioExtractionCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAutomationProjectAudioExtractionCategoryArgs:
    def __init__(__self__, *,
                 state: pulumi.Input['DataAutomationProjectState'],
                 type_configuration: Optional[pulumi.Input['DataAutomationProjectAudioExtractionCategoryTypeConfigurationArgs']] = None,
                 types: Optional[pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectAudioExtractionCategoryType']]]] = None):
        """
        :param pulumi.Input['DataAutomationProjectState'] state: Whether generating categorical data from audio is enabled.
        :param pulumi.Input['DataAutomationProjectAudioExtractionCategoryTypeConfigurationArgs'] type_configuration: This element contains information about extractions from different types. Used to enable speaker and channel labeling for transcripts.
        :param pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectAudioExtractionCategoryType']]] types: The types of data to generate.
        """
        pulumi.set(__self__, "state", state)
        if type_configuration is not None:
            pulumi.set(__self__, "type_configuration", type_configuration)
        if types is not None:
            pulumi.set(__self__, "types", types)

    @_builtins.property
    @pulumi.getter
    def state(self) -> pulumi.Input['DataAutomationProjectState']:
        """
        Whether generating categorical data from audio is enabled.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: pulumi.Input['DataAutomationProjectState']):
        pulumi.set(self, "state", value)

    @_builtins.property
    @pulumi.getter(name="typeConfiguration")
    def type_configuration(self) -> Optional[pulumi.Input['DataAutomationProjectAudioExtractionCategoryTypeConfigurationArgs']]:
        """
        This element contains information about extractions from different types. Used to enable speaker and channel labeling for transcripts.
        """
        return pulumi.get(self, "type_configuration")

    @type_configuration.setter
    def type_configuration(self, value: Optional[pulumi.Input['DataAutomationProjectAudioExtractionCategoryTypeConfigurationArgs']]):
        pulumi.set(self, "type_configuration", value)

    @_builtins.property
    @pulumi.getter
    def types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectAudioExtractionCategoryType']]]]:
        """
        The types of data to generate.
        """
        return pulumi.get(self, "types")

    @types.setter
    def types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectAudioExtractionCategoryType']]]]):
        pulumi.set(self, "types", value)


if not MYPY:
    class DataAutomationProjectAudioOverrideConfigurationArgsDict(TypedDict):
        modality_processing: NotRequired[pulumi.Input['DataAutomationProjectModalityProcessingConfigurationArgsDict']]
        """
        Sets modality processing for audio files. All modalities are enabled by default.
        """
elif False:
    DataAutomationProjectAudioOverrideConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAutomationProjectAudioOverrideConfigurationArgs:
    def __init__(__self__, *,
                 modality_processing: Optional[pulumi.Input['DataAutomationProjectModalityProcessingConfigurationArgs']] = None):
        """
        :param pulumi.Input['DataAutomationProjectModalityProcessingConfigurationArgs'] modality_processing: Sets modality processing for audio files. All modalities are enabled by default.
        """
        if modality_processing is not None:
            pulumi.set(__self__, "modality_processing", modality_processing)

    @_builtins.property
    @pulumi.getter(name="modalityProcessing")
    def modality_processing(self) -> Optional[pulumi.Input['DataAutomationProjectModalityProcessingConfigurationArgs']]:
        """
        Sets modality processing for audio files. All modalities are enabled by default.
        """
        return pulumi.get(self, "modality_processing")

    @modality_processing.setter
    def modality_processing(self, value: Optional[pulumi.Input['DataAutomationProjectModalityProcessingConfigurationArgs']]):
        pulumi.set(self, "modality_processing", value)


if not MYPY:
    class DataAutomationProjectAudioStandardExtractionArgsDict(TypedDict):
        category: pulumi.Input['DataAutomationProjectAudioExtractionCategoryArgsDict']
        """
        Settings for generating data from audio.
        """
elif False:
    DataAutomationProjectAudioStandardExtractionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAutomationProjectAudioStandardExtractionArgs:
    def __init__(__self__, *,
                 category: pulumi.Input['DataAutomationProjectAudioExtractionCategoryArgs']):
        """
        :param pulumi.Input['DataAutomationProjectAudioExtractionCategoryArgs'] category: Settings for generating data from audio.
        """
        pulumi.set(__self__, "category", category)

    @_builtins.property
    @pulumi.getter
    def category(self) -> pulumi.Input['DataAutomationProjectAudioExtractionCategoryArgs']:
        """
        Settings for generating data from audio.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: pulumi.Input['DataAutomationProjectAudioExtractionCategoryArgs']):
        pulumi.set(self, "category", value)


if not MYPY:
    class DataAutomationProjectAudioStandardGenerativeFieldArgsDict(TypedDict):
        state: pulumi.Input['DataAutomationProjectState']
        """
        Whether generating descriptions is enabled for audio.
        """
        types: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectAudioStandardGenerativeFieldType']]]]
        """
        The types of description to generate.
        """
elif False:
    DataAutomationProjectAudioStandardGenerativeFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAutomationProjectAudioStandardGenerativeFieldArgs:
    def __init__(__self__, *,
                 state: pulumi.Input['DataAutomationProjectState'],
                 types: Optional[pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectAudioStandardGenerativeFieldType']]]] = None):
        """
        :param pulumi.Input['DataAutomationProjectState'] state: Whether generating descriptions is enabled for audio.
        :param pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectAudioStandardGenerativeFieldType']]] types: The types of description to generate.
        """
        pulumi.set(__self__, "state", state)
        if types is not None:
            pulumi.set(__self__, "types", types)

    @_builtins.property
    @pulumi.getter
    def state(self) -> pulumi.Input['DataAutomationProjectState']:
        """
        Whether generating descriptions is enabled for audio.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: pulumi.Input['DataAutomationProjectState']):
        pulumi.set(self, "state", value)

    @_builtins.property
    @pulumi.getter
    def types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectAudioStandardGenerativeFieldType']]]]:
        """
        The types of description to generate.
        """
        return pulumi.get(self, "types")

    @types.setter
    def types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectAudioStandardGenerativeFieldType']]]]):
        pulumi.set(self, "types", value)


if not MYPY:
    class DataAutomationProjectAudioStandardOutputConfigurationArgsDict(TypedDict):
        extraction: NotRequired[pulumi.Input['DataAutomationProjectAudioStandardExtractionArgsDict']]
        """
        Settings for populating data fields that describe the audio.
        """
        generative_field: NotRequired[pulumi.Input['DataAutomationProjectAudioStandardGenerativeFieldArgsDict']]
        """
        Whether to generate descriptions of the data.
        """
elif False:
    DataAutomationProjectAudioStandardOutputConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAutomationProjectAudioStandardOutputConfigurationArgs:
    def __init__(__self__, *,
                 extraction: Optional[pulumi.Input['DataAutomationProjectAudioStandardExtractionArgs']] = None,
                 generative_field: Optional[pulumi.Input['DataAutomationProjectAudioStandardGenerativeFieldArgs']] = None):
        """
        :param pulumi.Input['DataAutomationProjectAudioStandardExtractionArgs'] extraction: Settings for populating data fields that describe the audio.
        :param pulumi.Input['DataAutomationProjectAudioStandardGenerativeFieldArgs'] generative_field: Whether to generate descriptions of the data.
        """
        if extraction is not None:
            pulumi.set(__self__, "extraction", extraction)
        if generative_field is not None:
            pulumi.set(__self__, "generative_field", generative_field)

    @_builtins.property
    @pulumi.getter
    def extraction(self) -> Optional[pulumi.Input['DataAutomationProjectAudioStandardExtractionArgs']]:
        """
        Settings for populating data fields that describe the audio.
        """
        return pulumi.get(self, "extraction")

    @extraction.setter
    def extraction(self, value: Optional[pulumi.Input['DataAutomationProjectAudioStandardExtractionArgs']]):
        pulumi.set(self, "extraction", value)

    @_builtins.property
    @pulumi.getter(name="generativeField")
    def generative_field(self) -> Optional[pulumi.Input['DataAutomationProjectAudioStandardGenerativeFieldArgs']]:
        """
        Whether to generate descriptions of the data.
        """
        return pulumi.get(self, "generative_field")

    @generative_field.setter
    def generative_field(self, value: Optional[pulumi.Input['DataAutomationProjectAudioStandardGenerativeFieldArgs']]):
        pulumi.set(self, "generative_field", value)


if not MYPY:
    class DataAutomationProjectBlueprintItemArgsDict(TypedDict):
        blueprint_arn: pulumi.Input[_builtins.str]
        """
        ARN of a Blueprint
        """
        blueprint_stage: NotRequired[pulumi.Input['DataAutomationProjectBlueprintStage']]
        """
        The blueprint's stage.
        """
        blueprint_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Blueprint Version
        """
elif False:
    DataAutomationProjectBlueprintItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAutomationProjectBlueprintItemArgs:
    def __init__(__self__, *,
                 blueprint_arn: pulumi.Input[_builtins.str],
                 blueprint_stage: Optional[pulumi.Input['DataAutomationProjectBlueprintStage']] = None,
                 blueprint_version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] blueprint_arn: ARN of a Blueprint
        :param pulumi.Input['DataAutomationProjectBlueprintStage'] blueprint_stage: The blueprint's stage.
        :param pulumi.Input[_builtins.str] blueprint_version: Blueprint Version
        """
        pulumi.set(__self__, "blueprint_arn", blueprint_arn)
        if blueprint_stage is not None:
            pulumi.set(__self__, "blueprint_stage", blueprint_stage)
        if blueprint_version is not None:
            pulumi.set(__self__, "blueprint_version", blueprint_version)

    @_builtins.property
    @pulumi.getter(name="blueprintArn")
    def blueprint_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of a Blueprint
        """
        return pulumi.get(self, "blueprint_arn")

    @blueprint_arn.setter
    def blueprint_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "blueprint_arn", value)

    @_builtins.property
    @pulumi.getter(name="blueprintStage")
    def blueprint_stage(self) -> Optional[pulumi.Input['DataAutomationProjectBlueprintStage']]:
        """
        The blueprint's stage.
        """
        return pulumi.get(self, "blueprint_stage")

    @blueprint_stage.setter
    def blueprint_stage(self, value: Optional[pulumi.Input['DataAutomationProjectBlueprintStage']]):
        pulumi.set(self, "blueprint_stage", value)

    @_builtins.property
    @pulumi.getter(name="blueprintVersion")
    def blueprint_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Blueprint Version
        """
        return pulumi.get(self, "blueprint_version")

    @blueprint_version.setter
    def blueprint_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "blueprint_version", value)


if not MYPY:
    class DataAutomationProjectChannelLabelingConfigurationArgsDict(TypedDict):
        state: pulumi.Input['DataAutomationProjectState']
        """
        State of channel labeling, either enabled or disabled.
        """
elif False:
    DataAutomationProjectChannelLabelingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAutomationProjectChannelLabelingConfigurationArgs:
    def __init__(__self__, *,
                 state: pulumi.Input['DataAutomationProjectState']):
        """
        :param pulumi.Input['DataAutomationProjectState'] state: State of channel labeling, either enabled or disabled.
        """
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> pulumi.Input['DataAutomationProjectState']:
        """
        State of channel labeling, either enabled or disabled.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: pulumi.Input['DataAutomationProjectState']):
        pulumi.set(self, "state", value)


if not MYPY:
    class DataAutomationProjectCustomOutputConfigurationArgsDict(TypedDict):
        """
        Custom output configuration
        """
        blueprints: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectBlueprintItemArgsDict']]]]
        """
        A list of blueprints.
        """
elif False:
    DataAutomationProjectCustomOutputConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAutomationProjectCustomOutputConfigurationArgs:
    def __init__(__self__, *,
                 blueprints: Optional[pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectBlueprintItemArgs']]]] = None):
        """
        Custom output configuration
        :param pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectBlueprintItemArgs']]] blueprints: A list of blueprints.
        """
        if blueprints is not None:
            pulumi.set(__self__, "blueprints", blueprints)

    @_builtins.property
    @pulumi.getter
    def blueprints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectBlueprintItemArgs']]]]:
        """
        A list of blueprints.
        """
        return pulumi.get(self, "blueprints")

    @blueprints.setter
    def blueprints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectBlueprintItemArgs']]]]):
        pulumi.set(self, "blueprints", value)


if not MYPY:
    class DataAutomationProjectDocumentBoundingBoxArgsDict(TypedDict):
        state: pulumi.Input['DataAutomationProjectState']
        """
        Whether bounding boxes are enabled for documents.
        """
elif False:
    DataAutomationProjectDocumentBoundingBoxArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAutomationProjectDocumentBoundingBoxArgs:
    def __init__(__self__, *,
                 state: pulumi.Input['DataAutomationProjectState']):
        """
        :param pulumi.Input['DataAutomationProjectState'] state: Whether bounding boxes are enabled for documents.
        """
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> pulumi.Input['DataAutomationProjectState']:
        """
        Whether bounding boxes are enabled for documents.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: pulumi.Input['DataAutomationProjectState']):
        pulumi.set(self, "state", value)


if not MYPY:
    class DataAutomationProjectDocumentExtractionGranularityArgsDict(TypedDict):
        types: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectDocumentExtractionGranularityType']]]]
        """
        Granularity settings for documents.
        """
elif False:
    DataAutomationProjectDocumentExtractionGranularityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAutomationProjectDocumentExtractionGranularityArgs:
    def __init__(__self__, *,
                 types: Optional[pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectDocumentExtractionGranularityType']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectDocumentExtractionGranularityType']]] types: Granularity settings for documents.
        """
        if types is not None:
            pulumi.set(__self__, "types", types)

    @_builtins.property
    @pulumi.getter
    def types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectDocumentExtractionGranularityType']]]]:
        """
        Granularity settings for documents.
        """
        return pulumi.get(self, "types")

    @types.setter
    def types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectDocumentExtractionGranularityType']]]]):
        pulumi.set(self, "types", value)


if not MYPY:
    class DataAutomationProjectDocumentOutputAdditionalFileFormatArgsDict(TypedDict):
        state: pulumi.Input['DataAutomationProjectState']
        """
        Whether additional file formats are enabled for a project.
        """
elif False:
    DataAutomationProjectDocumentOutputAdditionalFileFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAutomationProjectDocumentOutputAdditionalFileFormatArgs:
    def __init__(__self__, *,
                 state: pulumi.Input['DataAutomationProjectState']):
        """
        :param pulumi.Input['DataAutomationProjectState'] state: Whether additional file formats are enabled for a project.
        """
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> pulumi.Input['DataAutomationProjectState']:
        """
        Whether additional file formats are enabled for a project.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: pulumi.Input['DataAutomationProjectState']):
        pulumi.set(self, "state", value)


if not MYPY:
    class DataAutomationProjectDocumentOutputFormatArgsDict(TypedDict):
        additional_file_format: pulumi.Input['DataAutomationProjectDocumentOutputAdditionalFileFormatArgsDict']
        """
        Output settings for additional file formats.
        """
        text_format: pulumi.Input['DataAutomationProjectDocumentOutputTextFormatArgsDict']
        """
        An output text format.
        """
elif False:
    DataAutomationProjectDocumentOutputFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAutomationProjectDocumentOutputFormatArgs:
    def __init__(__self__, *,
                 additional_file_format: pulumi.Input['DataAutomationProjectDocumentOutputAdditionalFileFormatArgs'],
                 text_format: pulumi.Input['DataAutomationProjectDocumentOutputTextFormatArgs']):
        """
        :param pulumi.Input['DataAutomationProjectDocumentOutputAdditionalFileFormatArgs'] additional_file_format: Output settings for additional file formats.
        :param pulumi.Input['DataAutomationProjectDocumentOutputTextFormatArgs'] text_format: An output text format.
        """
        pulumi.set(__self__, "additional_file_format", additional_file_format)
        pulumi.set(__self__, "text_format", text_format)

    @_builtins.property
    @pulumi.getter(name="additionalFileFormat")
    def additional_file_format(self) -> pulumi.Input['DataAutomationProjectDocumentOutputAdditionalFileFormatArgs']:
        """
        Output settings for additional file formats.
        """
        return pulumi.get(self, "additional_file_format")

    @additional_file_format.setter
    def additional_file_format(self, value: pulumi.Input['DataAutomationProjectDocumentOutputAdditionalFileFormatArgs']):
        pulumi.set(self, "additional_file_format", value)

    @_builtins.property
    @pulumi.getter(name="textFormat")
    def text_format(self) -> pulumi.Input['DataAutomationProjectDocumentOutputTextFormatArgs']:
        """
        An output text format.
        """
        return pulumi.get(self, "text_format")

    @text_format.setter
    def text_format(self, value: pulumi.Input['DataAutomationProjectDocumentOutputTextFormatArgs']):
        pulumi.set(self, "text_format", value)


if not MYPY:
    class DataAutomationProjectDocumentOutputTextFormatArgsDict(TypedDict):
        types: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectDocumentOutputTextFormatType']]]]
        """
        The types of output text to generate.
        """
elif False:
    DataAutomationProjectDocumentOutputTextFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAutomationProjectDocumentOutputTextFormatArgs:
    def __init__(__self__, *,
                 types: Optional[pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectDocumentOutputTextFormatType']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectDocumentOutputTextFormatType']]] types: The types of output text to generate.
        """
        if types is not None:
            pulumi.set(__self__, "types", types)

    @_builtins.property
    @pulumi.getter
    def types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectDocumentOutputTextFormatType']]]]:
        """
        The types of output text to generate.
        """
        return pulumi.get(self, "types")

    @types.setter
    def types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectDocumentOutputTextFormatType']]]]):
        pulumi.set(self, "types", value)


if not MYPY:
    class DataAutomationProjectDocumentOverrideConfigurationArgsDict(TypedDict):
        modality_processing: NotRequired[pulumi.Input['DataAutomationProjectModalityProcessingConfigurationArgsDict']]
        """
        Sets modality processing for document files. All modalities are enabled by default.
        """
        splitter: NotRequired[pulumi.Input['DataAutomationProjectSplitterConfigurationArgsDict']]
        """
        Whether document splitter is enabled for a project.
        """
elif False:
    DataAutomationProjectDocumentOverrideConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAutomationProjectDocumentOverrideConfigurationArgs:
    def __init__(__self__, *,
                 modality_processing: Optional[pulumi.Input['DataAutomationProjectModalityProcessingConfigurationArgs']] = None,
                 splitter: Optional[pulumi.Input['DataAutomationProjectSplitterConfigurationArgs']] = None):
        """
        :param pulumi.Input['DataAutomationProjectModalityProcessingConfigurationArgs'] modality_processing: Sets modality processing for document files. All modalities are enabled by default.
        :param pulumi.Input['DataAutomationProjectSplitterConfigurationArgs'] splitter: Whether document splitter is enabled for a project.
        """
        if modality_processing is not None:
            pulumi.set(__self__, "modality_processing", modality_processing)
        if splitter is not None:
            pulumi.set(__self__, "splitter", splitter)

    @_builtins.property
    @pulumi.getter(name="modalityProcessing")
    def modality_processing(self) -> Optional[pulumi.Input['DataAutomationProjectModalityProcessingConfigurationArgs']]:
        """
        Sets modality processing for document files. All modalities are enabled by default.
        """
        return pulumi.get(self, "modality_processing")

    @modality_processing.setter
    def modality_processing(self, value: Optional[pulumi.Input['DataAutomationProjectModalityProcessingConfigurationArgs']]):
        pulumi.set(self, "modality_processing", value)

    @_builtins.property
    @pulumi.getter
    def splitter(self) -> Optional[pulumi.Input['DataAutomationProjectSplitterConfigurationArgs']]:
        """
        Whether document splitter is enabled for a project.
        """
        return pulumi.get(self, "splitter")

    @splitter.setter
    def splitter(self, value: Optional[pulumi.Input['DataAutomationProjectSplitterConfigurationArgs']]):
        pulumi.set(self, "splitter", value)


if not MYPY:
    class DataAutomationProjectDocumentStandardExtractionArgsDict(TypedDict):
        bounding_box: pulumi.Input['DataAutomationProjectDocumentBoundingBoxArgsDict']
        """
        Whether to generate bounding boxes.
        """
        granularity: pulumi.Input['DataAutomationProjectDocumentExtractionGranularityArgsDict']
        """
        Which granularities to generate data for.
        """
elif False:
    DataAutomationProjectDocumentStandardExtractionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAutomationProjectDocumentStandardExtractionArgs:
    def __init__(__self__, *,
                 bounding_box: pulumi.Input['DataAutomationProjectDocumentBoundingBoxArgs'],
                 granularity: pulumi.Input['DataAutomationProjectDocumentExtractionGranularityArgs']):
        """
        :param pulumi.Input['DataAutomationProjectDocumentBoundingBoxArgs'] bounding_box: Whether to generate bounding boxes.
        :param pulumi.Input['DataAutomationProjectDocumentExtractionGranularityArgs'] granularity: Which granularities to generate data for.
        """
        pulumi.set(__self__, "bounding_box", bounding_box)
        pulumi.set(__self__, "granularity", granularity)

    @_builtins.property
    @pulumi.getter(name="boundingBox")
    def bounding_box(self) -> pulumi.Input['DataAutomationProjectDocumentBoundingBoxArgs']:
        """
        Whether to generate bounding boxes.
        """
        return pulumi.get(self, "bounding_box")

    @bounding_box.setter
    def bounding_box(self, value: pulumi.Input['DataAutomationProjectDocumentBoundingBoxArgs']):
        pulumi.set(self, "bounding_box", value)

    @_builtins.property
    @pulumi.getter
    def granularity(self) -> pulumi.Input['DataAutomationProjectDocumentExtractionGranularityArgs']:
        """
        Which granularities to generate data for.
        """
        return pulumi.get(self, "granularity")

    @granularity.setter
    def granularity(self, value: pulumi.Input['DataAutomationProjectDocumentExtractionGranularityArgs']):
        pulumi.set(self, "granularity", value)


if not MYPY:
    class DataAutomationProjectDocumentStandardGenerativeFieldArgsDict(TypedDict):
        state: pulumi.Input['DataAutomationProjectState']
        """
        Whether generating descriptions is enabled for documents.
        """
elif False:
    DataAutomationProjectDocumentStandardGenerativeFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAutomationProjectDocumentStandardGenerativeFieldArgs:
    def __init__(__self__, *,
                 state: pulumi.Input['DataAutomationProjectState']):
        """
        :param pulumi.Input['DataAutomationProjectState'] state: Whether generating descriptions is enabled for documents.
        """
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> pulumi.Input['DataAutomationProjectState']:
        """
        Whether generating descriptions is enabled for documents.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: pulumi.Input['DataAutomationProjectState']):
        pulumi.set(self, "state", value)


if not MYPY:
    class DataAutomationProjectDocumentStandardOutputConfigurationArgsDict(TypedDict):
        extraction: NotRequired[pulumi.Input['DataAutomationProjectDocumentStandardExtractionArgsDict']]
        """
        Settings for populating data fields that describe the document.
        """
        generative_field: NotRequired[pulumi.Input['DataAutomationProjectDocumentStandardGenerativeFieldArgsDict']]
        """
        Whether to generate descriptions.
        """
        output_format: NotRequired[pulumi.Input['DataAutomationProjectDocumentOutputFormatArgsDict']]
        """
        The output format to generate.
        """
elif False:
    DataAutomationProjectDocumentStandardOutputConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAutomationProjectDocumentStandardOutputConfigurationArgs:
    def __init__(__self__, *,
                 extraction: Optional[pulumi.Input['DataAutomationProjectDocumentStandardExtractionArgs']] = None,
                 generative_field: Optional[pulumi.Input['DataAutomationProjectDocumentStandardGenerativeFieldArgs']] = None,
                 output_format: Optional[pulumi.Input['DataAutomationProjectDocumentOutputFormatArgs']] = None):
        """
        :param pulumi.Input['DataAutomationProjectDocumentStandardExtractionArgs'] extraction: Settings for populating data fields that describe the document.
        :param pulumi.Input['DataAutomationProjectDocumentStandardGenerativeFieldArgs'] generative_field: Whether to generate descriptions.
        :param pulumi.Input['DataAutomationProjectDocumentOutputFormatArgs'] output_format: The output format to generate.
        """
        if extraction is not None:
            pulumi.set(__self__, "extraction", extraction)
        if generative_field is not None:
            pulumi.set(__self__, "generative_field", generative_field)
        if output_format is not None:
            pulumi.set(__self__, "output_format", output_format)

    @_builtins.property
    @pulumi.getter
    def extraction(self) -> Optional[pulumi.Input['DataAutomationProjectDocumentStandardExtractionArgs']]:
        """
        Settings for populating data fields that describe the document.
        """
        return pulumi.get(self, "extraction")

    @extraction.setter
    def extraction(self, value: Optional[pulumi.Input['DataAutomationProjectDocumentStandardExtractionArgs']]):
        pulumi.set(self, "extraction", value)

    @_builtins.property
    @pulumi.getter(name="generativeField")
    def generative_field(self) -> Optional[pulumi.Input['DataAutomationProjectDocumentStandardGenerativeFieldArgs']]:
        """
        Whether to generate descriptions.
        """
        return pulumi.get(self, "generative_field")

    @generative_field.setter
    def generative_field(self, value: Optional[pulumi.Input['DataAutomationProjectDocumentStandardGenerativeFieldArgs']]):
        pulumi.set(self, "generative_field", value)

    @_builtins.property
    @pulumi.getter(name="outputFormat")
    def output_format(self) -> Optional[pulumi.Input['DataAutomationProjectDocumentOutputFormatArgs']]:
        """
        The output format to generate.
        """
        return pulumi.get(self, "output_format")

    @output_format.setter
    def output_format(self, value: Optional[pulumi.Input['DataAutomationProjectDocumentOutputFormatArgs']]):
        pulumi.set(self, "output_format", value)


if not MYPY:
    class DataAutomationProjectImageBoundingBoxArgsDict(TypedDict):
        state: pulumi.Input['DataAutomationProjectState']
        """
        Bounding box settings for a project.
        """
elif False:
    DataAutomationProjectImageBoundingBoxArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAutomationProjectImageBoundingBoxArgs:
    def __init__(__self__, *,
                 state: pulumi.Input['DataAutomationProjectState']):
        """
        :param pulumi.Input['DataAutomationProjectState'] state: Bounding box settings for a project.
        """
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> pulumi.Input['DataAutomationProjectState']:
        """
        Bounding box settings for a project.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: pulumi.Input['DataAutomationProjectState']):
        pulumi.set(self, "state", value)


if not MYPY:
    class DataAutomationProjectImageExtractionCategoryArgsDict(TypedDict):
        state: pulumi.Input['DataAutomationProjectState']
        """
        Whether generating categorical data from images is enabled.
        """
        types: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectImageExtractionCategoryType']]]]
        """
        The types of data to generate.
        """
elif False:
    DataAutomationProjectImageExtractionCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAutomationProjectImageExtractionCategoryArgs:
    def __init__(__self__, *,
                 state: pulumi.Input['DataAutomationProjectState'],
                 types: Optional[pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectImageExtractionCategoryType']]]] = None):
        """
        :param pulumi.Input['DataAutomationProjectState'] state: Whether generating categorical data from images is enabled.
        :param pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectImageExtractionCategoryType']]] types: The types of data to generate.
        """
        pulumi.set(__self__, "state", state)
        if types is not None:
            pulumi.set(__self__, "types", types)

    @_builtins.property
    @pulumi.getter
    def state(self) -> pulumi.Input['DataAutomationProjectState']:
        """
        Whether generating categorical data from images is enabled.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: pulumi.Input['DataAutomationProjectState']):
        pulumi.set(self, "state", value)

    @_builtins.property
    @pulumi.getter
    def types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectImageExtractionCategoryType']]]]:
        """
        The types of data to generate.
        """
        return pulumi.get(self, "types")

    @types.setter
    def types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectImageExtractionCategoryType']]]]):
        pulumi.set(self, "types", value)


if not MYPY:
    class DataAutomationProjectImageOverrideConfigurationArgsDict(TypedDict):
        modality_processing: NotRequired[pulumi.Input['DataAutomationProjectModalityProcessingConfigurationArgsDict']]
        """
        Sets modality processing for image files. All modalities are enabled by default.
        """
elif False:
    DataAutomationProjectImageOverrideConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAutomationProjectImageOverrideConfigurationArgs:
    def __init__(__self__, *,
                 modality_processing: Optional[pulumi.Input['DataAutomationProjectModalityProcessingConfigurationArgs']] = None):
        """
        :param pulumi.Input['DataAutomationProjectModalityProcessingConfigurationArgs'] modality_processing: Sets modality processing for image files. All modalities are enabled by default.
        """
        if modality_processing is not None:
            pulumi.set(__self__, "modality_processing", modality_processing)

    @_builtins.property
    @pulumi.getter(name="modalityProcessing")
    def modality_processing(self) -> Optional[pulumi.Input['DataAutomationProjectModalityProcessingConfigurationArgs']]:
        """
        Sets modality processing for image files. All modalities are enabled by default.
        """
        return pulumi.get(self, "modality_processing")

    @modality_processing.setter
    def modality_processing(self, value: Optional[pulumi.Input['DataAutomationProjectModalityProcessingConfigurationArgs']]):
        pulumi.set(self, "modality_processing", value)


if not MYPY:
    class DataAutomationProjectImageStandardExtractionArgsDict(TypedDict):
        bounding_box: pulumi.Input['DataAutomationProjectImageBoundingBoxArgsDict']
        """
        Settings for generating bounding boxes.
        """
        category: pulumi.Input['DataAutomationProjectImageExtractionCategoryArgsDict']
        """
        Settings for generating categorical data.
        """
elif False:
    DataAutomationProjectImageStandardExtractionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAutomationProjectImageStandardExtractionArgs:
    def __init__(__self__, *,
                 bounding_box: pulumi.Input['DataAutomationProjectImageBoundingBoxArgs'],
                 category: pulumi.Input['DataAutomationProjectImageExtractionCategoryArgs']):
        """
        :param pulumi.Input['DataAutomationProjectImageBoundingBoxArgs'] bounding_box: Settings for generating bounding boxes.
        :param pulumi.Input['DataAutomationProjectImageExtractionCategoryArgs'] category: Settings for generating categorical data.
        """
        pulumi.set(__self__, "bounding_box", bounding_box)
        pulumi.set(__self__, "category", category)

    @_builtins.property
    @pulumi.getter(name="boundingBox")
    def bounding_box(self) -> pulumi.Input['DataAutomationProjectImageBoundingBoxArgs']:
        """
        Settings for generating bounding boxes.
        """
        return pulumi.get(self, "bounding_box")

    @bounding_box.setter
    def bounding_box(self, value: pulumi.Input['DataAutomationProjectImageBoundingBoxArgs']):
        pulumi.set(self, "bounding_box", value)

    @_builtins.property
    @pulumi.getter
    def category(self) -> pulumi.Input['DataAutomationProjectImageExtractionCategoryArgs']:
        """
        Settings for generating categorical data.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: pulumi.Input['DataAutomationProjectImageExtractionCategoryArgs']):
        pulumi.set(self, "category", value)


if not MYPY:
    class DataAutomationProjectImageStandardGenerativeFieldArgsDict(TypedDict):
        state: pulumi.Input['DataAutomationProjectState']
        """
        Whether generating descriptions is enabled for images.
        """
        types: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectImageStandardGenerativeFieldType']]]]
        """
        Settings for generating descriptions of images.
        """
elif False:
    DataAutomationProjectImageStandardGenerativeFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAutomationProjectImageStandardGenerativeFieldArgs:
    def __init__(__self__, *,
                 state: pulumi.Input['DataAutomationProjectState'],
                 types: Optional[pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectImageStandardGenerativeFieldType']]]] = None):
        """
        :param pulumi.Input['DataAutomationProjectState'] state: Whether generating descriptions is enabled for images.
        :param pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectImageStandardGenerativeFieldType']]] types: Settings for generating descriptions of images.
        """
        pulumi.set(__self__, "state", state)
        if types is not None:
            pulumi.set(__self__, "types", types)

    @_builtins.property
    @pulumi.getter
    def state(self) -> pulumi.Input['DataAutomationProjectState']:
        """
        Whether generating descriptions is enabled for images.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: pulumi.Input['DataAutomationProjectState']):
        pulumi.set(self, "state", value)

    @_builtins.property
    @pulumi.getter
    def types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectImageStandardGenerativeFieldType']]]]:
        """
        Settings for generating descriptions of images.
        """
        return pulumi.get(self, "types")

    @types.setter
    def types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectImageStandardGenerativeFieldType']]]]):
        pulumi.set(self, "types", value)


if not MYPY:
    class DataAutomationProjectImageStandardOutputConfigurationArgsDict(TypedDict):
        extraction: NotRequired[pulumi.Input['DataAutomationProjectImageStandardExtractionArgsDict']]
        """
        Settings for populating data fields that describe the image.
        """
        generative_field: NotRequired[pulumi.Input['DataAutomationProjectImageStandardGenerativeFieldArgsDict']]
        """
        Whether to generate descriptions of the data.
        """
elif False:
    DataAutomationProjectImageStandardOutputConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAutomationProjectImageStandardOutputConfigurationArgs:
    def __init__(__self__, *,
                 extraction: Optional[pulumi.Input['DataAutomationProjectImageStandardExtractionArgs']] = None,
                 generative_field: Optional[pulumi.Input['DataAutomationProjectImageStandardGenerativeFieldArgs']] = None):
        """
        :param pulumi.Input['DataAutomationProjectImageStandardExtractionArgs'] extraction: Settings for populating data fields that describe the image.
        :param pulumi.Input['DataAutomationProjectImageStandardGenerativeFieldArgs'] generative_field: Whether to generate descriptions of the data.
        """
        if extraction is not None:
            pulumi.set(__self__, "extraction", extraction)
        if generative_field is not None:
            pulumi.set(__self__, "generative_field", generative_field)

    @_builtins.property
    @pulumi.getter
    def extraction(self) -> Optional[pulumi.Input['DataAutomationProjectImageStandardExtractionArgs']]:
        """
        Settings for populating data fields that describe the image.
        """
        return pulumi.get(self, "extraction")

    @extraction.setter
    def extraction(self, value: Optional[pulumi.Input['DataAutomationProjectImageStandardExtractionArgs']]):
        pulumi.set(self, "extraction", value)

    @_builtins.property
    @pulumi.getter(name="generativeField")
    def generative_field(self) -> Optional[pulumi.Input['DataAutomationProjectImageStandardGenerativeFieldArgs']]:
        """
        Whether to generate descriptions of the data.
        """
        return pulumi.get(self, "generative_field")

    @generative_field.setter
    def generative_field(self, value: Optional[pulumi.Input['DataAutomationProjectImageStandardGenerativeFieldArgs']]):
        pulumi.set(self, "generative_field", value)


if not MYPY:
    class DataAutomationProjectModalityProcessingConfigurationArgsDict(TypedDict):
        state: NotRequired[pulumi.Input['DataAutomationProjectState']]
        """
        Stores the state of the modality for your project, set to either enabled or disabled
        """
elif False:
    DataAutomationProjectModalityProcessingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAutomationProjectModalityProcessingConfigurationArgs:
    def __init__(__self__, *,
                 state: Optional[pulumi.Input['DataAutomationProjectState']] = None):
        """
        :param pulumi.Input['DataAutomationProjectState'] state: Stores the state of the modality for your project, set to either enabled or disabled
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input['DataAutomationProjectState']]:
        """
        Stores the state of the modality for your project, set to either enabled or disabled
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input['DataAutomationProjectState']]):
        pulumi.set(self, "state", value)


if not MYPY:
    class DataAutomationProjectModalityRoutingConfigurationArgsDict(TypedDict):
        """
        Modality routing configuration
        """
        jpeg: NotRequired[pulumi.Input['DataAutomationProjectDesiredModality']]
        """
        Sets whether JPEG files are routed to document or image processing.
        """
        mov: NotRequired[pulumi.Input['DataAutomationProjectDesiredModality']]
        """
        Sets whether MOV files are routed to audio or video processing.
        """
        mp4: NotRequired[pulumi.Input['DataAutomationProjectDesiredModality']]
        """
        Sets whether MP4 files are routed to audio or video processing.
        """
        png: NotRequired[pulumi.Input['DataAutomationProjectDesiredModality']]
        """
        Sets whether PNG files are routed to document or image processing.
        """
elif False:
    DataAutomationProjectModalityRoutingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAutomationProjectModalityRoutingConfigurationArgs:
    def __init__(__self__, *,
                 jpeg: Optional[pulumi.Input['DataAutomationProjectDesiredModality']] = None,
                 mov: Optional[pulumi.Input['DataAutomationProjectDesiredModality']] = None,
                 mp4: Optional[pulumi.Input['DataAutomationProjectDesiredModality']] = None,
                 png: Optional[pulumi.Input['DataAutomationProjectDesiredModality']] = None):
        """
        Modality routing configuration
        :param pulumi.Input['DataAutomationProjectDesiredModality'] jpeg: Sets whether JPEG files are routed to document or image processing.
        :param pulumi.Input['DataAutomationProjectDesiredModality'] mov: Sets whether MOV files are routed to audio or video processing.
        :param pulumi.Input['DataAutomationProjectDesiredModality'] mp4: Sets whether MP4 files are routed to audio or video processing.
        :param pulumi.Input['DataAutomationProjectDesiredModality'] png: Sets whether PNG files are routed to document or image processing.
        """
        if jpeg is not None:
            pulumi.set(__self__, "jpeg", jpeg)
        if mov is not None:
            pulumi.set(__self__, "mov", mov)
        if mp4 is not None:
            pulumi.set(__self__, "mp4", mp4)
        if png is not None:
            pulumi.set(__self__, "png", png)

    @_builtins.property
    @pulumi.getter
    def jpeg(self) -> Optional[pulumi.Input['DataAutomationProjectDesiredModality']]:
        """
        Sets whether JPEG files are routed to document or image processing.
        """
        return pulumi.get(self, "jpeg")

    @jpeg.setter
    def jpeg(self, value: Optional[pulumi.Input['DataAutomationProjectDesiredModality']]):
        pulumi.set(self, "jpeg", value)

    @_builtins.property
    @pulumi.getter
    def mov(self) -> Optional[pulumi.Input['DataAutomationProjectDesiredModality']]:
        """
        Sets whether MOV files are routed to audio or video processing.
        """
        return pulumi.get(self, "mov")

    @mov.setter
    def mov(self, value: Optional[pulumi.Input['DataAutomationProjectDesiredModality']]):
        pulumi.set(self, "mov", value)

    @_builtins.property
    @pulumi.getter
    def mp4(self) -> Optional[pulumi.Input['DataAutomationProjectDesiredModality']]:
        """
        Sets whether MP4 files are routed to audio or video processing.
        """
        return pulumi.get(self, "mp4")

    @mp4.setter
    def mp4(self, value: Optional[pulumi.Input['DataAutomationProjectDesiredModality']]):
        pulumi.set(self, "mp4", value)

    @_builtins.property
    @pulumi.getter
    def png(self) -> Optional[pulumi.Input['DataAutomationProjectDesiredModality']]:
        """
        Sets whether PNG files are routed to document or image processing.
        """
        return pulumi.get(self, "png")

    @png.setter
    def png(self, value: Optional[pulumi.Input['DataAutomationProjectDesiredModality']]):
        pulumi.set(self, "png", value)


if not MYPY:
    class DataAutomationProjectOverrideConfigurationArgsDict(TypedDict):
        """
        Override configuration
        """
        audio: NotRequired[pulumi.Input['DataAutomationProjectAudioOverrideConfigurationArgsDict']]
        """
        This element declares whether your project will process audio files.
        """
        document: NotRequired[pulumi.Input['DataAutomationProjectDocumentOverrideConfigurationArgsDict']]
        """
        Additional settings for a project.
        """
        image: NotRequired[pulumi.Input['DataAutomationProjectImageOverrideConfigurationArgsDict']]
        """
        This element declares whether your project will process image files.
        """
        modality_routing: NotRequired[pulumi.Input['DataAutomationProjectModalityRoutingConfigurationArgsDict']]
        """
        Lets you set which modalities certain file types are processed as.
        """
        video: NotRequired[pulumi.Input['DataAutomationProjectVideoOverrideConfigurationArgsDict']]
        """
        This element declares whether your project will process video files.
        """
elif False:
    DataAutomationProjectOverrideConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAutomationProjectOverrideConfigurationArgs:
    def __init__(__self__, *,
                 audio: Optional[pulumi.Input['DataAutomationProjectAudioOverrideConfigurationArgs']] = None,
                 document: Optional[pulumi.Input['DataAutomationProjectDocumentOverrideConfigurationArgs']] = None,
                 image: Optional[pulumi.Input['DataAutomationProjectImageOverrideConfigurationArgs']] = None,
                 modality_routing: Optional[pulumi.Input['DataAutomationProjectModalityRoutingConfigurationArgs']] = None,
                 video: Optional[pulumi.Input['DataAutomationProjectVideoOverrideConfigurationArgs']] = None):
        """
        Override configuration
        :param pulumi.Input['DataAutomationProjectAudioOverrideConfigurationArgs'] audio: This element declares whether your project will process audio files.
        :param pulumi.Input['DataAutomationProjectDocumentOverrideConfigurationArgs'] document: Additional settings for a project.
        :param pulumi.Input['DataAutomationProjectImageOverrideConfigurationArgs'] image: This element declares whether your project will process image files.
        :param pulumi.Input['DataAutomationProjectModalityRoutingConfigurationArgs'] modality_routing: Lets you set which modalities certain file types are processed as.
        :param pulumi.Input['DataAutomationProjectVideoOverrideConfigurationArgs'] video: This element declares whether your project will process video files.
        """
        if audio is not None:
            pulumi.set(__self__, "audio", audio)
        if document is not None:
            pulumi.set(__self__, "document", document)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if modality_routing is not None:
            pulumi.set(__self__, "modality_routing", modality_routing)
        if video is not None:
            pulumi.set(__self__, "video", video)

    @_builtins.property
    @pulumi.getter
    def audio(self) -> Optional[pulumi.Input['DataAutomationProjectAudioOverrideConfigurationArgs']]:
        """
        This element declares whether your project will process audio files.
        """
        return pulumi.get(self, "audio")

    @audio.setter
    def audio(self, value: Optional[pulumi.Input['DataAutomationProjectAudioOverrideConfigurationArgs']]):
        pulumi.set(self, "audio", value)

    @_builtins.property
    @pulumi.getter
    def document(self) -> Optional[pulumi.Input['DataAutomationProjectDocumentOverrideConfigurationArgs']]:
        """
        Additional settings for a project.
        """
        return pulumi.get(self, "document")

    @document.setter
    def document(self, value: Optional[pulumi.Input['DataAutomationProjectDocumentOverrideConfigurationArgs']]):
        pulumi.set(self, "document", value)

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input['DataAutomationProjectImageOverrideConfigurationArgs']]:
        """
        This element declares whether your project will process image files.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input['DataAutomationProjectImageOverrideConfigurationArgs']]):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter(name="modalityRouting")
    def modality_routing(self) -> Optional[pulumi.Input['DataAutomationProjectModalityRoutingConfigurationArgs']]:
        """
        Lets you set which modalities certain file types are processed as.
        """
        return pulumi.get(self, "modality_routing")

    @modality_routing.setter
    def modality_routing(self, value: Optional[pulumi.Input['DataAutomationProjectModalityRoutingConfigurationArgs']]):
        pulumi.set(self, "modality_routing", value)

    @_builtins.property
    @pulumi.getter
    def video(self) -> Optional[pulumi.Input['DataAutomationProjectVideoOverrideConfigurationArgs']]:
        """
        This element declares whether your project will process video files.
        """
        return pulumi.get(self, "video")

    @video.setter
    def video(self, value: Optional[pulumi.Input['DataAutomationProjectVideoOverrideConfigurationArgs']]):
        pulumi.set(self, "video", value)


if not MYPY:
    class DataAutomationProjectSpeakerLabelingConfigurationArgsDict(TypedDict):
        state: pulumi.Input['DataAutomationProjectState']
        """
        State of speaker labeling, either enabled or disabled.
        """
elif False:
    DataAutomationProjectSpeakerLabelingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAutomationProjectSpeakerLabelingConfigurationArgs:
    def __init__(__self__, *,
                 state: pulumi.Input['DataAutomationProjectState']):
        """
        :param pulumi.Input['DataAutomationProjectState'] state: State of speaker labeling, either enabled or disabled.
        """
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> pulumi.Input['DataAutomationProjectState']:
        """
        State of speaker labeling, either enabled or disabled.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: pulumi.Input['DataAutomationProjectState']):
        pulumi.set(self, "state", value)


if not MYPY:
    class DataAutomationProjectSplitterConfigurationArgsDict(TypedDict):
        state: NotRequired[pulumi.Input['DataAutomationProjectState']]
        """
        Whether document splitter is enabled for a project.
        """
elif False:
    DataAutomationProjectSplitterConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAutomationProjectSplitterConfigurationArgs:
    def __init__(__self__, *,
                 state: Optional[pulumi.Input['DataAutomationProjectState']] = None):
        """
        :param pulumi.Input['DataAutomationProjectState'] state: Whether document splitter is enabled for a project.
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input['DataAutomationProjectState']]:
        """
        Whether document splitter is enabled for a project.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input['DataAutomationProjectState']]):
        pulumi.set(self, "state", value)


if not MYPY:
    class DataAutomationProjectStandardOutputConfigurationArgsDict(TypedDict):
        """
        Standard output configuration
        """
        audio: NotRequired[pulumi.Input['DataAutomationProjectAudioStandardOutputConfigurationArgsDict']]
        """
        Settings for processing audio.
        """
        document: NotRequired[pulumi.Input['DataAutomationProjectDocumentStandardOutputConfigurationArgsDict']]
        """
        Settings for processing documents.
        """
        image: NotRequired[pulumi.Input['DataAutomationProjectImageStandardOutputConfigurationArgsDict']]
        """
        Settings for processing images.
        """
        video: NotRequired[pulumi.Input['DataAutomationProjectVideoStandardOutputConfigurationArgsDict']]
        """
        Settings for processing video.
        """
elif False:
    DataAutomationProjectStandardOutputConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAutomationProjectStandardOutputConfigurationArgs:
    def __init__(__self__, *,
                 audio: Optional[pulumi.Input['DataAutomationProjectAudioStandardOutputConfigurationArgs']] = None,
                 document: Optional[pulumi.Input['DataAutomationProjectDocumentStandardOutputConfigurationArgs']] = None,
                 image: Optional[pulumi.Input['DataAutomationProjectImageStandardOutputConfigurationArgs']] = None,
                 video: Optional[pulumi.Input['DataAutomationProjectVideoStandardOutputConfigurationArgs']] = None):
        """
        Standard output configuration
        :param pulumi.Input['DataAutomationProjectAudioStandardOutputConfigurationArgs'] audio: Settings for processing audio.
        :param pulumi.Input['DataAutomationProjectDocumentStandardOutputConfigurationArgs'] document: Settings for processing documents.
        :param pulumi.Input['DataAutomationProjectImageStandardOutputConfigurationArgs'] image: Settings for processing images.
        :param pulumi.Input['DataAutomationProjectVideoStandardOutputConfigurationArgs'] video: Settings for processing video.
        """
        if audio is not None:
            pulumi.set(__self__, "audio", audio)
        if document is not None:
            pulumi.set(__self__, "document", document)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if video is not None:
            pulumi.set(__self__, "video", video)

    @_builtins.property
    @pulumi.getter
    def audio(self) -> Optional[pulumi.Input['DataAutomationProjectAudioStandardOutputConfigurationArgs']]:
        """
        Settings for processing audio.
        """
        return pulumi.get(self, "audio")

    @audio.setter
    def audio(self, value: Optional[pulumi.Input['DataAutomationProjectAudioStandardOutputConfigurationArgs']]):
        pulumi.set(self, "audio", value)

    @_builtins.property
    @pulumi.getter
    def document(self) -> Optional[pulumi.Input['DataAutomationProjectDocumentStandardOutputConfigurationArgs']]:
        """
        Settings for processing documents.
        """
        return pulumi.get(self, "document")

    @document.setter
    def document(self, value: Optional[pulumi.Input['DataAutomationProjectDocumentStandardOutputConfigurationArgs']]):
        pulumi.set(self, "document", value)

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input['DataAutomationProjectImageStandardOutputConfigurationArgs']]:
        """
        Settings for processing images.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input['DataAutomationProjectImageStandardOutputConfigurationArgs']]):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter
    def video(self) -> Optional[pulumi.Input['DataAutomationProjectVideoStandardOutputConfigurationArgs']]:
        """
        Settings for processing video.
        """
        return pulumi.get(self, "video")

    @video.setter
    def video(self, value: Optional[pulumi.Input['DataAutomationProjectVideoStandardOutputConfigurationArgs']]):
        pulumi.set(self, "video", value)


if not MYPY:
    class DataAutomationProjectTranscriptConfigurationArgsDict(TypedDict):
        channel_labeling: NotRequired[pulumi.Input['DataAutomationProjectChannelLabelingConfigurationArgsDict']]
        """
        Enables channel labeling. Each audio channel will be labeled with a number, and the transcript will indicate which channel is being used.
        """
        speaker_labeling: NotRequired[pulumi.Input['DataAutomationProjectSpeakerLabelingConfigurationArgsDict']]
        """
        Enables speaker labeling. Each speaker within a transcript will recieve a number, and the transcript will note which speaker is talking.
        """
elif False:
    DataAutomationProjectTranscriptConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAutomationProjectTranscriptConfigurationArgs:
    def __init__(__self__, *,
                 channel_labeling: Optional[pulumi.Input['DataAutomationProjectChannelLabelingConfigurationArgs']] = None,
                 speaker_labeling: Optional[pulumi.Input['DataAutomationProjectSpeakerLabelingConfigurationArgs']] = None):
        """
        :param pulumi.Input['DataAutomationProjectChannelLabelingConfigurationArgs'] channel_labeling: Enables channel labeling. Each audio channel will be labeled with a number, and the transcript will indicate which channel is being used.
        :param pulumi.Input['DataAutomationProjectSpeakerLabelingConfigurationArgs'] speaker_labeling: Enables speaker labeling. Each speaker within a transcript will recieve a number, and the transcript will note which speaker is talking.
        """
        if channel_labeling is not None:
            pulumi.set(__self__, "channel_labeling", channel_labeling)
        if speaker_labeling is not None:
            pulumi.set(__self__, "speaker_labeling", speaker_labeling)

    @_builtins.property
    @pulumi.getter(name="channelLabeling")
    def channel_labeling(self) -> Optional[pulumi.Input['DataAutomationProjectChannelLabelingConfigurationArgs']]:
        """
        Enables channel labeling. Each audio channel will be labeled with a number, and the transcript will indicate which channel is being used.
        """
        return pulumi.get(self, "channel_labeling")

    @channel_labeling.setter
    def channel_labeling(self, value: Optional[pulumi.Input['DataAutomationProjectChannelLabelingConfigurationArgs']]):
        pulumi.set(self, "channel_labeling", value)

    @_builtins.property
    @pulumi.getter(name="speakerLabeling")
    def speaker_labeling(self) -> Optional[pulumi.Input['DataAutomationProjectSpeakerLabelingConfigurationArgs']]:
        """
        Enables speaker labeling. Each speaker within a transcript will recieve a number, and the transcript will note which speaker is talking.
        """
        return pulumi.get(self, "speaker_labeling")

    @speaker_labeling.setter
    def speaker_labeling(self, value: Optional[pulumi.Input['DataAutomationProjectSpeakerLabelingConfigurationArgs']]):
        pulumi.set(self, "speaker_labeling", value)


if not MYPY:
    class DataAutomationProjectVideoBoundingBoxArgsDict(TypedDict):
        state: pulumi.Input['DataAutomationProjectState']
        """
        Whether bounding boxes are enabled for video.
        """
elif False:
    DataAutomationProjectVideoBoundingBoxArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAutomationProjectVideoBoundingBoxArgs:
    def __init__(__self__, *,
                 state: pulumi.Input['DataAutomationProjectState']):
        """
        :param pulumi.Input['DataAutomationProjectState'] state: Whether bounding boxes are enabled for video.
        """
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> pulumi.Input['DataAutomationProjectState']:
        """
        Whether bounding boxes are enabled for video.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: pulumi.Input['DataAutomationProjectState']):
        pulumi.set(self, "state", value)


if not MYPY:
    class DataAutomationProjectVideoExtractionCategoryArgsDict(TypedDict):
        state: pulumi.Input['DataAutomationProjectState']
        """
        Whether generating categorical data from video is enabled.
        """
        types: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectVideoExtractionCategoryType']]]]
        """
        The types of data to generate.
        """
elif False:
    DataAutomationProjectVideoExtractionCategoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAutomationProjectVideoExtractionCategoryArgs:
    def __init__(__self__, *,
                 state: pulumi.Input['DataAutomationProjectState'],
                 types: Optional[pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectVideoExtractionCategoryType']]]] = None):
        """
        :param pulumi.Input['DataAutomationProjectState'] state: Whether generating categorical data from video is enabled.
        :param pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectVideoExtractionCategoryType']]] types: The types of data to generate.
        """
        pulumi.set(__self__, "state", state)
        if types is not None:
            pulumi.set(__self__, "types", types)

    @_builtins.property
    @pulumi.getter
    def state(self) -> pulumi.Input['DataAutomationProjectState']:
        """
        Whether generating categorical data from video is enabled.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: pulumi.Input['DataAutomationProjectState']):
        pulumi.set(self, "state", value)

    @_builtins.property
    @pulumi.getter
    def types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectVideoExtractionCategoryType']]]]:
        """
        The types of data to generate.
        """
        return pulumi.get(self, "types")

    @types.setter
    def types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectVideoExtractionCategoryType']]]]):
        pulumi.set(self, "types", value)


if not MYPY:
    class DataAutomationProjectVideoOverrideConfigurationArgsDict(TypedDict):
        modality_processing: NotRequired[pulumi.Input['DataAutomationProjectModalityProcessingConfigurationArgsDict']]
        """
        Sets modality processing for video files. All modalities are enabled by default.
        """
elif False:
    DataAutomationProjectVideoOverrideConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAutomationProjectVideoOverrideConfigurationArgs:
    def __init__(__self__, *,
                 modality_processing: Optional[pulumi.Input['DataAutomationProjectModalityProcessingConfigurationArgs']] = None):
        """
        :param pulumi.Input['DataAutomationProjectModalityProcessingConfigurationArgs'] modality_processing: Sets modality processing for video files. All modalities are enabled by default.
        """
        if modality_processing is not None:
            pulumi.set(__self__, "modality_processing", modality_processing)

    @_builtins.property
    @pulumi.getter(name="modalityProcessing")
    def modality_processing(self) -> Optional[pulumi.Input['DataAutomationProjectModalityProcessingConfigurationArgs']]:
        """
        Sets modality processing for video files. All modalities are enabled by default.
        """
        return pulumi.get(self, "modality_processing")

    @modality_processing.setter
    def modality_processing(self, value: Optional[pulumi.Input['DataAutomationProjectModalityProcessingConfigurationArgs']]):
        pulumi.set(self, "modality_processing", value)


if not MYPY:
    class DataAutomationProjectVideoStandardExtractionArgsDict(TypedDict):
        bounding_box: pulumi.Input['DataAutomationProjectVideoBoundingBoxArgsDict']
        """
        Settings for generating bounding boxes.
        """
        category: pulumi.Input['DataAutomationProjectVideoExtractionCategoryArgsDict']
        """
        Settings for generating categorical data.
        """
elif False:
    DataAutomationProjectVideoStandardExtractionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAutomationProjectVideoStandardExtractionArgs:
    def __init__(__self__, *,
                 bounding_box: pulumi.Input['DataAutomationProjectVideoBoundingBoxArgs'],
                 category: pulumi.Input['DataAutomationProjectVideoExtractionCategoryArgs']):
        """
        :param pulumi.Input['DataAutomationProjectVideoBoundingBoxArgs'] bounding_box: Settings for generating bounding boxes.
        :param pulumi.Input['DataAutomationProjectVideoExtractionCategoryArgs'] category: Settings for generating categorical data.
        """
        pulumi.set(__self__, "bounding_box", bounding_box)
        pulumi.set(__self__, "category", category)

    @_builtins.property
    @pulumi.getter(name="boundingBox")
    def bounding_box(self) -> pulumi.Input['DataAutomationProjectVideoBoundingBoxArgs']:
        """
        Settings for generating bounding boxes.
        """
        return pulumi.get(self, "bounding_box")

    @bounding_box.setter
    def bounding_box(self, value: pulumi.Input['DataAutomationProjectVideoBoundingBoxArgs']):
        pulumi.set(self, "bounding_box", value)

    @_builtins.property
    @pulumi.getter
    def category(self) -> pulumi.Input['DataAutomationProjectVideoExtractionCategoryArgs']:
        """
        Settings for generating categorical data.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: pulumi.Input['DataAutomationProjectVideoExtractionCategoryArgs']):
        pulumi.set(self, "category", value)


if not MYPY:
    class DataAutomationProjectVideoStandardGenerativeFieldArgsDict(TypedDict):
        state: pulumi.Input['DataAutomationProjectState']
        """
        Whether generating descriptions is enabled for video.
        """
        types: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectVideoStandardGenerativeFieldType']]]]
        """
        The types of description to generate.
        """
elif False:
    DataAutomationProjectVideoStandardGenerativeFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAutomationProjectVideoStandardGenerativeFieldArgs:
    def __init__(__self__, *,
                 state: pulumi.Input['DataAutomationProjectState'],
                 types: Optional[pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectVideoStandardGenerativeFieldType']]]] = None):
        """
        :param pulumi.Input['DataAutomationProjectState'] state: Whether generating descriptions is enabled for video.
        :param pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectVideoStandardGenerativeFieldType']]] types: The types of description to generate.
        """
        pulumi.set(__self__, "state", state)
        if types is not None:
            pulumi.set(__self__, "types", types)

    @_builtins.property
    @pulumi.getter
    def state(self) -> pulumi.Input['DataAutomationProjectState']:
        """
        Whether generating descriptions is enabled for video.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: pulumi.Input['DataAutomationProjectState']):
        pulumi.set(self, "state", value)

    @_builtins.property
    @pulumi.getter
    def types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectVideoStandardGenerativeFieldType']]]]:
        """
        The types of description to generate.
        """
        return pulumi.get(self, "types")

    @types.setter
    def types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataAutomationProjectVideoStandardGenerativeFieldType']]]]):
        pulumi.set(self, "types", value)


if not MYPY:
    class DataAutomationProjectVideoStandardOutputConfigurationArgsDict(TypedDict):
        extraction: NotRequired[pulumi.Input['DataAutomationProjectVideoStandardExtractionArgsDict']]
        """
        Settings for populating data fields that describe the video.
        """
        generative_field: NotRequired[pulumi.Input['DataAutomationProjectVideoStandardGenerativeFieldArgsDict']]
        """
        Whether to generate descriptions of the video.
        """
elif False:
    DataAutomationProjectVideoStandardOutputConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAutomationProjectVideoStandardOutputConfigurationArgs:
    def __init__(__self__, *,
                 extraction: Optional[pulumi.Input['DataAutomationProjectVideoStandardExtractionArgs']] = None,
                 generative_field: Optional[pulumi.Input['DataAutomationProjectVideoStandardGenerativeFieldArgs']] = None):
        """
        :param pulumi.Input['DataAutomationProjectVideoStandardExtractionArgs'] extraction: Settings for populating data fields that describe the video.
        :param pulumi.Input['DataAutomationProjectVideoStandardGenerativeFieldArgs'] generative_field: Whether to generate descriptions of the video.
        """
        if extraction is not None:
            pulumi.set(__self__, "extraction", extraction)
        if generative_field is not None:
            pulumi.set(__self__, "generative_field", generative_field)

    @_builtins.property
    @pulumi.getter
    def extraction(self) -> Optional[pulumi.Input['DataAutomationProjectVideoStandardExtractionArgs']]:
        """
        Settings for populating data fields that describe the video.
        """
        return pulumi.get(self, "extraction")

    @extraction.setter
    def extraction(self, value: Optional[pulumi.Input['DataAutomationProjectVideoStandardExtractionArgs']]):
        pulumi.set(self, "extraction", value)

    @_builtins.property
    @pulumi.getter(name="generativeField")
    def generative_field(self) -> Optional[pulumi.Input['DataAutomationProjectVideoStandardGenerativeFieldArgs']]:
        """
        Whether to generate descriptions of the video.
        """
        return pulumi.get(self, "generative_field")

    @generative_field.setter
    def generative_field(self, value: Optional[pulumi.Input['DataAutomationProjectVideoStandardGenerativeFieldArgs']]):
        pulumi.set(self, "generative_field", value)


if not MYPY:
    class DataSourceBedrockDataAutomationConfigurationArgsDict(TypedDict):
        """
        Settings for a Bedrock Data Automation used to parse documents for a data source.
        """
        parsing_modality: NotRequired[pulumi.Input['DataSourceParsingModality']]
        """
        Specifies whether to enable parsing of multimodal data, including both text and/or images.
        """
elif False:
    DataSourceBedrockDataAutomationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceBedrockDataAutomationConfigurationArgs:
    def __init__(__self__, *,
                 parsing_modality: Optional[pulumi.Input['DataSourceParsingModality']] = None):
        """
        Settings for a Bedrock Data Automation used to parse documents for a data source.
        :param pulumi.Input['DataSourceParsingModality'] parsing_modality: Specifies whether to enable parsing of multimodal data, including both text and/or images.
        """
        if parsing_modality is not None:
            pulumi.set(__self__, "parsing_modality", parsing_modality)

    @_builtins.property
    @pulumi.getter(name="parsingModality")
    def parsing_modality(self) -> Optional[pulumi.Input['DataSourceParsingModality']]:
        """
        Specifies whether to enable parsing of multimodal data, including both text and/or images.
        """
        return pulumi.get(self, "parsing_modality")

    @parsing_modality.setter
    def parsing_modality(self, value: Optional[pulumi.Input['DataSourceParsingModality']]):
        pulumi.set(self, "parsing_modality", value)


if not MYPY:
    class DataSourceBedrockFoundationModelConfigurationArgsDict(TypedDict):
        """
        Settings for a foundation model used to parse documents for a data source.
        """
        model_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the foundation model to use for parsing.
        """
        parsing_modality: NotRequired[pulumi.Input['DataSourceParsingModality']]
        """
        Specifies whether to enable parsing of multimodal data, including both text and/or images.
        """
        parsing_prompt: NotRequired[pulumi.Input['DataSourceParsingPromptArgsDict']]
        """
        Instructions for interpreting the contents of a document.
        """
elif False:
    DataSourceBedrockFoundationModelConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceBedrockFoundationModelConfigurationArgs:
    def __init__(__self__, *,
                 model_arn: pulumi.Input[_builtins.str],
                 parsing_modality: Optional[pulumi.Input['DataSourceParsingModality']] = None,
                 parsing_prompt: Optional[pulumi.Input['DataSourceParsingPromptArgs']] = None):
        """
        Settings for a foundation model used to parse documents for a data source.
        :param pulumi.Input[_builtins.str] model_arn: The ARN of the foundation model to use for parsing.
        :param pulumi.Input['DataSourceParsingModality'] parsing_modality: Specifies whether to enable parsing of multimodal data, including both text and/or images.
        :param pulumi.Input['DataSourceParsingPromptArgs'] parsing_prompt: Instructions for interpreting the contents of a document.
        """
        pulumi.set(__self__, "model_arn", model_arn)
        if parsing_modality is not None:
            pulumi.set(__self__, "parsing_modality", parsing_modality)
        if parsing_prompt is not None:
            pulumi.set(__self__, "parsing_prompt", parsing_prompt)

    @_builtins.property
    @pulumi.getter(name="modelArn")
    def model_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the foundation model to use for parsing.
        """
        return pulumi.get(self, "model_arn")

    @model_arn.setter
    def model_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "model_arn", value)

    @_builtins.property
    @pulumi.getter(name="parsingModality")
    def parsing_modality(self) -> Optional[pulumi.Input['DataSourceParsingModality']]:
        """
        Specifies whether to enable parsing of multimodal data, including both text and/or images.
        """
        return pulumi.get(self, "parsing_modality")

    @parsing_modality.setter
    def parsing_modality(self, value: Optional[pulumi.Input['DataSourceParsingModality']]):
        pulumi.set(self, "parsing_modality", value)

    @_builtins.property
    @pulumi.getter(name="parsingPrompt")
    def parsing_prompt(self) -> Optional[pulumi.Input['DataSourceParsingPromptArgs']]:
        """
        Instructions for interpreting the contents of a document.
        """
        return pulumi.get(self, "parsing_prompt")

    @parsing_prompt.setter
    def parsing_prompt(self, value: Optional[pulumi.Input['DataSourceParsingPromptArgs']]):
        pulumi.set(self, "parsing_prompt", value)


if not MYPY:
    class DataSourceBedrockFoundationModelContextEnrichmentConfigurationArgsDict(TypedDict):
        """
        Bedrock Foundation Model configuration to be used for Context Enrichment.
        """
        enrichment_strategy_configuration: pulumi.Input['DataSourceEnrichmentStrategyConfigurationArgsDict']
        """
        The enrichment stategy used to provide additional context. For example, Neptune GraphRAG uses Amazon Bedrock foundation models to perform chunk entity extraction.
        """
        model_arn: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name (ARN) of the model used to create vector embeddings for the knowledge base.
        """
elif False:
    DataSourceBedrockFoundationModelContextEnrichmentConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceBedrockFoundationModelContextEnrichmentConfigurationArgs:
    def __init__(__self__, *,
                 enrichment_strategy_configuration: pulumi.Input['DataSourceEnrichmentStrategyConfigurationArgs'],
                 model_arn: pulumi.Input[_builtins.str]):
        """
        Bedrock Foundation Model configuration to be used for Context Enrichment.
        :param pulumi.Input['DataSourceEnrichmentStrategyConfigurationArgs'] enrichment_strategy_configuration: The enrichment stategy used to provide additional context. For example, Neptune GraphRAG uses Amazon Bedrock foundation models to perform chunk entity extraction.
        :param pulumi.Input[_builtins.str] model_arn: The Amazon Resource Name (ARN) of the model used to create vector embeddings for the knowledge base.
        """
        pulumi.set(__self__, "enrichment_strategy_configuration", enrichment_strategy_configuration)
        pulumi.set(__self__, "model_arn", model_arn)

    @_builtins.property
    @pulumi.getter(name="enrichmentStrategyConfiguration")
    def enrichment_strategy_configuration(self) -> pulumi.Input['DataSourceEnrichmentStrategyConfigurationArgs']:
        """
        The enrichment stategy used to provide additional context. For example, Neptune GraphRAG uses Amazon Bedrock foundation models to perform chunk entity extraction.
        """
        return pulumi.get(self, "enrichment_strategy_configuration")

    @enrichment_strategy_configuration.setter
    def enrichment_strategy_configuration(self, value: pulumi.Input['DataSourceEnrichmentStrategyConfigurationArgs']):
        pulumi.set(self, "enrichment_strategy_configuration", value)

    @_builtins.property
    @pulumi.getter(name="modelArn")
    def model_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the model used to create vector embeddings for the knowledge base.
        """
        return pulumi.get(self, "model_arn")

    @model_arn.setter
    def model_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "model_arn", value)


if not MYPY:
    class DataSourceChunkingConfigurationArgsDict(TypedDict):
        """
        Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried.
        """
        chunking_strategy: pulumi.Input['DataSourceChunkingStrategy']
        """
        Knowledge base can split your source data into chunks. A *chunk* refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried. You have the following options for chunking your data. If you opt for `NONE` , then you may want to pre-process your files by splitting them up such that each file corresponds to a chunk.

        - `FIXED_SIZE`  Amazon Bedrock splits your source data into chunks of the approximate size that you set in the `fixedSizeChunkingConfiguration` .
        - `HIERARCHICAL`  Split documents into layers of chunks where the first layer contains large chunks, and the second layer contains smaller chunks derived from the first layer.
        - `SEMANTIC`  Split documents into chunks based on groups of similar content derived with natural language processing.
        - `NONE`  Amazon Bedrock treats each file as one chunk. If you choose this option, you may want to pre-process your documents by splitting them into separate files.
        """
        fixed_size_chunking_configuration: NotRequired[pulumi.Input['DataSourceFixedSizeChunkingConfigurationArgsDict']]
        """
        Configurations for when you choose fixed-size chunking. If you set the `chunkingStrategy` as `NONE` , exclude this field.
        """
        hierarchical_chunking_configuration: NotRequired[pulumi.Input['DataSourceHierarchicalChunkingConfigurationArgsDict']]
        """
        Settings for hierarchical document chunking for a data source. Hierarchical chunking splits documents into layers of chunks where the first layer contains large chunks, and the second layer contains smaller chunks derived from the first layer.
        """
        semantic_chunking_configuration: NotRequired[pulumi.Input['DataSourceSemanticChunkingConfigurationArgsDict']]
        """
        Settings for semantic document chunking for a data source. Semantic chunking splits a document into into smaller documents based on groups of similar content derived from the text with natural language processing.
        """
elif False:
    DataSourceChunkingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceChunkingConfigurationArgs:
    def __init__(__self__, *,
                 chunking_strategy: pulumi.Input['DataSourceChunkingStrategy'],
                 fixed_size_chunking_configuration: Optional[pulumi.Input['DataSourceFixedSizeChunkingConfigurationArgs']] = None,
                 hierarchical_chunking_configuration: Optional[pulumi.Input['DataSourceHierarchicalChunkingConfigurationArgs']] = None,
                 semantic_chunking_configuration: Optional[pulumi.Input['DataSourceSemanticChunkingConfigurationArgs']] = None):
        """
        Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried.
        :param pulumi.Input['DataSourceChunkingStrategy'] chunking_strategy: Knowledge base can split your source data into chunks. A *chunk* refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried. You have the following options for chunking your data. If you opt for `NONE` , then you may want to pre-process your files by splitting them up such that each file corresponds to a chunk.
               
               - `FIXED_SIZE`  Amazon Bedrock splits your source data into chunks of the approximate size that you set in the `fixedSizeChunkingConfiguration` .
               - `HIERARCHICAL`  Split documents into layers of chunks where the first layer contains large chunks, and the second layer contains smaller chunks derived from the first layer.
               - `SEMANTIC`  Split documents into chunks based on groups of similar content derived with natural language processing.
               - `NONE`  Amazon Bedrock treats each file as one chunk. If you choose this option, you may want to pre-process your documents by splitting them into separate files.
        :param pulumi.Input['DataSourceFixedSizeChunkingConfigurationArgs'] fixed_size_chunking_configuration: Configurations for when you choose fixed-size chunking. If you set the `chunkingStrategy` as `NONE` , exclude this field.
        :param pulumi.Input['DataSourceHierarchicalChunkingConfigurationArgs'] hierarchical_chunking_configuration: Settings for hierarchical document chunking for a data source. Hierarchical chunking splits documents into layers of chunks where the first layer contains large chunks, and the second layer contains smaller chunks derived from the first layer.
        :param pulumi.Input['DataSourceSemanticChunkingConfigurationArgs'] semantic_chunking_configuration: Settings for semantic document chunking for a data source. Semantic chunking splits a document into into smaller documents based on groups of similar content derived from the text with natural language processing.
        """
        pulumi.set(__self__, "chunking_strategy", chunking_strategy)
        if fixed_size_chunking_configuration is not None:
            pulumi.set(__self__, "fixed_size_chunking_configuration", fixed_size_chunking_configuration)
        if hierarchical_chunking_configuration is not None:
            pulumi.set(__self__, "hierarchical_chunking_configuration", hierarchical_chunking_configuration)
        if semantic_chunking_configuration is not None:
            pulumi.set(__self__, "semantic_chunking_configuration", semantic_chunking_configuration)

    @_builtins.property
    @pulumi.getter(name="chunkingStrategy")
    def chunking_strategy(self) -> pulumi.Input['DataSourceChunkingStrategy']:
        """
        Knowledge base can split your source data into chunks. A *chunk* refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried. You have the following options for chunking your data. If you opt for `NONE` , then you may want to pre-process your files by splitting them up such that each file corresponds to a chunk.

        - `FIXED_SIZE`  Amazon Bedrock splits your source data into chunks of the approximate size that you set in the `fixedSizeChunkingConfiguration` .
        - `HIERARCHICAL`  Split documents into layers of chunks where the first layer contains large chunks, and the second layer contains smaller chunks derived from the first layer.
        - `SEMANTIC`  Split documents into chunks based on groups of similar content derived with natural language processing.
        - `NONE`  Amazon Bedrock treats each file as one chunk. If you choose this option, you may want to pre-process your documents by splitting them into separate files.
        """
        return pulumi.get(self, "chunking_strategy")

    @chunking_strategy.setter
    def chunking_strategy(self, value: pulumi.Input['DataSourceChunkingStrategy']):
        pulumi.set(self, "chunking_strategy", value)

    @_builtins.property
    @pulumi.getter(name="fixedSizeChunkingConfiguration")
    def fixed_size_chunking_configuration(self) -> Optional[pulumi.Input['DataSourceFixedSizeChunkingConfigurationArgs']]:
        """
        Configurations for when you choose fixed-size chunking. If you set the `chunkingStrategy` as `NONE` , exclude this field.
        """
        return pulumi.get(self, "fixed_size_chunking_configuration")

    @fixed_size_chunking_configuration.setter
    def fixed_size_chunking_configuration(self, value: Optional[pulumi.Input['DataSourceFixedSizeChunkingConfigurationArgs']]):
        pulumi.set(self, "fixed_size_chunking_configuration", value)

    @_builtins.property
    @pulumi.getter(name="hierarchicalChunkingConfiguration")
    def hierarchical_chunking_configuration(self) -> Optional[pulumi.Input['DataSourceHierarchicalChunkingConfigurationArgs']]:
        """
        Settings for hierarchical document chunking for a data source. Hierarchical chunking splits documents into layers of chunks where the first layer contains large chunks, and the second layer contains smaller chunks derived from the first layer.
        """
        return pulumi.get(self, "hierarchical_chunking_configuration")

    @hierarchical_chunking_configuration.setter
    def hierarchical_chunking_configuration(self, value: Optional[pulumi.Input['DataSourceHierarchicalChunkingConfigurationArgs']]):
        pulumi.set(self, "hierarchical_chunking_configuration", value)

    @_builtins.property
    @pulumi.getter(name="semanticChunkingConfiguration")
    def semantic_chunking_configuration(self) -> Optional[pulumi.Input['DataSourceSemanticChunkingConfigurationArgs']]:
        """
        Settings for semantic document chunking for a data source. Semantic chunking splits a document into into smaller documents based on groups of similar content derived from the text with natural language processing.
        """
        return pulumi.get(self, "semantic_chunking_configuration")

    @semantic_chunking_configuration.setter
    def semantic_chunking_configuration(self, value: Optional[pulumi.Input['DataSourceSemanticChunkingConfigurationArgs']]):
        pulumi.set(self, "semantic_chunking_configuration", value)


if not MYPY:
    class DataSourceConfigurationArgsDict(TypedDict):
        """
        Specifies a raw data source location to ingest.
        """
        type: pulumi.Input['DataSourceType']
        """
        The type of data source.
        """
        confluence_configuration: NotRequired[pulumi.Input['DataSourceConfluenceDataSourceConfigurationArgsDict']]
        """
        The configuration information to connect to Confluence as your data source.

        > Confluence data source connector is in preview release and is subject to change.
        """
        s3_configuration: NotRequired[pulumi.Input['DataSourceS3DataSourceConfigurationArgsDict']]
        """
        The configuration information to connect to Amazon S3 as your data source.
        """
        salesforce_configuration: NotRequired[pulumi.Input['DataSourceSalesforceDataSourceConfigurationArgsDict']]
        """
        The configuration information to connect to Salesforce as your data source.

        > Salesforce data source connector is in preview release and is subject to change.
        """
        share_point_configuration: NotRequired[pulumi.Input['DataSourceSharePointDataSourceConfigurationArgsDict']]
        """
        The configuration information to connect to SharePoint as your data source.

        > SharePoint data source connector is in preview release and is subject to change.
        """
        web_configuration: NotRequired[pulumi.Input['DataSourceWebDataSourceConfigurationArgsDict']]
        """
        The configuration of web URLs to crawl for your data source. You should be authorized to crawl the URLs.

        > Crawling web URLs as your data source is in preview release and is subject to change.
        """
elif False:
    DataSourceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['DataSourceType'],
                 confluence_configuration: Optional[pulumi.Input['DataSourceConfluenceDataSourceConfigurationArgs']] = None,
                 s3_configuration: Optional[pulumi.Input['DataSourceS3DataSourceConfigurationArgs']] = None,
                 salesforce_configuration: Optional[pulumi.Input['DataSourceSalesforceDataSourceConfigurationArgs']] = None,
                 share_point_configuration: Optional[pulumi.Input['DataSourceSharePointDataSourceConfigurationArgs']] = None,
                 web_configuration: Optional[pulumi.Input['DataSourceWebDataSourceConfigurationArgs']] = None):
        """
        Specifies a raw data source location to ingest.
        :param pulumi.Input['DataSourceType'] type: The type of data source.
        :param pulumi.Input['DataSourceConfluenceDataSourceConfigurationArgs'] confluence_configuration: The configuration information to connect to Confluence as your data source.
               
               > Confluence data source connector is in preview release and is subject to change.
        :param pulumi.Input['DataSourceS3DataSourceConfigurationArgs'] s3_configuration: The configuration information to connect to Amazon S3 as your data source.
        :param pulumi.Input['DataSourceSalesforceDataSourceConfigurationArgs'] salesforce_configuration: The configuration information to connect to Salesforce as your data source.
               
               > Salesforce data source connector is in preview release and is subject to change.
        :param pulumi.Input['DataSourceSharePointDataSourceConfigurationArgs'] share_point_configuration: The configuration information to connect to SharePoint as your data source.
               
               > SharePoint data source connector is in preview release and is subject to change.
        :param pulumi.Input['DataSourceWebDataSourceConfigurationArgs'] web_configuration: The configuration of web URLs to crawl for your data source. You should be authorized to crawl the URLs.
               
               > Crawling web URLs as your data source is in preview release and is subject to change.
        """
        pulumi.set(__self__, "type", type)
        if confluence_configuration is not None:
            pulumi.set(__self__, "confluence_configuration", confluence_configuration)
        if s3_configuration is not None:
            pulumi.set(__self__, "s3_configuration", s3_configuration)
        if salesforce_configuration is not None:
            pulumi.set(__self__, "salesforce_configuration", salesforce_configuration)
        if share_point_configuration is not None:
            pulumi.set(__self__, "share_point_configuration", share_point_configuration)
        if web_configuration is not None:
            pulumi.set(__self__, "web_configuration", web_configuration)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['DataSourceType']:
        """
        The type of data source.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['DataSourceType']):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="confluenceConfiguration")
    def confluence_configuration(self) -> Optional[pulumi.Input['DataSourceConfluenceDataSourceConfigurationArgs']]:
        """
        The configuration information to connect to Confluence as your data source.

        > Confluence data source connector is in preview release and is subject to change.
        """
        return pulumi.get(self, "confluence_configuration")

    @confluence_configuration.setter
    def confluence_configuration(self, value: Optional[pulumi.Input['DataSourceConfluenceDataSourceConfigurationArgs']]):
        pulumi.set(self, "confluence_configuration", value)

    @_builtins.property
    @pulumi.getter(name="s3Configuration")
    def s3_configuration(self) -> Optional[pulumi.Input['DataSourceS3DataSourceConfigurationArgs']]:
        """
        The configuration information to connect to Amazon S3 as your data source.
        """
        return pulumi.get(self, "s3_configuration")

    @s3_configuration.setter
    def s3_configuration(self, value: Optional[pulumi.Input['DataSourceS3DataSourceConfigurationArgs']]):
        pulumi.set(self, "s3_configuration", value)

    @_builtins.property
    @pulumi.getter(name="salesforceConfiguration")
    def salesforce_configuration(self) -> Optional[pulumi.Input['DataSourceSalesforceDataSourceConfigurationArgs']]:
        """
        The configuration information to connect to Salesforce as your data source.

        > Salesforce data source connector is in preview release and is subject to change.
        """
        return pulumi.get(self, "salesforce_configuration")

    @salesforce_configuration.setter
    def salesforce_configuration(self, value: Optional[pulumi.Input['DataSourceSalesforceDataSourceConfigurationArgs']]):
        pulumi.set(self, "salesforce_configuration", value)

    @_builtins.property
    @pulumi.getter(name="sharePointConfiguration")
    def share_point_configuration(self) -> Optional[pulumi.Input['DataSourceSharePointDataSourceConfigurationArgs']]:
        """
        The configuration information to connect to SharePoint as your data source.

        > SharePoint data source connector is in preview release and is subject to change.
        """
        return pulumi.get(self, "share_point_configuration")

    @share_point_configuration.setter
    def share_point_configuration(self, value: Optional[pulumi.Input['DataSourceSharePointDataSourceConfigurationArgs']]):
        pulumi.set(self, "share_point_configuration", value)

    @_builtins.property
    @pulumi.getter(name="webConfiguration")
    def web_configuration(self) -> Optional[pulumi.Input['DataSourceWebDataSourceConfigurationArgs']]:
        """
        The configuration of web URLs to crawl for your data source. You should be authorized to crawl the URLs.

        > Crawling web URLs as your data source is in preview release and is subject to change.
        """
        return pulumi.get(self, "web_configuration")

    @web_configuration.setter
    def web_configuration(self, value: Optional[pulumi.Input['DataSourceWebDataSourceConfigurationArgs']]):
        pulumi.set(self, "web_configuration", value)


if not MYPY:
    class DataSourceConfluenceCrawlerConfigurationArgsDict(TypedDict):
        """
        The configuration of the Confluence content. For example, configuring specific types of Confluence content.
        """
        filter_configuration: NotRequired[pulumi.Input['DataSourceCrawlFilterConfigurationArgsDict']]
        """
        The configuration of filtering the Confluence content. For example, configuring regular expression patterns to include or exclude certain content.
        """
elif False:
    DataSourceConfluenceCrawlerConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceConfluenceCrawlerConfigurationArgs:
    def __init__(__self__, *,
                 filter_configuration: Optional[pulumi.Input['DataSourceCrawlFilterConfigurationArgs']] = None):
        """
        The configuration of the Confluence content. For example, configuring specific types of Confluence content.
        :param pulumi.Input['DataSourceCrawlFilterConfigurationArgs'] filter_configuration: The configuration of filtering the Confluence content. For example, configuring regular expression patterns to include or exclude certain content.
        """
        if filter_configuration is not None:
            pulumi.set(__self__, "filter_configuration", filter_configuration)

    @_builtins.property
    @pulumi.getter(name="filterConfiguration")
    def filter_configuration(self) -> Optional[pulumi.Input['DataSourceCrawlFilterConfigurationArgs']]:
        """
        The configuration of filtering the Confluence content. For example, configuring regular expression patterns to include or exclude certain content.
        """
        return pulumi.get(self, "filter_configuration")

    @filter_configuration.setter
    def filter_configuration(self, value: Optional[pulumi.Input['DataSourceCrawlFilterConfigurationArgs']]):
        pulumi.set(self, "filter_configuration", value)


if not MYPY:
    class DataSourceConfluenceDataSourceConfigurationArgsDict(TypedDict):
        """
        The configuration information to connect to Confluence as your data source.
        """
        source_configuration: pulumi.Input['DataSourceConfluenceSourceConfigurationArgsDict']
        """
        The endpoint information to connect to your Confluence data source.
        """
        crawler_configuration: NotRequired[pulumi.Input['DataSourceConfluenceCrawlerConfigurationArgsDict']]
        """
        The configuration of the Confluence content. For example, configuring specific types of Confluence content.
        """
elif False:
    DataSourceConfluenceDataSourceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceConfluenceDataSourceConfigurationArgs:
    def __init__(__self__, *,
                 source_configuration: pulumi.Input['DataSourceConfluenceSourceConfigurationArgs'],
                 crawler_configuration: Optional[pulumi.Input['DataSourceConfluenceCrawlerConfigurationArgs']] = None):
        """
        The configuration information to connect to Confluence as your data source.
        :param pulumi.Input['DataSourceConfluenceSourceConfigurationArgs'] source_configuration: The endpoint information to connect to your Confluence data source.
        :param pulumi.Input['DataSourceConfluenceCrawlerConfigurationArgs'] crawler_configuration: The configuration of the Confluence content. For example, configuring specific types of Confluence content.
        """
        pulumi.set(__self__, "source_configuration", source_configuration)
        if crawler_configuration is not None:
            pulumi.set(__self__, "crawler_configuration", crawler_configuration)

    @_builtins.property
    @pulumi.getter(name="sourceConfiguration")
    def source_configuration(self) -> pulumi.Input['DataSourceConfluenceSourceConfigurationArgs']:
        """
        The endpoint information to connect to your Confluence data source.
        """
        return pulumi.get(self, "source_configuration")

    @source_configuration.setter
    def source_configuration(self, value: pulumi.Input['DataSourceConfluenceSourceConfigurationArgs']):
        pulumi.set(self, "source_configuration", value)

    @_builtins.property
    @pulumi.getter(name="crawlerConfiguration")
    def crawler_configuration(self) -> Optional[pulumi.Input['DataSourceConfluenceCrawlerConfigurationArgs']]:
        """
        The configuration of the Confluence content. For example, configuring specific types of Confluence content.
        """
        return pulumi.get(self, "crawler_configuration")

    @crawler_configuration.setter
    def crawler_configuration(self, value: Optional[pulumi.Input['DataSourceConfluenceCrawlerConfigurationArgs']]):
        pulumi.set(self, "crawler_configuration", value)


if not MYPY:
    class DataSourceConfluenceSourceConfigurationArgsDict(TypedDict):
        """
        The endpoint information to connect to your Confluence data source.
        """
        auth_type: pulumi.Input['DataSourceConfluenceSourceConfigurationAuthType']
        """
        The supported authentication type to authenticate and connect to your Confluence instance.
        """
        credentials_secret_arn: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your Confluence instance URL. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see Confluence connection configuration.
        """
        host_type: pulumi.Input['DataSourceConfluenceSourceConfigurationHostType']
        """
        The supported host type, whether online/cloud or server/on-premises.
        """
        host_url: pulumi.Input[_builtins.str]
        """
        The Confluence host URL or instance URL.
        """
elif False:
    DataSourceConfluenceSourceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceConfluenceSourceConfigurationArgs:
    def __init__(__self__, *,
                 auth_type: pulumi.Input['DataSourceConfluenceSourceConfigurationAuthType'],
                 credentials_secret_arn: pulumi.Input[_builtins.str],
                 host_type: pulumi.Input['DataSourceConfluenceSourceConfigurationHostType'],
                 host_url: pulumi.Input[_builtins.str]):
        """
        The endpoint information to connect to your Confluence data source.
        :param pulumi.Input['DataSourceConfluenceSourceConfigurationAuthType'] auth_type: The supported authentication type to authenticate and connect to your Confluence instance.
        :param pulumi.Input[_builtins.str] credentials_secret_arn: The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your Confluence instance URL. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see Confluence connection configuration.
        :param pulumi.Input['DataSourceConfluenceSourceConfigurationHostType'] host_type: The supported host type, whether online/cloud or server/on-premises.
        :param pulumi.Input[_builtins.str] host_url: The Confluence host URL or instance URL.
        """
        pulumi.set(__self__, "auth_type", auth_type)
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "host_type", host_type)
        pulumi.set(__self__, "host_url", host_url)

    @_builtins.property
    @pulumi.getter(name="authType")
    def auth_type(self) -> pulumi.Input['DataSourceConfluenceSourceConfigurationAuthType']:
        """
        The supported authentication type to authenticate and connect to your Confluence instance.
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: pulumi.Input['DataSourceConfluenceSourceConfigurationAuthType']):
        pulumi.set(self, "auth_type", value)

    @_builtins.property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your Confluence instance URL. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see Confluence connection configuration.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @credentials_secret_arn.setter
    def credentials_secret_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "credentials_secret_arn", value)

    @_builtins.property
    @pulumi.getter(name="hostType")
    def host_type(self) -> pulumi.Input['DataSourceConfluenceSourceConfigurationHostType']:
        """
        The supported host type, whether online/cloud or server/on-premises.
        """
        return pulumi.get(self, "host_type")

    @host_type.setter
    def host_type(self, value: pulumi.Input['DataSourceConfluenceSourceConfigurationHostType']):
        pulumi.set(self, "host_type", value)

    @_builtins.property
    @pulumi.getter(name="hostUrl")
    def host_url(self) -> pulumi.Input[_builtins.str]:
        """
        The Confluence host URL or instance URL.
        """
        return pulumi.get(self, "host_url")

    @host_url.setter
    def host_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host_url", value)


if not MYPY:
    class DataSourceContextEnrichmentConfigurationArgsDict(TypedDict):
        """
        Additional Enrichment Configuration for example when using GraphRag.
        """
        type: pulumi.Input['DataSourceContextEnrichmentType']
        """
        The method used for context enrichment. It must be Amazon Bedrock foundation models.
        """
        bedrock_foundation_model_configuration: NotRequired[pulumi.Input['DataSourceBedrockFoundationModelContextEnrichmentConfigurationArgsDict']]
        """
        The configuration of the Amazon Bedrock foundation model used for context enrichment.
        """
elif False:
    DataSourceContextEnrichmentConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceContextEnrichmentConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['DataSourceContextEnrichmentType'],
                 bedrock_foundation_model_configuration: Optional[pulumi.Input['DataSourceBedrockFoundationModelContextEnrichmentConfigurationArgs']] = None):
        """
        Additional Enrichment Configuration for example when using GraphRag.
        :param pulumi.Input['DataSourceContextEnrichmentType'] type: The method used for context enrichment. It must be Amazon Bedrock foundation models.
        :param pulumi.Input['DataSourceBedrockFoundationModelContextEnrichmentConfigurationArgs'] bedrock_foundation_model_configuration: The configuration of the Amazon Bedrock foundation model used for context enrichment.
        """
        pulumi.set(__self__, "type", type)
        if bedrock_foundation_model_configuration is not None:
            pulumi.set(__self__, "bedrock_foundation_model_configuration", bedrock_foundation_model_configuration)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['DataSourceContextEnrichmentType']:
        """
        The method used for context enrichment. It must be Amazon Bedrock foundation models.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['DataSourceContextEnrichmentType']):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="bedrockFoundationModelConfiguration")
    def bedrock_foundation_model_configuration(self) -> Optional[pulumi.Input['DataSourceBedrockFoundationModelContextEnrichmentConfigurationArgs']]:
        """
        The configuration of the Amazon Bedrock foundation model used for context enrichment.
        """
        return pulumi.get(self, "bedrock_foundation_model_configuration")

    @bedrock_foundation_model_configuration.setter
    def bedrock_foundation_model_configuration(self, value: Optional[pulumi.Input['DataSourceBedrockFoundationModelContextEnrichmentConfigurationArgs']]):
        pulumi.set(self, "bedrock_foundation_model_configuration", value)


if not MYPY:
    class DataSourceCrawlFilterConfigurationArgsDict(TypedDict):
        """
        The type of filtering that you want to apply to certain objects or content of the data source. For example, the PATTERN type is regular expression patterns you can apply to filter your content.
        """
        type: pulumi.Input['DataSourceCrawlFilterConfigurationType']
        """
        The crawl filter type.
        """
        pattern_object_filter: NotRequired[pulumi.Input['DataSourcePatternObjectFilterConfigurationArgsDict']]
        """
        The configuration of filtering certain objects or content types of the data source.
        """
elif False:
    DataSourceCrawlFilterConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceCrawlFilterConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['DataSourceCrawlFilterConfigurationType'],
                 pattern_object_filter: Optional[pulumi.Input['DataSourcePatternObjectFilterConfigurationArgs']] = None):
        """
        The type of filtering that you want to apply to certain objects or content of the data source. For example, the PATTERN type is regular expression patterns you can apply to filter your content.
        :param pulumi.Input['DataSourceCrawlFilterConfigurationType'] type: The crawl filter type.
        :param pulumi.Input['DataSourcePatternObjectFilterConfigurationArgs'] pattern_object_filter: The configuration of filtering certain objects or content types of the data source.
        """
        pulumi.set(__self__, "type", type)
        if pattern_object_filter is not None:
            pulumi.set(__self__, "pattern_object_filter", pattern_object_filter)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['DataSourceCrawlFilterConfigurationType']:
        """
        The crawl filter type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['DataSourceCrawlFilterConfigurationType']):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="patternObjectFilter")
    def pattern_object_filter(self) -> Optional[pulumi.Input['DataSourcePatternObjectFilterConfigurationArgs']]:
        """
        The configuration of filtering certain objects or content types of the data source.
        """
        return pulumi.get(self, "pattern_object_filter")

    @pattern_object_filter.setter
    def pattern_object_filter(self, value: Optional[pulumi.Input['DataSourcePatternObjectFilterConfigurationArgs']]):
        pulumi.set(self, "pattern_object_filter", value)


if not MYPY:
    class DataSourceCustomTransformationConfigurationArgsDict(TypedDict):
        """
        Settings for customizing steps in the data source content ingestion pipeline.
        """
        intermediate_storage: pulumi.Input['DataSourceIntermediateStorageArgsDict']
        """
        An S3 bucket path for input and output objects.
        """
        transformations: pulumi.Input[Sequence[pulumi.Input['DataSourceTransformationArgsDict']]]
        """
        A list of Lambda functions that process documents.
        """
elif False:
    DataSourceCustomTransformationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceCustomTransformationConfigurationArgs:
    def __init__(__self__, *,
                 intermediate_storage: pulumi.Input['DataSourceIntermediateStorageArgs'],
                 transformations: pulumi.Input[Sequence[pulumi.Input['DataSourceTransformationArgs']]]):
        """
        Settings for customizing steps in the data source content ingestion pipeline.
        :param pulumi.Input['DataSourceIntermediateStorageArgs'] intermediate_storage: An S3 bucket path for input and output objects.
        :param pulumi.Input[Sequence[pulumi.Input['DataSourceTransformationArgs']]] transformations: A list of Lambda functions that process documents.
        """
        pulumi.set(__self__, "intermediate_storage", intermediate_storage)
        pulumi.set(__self__, "transformations", transformations)

    @_builtins.property
    @pulumi.getter(name="intermediateStorage")
    def intermediate_storage(self) -> pulumi.Input['DataSourceIntermediateStorageArgs']:
        """
        An S3 bucket path for input and output objects.
        """
        return pulumi.get(self, "intermediate_storage")

    @intermediate_storage.setter
    def intermediate_storage(self, value: pulumi.Input['DataSourceIntermediateStorageArgs']):
        pulumi.set(self, "intermediate_storage", value)

    @_builtins.property
    @pulumi.getter
    def transformations(self) -> pulumi.Input[Sequence[pulumi.Input['DataSourceTransformationArgs']]]:
        """
        A list of Lambda functions that process documents.
        """
        return pulumi.get(self, "transformations")

    @transformations.setter
    def transformations(self, value: pulumi.Input[Sequence[pulumi.Input['DataSourceTransformationArgs']]]):
        pulumi.set(self, "transformations", value)


if not MYPY:
    class DataSourceEnrichmentStrategyConfigurationArgsDict(TypedDict):
        """
        Strategy to be used when using Bedrock Foundation Model for Context Enrichment.
        """
        method: pulumi.Input['DataSourceEnrichmentStrategyMethod']
        """
        The method used for the context enrichment strategy.
        """
elif False:
    DataSourceEnrichmentStrategyConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceEnrichmentStrategyConfigurationArgs:
    def __init__(__self__, *,
                 method: pulumi.Input['DataSourceEnrichmentStrategyMethod']):
        """
        Strategy to be used when using Bedrock Foundation Model for Context Enrichment.
        :param pulumi.Input['DataSourceEnrichmentStrategyMethod'] method: The method used for the context enrichment strategy.
        """
        pulumi.set(__self__, "method", method)

    @_builtins.property
    @pulumi.getter
    def method(self) -> pulumi.Input['DataSourceEnrichmentStrategyMethod']:
        """
        The method used for the context enrichment strategy.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: pulumi.Input['DataSourceEnrichmentStrategyMethod']):
        pulumi.set(self, "method", value)


if not MYPY:
    class DataSourceFixedSizeChunkingConfigurationArgsDict(TypedDict):
        """
        Configurations for when you choose fixed-size chunking. If you set the chunkingStrategy as NONE, exclude this field.
        """
        max_tokens: pulumi.Input[_builtins.int]
        """
        The maximum number of tokens to include in a chunk.
        """
        overlap_percentage: pulumi.Input[_builtins.int]
        """
        The percentage of overlap between adjacent chunks of a data source.
        """
elif False:
    DataSourceFixedSizeChunkingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceFixedSizeChunkingConfigurationArgs:
    def __init__(__self__, *,
                 max_tokens: pulumi.Input[_builtins.int],
                 overlap_percentage: pulumi.Input[_builtins.int]):
        """
        Configurations for when you choose fixed-size chunking. If you set the chunkingStrategy as NONE, exclude this field.
        :param pulumi.Input[_builtins.int] max_tokens: The maximum number of tokens to include in a chunk.
        :param pulumi.Input[_builtins.int] overlap_percentage: The percentage of overlap between adjacent chunks of a data source.
        """
        pulumi.set(__self__, "max_tokens", max_tokens)
        pulumi.set(__self__, "overlap_percentage", overlap_percentage)

    @_builtins.property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> pulumi.Input[_builtins.int]:
        """
        The maximum number of tokens to include in a chunk.
        """
        return pulumi.get(self, "max_tokens")

    @max_tokens.setter
    def max_tokens(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max_tokens", value)

    @_builtins.property
    @pulumi.getter(name="overlapPercentage")
    def overlap_percentage(self) -> pulumi.Input[_builtins.int]:
        """
        The percentage of overlap between adjacent chunks of a data source.
        """
        return pulumi.get(self, "overlap_percentage")

    @overlap_percentage.setter
    def overlap_percentage(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "overlap_percentage", value)


if not MYPY:
    class DataSourceHierarchicalChunkingConfigurationArgsDict(TypedDict):
        """
        Configurations for when you choose hierarchical chunking. If you set the chunkingStrategy as NONE, exclude this field.
        """
        level_configurations: pulumi.Input[Sequence[pulumi.Input['DataSourceHierarchicalChunkingLevelConfigurationArgsDict']]]
        """
        Token settings for each layer.
        """
        overlap_tokens: pulumi.Input[_builtins.int]
        """
        The number of tokens to repeat across chunks in the same layer.
        """
elif False:
    DataSourceHierarchicalChunkingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceHierarchicalChunkingConfigurationArgs:
    def __init__(__self__, *,
                 level_configurations: pulumi.Input[Sequence[pulumi.Input['DataSourceHierarchicalChunkingLevelConfigurationArgs']]],
                 overlap_tokens: pulumi.Input[_builtins.int]):
        """
        Configurations for when you choose hierarchical chunking. If you set the chunkingStrategy as NONE, exclude this field.
        :param pulumi.Input[Sequence[pulumi.Input['DataSourceHierarchicalChunkingLevelConfigurationArgs']]] level_configurations: Token settings for each layer.
        :param pulumi.Input[_builtins.int] overlap_tokens: The number of tokens to repeat across chunks in the same layer.
        """
        pulumi.set(__self__, "level_configurations", level_configurations)
        pulumi.set(__self__, "overlap_tokens", overlap_tokens)

    @_builtins.property
    @pulumi.getter(name="levelConfigurations")
    def level_configurations(self) -> pulumi.Input[Sequence[pulumi.Input['DataSourceHierarchicalChunkingLevelConfigurationArgs']]]:
        """
        Token settings for each layer.
        """
        return pulumi.get(self, "level_configurations")

    @level_configurations.setter
    def level_configurations(self, value: pulumi.Input[Sequence[pulumi.Input['DataSourceHierarchicalChunkingLevelConfigurationArgs']]]):
        pulumi.set(self, "level_configurations", value)

    @_builtins.property
    @pulumi.getter(name="overlapTokens")
    def overlap_tokens(self) -> pulumi.Input[_builtins.int]:
        """
        The number of tokens to repeat across chunks in the same layer.
        """
        return pulumi.get(self, "overlap_tokens")

    @overlap_tokens.setter
    def overlap_tokens(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "overlap_tokens", value)


if not MYPY:
    class DataSourceHierarchicalChunkingLevelConfigurationArgsDict(TypedDict):
        """
        Token settings for a layer in a hierarchical chunking configuration.
        """
        max_tokens: pulumi.Input[_builtins.int]
        """
        The maximum number of tokens that a chunk can contain in this layer.
        """
elif False:
    DataSourceHierarchicalChunkingLevelConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceHierarchicalChunkingLevelConfigurationArgs:
    def __init__(__self__, *,
                 max_tokens: pulumi.Input[_builtins.int]):
        """
        Token settings for a layer in a hierarchical chunking configuration.
        :param pulumi.Input[_builtins.int] max_tokens: The maximum number of tokens that a chunk can contain in this layer.
        """
        pulumi.set(__self__, "max_tokens", max_tokens)

    @_builtins.property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> pulumi.Input[_builtins.int]:
        """
        The maximum number of tokens that a chunk can contain in this layer.
        """
        return pulumi.get(self, "max_tokens")

    @max_tokens.setter
    def max_tokens(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max_tokens", value)


if not MYPY:
    class DataSourceIntermediateStorageArgsDict(TypedDict):
        """
        A location for storing content from data sources temporarily as it is processed by custom components in the ingestion pipeline.
        """
        s3_location: pulumi.Input['DataSourceS3LocationArgsDict']
        """
        An S3 bucket path.
        """
elif False:
    DataSourceIntermediateStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceIntermediateStorageArgs:
    def __init__(__self__, *,
                 s3_location: pulumi.Input['DataSourceS3LocationArgs']):
        """
        A location for storing content from data sources temporarily as it is processed by custom components in the ingestion pipeline.
        :param pulumi.Input['DataSourceS3LocationArgs'] s3_location: An S3 bucket path.
        """
        pulumi.set(__self__, "s3_location", s3_location)

    @_builtins.property
    @pulumi.getter(name="s3Location")
    def s3_location(self) -> pulumi.Input['DataSourceS3LocationArgs']:
        """
        An S3 bucket path.
        """
        return pulumi.get(self, "s3_location")

    @s3_location.setter
    def s3_location(self, value: pulumi.Input['DataSourceS3LocationArgs']):
        pulumi.set(self, "s3_location", value)


if not MYPY:
    class DataSourceParsingConfigurationArgsDict(TypedDict):
        """
        Settings for parsing document contents
        """
        parsing_strategy: pulumi.Input['DataSourceParsingStrategy']
        """
        The parsing strategy for the data source.
        """
        bedrock_data_automation_configuration: NotRequired[pulumi.Input['DataSourceBedrockDataAutomationConfigurationArgsDict']]
        """
        If you specify `BEDROCK_DATA_AUTOMATION` as the parsing strategy for ingesting your data source, use this object to modify configurations for using the Amazon Bedrock Data Automation parser.
        """
        bedrock_foundation_model_configuration: NotRequired[pulumi.Input['DataSourceBedrockFoundationModelConfigurationArgsDict']]
        """
        If you specify `BEDROCK_FOUNDATION_MODEL` as the parsing strategy for ingesting your data source, use this object to modify configurations for using a foundation model to parse documents.
        """
elif False:
    DataSourceParsingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParsingConfigurationArgs:
    def __init__(__self__, *,
                 parsing_strategy: pulumi.Input['DataSourceParsingStrategy'],
                 bedrock_data_automation_configuration: Optional[pulumi.Input['DataSourceBedrockDataAutomationConfigurationArgs']] = None,
                 bedrock_foundation_model_configuration: Optional[pulumi.Input['DataSourceBedrockFoundationModelConfigurationArgs']] = None):
        """
        Settings for parsing document contents
        :param pulumi.Input['DataSourceParsingStrategy'] parsing_strategy: The parsing strategy for the data source.
        :param pulumi.Input['DataSourceBedrockDataAutomationConfigurationArgs'] bedrock_data_automation_configuration: If you specify `BEDROCK_DATA_AUTOMATION` as the parsing strategy for ingesting your data source, use this object to modify configurations for using the Amazon Bedrock Data Automation parser.
        :param pulumi.Input['DataSourceBedrockFoundationModelConfigurationArgs'] bedrock_foundation_model_configuration: If you specify `BEDROCK_FOUNDATION_MODEL` as the parsing strategy for ingesting your data source, use this object to modify configurations for using a foundation model to parse documents.
        """
        pulumi.set(__self__, "parsing_strategy", parsing_strategy)
        if bedrock_data_automation_configuration is not None:
            pulumi.set(__self__, "bedrock_data_automation_configuration", bedrock_data_automation_configuration)
        if bedrock_foundation_model_configuration is not None:
            pulumi.set(__self__, "bedrock_foundation_model_configuration", bedrock_foundation_model_configuration)

    @_builtins.property
    @pulumi.getter(name="parsingStrategy")
    def parsing_strategy(self) -> pulumi.Input['DataSourceParsingStrategy']:
        """
        The parsing strategy for the data source.
        """
        return pulumi.get(self, "parsing_strategy")

    @parsing_strategy.setter
    def parsing_strategy(self, value: pulumi.Input['DataSourceParsingStrategy']):
        pulumi.set(self, "parsing_strategy", value)

    @_builtins.property
    @pulumi.getter(name="bedrockDataAutomationConfiguration")
    def bedrock_data_automation_configuration(self) -> Optional[pulumi.Input['DataSourceBedrockDataAutomationConfigurationArgs']]:
        """
        If you specify `BEDROCK_DATA_AUTOMATION` as the parsing strategy for ingesting your data source, use this object to modify configurations for using the Amazon Bedrock Data Automation parser.
        """
        return pulumi.get(self, "bedrock_data_automation_configuration")

    @bedrock_data_automation_configuration.setter
    def bedrock_data_automation_configuration(self, value: Optional[pulumi.Input['DataSourceBedrockDataAutomationConfigurationArgs']]):
        pulumi.set(self, "bedrock_data_automation_configuration", value)

    @_builtins.property
    @pulumi.getter(name="bedrockFoundationModelConfiguration")
    def bedrock_foundation_model_configuration(self) -> Optional[pulumi.Input['DataSourceBedrockFoundationModelConfigurationArgs']]:
        """
        If you specify `BEDROCK_FOUNDATION_MODEL` as the parsing strategy for ingesting your data source, use this object to modify configurations for using a foundation model to parse documents.
        """
        return pulumi.get(self, "bedrock_foundation_model_configuration")

    @bedrock_foundation_model_configuration.setter
    def bedrock_foundation_model_configuration(self, value: Optional[pulumi.Input['DataSourceBedrockFoundationModelConfigurationArgs']]):
        pulumi.set(self, "bedrock_foundation_model_configuration", value)


if not MYPY:
    class DataSourceParsingPromptArgsDict(TypedDict):
        """
        Instructions for interpreting the contents of a document.
        """
        parsing_prompt_text: pulumi.Input[_builtins.str]
        """
        Instructions for interpreting the contents of a document.
        """
elif False:
    DataSourceParsingPromptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceParsingPromptArgs:
    def __init__(__self__, *,
                 parsing_prompt_text: pulumi.Input[_builtins.str]):
        """
        Instructions for interpreting the contents of a document.
        :param pulumi.Input[_builtins.str] parsing_prompt_text: Instructions for interpreting the contents of a document.
        """
        pulumi.set(__self__, "parsing_prompt_text", parsing_prompt_text)

    @_builtins.property
    @pulumi.getter(name="parsingPromptText")
    def parsing_prompt_text(self) -> pulumi.Input[_builtins.str]:
        """
        Instructions for interpreting the contents of a document.
        """
        return pulumi.get(self, "parsing_prompt_text")

    @parsing_prompt_text.setter
    def parsing_prompt_text(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "parsing_prompt_text", value)


if not MYPY:
    class DataSourcePatternObjectFilterConfigurationArgsDict(TypedDict):
        """
        The configuration of specific filters applied to your data source content. You can filter out or include certain content.
        """
        filters: pulumi.Input[Sequence[pulumi.Input['DataSourcePatternObjectFilterArgsDict']]]
        """
        The configuration of specific filters applied to your data source content. You can filter out or include certain content.
        """
elif False:
    DataSourcePatternObjectFilterConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourcePatternObjectFilterConfigurationArgs:
    def __init__(__self__, *,
                 filters: pulumi.Input[Sequence[pulumi.Input['DataSourcePatternObjectFilterArgs']]]):
        """
        The configuration of specific filters applied to your data source content. You can filter out or include certain content.
        :param pulumi.Input[Sequence[pulumi.Input['DataSourcePatternObjectFilterArgs']]] filters: The configuration of specific filters applied to your data source content. You can filter out or include certain content.
        """
        pulumi.set(__self__, "filters", filters)

    @_builtins.property
    @pulumi.getter
    def filters(self) -> pulumi.Input[Sequence[pulumi.Input['DataSourcePatternObjectFilterArgs']]]:
        """
        The configuration of specific filters applied to your data source content. You can filter out or include certain content.
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: pulumi.Input[Sequence[pulumi.Input['DataSourcePatternObjectFilterArgs']]]):
        pulumi.set(self, "filters", value)


if not MYPY:
    class DataSourcePatternObjectFilterArgsDict(TypedDict):
        """
        The specific filters applied to your data source content. You can filter out or include certain content.
        """
        object_type: pulumi.Input[_builtins.str]
        """
        The supported object type or content type of the data source.
        """
        exclusion_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        inclusion_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    DataSourcePatternObjectFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourcePatternObjectFilterArgs:
    def __init__(__self__, *,
                 object_type: pulumi.Input[_builtins.str],
                 exclusion_filters: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 inclusion_filters: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        The specific filters applied to your data source content. You can filter out or include certain content.
        :param pulumi.Input[_builtins.str] object_type: The supported object type or content type of the data source.
        """
        pulumi.set(__self__, "object_type", object_type)
        if exclusion_filters is not None:
            pulumi.set(__self__, "exclusion_filters", exclusion_filters)
        if inclusion_filters is not None:
            pulumi.set(__self__, "inclusion_filters", inclusion_filters)

    @_builtins.property
    @pulumi.getter(name="objectType")
    def object_type(self) -> pulumi.Input[_builtins.str]:
        """
        The supported object type or content type of the data source.
        """
        return pulumi.get(self, "object_type")

    @object_type.setter
    def object_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "object_type", value)

    @_builtins.property
    @pulumi.getter(name="exclusionFilters")
    def exclusion_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "exclusion_filters")

    @exclusion_filters.setter
    def exclusion_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclusion_filters", value)

    @_builtins.property
    @pulumi.getter(name="inclusionFilters")
    def inclusion_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "inclusion_filters")

    @inclusion_filters.setter
    def inclusion_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "inclusion_filters", value)


if not MYPY:
    class DataSourceS3DataSourceConfigurationArgsDict(TypedDict):
        """
        The configuration information to connect to Amazon S3 as your data source.
        """
        bucket_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the bucket that contains the data source.
        """
        bucket_owner_account_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The account ID for the owner of the S3 bucket.
        """
        inclusion_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of S3 prefixes that define the object containing the data sources.
        """
elif False:
    DataSourceS3DataSourceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceS3DataSourceConfigurationArgs:
    def __init__(__self__, *,
                 bucket_arn: pulumi.Input[_builtins.str],
                 bucket_owner_account_id: Optional[pulumi.Input[_builtins.str]] = None,
                 inclusion_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        The configuration information to connect to Amazon S3 as your data source.
        :param pulumi.Input[_builtins.str] bucket_arn: The ARN of the bucket that contains the data source.
        :param pulumi.Input[_builtins.str] bucket_owner_account_id: The account ID for the owner of the S3 bucket.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] inclusion_prefixes: A list of S3 prefixes that define the object containing the data sources.
        """
        pulumi.set(__self__, "bucket_arn", bucket_arn)
        if bucket_owner_account_id is not None:
            pulumi.set(__self__, "bucket_owner_account_id", bucket_owner_account_id)
        if inclusion_prefixes is not None:
            pulumi.set(__self__, "inclusion_prefixes", inclusion_prefixes)

    @_builtins.property
    @pulumi.getter(name="bucketArn")
    def bucket_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the bucket that contains the data source.
        """
        return pulumi.get(self, "bucket_arn")

    @bucket_arn.setter
    def bucket_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_arn", value)

    @_builtins.property
    @pulumi.getter(name="bucketOwnerAccountId")
    def bucket_owner_account_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The account ID for the owner of the S3 bucket.
        """
        return pulumi.get(self, "bucket_owner_account_id")

    @bucket_owner_account_id.setter
    def bucket_owner_account_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_owner_account_id", value)

    @_builtins.property
    @pulumi.getter(name="inclusionPrefixes")
    def inclusion_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of S3 prefixes that define the object containing the data sources.
        """
        return pulumi.get(self, "inclusion_prefixes")

    @inclusion_prefixes.setter
    def inclusion_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "inclusion_prefixes", value)


if not MYPY:
    class DataSourceS3LocationArgsDict(TypedDict):
        """
        An Amazon S3 location.
        """
        uri: pulumi.Input[_builtins.str]
        """
        The location's URI
        """
elif False:
    DataSourceS3LocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceS3LocationArgs:
    def __init__(__self__, *,
                 uri: pulumi.Input[_builtins.str]):
        """
        An Amazon S3 location.
        :param pulumi.Input[_builtins.str] uri: The location's URI
        """
        pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> pulumi.Input[_builtins.str]:
        """
        The location's URI
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class DataSourceSalesforceCrawlerConfigurationArgsDict(TypedDict):
        """
        The configuration of filtering the Salesforce content. For example, configuring regular expression patterns to include or exclude certain content.
        """
        filter_configuration: NotRequired[pulumi.Input['DataSourceCrawlFilterConfigurationArgsDict']]
        """
        The configuration of filtering the Salesforce content. For example, configuring regular expression patterns to include or exclude certain content.
        """
elif False:
    DataSourceSalesforceCrawlerConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceSalesforceCrawlerConfigurationArgs:
    def __init__(__self__, *,
                 filter_configuration: Optional[pulumi.Input['DataSourceCrawlFilterConfigurationArgs']] = None):
        """
        The configuration of filtering the Salesforce content. For example, configuring regular expression patterns to include or exclude certain content.
        :param pulumi.Input['DataSourceCrawlFilterConfigurationArgs'] filter_configuration: The configuration of filtering the Salesforce content. For example, configuring regular expression patterns to include or exclude certain content.
        """
        if filter_configuration is not None:
            pulumi.set(__self__, "filter_configuration", filter_configuration)

    @_builtins.property
    @pulumi.getter(name="filterConfiguration")
    def filter_configuration(self) -> Optional[pulumi.Input['DataSourceCrawlFilterConfigurationArgs']]:
        """
        The configuration of filtering the Salesforce content. For example, configuring regular expression patterns to include or exclude certain content.
        """
        return pulumi.get(self, "filter_configuration")

    @filter_configuration.setter
    def filter_configuration(self, value: Optional[pulumi.Input['DataSourceCrawlFilterConfigurationArgs']]):
        pulumi.set(self, "filter_configuration", value)


if not MYPY:
    class DataSourceSalesforceDataSourceConfigurationArgsDict(TypedDict):
        """
        The configuration information to connect to Salesforce as your data source.
        """
        source_configuration: pulumi.Input['DataSourceSalesforceSourceConfigurationArgsDict']
        """
        The endpoint information to connect to your Salesforce data source.
        """
        crawler_configuration: NotRequired[pulumi.Input['DataSourceSalesforceCrawlerConfigurationArgsDict']]
        """
        The configuration of the Salesforce content. For example, configuring specific types of Salesforce content.
        """
elif False:
    DataSourceSalesforceDataSourceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceSalesforceDataSourceConfigurationArgs:
    def __init__(__self__, *,
                 source_configuration: pulumi.Input['DataSourceSalesforceSourceConfigurationArgs'],
                 crawler_configuration: Optional[pulumi.Input['DataSourceSalesforceCrawlerConfigurationArgs']] = None):
        """
        The configuration information to connect to Salesforce as your data source.
        :param pulumi.Input['DataSourceSalesforceSourceConfigurationArgs'] source_configuration: The endpoint information to connect to your Salesforce data source.
        :param pulumi.Input['DataSourceSalesforceCrawlerConfigurationArgs'] crawler_configuration: The configuration of the Salesforce content. For example, configuring specific types of Salesforce content.
        """
        pulumi.set(__self__, "source_configuration", source_configuration)
        if crawler_configuration is not None:
            pulumi.set(__self__, "crawler_configuration", crawler_configuration)

    @_builtins.property
    @pulumi.getter(name="sourceConfiguration")
    def source_configuration(self) -> pulumi.Input['DataSourceSalesforceSourceConfigurationArgs']:
        """
        The endpoint information to connect to your Salesforce data source.
        """
        return pulumi.get(self, "source_configuration")

    @source_configuration.setter
    def source_configuration(self, value: pulumi.Input['DataSourceSalesforceSourceConfigurationArgs']):
        pulumi.set(self, "source_configuration", value)

    @_builtins.property
    @pulumi.getter(name="crawlerConfiguration")
    def crawler_configuration(self) -> Optional[pulumi.Input['DataSourceSalesforceCrawlerConfigurationArgs']]:
        """
        The configuration of the Salesforce content. For example, configuring specific types of Salesforce content.
        """
        return pulumi.get(self, "crawler_configuration")

    @crawler_configuration.setter
    def crawler_configuration(self, value: Optional[pulumi.Input['DataSourceSalesforceCrawlerConfigurationArgs']]):
        pulumi.set(self, "crawler_configuration", value)


if not MYPY:
    class DataSourceSalesforceSourceConfigurationArgsDict(TypedDict):
        """
        The endpoint information to connect to your Salesforce data source.
        """
        auth_type: pulumi.Input['DataSourceSalesforceSourceConfigurationAuthType']
        """
        The supported authentication type to authenticate and connect to your Salesforce instance.
        """
        credentials_secret_arn: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your Salesforce instance URL. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see Salesforce connection configuration.
        """
        host_url: pulumi.Input[_builtins.str]
        """
        The Salesforce host URL or instance URL.
        """
elif False:
    DataSourceSalesforceSourceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceSalesforceSourceConfigurationArgs:
    def __init__(__self__, *,
                 auth_type: pulumi.Input['DataSourceSalesforceSourceConfigurationAuthType'],
                 credentials_secret_arn: pulumi.Input[_builtins.str],
                 host_url: pulumi.Input[_builtins.str]):
        """
        The endpoint information to connect to your Salesforce data source.
        :param pulumi.Input['DataSourceSalesforceSourceConfigurationAuthType'] auth_type: The supported authentication type to authenticate and connect to your Salesforce instance.
        :param pulumi.Input[_builtins.str] credentials_secret_arn: The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your Salesforce instance URL. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see Salesforce connection configuration.
        :param pulumi.Input[_builtins.str] host_url: The Salesforce host URL or instance URL.
        """
        pulumi.set(__self__, "auth_type", auth_type)
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "host_url", host_url)

    @_builtins.property
    @pulumi.getter(name="authType")
    def auth_type(self) -> pulumi.Input['DataSourceSalesforceSourceConfigurationAuthType']:
        """
        The supported authentication type to authenticate and connect to your Salesforce instance.
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: pulumi.Input['DataSourceSalesforceSourceConfigurationAuthType']):
        pulumi.set(self, "auth_type", value)

    @_builtins.property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your Salesforce instance URL. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see Salesforce connection configuration.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @credentials_secret_arn.setter
    def credentials_secret_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "credentials_secret_arn", value)

    @_builtins.property
    @pulumi.getter(name="hostUrl")
    def host_url(self) -> pulumi.Input[_builtins.str]:
        """
        The Salesforce host URL or instance URL.
        """
        return pulumi.get(self, "host_url")

    @host_url.setter
    def host_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host_url", value)


if not MYPY:
    class DataSourceSeedUrlArgsDict(TypedDict):
        """
        A seed url object.
        """
        url: pulumi.Input[_builtins.str]
        """
        A web url.
        """
elif False:
    DataSourceSeedUrlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceSeedUrlArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str]):
        """
        A seed url object.
        :param pulumi.Input[_builtins.str] url: A web url.
        """
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        A web url.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)


if not MYPY:
    class DataSourceSemanticChunkingConfigurationArgsDict(TypedDict):
        """
        Configurations for when you choose semantic chunking. If you set the chunkingStrategy as NONE, exclude this field.
        """
        breakpoint_percentile_threshold: pulumi.Input[_builtins.int]
        """
        The dissimilarity threshold for splitting chunks.
        """
        buffer_size: pulumi.Input[_builtins.int]
        """
        The buffer size.
        """
        max_tokens: pulumi.Input[_builtins.int]
        """
        The maximum number of tokens that a chunk can contain.
        """
elif False:
    DataSourceSemanticChunkingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceSemanticChunkingConfigurationArgs:
    def __init__(__self__, *,
                 breakpoint_percentile_threshold: pulumi.Input[_builtins.int],
                 buffer_size: pulumi.Input[_builtins.int],
                 max_tokens: pulumi.Input[_builtins.int]):
        """
        Configurations for when you choose semantic chunking. If you set the chunkingStrategy as NONE, exclude this field.
        :param pulumi.Input[_builtins.int] breakpoint_percentile_threshold: The dissimilarity threshold for splitting chunks.
        :param pulumi.Input[_builtins.int] buffer_size: The buffer size.
        :param pulumi.Input[_builtins.int] max_tokens: The maximum number of tokens that a chunk can contain.
        """
        pulumi.set(__self__, "breakpoint_percentile_threshold", breakpoint_percentile_threshold)
        pulumi.set(__self__, "buffer_size", buffer_size)
        pulumi.set(__self__, "max_tokens", max_tokens)

    @_builtins.property
    @pulumi.getter(name="breakpointPercentileThreshold")
    def breakpoint_percentile_threshold(self) -> pulumi.Input[_builtins.int]:
        """
        The dissimilarity threshold for splitting chunks.
        """
        return pulumi.get(self, "breakpoint_percentile_threshold")

    @breakpoint_percentile_threshold.setter
    def breakpoint_percentile_threshold(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "breakpoint_percentile_threshold", value)

    @_builtins.property
    @pulumi.getter(name="bufferSize")
    def buffer_size(self) -> pulumi.Input[_builtins.int]:
        """
        The buffer size.
        """
        return pulumi.get(self, "buffer_size")

    @buffer_size.setter
    def buffer_size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "buffer_size", value)

    @_builtins.property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> pulumi.Input[_builtins.int]:
        """
        The maximum number of tokens that a chunk can contain.
        """
        return pulumi.get(self, "max_tokens")

    @max_tokens.setter
    def max_tokens(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max_tokens", value)


if not MYPY:
    class DataSourceServerSideEncryptionConfigurationArgsDict(TypedDict):
        """
        Contains details about the server-side encryption for the data source.
        """
        kms_key_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ARN of the AWS KMS key used to encrypt the resource.
        """
elif False:
    DataSourceServerSideEncryptionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceServerSideEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 kms_key_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Contains details about the server-side encryption for the data source.
        :param pulumi.Input[_builtins.str] kms_key_arn: The ARN of the AWS KMS key used to encrypt the resource.
        """
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ARN of the AWS KMS key used to encrypt the resource.
        """
        return pulumi.get(self, "kms_key_arn")

    @kms_key_arn.setter
    def kms_key_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_arn", value)


if not MYPY:
    class DataSourceSharePointCrawlerConfigurationArgsDict(TypedDict):
        """
        The configuration of the SharePoint content. For example, configuring specific types of SharePoint content.
        """
        filter_configuration: NotRequired[pulumi.Input['DataSourceCrawlFilterConfigurationArgsDict']]
        """
        The configuration of filtering the SharePoint content. For example, configuring regular expression patterns to include or exclude certain content.
        """
elif False:
    DataSourceSharePointCrawlerConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceSharePointCrawlerConfigurationArgs:
    def __init__(__self__, *,
                 filter_configuration: Optional[pulumi.Input['DataSourceCrawlFilterConfigurationArgs']] = None):
        """
        The configuration of the SharePoint content. For example, configuring specific types of SharePoint content.
        :param pulumi.Input['DataSourceCrawlFilterConfigurationArgs'] filter_configuration: The configuration of filtering the SharePoint content. For example, configuring regular expression patterns to include or exclude certain content.
        """
        if filter_configuration is not None:
            pulumi.set(__self__, "filter_configuration", filter_configuration)

    @_builtins.property
    @pulumi.getter(name="filterConfiguration")
    def filter_configuration(self) -> Optional[pulumi.Input['DataSourceCrawlFilterConfigurationArgs']]:
        """
        The configuration of filtering the SharePoint content. For example, configuring regular expression patterns to include or exclude certain content.
        """
        return pulumi.get(self, "filter_configuration")

    @filter_configuration.setter
    def filter_configuration(self, value: Optional[pulumi.Input['DataSourceCrawlFilterConfigurationArgs']]):
        pulumi.set(self, "filter_configuration", value)


if not MYPY:
    class DataSourceSharePointDataSourceConfigurationArgsDict(TypedDict):
        """
        The configuration information to connect to SharePoint as your data source.
        """
        source_configuration: pulumi.Input['DataSourceSharePointSourceConfigurationArgsDict']
        """
        The endpoint information to connect to your SharePoint data source.
        """
        crawler_configuration: NotRequired[pulumi.Input['DataSourceSharePointCrawlerConfigurationArgsDict']]
        """
        The configuration of the SharePoint content. For example, configuring specific types of SharePoint content.
        """
elif False:
    DataSourceSharePointDataSourceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceSharePointDataSourceConfigurationArgs:
    def __init__(__self__, *,
                 source_configuration: pulumi.Input['DataSourceSharePointSourceConfigurationArgs'],
                 crawler_configuration: Optional[pulumi.Input['DataSourceSharePointCrawlerConfigurationArgs']] = None):
        """
        The configuration information to connect to SharePoint as your data source.
        :param pulumi.Input['DataSourceSharePointSourceConfigurationArgs'] source_configuration: The endpoint information to connect to your SharePoint data source.
        :param pulumi.Input['DataSourceSharePointCrawlerConfigurationArgs'] crawler_configuration: The configuration of the SharePoint content. For example, configuring specific types of SharePoint content.
        """
        pulumi.set(__self__, "source_configuration", source_configuration)
        if crawler_configuration is not None:
            pulumi.set(__self__, "crawler_configuration", crawler_configuration)

    @_builtins.property
    @pulumi.getter(name="sourceConfiguration")
    def source_configuration(self) -> pulumi.Input['DataSourceSharePointSourceConfigurationArgs']:
        """
        The endpoint information to connect to your SharePoint data source.
        """
        return pulumi.get(self, "source_configuration")

    @source_configuration.setter
    def source_configuration(self, value: pulumi.Input['DataSourceSharePointSourceConfigurationArgs']):
        pulumi.set(self, "source_configuration", value)

    @_builtins.property
    @pulumi.getter(name="crawlerConfiguration")
    def crawler_configuration(self) -> Optional[pulumi.Input['DataSourceSharePointCrawlerConfigurationArgs']]:
        """
        The configuration of the SharePoint content. For example, configuring specific types of SharePoint content.
        """
        return pulumi.get(self, "crawler_configuration")

    @crawler_configuration.setter
    def crawler_configuration(self, value: Optional[pulumi.Input['DataSourceSharePointCrawlerConfigurationArgs']]):
        pulumi.set(self, "crawler_configuration", value)


if not MYPY:
    class DataSourceSharePointSourceConfigurationArgsDict(TypedDict):
        """
        The endpoint information to connect to your SharePoint data source.
        """
        auth_type: pulumi.Input['DataSourceSharePointSourceConfigurationAuthType']
        """
        The supported authentication type to authenticate and connect to your SharePoint site/sites.
        """
        credentials_secret_arn: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your SharePoint site/sites. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see SharePoint connection configuration.
        """
        domain: pulumi.Input[_builtins.str]
        """
        The domain of your SharePoint instance or site URL/URLs.
        """
        host_type: pulumi.Input['DataSourceSharePointSourceConfigurationHostType']
        """
        The supported host type, whether online/cloud or server/on-premises.
        """
        site_urls: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        A list of one or more SharePoint site URLs.
        """
        tenant_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The identifier of your Microsoft 365 tenant.
        """
elif False:
    DataSourceSharePointSourceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceSharePointSourceConfigurationArgs:
    def __init__(__self__, *,
                 auth_type: pulumi.Input['DataSourceSharePointSourceConfigurationAuthType'],
                 credentials_secret_arn: pulumi.Input[_builtins.str],
                 domain: pulumi.Input[_builtins.str],
                 host_type: pulumi.Input['DataSourceSharePointSourceConfigurationHostType'],
                 site_urls: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 tenant_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The endpoint information to connect to your SharePoint data source.
        :param pulumi.Input['DataSourceSharePointSourceConfigurationAuthType'] auth_type: The supported authentication type to authenticate and connect to your SharePoint site/sites.
        :param pulumi.Input[_builtins.str] credentials_secret_arn: The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your SharePoint site/sites. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see SharePoint connection configuration.
        :param pulumi.Input[_builtins.str] domain: The domain of your SharePoint instance or site URL/URLs.
        :param pulumi.Input['DataSourceSharePointSourceConfigurationHostType'] host_type: The supported host type, whether online/cloud or server/on-premises.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] site_urls: A list of one or more SharePoint site URLs.
        :param pulumi.Input[_builtins.str] tenant_id: The identifier of your Microsoft 365 tenant.
        """
        pulumi.set(__self__, "auth_type", auth_type)
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "host_type", host_type)
        pulumi.set(__self__, "site_urls", site_urls)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter(name="authType")
    def auth_type(self) -> pulumi.Input['DataSourceSharePointSourceConfigurationAuthType']:
        """
        The supported authentication type to authenticate and connect to your SharePoint site/sites.
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: pulumi.Input['DataSourceSharePointSourceConfigurationAuthType']):
        pulumi.set(self, "auth_type", value)

    @_builtins.property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your SharePoint site/sites. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see SharePoint connection configuration.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @credentials_secret_arn.setter
    def credentials_secret_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "credentials_secret_arn", value)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> pulumi.Input[_builtins.str]:
        """
        The domain of your SharePoint instance or site URL/URLs.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain", value)

    @_builtins.property
    @pulumi.getter(name="hostType")
    def host_type(self) -> pulumi.Input['DataSourceSharePointSourceConfigurationHostType']:
        """
        The supported host type, whether online/cloud or server/on-premises.
        """
        return pulumi.get(self, "host_type")

    @host_type.setter
    def host_type(self, value: pulumi.Input['DataSourceSharePointSourceConfigurationHostType']):
        pulumi.set(self, "host_type", value)

    @_builtins.property
    @pulumi.getter(name="siteUrls")
    def site_urls(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        A list of one or more SharePoint site URLs.
        """
        return pulumi.get(self, "site_urls")

    @site_urls.setter
    def site_urls(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "site_urls", value)

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The identifier of your Microsoft 365 tenant.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class DataSourceTransformationFunctionArgsDict(TypedDict):
        """
        A Lambda function that processes documents.
        """
        transformation_lambda_configuration: pulumi.Input['DataSourceTransformationLambdaConfigurationArgsDict']
        """
        The Lambda function.
        """
elif False:
    DataSourceTransformationFunctionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceTransformationFunctionArgs:
    def __init__(__self__, *,
                 transformation_lambda_configuration: pulumi.Input['DataSourceTransformationLambdaConfigurationArgs']):
        """
        A Lambda function that processes documents.
        :param pulumi.Input['DataSourceTransformationLambdaConfigurationArgs'] transformation_lambda_configuration: The Lambda function.
        """
        pulumi.set(__self__, "transformation_lambda_configuration", transformation_lambda_configuration)

    @_builtins.property
    @pulumi.getter(name="transformationLambdaConfiguration")
    def transformation_lambda_configuration(self) -> pulumi.Input['DataSourceTransformationLambdaConfigurationArgs']:
        """
        The Lambda function.
        """
        return pulumi.get(self, "transformation_lambda_configuration")

    @transformation_lambda_configuration.setter
    def transformation_lambda_configuration(self, value: pulumi.Input['DataSourceTransformationLambdaConfigurationArgs']):
        pulumi.set(self, "transformation_lambda_configuration", value)


if not MYPY:
    class DataSourceTransformationLambdaConfigurationArgsDict(TypedDict):
        """
        A Lambda function that processes documents.
        """
        lambda_arn: pulumi.Input[_builtins.str]
        """
        The function's ARN identifier.
        """
elif False:
    DataSourceTransformationLambdaConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceTransformationLambdaConfigurationArgs:
    def __init__(__self__, *,
                 lambda_arn: pulumi.Input[_builtins.str]):
        """
        A Lambda function that processes documents.
        :param pulumi.Input[_builtins.str] lambda_arn: The function's ARN identifier.
        """
        pulumi.set(__self__, "lambda_arn", lambda_arn)

    @_builtins.property
    @pulumi.getter(name="lambdaArn")
    def lambda_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The function's ARN identifier.
        """
        return pulumi.get(self, "lambda_arn")

    @lambda_arn.setter
    def lambda_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "lambda_arn", value)


if not MYPY:
    class DataSourceTransformationArgsDict(TypedDict):
        """
        A Lambda function that processes documents.
        """
        step_to_apply: pulumi.Input['DataSourceTransformationStepToApply']
        """
        When the service applies the transformation.
        """
        transformation_function: pulumi.Input['DataSourceTransformationFunctionArgsDict']
        """
        A Lambda function that processes documents.
        """
elif False:
    DataSourceTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceTransformationArgs:
    def __init__(__self__, *,
                 step_to_apply: pulumi.Input['DataSourceTransformationStepToApply'],
                 transformation_function: pulumi.Input['DataSourceTransformationFunctionArgs']):
        """
        A Lambda function that processes documents.
        :param pulumi.Input['DataSourceTransformationStepToApply'] step_to_apply: When the service applies the transformation.
        :param pulumi.Input['DataSourceTransformationFunctionArgs'] transformation_function: A Lambda function that processes documents.
        """
        pulumi.set(__self__, "step_to_apply", step_to_apply)
        pulumi.set(__self__, "transformation_function", transformation_function)

    @_builtins.property
    @pulumi.getter(name="stepToApply")
    def step_to_apply(self) -> pulumi.Input['DataSourceTransformationStepToApply']:
        """
        When the service applies the transformation.
        """
        return pulumi.get(self, "step_to_apply")

    @step_to_apply.setter
    def step_to_apply(self, value: pulumi.Input['DataSourceTransformationStepToApply']):
        pulumi.set(self, "step_to_apply", value)

    @_builtins.property
    @pulumi.getter(name="transformationFunction")
    def transformation_function(self) -> pulumi.Input['DataSourceTransformationFunctionArgs']:
        """
        A Lambda function that processes documents.
        """
        return pulumi.get(self, "transformation_function")

    @transformation_function.setter
    def transformation_function(self, value: pulumi.Input['DataSourceTransformationFunctionArgs']):
        pulumi.set(self, "transformation_function", value)


if not MYPY:
    class DataSourceUrlConfigurationArgsDict(TypedDict):
        """
        A url configuration.
        """
        seed_urls: pulumi.Input[Sequence[pulumi.Input['DataSourceSeedUrlArgsDict']]]
        """
        One or more seed or starting point URLs.
        """
elif False:
    DataSourceUrlConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceUrlConfigurationArgs:
    def __init__(__self__, *,
                 seed_urls: pulumi.Input[Sequence[pulumi.Input['DataSourceSeedUrlArgs']]]):
        """
        A url configuration.
        :param pulumi.Input[Sequence[pulumi.Input['DataSourceSeedUrlArgs']]] seed_urls: One or more seed or starting point URLs.
        """
        pulumi.set(__self__, "seed_urls", seed_urls)

    @_builtins.property
    @pulumi.getter(name="seedUrls")
    def seed_urls(self) -> pulumi.Input[Sequence[pulumi.Input['DataSourceSeedUrlArgs']]]:
        """
        One or more seed or starting point URLs.
        """
        return pulumi.get(self, "seed_urls")

    @seed_urls.setter
    def seed_urls(self, value: pulumi.Input[Sequence[pulumi.Input['DataSourceSeedUrlArgs']]]):
        pulumi.set(self, "seed_urls", value)


if not MYPY:
    class DataSourceVectorIngestionConfigurationArgsDict(TypedDict):
        """
        Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried.
        """
        chunking_configuration: NotRequired[pulumi.Input['DataSourceChunkingConfigurationArgsDict']]
        """
        Details about how to chunk the documents in the data source. A *chunk* refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried.
        """
        context_enrichment_configuration: NotRequired[pulumi.Input['DataSourceContextEnrichmentConfigurationArgsDict']]
        """
        The context enrichment configuration used for ingestion of the data into the vector store.
        """
        custom_transformation_configuration: NotRequired[pulumi.Input['DataSourceCustomTransformationConfigurationArgsDict']]
        """
        A custom document transformer for parsed data source documents.
        """
        parsing_configuration: NotRequired[pulumi.Input['DataSourceParsingConfigurationArgsDict']]
        """
        Configurations for a parser to use for parsing documents in your data source. If you exclude this field, the default parser will be used.
        """
elif False:
    DataSourceVectorIngestionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceVectorIngestionConfigurationArgs:
    def __init__(__self__, *,
                 chunking_configuration: Optional[pulumi.Input['DataSourceChunkingConfigurationArgs']] = None,
                 context_enrichment_configuration: Optional[pulumi.Input['DataSourceContextEnrichmentConfigurationArgs']] = None,
                 custom_transformation_configuration: Optional[pulumi.Input['DataSourceCustomTransformationConfigurationArgs']] = None,
                 parsing_configuration: Optional[pulumi.Input['DataSourceParsingConfigurationArgs']] = None):
        """
        Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried.
        :param pulumi.Input['DataSourceChunkingConfigurationArgs'] chunking_configuration: Details about how to chunk the documents in the data source. A *chunk* refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried.
        :param pulumi.Input['DataSourceContextEnrichmentConfigurationArgs'] context_enrichment_configuration: The context enrichment configuration used for ingestion of the data into the vector store.
        :param pulumi.Input['DataSourceCustomTransformationConfigurationArgs'] custom_transformation_configuration: A custom document transformer for parsed data source documents.
        :param pulumi.Input['DataSourceParsingConfigurationArgs'] parsing_configuration: Configurations for a parser to use for parsing documents in your data source. If you exclude this field, the default parser will be used.
        """
        if chunking_configuration is not None:
            pulumi.set(__self__, "chunking_configuration", chunking_configuration)
        if context_enrichment_configuration is not None:
            pulumi.set(__self__, "context_enrichment_configuration", context_enrichment_configuration)
        if custom_transformation_configuration is not None:
            pulumi.set(__self__, "custom_transformation_configuration", custom_transformation_configuration)
        if parsing_configuration is not None:
            pulumi.set(__self__, "parsing_configuration", parsing_configuration)

    @_builtins.property
    @pulumi.getter(name="chunkingConfiguration")
    def chunking_configuration(self) -> Optional[pulumi.Input['DataSourceChunkingConfigurationArgs']]:
        """
        Details about how to chunk the documents in the data source. A *chunk* refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried.
        """
        return pulumi.get(self, "chunking_configuration")

    @chunking_configuration.setter
    def chunking_configuration(self, value: Optional[pulumi.Input['DataSourceChunkingConfigurationArgs']]):
        pulumi.set(self, "chunking_configuration", value)

    @_builtins.property
    @pulumi.getter(name="contextEnrichmentConfiguration")
    def context_enrichment_configuration(self) -> Optional[pulumi.Input['DataSourceContextEnrichmentConfigurationArgs']]:
        """
        The context enrichment configuration used for ingestion of the data into the vector store.
        """
        return pulumi.get(self, "context_enrichment_configuration")

    @context_enrichment_configuration.setter
    def context_enrichment_configuration(self, value: Optional[pulumi.Input['DataSourceContextEnrichmentConfigurationArgs']]):
        pulumi.set(self, "context_enrichment_configuration", value)

    @_builtins.property
    @pulumi.getter(name="customTransformationConfiguration")
    def custom_transformation_configuration(self) -> Optional[pulumi.Input['DataSourceCustomTransformationConfigurationArgs']]:
        """
        A custom document transformer for parsed data source documents.
        """
        return pulumi.get(self, "custom_transformation_configuration")

    @custom_transformation_configuration.setter
    def custom_transformation_configuration(self, value: Optional[pulumi.Input['DataSourceCustomTransformationConfigurationArgs']]):
        pulumi.set(self, "custom_transformation_configuration", value)

    @_builtins.property
    @pulumi.getter(name="parsingConfiguration")
    def parsing_configuration(self) -> Optional[pulumi.Input['DataSourceParsingConfigurationArgs']]:
        """
        Configurations for a parser to use for parsing documents in your data source. If you exclude this field, the default parser will be used.
        """
        return pulumi.get(self, "parsing_configuration")

    @parsing_configuration.setter
    def parsing_configuration(self, value: Optional[pulumi.Input['DataSourceParsingConfigurationArgs']]):
        pulumi.set(self, "parsing_configuration", value)


if not MYPY:
    class DataSourceWebCrawlerConfigurationArgsDict(TypedDict):
        """
        Configuration for the web crawler.
        """
        crawler_limits: NotRequired[pulumi.Input['DataSourceWebCrawlerLimitsArgsDict']]
        """
        The configuration of crawl limits for the web URLs.
        """
        exclusion_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of one or more exclusion regular expression patterns to exclude certain URLs. If you specify an inclusion and exclusion filter/pattern and both match a URL, the exclusion filter takes precedence and the web content of the URL isnt crawled.
        """
        inclusion_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of one or more inclusion regular expression patterns to include certain URLs. If you specify an inclusion and exclusion filter/pattern and both match a URL, the exclusion filter takes precedence and the web content of the URL isnt crawled.
        """
        scope: NotRequired[pulumi.Input['DataSourceWebScopeType']]
        """
        The scope of what is crawled for your URLs.

        You can choose to crawl only web pages that belong to the same host or primary domain. For example, only web pages that contain the seed URL "https://docs.aws.amazon.com/bedrock/latest/userguide/" and no other domains. You can choose to include sub domains in addition to the host or primary domain. For example, web pages that contain "aws.amazon.com" can also include sub domain "docs.aws.amazon.com".
        """
        user_agent: NotRequired[pulumi.Input[_builtins.str]]
        """
        The suffix that will be included in the user agent header.
        """
        user_agent_header: NotRequired[pulumi.Input[_builtins.str]]
        """
        The full user agent header, including UUID and suffix.
        """
elif False:
    DataSourceWebCrawlerConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceWebCrawlerConfigurationArgs:
    def __init__(__self__, *,
                 crawler_limits: Optional[pulumi.Input['DataSourceWebCrawlerLimitsArgs']] = None,
                 exclusion_filters: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 inclusion_filters: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 scope: Optional[pulumi.Input['DataSourceWebScopeType']] = None,
                 user_agent: Optional[pulumi.Input[_builtins.str]] = None,
                 user_agent_header: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Configuration for the web crawler.
        :param pulumi.Input['DataSourceWebCrawlerLimitsArgs'] crawler_limits: The configuration of crawl limits for the web URLs.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclusion_filters: A list of one or more exclusion regular expression patterns to exclude certain URLs. If you specify an inclusion and exclusion filter/pattern and both match a URL, the exclusion filter takes precedence and the web content of the URL isnt crawled.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] inclusion_filters: A list of one or more inclusion regular expression patterns to include certain URLs. If you specify an inclusion and exclusion filter/pattern and both match a URL, the exclusion filter takes precedence and the web content of the URL isnt crawled.
        :param pulumi.Input['DataSourceWebScopeType'] scope: The scope of what is crawled for your URLs.
               
               You can choose to crawl only web pages that belong to the same host or primary domain. For example, only web pages that contain the seed URL "https://docs.aws.amazon.com/bedrock/latest/userguide/" and no other domains. You can choose to include sub domains in addition to the host or primary domain. For example, web pages that contain "aws.amazon.com" can also include sub domain "docs.aws.amazon.com".
        :param pulumi.Input[_builtins.str] user_agent: The suffix that will be included in the user agent header.
        :param pulumi.Input[_builtins.str] user_agent_header: The full user agent header, including UUID and suffix.
        """
        if crawler_limits is not None:
            pulumi.set(__self__, "crawler_limits", crawler_limits)
        if exclusion_filters is not None:
            pulumi.set(__self__, "exclusion_filters", exclusion_filters)
        if inclusion_filters is not None:
            pulumi.set(__self__, "inclusion_filters", inclusion_filters)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if user_agent is not None:
            pulumi.set(__self__, "user_agent", user_agent)
        if user_agent_header is not None:
            pulumi.set(__self__, "user_agent_header", user_agent_header)

    @_builtins.property
    @pulumi.getter(name="crawlerLimits")
    def crawler_limits(self) -> Optional[pulumi.Input['DataSourceWebCrawlerLimitsArgs']]:
        """
        The configuration of crawl limits for the web URLs.
        """
        return pulumi.get(self, "crawler_limits")

    @crawler_limits.setter
    def crawler_limits(self, value: Optional[pulumi.Input['DataSourceWebCrawlerLimitsArgs']]):
        pulumi.set(self, "crawler_limits", value)

    @_builtins.property
    @pulumi.getter(name="exclusionFilters")
    def exclusion_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of one or more exclusion regular expression patterns to exclude certain URLs. If you specify an inclusion and exclusion filter/pattern and both match a URL, the exclusion filter takes precedence and the web content of the URL isnt crawled.
        """
        return pulumi.get(self, "exclusion_filters")

    @exclusion_filters.setter
    def exclusion_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclusion_filters", value)

    @_builtins.property
    @pulumi.getter(name="inclusionFilters")
    def inclusion_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of one or more inclusion regular expression patterns to include certain URLs. If you specify an inclusion and exclusion filter/pattern and both match a URL, the exclusion filter takes precedence and the web content of the URL isnt crawled.
        """
        return pulumi.get(self, "inclusion_filters")

    @inclusion_filters.setter
    def inclusion_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "inclusion_filters", value)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input['DataSourceWebScopeType']]:
        """
        The scope of what is crawled for your URLs.

        You can choose to crawl only web pages that belong to the same host or primary domain. For example, only web pages that contain the seed URL "https://docs.aws.amazon.com/bedrock/latest/userguide/" and no other domains. You can choose to include sub domains in addition to the host or primary domain. For example, web pages that contain "aws.amazon.com" can also include sub domain "docs.aws.amazon.com".
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input['DataSourceWebScopeType']]):
        pulumi.set(self, "scope", value)

    @_builtins.property
    @pulumi.getter(name="userAgent")
    def user_agent(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The suffix that will be included in the user agent header.
        """
        return pulumi.get(self, "user_agent")

    @user_agent.setter
    def user_agent(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_agent", value)

    @_builtins.property
    @pulumi.getter(name="userAgentHeader")
    def user_agent_header(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The full user agent header, including UUID and suffix.
        """
        return pulumi.get(self, "user_agent_header")

    @user_agent_header.setter
    def user_agent_header(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_agent_header", value)


if not MYPY:
    class DataSourceWebCrawlerLimitsArgsDict(TypedDict):
        """
        Limit settings for the web crawler.
        """
        max_pages: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum number of pages the crawler can crawl.
        """
        rate_limit: NotRequired[pulumi.Input[_builtins.int]]
        """
        Rate of web URLs retrieved per minute.
        """
elif False:
    DataSourceWebCrawlerLimitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceWebCrawlerLimitsArgs:
    def __init__(__self__, *,
                 max_pages: Optional[pulumi.Input[_builtins.int]] = None,
                 rate_limit: Optional[pulumi.Input[_builtins.int]] = None):
        """
        Limit settings for the web crawler.
        :param pulumi.Input[_builtins.int] max_pages: Maximum number of pages the crawler can crawl.
        :param pulumi.Input[_builtins.int] rate_limit: Rate of web URLs retrieved per minute.
        """
        if max_pages is not None:
            pulumi.set(__self__, "max_pages", max_pages)
        if rate_limit is not None:
            pulumi.set(__self__, "rate_limit", rate_limit)

    @_builtins.property
    @pulumi.getter(name="maxPages")
    def max_pages(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum number of pages the crawler can crawl.
        """
        return pulumi.get(self, "max_pages")

    @max_pages.setter
    def max_pages(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_pages", value)

    @_builtins.property
    @pulumi.getter(name="rateLimit")
    def rate_limit(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Rate of web URLs retrieved per minute.
        """
        return pulumi.get(self, "rate_limit")

    @rate_limit.setter
    def rate_limit(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "rate_limit", value)


if not MYPY:
    class DataSourceWebDataSourceConfigurationArgsDict(TypedDict):
        """
        Configures a web data source location.
        """
        source_configuration: pulumi.Input['DataSourceWebSourceConfigurationArgsDict']
        """
        The source configuration details for the web data source.
        """
        crawler_configuration: NotRequired[pulumi.Input['DataSourceWebCrawlerConfigurationArgsDict']]
        """
        The Web Crawler configuration details for the web data source.
        """
elif False:
    DataSourceWebDataSourceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceWebDataSourceConfigurationArgs:
    def __init__(__self__, *,
                 source_configuration: pulumi.Input['DataSourceWebSourceConfigurationArgs'],
                 crawler_configuration: Optional[pulumi.Input['DataSourceWebCrawlerConfigurationArgs']] = None):
        """
        Configures a web data source location.
        :param pulumi.Input['DataSourceWebSourceConfigurationArgs'] source_configuration: The source configuration details for the web data source.
        :param pulumi.Input['DataSourceWebCrawlerConfigurationArgs'] crawler_configuration: The Web Crawler configuration details for the web data source.
        """
        pulumi.set(__self__, "source_configuration", source_configuration)
        if crawler_configuration is not None:
            pulumi.set(__self__, "crawler_configuration", crawler_configuration)

    @_builtins.property
    @pulumi.getter(name="sourceConfiguration")
    def source_configuration(self) -> pulumi.Input['DataSourceWebSourceConfigurationArgs']:
        """
        The source configuration details for the web data source.
        """
        return pulumi.get(self, "source_configuration")

    @source_configuration.setter
    def source_configuration(self, value: pulumi.Input['DataSourceWebSourceConfigurationArgs']):
        pulumi.set(self, "source_configuration", value)

    @_builtins.property
    @pulumi.getter(name="crawlerConfiguration")
    def crawler_configuration(self) -> Optional[pulumi.Input['DataSourceWebCrawlerConfigurationArgs']]:
        """
        The Web Crawler configuration details for the web data source.
        """
        return pulumi.get(self, "crawler_configuration")

    @crawler_configuration.setter
    def crawler_configuration(self, value: Optional[pulumi.Input['DataSourceWebCrawlerConfigurationArgs']]):
        pulumi.set(self, "crawler_configuration", value)


if not MYPY:
    class DataSourceWebSourceConfigurationArgsDict(TypedDict):
        """
        A web source configuration.
        """
        url_configuration: pulumi.Input['DataSourceUrlConfigurationArgsDict']
        """
        The configuration of the URL/URLs.
        """
elif False:
    DataSourceWebSourceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataSourceWebSourceConfigurationArgs:
    def __init__(__self__, *,
                 url_configuration: pulumi.Input['DataSourceUrlConfigurationArgs']):
        """
        A web source configuration.
        :param pulumi.Input['DataSourceUrlConfigurationArgs'] url_configuration: The configuration of the URL/URLs.
        """
        pulumi.set(__self__, "url_configuration", url_configuration)

    @_builtins.property
    @pulumi.getter(name="urlConfiguration")
    def url_configuration(self) -> pulumi.Input['DataSourceUrlConfigurationArgs']:
        """
        The configuration of the URL/URLs.
        """
        return pulumi.get(self, "url_configuration")

    @url_configuration.setter
    def url_configuration(self, value: pulumi.Input['DataSourceUrlConfigurationArgs']):
        pulumi.set(self, "url_configuration", value)


if not MYPY:
    class FlowAdditionalModelRequestFieldsArgsDict(TypedDict):
        pass
elif False:
    FlowAdditionalModelRequestFieldsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowAdditionalModelRequestFieldsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class FlowAgentFlowNodeConfigurationArgsDict(TypedDict):
        """
        Agent flow node configuration
        """
        agent_alias_arn: pulumi.Input[_builtins.str]
        """
        Arn representation of the Agent Alias.
        """
elif False:
    FlowAgentFlowNodeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowAgentFlowNodeConfigurationArgs:
    def __init__(__self__, *,
                 agent_alias_arn: pulumi.Input[_builtins.str]):
        """
        Agent flow node configuration
        :param pulumi.Input[_builtins.str] agent_alias_arn: Arn representation of the Agent Alias.
        """
        pulumi.set(__self__, "agent_alias_arn", agent_alias_arn)

    @_builtins.property
    @pulumi.getter(name="agentAliasArn")
    def agent_alias_arn(self) -> pulumi.Input[_builtins.str]:
        """
        Arn representation of the Agent Alias.
        """
        return pulumi.get(self, "agent_alias_arn")

    @agent_alias_arn.setter
    def agent_alias_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "agent_alias_arn", value)


if not MYPY:
    class FlowAliasConcurrencyConfigurationArgsDict(TypedDict):
        type: pulumi.Input['FlowAliasConcurrencyType']
        """
        The type of concurrency to use for parallel node execution. Specify one of the following options:

        - `Automatic` - Amazon Bedrock determines which nodes can be executed in parallel based on the flow definition and its dependencies.
        - `Manual` - You specify which nodes can be executed in parallel.
        """
        max_concurrency: NotRequired[pulumi.Input[_builtins.float]]
        """
        Number of nodes executed concurrently at a time
        """
elif False:
    FlowAliasConcurrencyConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowAliasConcurrencyConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['FlowAliasConcurrencyType'],
                 max_concurrency: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input['FlowAliasConcurrencyType'] type: The type of concurrency to use for parallel node execution. Specify one of the following options:
               
               - `Automatic` - Amazon Bedrock determines which nodes can be executed in parallel based on the flow definition and its dependencies.
               - `Manual` - You specify which nodes can be executed in parallel.
        :param pulumi.Input[_builtins.float] max_concurrency: Number of nodes executed concurrently at a time
        """
        pulumi.set(__self__, "type", type)
        if max_concurrency is not None:
            pulumi.set(__self__, "max_concurrency", max_concurrency)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['FlowAliasConcurrencyType']:
        """
        The type of concurrency to use for parallel node execution. Specify one of the following options:

        - `Automatic` - Amazon Bedrock determines which nodes can be executed in parallel based on the flow definition and its dependencies.
        - `Manual` - You specify which nodes can be executed in parallel.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['FlowAliasConcurrencyType']):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="maxConcurrency")
    def max_concurrency(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Number of nodes executed concurrently at a time
        """
        return pulumi.get(self, "max_concurrency")

    @max_concurrency.setter
    def max_concurrency(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "max_concurrency", value)


if not MYPY:
    class FlowAliasRoutingConfigurationListItemArgsDict(TypedDict):
        """
        Details about the routing configuration for a Flow alias.
        """
        flow_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Version.
        """
elif False:
    FlowAliasRoutingConfigurationListItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowAliasRoutingConfigurationListItemArgs:
    def __init__(__self__, *,
                 flow_version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Details about the routing configuration for a Flow alias.
        :param pulumi.Input[_builtins.str] flow_version: Version.
        """
        if flow_version is not None:
            pulumi.set(__self__, "flow_version", flow_version)

    @_builtins.property
    @pulumi.getter(name="flowVersion")
    def flow_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Version.
        """
        return pulumi.get(self, "flow_version")

    @flow_version.setter
    def flow_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "flow_version", value)


if not MYPY:
    class FlowCollectorFlowNodeConfigurationArgsDict(TypedDict):
        """
        Collector flow node configuration
        """
        pass
elif False:
    FlowCollectorFlowNodeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowCollectorFlowNodeConfigurationArgs:
    def __init__(__self__):
        """
        Collector flow node configuration
        """
        pass


if not MYPY:
    class FlowConditionFlowNodeConfigurationArgsDict(TypedDict):
        """
        Condition flow node configuration
        """
        conditions: pulumi.Input[Sequence[pulumi.Input['FlowConditionArgsDict']]]
        """
        List of conditions in a condition node
        """
elif False:
    FlowConditionFlowNodeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowConditionFlowNodeConfigurationArgs:
    def __init__(__self__, *,
                 conditions: pulumi.Input[Sequence[pulumi.Input['FlowConditionArgs']]]):
        """
        Condition flow node configuration
        :param pulumi.Input[Sequence[pulumi.Input['FlowConditionArgs']]] conditions: List of conditions in a condition node
        """
        pulumi.set(__self__, "conditions", conditions)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> pulumi.Input[Sequence[pulumi.Input['FlowConditionArgs']]]:
        """
        List of conditions in a condition node
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: pulumi.Input[Sequence[pulumi.Input['FlowConditionArgs']]]):
        pulumi.set(self, "conditions", value)


if not MYPY:
    class FlowConditionalConnectionConfigurationArgsDict(TypedDict):
        """
        Conditional connection configuration
        """
        condition: pulumi.Input[_builtins.str]
        """
        Name of a condition in a flow
        """
elif False:
    FlowConditionalConnectionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowConditionalConnectionConfigurationArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[_builtins.str]):
        """
        Conditional connection configuration
        :param pulumi.Input[_builtins.str] condition: Name of a condition in a flow
        """
        pulumi.set(__self__, "condition", condition)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> pulumi.Input[_builtins.str]:
        """
        Name of a condition in a flow
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "condition", value)


if not MYPY:
    class FlowConditionArgsDict(TypedDict):
        """
        Condition branch for a condition node
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of a condition in a flow
        """
        expression: NotRequired[pulumi.Input[_builtins.str]]
        """
        Expression for a condition in a flow
        """
elif False:
    FlowConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowConditionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 expression: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Condition branch for a condition node
        :param pulumi.Input[_builtins.str] name: Name of a condition in a flow
        :param pulumi.Input[_builtins.str] expression: Expression for a condition in a flow
        """
        pulumi.set(__self__, "name", name)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of a condition in a flow
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Expression for a condition in a flow
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expression", value)


if not MYPY:
    class FlowConnectionConfiguration0PropertiesArgsDict(TypedDict):
        """
        Connection configuration
        """
        data: pulumi.Input['FlowDataConnectionConfigurationArgsDict']
elif False:
    FlowConnectionConfiguration0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowConnectionConfiguration0PropertiesArgs:
    def __init__(__self__, *,
                 data: pulumi.Input['FlowDataConnectionConfigurationArgs']):
        """
        Connection configuration
        """
        pulumi.set(__self__, "data", data)

    @_builtins.property
    @pulumi.getter
    def data(self) -> pulumi.Input['FlowDataConnectionConfigurationArgs']:
        return pulumi.get(self, "data")

    @data.setter
    def data(self, value: pulumi.Input['FlowDataConnectionConfigurationArgs']):
        pulumi.set(self, "data", value)


if not MYPY:
    class FlowConnectionConfiguration1PropertiesArgsDict(TypedDict):
        """
        Connection configuration
        """
        conditional: pulumi.Input['FlowConditionalConnectionConfigurationArgsDict']
elif False:
    FlowConnectionConfiguration1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowConnectionConfiguration1PropertiesArgs:
    def __init__(__self__, *,
                 conditional: pulumi.Input['FlowConditionalConnectionConfigurationArgs']):
        """
        Connection configuration
        """
        pulumi.set(__self__, "conditional", conditional)

    @_builtins.property
    @pulumi.getter
    def conditional(self) -> pulumi.Input['FlowConditionalConnectionConfigurationArgs']:
        return pulumi.get(self, "conditional")

    @conditional.setter
    def conditional(self, value: pulumi.Input['FlowConditionalConnectionConfigurationArgs']):
        pulumi.set(self, "conditional", value)


if not MYPY:
    class FlowConnectionArgsDict(TypedDict):
        """
        Flow connection
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of a connection in a flow
        """
        source: pulumi.Input[_builtins.str]
        """
        Name of a node in a flow
        """
        target: pulumi.Input[_builtins.str]
        """
        Name of a node in a flow
        """
        type: pulumi.Input['FlowConnectionType']
        """
        Whether the source node that the connection begins from is a condition node ( `Conditional` ) or not ( `Data` ).
        """
        configuration: NotRequired[pulumi.Input[Union['FlowConnectionConfiguration0PropertiesArgsDict', 'FlowConnectionConfiguration1PropertiesArgsDict']]]
        """
        The configuration of the connection.
        """
elif False:
    FlowConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowConnectionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 source: pulumi.Input[_builtins.str],
                 target: pulumi.Input[_builtins.str],
                 type: pulumi.Input['FlowConnectionType'],
                 configuration: Optional[pulumi.Input[Union['FlowConnectionConfiguration0PropertiesArgs', 'FlowConnectionConfiguration1PropertiesArgs']]] = None):
        """
        Flow connection
        :param pulumi.Input[_builtins.str] name: Name of a connection in a flow
        :param pulumi.Input[_builtins.str] source: Name of a node in a flow
        :param pulumi.Input[_builtins.str] target: Name of a node in a flow
        :param pulumi.Input['FlowConnectionType'] type: Whether the source node that the connection begins from is a condition node ( `Conditional` ) or not ( `Data` ).
        :param pulumi.Input[Union['FlowConnectionConfiguration0PropertiesArgs', 'FlowConnectionConfiguration1PropertiesArgs']] configuration: The configuration of the connection.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "type", type)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of a connection in a flow
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> pulumi.Input[_builtins.str]:
        """
        Name of a node in a flow
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> pulumi.Input[_builtins.str]:
        """
        Name of a node in a flow
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['FlowConnectionType']:
        """
        Whether the source node that the connection begins from is a condition node ( `Conditional` ) or not ( `Data` ).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['FlowConnectionType']):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> Optional[pulumi.Input[Union['FlowConnectionConfiguration0PropertiesArgs', 'FlowConnectionConfiguration1PropertiesArgs']]]:
        """
        The configuration of the connection.
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[pulumi.Input[Union['FlowConnectionConfiguration0PropertiesArgs', 'FlowConnectionConfiguration1PropertiesArgs']]]):
        pulumi.set(self, "configuration", value)


if not MYPY:
    class FlowDataConnectionConfigurationArgsDict(TypedDict):
        """
        Data connection configuration
        """
        source_output: pulumi.Input[_builtins.str]
        """
        Name of a node output in a flow
        """
        target_input: pulumi.Input[_builtins.str]
        """
        Name of a node input in a flow
        """
elif False:
    FlowDataConnectionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowDataConnectionConfigurationArgs:
    def __init__(__self__, *,
                 source_output: pulumi.Input[_builtins.str],
                 target_input: pulumi.Input[_builtins.str]):
        """
        Data connection configuration
        :param pulumi.Input[_builtins.str] source_output: Name of a node output in a flow
        :param pulumi.Input[_builtins.str] target_input: Name of a node input in a flow
        """
        pulumi.set(__self__, "source_output", source_output)
        pulumi.set(__self__, "target_input", target_input)

    @_builtins.property
    @pulumi.getter(name="sourceOutput")
    def source_output(self) -> pulumi.Input[_builtins.str]:
        """
        Name of a node output in a flow
        """
        return pulumi.get(self, "source_output")

    @source_output.setter
    def source_output(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_output", value)

    @_builtins.property
    @pulumi.getter(name="targetInput")
    def target_input(self) -> pulumi.Input[_builtins.str]:
        """
        Name of a node input in a flow
        """
        return pulumi.get(self, "target_input")

    @target_input.setter
    def target_input(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_input", value)


if not MYPY:
    class FlowDefinitionArgsDict(TypedDict):
        """
        Flow definition
        """
        connections: NotRequired[pulumi.Input[Sequence[pulumi.Input['FlowConnectionArgsDict']]]]
        """
        List of connections
        """
        nodes: NotRequired[pulumi.Input[Sequence[pulumi.Input['FlowNodeArgsDict']]]]
        """
        List of nodes in a flow
        """
elif False:
    FlowDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowDefinitionArgs:
    def __init__(__self__, *,
                 connections: Optional[pulumi.Input[Sequence[pulumi.Input['FlowConnectionArgs']]]] = None,
                 nodes: Optional[pulumi.Input[Sequence[pulumi.Input['FlowNodeArgs']]]] = None):
        """
        Flow definition
        :param pulumi.Input[Sequence[pulumi.Input['FlowConnectionArgs']]] connections: List of connections
        :param pulumi.Input[Sequence[pulumi.Input['FlowNodeArgs']]] nodes: List of nodes in a flow
        """
        if connections is not None:
            pulumi.set(__self__, "connections", connections)
        if nodes is not None:
            pulumi.set(__self__, "nodes", nodes)

    @_builtins.property
    @pulumi.getter
    def connections(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FlowConnectionArgs']]]]:
        """
        List of connections
        """
        return pulumi.get(self, "connections")

    @connections.setter
    def connections(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FlowConnectionArgs']]]]):
        pulumi.set(self, "connections", value)

    @_builtins.property
    @pulumi.getter
    def nodes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FlowNodeArgs']]]]:
        """
        List of nodes in a flow
        """
        return pulumi.get(self, "nodes")

    @nodes.setter
    def nodes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FlowNodeArgs']]]]):
        pulumi.set(self, "nodes", value)


if not MYPY:
    class FlowFieldForRerankingArgsDict(TypedDict):
        """
        Field name for reranking
        """
        field_name: pulumi.Input[_builtins.str]
        """
        Field name for reranking
        """
elif False:
    FlowFieldForRerankingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowFieldForRerankingArgs:
    def __init__(__self__, *,
                 field_name: pulumi.Input[_builtins.str]):
        """
        Field name for reranking
        :param pulumi.Input[_builtins.str] field_name: Field name for reranking
        """
        pulumi.set(__self__, "field_name", field_name)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> pulumi.Input[_builtins.str]:
        """
        Field name for reranking
        """
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "field_name", value)


if not MYPY:
    class FlowGuardrailConfigurationArgsDict(TypedDict):
        """
        Configuration for a guardrail
        """
        guardrail_identifier: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identifier for the guardrail, could be the id or the arn
        """
        guardrail_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Version of the guardrail
        """
elif False:
    FlowGuardrailConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowGuardrailConfigurationArgs:
    def __init__(__self__, *,
                 guardrail_identifier: Optional[pulumi.Input[_builtins.str]] = None,
                 guardrail_version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Configuration for a guardrail
        :param pulumi.Input[_builtins.str] guardrail_identifier: Identifier for the guardrail, could be the id or the arn
        :param pulumi.Input[_builtins.str] guardrail_version: Version of the guardrail
        """
        if guardrail_identifier is not None:
            pulumi.set(__self__, "guardrail_identifier", guardrail_identifier)
        if guardrail_version is not None:
            pulumi.set(__self__, "guardrail_version", guardrail_version)

    @_builtins.property
    @pulumi.getter(name="guardrailIdentifier")
    def guardrail_identifier(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifier for the guardrail, could be the id or the arn
        """
        return pulumi.get(self, "guardrail_identifier")

    @guardrail_identifier.setter
    def guardrail_identifier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "guardrail_identifier", value)

    @_builtins.property
    @pulumi.getter(name="guardrailVersion")
    def guardrail_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Version of the guardrail
        """
        return pulumi.get(self, "guardrail_version")

    @guardrail_version.setter
    def guardrail_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "guardrail_version", value)


if not MYPY:
    class FlowInlineCodeFlowNodeConfigurationArgsDict(TypedDict):
        """
        Inline code config strucuture, contains code configs
        """
        code: pulumi.Input[_builtins.str]
        """
        The inline code entered by customers. max size is 5MB.
        """
        language: pulumi.Input['FlowSupportedLanguages']
elif False:
    FlowInlineCodeFlowNodeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowInlineCodeFlowNodeConfigurationArgs:
    def __init__(__self__, *,
                 code: pulumi.Input[_builtins.str],
                 language: pulumi.Input['FlowSupportedLanguages']):
        """
        Inline code config strucuture, contains code configs
        :param pulumi.Input[_builtins.str] code: The inline code entered by customers. max size is 5MB.
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "language", language)

    @_builtins.property
    @pulumi.getter
    def code(self) -> pulumi.Input[_builtins.str]:
        """
        The inline code entered by customers. max size is 5MB.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "code", value)

    @_builtins.property
    @pulumi.getter
    def language(self) -> pulumi.Input['FlowSupportedLanguages']:
        return pulumi.get(self, "language")

    @language.setter
    def language(self, value: pulumi.Input['FlowSupportedLanguages']):
        pulumi.set(self, "language", value)


if not MYPY:
    class FlowInputFlowNodeConfigurationArgsDict(TypedDict):
        """
        Input flow node configuration
        """
        pass
elif False:
    FlowInputFlowNodeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowInputFlowNodeConfigurationArgs:
    def __init__(__self__):
        """
        Input flow node configuration
        """
        pass


if not MYPY:
    class FlowIteratorFlowNodeConfigurationArgsDict(TypedDict):
        """
        Iterator flow node configuration
        """
        pass
elif False:
    FlowIteratorFlowNodeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowIteratorFlowNodeConfigurationArgs:
    def __init__(__self__):
        """
        Iterator flow node configuration
        """
        pass


if not MYPY:
    class FlowKnowledgeBaseFlowNodeConfigurationArgsDict(TypedDict):
        """
        Knowledge base flow node configuration
        """
        knowledge_base_id: pulumi.Input[_builtins.str]
        """
        Identifier of the KnowledgeBase
        """
        guardrail_configuration: NotRequired[pulumi.Input['FlowGuardrailConfigurationArgsDict']]
        inference_configuration: NotRequired[pulumi.Input['FlowPromptInferenceConfigurationPropertiesArgsDict']]
        model_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ARN or Id of a Bedrock Foundational Model or Inference Profile, or the ARN of a imported model, or a provisioned throughput ARN for custom models.
        """
        number_of_results: NotRequired[pulumi.Input[_builtins.float]]
        """
        Number Of Results to Retrieve
        """
        orchestration_configuration: NotRequired[pulumi.Input['FlowKnowledgeBaseOrchestrationConfigurationArgsDict']]
        prompt_template: NotRequired[pulumi.Input['FlowKnowledgeBasePromptTemplatePropertiesArgsDict']]
        reranking_configuration: NotRequired[pulumi.Input['FlowVectorSearchRerankingConfigurationArgsDict']]
elif False:
    FlowKnowledgeBaseFlowNodeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowKnowledgeBaseFlowNodeConfigurationArgs:
    def __init__(__self__, *,
                 knowledge_base_id: pulumi.Input[_builtins.str],
                 guardrail_configuration: Optional[pulumi.Input['FlowGuardrailConfigurationArgs']] = None,
                 inference_configuration: Optional[pulumi.Input['FlowPromptInferenceConfigurationPropertiesArgs']] = None,
                 model_id: Optional[pulumi.Input[_builtins.str]] = None,
                 number_of_results: Optional[pulumi.Input[_builtins.float]] = None,
                 orchestration_configuration: Optional[pulumi.Input['FlowKnowledgeBaseOrchestrationConfigurationArgs']] = None,
                 prompt_template: Optional[pulumi.Input['FlowKnowledgeBasePromptTemplatePropertiesArgs']] = None,
                 reranking_configuration: Optional[pulumi.Input['FlowVectorSearchRerankingConfigurationArgs']] = None):
        """
        Knowledge base flow node configuration
        :param pulumi.Input[_builtins.str] knowledge_base_id: Identifier of the KnowledgeBase
        :param pulumi.Input[_builtins.str] model_id: ARN or Id of a Bedrock Foundational Model or Inference Profile, or the ARN of a imported model, or a provisioned throughput ARN for custom models.
        :param pulumi.Input[_builtins.float] number_of_results: Number Of Results to Retrieve
        """
        pulumi.set(__self__, "knowledge_base_id", knowledge_base_id)
        if guardrail_configuration is not None:
            pulumi.set(__self__, "guardrail_configuration", guardrail_configuration)
        if inference_configuration is not None:
            pulumi.set(__self__, "inference_configuration", inference_configuration)
        if model_id is not None:
            pulumi.set(__self__, "model_id", model_id)
        if number_of_results is not None:
            pulumi.set(__self__, "number_of_results", number_of_results)
        if orchestration_configuration is not None:
            pulumi.set(__self__, "orchestration_configuration", orchestration_configuration)
        if prompt_template is not None:
            pulumi.set(__self__, "prompt_template", prompt_template)
        if reranking_configuration is not None:
            pulumi.set(__self__, "reranking_configuration", reranking_configuration)

    @_builtins.property
    @pulumi.getter(name="knowledgeBaseId")
    def knowledge_base_id(self) -> pulumi.Input[_builtins.str]:
        """
        Identifier of the KnowledgeBase
        """
        return pulumi.get(self, "knowledge_base_id")

    @knowledge_base_id.setter
    def knowledge_base_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "knowledge_base_id", value)

    @_builtins.property
    @pulumi.getter(name="guardrailConfiguration")
    def guardrail_configuration(self) -> Optional[pulumi.Input['FlowGuardrailConfigurationArgs']]:
        return pulumi.get(self, "guardrail_configuration")

    @guardrail_configuration.setter
    def guardrail_configuration(self, value: Optional[pulumi.Input['FlowGuardrailConfigurationArgs']]):
        pulumi.set(self, "guardrail_configuration", value)

    @_builtins.property
    @pulumi.getter(name="inferenceConfiguration")
    def inference_configuration(self) -> Optional[pulumi.Input['FlowPromptInferenceConfigurationPropertiesArgs']]:
        return pulumi.get(self, "inference_configuration")

    @inference_configuration.setter
    def inference_configuration(self, value: Optional[pulumi.Input['FlowPromptInferenceConfigurationPropertiesArgs']]):
        pulumi.set(self, "inference_configuration", value)

    @_builtins.property
    @pulumi.getter(name="modelId")
    def model_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ARN or Id of a Bedrock Foundational Model or Inference Profile, or the ARN of a imported model, or a provisioned throughput ARN for custom models.
        """
        return pulumi.get(self, "model_id")

    @model_id.setter
    def model_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model_id", value)

    @_builtins.property
    @pulumi.getter(name="numberOfResults")
    def number_of_results(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Number Of Results to Retrieve
        """
        return pulumi.get(self, "number_of_results")

    @number_of_results.setter
    def number_of_results(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "number_of_results", value)

    @_builtins.property
    @pulumi.getter(name="orchestrationConfiguration")
    def orchestration_configuration(self) -> Optional[pulumi.Input['FlowKnowledgeBaseOrchestrationConfigurationArgs']]:
        return pulumi.get(self, "orchestration_configuration")

    @orchestration_configuration.setter
    def orchestration_configuration(self, value: Optional[pulumi.Input['FlowKnowledgeBaseOrchestrationConfigurationArgs']]):
        pulumi.set(self, "orchestration_configuration", value)

    @_builtins.property
    @pulumi.getter(name="promptTemplate")
    def prompt_template(self) -> Optional[pulumi.Input['FlowKnowledgeBasePromptTemplatePropertiesArgs']]:
        return pulumi.get(self, "prompt_template")

    @prompt_template.setter
    def prompt_template(self, value: Optional[pulumi.Input['FlowKnowledgeBasePromptTemplatePropertiesArgs']]):
        pulumi.set(self, "prompt_template", value)

    @_builtins.property
    @pulumi.getter(name="rerankingConfiguration")
    def reranking_configuration(self) -> Optional[pulumi.Input['FlowVectorSearchRerankingConfigurationArgs']]:
        return pulumi.get(self, "reranking_configuration")

    @reranking_configuration.setter
    def reranking_configuration(self, value: Optional[pulumi.Input['FlowVectorSearchRerankingConfigurationArgs']]):
        pulumi.set(self, "reranking_configuration", value)


if not MYPY:
    class FlowKnowledgeBaseOrchestrationConfigurationArgsDict(TypedDict):
        additional_model_request_fields: NotRequired[pulumi.Input['FlowAdditionalModelRequestFieldsArgsDict']]
        inference_config: NotRequired[pulumi.Input['FlowPromptInferenceConfigurationPropertiesArgsDict']]
        performance_config: NotRequired[pulumi.Input['FlowPerformanceConfigurationArgsDict']]
        prompt_template: NotRequired[pulumi.Input['FlowKnowledgeBasePromptTemplatePropertiesArgsDict']]
elif False:
    FlowKnowledgeBaseOrchestrationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowKnowledgeBaseOrchestrationConfigurationArgs:
    def __init__(__self__, *,
                 additional_model_request_fields: Optional[pulumi.Input['FlowAdditionalModelRequestFieldsArgs']] = None,
                 inference_config: Optional[pulumi.Input['FlowPromptInferenceConfigurationPropertiesArgs']] = None,
                 performance_config: Optional[pulumi.Input['FlowPerformanceConfigurationArgs']] = None,
                 prompt_template: Optional[pulumi.Input['FlowKnowledgeBasePromptTemplatePropertiesArgs']] = None):
        if additional_model_request_fields is not None:
            pulumi.set(__self__, "additional_model_request_fields", additional_model_request_fields)
        if inference_config is not None:
            pulumi.set(__self__, "inference_config", inference_config)
        if performance_config is not None:
            pulumi.set(__self__, "performance_config", performance_config)
        if prompt_template is not None:
            pulumi.set(__self__, "prompt_template", prompt_template)

    @_builtins.property
    @pulumi.getter(name="additionalModelRequestFields")
    def additional_model_request_fields(self) -> Optional[pulumi.Input['FlowAdditionalModelRequestFieldsArgs']]:
        return pulumi.get(self, "additional_model_request_fields")

    @additional_model_request_fields.setter
    def additional_model_request_fields(self, value: Optional[pulumi.Input['FlowAdditionalModelRequestFieldsArgs']]):
        pulumi.set(self, "additional_model_request_fields", value)

    @_builtins.property
    @pulumi.getter(name="inferenceConfig")
    def inference_config(self) -> Optional[pulumi.Input['FlowPromptInferenceConfigurationPropertiesArgs']]:
        return pulumi.get(self, "inference_config")

    @inference_config.setter
    def inference_config(self, value: Optional[pulumi.Input['FlowPromptInferenceConfigurationPropertiesArgs']]):
        pulumi.set(self, "inference_config", value)

    @_builtins.property
    @pulumi.getter(name="performanceConfig")
    def performance_config(self) -> Optional[pulumi.Input['FlowPerformanceConfigurationArgs']]:
        return pulumi.get(self, "performance_config")

    @performance_config.setter
    def performance_config(self, value: Optional[pulumi.Input['FlowPerformanceConfigurationArgs']]):
        pulumi.set(self, "performance_config", value)

    @_builtins.property
    @pulumi.getter(name="promptTemplate")
    def prompt_template(self) -> Optional[pulumi.Input['FlowKnowledgeBasePromptTemplatePropertiesArgs']]:
        return pulumi.get(self, "prompt_template")

    @prompt_template.setter
    def prompt_template(self, value: Optional[pulumi.Input['FlowKnowledgeBasePromptTemplatePropertiesArgs']]):
        pulumi.set(self, "prompt_template", value)


if not MYPY:
    class FlowKnowledgeBasePromptTemplatePropertiesArgsDict(TypedDict):
        """
        Knowledge Base Prompt template
        """
        text_prompt_template: pulumi.Input[_builtins.str]
elif False:
    FlowKnowledgeBasePromptTemplatePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowKnowledgeBasePromptTemplatePropertiesArgs:
    def __init__(__self__, *,
                 text_prompt_template: pulumi.Input[_builtins.str]):
        """
        Knowledge Base Prompt template
        """
        pulumi.set(__self__, "text_prompt_template", text_prompt_template)

    @_builtins.property
    @pulumi.getter(name="textPromptTemplate")
    def text_prompt_template(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "text_prompt_template")

    @text_prompt_template.setter
    def text_prompt_template(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "text_prompt_template", value)


if not MYPY:
    class FlowLambdaFunctionFlowNodeConfigurationArgsDict(TypedDict):
        """
        Lambda function flow node configuration
        """
        lambda_arn: pulumi.Input[_builtins.str]
        """
        ARN of a Lambda.
        """
elif False:
    FlowLambdaFunctionFlowNodeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowLambdaFunctionFlowNodeConfigurationArgs:
    def __init__(__self__, *,
                 lambda_arn: pulumi.Input[_builtins.str]):
        """
        Lambda function flow node configuration
        :param pulumi.Input[_builtins.str] lambda_arn: ARN of a Lambda.
        """
        pulumi.set(__self__, "lambda_arn", lambda_arn)

    @_builtins.property
    @pulumi.getter(name="lambdaArn")
    def lambda_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of a Lambda.
        """
        return pulumi.get(self, "lambda_arn")

    @lambda_arn.setter
    def lambda_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "lambda_arn", value)


if not MYPY:
    class FlowLexFlowNodeConfigurationArgsDict(TypedDict):
        """
        Lex flow node configuration
        """
        bot_alias_arn: pulumi.Input[_builtins.str]
        """
        ARN of a Lex bot alias
        """
        locale_id: pulumi.Input[_builtins.str]
        """
        Lex bot locale id
        """
elif False:
    FlowLexFlowNodeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowLexFlowNodeConfigurationArgs:
    def __init__(__self__, *,
                 bot_alias_arn: pulumi.Input[_builtins.str],
                 locale_id: pulumi.Input[_builtins.str]):
        """
        Lex flow node configuration
        :param pulumi.Input[_builtins.str] bot_alias_arn: ARN of a Lex bot alias
        :param pulumi.Input[_builtins.str] locale_id: Lex bot locale id
        """
        pulumi.set(__self__, "bot_alias_arn", bot_alias_arn)
        pulumi.set(__self__, "locale_id", locale_id)

    @_builtins.property
    @pulumi.getter(name="botAliasArn")
    def bot_alias_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of a Lex bot alias
        """
        return pulumi.get(self, "bot_alias_arn")

    @bot_alias_arn.setter
    def bot_alias_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bot_alias_arn", value)

    @_builtins.property
    @pulumi.getter(name="localeId")
    def locale_id(self) -> pulumi.Input[_builtins.str]:
        """
        Lex bot locale id
        """
        return pulumi.get(self, "locale_id")

    @locale_id.setter
    def locale_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "locale_id", value)


if not MYPY:
    class FlowLoopControllerFlowNodeConfigurationArgsDict(TypedDict):
        """
        Configuration for the LoopController node, which manages loop execution
        """
        continue_condition: pulumi.Input['FlowConditionArgsDict']
        max_iterations: NotRequired[pulumi.Input[_builtins.float]]
        """
        Maximum number of iterations the loop can perform
        """
elif False:
    FlowLoopControllerFlowNodeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowLoopControllerFlowNodeConfigurationArgs:
    def __init__(__self__, *,
                 continue_condition: pulumi.Input['FlowConditionArgs'],
                 max_iterations: Optional[pulumi.Input[_builtins.float]] = None):
        """
        Configuration for the LoopController node, which manages loop execution
        :param pulumi.Input[_builtins.float] max_iterations: Maximum number of iterations the loop can perform
        """
        pulumi.set(__self__, "continue_condition", continue_condition)
        if max_iterations is not None:
            pulumi.set(__self__, "max_iterations", max_iterations)

    @_builtins.property
    @pulumi.getter(name="continueCondition")
    def continue_condition(self) -> pulumi.Input['FlowConditionArgs']:
        return pulumi.get(self, "continue_condition")

    @continue_condition.setter
    def continue_condition(self, value: pulumi.Input['FlowConditionArgs']):
        pulumi.set(self, "continue_condition", value)

    @_builtins.property
    @pulumi.getter(name="maxIterations")
    def max_iterations(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Maximum number of iterations the loop can perform
        """
        return pulumi.get(self, "max_iterations")

    @max_iterations.setter
    def max_iterations(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "max_iterations", value)


if not MYPY:
    class FlowLoopFlowNodeConfigurationArgsDict(TypedDict):
        """
        Loop node config, contains loop's internal definition
        """
        definition: pulumi.Input['FlowDefinitionArgsDict']
elif False:
    FlowLoopFlowNodeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowLoopFlowNodeConfigurationArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input['FlowDefinitionArgs']):
        """
        Loop node config, contains loop's internal definition
        """
        pulumi.set(__self__, "definition", definition)

    @_builtins.property
    @pulumi.getter
    def definition(self) -> pulumi.Input['FlowDefinitionArgs']:
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input['FlowDefinitionArgs']):
        pulumi.set(self, "definition", value)


if not MYPY:
    class FlowLoopInputFlowNodeConfigurationArgsDict(TypedDict):
        """
        Configuration for the LoopInput node
        """
        pass
elif False:
    FlowLoopInputFlowNodeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowLoopInputFlowNodeConfigurationArgs:
    def __init__(__self__):
        """
        Configuration for the LoopInput node
        """
        pass


if not MYPY:
    class FlowMetadataConfigurationForRerankingArgsDict(TypedDict):
        selection_mode: pulumi.Input['FlowRerankingMetadataSelectionMode']
        selective_mode_configuration: NotRequired[pulumi.Input[Union['FlowRerankingMetadataSelectiveModeConfiguration0PropertiesArgsDict', 'FlowRerankingMetadataSelectiveModeConfiguration1PropertiesArgsDict']]]
elif False:
    FlowMetadataConfigurationForRerankingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowMetadataConfigurationForRerankingArgs:
    def __init__(__self__, *,
                 selection_mode: pulumi.Input['FlowRerankingMetadataSelectionMode'],
                 selective_mode_configuration: Optional[pulumi.Input[Union['FlowRerankingMetadataSelectiveModeConfiguration0PropertiesArgs', 'FlowRerankingMetadataSelectiveModeConfiguration1PropertiesArgs']]] = None):
        pulumi.set(__self__, "selection_mode", selection_mode)
        if selective_mode_configuration is not None:
            pulumi.set(__self__, "selective_mode_configuration", selective_mode_configuration)

    @_builtins.property
    @pulumi.getter(name="selectionMode")
    def selection_mode(self) -> pulumi.Input['FlowRerankingMetadataSelectionMode']:
        return pulumi.get(self, "selection_mode")

    @selection_mode.setter
    def selection_mode(self, value: pulumi.Input['FlowRerankingMetadataSelectionMode']):
        pulumi.set(self, "selection_mode", value)

    @_builtins.property
    @pulumi.getter(name="selectiveModeConfiguration")
    def selective_mode_configuration(self) -> Optional[pulumi.Input[Union['FlowRerankingMetadataSelectiveModeConfiguration0PropertiesArgs', 'FlowRerankingMetadataSelectiveModeConfiguration1PropertiesArgs']]]:
        return pulumi.get(self, "selective_mode_configuration")

    @selective_mode_configuration.setter
    def selective_mode_configuration(self, value: Optional[pulumi.Input[Union['FlowRerankingMetadataSelectiveModeConfiguration0PropertiesArgs', 'FlowRerankingMetadataSelectiveModeConfiguration1PropertiesArgs']]]):
        pulumi.set(self, "selective_mode_configuration", value)


if not MYPY:
    class FlowNodeConfiguration0PropertiesArgsDict(TypedDict):
        """
        Node configuration in a flow
        """
        input: pulumi.Input['FlowInputFlowNodeConfigurationArgsDict']
elif False:
    FlowNodeConfiguration0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowNodeConfiguration0PropertiesArgs:
    def __init__(__self__, *,
                 input: pulumi.Input['FlowInputFlowNodeConfigurationArgs']):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "input", input)

    @_builtins.property
    @pulumi.getter
    def input(self) -> pulumi.Input['FlowInputFlowNodeConfigurationArgs']:
        return pulumi.get(self, "input")

    @input.setter
    def input(self, value: pulumi.Input['FlowInputFlowNodeConfigurationArgs']):
        pulumi.set(self, "input", value)


if not MYPY:
    class FlowNodeConfiguration10PropertiesArgsDict(TypedDict):
        """
        Node configuration in a flow
        """
        collector: pulumi.Input['FlowCollectorFlowNodeConfigurationArgsDict']
elif False:
    FlowNodeConfiguration10PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowNodeConfiguration10PropertiesArgs:
    def __init__(__self__, *,
                 collector: pulumi.Input['FlowCollectorFlowNodeConfigurationArgs']):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "collector", collector)

    @_builtins.property
    @pulumi.getter
    def collector(self) -> pulumi.Input['FlowCollectorFlowNodeConfigurationArgs']:
        return pulumi.get(self, "collector")

    @collector.setter
    def collector(self, value: pulumi.Input['FlowCollectorFlowNodeConfigurationArgs']):
        pulumi.set(self, "collector", value)


if not MYPY:
    class FlowNodeConfiguration11PropertiesArgsDict(TypedDict):
        """
        Node configuration in a flow
        """
        retrieval: pulumi.Input['FlowRetrievalFlowNodeConfigurationArgsDict']
elif False:
    FlowNodeConfiguration11PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowNodeConfiguration11PropertiesArgs:
    def __init__(__self__, *,
                 retrieval: pulumi.Input['FlowRetrievalFlowNodeConfigurationArgs']):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "retrieval", retrieval)

    @_builtins.property
    @pulumi.getter
    def retrieval(self) -> pulumi.Input['FlowRetrievalFlowNodeConfigurationArgs']:
        return pulumi.get(self, "retrieval")

    @retrieval.setter
    def retrieval(self, value: pulumi.Input['FlowRetrievalFlowNodeConfigurationArgs']):
        pulumi.set(self, "retrieval", value)


if not MYPY:
    class FlowNodeConfiguration12PropertiesArgsDict(TypedDict):
        """
        Node configuration in a flow
        """
        inline_code: pulumi.Input['FlowInlineCodeFlowNodeConfigurationArgsDict']
elif False:
    FlowNodeConfiguration12PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowNodeConfiguration12PropertiesArgs:
    def __init__(__self__, *,
                 inline_code: pulumi.Input['FlowInlineCodeFlowNodeConfigurationArgs']):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "inline_code", inline_code)

    @_builtins.property
    @pulumi.getter(name="inlineCode")
    def inline_code(self) -> pulumi.Input['FlowInlineCodeFlowNodeConfigurationArgs']:
        return pulumi.get(self, "inline_code")

    @inline_code.setter
    def inline_code(self, value: pulumi.Input['FlowInlineCodeFlowNodeConfigurationArgs']):
        pulumi.set(self, "inline_code", value)


if not MYPY:
    class FlowNodeConfiguration13PropertiesArgsDict(TypedDict):
        """
        Node configuration in a flow
        """
        loop: pulumi.Input['FlowLoopFlowNodeConfigurationArgsDict']
elif False:
    FlowNodeConfiguration13PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowNodeConfiguration13PropertiesArgs:
    def __init__(__self__, *,
                 loop: pulumi.Input['FlowLoopFlowNodeConfigurationArgs']):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "loop", loop)

    @_builtins.property
    @pulumi.getter
    def loop(self) -> pulumi.Input['FlowLoopFlowNodeConfigurationArgs']:
        return pulumi.get(self, "loop")

    @loop.setter
    def loop(self, value: pulumi.Input['FlowLoopFlowNodeConfigurationArgs']):
        pulumi.set(self, "loop", value)


if not MYPY:
    class FlowNodeConfiguration14PropertiesArgsDict(TypedDict):
        """
        Node configuration in a flow
        """
        loop_input: pulumi.Input['FlowLoopInputFlowNodeConfigurationArgsDict']
elif False:
    FlowNodeConfiguration14PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowNodeConfiguration14PropertiesArgs:
    def __init__(__self__, *,
                 loop_input: pulumi.Input['FlowLoopInputFlowNodeConfigurationArgs']):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "loop_input", loop_input)

    @_builtins.property
    @pulumi.getter(name="loopInput")
    def loop_input(self) -> pulumi.Input['FlowLoopInputFlowNodeConfigurationArgs']:
        return pulumi.get(self, "loop_input")

    @loop_input.setter
    def loop_input(self, value: pulumi.Input['FlowLoopInputFlowNodeConfigurationArgs']):
        pulumi.set(self, "loop_input", value)


if not MYPY:
    class FlowNodeConfiguration15PropertiesArgsDict(TypedDict):
        """
        Node configuration in a flow
        """
        loop_controller: pulumi.Input['FlowLoopControllerFlowNodeConfigurationArgsDict']
elif False:
    FlowNodeConfiguration15PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowNodeConfiguration15PropertiesArgs:
    def __init__(__self__, *,
                 loop_controller: pulumi.Input['FlowLoopControllerFlowNodeConfigurationArgs']):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "loop_controller", loop_controller)

    @_builtins.property
    @pulumi.getter(name="loopController")
    def loop_controller(self) -> pulumi.Input['FlowLoopControllerFlowNodeConfigurationArgs']:
        return pulumi.get(self, "loop_controller")

    @loop_controller.setter
    def loop_controller(self, value: pulumi.Input['FlowLoopControllerFlowNodeConfigurationArgs']):
        pulumi.set(self, "loop_controller", value)


if not MYPY:
    class FlowNodeConfiguration1PropertiesArgsDict(TypedDict):
        """
        Node configuration in a flow
        """
        output: pulumi.Input['FlowOutputFlowNodeConfigurationArgsDict']
elif False:
    FlowNodeConfiguration1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowNodeConfiguration1PropertiesArgs:
    def __init__(__self__, *,
                 output: pulumi.Input['FlowOutputFlowNodeConfigurationArgs']):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "output", output)

    @_builtins.property
    @pulumi.getter
    def output(self) -> pulumi.Input['FlowOutputFlowNodeConfigurationArgs']:
        return pulumi.get(self, "output")

    @output.setter
    def output(self, value: pulumi.Input['FlowOutputFlowNodeConfigurationArgs']):
        pulumi.set(self, "output", value)


if not MYPY:
    class FlowNodeConfiguration2PropertiesArgsDict(TypedDict):
        """
        Node configuration in a flow
        """
        knowledge_base: pulumi.Input['FlowKnowledgeBaseFlowNodeConfigurationArgsDict']
elif False:
    FlowNodeConfiguration2PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowNodeConfiguration2PropertiesArgs:
    def __init__(__self__, *,
                 knowledge_base: pulumi.Input['FlowKnowledgeBaseFlowNodeConfigurationArgs']):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "knowledge_base", knowledge_base)

    @_builtins.property
    @pulumi.getter(name="knowledgeBase")
    def knowledge_base(self) -> pulumi.Input['FlowKnowledgeBaseFlowNodeConfigurationArgs']:
        return pulumi.get(self, "knowledge_base")

    @knowledge_base.setter
    def knowledge_base(self, value: pulumi.Input['FlowKnowledgeBaseFlowNodeConfigurationArgs']):
        pulumi.set(self, "knowledge_base", value)


if not MYPY:
    class FlowNodeConfiguration3PropertiesArgsDict(TypedDict):
        """
        Node configuration in a flow
        """
        condition: pulumi.Input['FlowConditionFlowNodeConfigurationArgsDict']
elif False:
    FlowNodeConfiguration3PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowNodeConfiguration3PropertiesArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input['FlowConditionFlowNodeConfigurationArgs']):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "condition", condition)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> pulumi.Input['FlowConditionFlowNodeConfigurationArgs']:
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input['FlowConditionFlowNodeConfigurationArgs']):
        pulumi.set(self, "condition", value)


if not MYPY:
    class FlowNodeConfiguration4PropertiesArgsDict(TypedDict):
        """
        Node configuration in a flow
        """
        lex: pulumi.Input['FlowLexFlowNodeConfigurationArgsDict']
elif False:
    FlowNodeConfiguration4PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowNodeConfiguration4PropertiesArgs:
    def __init__(__self__, *,
                 lex: pulumi.Input['FlowLexFlowNodeConfigurationArgs']):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "lex", lex)

    @_builtins.property
    @pulumi.getter
    def lex(self) -> pulumi.Input['FlowLexFlowNodeConfigurationArgs']:
        return pulumi.get(self, "lex")

    @lex.setter
    def lex(self, value: pulumi.Input['FlowLexFlowNodeConfigurationArgs']):
        pulumi.set(self, "lex", value)


if not MYPY:
    class FlowNodeConfiguration5PropertiesArgsDict(TypedDict):
        """
        Node configuration in a flow
        """
        prompt: pulumi.Input['FlowPromptFlowNodeConfigurationArgsDict']
elif False:
    FlowNodeConfiguration5PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowNodeConfiguration5PropertiesArgs:
    def __init__(__self__, *,
                 prompt: pulumi.Input['FlowPromptFlowNodeConfigurationArgs']):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "prompt", prompt)

    @_builtins.property
    @pulumi.getter
    def prompt(self) -> pulumi.Input['FlowPromptFlowNodeConfigurationArgs']:
        return pulumi.get(self, "prompt")

    @prompt.setter
    def prompt(self, value: pulumi.Input['FlowPromptFlowNodeConfigurationArgs']):
        pulumi.set(self, "prompt", value)


if not MYPY:
    class FlowNodeConfiguration6PropertiesArgsDict(TypedDict):
        """
        Node configuration in a flow
        """
        lambda_function: pulumi.Input['FlowLambdaFunctionFlowNodeConfigurationArgsDict']
elif False:
    FlowNodeConfiguration6PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowNodeConfiguration6PropertiesArgs:
    def __init__(__self__, *,
                 lambda_function: pulumi.Input['FlowLambdaFunctionFlowNodeConfigurationArgs']):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "lambda_function", lambda_function)

    @_builtins.property
    @pulumi.getter(name="lambdaFunction")
    def lambda_function(self) -> pulumi.Input['FlowLambdaFunctionFlowNodeConfigurationArgs']:
        return pulumi.get(self, "lambda_function")

    @lambda_function.setter
    def lambda_function(self, value: pulumi.Input['FlowLambdaFunctionFlowNodeConfigurationArgs']):
        pulumi.set(self, "lambda_function", value)


if not MYPY:
    class FlowNodeConfiguration7PropertiesArgsDict(TypedDict):
        """
        Node configuration in a flow
        """
        agent: pulumi.Input['FlowAgentFlowNodeConfigurationArgsDict']
elif False:
    FlowNodeConfiguration7PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowNodeConfiguration7PropertiesArgs:
    def __init__(__self__, *,
                 agent: pulumi.Input['FlowAgentFlowNodeConfigurationArgs']):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "agent", agent)

    @_builtins.property
    @pulumi.getter
    def agent(self) -> pulumi.Input['FlowAgentFlowNodeConfigurationArgs']:
        return pulumi.get(self, "agent")

    @agent.setter
    def agent(self, value: pulumi.Input['FlowAgentFlowNodeConfigurationArgs']):
        pulumi.set(self, "agent", value)


if not MYPY:
    class FlowNodeConfiguration8PropertiesArgsDict(TypedDict):
        """
        Node configuration in a flow
        """
        storage: pulumi.Input['FlowStorageFlowNodeConfigurationArgsDict']
elif False:
    FlowNodeConfiguration8PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowNodeConfiguration8PropertiesArgs:
    def __init__(__self__, *,
                 storage: pulumi.Input['FlowStorageFlowNodeConfigurationArgs']):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "storage", storage)

    @_builtins.property
    @pulumi.getter
    def storage(self) -> pulumi.Input['FlowStorageFlowNodeConfigurationArgs']:
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: pulumi.Input['FlowStorageFlowNodeConfigurationArgs']):
        pulumi.set(self, "storage", value)


if not MYPY:
    class FlowNodeConfiguration9PropertiesArgsDict(TypedDict):
        """
        Node configuration in a flow
        """
        iterator: pulumi.Input['FlowIteratorFlowNodeConfigurationArgsDict']
elif False:
    FlowNodeConfiguration9PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowNodeConfiguration9PropertiesArgs:
    def __init__(__self__, *,
                 iterator: pulumi.Input['FlowIteratorFlowNodeConfigurationArgs']):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "iterator", iterator)

    @_builtins.property
    @pulumi.getter
    def iterator(self) -> pulumi.Input['FlowIteratorFlowNodeConfigurationArgs']:
        return pulumi.get(self, "iterator")

    @iterator.setter
    def iterator(self, value: pulumi.Input['FlowIteratorFlowNodeConfigurationArgs']):
        pulumi.set(self, "iterator", value)


if not MYPY:
    class FlowNodeInputArgsDict(TypedDict):
        """
        Input to a node in a flow
        """
        expression: pulumi.Input[_builtins.str]
        """
        Expression for a node input in a flow
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of a node input in a flow
        """
        type: pulumi.Input['FlowNodeIoDataType']
        """
        Specifies the data type of the input. If the input doesn't match this type at runtime, a validation error will be thrown.
        """
        category: NotRequired[pulumi.Input['FlowNodeInputCategory']]
        """
        Specifies how input data flows between iterations in a DoWhile loop.

        - `LoopCondition` - Controls whether the loop continues by evaluating condition expressions against the input data. Use this category to define the condition that determines if the loop should continue.
        - `ReturnValueToLoopStart` - Defines data to pass back to the start of the loop's next iteration. Use this category for variables that you want to update for each loop iteration.
        - `ExitLoop` - Defines the value that's available once the loop ends. Use this category to expose loop results to nodes outside the loop.
        """
elif False:
    FlowNodeInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowNodeInputArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input['FlowNodeIoDataType'],
                 category: Optional[pulumi.Input['FlowNodeInputCategory']] = None):
        """
        Input to a node in a flow
        :param pulumi.Input[_builtins.str] expression: Expression for a node input in a flow
        :param pulumi.Input[_builtins.str] name: Name of a node input in a flow
        :param pulumi.Input['FlowNodeIoDataType'] type: Specifies the data type of the input. If the input doesn't match this type at runtime, a validation error will be thrown.
        :param pulumi.Input['FlowNodeInputCategory'] category: Specifies how input data flows between iterations in a DoWhile loop.
               
               - `LoopCondition` - Controls whether the loop continues by evaluating condition expressions against the input data. Use this category to define the condition that determines if the loop should continue.
               - `ReturnValueToLoopStart` - Defines data to pass back to the start of the loop's next iteration. Use this category for variables that you want to update for each loop iteration.
               - `ExitLoop` - Defines the value that's available once the loop ends. Use this category to expose loop results to nodes outside the loop.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if category is not None:
            pulumi.set(__self__, "category", category)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> pulumi.Input[_builtins.str]:
        """
        Expression for a node input in a flow
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of a node input in a flow
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['FlowNodeIoDataType']:
        """
        Specifies the data type of the input. If the input doesn't match this type at runtime, a validation error will be thrown.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['FlowNodeIoDataType']):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input['FlowNodeInputCategory']]:
        """
        Specifies how input data flows between iterations in a DoWhile loop.

        - `LoopCondition` - Controls whether the loop continues by evaluating condition expressions against the input data. Use this category to define the condition that determines if the loop should continue.
        - `ReturnValueToLoopStart` - Defines data to pass back to the start of the loop's next iteration. Use this category for variables that you want to update for each loop iteration.
        - `ExitLoop` - Defines the value that's available once the loop ends. Use this category to expose loop results to nodes outside the loop.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input['FlowNodeInputCategory']]):
        pulumi.set(self, "category", value)


if not MYPY:
    class FlowNodeOutputArgsDict(TypedDict):
        """
        Output of a node in a flow
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of a node output in a flow
        """
        type: pulumi.Input['FlowNodeIoDataType']
        """
        The data type of the output. If the output doesn't match this type at runtime, a validation error will be thrown.
        """
elif False:
    FlowNodeOutputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowNodeOutputArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input['FlowNodeIoDataType']):
        """
        Output of a node in a flow
        :param pulumi.Input[_builtins.str] name: Name of a node output in a flow
        :param pulumi.Input['FlowNodeIoDataType'] type: The data type of the output. If the output doesn't match this type at runtime, a validation error will be thrown.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of a node output in a flow
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['FlowNodeIoDataType']:
        """
        The data type of the output. If the output doesn't match this type at runtime, a validation error will be thrown.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['FlowNodeIoDataType']):
        pulumi.set(self, "type", value)


if not MYPY:
    class FlowNodeArgsDict(TypedDict):
        """
        Internal mixin for flow node
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of a node in a flow
        """
        type: pulumi.Input['FlowNodeType']
        """
        The type of node. This value must match the name of the key that you provide in the configuration you provide in the `FlowNodeConfiguration` field.
        """
        configuration: NotRequired[pulumi.Input[Union['FlowNodeConfiguration0PropertiesArgsDict', 'FlowNodeConfiguration1PropertiesArgsDict', 'FlowNodeConfiguration2PropertiesArgsDict', 'FlowNodeConfiguration3PropertiesArgsDict', 'FlowNodeConfiguration4PropertiesArgsDict', 'FlowNodeConfiguration5PropertiesArgsDict', 'FlowNodeConfiguration6PropertiesArgsDict', 'FlowNodeConfiguration7PropertiesArgsDict', 'FlowNodeConfiguration8PropertiesArgsDict', 'FlowNodeConfiguration9PropertiesArgsDict', 'FlowNodeConfiguration10PropertiesArgsDict', 'FlowNodeConfiguration11PropertiesArgsDict', 'FlowNodeConfiguration12PropertiesArgsDict', 'FlowNodeConfiguration13PropertiesArgsDict', 'FlowNodeConfiguration14PropertiesArgsDict', 'FlowNodeConfiguration15PropertiesArgsDict']]]
        """
        Contains configurations for the node.
        """
        inputs: NotRequired[pulumi.Input[Sequence[pulumi.Input['FlowNodeInputArgsDict']]]]
        """
        List of node inputs in a flow
        """
        outputs: NotRequired[pulumi.Input[Sequence[pulumi.Input['FlowNodeOutputArgsDict']]]]
        """
        List of node outputs in a flow
        """
elif False:
    FlowNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowNodeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input['FlowNodeType'],
                 configuration: Optional[pulumi.Input[Union['FlowNodeConfiguration0PropertiesArgs', 'FlowNodeConfiguration1PropertiesArgs', 'FlowNodeConfiguration2PropertiesArgs', 'FlowNodeConfiguration3PropertiesArgs', 'FlowNodeConfiguration4PropertiesArgs', 'FlowNodeConfiguration5PropertiesArgs', 'FlowNodeConfiguration6PropertiesArgs', 'FlowNodeConfiguration7PropertiesArgs', 'FlowNodeConfiguration8PropertiesArgs', 'FlowNodeConfiguration9PropertiesArgs', 'FlowNodeConfiguration10PropertiesArgs', 'FlowNodeConfiguration11PropertiesArgs', 'FlowNodeConfiguration12PropertiesArgs', 'FlowNodeConfiguration13PropertiesArgs', 'FlowNodeConfiguration14PropertiesArgs', 'FlowNodeConfiguration15PropertiesArgs']]] = None,
                 inputs: Optional[pulumi.Input[Sequence[pulumi.Input['FlowNodeInputArgs']]]] = None,
                 outputs: Optional[pulumi.Input[Sequence[pulumi.Input['FlowNodeOutputArgs']]]] = None):
        """
        Internal mixin for flow node
        :param pulumi.Input[_builtins.str] name: Name of a node in a flow
        :param pulumi.Input['FlowNodeType'] type: The type of node. This value must match the name of the key that you provide in the configuration you provide in the `FlowNodeConfiguration` field.
        :param pulumi.Input[Union['FlowNodeConfiguration0PropertiesArgs', 'FlowNodeConfiguration1PropertiesArgs', 'FlowNodeConfiguration2PropertiesArgs', 'FlowNodeConfiguration3PropertiesArgs', 'FlowNodeConfiguration4PropertiesArgs', 'FlowNodeConfiguration5PropertiesArgs', 'FlowNodeConfiguration6PropertiesArgs', 'FlowNodeConfiguration7PropertiesArgs', 'FlowNodeConfiguration8PropertiesArgs', 'FlowNodeConfiguration9PropertiesArgs', 'FlowNodeConfiguration10PropertiesArgs', 'FlowNodeConfiguration11PropertiesArgs', 'FlowNodeConfiguration12PropertiesArgs', 'FlowNodeConfiguration13PropertiesArgs', 'FlowNodeConfiguration14PropertiesArgs', 'FlowNodeConfiguration15PropertiesArgs']] configuration: Contains configurations for the node.
        :param pulumi.Input[Sequence[pulumi.Input['FlowNodeInputArgs']]] inputs: List of node inputs in a flow
        :param pulumi.Input[Sequence[pulumi.Input['FlowNodeOutputArgs']]] outputs: List of node outputs in a flow
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if inputs is not None:
            pulumi.set(__self__, "inputs", inputs)
        if outputs is not None:
            pulumi.set(__self__, "outputs", outputs)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of a node in a flow
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['FlowNodeType']:
        """
        The type of node. This value must match the name of the key that you provide in the configuration you provide in the `FlowNodeConfiguration` field.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['FlowNodeType']):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> Optional[pulumi.Input[Union['FlowNodeConfiguration0PropertiesArgs', 'FlowNodeConfiguration1PropertiesArgs', 'FlowNodeConfiguration2PropertiesArgs', 'FlowNodeConfiguration3PropertiesArgs', 'FlowNodeConfiguration4PropertiesArgs', 'FlowNodeConfiguration5PropertiesArgs', 'FlowNodeConfiguration6PropertiesArgs', 'FlowNodeConfiguration7PropertiesArgs', 'FlowNodeConfiguration8PropertiesArgs', 'FlowNodeConfiguration9PropertiesArgs', 'FlowNodeConfiguration10PropertiesArgs', 'FlowNodeConfiguration11PropertiesArgs', 'FlowNodeConfiguration12PropertiesArgs', 'FlowNodeConfiguration13PropertiesArgs', 'FlowNodeConfiguration14PropertiesArgs', 'FlowNodeConfiguration15PropertiesArgs']]]:
        """
        Contains configurations for the node.
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[pulumi.Input[Union['FlowNodeConfiguration0PropertiesArgs', 'FlowNodeConfiguration1PropertiesArgs', 'FlowNodeConfiguration2PropertiesArgs', 'FlowNodeConfiguration3PropertiesArgs', 'FlowNodeConfiguration4PropertiesArgs', 'FlowNodeConfiguration5PropertiesArgs', 'FlowNodeConfiguration6PropertiesArgs', 'FlowNodeConfiguration7PropertiesArgs', 'FlowNodeConfiguration8PropertiesArgs', 'FlowNodeConfiguration9PropertiesArgs', 'FlowNodeConfiguration10PropertiesArgs', 'FlowNodeConfiguration11PropertiesArgs', 'FlowNodeConfiguration12PropertiesArgs', 'FlowNodeConfiguration13PropertiesArgs', 'FlowNodeConfiguration14PropertiesArgs', 'FlowNodeConfiguration15PropertiesArgs']]]):
        pulumi.set(self, "configuration", value)

    @_builtins.property
    @pulumi.getter
    def inputs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FlowNodeInputArgs']]]]:
        """
        List of node inputs in a flow
        """
        return pulumi.get(self, "inputs")

    @inputs.setter
    def inputs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FlowNodeInputArgs']]]]):
        pulumi.set(self, "inputs", value)

    @_builtins.property
    @pulumi.getter
    def outputs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FlowNodeOutputArgs']]]]:
        """
        List of node outputs in a flow
        """
        return pulumi.get(self, "outputs")

    @outputs.setter
    def outputs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FlowNodeOutputArgs']]]]):
        pulumi.set(self, "outputs", value)


if not MYPY:
    class FlowOutputFlowNodeConfigurationArgsDict(TypedDict):
        """
        Output flow node configuration
        """
        pass
elif False:
    FlowOutputFlowNodeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowOutputFlowNodeConfigurationArgs:
    def __init__(__self__):
        """
        Output flow node configuration
        """
        pass


if not MYPY:
    class FlowPerformanceConfigurationArgsDict(TypedDict):
        latency: NotRequired[pulumi.Input['FlowPerformanceConfigurationLatency']]
elif False:
    FlowPerformanceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowPerformanceConfigurationArgs:
    def __init__(__self__, *,
                 latency: Optional[pulumi.Input['FlowPerformanceConfigurationLatency']] = None):
        if latency is not None:
            pulumi.set(__self__, "latency", latency)

    @_builtins.property
    @pulumi.getter
    def latency(self) -> Optional[pulumi.Input['FlowPerformanceConfigurationLatency']]:
        return pulumi.get(self, "latency")

    @latency.setter
    def latency(self, value: Optional[pulumi.Input['FlowPerformanceConfigurationLatency']]):
        pulumi.set(self, "latency", value)


if not MYPY:
    class FlowPromptFlowNodeConfigurationArgsDict(TypedDict):
        """
        Prompt flow node configuration
        """
        source_configuration: pulumi.Input[Union['FlowPromptFlowNodeSourceConfiguration0PropertiesArgsDict', 'FlowPromptFlowNodeSourceConfiguration1PropertiesArgsDict']]
        guardrail_configuration: NotRequired[pulumi.Input['FlowGuardrailConfigurationArgsDict']]
elif False:
    FlowPromptFlowNodeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowPromptFlowNodeConfigurationArgs:
    def __init__(__self__, *,
                 source_configuration: pulumi.Input[Union['FlowPromptFlowNodeSourceConfiguration0PropertiesArgs', 'FlowPromptFlowNodeSourceConfiguration1PropertiesArgs']],
                 guardrail_configuration: Optional[pulumi.Input['FlowGuardrailConfigurationArgs']] = None):
        """
        Prompt flow node configuration
        """
        pulumi.set(__self__, "source_configuration", source_configuration)
        if guardrail_configuration is not None:
            pulumi.set(__self__, "guardrail_configuration", guardrail_configuration)

    @_builtins.property
    @pulumi.getter(name="sourceConfiguration")
    def source_configuration(self) -> pulumi.Input[Union['FlowPromptFlowNodeSourceConfiguration0PropertiesArgs', 'FlowPromptFlowNodeSourceConfiguration1PropertiesArgs']]:
        return pulumi.get(self, "source_configuration")

    @source_configuration.setter
    def source_configuration(self, value: pulumi.Input[Union['FlowPromptFlowNodeSourceConfiguration0PropertiesArgs', 'FlowPromptFlowNodeSourceConfiguration1PropertiesArgs']]):
        pulumi.set(self, "source_configuration", value)

    @_builtins.property
    @pulumi.getter(name="guardrailConfiguration")
    def guardrail_configuration(self) -> Optional[pulumi.Input['FlowGuardrailConfigurationArgs']]:
        return pulumi.get(self, "guardrail_configuration")

    @guardrail_configuration.setter
    def guardrail_configuration(self, value: Optional[pulumi.Input['FlowGuardrailConfigurationArgs']]):
        pulumi.set(self, "guardrail_configuration", value)


if not MYPY:
    class FlowPromptFlowNodeInlineConfigurationArgsDict(TypedDict):
        """
        Inline prompt configuration for prompt node
        """
        model_id: pulumi.Input[_builtins.str]
        """
        ARN or Id of a Bedrock Foundational Model or Inference Profile, or the ARN of a imported model, or a provisioned throughput ARN for custom models.
        """
        template_configuration: pulumi.Input['FlowPromptTemplateConfigurationPropertiesArgsDict']
        template_type: pulumi.Input['FlowPromptTemplateType']
        inference_configuration: NotRequired[pulumi.Input['FlowPromptInferenceConfigurationPropertiesArgsDict']]
elif False:
    FlowPromptFlowNodeInlineConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowPromptFlowNodeInlineConfigurationArgs:
    def __init__(__self__, *,
                 model_id: pulumi.Input[_builtins.str],
                 template_configuration: pulumi.Input['FlowPromptTemplateConfigurationPropertiesArgs'],
                 template_type: pulumi.Input['FlowPromptTemplateType'],
                 inference_configuration: Optional[pulumi.Input['FlowPromptInferenceConfigurationPropertiesArgs']] = None):
        """
        Inline prompt configuration for prompt node
        :param pulumi.Input[_builtins.str] model_id: ARN or Id of a Bedrock Foundational Model or Inference Profile, or the ARN of a imported model, or a provisioned throughput ARN for custom models.
        """
        pulumi.set(__self__, "model_id", model_id)
        pulumi.set(__self__, "template_configuration", template_configuration)
        pulumi.set(__self__, "template_type", template_type)
        if inference_configuration is not None:
            pulumi.set(__self__, "inference_configuration", inference_configuration)

    @_builtins.property
    @pulumi.getter(name="modelId")
    def model_id(self) -> pulumi.Input[_builtins.str]:
        """
        ARN or Id of a Bedrock Foundational Model or Inference Profile, or the ARN of a imported model, or a provisioned throughput ARN for custom models.
        """
        return pulumi.get(self, "model_id")

    @model_id.setter
    def model_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "model_id", value)

    @_builtins.property
    @pulumi.getter(name="templateConfiguration")
    def template_configuration(self) -> pulumi.Input['FlowPromptTemplateConfigurationPropertiesArgs']:
        return pulumi.get(self, "template_configuration")

    @template_configuration.setter
    def template_configuration(self, value: pulumi.Input['FlowPromptTemplateConfigurationPropertiesArgs']):
        pulumi.set(self, "template_configuration", value)

    @_builtins.property
    @pulumi.getter(name="templateType")
    def template_type(self) -> pulumi.Input['FlowPromptTemplateType']:
        return pulumi.get(self, "template_type")

    @template_type.setter
    def template_type(self, value: pulumi.Input['FlowPromptTemplateType']):
        pulumi.set(self, "template_type", value)

    @_builtins.property
    @pulumi.getter(name="inferenceConfiguration")
    def inference_configuration(self) -> Optional[pulumi.Input['FlowPromptInferenceConfigurationPropertiesArgs']]:
        return pulumi.get(self, "inference_configuration")

    @inference_configuration.setter
    def inference_configuration(self, value: Optional[pulumi.Input['FlowPromptInferenceConfigurationPropertiesArgs']]):
        pulumi.set(self, "inference_configuration", value)


if not MYPY:
    class FlowPromptFlowNodeResourceConfigurationArgsDict(TypedDict):
        """
        Resource prompt configuration for prompt node
        """
        prompt_arn: pulumi.Input[_builtins.str]
        """
        ARN of a prompt resource possibly with a version
        """
elif False:
    FlowPromptFlowNodeResourceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowPromptFlowNodeResourceConfigurationArgs:
    def __init__(__self__, *,
                 prompt_arn: pulumi.Input[_builtins.str]):
        """
        Resource prompt configuration for prompt node
        :param pulumi.Input[_builtins.str] prompt_arn: ARN of a prompt resource possibly with a version
        """
        pulumi.set(__self__, "prompt_arn", prompt_arn)

    @_builtins.property
    @pulumi.getter(name="promptArn")
    def prompt_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN of a prompt resource possibly with a version
        """
        return pulumi.get(self, "prompt_arn")

    @prompt_arn.setter
    def prompt_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "prompt_arn", value)


if not MYPY:
    class FlowPromptFlowNodeSourceConfiguration0PropertiesArgsDict(TypedDict):
        """
        Prompt source configuration for prompt node
        """
        resource: pulumi.Input['FlowPromptFlowNodeResourceConfigurationArgsDict']
elif False:
    FlowPromptFlowNodeSourceConfiguration0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowPromptFlowNodeSourceConfiguration0PropertiesArgs:
    def __init__(__self__, *,
                 resource: pulumi.Input['FlowPromptFlowNodeResourceConfigurationArgs']):
        """
        Prompt source configuration for prompt node
        """
        pulumi.set(__self__, "resource", resource)

    @_builtins.property
    @pulumi.getter
    def resource(self) -> pulumi.Input['FlowPromptFlowNodeResourceConfigurationArgs']:
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: pulumi.Input['FlowPromptFlowNodeResourceConfigurationArgs']):
        pulumi.set(self, "resource", value)


if not MYPY:
    class FlowPromptFlowNodeSourceConfiguration1PropertiesArgsDict(TypedDict):
        """
        Prompt source configuration for prompt node
        """
        inline: pulumi.Input['FlowPromptFlowNodeInlineConfigurationArgsDict']
elif False:
    FlowPromptFlowNodeSourceConfiguration1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowPromptFlowNodeSourceConfiguration1PropertiesArgs:
    def __init__(__self__, *,
                 inline: pulumi.Input['FlowPromptFlowNodeInlineConfigurationArgs']):
        """
        Prompt source configuration for prompt node
        """
        pulumi.set(__self__, "inline", inline)

    @_builtins.property
    @pulumi.getter
    def inline(self) -> pulumi.Input['FlowPromptFlowNodeInlineConfigurationArgs']:
        return pulumi.get(self, "inline")

    @inline.setter
    def inline(self, value: pulumi.Input['FlowPromptFlowNodeInlineConfigurationArgs']):
        pulumi.set(self, "inline", value)


if not MYPY:
    class FlowPromptInferenceConfigurationPropertiesArgsDict(TypedDict):
        """
        Model inference configuration
        """
        text: pulumi.Input['FlowPromptModelInferenceConfigurationArgsDict']
elif False:
    FlowPromptInferenceConfigurationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowPromptInferenceConfigurationPropertiesArgs:
    def __init__(__self__, *,
                 text: pulumi.Input['FlowPromptModelInferenceConfigurationArgs']):
        """
        Model inference configuration
        """
        pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def text(self) -> pulumi.Input['FlowPromptModelInferenceConfigurationArgs']:
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input['FlowPromptModelInferenceConfigurationArgs']):
        pulumi.set(self, "text", value)


if not MYPY:
    class FlowPromptInputVariableArgsDict(TypedDict):
        """
        Input variable
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name for an input variable
        """
elif False:
    FlowPromptInputVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowPromptInputVariableArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Input variable
        :param pulumi.Input[_builtins.str] name: Name for an input variable
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name for an input variable
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class FlowPromptModelInferenceConfigurationArgsDict(TypedDict):
        """
        Prompt model inference configuration
        """
        max_tokens: NotRequired[pulumi.Input[_builtins.float]]
        """
        Maximum length of output
        """
        stop_sequences: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of stop sequences
        """
        temperature: NotRequired[pulumi.Input[_builtins.float]]
        """
        Controls randomness, higher values increase diversity
        """
        top_p: NotRequired[pulumi.Input[_builtins.float]]
        """
        Cumulative probability cutoff for token selection
        """
elif False:
    FlowPromptModelInferenceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowPromptModelInferenceConfigurationArgs:
    def __init__(__self__, *,
                 max_tokens: Optional[pulumi.Input[_builtins.float]] = None,
                 stop_sequences: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 temperature: Optional[pulumi.Input[_builtins.float]] = None,
                 top_p: Optional[pulumi.Input[_builtins.float]] = None):
        """
        Prompt model inference configuration
        :param pulumi.Input[_builtins.float] max_tokens: Maximum length of output
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] stop_sequences: List of stop sequences
        :param pulumi.Input[_builtins.float] temperature: Controls randomness, higher values increase diversity
        :param pulumi.Input[_builtins.float] top_p: Cumulative probability cutoff for token selection
        """
        if max_tokens is not None:
            pulumi.set(__self__, "max_tokens", max_tokens)
        if stop_sequences is not None:
            pulumi.set(__self__, "stop_sequences", stop_sequences)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)
        if top_p is not None:
            pulumi.set(__self__, "top_p", top_p)

    @_builtins.property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Maximum length of output
        """
        return pulumi.get(self, "max_tokens")

    @max_tokens.setter
    def max_tokens(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "max_tokens", value)

    @_builtins.property
    @pulumi.getter(name="stopSequences")
    def stop_sequences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of stop sequences
        """
        return pulumi.get(self, "stop_sequences")

    @stop_sequences.setter
    def stop_sequences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "stop_sequences", value)

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Controls randomness, higher values increase diversity
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "temperature", value)

    @_builtins.property
    @pulumi.getter(name="topP")
    def top_p(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Cumulative probability cutoff for token selection
        """
        return pulumi.get(self, "top_p")

    @top_p.setter
    def top_p(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "top_p", value)


if not MYPY:
    class FlowPromptTemplateConfigurationPropertiesArgsDict(TypedDict):
        """
        Prompt template configuration
        """
        text: pulumi.Input['FlowTextPromptTemplateConfigurationArgsDict']
elif False:
    FlowPromptTemplateConfigurationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowPromptTemplateConfigurationPropertiesArgs:
    def __init__(__self__, *,
                 text: pulumi.Input['FlowTextPromptTemplateConfigurationArgs']):
        """
        Prompt template configuration
        """
        pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def text(self) -> pulumi.Input['FlowTextPromptTemplateConfigurationArgs']:
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input['FlowTextPromptTemplateConfigurationArgs']):
        pulumi.set(self, "text", value)


if not MYPY:
    class FlowRerankingMetadataSelectiveModeConfiguration0PropertiesArgsDict(TypedDict):
        """
        Reranking Metadata Selective Mode Configuration
        """
        fields_to_include: pulumi.Input[Sequence[pulumi.Input['FlowFieldForRerankingArgsDict']]]
elif False:
    FlowRerankingMetadataSelectiveModeConfiguration0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowRerankingMetadataSelectiveModeConfiguration0PropertiesArgs:
    def __init__(__self__, *,
                 fields_to_include: pulumi.Input[Sequence[pulumi.Input['FlowFieldForRerankingArgs']]]):
        """
        Reranking Metadata Selective Mode Configuration
        """
        pulumi.set(__self__, "fields_to_include", fields_to_include)

    @_builtins.property
    @pulumi.getter(name="fieldsToInclude")
    def fields_to_include(self) -> pulumi.Input[Sequence[pulumi.Input['FlowFieldForRerankingArgs']]]:
        return pulumi.get(self, "fields_to_include")

    @fields_to_include.setter
    def fields_to_include(self, value: pulumi.Input[Sequence[pulumi.Input['FlowFieldForRerankingArgs']]]):
        pulumi.set(self, "fields_to_include", value)


if not MYPY:
    class FlowRerankingMetadataSelectiveModeConfiguration1PropertiesArgsDict(TypedDict):
        """
        Reranking Metadata Selective Mode Configuration
        """
        fields_to_exclude: pulumi.Input[Sequence[pulumi.Input['FlowFieldForRerankingArgsDict']]]
elif False:
    FlowRerankingMetadataSelectiveModeConfiguration1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowRerankingMetadataSelectiveModeConfiguration1PropertiesArgs:
    def __init__(__self__, *,
                 fields_to_exclude: pulumi.Input[Sequence[pulumi.Input['FlowFieldForRerankingArgs']]]):
        """
        Reranking Metadata Selective Mode Configuration
        """
        pulumi.set(__self__, "fields_to_exclude", fields_to_exclude)

    @_builtins.property
    @pulumi.getter(name="fieldsToExclude")
    def fields_to_exclude(self) -> pulumi.Input[Sequence[pulumi.Input['FlowFieldForRerankingArgs']]]:
        return pulumi.get(self, "fields_to_exclude")

    @fields_to_exclude.setter
    def fields_to_exclude(self, value: pulumi.Input[Sequence[pulumi.Input['FlowFieldForRerankingArgs']]]):
        pulumi.set(self, "fields_to_exclude", value)


if not MYPY:
    class FlowRetrievalFlowNodeConfigurationArgsDict(TypedDict):
        """
        Retrieval flow node configuration
        """
        service_configuration: pulumi.Input['FlowRetrievalFlowNodeServiceConfigurationPropertiesArgsDict']
elif False:
    FlowRetrievalFlowNodeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowRetrievalFlowNodeConfigurationArgs:
    def __init__(__self__, *,
                 service_configuration: pulumi.Input['FlowRetrievalFlowNodeServiceConfigurationPropertiesArgs']):
        """
        Retrieval flow node configuration
        """
        pulumi.set(__self__, "service_configuration", service_configuration)

    @_builtins.property
    @pulumi.getter(name="serviceConfiguration")
    def service_configuration(self) -> pulumi.Input['FlowRetrievalFlowNodeServiceConfigurationPropertiesArgs']:
        return pulumi.get(self, "service_configuration")

    @service_configuration.setter
    def service_configuration(self, value: pulumi.Input['FlowRetrievalFlowNodeServiceConfigurationPropertiesArgs']):
        pulumi.set(self, "service_configuration", value)


if not MYPY:
    class FlowRetrievalFlowNodeS3ConfigurationArgsDict(TypedDict):
        """
        s3 Retrieval configuration for Retrieval node
        """
        bucket_name: pulumi.Input[_builtins.str]
        """
        bucket name of an s3 that will be used for Retrieval flow node configuration
        """
elif False:
    FlowRetrievalFlowNodeS3ConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowRetrievalFlowNodeS3ConfigurationArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[_builtins.str]):
        """
        s3 Retrieval configuration for Retrieval node
        :param pulumi.Input[_builtins.str] bucket_name: bucket name of an s3 that will be used for Retrieval flow node configuration
        """
        pulumi.set(__self__, "bucket_name", bucket_name)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[_builtins.str]:
        """
        bucket name of an s3 that will be used for Retrieval flow node configuration
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_name", value)


if not MYPY:
    class FlowRetrievalFlowNodeServiceConfigurationPropertiesArgsDict(TypedDict):
        """
        Retrieval service configuration for Retrieval node
        """
        s3: NotRequired[pulumi.Input['FlowRetrievalFlowNodeS3ConfigurationArgsDict']]
elif False:
    FlowRetrievalFlowNodeServiceConfigurationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowRetrievalFlowNodeServiceConfigurationPropertiesArgs:
    def __init__(__self__, *,
                 s3: Optional[pulumi.Input['FlowRetrievalFlowNodeS3ConfigurationArgs']] = None):
        """
        Retrieval service configuration for Retrieval node
        """
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['FlowRetrievalFlowNodeS3ConfigurationArgs']]:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['FlowRetrievalFlowNodeS3ConfigurationArgs']]):
        pulumi.set(self, "s3", value)


if not MYPY:
    class FlowS3LocationArgsDict(TypedDict):
        """
        A bucket, key and optional version pointing to an S3 object containing a UTF-8 encoded JSON string Definition with the same schema as the Definition property of this resource
        """
        bucket: pulumi.Input[_builtins.str]
        """
        A bucket in S3
        """
        key: pulumi.Input[_builtins.str]
        """
        A object key in S3
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The version of the the S3 object to use
        """
elif False:
    FlowS3LocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowS3LocationArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[_builtins.str],
                 key: pulumi.Input[_builtins.str],
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        A bucket, key and optional version pointing to an S3 object containing a UTF-8 encoded JSON string Definition with the same schema as the Definition property of this resource
        :param pulumi.Input[_builtins.str] bucket: A bucket in S3
        :param pulumi.Input[_builtins.str] key: A object key in S3
        :param pulumi.Input[_builtins.str] version: The version of the the S3 object to use
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "key", key)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[_builtins.str]:
        """
        A bucket in S3
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        A object key in S3
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The version of the the S3 object to use
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class FlowStorageFlowNodeConfigurationArgsDict(TypedDict):
        """
        Storage flow node configuration
        """
        service_configuration: pulumi.Input['FlowStorageFlowNodeServiceConfigurationPropertiesArgsDict']
elif False:
    FlowStorageFlowNodeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowStorageFlowNodeConfigurationArgs:
    def __init__(__self__, *,
                 service_configuration: pulumi.Input['FlowStorageFlowNodeServiceConfigurationPropertiesArgs']):
        """
        Storage flow node configuration
        """
        pulumi.set(__self__, "service_configuration", service_configuration)

    @_builtins.property
    @pulumi.getter(name="serviceConfiguration")
    def service_configuration(self) -> pulumi.Input['FlowStorageFlowNodeServiceConfigurationPropertiesArgs']:
        return pulumi.get(self, "service_configuration")

    @service_configuration.setter
    def service_configuration(self, value: pulumi.Input['FlowStorageFlowNodeServiceConfigurationPropertiesArgs']):
        pulumi.set(self, "service_configuration", value)


if not MYPY:
    class FlowStorageFlowNodeS3ConfigurationArgsDict(TypedDict):
        """
        s3 storage configuration for storage node
        """
        bucket_name: pulumi.Input[_builtins.str]
        """
        bucket name of an s3 that will be used for storage flow node configuration
        """
elif False:
    FlowStorageFlowNodeS3ConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowStorageFlowNodeS3ConfigurationArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[_builtins.str]):
        """
        s3 storage configuration for storage node
        :param pulumi.Input[_builtins.str] bucket_name: bucket name of an s3 that will be used for storage flow node configuration
        """
        pulumi.set(__self__, "bucket_name", bucket_name)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[_builtins.str]:
        """
        bucket name of an s3 that will be used for storage flow node configuration
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_name", value)


if not MYPY:
    class FlowStorageFlowNodeServiceConfigurationPropertiesArgsDict(TypedDict):
        """
        storage service configuration for storage node
        """
        s3: NotRequired[pulumi.Input['FlowStorageFlowNodeS3ConfigurationArgsDict']]
elif False:
    FlowStorageFlowNodeServiceConfigurationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowStorageFlowNodeServiceConfigurationPropertiesArgs:
    def __init__(__self__, *,
                 s3: Optional[pulumi.Input['FlowStorageFlowNodeS3ConfigurationArgs']] = None):
        """
        storage service configuration for storage node
        """
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['FlowStorageFlowNodeS3ConfigurationArgs']]:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['FlowStorageFlowNodeS3ConfigurationArgs']]):
        pulumi.set(self, "s3", value)


if not MYPY:
    class FlowTextPromptTemplateConfigurationArgsDict(TypedDict):
        """
        Configuration for text prompt template
        """
        text: pulumi.Input[_builtins.str]
        """
        Prompt content for String prompt template
        """
        input_variables: NotRequired[pulumi.Input[Sequence[pulumi.Input['FlowPromptInputVariableArgsDict']]]]
        """
        List of input variables
        """
elif False:
    FlowTextPromptTemplateConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowTextPromptTemplateConfigurationArgs:
    def __init__(__self__, *,
                 text: pulumi.Input[_builtins.str],
                 input_variables: Optional[pulumi.Input[Sequence[pulumi.Input['FlowPromptInputVariableArgs']]]] = None):
        """
        Configuration for text prompt template
        :param pulumi.Input[_builtins.str] text: Prompt content for String prompt template
        :param pulumi.Input[Sequence[pulumi.Input['FlowPromptInputVariableArgs']]] input_variables: List of input variables
        """
        pulumi.set(__self__, "text", text)
        if input_variables is not None:
            pulumi.set(__self__, "input_variables", input_variables)

    @_builtins.property
    @pulumi.getter
    def text(self) -> pulumi.Input[_builtins.str]:
        """
        Prompt content for String prompt template
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "text", value)

    @_builtins.property
    @pulumi.getter(name="inputVariables")
    def input_variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FlowPromptInputVariableArgs']]]]:
        """
        List of input variables
        """
        return pulumi.get(self, "input_variables")

    @input_variables.setter
    def input_variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FlowPromptInputVariableArgs']]]]):
        pulumi.set(self, "input_variables", value)


if not MYPY:
    class FlowVectorSearchBedrockRerankingConfigurationArgsDict(TypedDict):
        model_configuration: pulumi.Input['FlowVectorSearchBedrockRerankingModelConfigurationArgsDict']
        metadata_configuration: NotRequired[pulumi.Input['FlowMetadataConfigurationForRerankingArgsDict']]
        number_of_reranked_results: NotRequired[pulumi.Input[_builtins.float]]
        """
        Number Of Results For Reranking
        """
elif False:
    FlowVectorSearchBedrockRerankingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowVectorSearchBedrockRerankingConfigurationArgs:
    def __init__(__self__, *,
                 model_configuration: pulumi.Input['FlowVectorSearchBedrockRerankingModelConfigurationArgs'],
                 metadata_configuration: Optional[pulumi.Input['FlowMetadataConfigurationForRerankingArgs']] = None,
                 number_of_reranked_results: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] number_of_reranked_results: Number Of Results For Reranking
        """
        pulumi.set(__self__, "model_configuration", model_configuration)
        if metadata_configuration is not None:
            pulumi.set(__self__, "metadata_configuration", metadata_configuration)
        if number_of_reranked_results is not None:
            pulumi.set(__self__, "number_of_reranked_results", number_of_reranked_results)

    @_builtins.property
    @pulumi.getter(name="modelConfiguration")
    def model_configuration(self) -> pulumi.Input['FlowVectorSearchBedrockRerankingModelConfigurationArgs']:
        return pulumi.get(self, "model_configuration")

    @model_configuration.setter
    def model_configuration(self, value: pulumi.Input['FlowVectorSearchBedrockRerankingModelConfigurationArgs']):
        pulumi.set(self, "model_configuration", value)

    @_builtins.property
    @pulumi.getter(name="metadataConfiguration")
    def metadata_configuration(self) -> Optional[pulumi.Input['FlowMetadataConfigurationForRerankingArgs']]:
        return pulumi.get(self, "metadata_configuration")

    @metadata_configuration.setter
    def metadata_configuration(self, value: Optional[pulumi.Input['FlowMetadataConfigurationForRerankingArgs']]):
        pulumi.set(self, "metadata_configuration", value)

    @_builtins.property
    @pulumi.getter(name="numberOfRerankedResults")
    def number_of_reranked_results(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Number Of Results For Reranking
        """
        return pulumi.get(self, "number_of_reranked_results")

    @number_of_reranked_results.setter
    def number_of_reranked_results(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "number_of_reranked_results", value)


if not MYPY:
    class FlowVectorSearchBedrockRerankingModelConfigurationArgsDict(TypedDict):
        model_arn: pulumi.Input[_builtins.str]
        additional_model_request_fields: NotRequired[pulumi.Input['FlowAdditionalModelRequestFieldsArgsDict']]
elif False:
    FlowVectorSearchBedrockRerankingModelConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowVectorSearchBedrockRerankingModelConfigurationArgs:
    def __init__(__self__, *,
                 model_arn: pulumi.Input[_builtins.str],
                 additional_model_request_fields: Optional[pulumi.Input['FlowAdditionalModelRequestFieldsArgs']] = None):
        pulumi.set(__self__, "model_arn", model_arn)
        if additional_model_request_fields is not None:
            pulumi.set(__self__, "additional_model_request_fields", additional_model_request_fields)

    @_builtins.property
    @pulumi.getter(name="modelArn")
    def model_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "model_arn")

    @model_arn.setter
    def model_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "model_arn", value)

    @_builtins.property
    @pulumi.getter(name="additionalModelRequestFields")
    def additional_model_request_fields(self) -> Optional[pulumi.Input['FlowAdditionalModelRequestFieldsArgs']]:
        return pulumi.get(self, "additional_model_request_fields")

    @additional_model_request_fields.setter
    def additional_model_request_fields(self, value: Optional[pulumi.Input['FlowAdditionalModelRequestFieldsArgs']]):
        pulumi.set(self, "additional_model_request_fields", value)


if not MYPY:
    class FlowVectorSearchRerankingConfigurationArgsDict(TypedDict):
        type: pulumi.Input['FlowVectorSearchRerankingConfigurationType']
        bedrock_reranking_configuration: NotRequired[pulumi.Input['FlowVectorSearchBedrockRerankingConfigurationArgsDict']]
elif False:
    FlowVectorSearchRerankingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowVectorSearchRerankingConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['FlowVectorSearchRerankingConfigurationType'],
                 bedrock_reranking_configuration: Optional[pulumi.Input['FlowVectorSearchBedrockRerankingConfigurationArgs']] = None):
        pulumi.set(__self__, "type", type)
        if bedrock_reranking_configuration is not None:
            pulumi.set(__self__, "bedrock_reranking_configuration", bedrock_reranking_configuration)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['FlowVectorSearchRerankingConfigurationType']:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['FlowVectorSearchRerankingConfigurationType']):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="bedrockRerankingConfiguration")
    def bedrock_reranking_configuration(self) -> Optional[pulumi.Input['FlowVectorSearchBedrockRerankingConfigurationArgs']]:
        return pulumi.get(self, "bedrock_reranking_configuration")

    @bedrock_reranking_configuration.setter
    def bedrock_reranking_configuration(self, value: Optional[pulumi.Input['FlowVectorSearchBedrockRerankingConfigurationArgs']]):
        pulumi.set(self, "bedrock_reranking_configuration", value)


if not MYPY:
    class GuardrailAutomatedReasoningPolicyConfigArgsDict(TypedDict):
        """
        Optional configuration for integrating Automated Reasoning policies with the guardrail.
        """
        policies: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The list of Automated Reasoning policy ARNs to include in the guardrail configuration
        """
        confidence_threshold: NotRequired[pulumi.Input[_builtins.float]]
        """
        The confidence threshold for triggering guardrail actions based on Automated Reasoning policy violations.
        """
elif False:
    GuardrailAutomatedReasoningPolicyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailAutomatedReasoningPolicyConfigArgs:
    def __init__(__self__, *,
                 policies: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 confidence_threshold: Optional[pulumi.Input[_builtins.float]] = None):
        """
        Optional configuration for integrating Automated Reasoning policies with the guardrail.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] policies: The list of Automated Reasoning policy ARNs to include in the guardrail configuration
        :param pulumi.Input[_builtins.float] confidence_threshold: The confidence threshold for triggering guardrail actions based on Automated Reasoning policy violations.
        """
        pulumi.set(__self__, "policies", policies)
        if confidence_threshold is not None:
            pulumi.set(__self__, "confidence_threshold", confidence_threshold)

    @_builtins.property
    @pulumi.getter
    def policies(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The list of Automated Reasoning policy ARNs to include in the guardrail configuration
        """
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "policies", value)

    @_builtins.property
    @pulumi.getter(name="confidenceThreshold")
    def confidence_threshold(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The confidence threshold for triggering guardrail actions based on Automated Reasoning policy violations.
        """
        return pulumi.get(self, "confidence_threshold")

    @confidence_threshold.setter
    def confidence_threshold(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "confidence_threshold", value)


if not MYPY:
    class GuardrailContentFilterConfigArgsDict(TypedDict):
        """
        Content filter config in content policy.
        """
        input_strength: pulumi.Input['GuardrailFilterStrength']
        """
        The strength of the content filter to apply to prompts. As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.
        """
        output_strength: pulumi.Input['GuardrailFilterStrength']
        """
        The strength of the content filter to apply to model responses. As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.
        """
        type: pulumi.Input['GuardrailContentFilterType']
        """
        The harmful category that the content filter is applied to.
        """
        input_action: NotRequired[pulumi.Input['GuardrailContentFilterAction']]
        """
        Specifies the action to take when harmful content is detected. Supported values include:

        - `BLOCK`  Block the content and replace it with blocked messaging.
        - `NONE`  Take no action but return detection information in the trace response.
        """
        input_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        input_modalities: NotRequired[pulumi.Input[Sequence[pulumi.Input['GuardrailModality']]]]
        """
        List of modalities
        """
        output_action: NotRequired[pulumi.Input['GuardrailContentFilterAction']]
        """
        Specifies the action to take when harmful content is detected in the output. Supported values include:

        - `BLOCK`  Block the content and replace it with blocked messaging.
        - `NONE`  Take no action but return detection information in the trace response.
        """
        output_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        output_modalities: NotRequired[pulumi.Input[Sequence[pulumi.Input['GuardrailModality']]]]
        """
        List of modalities
        """
elif False:
    GuardrailContentFilterConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailContentFilterConfigArgs:
    def __init__(__self__, *,
                 input_strength: pulumi.Input['GuardrailFilterStrength'],
                 output_strength: pulumi.Input['GuardrailFilterStrength'],
                 type: pulumi.Input['GuardrailContentFilterType'],
                 input_action: Optional[pulumi.Input['GuardrailContentFilterAction']] = None,
                 input_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 input_modalities: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailModality']]]] = None,
                 output_action: Optional[pulumi.Input['GuardrailContentFilterAction']] = None,
                 output_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 output_modalities: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailModality']]]] = None):
        """
        Content filter config in content policy.
        :param pulumi.Input['GuardrailFilterStrength'] input_strength: The strength of the content filter to apply to prompts. As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.
        :param pulumi.Input['GuardrailFilterStrength'] output_strength: The strength of the content filter to apply to model responses. As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.
        :param pulumi.Input['GuardrailContentFilterType'] type: The harmful category that the content filter is applied to.
        :param pulumi.Input['GuardrailContentFilterAction'] input_action: Specifies the action to take when harmful content is detected. Supported values include:
               
               - `BLOCK`  Block the content and replace it with blocked messaging.
               - `NONE`  Take no action but return detection information in the trace response.
        :param pulumi.Input[_builtins.bool] input_enabled: Specifies whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailModality']]] input_modalities: List of modalities
        :param pulumi.Input['GuardrailContentFilterAction'] output_action: Specifies the action to take when harmful content is detected in the output. Supported values include:
               
               - `BLOCK`  Block the content and replace it with blocked messaging.
               - `NONE`  Take no action but return detection information in the trace response.
        :param pulumi.Input[_builtins.bool] output_enabled: Specifies whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailModality']]] output_modalities: List of modalities
        """
        pulumi.set(__self__, "input_strength", input_strength)
        pulumi.set(__self__, "output_strength", output_strength)
        pulumi.set(__self__, "type", type)
        if input_action is not None:
            pulumi.set(__self__, "input_action", input_action)
        if input_enabled is not None:
            pulumi.set(__self__, "input_enabled", input_enabled)
        if input_modalities is not None:
            pulumi.set(__self__, "input_modalities", input_modalities)
        if output_action is not None:
            pulumi.set(__self__, "output_action", output_action)
        if output_enabled is not None:
            pulumi.set(__self__, "output_enabled", output_enabled)
        if output_modalities is not None:
            pulumi.set(__self__, "output_modalities", output_modalities)

    @_builtins.property
    @pulumi.getter(name="inputStrength")
    def input_strength(self) -> pulumi.Input['GuardrailFilterStrength']:
        """
        The strength of the content filter to apply to prompts. As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.
        """
        return pulumi.get(self, "input_strength")

    @input_strength.setter
    def input_strength(self, value: pulumi.Input['GuardrailFilterStrength']):
        pulumi.set(self, "input_strength", value)

    @_builtins.property
    @pulumi.getter(name="outputStrength")
    def output_strength(self) -> pulumi.Input['GuardrailFilterStrength']:
        """
        The strength of the content filter to apply to model responses. As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.
        """
        return pulumi.get(self, "output_strength")

    @output_strength.setter
    def output_strength(self, value: pulumi.Input['GuardrailFilterStrength']):
        pulumi.set(self, "output_strength", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['GuardrailContentFilterType']:
        """
        The harmful category that the content filter is applied to.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['GuardrailContentFilterType']):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="inputAction")
    def input_action(self) -> Optional[pulumi.Input['GuardrailContentFilterAction']]:
        """
        Specifies the action to take when harmful content is detected. Supported values include:

        - `BLOCK`  Block the content and replace it with blocked messaging.
        - `NONE`  Take no action but return detection information in the trace response.
        """
        return pulumi.get(self, "input_action")

    @input_action.setter
    def input_action(self, value: Optional[pulumi.Input['GuardrailContentFilterAction']]):
        pulumi.set(self, "input_action", value)

    @_builtins.property
    @pulumi.getter(name="inputEnabled")
    def input_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        return pulumi.get(self, "input_enabled")

    @input_enabled.setter
    def input_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "input_enabled", value)

    @_builtins.property
    @pulumi.getter(name="inputModalities")
    def input_modalities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailModality']]]]:
        """
        List of modalities
        """
        return pulumi.get(self, "input_modalities")

    @input_modalities.setter
    def input_modalities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailModality']]]]):
        pulumi.set(self, "input_modalities", value)

    @_builtins.property
    @pulumi.getter(name="outputAction")
    def output_action(self) -> Optional[pulumi.Input['GuardrailContentFilterAction']]:
        """
        Specifies the action to take when harmful content is detected in the output. Supported values include:

        - `BLOCK`  Block the content and replace it with blocked messaging.
        - `NONE`  Take no action but return detection information in the trace response.
        """
        return pulumi.get(self, "output_action")

    @output_action.setter
    def output_action(self, value: Optional[pulumi.Input['GuardrailContentFilterAction']]):
        pulumi.set(self, "output_action", value)

    @_builtins.property
    @pulumi.getter(name="outputEnabled")
    def output_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        return pulumi.get(self, "output_enabled")

    @output_enabled.setter
    def output_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "output_enabled", value)

    @_builtins.property
    @pulumi.getter(name="outputModalities")
    def output_modalities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailModality']]]]:
        """
        List of modalities
        """
        return pulumi.get(self, "output_modalities")

    @output_modalities.setter
    def output_modalities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailModality']]]]):
        pulumi.set(self, "output_modalities", value)


if not MYPY:
    class GuardrailContentPolicyConfigContentFiltersTierConfigPropertiesArgsDict(TypedDict):
        """
        Guardrail tier config for content policy
        """
        tier_name: pulumi.Input['GuardrailContentFiltersTierName']
elif False:
    GuardrailContentPolicyConfigContentFiltersTierConfigPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailContentPolicyConfigContentFiltersTierConfigPropertiesArgs:
    def __init__(__self__, *,
                 tier_name: pulumi.Input['GuardrailContentFiltersTierName']):
        """
        Guardrail tier config for content policy
        """
        pulumi.set(__self__, "tier_name", tier_name)

    @_builtins.property
    @pulumi.getter(name="tierName")
    def tier_name(self) -> pulumi.Input['GuardrailContentFiltersTierName']:
        return pulumi.get(self, "tier_name")

    @tier_name.setter
    def tier_name(self, value: pulumi.Input['GuardrailContentFiltersTierName']):
        pulumi.set(self, "tier_name", value)


if not MYPY:
    class GuardrailContentPolicyConfigArgsDict(TypedDict):
        """
        Content policy config for a guardrail.
        """
        filters_config: pulumi.Input[Sequence[pulumi.Input['GuardrailContentFilterConfigArgsDict']]]
        """
        List of content filter configs in content policy.
        """
        content_filters_tier_config: NotRequired[pulumi.Input['GuardrailContentPolicyConfigContentFiltersTierConfigPropertiesArgsDict']]
        """
        Guardrail tier config for content policy
        """
elif False:
    GuardrailContentPolicyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailContentPolicyConfigArgs:
    def __init__(__self__, *,
                 filters_config: pulumi.Input[Sequence[pulumi.Input['GuardrailContentFilterConfigArgs']]],
                 content_filters_tier_config: Optional[pulumi.Input['GuardrailContentPolicyConfigContentFiltersTierConfigPropertiesArgs']] = None):
        """
        Content policy config for a guardrail.
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailContentFilterConfigArgs']]] filters_config: List of content filter configs in content policy.
        :param pulumi.Input['GuardrailContentPolicyConfigContentFiltersTierConfigPropertiesArgs'] content_filters_tier_config: Guardrail tier config for content policy
        """
        pulumi.set(__self__, "filters_config", filters_config)
        if content_filters_tier_config is not None:
            pulumi.set(__self__, "content_filters_tier_config", content_filters_tier_config)

    @_builtins.property
    @pulumi.getter(name="filtersConfig")
    def filters_config(self) -> pulumi.Input[Sequence[pulumi.Input['GuardrailContentFilterConfigArgs']]]:
        """
        List of content filter configs in content policy.
        """
        return pulumi.get(self, "filters_config")

    @filters_config.setter
    def filters_config(self, value: pulumi.Input[Sequence[pulumi.Input['GuardrailContentFilterConfigArgs']]]):
        pulumi.set(self, "filters_config", value)

    @_builtins.property
    @pulumi.getter(name="contentFiltersTierConfig")
    def content_filters_tier_config(self) -> Optional[pulumi.Input['GuardrailContentPolicyConfigContentFiltersTierConfigPropertiesArgs']]:
        """
        Guardrail tier config for content policy
        """
        return pulumi.get(self, "content_filters_tier_config")

    @content_filters_tier_config.setter
    def content_filters_tier_config(self, value: Optional[pulumi.Input['GuardrailContentPolicyConfigContentFiltersTierConfigPropertiesArgs']]):
        pulumi.set(self, "content_filters_tier_config", value)


if not MYPY:
    class GuardrailContextualGroundingFilterConfigArgsDict(TypedDict):
        """
        A config for grounding filter.
        """
        threshold: pulumi.Input[_builtins.float]
        """
        The threshold for this filter.
        """
        type: pulumi.Input['GuardrailContextualGroundingFilterType']
        """
        The filter details for the guardrails contextual grounding filter.
        """
        action: NotRequired[pulumi.Input['GuardrailContextualGroundingAction']]
        """
        Specifies the action to take when content fails the contextual grounding evaluation. Supported values include:

        - `BLOCK`  Block the content and replace it with blocked messaging.
        - `NONE`  Take no action but return detection information in the trace response.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable contextual grounding evaluation. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
elif False:
    GuardrailContextualGroundingFilterConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailContextualGroundingFilterConfigArgs:
    def __init__(__self__, *,
                 threshold: pulumi.Input[_builtins.float],
                 type: pulumi.Input['GuardrailContextualGroundingFilterType'],
                 action: Optional[pulumi.Input['GuardrailContextualGroundingAction']] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        A config for grounding filter.
        :param pulumi.Input[_builtins.float] threshold: The threshold for this filter.
        :param pulumi.Input['GuardrailContextualGroundingFilterType'] type: The filter details for the guardrails contextual grounding filter.
        :param pulumi.Input['GuardrailContextualGroundingAction'] action: Specifies the action to take when content fails the contextual grounding evaluation. Supported values include:
               
               - `BLOCK`  Block the content and replace it with blocked messaging.
               - `NONE`  Take no action but return detection information in the trace response.
        :param pulumi.Input[_builtins.bool] enabled: Specifies whether to enable contextual grounding evaluation. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "type", type)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[_builtins.float]:
        """
        The threshold for this filter.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "threshold", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['GuardrailContextualGroundingFilterType']:
        """
        The filter details for the guardrails contextual grounding filter.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['GuardrailContextualGroundingFilterType']):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input['GuardrailContextualGroundingAction']]:
        """
        Specifies the action to take when content fails the contextual grounding evaluation. Supported values include:

        - `BLOCK`  Block the content and replace it with blocked messaging.
        - `NONE`  Take no action but return detection information in the trace response.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input['GuardrailContextualGroundingAction']]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable contextual grounding evaluation. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class GuardrailContextualGroundingPolicyConfigArgsDict(TypedDict):
        """
        Contextual grounding policy config for a guardrail.
        """
        filters_config: pulumi.Input[Sequence[pulumi.Input['GuardrailContextualGroundingFilterConfigArgsDict']]]
        """
        List of contextual grounding filter configs.
        """
elif False:
    GuardrailContextualGroundingPolicyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailContextualGroundingPolicyConfigArgs:
    def __init__(__self__, *,
                 filters_config: pulumi.Input[Sequence[pulumi.Input['GuardrailContextualGroundingFilterConfigArgs']]]):
        """
        Contextual grounding policy config for a guardrail.
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailContextualGroundingFilterConfigArgs']]] filters_config: List of contextual grounding filter configs.
        """
        pulumi.set(__self__, "filters_config", filters_config)

    @_builtins.property
    @pulumi.getter(name="filtersConfig")
    def filters_config(self) -> pulumi.Input[Sequence[pulumi.Input['GuardrailContextualGroundingFilterConfigArgs']]]:
        """
        List of contextual grounding filter configs.
        """
        return pulumi.get(self, "filters_config")

    @filters_config.setter
    def filters_config(self, value: pulumi.Input[Sequence[pulumi.Input['GuardrailContextualGroundingFilterConfigArgs']]]):
        pulumi.set(self, "filters_config", value)


if not MYPY:
    class GuardrailCrossRegionConfigArgsDict(TypedDict):
        """
        The system-defined guardrail profile that youre using with your guardrail
        """
        guardrail_profile_arn: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name (ARN) of the guardrail profile
        """
elif False:
    GuardrailCrossRegionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailCrossRegionConfigArgs:
    def __init__(__self__, *,
                 guardrail_profile_arn: pulumi.Input[_builtins.str]):
        """
        The system-defined guardrail profile that youre using with your guardrail
        :param pulumi.Input[_builtins.str] guardrail_profile_arn: The Amazon Resource Name (ARN) of the guardrail profile
        """
        pulumi.set(__self__, "guardrail_profile_arn", guardrail_profile_arn)

    @_builtins.property
    @pulumi.getter(name="guardrailProfileArn")
    def guardrail_profile_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the guardrail profile
        """
        return pulumi.get(self, "guardrail_profile_arn")

    @guardrail_profile_arn.setter
    def guardrail_profile_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "guardrail_profile_arn", value)


if not MYPY:
    class GuardrailManagedWordsConfigArgsDict(TypedDict):
        """
        A managed words config.
        """
        type: pulumi.Input['GuardrailManagedWordsType']
        """
        The managed word type to configure for the guardrail.
        """
        input_action: NotRequired[pulumi.Input['GuardrailWordAction']]
        """
        Specifies the action to take when harmful content is detected in the input. Supported values include:

        - `BLOCK`  Block the content and replace it with blocked messaging.
        - `NONE`  Take no action but return detection information in the trace response.
        """
        input_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        output_action: NotRequired[pulumi.Input['GuardrailWordAction']]
        """
        Specifies the action to take when harmful content is detected in the output. Supported values include:

        - `BLOCK`  Block the content and replace it with blocked messaging.
        - `NONE`  Take no action but return detection information in the trace response.
        """
        output_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
elif False:
    GuardrailManagedWordsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailManagedWordsConfigArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['GuardrailManagedWordsType'],
                 input_action: Optional[pulumi.Input['GuardrailWordAction']] = None,
                 input_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 output_action: Optional[pulumi.Input['GuardrailWordAction']] = None,
                 output_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        A managed words config.
        :param pulumi.Input['GuardrailManagedWordsType'] type: The managed word type to configure for the guardrail.
        :param pulumi.Input['GuardrailWordAction'] input_action: Specifies the action to take when harmful content is detected in the input. Supported values include:
               
               - `BLOCK`  Block the content and replace it with blocked messaging.
               - `NONE`  Take no action but return detection information in the trace response.
        :param pulumi.Input[_builtins.bool] input_enabled: Specifies whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        :param pulumi.Input['GuardrailWordAction'] output_action: Specifies the action to take when harmful content is detected in the output. Supported values include:
               
               - `BLOCK`  Block the content and replace it with blocked messaging.
               - `NONE`  Take no action but return detection information in the trace response.
        :param pulumi.Input[_builtins.bool] output_enabled: Specifies whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        pulumi.set(__self__, "type", type)
        if input_action is not None:
            pulumi.set(__self__, "input_action", input_action)
        if input_enabled is not None:
            pulumi.set(__self__, "input_enabled", input_enabled)
        if output_action is not None:
            pulumi.set(__self__, "output_action", output_action)
        if output_enabled is not None:
            pulumi.set(__self__, "output_enabled", output_enabled)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['GuardrailManagedWordsType']:
        """
        The managed word type to configure for the guardrail.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['GuardrailManagedWordsType']):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="inputAction")
    def input_action(self) -> Optional[pulumi.Input['GuardrailWordAction']]:
        """
        Specifies the action to take when harmful content is detected in the input. Supported values include:

        - `BLOCK`  Block the content and replace it with blocked messaging.
        - `NONE`  Take no action but return detection information in the trace response.
        """
        return pulumi.get(self, "input_action")

    @input_action.setter
    def input_action(self, value: Optional[pulumi.Input['GuardrailWordAction']]):
        pulumi.set(self, "input_action", value)

    @_builtins.property
    @pulumi.getter(name="inputEnabled")
    def input_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        return pulumi.get(self, "input_enabled")

    @input_enabled.setter
    def input_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "input_enabled", value)

    @_builtins.property
    @pulumi.getter(name="outputAction")
    def output_action(self) -> Optional[pulumi.Input['GuardrailWordAction']]:
        """
        Specifies the action to take when harmful content is detected in the output. Supported values include:

        - `BLOCK`  Block the content and replace it with blocked messaging.
        - `NONE`  Take no action but return detection information in the trace response.
        """
        return pulumi.get(self, "output_action")

    @output_action.setter
    def output_action(self, value: Optional[pulumi.Input['GuardrailWordAction']]):
        pulumi.set(self, "output_action", value)

    @_builtins.property
    @pulumi.getter(name="outputEnabled")
    def output_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        return pulumi.get(self, "output_enabled")

    @output_enabled.setter
    def output_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "output_enabled", value)


if not MYPY:
    class GuardrailPiiEntityConfigArgsDict(TypedDict):
        """
        Pii entity configuration.
        """
        action: pulumi.Input['GuardrailSensitiveInformationAction']
        """
        Configure guardrail action when the PII entity is detected.
        """
        type: pulumi.Input['GuardrailPiiEntityType']
        """
        Configure guardrail type when the PII entity is detected.

        The following PIIs are used to block or mask sensitive information:

        - *General*

        - *ADDRESS*

        A physical address, such as "100 Main Street, Anytown, USA" or "Suite #12, Building 123". An address can include information such as the street, building, location, city, state, country, county, zip code, precinct, and neighborhood.
        - *AGE*

        An individual's age, including the quantity and unit of time. For example, in the phrase "I am 40 years old," Guardrails recognizes "40 years" as an age.
        - *NAME*

        An individual's name. This entity type does not include titles, such as Dr., Mr., Mrs., or Miss. guardrails doesn't apply this entity type to names that are part of organizations or addresses. For example, guardrails recognizes the "John Doe Organization" as an organization, and it recognizes "Jane Doe Street" as an address.
        - *EMAIL*

        An email address, such as *marymajor@email.com* .
        - *PHONE*

        A phone number. This entity type also includes fax and pager numbers.
        - *USERNAME*

        A user name that identifies an account, such as a login name, screen name, nick name, or handle.
        - *PASSWORD*

        An alphanumeric string that is used as a password, such as "* *very20special#pass** ".
        - *DRIVER_ID*

        The number assigned to a driver's license, which is an official document permitting an individual to operate one or more motorized vehicles on a public road. A driver's license number consists of alphanumeric characters.
        - *LICENSE_PLATE*

        A license plate for a vehicle is issued by the state or country where the vehicle is registered. The format for passenger vehicles is typically five to eight digits, consisting of upper-case letters and numbers. The format varies depending on the location of the issuing state or country.
        - *VEHICLE_IDENTIFICATION_NUMBER*

        A Vehicle Identification Number (VIN) uniquely identifies a vehicle. VIN content and format are defined in the *ISO 3779* specification. Each country has specific codes and formats for VINs.
        - *Finance*

        - *CREDIT_DEBIT_CARD_CVV*

        A three-digit card verification code (CVV) that is present on VISA, MasterCard, and Discover credit and debit cards. For American Express credit or debit cards, the CVV is a four-digit numeric code.
        - *CREDIT_DEBIT_CARD_EXPIRY*

        The expiration date for a credit or debit card. This number is usually four digits long and is often formatted as *month/year* or *MM/YY* . Guardrails recognizes expiration dates such as *01/21* , *01/2021* , and *Jan 2021* .
        - *CREDIT_DEBIT_CARD_NUMBER*

        The number for a credit or debit card. These numbers can vary from 13 to 16 digits in length. However, Amazon Comprehend also recognizes credit or debit card numbers when only the last four digits are present.
        - *PIN*

        A four-digit personal identification number (PIN) with which you can access your bank account.
        - *INTERNATIONAL_BANK_ACCOUNT_NUMBER*

        An International Bank Account Number has specific formats in each country. For more information, see [www.iban.com/structure](https://docs.aws.amazon.com/https://www.iban.com/structure) .
        - *SWIFT_CODE*

        A SWIFT code is a standard format of Bank Identifier Code (BIC) used to specify a particular bank or branch. Banks use these codes for money transfers such as international wire transfers.

        SWIFT codes consist of eight or 11 characters. The 11-digit codes refer to specific branches, while eight-digit codes (or 11-digit codes ending in 'XXX') refer to the head or primary office.
        - *IT*

        - *IP_ADDRESS*

        An IPv4 address, such as *198.51.100.0* .
        - *MAC_ADDRESS*

        A *media access control* (MAC) address is a unique identifier assigned to a network interface controller (NIC).
        - *URL*

        A web address, such as *www.example.com* .
        - *AWS_ACCESS_KEY*

        A unique identifier that's associated with a secret access key; you use the access key ID and secret access key to sign programmatic AWS requests cryptographically.
        - *AWS_SECRET_KEY*

        A unique identifier that's associated with an access key. You use the access key ID and secret access key to sign programmatic AWS requests cryptographically.
        - *USA specific*

        - *US_BANK_ACCOUNT_NUMBER*

        A US bank account number, which is typically 10 to 12 digits long.
        - *US_BANK_ROUTING_NUMBER*

        A US bank account routing number. These are typically nine digits long,
        - *US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER*

        A US Individual Taxpayer Identification Number (ITIN) is a nine-digit number that starts with a "9" and contain a "7" or "8" as the fourth digit. An ITIN can be formatted with a space or a dash after the third and forth digits.
        - *US_PASSPORT_NUMBER*

        A US passport number. Passport numbers range from six to nine alphanumeric characters.
        - *US_SOCIAL_SECURITY_NUMBER*

        A US Social Security Number (SSN) is a nine-digit number that is issued to US citizens, permanent residents, and temporary working residents.
        - *Canada specific*

        - *CA_HEALTH_NUMBER*

        A Canadian Health Service Number is a 10-digit unique identifier, required for individuals to access healthcare benefits.
        - *CA_SOCIAL_INSURANCE_NUMBER*

        A Canadian Social Insurance Number (SIN) is a nine-digit unique identifier, required for individuals to access government programs and benefits.

        The SIN is formatted as three groups of three digits, such as *123-456-789* . A SIN can be validated through a simple check-digit process called the [Luhn algorithm](https://docs.aws.amazon.com/https://www.wikipedia.org/wiki/Luhn_algorithm) .
        - *UK Specific*

        - *UK_NATIONAL_HEALTH_SERVICE_NUMBER*

        A UK National Health Service Number is a 10-17 digit number, such as *485 777 3456* . The current system formats the 10-digit number with spaces after the third and sixth digits. The final digit is an error-detecting checksum.
        - *UK_NATIONAL_INSURANCE_NUMBER*

        A UK National Insurance Number (NINO) provides individuals with access to National Insurance (social security) benefits. It is also used for some purposes in the UK tax system.

        The number is nine digits long and starts with two letters, followed by six numbers and one letter. A NINO can be formatted with a space or a dash after the two letters and after the second, forth, and sixth digits.
        - *UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER*

        A UK Unique Taxpayer Reference (UTR) is a 10-digit number that identifies a taxpayer or a business.
        - *Custom*

        - *Regex filter* - You can use a regular expressions to define patterns for a guardrail to recognize and act upon such as serial number, booking ID etc..
        """
        input_action: NotRequired[pulumi.Input['GuardrailSensitiveInformationAction']]
        """
        Specifies the action to take when harmful content is detected in the input. Supported values include:

        - `BLOCK`  Block the content and replace it with blocked messaging.
        - `ANONYMIZE`  Mask the content and replace it with identifier tags.
        - `NONE`  Take no action but return detection information in the trace response.
        """
        input_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        output_action: NotRequired[pulumi.Input['GuardrailSensitiveInformationAction']]
        """
        Specifies the action to take when harmful content is detected in the output. Supported values include:

        - `BLOCK`  Block the content and replace it with blocked messaging.
        - `ANONYMIZE`  Mask the content and replace it with identifier tags.
        - `NONE`  Take no action but return detection information in the trace response.
        """
        output_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether guardrail evaluation is enabled on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
elif False:
    GuardrailPiiEntityConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailPiiEntityConfigArgs:
    def __init__(__self__, *,
                 action: pulumi.Input['GuardrailSensitiveInformationAction'],
                 type: pulumi.Input['GuardrailPiiEntityType'],
                 input_action: Optional[pulumi.Input['GuardrailSensitiveInformationAction']] = None,
                 input_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 output_action: Optional[pulumi.Input['GuardrailSensitiveInformationAction']] = None,
                 output_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        Pii entity configuration.
        :param pulumi.Input['GuardrailSensitiveInformationAction'] action: Configure guardrail action when the PII entity is detected.
        :param pulumi.Input['GuardrailPiiEntityType'] type: Configure guardrail type when the PII entity is detected.
               
               The following PIIs are used to block or mask sensitive information:
               
               - *General*
               
               - *ADDRESS*
               
               A physical address, such as "100 Main Street, Anytown, USA" or "Suite #12, Building 123". An address can include information such as the street, building, location, city, state, country, county, zip code, precinct, and neighborhood.
               - *AGE*
               
               An individual's age, including the quantity and unit of time. For example, in the phrase "I am 40 years old," Guardrails recognizes "40 years" as an age.
               - *NAME*
               
               An individual's name. This entity type does not include titles, such as Dr., Mr., Mrs., or Miss. guardrails doesn't apply this entity type to names that are part of organizations or addresses. For example, guardrails recognizes the "John Doe Organization" as an organization, and it recognizes "Jane Doe Street" as an address.
               - *EMAIL*
               
               An email address, such as *marymajor@email.com* .
               - *PHONE*
               
               A phone number. This entity type also includes fax and pager numbers.
               - *USERNAME*
               
               A user name that identifies an account, such as a login name, screen name, nick name, or handle.
               - *PASSWORD*
               
               An alphanumeric string that is used as a password, such as "* *very20special#pass** ".
               - *DRIVER_ID*
               
               The number assigned to a driver's license, which is an official document permitting an individual to operate one or more motorized vehicles on a public road. A driver's license number consists of alphanumeric characters.
               - *LICENSE_PLATE*
               
               A license plate for a vehicle is issued by the state or country where the vehicle is registered. The format for passenger vehicles is typically five to eight digits, consisting of upper-case letters and numbers. The format varies depending on the location of the issuing state or country.
               - *VEHICLE_IDENTIFICATION_NUMBER*
               
               A Vehicle Identification Number (VIN) uniquely identifies a vehicle. VIN content and format are defined in the *ISO 3779* specification. Each country has specific codes and formats for VINs.
               - *Finance*
               
               - *CREDIT_DEBIT_CARD_CVV*
               
               A three-digit card verification code (CVV) that is present on VISA, MasterCard, and Discover credit and debit cards. For American Express credit or debit cards, the CVV is a four-digit numeric code.
               - *CREDIT_DEBIT_CARD_EXPIRY*
               
               The expiration date for a credit or debit card. This number is usually four digits long and is often formatted as *month/year* or *MM/YY* . Guardrails recognizes expiration dates such as *01/21* , *01/2021* , and *Jan 2021* .
               - *CREDIT_DEBIT_CARD_NUMBER*
               
               The number for a credit or debit card. These numbers can vary from 13 to 16 digits in length. However, Amazon Comprehend also recognizes credit or debit card numbers when only the last four digits are present.
               - *PIN*
               
               A four-digit personal identification number (PIN) with which you can access your bank account.
               - *INTERNATIONAL_BANK_ACCOUNT_NUMBER*
               
               An International Bank Account Number has specific formats in each country. For more information, see [www.iban.com/structure](https://docs.aws.amazon.com/https://www.iban.com/structure) .
               - *SWIFT_CODE*
               
               A SWIFT code is a standard format of Bank Identifier Code (BIC) used to specify a particular bank or branch. Banks use these codes for money transfers such as international wire transfers.
               
               SWIFT codes consist of eight or 11 characters. The 11-digit codes refer to specific branches, while eight-digit codes (or 11-digit codes ending in 'XXX') refer to the head or primary office.
               - *IT*
               
               - *IP_ADDRESS*
               
               An IPv4 address, such as *198.51.100.0* .
               - *MAC_ADDRESS*
               
               A *media access control* (MAC) address is a unique identifier assigned to a network interface controller (NIC).
               - *URL*
               
               A web address, such as *www.example.com* .
               - *AWS_ACCESS_KEY*
               
               A unique identifier that's associated with a secret access key; you use the access key ID and secret access key to sign programmatic AWS requests cryptographically.
               - *AWS_SECRET_KEY*
               
               A unique identifier that's associated with an access key. You use the access key ID and secret access key to sign programmatic AWS requests cryptographically.
               - *USA specific*
               
               - *US_BANK_ACCOUNT_NUMBER*
               
               A US bank account number, which is typically 10 to 12 digits long.
               - *US_BANK_ROUTING_NUMBER*
               
               A US bank account routing number. These are typically nine digits long,
               - *US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER*
               
               A US Individual Taxpayer Identification Number (ITIN) is a nine-digit number that starts with a "9" and contain a "7" or "8" as the fourth digit. An ITIN can be formatted with a space or a dash after the third and forth digits.
               - *US_PASSPORT_NUMBER*
               
               A US passport number. Passport numbers range from six to nine alphanumeric characters.
               - *US_SOCIAL_SECURITY_NUMBER*
               
               A US Social Security Number (SSN) is a nine-digit number that is issued to US citizens, permanent residents, and temporary working residents.
               - *Canada specific*
               
               - *CA_HEALTH_NUMBER*
               
               A Canadian Health Service Number is a 10-digit unique identifier, required for individuals to access healthcare benefits.
               - *CA_SOCIAL_INSURANCE_NUMBER*
               
               A Canadian Social Insurance Number (SIN) is a nine-digit unique identifier, required for individuals to access government programs and benefits.
               
               The SIN is formatted as three groups of three digits, such as *123-456-789* . A SIN can be validated through a simple check-digit process called the [Luhn algorithm](https://docs.aws.amazon.com/https://www.wikipedia.org/wiki/Luhn_algorithm) .
               - *UK Specific*
               
               - *UK_NATIONAL_HEALTH_SERVICE_NUMBER*
               
               A UK National Health Service Number is a 10-17 digit number, such as *485 777 3456* . The current system formats the 10-digit number with spaces after the third and sixth digits. The final digit is an error-detecting checksum.
               - *UK_NATIONAL_INSURANCE_NUMBER*
               
               A UK National Insurance Number (NINO) provides individuals with access to National Insurance (social security) benefits. It is also used for some purposes in the UK tax system.
               
               The number is nine digits long and starts with two letters, followed by six numbers and one letter. A NINO can be formatted with a space or a dash after the two letters and after the second, forth, and sixth digits.
               - *UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER*
               
               A UK Unique Taxpayer Reference (UTR) is a 10-digit number that identifies a taxpayer or a business.
               - *Custom*
               
               - *Regex filter* - You can use a regular expressions to define patterns for a guardrail to recognize and act upon such as serial number, booking ID etc..
        :param pulumi.Input['GuardrailSensitiveInformationAction'] input_action: Specifies the action to take when harmful content is detected in the input. Supported values include:
               
               - `BLOCK`  Block the content and replace it with blocked messaging.
               - `ANONYMIZE`  Mask the content and replace it with identifier tags.
               - `NONE`  Take no action but return detection information in the trace response.
        :param pulumi.Input[_builtins.bool] input_enabled: Specifies whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        :param pulumi.Input['GuardrailSensitiveInformationAction'] output_action: Specifies the action to take when harmful content is detected in the output. Supported values include:
               
               - `BLOCK`  Block the content and replace it with blocked messaging.
               - `ANONYMIZE`  Mask the content and replace it with identifier tags.
               - `NONE`  Take no action but return detection information in the trace response.
        :param pulumi.Input[_builtins.bool] output_enabled: Indicates whether guardrail evaluation is enabled on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "type", type)
        if input_action is not None:
            pulumi.set(__self__, "input_action", input_action)
        if input_enabled is not None:
            pulumi.set(__self__, "input_enabled", input_enabled)
        if output_action is not None:
            pulumi.set(__self__, "output_action", output_action)
        if output_enabled is not None:
            pulumi.set(__self__, "output_enabled", output_enabled)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input['GuardrailSensitiveInformationAction']:
        """
        Configure guardrail action when the PII entity is detected.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input['GuardrailSensitiveInformationAction']):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['GuardrailPiiEntityType']:
        """
        Configure guardrail type when the PII entity is detected.

        The following PIIs are used to block or mask sensitive information:

        - *General*

        - *ADDRESS*

        A physical address, such as "100 Main Street, Anytown, USA" or "Suite #12, Building 123". An address can include information such as the street, building, location, city, state, country, county, zip code, precinct, and neighborhood.
        - *AGE*

        An individual's age, including the quantity and unit of time. For example, in the phrase "I am 40 years old," Guardrails recognizes "40 years" as an age.
        - *NAME*

        An individual's name. This entity type does not include titles, such as Dr., Mr., Mrs., or Miss. guardrails doesn't apply this entity type to names that are part of organizations or addresses. For example, guardrails recognizes the "John Doe Organization" as an organization, and it recognizes "Jane Doe Street" as an address.
        - *EMAIL*

        An email address, such as *marymajor@email.com* .
        - *PHONE*

        A phone number. This entity type also includes fax and pager numbers.
        - *USERNAME*

        A user name that identifies an account, such as a login name, screen name, nick name, or handle.
        - *PASSWORD*

        An alphanumeric string that is used as a password, such as "* *very20special#pass** ".
        - *DRIVER_ID*

        The number assigned to a driver's license, which is an official document permitting an individual to operate one or more motorized vehicles on a public road. A driver's license number consists of alphanumeric characters.
        - *LICENSE_PLATE*

        A license plate for a vehicle is issued by the state or country where the vehicle is registered. The format for passenger vehicles is typically five to eight digits, consisting of upper-case letters and numbers. The format varies depending on the location of the issuing state or country.
        - *VEHICLE_IDENTIFICATION_NUMBER*

        A Vehicle Identification Number (VIN) uniquely identifies a vehicle. VIN content and format are defined in the *ISO 3779* specification. Each country has specific codes and formats for VINs.
        - *Finance*

        - *CREDIT_DEBIT_CARD_CVV*

        A three-digit card verification code (CVV) that is present on VISA, MasterCard, and Discover credit and debit cards. For American Express credit or debit cards, the CVV is a four-digit numeric code.
        - *CREDIT_DEBIT_CARD_EXPIRY*

        The expiration date for a credit or debit card. This number is usually four digits long and is often formatted as *month/year* or *MM/YY* . Guardrails recognizes expiration dates such as *01/21* , *01/2021* , and *Jan 2021* .
        - *CREDIT_DEBIT_CARD_NUMBER*

        The number for a credit or debit card. These numbers can vary from 13 to 16 digits in length. However, Amazon Comprehend also recognizes credit or debit card numbers when only the last four digits are present.
        - *PIN*

        A four-digit personal identification number (PIN) with which you can access your bank account.
        - *INTERNATIONAL_BANK_ACCOUNT_NUMBER*

        An International Bank Account Number has specific formats in each country. For more information, see [www.iban.com/structure](https://docs.aws.amazon.com/https://www.iban.com/structure) .
        - *SWIFT_CODE*

        A SWIFT code is a standard format of Bank Identifier Code (BIC) used to specify a particular bank or branch. Banks use these codes for money transfers such as international wire transfers.

        SWIFT codes consist of eight or 11 characters. The 11-digit codes refer to specific branches, while eight-digit codes (or 11-digit codes ending in 'XXX') refer to the head or primary office.
        - *IT*

        - *IP_ADDRESS*

        An IPv4 address, such as *198.51.100.0* .
        - *MAC_ADDRESS*

        A *media access control* (MAC) address is a unique identifier assigned to a network interface controller (NIC).
        - *URL*

        A web address, such as *www.example.com* .
        - *AWS_ACCESS_KEY*

        A unique identifier that's associated with a secret access key; you use the access key ID and secret access key to sign programmatic AWS requests cryptographically.
        - *AWS_SECRET_KEY*

        A unique identifier that's associated with an access key. You use the access key ID and secret access key to sign programmatic AWS requests cryptographically.
        - *USA specific*

        - *US_BANK_ACCOUNT_NUMBER*

        A US bank account number, which is typically 10 to 12 digits long.
        - *US_BANK_ROUTING_NUMBER*

        A US bank account routing number. These are typically nine digits long,
        - *US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER*

        A US Individual Taxpayer Identification Number (ITIN) is a nine-digit number that starts with a "9" and contain a "7" or "8" as the fourth digit. An ITIN can be formatted with a space or a dash after the third and forth digits.
        - *US_PASSPORT_NUMBER*

        A US passport number. Passport numbers range from six to nine alphanumeric characters.
        - *US_SOCIAL_SECURITY_NUMBER*

        A US Social Security Number (SSN) is a nine-digit number that is issued to US citizens, permanent residents, and temporary working residents.
        - *Canada specific*

        - *CA_HEALTH_NUMBER*

        A Canadian Health Service Number is a 10-digit unique identifier, required for individuals to access healthcare benefits.
        - *CA_SOCIAL_INSURANCE_NUMBER*

        A Canadian Social Insurance Number (SIN) is a nine-digit unique identifier, required for individuals to access government programs and benefits.

        The SIN is formatted as three groups of three digits, such as *123-456-789* . A SIN can be validated through a simple check-digit process called the [Luhn algorithm](https://docs.aws.amazon.com/https://www.wikipedia.org/wiki/Luhn_algorithm) .
        - *UK Specific*

        - *UK_NATIONAL_HEALTH_SERVICE_NUMBER*

        A UK National Health Service Number is a 10-17 digit number, such as *485 777 3456* . The current system formats the 10-digit number with spaces after the third and sixth digits. The final digit is an error-detecting checksum.
        - *UK_NATIONAL_INSURANCE_NUMBER*

        A UK National Insurance Number (NINO) provides individuals with access to National Insurance (social security) benefits. It is also used for some purposes in the UK tax system.

        The number is nine digits long and starts with two letters, followed by six numbers and one letter. A NINO can be formatted with a space or a dash after the two letters and after the second, forth, and sixth digits.
        - *UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER*

        A UK Unique Taxpayer Reference (UTR) is a 10-digit number that identifies a taxpayer or a business.
        - *Custom*

        - *Regex filter* - You can use a regular expressions to define patterns for a guardrail to recognize and act upon such as serial number, booking ID etc..
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['GuardrailPiiEntityType']):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="inputAction")
    def input_action(self) -> Optional[pulumi.Input['GuardrailSensitiveInformationAction']]:
        """
        Specifies the action to take when harmful content is detected in the input. Supported values include:

        - `BLOCK`  Block the content and replace it with blocked messaging.
        - `ANONYMIZE`  Mask the content and replace it with identifier tags.
        - `NONE`  Take no action but return detection information in the trace response.
        """
        return pulumi.get(self, "input_action")

    @input_action.setter
    def input_action(self, value: Optional[pulumi.Input['GuardrailSensitiveInformationAction']]):
        pulumi.set(self, "input_action", value)

    @_builtins.property
    @pulumi.getter(name="inputEnabled")
    def input_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        return pulumi.get(self, "input_enabled")

    @input_enabled.setter
    def input_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "input_enabled", value)

    @_builtins.property
    @pulumi.getter(name="outputAction")
    def output_action(self) -> Optional[pulumi.Input['GuardrailSensitiveInformationAction']]:
        """
        Specifies the action to take when harmful content is detected in the output. Supported values include:

        - `BLOCK`  Block the content and replace it with blocked messaging.
        - `ANONYMIZE`  Mask the content and replace it with identifier tags.
        - `NONE`  Take no action but return detection information in the trace response.
        """
        return pulumi.get(self, "output_action")

    @output_action.setter
    def output_action(self, value: Optional[pulumi.Input['GuardrailSensitiveInformationAction']]):
        pulumi.set(self, "output_action", value)

    @_builtins.property
    @pulumi.getter(name="outputEnabled")
    def output_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether guardrail evaluation is enabled on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        return pulumi.get(self, "output_enabled")

    @output_enabled.setter
    def output_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "output_enabled", value)


if not MYPY:
    class GuardrailRegexConfigArgsDict(TypedDict):
        """
        A regex configuration.
        """
        action: pulumi.Input['GuardrailSensitiveInformationAction']
        """
        The guardrail action to configure when matching regular expression is detected.
        """
        name: pulumi.Input[_builtins.str]
        """
        The regex name.
        """
        pattern: pulumi.Input[_builtins.str]
        """
        The regex pattern.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The regex description.
        """
        input_action: NotRequired[pulumi.Input['GuardrailSensitiveInformationAction']]
        """
        Specifies the action to take when harmful content is detected in the input. Supported values include:

        - `BLOCK`  Block the content and replace it with blocked messaging.
        - `NONE`  Take no action but return detection information in the trace response.
        """
        input_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        output_action: NotRequired[pulumi.Input['GuardrailSensitiveInformationAction']]
        """
        Specifies the action to take when harmful content is detected in the output. Supported values include:

        - `BLOCK`  Block the content and replace it with blocked messaging.
        - `NONE`  Take no action but return detection information in the trace response.
        """
        output_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
elif False:
    GuardrailRegexConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailRegexConfigArgs:
    def __init__(__self__, *,
                 action: pulumi.Input['GuardrailSensitiveInformationAction'],
                 name: pulumi.Input[_builtins.str],
                 pattern: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 input_action: Optional[pulumi.Input['GuardrailSensitiveInformationAction']] = None,
                 input_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 output_action: Optional[pulumi.Input['GuardrailSensitiveInformationAction']] = None,
                 output_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        A regex configuration.
        :param pulumi.Input['GuardrailSensitiveInformationAction'] action: The guardrail action to configure when matching regular expression is detected.
        :param pulumi.Input[_builtins.str] name: The regex name.
        :param pulumi.Input[_builtins.str] pattern: The regex pattern.
        :param pulumi.Input[_builtins.str] description: The regex description.
        :param pulumi.Input['GuardrailSensitiveInformationAction'] input_action: Specifies the action to take when harmful content is detected in the input. Supported values include:
               
               - `BLOCK`  Block the content and replace it with blocked messaging.
               - `NONE`  Take no action but return detection information in the trace response.
        :param pulumi.Input[_builtins.bool] input_enabled: Specifies whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        :param pulumi.Input['GuardrailSensitiveInformationAction'] output_action: Specifies the action to take when harmful content is detected in the output. Supported values include:
               
               - `BLOCK`  Block the content and replace it with blocked messaging.
               - `NONE`  Take no action but return detection information in the trace response.
        :param pulumi.Input[_builtins.bool] output_enabled: Specifies whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pattern", pattern)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if input_action is not None:
            pulumi.set(__self__, "input_action", input_action)
        if input_enabled is not None:
            pulumi.set(__self__, "input_enabled", input_enabled)
        if output_action is not None:
            pulumi.set(__self__, "output_action", output_action)
        if output_enabled is not None:
            pulumi.set(__self__, "output_enabled", output_enabled)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input['GuardrailSensitiveInformationAction']:
        """
        The guardrail action to configure when matching regular expression is detected.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input['GuardrailSensitiveInformationAction']):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The regex name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def pattern(self) -> pulumi.Input[_builtins.str]:
        """
        The regex pattern.
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "pattern", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The regex description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="inputAction")
    def input_action(self) -> Optional[pulumi.Input['GuardrailSensitiveInformationAction']]:
        """
        Specifies the action to take when harmful content is detected in the input. Supported values include:

        - `BLOCK`  Block the content and replace it with blocked messaging.
        - `NONE`  Take no action but return detection information in the trace response.
        """
        return pulumi.get(self, "input_action")

    @input_action.setter
    def input_action(self, value: Optional[pulumi.Input['GuardrailSensitiveInformationAction']]):
        pulumi.set(self, "input_action", value)

    @_builtins.property
    @pulumi.getter(name="inputEnabled")
    def input_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        return pulumi.get(self, "input_enabled")

    @input_enabled.setter
    def input_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "input_enabled", value)

    @_builtins.property
    @pulumi.getter(name="outputAction")
    def output_action(self) -> Optional[pulumi.Input['GuardrailSensitiveInformationAction']]:
        """
        Specifies the action to take when harmful content is detected in the output. Supported values include:

        - `BLOCK`  Block the content and replace it with blocked messaging.
        - `NONE`  Take no action but return detection information in the trace response.
        """
        return pulumi.get(self, "output_action")

    @output_action.setter
    def output_action(self, value: Optional[pulumi.Input['GuardrailSensitiveInformationAction']]):
        pulumi.set(self, "output_action", value)

    @_builtins.property
    @pulumi.getter(name="outputEnabled")
    def output_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        return pulumi.get(self, "output_enabled")

    @output_enabled.setter
    def output_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "output_enabled", value)


if not MYPY:
    class GuardrailSensitiveInformationPolicyConfigArgsDict(TypedDict):
        """
        Sensitive information policy config for a guardrail.
        """
        pii_entities_config: NotRequired[pulumi.Input[Sequence[pulumi.Input['GuardrailPiiEntityConfigArgsDict']]]]
        """
        List of entities.
        """
        regexes_config: NotRequired[pulumi.Input[Sequence[pulumi.Input['GuardrailRegexConfigArgsDict']]]]
        """
        List of regex.
        """
elif False:
    GuardrailSensitiveInformationPolicyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailSensitiveInformationPolicyConfigArgs:
    def __init__(__self__, *,
                 pii_entities_config: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailPiiEntityConfigArgs']]]] = None,
                 regexes_config: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailRegexConfigArgs']]]] = None):
        """
        Sensitive information policy config for a guardrail.
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailPiiEntityConfigArgs']]] pii_entities_config: List of entities.
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailRegexConfigArgs']]] regexes_config: List of regex.
        """
        if pii_entities_config is not None:
            pulumi.set(__self__, "pii_entities_config", pii_entities_config)
        if regexes_config is not None:
            pulumi.set(__self__, "regexes_config", regexes_config)

    @_builtins.property
    @pulumi.getter(name="piiEntitiesConfig")
    def pii_entities_config(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailPiiEntityConfigArgs']]]]:
        """
        List of entities.
        """
        return pulumi.get(self, "pii_entities_config")

    @pii_entities_config.setter
    def pii_entities_config(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailPiiEntityConfigArgs']]]]):
        pulumi.set(self, "pii_entities_config", value)

    @_builtins.property
    @pulumi.getter(name="regexesConfig")
    def regexes_config(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailRegexConfigArgs']]]]:
        """
        List of regex.
        """
        return pulumi.get(self, "regexes_config")

    @regexes_config.setter
    def regexes_config(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailRegexConfigArgs']]]]):
        pulumi.set(self, "regexes_config", value)


if not MYPY:
    class GuardrailTopicConfigArgsDict(TypedDict):
        """
        Topic config in topic policy.
        """
        definition: pulumi.Input[_builtins.str]
        """
        Definition of topic in topic policy
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of topic in topic policy
        """
        type: pulumi.Input['GuardrailTopicType']
        """
        Specifies to deny the topic.
        """
        examples: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of text examples
        """
        input_action: NotRequired[pulumi.Input['GuardrailTopicAction']]
        """
        Specifies the action to take when harmful content is detected in the input. Supported values include:

        - `BLOCK`  Block the content and replace it with blocked messaging.
        - `NONE`  Take no action but return detection information in the trace response.
        """
        input_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        output_action: NotRequired[pulumi.Input['GuardrailTopicAction']]
        """
        Specifies the action to take when harmful content is detected in the output. Supported values include:

        - `BLOCK`  Block the content and replace it with blocked messaging.
        - `NONE`  Take no action but return detection information in the trace response.
        """
        output_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
elif False:
    GuardrailTopicConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailTopicConfigArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input['GuardrailTopicType'],
                 examples: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 input_action: Optional[pulumi.Input['GuardrailTopicAction']] = None,
                 input_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 output_action: Optional[pulumi.Input['GuardrailTopicAction']] = None,
                 output_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        Topic config in topic policy.
        :param pulumi.Input[_builtins.str] definition: Definition of topic in topic policy
        :param pulumi.Input[_builtins.str] name: Name of topic in topic policy
        :param pulumi.Input['GuardrailTopicType'] type: Specifies to deny the topic.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] examples: List of text examples
        :param pulumi.Input['GuardrailTopicAction'] input_action: Specifies the action to take when harmful content is detected in the input. Supported values include:
               
               - `BLOCK`  Block the content and replace it with blocked messaging.
               - `NONE`  Take no action but return detection information in the trace response.
        :param pulumi.Input[_builtins.bool] input_enabled: Specifies whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        :param pulumi.Input['GuardrailTopicAction'] output_action: Specifies the action to take when harmful content is detected in the output. Supported values include:
               
               - `BLOCK`  Block the content and replace it with blocked messaging.
               - `NONE`  Take no action but return detection information in the trace response.
        :param pulumi.Input[_builtins.bool] output_enabled: Specifies whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if examples is not None:
            pulumi.set(__self__, "examples", examples)
        if input_action is not None:
            pulumi.set(__self__, "input_action", input_action)
        if input_enabled is not None:
            pulumi.set(__self__, "input_enabled", input_enabled)
        if output_action is not None:
            pulumi.set(__self__, "output_action", output_action)
        if output_enabled is not None:
            pulumi.set(__self__, "output_enabled", output_enabled)

    @_builtins.property
    @pulumi.getter
    def definition(self) -> pulumi.Input[_builtins.str]:
        """
        Definition of topic in topic policy
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "definition", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of topic in topic policy
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['GuardrailTopicType']:
        """
        Specifies to deny the topic.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['GuardrailTopicType']):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def examples(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of text examples
        """
        return pulumi.get(self, "examples")

    @examples.setter
    def examples(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "examples", value)

    @_builtins.property
    @pulumi.getter(name="inputAction")
    def input_action(self) -> Optional[pulumi.Input['GuardrailTopicAction']]:
        """
        Specifies the action to take when harmful content is detected in the input. Supported values include:

        - `BLOCK`  Block the content and replace it with blocked messaging.
        - `NONE`  Take no action but return detection information in the trace response.
        """
        return pulumi.get(self, "input_action")

    @input_action.setter
    def input_action(self, value: Optional[pulumi.Input['GuardrailTopicAction']]):
        pulumi.set(self, "input_action", value)

    @_builtins.property
    @pulumi.getter(name="inputEnabled")
    def input_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        return pulumi.get(self, "input_enabled")

    @input_enabled.setter
    def input_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "input_enabled", value)

    @_builtins.property
    @pulumi.getter(name="outputAction")
    def output_action(self) -> Optional[pulumi.Input['GuardrailTopicAction']]:
        """
        Specifies the action to take when harmful content is detected in the output. Supported values include:

        - `BLOCK`  Block the content and replace it with blocked messaging.
        - `NONE`  Take no action but return detection information in the trace response.
        """
        return pulumi.get(self, "output_action")

    @output_action.setter
    def output_action(self, value: Optional[pulumi.Input['GuardrailTopicAction']]):
        pulumi.set(self, "output_action", value)

    @_builtins.property
    @pulumi.getter(name="outputEnabled")
    def output_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        return pulumi.get(self, "output_enabled")

    @output_enabled.setter
    def output_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "output_enabled", value)


if not MYPY:
    class GuardrailTopicPolicyConfigTopicsTierConfigPropertiesArgsDict(TypedDict):
        """
        Guardrail tier config for topic policy
        """
        tier_name: pulumi.Input['GuardrailTopicsTierName']
elif False:
    GuardrailTopicPolicyConfigTopicsTierConfigPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailTopicPolicyConfigTopicsTierConfigPropertiesArgs:
    def __init__(__self__, *,
                 tier_name: pulumi.Input['GuardrailTopicsTierName']):
        """
        Guardrail tier config for topic policy
        """
        pulumi.set(__self__, "tier_name", tier_name)

    @_builtins.property
    @pulumi.getter(name="tierName")
    def tier_name(self) -> pulumi.Input['GuardrailTopicsTierName']:
        return pulumi.get(self, "tier_name")

    @tier_name.setter
    def tier_name(self, value: pulumi.Input['GuardrailTopicsTierName']):
        pulumi.set(self, "tier_name", value)


if not MYPY:
    class GuardrailTopicPolicyConfigArgsDict(TypedDict):
        """
        Topic policy config for a guardrail.
        """
        topics_config: pulumi.Input[Sequence[pulumi.Input['GuardrailTopicConfigArgsDict']]]
        """
        List of topic configs in topic policy.
        """
        topics_tier_config: NotRequired[pulumi.Input['GuardrailTopicPolicyConfigTopicsTierConfigPropertiesArgsDict']]
        """
        Guardrail tier config for topic policy
        """
elif False:
    GuardrailTopicPolicyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailTopicPolicyConfigArgs:
    def __init__(__self__, *,
                 topics_config: pulumi.Input[Sequence[pulumi.Input['GuardrailTopicConfigArgs']]],
                 topics_tier_config: Optional[pulumi.Input['GuardrailTopicPolicyConfigTopicsTierConfigPropertiesArgs']] = None):
        """
        Topic policy config for a guardrail.
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailTopicConfigArgs']]] topics_config: List of topic configs in topic policy.
        :param pulumi.Input['GuardrailTopicPolicyConfigTopicsTierConfigPropertiesArgs'] topics_tier_config: Guardrail tier config for topic policy
        """
        pulumi.set(__self__, "topics_config", topics_config)
        if topics_tier_config is not None:
            pulumi.set(__self__, "topics_tier_config", topics_tier_config)

    @_builtins.property
    @pulumi.getter(name="topicsConfig")
    def topics_config(self) -> pulumi.Input[Sequence[pulumi.Input['GuardrailTopicConfigArgs']]]:
        """
        List of topic configs in topic policy.
        """
        return pulumi.get(self, "topics_config")

    @topics_config.setter
    def topics_config(self, value: pulumi.Input[Sequence[pulumi.Input['GuardrailTopicConfigArgs']]]):
        pulumi.set(self, "topics_config", value)

    @_builtins.property
    @pulumi.getter(name="topicsTierConfig")
    def topics_tier_config(self) -> Optional[pulumi.Input['GuardrailTopicPolicyConfigTopicsTierConfigPropertiesArgs']]:
        """
        Guardrail tier config for topic policy
        """
        return pulumi.get(self, "topics_tier_config")

    @topics_tier_config.setter
    def topics_tier_config(self, value: Optional[pulumi.Input['GuardrailTopicPolicyConfigTopicsTierConfigPropertiesArgs']]):
        pulumi.set(self, "topics_tier_config", value)


if not MYPY:
    class GuardrailWordConfigArgsDict(TypedDict):
        """
        A custom word config.
        """
        text: pulumi.Input[_builtins.str]
        """
        The custom word text.
        """
        input_action: NotRequired[pulumi.Input['GuardrailWordAction']]
        """
        Specifies the action to take when harmful content is detected in the input. Supported values include:

        - `BLOCK`  Block the content and replace it with blocked messaging.
        - `NONE`  Take no action but return detection information in the trace response.
        """
        input_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable guardrail evaluation on the intput. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        output_action: NotRequired[pulumi.Input['GuardrailWordAction']]
        """
        Specifies the action to take when harmful content is detected in the output. Supported values include:

        - `BLOCK`  Block the content and replace it with blocked messaging.
        - `NONE`  Take no action but return detection information in the trace response.
        """
        output_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
elif False:
    GuardrailWordConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailWordConfigArgs:
    def __init__(__self__, *,
                 text: pulumi.Input[_builtins.str],
                 input_action: Optional[pulumi.Input['GuardrailWordAction']] = None,
                 input_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 output_action: Optional[pulumi.Input['GuardrailWordAction']] = None,
                 output_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        A custom word config.
        :param pulumi.Input[_builtins.str] text: The custom word text.
        :param pulumi.Input['GuardrailWordAction'] input_action: Specifies the action to take when harmful content is detected in the input. Supported values include:
               
               - `BLOCK`  Block the content and replace it with blocked messaging.
               - `NONE`  Take no action but return detection information in the trace response.
        :param pulumi.Input[_builtins.bool] input_enabled: Specifies whether to enable guardrail evaluation on the intput. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        :param pulumi.Input['GuardrailWordAction'] output_action: Specifies the action to take when harmful content is detected in the output. Supported values include:
               
               - `BLOCK`  Block the content and replace it with blocked messaging.
               - `NONE`  Take no action but return detection information in the trace response.
        :param pulumi.Input[_builtins.bool] output_enabled: Specifies whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        pulumi.set(__self__, "text", text)
        if input_action is not None:
            pulumi.set(__self__, "input_action", input_action)
        if input_enabled is not None:
            pulumi.set(__self__, "input_enabled", input_enabled)
        if output_action is not None:
            pulumi.set(__self__, "output_action", output_action)
        if output_enabled is not None:
            pulumi.set(__self__, "output_enabled", output_enabled)

    @_builtins.property
    @pulumi.getter
    def text(self) -> pulumi.Input[_builtins.str]:
        """
        The custom word text.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "text", value)

    @_builtins.property
    @pulumi.getter(name="inputAction")
    def input_action(self) -> Optional[pulumi.Input['GuardrailWordAction']]:
        """
        Specifies the action to take when harmful content is detected in the input. Supported values include:

        - `BLOCK`  Block the content and replace it with blocked messaging.
        - `NONE`  Take no action but return detection information in the trace response.
        """
        return pulumi.get(self, "input_action")

    @input_action.setter
    def input_action(self, value: Optional[pulumi.Input['GuardrailWordAction']]):
        pulumi.set(self, "input_action", value)

    @_builtins.property
    @pulumi.getter(name="inputEnabled")
    def input_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable guardrail evaluation on the intput. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        return pulumi.get(self, "input_enabled")

    @input_enabled.setter
    def input_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "input_enabled", value)

    @_builtins.property
    @pulumi.getter(name="outputAction")
    def output_action(self) -> Optional[pulumi.Input['GuardrailWordAction']]:
        """
        Specifies the action to take when harmful content is detected in the output. Supported values include:

        - `BLOCK`  Block the content and replace it with blocked messaging.
        - `NONE`  Take no action but return detection information in the trace response.
        """
        return pulumi.get(self, "output_action")

    @output_action.setter
    def output_action(self, value: Optional[pulumi.Input['GuardrailWordAction']]):
        pulumi.set(self, "output_action", value)

    @_builtins.property
    @pulumi.getter(name="outputEnabled")
    def output_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        return pulumi.get(self, "output_enabled")

    @output_enabled.setter
    def output_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "output_enabled", value)


if not MYPY:
    class GuardrailWordPolicyConfigArgsDict(TypedDict):
        """
        Word policy config for a guardrail.
        """
        managed_word_lists_config: NotRequired[pulumi.Input[Sequence[pulumi.Input['GuardrailManagedWordsConfigArgsDict']]]]
        """
        A config for the list of managed words.
        """
        words_config: NotRequired[pulumi.Input[Sequence[pulumi.Input['GuardrailWordConfigArgsDict']]]]
        """
        List of custom word configs.
        """
elif False:
    GuardrailWordPolicyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailWordPolicyConfigArgs:
    def __init__(__self__, *,
                 managed_word_lists_config: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailManagedWordsConfigArgs']]]] = None,
                 words_config: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailWordConfigArgs']]]] = None):
        """
        Word policy config for a guardrail.
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailManagedWordsConfigArgs']]] managed_word_lists_config: A config for the list of managed words.
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailWordConfigArgs']]] words_config: List of custom word configs.
        """
        if managed_word_lists_config is not None:
            pulumi.set(__self__, "managed_word_lists_config", managed_word_lists_config)
        if words_config is not None:
            pulumi.set(__self__, "words_config", words_config)

    @_builtins.property
    @pulumi.getter(name="managedWordListsConfig")
    def managed_word_lists_config(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailManagedWordsConfigArgs']]]]:
        """
        A config for the list of managed words.
        """
        return pulumi.get(self, "managed_word_lists_config")

    @managed_word_lists_config.setter
    def managed_word_lists_config(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailManagedWordsConfigArgs']]]]):
        pulumi.set(self, "managed_word_lists_config", value)

    @_builtins.property
    @pulumi.getter(name="wordsConfig")
    def words_config(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailWordConfigArgs']]]]:
        """
        List of custom word configs.
        """
        return pulumi.get(self, "words_config")

    @words_config.setter
    def words_config(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailWordConfigArgs']]]]):
        pulumi.set(self, "words_config", value)


if not MYPY:
    class IntelligentPromptRouterPromptRouterTargetModelArgsDict(TypedDict):
        """
        Model configuration
        """
        model_arn: pulumi.Input[_builtins.str]
        """
        Arn of underlying model which are added in the Prompt Router.
        """
elif False:
    IntelligentPromptRouterPromptRouterTargetModelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntelligentPromptRouterPromptRouterTargetModelArgs:
    def __init__(__self__, *,
                 model_arn: pulumi.Input[_builtins.str]):
        """
        Model configuration
        :param pulumi.Input[_builtins.str] model_arn: Arn of underlying model which are added in the Prompt Router.
        """
        pulumi.set(__self__, "model_arn", model_arn)

    @_builtins.property
    @pulumi.getter(name="modelArn")
    def model_arn(self) -> pulumi.Input[_builtins.str]:
        """
        Arn of underlying model which are added in the Prompt Router.
        """
        return pulumi.get(self, "model_arn")

    @model_arn.setter
    def model_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "model_arn", value)


if not MYPY:
    class IntelligentPromptRouterRoutingCriteriaArgsDict(TypedDict):
        """
        Represents the criteria used for routing requests.
        """
        response_quality_difference: pulumi.Input[_builtins.float]
        """
        The criteria's response quality difference.
        """
elif False:
    IntelligentPromptRouterRoutingCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntelligentPromptRouterRoutingCriteriaArgs:
    def __init__(__self__, *,
                 response_quality_difference: pulumi.Input[_builtins.float]):
        """
        Represents the criteria used for routing requests.
        :param pulumi.Input[_builtins.float] response_quality_difference: The criteria's response quality difference.
        """
        pulumi.set(__self__, "response_quality_difference", response_quality_difference)

    @_builtins.property
    @pulumi.getter(name="responseQualityDifference")
    def response_quality_difference(self) -> pulumi.Input[_builtins.float]:
        """
        The criteria's response quality difference.
        """
        return pulumi.get(self, "response_quality_difference")

    @response_quality_difference.setter
    def response_quality_difference(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "response_quality_difference", value)


if not MYPY:
    class KnowledgeBaseBedrockEmbeddingModelConfigurationArgsDict(TypedDict):
        """
        The vector configuration details for the Bedrock embeddings model.
        """
        dimensions: NotRequired[pulumi.Input[_builtins.int]]
        """
        The dimensions details for the vector configuration used on the Bedrock embeddings model.
        """
        embedding_data_type: NotRequired[pulumi.Input['KnowledgeBaseBedrockEmbeddingModelConfigurationEmbeddingDataType']]
        """
        The data type for the vectors when using a model to convert text into vector embeddings.
        """
elif False:
    KnowledgeBaseBedrockEmbeddingModelConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KnowledgeBaseBedrockEmbeddingModelConfigurationArgs:
    def __init__(__self__, *,
                 dimensions: Optional[pulumi.Input[_builtins.int]] = None,
                 embedding_data_type: Optional[pulumi.Input['KnowledgeBaseBedrockEmbeddingModelConfigurationEmbeddingDataType']] = None):
        """
        The vector configuration details for the Bedrock embeddings model.
        :param pulumi.Input[_builtins.int] dimensions: The dimensions details for the vector configuration used on the Bedrock embeddings model.
        :param pulumi.Input['KnowledgeBaseBedrockEmbeddingModelConfigurationEmbeddingDataType'] embedding_data_type: The data type for the vectors when using a model to convert text into vector embeddings.
        """
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if embedding_data_type is not None:
            pulumi.set(__self__, "embedding_data_type", embedding_data_type)

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The dimensions details for the vector configuration used on the Bedrock embeddings model.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "dimensions", value)

    @_builtins.property
    @pulumi.getter(name="embeddingDataType")
    def embedding_data_type(self) -> Optional[pulumi.Input['KnowledgeBaseBedrockEmbeddingModelConfigurationEmbeddingDataType']]:
        """
        The data type for the vectors when using a model to convert text into vector embeddings.
        """
        return pulumi.get(self, "embedding_data_type")

    @embedding_data_type.setter
    def embedding_data_type(self, value: Optional[pulumi.Input['KnowledgeBaseBedrockEmbeddingModelConfigurationEmbeddingDataType']]):
        pulumi.set(self, "embedding_data_type", value)


if not MYPY:
    class KnowledgeBaseConfigurationArgsDict(TypedDict):
        """
        Contains details about the embeddings model used for the knowledge base.
        """
        type: pulumi.Input['KnowledgeBaseType']
        """
        The type of data that the data source is converted into for the knowledge base.
        """
        kendra_knowledge_base_configuration: NotRequired[pulumi.Input['KnowledgeBaseKendraKnowledgeBaseConfigurationArgsDict']]
        """
        Settings for an Amazon Kendra knowledge base.
        """
        sql_knowledge_base_configuration: NotRequired[pulumi.Input['KnowledgeBaseSqlKnowledgeBaseConfigurationArgsDict']]
        """
        Specifies configurations for a knowledge base connected to an SQL database.
        """
        vector_knowledge_base_configuration: NotRequired[pulumi.Input['KnowledgeBaseVectorKnowledgeBaseConfigurationArgsDict']]
        """
        Contains details about the model that's used to convert the data source into vector embeddings.
        """
elif False:
    KnowledgeBaseConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KnowledgeBaseConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['KnowledgeBaseType'],
                 kendra_knowledge_base_configuration: Optional[pulumi.Input['KnowledgeBaseKendraKnowledgeBaseConfigurationArgs']] = None,
                 sql_knowledge_base_configuration: Optional[pulumi.Input['KnowledgeBaseSqlKnowledgeBaseConfigurationArgs']] = None,
                 vector_knowledge_base_configuration: Optional[pulumi.Input['KnowledgeBaseVectorKnowledgeBaseConfigurationArgs']] = None):
        """
        Contains details about the embeddings model used for the knowledge base.
        :param pulumi.Input['KnowledgeBaseType'] type: The type of data that the data source is converted into for the knowledge base.
        :param pulumi.Input['KnowledgeBaseKendraKnowledgeBaseConfigurationArgs'] kendra_knowledge_base_configuration: Settings for an Amazon Kendra knowledge base.
        :param pulumi.Input['KnowledgeBaseSqlKnowledgeBaseConfigurationArgs'] sql_knowledge_base_configuration: Specifies configurations for a knowledge base connected to an SQL database.
        :param pulumi.Input['KnowledgeBaseVectorKnowledgeBaseConfigurationArgs'] vector_knowledge_base_configuration: Contains details about the model that's used to convert the data source into vector embeddings.
        """
        pulumi.set(__self__, "type", type)
        if kendra_knowledge_base_configuration is not None:
            pulumi.set(__self__, "kendra_knowledge_base_configuration", kendra_knowledge_base_configuration)
        if sql_knowledge_base_configuration is not None:
            pulumi.set(__self__, "sql_knowledge_base_configuration", sql_knowledge_base_configuration)
        if vector_knowledge_base_configuration is not None:
            pulumi.set(__self__, "vector_knowledge_base_configuration", vector_knowledge_base_configuration)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['KnowledgeBaseType']:
        """
        The type of data that the data source is converted into for the knowledge base.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['KnowledgeBaseType']):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="kendraKnowledgeBaseConfiguration")
    def kendra_knowledge_base_configuration(self) -> Optional[pulumi.Input['KnowledgeBaseKendraKnowledgeBaseConfigurationArgs']]:
        """
        Settings for an Amazon Kendra knowledge base.
        """
        return pulumi.get(self, "kendra_knowledge_base_configuration")

    @kendra_knowledge_base_configuration.setter
    def kendra_knowledge_base_configuration(self, value: Optional[pulumi.Input['KnowledgeBaseKendraKnowledgeBaseConfigurationArgs']]):
        pulumi.set(self, "kendra_knowledge_base_configuration", value)

    @_builtins.property
    @pulumi.getter(name="sqlKnowledgeBaseConfiguration")
    def sql_knowledge_base_configuration(self) -> Optional[pulumi.Input['KnowledgeBaseSqlKnowledgeBaseConfigurationArgs']]:
        """
        Specifies configurations for a knowledge base connected to an SQL database.
        """
        return pulumi.get(self, "sql_knowledge_base_configuration")

    @sql_knowledge_base_configuration.setter
    def sql_knowledge_base_configuration(self, value: Optional[pulumi.Input['KnowledgeBaseSqlKnowledgeBaseConfigurationArgs']]):
        pulumi.set(self, "sql_knowledge_base_configuration", value)

    @_builtins.property
    @pulumi.getter(name="vectorKnowledgeBaseConfiguration")
    def vector_knowledge_base_configuration(self) -> Optional[pulumi.Input['KnowledgeBaseVectorKnowledgeBaseConfigurationArgs']]:
        """
        Contains details about the model that's used to convert the data source into vector embeddings.
        """
        return pulumi.get(self, "vector_knowledge_base_configuration")

    @vector_knowledge_base_configuration.setter
    def vector_knowledge_base_configuration(self, value: Optional[pulumi.Input['KnowledgeBaseVectorKnowledgeBaseConfigurationArgs']]):
        pulumi.set(self, "vector_knowledge_base_configuration", value)


if not MYPY:
    class KnowledgeBaseCuratedQueryArgsDict(TypedDict):
        """
        Curated query or question and answer pair
        """
        natural_language: pulumi.Input[_builtins.str]
        sql: pulumi.Input[_builtins.str]
elif False:
    KnowledgeBaseCuratedQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KnowledgeBaseCuratedQueryArgs:
    def __init__(__self__, *,
                 natural_language: pulumi.Input[_builtins.str],
                 sql: pulumi.Input[_builtins.str]):
        """
        Curated query or question and answer pair
        """
        pulumi.set(__self__, "natural_language", natural_language)
        pulumi.set(__self__, "sql", sql)

    @_builtins.property
    @pulumi.getter(name="naturalLanguage")
    def natural_language(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "natural_language")

    @natural_language.setter
    def natural_language(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "natural_language", value)

    @_builtins.property
    @pulumi.getter
    def sql(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "sql")

    @sql.setter
    def sql(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "sql", value)


if not MYPY:
    class KnowledgeBaseEmbeddingModelConfigurationArgsDict(TypedDict):
        """
        The embeddings model configuration details for the vector model used in Knowledge Base.
        """
        bedrock_embedding_model_configuration: NotRequired[pulumi.Input['KnowledgeBaseBedrockEmbeddingModelConfigurationArgsDict']]
        """
        The vector configuration details on the Bedrock embeddings model.
        """
elif False:
    KnowledgeBaseEmbeddingModelConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KnowledgeBaseEmbeddingModelConfigurationArgs:
    def __init__(__self__, *,
                 bedrock_embedding_model_configuration: Optional[pulumi.Input['KnowledgeBaseBedrockEmbeddingModelConfigurationArgs']] = None):
        """
        The embeddings model configuration details for the vector model used in Knowledge Base.
        :param pulumi.Input['KnowledgeBaseBedrockEmbeddingModelConfigurationArgs'] bedrock_embedding_model_configuration: The vector configuration details on the Bedrock embeddings model.
        """
        if bedrock_embedding_model_configuration is not None:
            pulumi.set(__self__, "bedrock_embedding_model_configuration", bedrock_embedding_model_configuration)

    @_builtins.property
    @pulumi.getter(name="bedrockEmbeddingModelConfiguration")
    def bedrock_embedding_model_configuration(self) -> Optional[pulumi.Input['KnowledgeBaseBedrockEmbeddingModelConfigurationArgs']]:
        """
        The vector configuration details on the Bedrock embeddings model.
        """
        return pulumi.get(self, "bedrock_embedding_model_configuration")

    @bedrock_embedding_model_configuration.setter
    def bedrock_embedding_model_configuration(self, value: Optional[pulumi.Input['KnowledgeBaseBedrockEmbeddingModelConfigurationArgs']]):
        pulumi.set(self, "bedrock_embedding_model_configuration", value)


if not MYPY:
    class KnowledgeBaseKendraKnowledgeBaseConfigurationArgsDict(TypedDict):
        """
        Configurations for a Kendra knowledge base
        """
        kendra_index_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the Amazon Kendra index.
        """
elif False:
    KnowledgeBaseKendraKnowledgeBaseConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KnowledgeBaseKendraKnowledgeBaseConfigurationArgs:
    def __init__(__self__, *,
                 kendra_index_arn: pulumi.Input[_builtins.str]):
        """
        Configurations for a Kendra knowledge base
        :param pulumi.Input[_builtins.str] kendra_index_arn: The ARN of the Amazon Kendra index.
        """
        pulumi.set(__self__, "kendra_index_arn", kendra_index_arn)

    @_builtins.property
    @pulumi.getter(name="kendraIndexArn")
    def kendra_index_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the Amazon Kendra index.
        """
        return pulumi.get(self, "kendra_index_arn")

    @kendra_index_arn.setter
    def kendra_index_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "kendra_index_arn", value)


if not MYPY:
    class KnowledgeBaseMongoDbAtlasConfigurationArgsDict(TypedDict):
        """
        Contains the storage configuration of the knowledge base in MongoDb Atlas Cloud.
        """
        collection_name: pulumi.Input[_builtins.str]
        """
        Name of the collection within MongoDB Atlas.
        """
        credentials_secret_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the secret that you created in AWS Secrets Manager that is linked to your Amazon Mongo database.
        """
        database_name: pulumi.Input[_builtins.str]
        """
        Name of the database within MongoDB Atlas.
        """
        endpoint: pulumi.Input[_builtins.str]
        """
        MongoDB Atlas endpoint.
        """
        field_mapping: pulumi.Input['KnowledgeBaseMongoDbAtlasFieldMappingArgsDict']
        """
        Contains the names of the fields to which to map information about the vector store.
        """
        vector_index_name: pulumi.Input[_builtins.str]
        """
        Name of a MongoDB Atlas index.
        """
        endpoint_service_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        MongoDB Atlas endpoint service name.
        """
        text_index_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of a MongoDB Atlas text index.
        """
elif False:
    KnowledgeBaseMongoDbAtlasConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KnowledgeBaseMongoDbAtlasConfigurationArgs:
    def __init__(__self__, *,
                 collection_name: pulumi.Input[_builtins.str],
                 credentials_secret_arn: pulumi.Input[_builtins.str],
                 database_name: pulumi.Input[_builtins.str],
                 endpoint: pulumi.Input[_builtins.str],
                 field_mapping: pulumi.Input['KnowledgeBaseMongoDbAtlasFieldMappingArgs'],
                 vector_index_name: pulumi.Input[_builtins.str],
                 endpoint_service_name: Optional[pulumi.Input[_builtins.str]] = None,
                 text_index_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Contains the storage configuration of the knowledge base in MongoDb Atlas Cloud.
        :param pulumi.Input[_builtins.str] collection_name: Name of the collection within MongoDB Atlas.
        :param pulumi.Input[_builtins.str] credentials_secret_arn: The ARN of the secret that you created in AWS Secrets Manager that is linked to your Amazon Mongo database.
        :param pulumi.Input[_builtins.str] database_name: Name of the database within MongoDB Atlas.
        :param pulumi.Input[_builtins.str] endpoint: MongoDB Atlas endpoint.
        :param pulumi.Input['KnowledgeBaseMongoDbAtlasFieldMappingArgs'] field_mapping: Contains the names of the fields to which to map information about the vector store.
        :param pulumi.Input[_builtins.str] vector_index_name: Name of a MongoDB Atlas index.
        :param pulumi.Input[_builtins.str] endpoint_service_name: MongoDB Atlas endpoint service name.
        :param pulumi.Input[_builtins.str] text_index_name: Name of a MongoDB Atlas text index.
        """
        pulumi.set(__self__, "collection_name", collection_name)
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "field_mapping", field_mapping)
        pulumi.set(__self__, "vector_index_name", vector_index_name)
        if endpoint_service_name is not None:
            pulumi.set(__self__, "endpoint_service_name", endpoint_service_name)
        if text_index_name is not None:
            pulumi.set(__self__, "text_index_name", text_index_name)

    @_builtins.property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the collection within MongoDB Atlas.
        """
        return pulumi.get(self, "collection_name")

    @collection_name.setter
    def collection_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "collection_name", value)

    @_builtins.property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the secret that you created in AWS Secrets Manager that is linked to your Amazon Mongo database.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @credentials_secret_arn.setter
    def credentials_secret_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "credentials_secret_arn", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the database within MongoDB Atlas.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        MongoDB Atlas endpoint.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> pulumi.Input['KnowledgeBaseMongoDbAtlasFieldMappingArgs']:
        """
        Contains the names of the fields to which to map information about the vector store.
        """
        return pulumi.get(self, "field_mapping")

    @field_mapping.setter
    def field_mapping(self, value: pulumi.Input['KnowledgeBaseMongoDbAtlasFieldMappingArgs']):
        pulumi.set(self, "field_mapping", value)

    @_builtins.property
    @pulumi.getter(name="vectorIndexName")
    def vector_index_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of a MongoDB Atlas index.
        """
        return pulumi.get(self, "vector_index_name")

    @vector_index_name.setter
    def vector_index_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vector_index_name", value)

    @_builtins.property
    @pulumi.getter(name="endpointServiceName")
    def endpoint_service_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        MongoDB Atlas endpoint service name.
        """
        return pulumi.get(self, "endpoint_service_name")

    @endpoint_service_name.setter
    def endpoint_service_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint_service_name", value)

    @_builtins.property
    @pulumi.getter(name="textIndexName")
    def text_index_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of a MongoDB Atlas text index.
        """
        return pulumi.get(self, "text_index_name")

    @text_index_name.setter
    def text_index_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text_index_name", value)


if not MYPY:
    class KnowledgeBaseMongoDbAtlasFieldMappingArgsDict(TypedDict):
        """
        Contains the names of the fields to which to map information about the vector store.
        """
        metadata_field: pulumi.Input[_builtins.str]
        """
        The name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        text_field: pulumi.Input[_builtins.str]
        """
        The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        vector_field: pulumi.Input[_builtins.str]
        """
        The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
elif False:
    KnowledgeBaseMongoDbAtlasFieldMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KnowledgeBaseMongoDbAtlasFieldMappingArgs:
    def __init__(__self__, *,
                 metadata_field: pulumi.Input[_builtins.str],
                 text_field: pulumi.Input[_builtins.str],
                 vector_field: pulumi.Input[_builtins.str]):
        """
        Contains the names of the fields to which to map information about the vector store.
        :param pulumi.Input[_builtins.str] metadata_field: The name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param pulumi.Input[_builtins.str] text_field: The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        :param pulumi.Input[_builtins.str] vector_field: The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        pulumi.set(__self__, "metadata_field", metadata_field)
        pulumi.set(__self__, "text_field", text_field)
        pulumi.set(__self__, "vector_field", vector_field)

    @_builtins.property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @metadata_field.setter
    def metadata_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metadata_field", value)

    @_builtins.property
    @pulumi.getter(name="textField")
    def text_field(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")

    @text_field.setter
    def text_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "text_field", value)

    @_builtins.property
    @pulumi.getter(name="vectorField")
    def vector_field(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        return pulumi.get(self, "vector_field")

    @vector_field.setter
    def vector_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vector_field", value)


if not MYPY:
    class KnowledgeBaseNeptuneAnalyticsConfigurationArgsDict(TypedDict):
        """
        Contains the configurations to use Neptune Analytics as Vector Store.
        """
        field_mapping: pulumi.Input['KnowledgeBaseNeptuneAnalyticsFieldMappingArgsDict']
        """
        Contains the names of the fields to which to map information about the vector store.
        """
        graph_arn: pulumi.Input[_builtins.str]
        """
        ARN for Neptune Analytics graph database.
        """
elif False:
    KnowledgeBaseNeptuneAnalyticsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KnowledgeBaseNeptuneAnalyticsConfigurationArgs:
    def __init__(__self__, *,
                 field_mapping: pulumi.Input['KnowledgeBaseNeptuneAnalyticsFieldMappingArgs'],
                 graph_arn: pulumi.Input[_builtins.str]):
        """
        Contains the configurations to use Neptune Analytics as Vector Store.
        :param pulumi.Input['KnowledgeBaseNeptuneAnalyticsFieldMappingArgs'] field_mapping: Contains the names of the fields to which to map information about the vector store.
        :param pulumi.Input[_builtins.str] graph_arn: ARN for Neptune Analytics graph database.
        """
        pulumi.set(__self__, "field_mapping", field_mapping)
        pulumi.set(__self__, "graph_arn", graph_arn)

    @_builtins.property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> pulumi.Input['KnowledgeBaseNeptuneAnalyticsFieldMappingArgs']:
        """
        Contains the names of the fields to which to map information about the vector store.
        """
        return pulumi.get(self, "field_mapping")

    @field_mapping.setter
    def field_mapping(self, value: pulumi.Input['KnowledgeBaseNeptuneAnalyticsFieldMappingArgs']):
        pulumi.set(self, "field_mapping", value)

    @_builtins.property
    @pulumi.getter(name="graphArn")
    def graph_arn(self) -> pulumi.Input[_builtins.str]:
        """
        ARN for Neptune Analytics graph database.
        """
        return pulumi.get(self, "graph_arn")

    @graph_arn.setter
    def graph_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "graph_arn", value)


if not MYPY:
    class KnowledgeBaseNeptuneAnalyticsFieldMappingArgsDict(TypedDict):
        """
        A mapping of Bedrock Knowledge Base fields to Neptune Analytics fields.
        """
        metadata_field: pulumi.Input[_builtins.str]
        """
        The name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        text_field: pulumi.Input[_builtins.str]
        """
        The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
elif False:
    KnowledgeBaseNeptuneAnalyticsFieldMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KnowledgeBaseNeptuneAnalyticsFieldMappingArgs:
    def __init__(__self__, *,
                 metadata_field: pulumi.Input[_builtins.str],
                 text_field: pulumi.Input[_builtins.str]):
        """
        A mapping of Bedrock Knowledge Base fields to Neptune Analytics fields.
        :param pulumi.Input[_builtins.str] metadata_field: The name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param pulumi.Input[_builtins.str] text_field: The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        pulumi.set(__self__, "metadata_field", metadata_field)
        pulumi.set(__self__, "text_field", text_field)

    @_builtins.property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @metadata_field.setter
    def metadata_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metadata_field", value)

    @_builtins.property
    @pulumi.getter(name="textField")
    def text_field(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")

    @text_field.setter
    def text_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "text_field", value)


if not MYPY:
    class KnowledgeBaseOpenSearchManagedClusterConfigurationArgsDict(TypedDict):
        """
        Contains the storage configuration of the knowledge base in Amazon OpenSearch Service.
        """
        domain_arn: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name (ARN) of the OpenSearch domain.
        """
        domain_endpoint: pulumi.Input[_builtins.str]
        """
        The endpoint URL the OpenSearch domain.
        """
        field_mapping: pulumi.Input['KnowledgeBaseOpenSearchManagedClusterFieldMappingArgsDict']
        """
        Contains the names of the fields to which to map information about the vector store.
        """
        vector_index_name: pulumi.Input[_builtins.str]
        """
        The name of the vector store.
        """
elif False:
    KnowledgeBaseOpenSearchManagedClusterConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KnowledgeBaseOpenSearchManagedClusterConfigurationArgs:
    def __init__(__self__, *,
                 domain_arn: pulumi.Input[_builtins.str],
                 domain_endpoint: pulumi.Input[_builtins.str],
                 field_mapping: pulumi.Input['KnowledgeBaseOpenSearchManagedClusterFieldMappingArgs'],
                 vector_index_name: pulumi.Input[_builtins.str]):
        """
        Contains the storage configuration of the knowledge base in Amazon OpenSearch Service.
        :param pulumi.Input[_builtins.str] domain_arn: The Amazon Resource Name (ARN) of the OpenSearch domain.
        :param pulumi.Input[_builtins.str] domain_endpoint: The endpoint URL the OpenSearch domain.
        :param pulumi.Input['KnowledgeBaseOpenSearchManagedClusterFieldMappingArgs'] field_mapping: Contains the names of the fields to which to map information about the vector store.
        :param pulumi.Input[_builtins.str] vector_index_name: The name of the vector store.
        """
        pulumi.set(__self__, "domain_arn", domain_arn)
        pulumi.set(__self__, "domain_endpoint", domain_endpoint)
        pulumi.set(__self__, "field_mapping", field_mapping)
        pulumi.set(__self__, "vector_index_name", vector_index_name)

    @_builtins.property
    @pulumi.getter(name="domainArn")
    def domain_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the OpenSearch domain.
        """
        return pulumi.get(self, "domain_arn")

    @domain_arn.setter
    def domain_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain_arn", value)

    @_builtins.property
    @pulumi.getter(name="domainEndpoint")
    def domain_endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        The endpoint URL the OpenSearch domain.
        """
        return pulumi.get(self, "domain_endpoint")

    @domain_endpoint.setter
    def domain_endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> pulumi.Input['KnowledgeBaseOpenSearchManagedClusterFieldMappingArgs']:
        """
        Contains the names of the fields to which to map information about the vector store.
        """
        return pulumi.get(self, "field_mapping")

    @field_mapping.setter
    def field_mapping(self, value: pulumi.Input['KnowledgeBaseOpenSearchManagedClusterFieldMappingArgs']):
        pulumi.set(self, "field_mapping", value)

    @_builtins.property
    @pulumi.getter(name="vectorIndexName")
    def vector_index_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the vector store.
        """
        return pulumi.get(self, "vector_index_name")

    @vector_index_name.setter
    def vector_index_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vector_index_name", value)


if not MYPY:
    class KnowledgeBaseOpenSearchManagedClusterFieldMappingArgsDict(TypedDict):
        """
        A mapping of Bedrock Knowledge Base fields to OpenSearch Managed Cluster field names
        """
        metadata_field: pulumi.Input[_builtins.str]
        """
        The name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        text_field: pulumi.Input[_builtins.str]
        """
        The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        vector_field: pulumi.Input[_builtins.str]
        """
        The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
elif False:
    KnowledgeBaseOpenSearchManagedClusterFieldMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KnowledgeBaseOpenSearchManagedClusterFieldMappingArgs:
    def __init__(__self__, *,
                 metadata_field: pulumi.Input[_builtins.str],
                 text_field: pulumi.Input[_builtins.str],
                 vector_field: pulumi.Input[_builtins.str]):
        """
        A mapping of Bedrock Knowledge Base fields to OpenSearch Managed Cluster field names
        :param pulumi.Input[_builtins.str] metadata_field: The name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param pulumi.Input[_builtins.str] text_field: The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        :param pulumi.Input[_builtins.str] vector_field: The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        pulumi.set(__self__, "metadata_field", metadata_field)
        pulumi.set(__self__, "text_field", text_field)
        pulumi.set(__self__, "vector_field", vector_field)

    @_builtins.property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @metadata_field.setter
    def metadata_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metadata_field", value)

    @_builtins.property
    @pulumi.getter(name="textField")
    def text_field(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")

    @text_field.setter
    def text_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "text_field", value)

    @_builtins.property
    @pulumi.getter(name="vectorField")
    def vector_field(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        return pulumi.get(self, "vector_field")

    @vector_field.setter
    def vector_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vector_field", value)


if not MYPY:
    class KnowledgeBaseOpenSearchServerlessConfigurationArgsDict(TypedDict):
        """
        Contains the storage configuration of the knowledge base in Amazon OpenSearch Service.
        """
        collection_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the OpenSearch Service vector store.
        """
        field_mapping: pulumi.Input['KnowledgeBaseOpenSearchServerlessFieldMappingArgsDict']
        """
        Contains the names of the fields to which to map information about the vector store.
        """
        vector_index_name: pulumi.Input[_builtins.str]
        """
        The name of the vector store.
        """
elif False:
    KnowledgeBaseOpenSearchServerlessConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KnowledgeBaseOpenSearchServerlessConfigurationArgs:
    def __init__(__self__, *,
                 collection_arn: pulumi.Input[_builtins.str],
                 field_mapping: pulumi.Input['KnowledgeBaseOpenSearchServerlessFieldMappingArgs'],
                 vector_index_name: pulumi.Input[_builtins.str]):
        """
        Contains the storage configuration of the knowledge base in Amazon OpenSearch Service.
        :param pulumi.Input[_builtins.str] collection_arn: The ARN of the OpenSearch Service vector store.
        :param pulumi.Input['KnowledgeBaseOpenSearchServerlessFieldMappingArgs'] field_mapping: Contains the names of the fields to which to map information about the vector store.
        :param pulumi.Input[_builtins.str] vector_index_name: The name of the vector store.
        """
        pulumi.set(__self__, "collection_arn", collection_arn)
        pulumi.set(__self__, "field_mapping", field_mapping)
        pulumi.set(__self__, "vector_index_name", vector_index_name)

    @_builtins.property
    @pulumi.getter(name="collectionArn")
    def collection_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the OpenSearch Service vector store.
        """
        return pulumi.get(self, "collection_arn")

    @collection_arn.setter
    def collection_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "collection_arn", value)

    @_builtins.property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> pulumi.Input['KnowledgeBaseOpenSearchServerlessFieldMappingArgs']:
        """
        Contains the names of the fields to which to map information about the vector store.
        """
        return pulumi.get(self, "field_mapping")

    @field_mapping.setter
    def field_mapping(self, value: pulumi.Input['KnowledgeBaseOpenSearchServerlessFieldMappingArgs']):
        pulumi.set(self, "field_mapping", value)

    @_builtins.property
    @pulumi.getter(name="vectorIndexName")
    def vector_index_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the vector store.
        """
        return pulumi.get(self, "vector_index_name")

    @vector_index_name.setter
    def vector_index_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vector_index_name", value)


if not MYPY:
    class KnowledgeBaseOpenSearchServerlessFieldMappingArgsDict(TypedDict):
        """
        A mapping of Bedrock Knowledge Base fields to OpenSearch Serverless field names
        """
        metadata_field: pulumi.Input[_builtins.str]
        """
        The name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        text_field: pulumi.Input[_builtins.str]
        """
        The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        vector_field: pulumi.Input[_builtins.str]
        """
        The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
elif False:
    KnowledgeBaseOpenSearchServerlessFieldMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KnowledgeBaseOpenSearchServerlessFieldMappingArgs:
    def __init__(__self__, *,
                 metadata_field: pulumi.Input[_builtins.str],
                 text_field: pulumi.Input[_builtins.str],
                 vector_field: pulumi.Input[_builtins.str]):
        """
        A mapping of Bedrock Knowledge Base fields to OpenSearch Serverless field names
        :param pulumi.Input[_builtins.str] metadata_field: The name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param pulumi.Input[_builtins.str] text_field: The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        :param pulumi.Input[_builtins.str] vector_field: The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        pulumi.set(__self__, "metadata_field", metadata_field)
        pulumi.set(__self__, "text_field", text_field)
        pulumi.set(__self__, "vector_field", vector_field)

    @_builtins.property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @metadata_field.setter
    def metadata_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metadata_field", value)

    @_builtins.property
    @pulumi.getter(name="textField")
    def text_field(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")

    @text_field.setter
    def text_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "text_field", value)

    @_builtins.property
    @pulumi.getter(name="vectorField")
    def vector_field(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        return pulumi.get(self, "vector_field")

    @vector_field.setter
    def vector_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vector_field", value)


if not MYPY:
    class KnowledgeBasePineconeConfigurationArgsDict(TypedDict):
        """
        Contains the storage configuration of the knowledge base in Pinecone.
        """
        connection_string: pulumi.Input[_builtins.str]
        """
        The endpoint URL for your index management page.
        """
        credentials_secret_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the secret that you created in AWS Secrets Manager that is linked to your Pinecone API key.
        """
        field_mapping: pulumi.Input['KnowledgeBasePineconeFieldMappingArgsDict']
        """
        Contains the names of the fields to which to map information about the vector store.
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        The namespace to be used to write new data to your database.
        """
elif False:
    KnowledgeBasePineconeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KnowledgeBasePineconeConfigurationArgs:
    def __init__(__self__, *,
                 connection_string: pulumi.Input[_builtins.str],
                 credentials_secret_arn: pulumi.Input[_builtins.str],
                 field_mapping: pulumi.Input['KnowledgeBasePineconeFieldMappingArgs'],
                 namespace: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Contains the storage configuration of the knowledge base in Pinecone.
        :param pulumi.Input[_builtins.str] connection_string: The endpoint URL for your index management page.
        :param pulumi.Input[_builtins.str] credentials_secret_arn: The ARN of the secret that you created in AWS Secrets Manager that is linked to your Pinecone API key.
        :param pulumi.Input['KnowledgeBasePineconeFieldMappingArgs'] field_mapping: Contains the names of the fields to which to map information about the vector store.
        :param pulumi.Input[_builtins.str] namespace: The namespace to be used to write new data to your database.
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "field_mapping", field_mapping)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @_builtins.property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> pulumi.Input[_builtins.str]:
        """
        The endpoint URL for your index management page.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "connection_string", value)

    @_builtins.property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the secret that you created in AWS Secrets Manager that is linked to your Pinecone API key.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @credentials_secret_arn.setter
    def credentials_secret_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "credentials_secret_arn", value)

    @_builtins.property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> pulumi.Input['KnowledgeBasePineconeFieldMappingArgs']:
        """
        Contains the names of the fields to which to map information about the vector store.
        """
        return pulumi.get(self, "field_mapping")

    @field_mapping.setter
    def field_mapping(self, value: pulumi.Input['KnowledgeBasePineconeFieldMappingArgs']):
        pulumi.set(self, "field_mapping", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The namespace to be used to write new data to your database.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class KnowledgeBasePineconeFieldMappingArgsDict(TypedDict):
        """
        Contains the names of the fields to which to map information about the vector store.
        """
        metadata_field: pulumi.Input[_builtins.str]
        """
        The name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        text_field: pulumi.Input[_builtins.str]
        """
        The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
elif False:
    KnowledgeBasePineconeFieldMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KnowledgeBasePineconeFieldMappingArgs:
    def __init__(__self__, *,
                 metadata_field: pulumi.Input[_builtins.str],
                 text_field: pulumi.Input[_builtins.str]):
        """
        Contains the names of the fields to which to map information about the vector store.
        :param pulumi.Input[_builtins.str] metadata_field: The name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param pulumi.Input[_builtins.str] text_field: The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        pulumi.set(__self__, "metadata_field", metadata_field)
        pulumi.set(__self__, "text_field", text_field)

    @_builtins.property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @metadata_field.setter
    def metadata_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metadata_field", value)

    @_builtins.property
    @pulumi.getter(name="textField")
    def text_field(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")

    @text_field.setter
    def text_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "text_field", value)


if not MYPY:
    class KnowledgeBaseQueryGenerationColumnArgsDict(TypedDict):
        """
        Redshift query generation column
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        inclusion: NotRequired[pulumi.Input['KnowledgeBaseInclusionType']]
        name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    KnowledgeBaseQueryGenerationColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KnowledgeBaseQueryGenerationColumnArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 inclusion: Optional[pulumi.Input['KnowledgeBaseInclusionType']] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Redshift query generation column
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if inclusion is not None:
            pulumi.set(__self__, "inclusion", inclusion)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def inclusion(self) -> Optional[pulumi.Input['KnowledgeBaseInclusionType']]:
        return pulumi.get(self, "inclusion")

    @inclusion.setter
    def inclusion(self, value: Optional[pulumi.Input['KnowledgeBaseInclusionType']]):
        pulumi.set(self, "inclusion", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class KnowledgeBaseQueryGenerationConfigurationArgsDict(TypedDict):
        """
        Configurations for generating Redshift engine queries
        """
        execution_timeout_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The time after which query generation will time out.
        """
        generation_context: NotRequired[pulumi.Input['KnowledgeBaseQueryGenerationContextArgsDict']]
        """
        Specifies configurations for context to use during query generation.
        """
elif False:
    KnowledgeBaseQueryGenerationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KnowledgeBaseQueryGenerationConfigurationArgs:
    def __init__(__self__, *,
                 execution_timeout_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 generation_context: Optional[pulumi.Input['KnowledgeBaseQueryGenerationContextArgs']] = None):
        """
        Configurations for generating Redshift engine queries
        :param pulumi.Input[_builtins.int] execution_timeout_seconds: The time after which query generation will time out.
        :param pulumi.Input['KnowledgeBaseQueryGenerationContextArgs'] generation_context: Specifies configurations for context to use during query generation.
        """
        if execution_timeout_seconds is not None:
            pulumi.set(__self__, "execution_timeout_seconds", execution_timeout_seconds)
        if generation_context is not None:
            pulumi.set(__self__, "generation_context", generation_context)

    @_builtins.property
    @pulumi.getter(name="executionTimeoutSeconds")
    def execution_timeout_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The time after which query generation will time out.
        """
        return pulumi.get(self, "execution_timeout_seconds")

    @execution_timeout_seconds.setter
    def execution_timeout_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "execution_timeout_seconds", value)

    @_builtins.property
    @pulumi.getter(name="generationContext")
    def generation_context(self) -> Optional[pulumi.Input['KnowledgeBaseQueryGenerationContextArgs']]:
        """
        Specifies configurations for context to use during query generation.
        """
        return pulumi.get(self, "generation_context")

    @generation_context.setter
    def generation_context(self, value: Optional[pulumi.Input['KnowledgeBaseQueryGenerationContextArgs']]):
        pulumi.set(self, "generation_context", value)


if not MYPY:
    class KnowledgeBaseQueryGenerationContextArgsDict(TypedDict):
        """
        Context used to improve query generation
        """
        curated_queries: NotRequired[pulumi.Input[Sequence[pulumi.Input['KnowledgeBaseCuratedQueryArgsDict']]]]
        """
        An array of objects, each of which defines information about example queries to help the query engine generate appropriate SQL queries.
        """
        tables: NotRequired[pulumi.Input[Sequence[pulumi.Input['KnowledgeBaseQueryGenerationTableArgsDict']]]]
        """
        An array of objects, each of which defines information about a table in the database.
        """
elif False:
    KnowledgeBaseQueryGenerationContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KnowledgeBaseQueryGenerationContextArgs:
    def __init__(__self__, *,
                 curated_queries: Optional[pulumi.Input[Sequence[pulumi.Input['KnowledgeBaseCuratedQueryArgs']]]] = None,
                 tables: Optional[pulumi.Input[Sequence[pulumi.Input['KnowledgeBaseQueryGenerationTableArgs']]]] = None):
        """
        Context used to improve query generation
        :param pulumi.Input[Sequence[pulumi.Input['KnowledgeBaseCuratedQueryArgs']]] curated_queries: An array of objects, each of which defines information about example queries to help the query engine generate appropriate SQL queries.
        :param pulumi.Input[Sequence[pulumi.Input['KnowledgeBaseQueryGenerationTableArgs']]] tables: An array of objects, each of which defines information about a table in the database.
        """
        if curated_queries is not None:
            pulumi.set(__self__, "curated_queries", curated_queries)
        if tables is not None:
            pulumi.set(__self__, "tables", tables)

    @_builtins.property
    @pulumi.getter(name="curatedQueries")
    def curated_queries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KnowledgeBaseCuratedQueryArgs']]]]:
        """
        An array of objects, each of which defines information about example queries to help the query engine generate appropriate SQL queries.
        """
        return pulumi.get(self, "curated_queries")

    @curated_queries.setter
    def curated_queries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KnowledgeBaseCuratedQueryArgs']]]]):
        pulumi.set(self, "curated_queries", value)

    @_builtins.property
    @pulumi.getter
    def tables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KnowledgeBaseQueryGenerationTableArgs']]]]:
        """
        An array of objects, each of which defines information about a table in the database.
        """
        return pulumi.get(self, "tables")

    @tables.setter
    def tables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KnowledgeBaseQueryGenerationTableArgs']]]]):
        pulumi.set(self, "tables", value)


if not MYPY:
    class KnowledgeBaseQueryGenerationTableArgsDict(TypedDict):
        """
        Tables used for Redshift query generation context
        """
        name: pulumi.Input[_builtins.str]
        columns: NotRequired[pulumi.Input[Sequence[pulumi.Input['KnowledgeBaseQueryGenerationColumnArgsDict']]]]
        description: NotRequired[pulumi.Input[_builtins.str]]
        inclusion: NotRequired[pulumi.Input['KnowledgeBaseInclusionType']]
elif False:
    KnowledgeBaseQueryGenerationTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KnowledgeBaseQueryGenerationTableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 columns: Optional[pulumi.Input[Sequence[pulumi.Input['KnowledgeBaseQueryGenerationColumnArgs']]]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 inclusion: Optional[pulumi.Input['KnowledgeBaseInclusionType']] = None):
        """
        Tables used for Redshift query generation context
        """
        pulumi.set(__self__, "name", name)
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if inclusion is not None:
            pulumi.set(__self__, "inclusion", inclusion)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KnowledgeBaseQueryGenerationColumnArgs']]]]:
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KnowledgeBaseQueryGenerationColumnArgs']]]]):
        pulumi.set(self, "columns", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def inclusion(self) -> Optional[pulumi.Input['KnowledgeBaseInclusionType']]:
        return pulumi.get(self, "inclusion")

    @inclusion.setter
    def inclusion(self, value: Optional[pulumi.Input['KnowledgeBaseInclusionType']]):
        pulumi.set(self, "inclusion", value)


if not MYPY:
    class KnowledgeBaseRdsConfigurationArgsDict(TypedDict):
        """
        Contains details about the storage configuration of the knowledge base in Amazon RDS. For more information, see Create a vector index in Amazon RDS.
        """
        credentials_secret_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the secret that you created in AWS Secrets Manager that is linked to your Amazon RDS database.
        """
        database_name: pulumi.Input[_builtins.str]
        """
        The name of your Amazon RDS database.
        """
        field_mapping: pulumi.Input['KnowledgeBaseRdsFieldMappingArgsDict']
        """
        Contains the names of the fields to which to map information about the vector store.
        """
        resource_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the vector store.
        """
        table_name: pulumi.Input[_builtins.str]
        """
        The name of the table in the database.
        """
elif False:
    KnowledgeBaseRdsConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KnowledgeBaseRdsConfigurationArgs:
    def __init__(__self__, *,
                 credentials_secret_arn: pulumi.Input[_builtins.str],
                 database_name: pulumi.Input[_builtins.str],
                 field_mapping: pulumi.Input['KnowledgeBaseRdsFieldMappingArgs'],
                 resource_arn: pulumi.Input[_builtins.str],
                 table_name: pulumi.Input[_builtins.str]):
        """
        Contains details about the storage configuration of the knowledge base in Amazon RDS. For more information, see Create a vector index in Amazon RDS.
        :param pulumi.Input[_builtins.str] credentials_secret_arn: The ARN of the secret that you created in AWS Secrets Manager that is linked to your Amazon RDS database.
        :param pulumi.Input[_builtins.str] database_name: The name of your Amazon RDS database.
        :param pulumi.Input['KnowledgeBaseRdsFieldMappingArgs'] field_mapping: Contains the names of the fields to which to map information about the vector store.
        :param pulumi.Input[_builtins.str] resource_arn: The ARN of the vector store.
        :param pulumi.Input[_builtins.str] table_name: The name of the table in the database.
        """
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "field_mapping", field_mapping)
        pulumi.set(__self__, "resource_arn", resource_arn)
        pulumi.set(__self__, "table_name", table_name)

    @_builtins.property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the secret that you created in AWS Secrets Manager that is linked to your Amazon RDS database.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @credentials_secret_arn.setter
    def credentials_secret_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "credentials_secret_arn", value)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of your Amazon RDS database.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> pulumi.Input['KnowledgeBaseRdsFieldMappingArgs']:
        """
        Contains the names of the fields to which to map information about the vector store.
        """
        return pulumi.get(self, "field_mapping")

    @field_mapping.setter
    def field_mapping(self, value: pulumi.Input['KnowledgeBaseRdsFieldMappingArgs']):
        pulumi.set(self, "field_mapping", value)

    @_builtins.property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the vector store.
        """
        return pulumi.get(self, "resource_arn")

    @resource_arn.setter
    def resource_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_arn", value)

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the table in the database.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "table_name", value)


if not MYPY:
    class KnowledgeBaseRdsFieldMappingArgsDict(TypedDict):
        """
        Contains the names of the fields to which to map information about the vector store.
        """
        metadata_field: pulumi.Input[_builtins.str]
        """
        The name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        primary_key_field: pulumi.Input[_builtins.str]
        """
        The name of the field in which Amazon Bedrock stores the ID for each entry.
        """
        text_field: pulumi.Input[_builtins.str]
        """
        The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        vector_field: pulumi.Input[_builtins.str]
        """
        The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        custom_metadata_field: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the field in which Amazon Bedrock stores custom metadata about the vector store.
        """
elif False:
    KnowledgeBaseRdsFieldMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KnowledgeBaseRdsFieldMappingArgs:
    def __init__(__self__, *,
                 metadata_field: pulumi.Input[_builtins.str],
                 primary_key_field: pulumi.Input[_builtins.str],
                 text_field: pulumi.Input[_builtins.str],
                 vector_field: pulumi.Input[_builtins.str],
                 custom_metadata_field: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Contains the names of the fields to which to map information about the vector store.
        :param pulumi.Input[_builtins.str] metadata_field: The name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param pulumi.Input[_builtins.str] primary_key_field: The name of the field in which Amazon Bedrock stores the ID for each entry.
        :param pulumi.Input[_builtins.str] text_field: The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        :param pulumi.Input[_builtins.str] vector_field: The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        :param pulumi.Input[_builtins.str] custom_metadata_field: The name of the field in which Amazon Bedrock stores custom metadata about the vector store.
        """
        pulumi.set(__self__, "metadata_field", metadata_field)
        pulumi.set(__self__, "primary_key_field", primary_key_field)
        pulumi.set(__self__, "text_field", text_field)
        pulumi.set(__self__, "vector_field", vector_field)
        if custom_metadata_field is not None:
            pulumi.set(__self__, "custom_metadata_field", custom_metadata_field)

    @_builtins.property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @metadata_field.setter
    def metadata_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metadata_field", value)

    @_builtins.property
    @pulumi.getter(name="primaryKeyField")
    def primary_key_field(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the field in which Amazon Bedrock stores the ID for each entry.
        """
        return pulumi.get(self, "primary_key_field")

    @primary_key_field.setter
    def primary_key_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "primary_key_field", value)

    @_builtins.property
    @pulumi.getter(name="textField")
    def text_field(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")

    @text_field.setter
    def text_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "text_field", value)

    @_builtins.property
    @pulumi.getter(name="vectorField")
    def vector_field(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        return pulumi.get(self, "vector_field")

    @vector_field.setter
    def vector_field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vector_field", value)

    @_builtins.property
    @pulumi.getter(name="customMetadataField")
    def custom_metadata_field(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the field in which Amazon Bedrock stores custom metadata about the vector store.
        """
        return pulumi.get(self, "custom_metadata_field")

    @custom_metadata_field.setter
    def custom_metadata_field(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_metadata_field", value)


if not MYPY:
    class KnowledgeBaseRedshiftConfigurationArgsDict(TypedDict):
        """
        Configurations for a Redshift knowledge base
        """
        query_engine_configuration: pulumi.Input['KnowledgeBaseRedshiftQueryEngineConfigurationArgsDict']
        """
        Specifies configurations for an Amazon Redshift query engine.
        """
        storage_configurations: pulumi.Input[Sequence[pulumi.Input['KnowledgeBaseRedshiftQueryEngineStorageConfigurationArgsDict']]]
        """
        Specifies configurations for Amazon Redshift database storage.
        """
        query_generation_configuration: NotRequired[pulumi.Input['KnowledgeBaseQueryGenerationConfigurationArgsDict']]
        """
        Specifies configurations for generating queries.
        """
elif False:
    KnowledgeBaseRedshiftConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KnowledgeBaseRedshiftConfigurationArgs:
    def __init__(__self__, *,
                 query_engine_configuration: pulumi.Input['KnowledgeBaseRedshiftQueryEngineConfigurationArgs'],
                 storage_configurations: pulumi.Input[Sequence[pulumi.Input['KnowledgeBaseRedshiftQueryEngineStorageConfigurationArgs']]],
                 query_generation_configuration: Optional[pulumi.Input['KnowledgeBaseQueryGenerationConfigurationArgs']] = None):
        """
        Configurations for a Redshift knowledge base
        :param pulumi.Input['KnowledgeBaseRedshiftQueryEngineConfigurationArgs'] query_engine_configuration: Specifies configurations for an Amazon Redshift query engine.
        :param pulumi.Input[Sequence[pulumi.Input['KnowledgeBaseRedshiftQueryEngineStorageConfigurationArgs']]] storage_configurations: Specifies configurations for Amazon Redshift database storage.
        :param pulumi.Input['KnowledgeBaseQueryGenerationConfigurationArgs'] query_generation_configuration: Specifies configurations for generating queries.
        """
        pulumi.set(__self__, "query_engine_configuration", query_engine_configuration)
        pulumi.set(__self__, "storage_configurations", storage_configurations)
        if query_generation_configuration is not None:
            pulumi.set(__self__, "query_generation_configuration", query_generation_configuration)

    @_builtins.property
    @pulumi.getter(name="queryEngineConfiguration")
    def query_engine_configuration(self) -> pulumi.Input['KnowledgeBaseRedshiftQueryEngineConfigurationArgs']:
        """
        Specifies configurations for an Amazon Redshift query engine.
        """
        return pulumi.get(self, "query_engine_configuration")

    @query_engine_configuration.setter
    def query_engine_configuration(self, value: pulumi.Input['KnowledgeBaseRedshiftQueryEngineConfigurationArgs']):
        pulumi.set(self, "query_engine_configuration", value)

    @_builtins.property
    @pulumi.getter(name="storageConfigurations")
    def storage_configurations(self) -> pulumi.Input[Sequence[pulumi.Input['KnowledgeBaseRedshiftQueryEngineStorageConfigurationArgs']]]:
        """
        Specifies configurations for Amazon Redshift database storage.
        """
        return pulumi.get(self, "storage_configurations")

    @storage_configurations.setter
    def storage_configurations(self, value: pulumi.Input[Sequence[pulumi.Input['KnowledgeBaseRedshiftQueryEngineStorageConfigurationArgs']]]):
        pulumi.set(self, "storage_configurations", value)

    @_builtins.property
    @pulumi.getter(name="queryGenerationConfiguration")
    def query_generation_configuration(self) -> Optional[pulumi.Input['KnowledgeBaseQueryGenerationConfigurationArgs']]:
        """
        Specifies configurations for generating queries.
        """
        return pulumi.get(self, "query_generation_configuration")

    @query_generation_configuration.setter
    def query_generation_configuration(self, value: Optional[pulumi.Input['KnowledgeBaseQueryGenerationConfigurationArgs']]):
        pulumi.set(self, "query_generation_configuration", value)


if not MYPY:
    class KnowledgeBaseRedshiftProvisionedAuthConfigurationArgsDict(TypedDict):
        """
        Configurations for Redshift query engine provisioned auth setup
        """
        type: pulumi.Input['KnowledgeBaseRedshiftProvisionedAuthType']
        """
        The type of authentication to use.
        """
        database_user: NotRequired[pulumi.Input[_builtins.str]]
        """
        Redshift database user
        """
        username_password_secret_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ARN of an Secrets Manager secret for authentication.
        """
elif False:
    KnowledgeBaseRedshiftProvisionedAuthConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KnowledgeBaseRedshiftProvisionedAuthConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['KnowledgeBaseRedshiftProvisionedAuthType'],
                 database_user: Optional[pulumi.Input[_builtins.str]] = None,
                 username_password_secret_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Configurations for Redshift query engine provisioned auth setup
        :param pulumi.Input['KnowledgeBaseRedshiftProvisionedAuthType'] type: The type of authentication to use.
        :param pulumi.Input[_builtins.str] database_user: Redshift database user
        :param pulumi.Input[_builtins.str] username_password_secret_arn: The ARN of an Secrets Manager secret for authentication.
        """
        pulumi.set(__self__, "type", type)
        if database_user is not None:
            pulumi.set(__self__, "database_user", database_user)
        if username_password_secret_arn is not None:
            pulumi.set(__self__, "username_password_secret_arn", username_password_secret_arn)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['KnowledgeBaseRedshiftProvisionedAuthType']:
        """
        The type of authentication to use.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['KnowledgeBaseRedshiftProvisionedAuthType']):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="databaseUser")
    def database_user(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Redshift database user
        """
        return pulumi.get(self, "database_user")

    @database_user.setter
    def database_user(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_user", value)

    @_builtins.property
    @pulumi.getter(name="usernamePasswordSecretArn")
    def username_password_secret_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ARN of an Secrets Manager secret for authentication.
        """
        return pulumi.get(self, "username_password_secret_arn")

    @username_password_secret_arn.setter
    def username_password_secret_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username_password_secret_arn", value)


if not MYPY:
    class KnowledgeBaseRedshiftProvisionedConfigurationArgsDict(TypedDict):
        """
        Configurations for provisioned Redshift query engine
        """
        auth_configuration: pulumi.Input['KnowledgeBaseRedshiftProvisionedAuthConfigurationArgsDict']
        """
        Specifies configurations for authentication to Amazon Redshift.
        """
        cluster_identifier: pulumi.Input[_builtins.str]
        """
        The ID of the Amazon Redshift cluster.
        """
elif False:
    KnowledgeBaseRedshiftProvisionedConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KnowledgeBaseRedshiftProvisionedConfigurationArgs:
    def __init__(__self__, *,
                 auth_configuration: pulumi.Input['KnowledgeBaseRedshiftProvisionedAuthConfigurationArgs'],
                 cluster_identifier: pulumi.Input[_builtins.str]):
        """
        Configurations for provisioned Redshift query engine
        :param pulumi.Input['KnowledgeBaseRedshiftProvisionedAuthConfigurationArgs'] auth_configuration: Specifies configurations for authentication to Amazon Redshift.
        :param pulumi.Input[_builtins.str] cluster_identifier: The ID of the Amazon Redshift cluster.
        """
        pulumi.set(__self__, "auth_configuration", auth_configuration)
        pulumi.set(__self__, "cluster_identifier", cluster_identifier)

    @_builtins.property
    @pulumi.getter(name="authConfiguration")
    def auth_configuration(self) -> pulumi.Input['KnowledgeBaseRedshiftProvisionedAuthConfigurationArgs']:
        """
        Specifies configurations for authentication to Amazon Redshift.
        """
        return pulumi.get(self, "auth_configuration")

    @auth_configuration.setter
    def auth_configuration(self, value: pulumi.Input['KnowledgeBaseRedshiftProvisionedAuthConfigurationArgs']):
        pulumi.set(self, "auth_configuration", value)

    @_builtins.property
    @pulumi.getter(name="clusterIdentifier")
    def cluster_identifier(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the Amazon Redshift cluster.
        """
        return pulumi.get(self, "cluster_identifier")

    @cluster_identifier.setter
    def cluster_identifier(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cluster_identifier", value)


if not MYPY:
    class KnowledgeBaseRedshiftQueryEngineAwsDataCatalogStorageConfigurationArgsDict(TypedDict):
        """
        Configurations for Redshift query engine AWS Data Catalog backed storage
        """
        table_names: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    KnowledgeBaseRedshiftQueryEngineAwsDataCatalogStorageConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KnowledgeBaseRedshiftQueryEngineAwsDataCatalogStorageConfigurationArgs:
    def __init__(__self__, *,
                 table_names: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        Configurations for Redshift query engine AWS Data Catalog backed storage
        """
        pulumi.set(__self__, "table_names", table_names)

    @_builtins.property
    @pulumi.getter(name="tableNames")
    def table_names(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "table_names")

    @table_names.setter
    def table_names(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "table_names", value)


if not MYPY:
    class KnowledgeBaseRedshiftQueryEngineConfigurationArgsDict(TypedDict):
        """
        Configurations for Redshift query engine
        """
        type: pulumi.Input['KnowledgeBaseRedshiftQueryEngineType']
        """
        The type of query engine.
        """
        provisioned_configuration: NotRequired[pulumi.Input['KnowledgeBaseRedshiftProvisionedConfigurationArgsDict']]
        """
        Specifies configurations for a provisioned Amazon Redshift query engine.
        """
        serverless_configuration: NotRequired[pulumi.Input['KnowledgeBaseRedshiftServerlessConfigurationArgsDict']]
        """
        Specifies configurations for a serverless Amazon Redshift query engine.
        """
elif False:
    KnowledgeBaseRedshiftQueryEngineConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KnowledgeBaseRedshiftQueryEngineConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['KnowledgeBaseRedshiftQueryEngineType'],
                 provisioned_configuration: Optional[pulumi.Input['KnowledgeBaseRedshiftProvisionedConfigurationArgs']] = None,
                 serverless_configuration: Optional[pulumi.Input['KnowledgeBaseRedshiftServerlessConfigurationArgs']] = None):
        """
        Configurations for Redshift query engine
        :param pulumi.Input['KnowledgeBaseRedshiftQueryEngineType'] type: The type of query engine.
        :param pulumi.Input['KnowledgeBaseRedshiftProvisionedConfigurationArgs'] provisioned_configuration: Specifies configurations for a provisioned Amazon Redshift query engine.
        :param pulumi.Input['KnowledgeBaseRedshiftServerlessConfigurationArgs'] serverless_configuration: Specifies configurations for a serverless Amazon Redshift query engine.
        """
        pulumi.set(__self__, "type", type)
        if provisioned_configuration is not None:
            pulumi.set(__self__, "provisioned_configuration", provisioned_configuration)
        if serverless_configuration is not None:
            pulumi.set(__self__, "serverless_configuration", serverless_configuration)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['KnowledgeBaseRedshiftQueryEngineType']:
        """
        The type of query engine.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['KnowledgeBaseRedshiftQueryEngineType']):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="provisionedConfiguration")
    def provisioned_configuration(self) -> Optional[pulumi.Input['KnowledgeBaseRedshiftProvisionedConfigurationArgs']]:
        """
        Specifies configurations for a provisioned Amazon Redshift query engine.
        """
        return pulumi.get(self, "provisioned_configuration")

    @provisioned_configuration.setter
    def provisioned_configuration(self, value: Optional[pulumi.Input['KnowledgeBaseRedshiftProvisionedConfigurationArgs']]):
        pulumi.set(self, "provisioned_configuration", value)

    @_builtins.property
    @pulumi.getter(name="serverlessConfiguration")
    def serverless_configuration(self) -> Optional[pulumi.Input['KnowledgeBaseRedshiftServerlessConfigurationArgs']]:
        """
        Specifies configurations for a serverless Amazon Redshift query engine.
        """
        return pulumi.get(self, "serverless_configuration")

    @serverless_configuration.setter
    def serverless_configuration(self, value: Optional[pulumi.Input['KnowledgeBaseRedshiftServerlessConfigurationArgs']]):
        pulumi.set(self, "serverless_configuration", value)


if not MYPY:
    class KnowledgeBaseRedshiftQueryEngineRedshiftStorageConfigurationArgsDict(TypedDict):
        """
        Configurations for Redshift query engine Redshift backed storage
        """
        database_name: pulumi.Input[_builtins.str]
elif False:
    KnowledgeBaseRedshiftQueryEngineRedshiftStorageConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KnowledgeBaseRedshiftQueryEngineRedshiftStorageConfigurationArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[_builtins.str]):
        """
        Configurations for Redshift query engine Redshift backed storage
        """
        pulumi.set(__self__, "database_name", database_name)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database_name", value)


if not MYPY:
    class KnowledgeBaseRedshiftQueryEngineStorageConfigurationArgsDict(TypedDict):
        """
        Configurations for available Redshift query engine storage types
        """
        type: pulumi.Input['KnowledgeBaseRedshiftQueryEngineStorageType']
        aws_data_catalog_configuration: NotRequired[pulumi.Input['KnowledgeBaseRedshiftQueryEngineAwsDataCatalogStorageConfigurationArgsDict']]
        redshift_configuration: NotRequired[pulumi.Input['KnowledgeBaseRedshiftQueryEngineRedshiftStorageConfigurationArgsDict']]
elif False:
    KnowledgeBaseRedshiftQueryEngineStorageConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KnowledgeBaseRedshiftQueryEngineStorageConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['KnowledgeBaseRedshiftQueryEngineStorageType'],
                 aws_data_catalog_configuration: Optional[pulumi.Input['KnowledgeBaseRedshiftQueryEngineAwsDataCatalogStorageConfigurationArgs']] = None,
                 redshift_configuration: Optional[pulumi.Input['KnowledgeBaseRedshiftQueryEngineRedshiftStorageConfigurationArgs']] = None):
        """
        Configurations for available Redshift query engine storage types
        """
        pulumi.set(__self__, "type", type)
        if aws_data_catalog_configuration is not None:
            pulumi.set(__self__, "aws_data_catalog_configuration", aws_data_catalog_configuration)
        if redshift_configuration is not None:
            pulumi.set(__self__, "redshift_configuration", redshift_configuration)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['KnowledgeBaseRedshiftQueryEngineStorageType']:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['KnowledgeBaseRedshiftQueryEngineStorageType']):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="awsDataCatalogConfiguration")
    def aws_data_catalog_configuration(self) -> Optional[pulumi.Input['KnowledgeBaseRedshiftQueryEngineAwsDataCatalogStorageConfigurationArgs']]:
        return pulumi.get(self, "aws_data_catalog_configuration")

    @aws_data_catalog_configuration.setter
    def aws_data_catalog_configuration(self, value: Optional[pulumi.Input['KnowledgeBaseRedshiftQueryEngineAwsDataCatalogStorageConfigurationArgs']]):
        pulumi.set(self, "aws_data_catalog_configuration", value)

    @_builtins.property
    @pulumi.getter(name="redshiftConfiguration")
    def redshift_configuration(self) -> Optional[pulumi.Input['KnowledgeBaseRedshiftQueryEngineRedshiftStorageConfigurationArgs']]:
        return pulumi.get(self, "redshift_configuration")

    @redshift_configuration.setter
    def redshift_configuration(self, value: Optional[pulumi.Input['KnowledgeBaseRedshiftQueryEngineRedshiftStorageConfigurationArgs']]):
        pulumi.set(self, "redshift_configuration", value)


if not MYPY:
    class KnowledgeBaseRedshiftServerlessAuthConfigurationArgsDict(TypedDict):
        """
        Configurations for Redshift query engine serverless auth setup
        """
        type: pulumi.Input['KnowledgeBaseRedshiftServerlessAuthType']
        """
        The type of authentication to use.
        """
        username_password_secret_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ARN of an Secrets Manager secret for authentication.
        """
elif False:
    KnowledgeBaseRedshiftServerlessAuthConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KnowledgeBaseRedshiftServerlessAuthConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['KnowledgeBaseRedshiftServerlessAuthType'],
                 username_password_secret_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Configurations for Redshift query engine serverless auth setup
        :param pulumi.Input['KnowledgeBaseRedshiftServerlessAuthType'] type: The type of authentication to use.
        :param pulumi.Input[_builtins.str] username_password_secret_arn: The ARN of an Secrets Manager secret for authentication.
        """
        pulumi.set(__self__, "type", type)
        if username_password_secret_arn is not None:
            pulumi.set(__self__, "username_password_secret_arn", username_password_secret_arn)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['KnowledgeBaseRedshiftServerlessAuthType']:
        """
        The type of authentication to use.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['KnowledgeBaseRedshiftServerlessAuthType']):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="usernamePasswordSecretArn")
    def username_password_secret_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ARN of an Secrets Manager secret for authentication.
        """
        return pulumi.get(self, "username_password_secret_arn")

    @username_password_secret_arn.setter
    def username_password_secret_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username_password_secret_arn", value)


if not MYPY:
    class KnowledgeBaseRedshiftServerlessConfigurationArgsDict(TypedDict):
        """
        Configurations for serverless Redshift query engine
        """
        auth_configuration: pulumi.Input['KnowledgeBaseRedshiftServerlessAuthConfigurationArgsDict']
        """
        Specifies configurations for authentication to an Amazon Redshift provisioned data warehouse.
        """
        workgroup_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the Amazon Redshift workgroup.
        """
elif False:
    KnowledgeBaseRedshiftServerlessConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KnowledgeBaseRedshiftServerlessConfigurationArgs:
    def __init__(__self__, *,
                 auth_configuration: pulumi.Input['KnowledgeBaseRedshiftServerlessAuthConfigurationArgs'],
                 workgroup_arn: pulumi.Input[_builtins.str]):
        """
        Configurations for serverless Redshift query engine
        :param pulumi.Input['KnowledgeBaseRedshiftServerlessAuthConfigurationArgs'] auth_configuration: Specifies configurations for authentication to an Amazon Redshift provisioned data warehouse.
        :param pulumi.Input[_builtins.str] workgroup_arn: The ARN of the Amazon Redshift workgroup.
        """
        pulumi.set(__self__, "auth_configuration", auth_configuration)
        pulumi.set(__self__, "workgroup_arn", workgroup_arn)

    @_builtins.property
    @pulumi.getter(name="authConfiguration")
    def auth_configuration(self) -> pulumi.Input['KnowledgeBaseRedshiftServerlessAuthConfigurationArgs']:
        """
        Specifies configurations for authentication to an Amazon Redshift provisioned data warehouse.
        """
        return pulumi.get(self, "auth_configuration")

    @auth_configuration.setter
    def auth_configuration(self, value: pulumi.Input['KnowledgeBaseRedshiftServerlessAuthConfigurationArgs']):
        pulumi.set(self, "auth_configuration", value)

    @_builtins.property
    @pulumi.getter(name="workgroupArn")
    def workgroup_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the Amazon Redshift workgroup.
        """
        return pulumi.get(self, "workgroup_arn")

    @workgroup_arn.setter
    def workgroup_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "workgroup_arn", value)


if not MYPY:
    class KnowledgeBaseS3LocationArgsDict(TypedDict):
        """
        An Amazon S3 location.
        """
        uri: pulumi.Input[_builtins.str]
        """
        The location's URI
        """
elif False:
    KnowledgeBaseS3LocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KnowledgeBaseS3LocationArgs:
    def __init__(__self__, *,
                 uri: pulumi.Input[_builtins.str]):
        """
        An Amazon S3 location.
        :param pulumi.Input[_builtins.str] uri: The location's URI
        """
        pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> pulumi.Input[_builtins.str]:
        """
        The location's URI
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class KnowledgeBaseSqlKnowledgeBaseConfigurationArgsDict(TypedDict):
        """
        Configurations for a SQL knowledge base
        """
        type: pulumi.Input['KnowledgeBaseQueryEngineType']
        """
        The type of SQL database to connect to the knowledge base.
        """
        redshift_configuration: NotRequired[pulumi.Input['KnowledgeBaseRedshiftConfigurationArgsDict']]
        """
        Specifies configurations for a knowledge base connected to an Amazon Redshift database.
        """
elif False:
    KnowledgeBaseSqlKnowledgeBaseConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KnowledgeBaseSqlKnowledgeBaseConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['KnowledgeBaseQueryEngineType'],
                 redshift_configuration: Optional[pulumi.Input['KnowledgeBaseRedshiftConfigurationArgs']] = None):
        """
        Configurations for a SQL knowledge base
        :param pulumi.Input['KnowledgeBaseQueryEngineType'] type: The type of SQL database to connect to the knowledge base.
        :param pulumi.Input['KnowledgeBaseRedshiftConfigurationArgs'] redshift_configuration: Specifies configurations for a knowledge base connected to an Amazon Redshift database.
        """
        pulumi.set(__self__, "type", type)
        if redshift_configuration is not None:
            pulumi.set(__self__, "redshift_configuration", redshift_configuration)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['KnowledgeBaseQueryEngineType']:
        """
        The type of SQL database to connect to the knowledge base.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['KnowledgeBaseQueryEngineType']):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="redshiftConfiguration")
    def redshift_configuration(self) -> Optional[pulumi.Input['KnowledgeBaseRedshiftConfigurationArgs']]:
        """
        Specifies configurations for a knowledge base connected to an Amazon Redshift database.
        """
        return pulumi.get(self, "redshift_configuration")

    @redshift_configuration.setter
    def redshift_configuration(self, value: Optional[pulumi.Input['KnowledgeBaseRedshiftConfigurationArgs']]):
        pulumi.set(self, "redshift_configuration", value)


if not MYPY:
    class KnowledgeBaseStorageConfigurationArgsDict(TypedDict):
        """
        The vector store service in which the knowledge base is stored.
        """
        type: pulumi.Input['KnowledgeBaseStorageType']
        """
        The vector store service in which the knowledge base is stored.
        """
        mongo_db_atlas_configuration: NotRequired[pulumi.Input['KnowledgeBaseMongoDbAtlasConfigurationArgsDict']]
        """
        Contains the storage configuration of the knowledge base in MongoDB Atlas.
        """
        neptune_analytics_configuration: NotRequired[pulumi.Input['KnowledgeBaseNeptuneAnalyticsConfigurationArgsDict']]
        """
        Contains details about the Neptune Analytics configuration of the knowledge base in Amazon Neptune. For more information, see [Create a vector index in Amazon Neptune Analytics.](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-neptune.html) .
        """
        opensearch_managed_cluster_configuration: NotRequired[pulumi.Input['KnowledgeBaseOpenSearchManagedClusterConfigurationArgsDict']]
        """
        Contains details about the storage configuration of the knowledge base in OpenSearch Managed Cluster. For more information, see [Create a vector index in Amazon OpenSearch Service](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-osm.html) .
        """
        opensearch_serverless_configuration: NotRequired[pulumi.Input['KnowledgeBaseOpenSearchServerlessConfigurationArgsDict']]
        """
        Contains the storage configuration of the knowledge base in Amazon OpenSearch Service.
        """
        pinecone_configuration: NotRequired[pulumi.Input['KnowledgeBasePineconeConfigurationArgsDict']]
        """
        Contains the storage configuration of the knowledge base in Pinecone.
        """
        rds_configuration: NotRequired[pulumi.Input['KnowledgeBaseRdsConfigurationArgsDict']]
        """
        Contains details about the storage configuration of the knowledge base in Amazon RDS. For more information, see [Create a vector index in Amazon RDS](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-rds.html) .
        """
elif False:
    KnowledgeBaseStorageConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KnowledgeBaseStorageConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['KnowledgeBaseStorageType'],
                 mongo_db_atlas_configuration: Optional[pulumi.Input['KnowledgeBaseMongoDbAtlasConfigurationArgs']] = None,
                 neptune_analytics_configuration: Optional[pulumi.Input['KnowledgeBaseNeptuneAnalyticsConfigurationArgs']] = None,
                 opensearch_managed_cluster_configuration: Optional[pulumi.Input['KnowledgeBaseOpenSearchManagedClusterConfigurationArgs']] = None,
                 opensearch_serverless_configuration: Optional[pulumi.Input['KnowledgeBaseOpenSearchServerlessConfigurationArgs']] = None,
                 pinecone_configuration: Optional[pulumi.Input['KnowledgeBasePineconeConfigurationArgs']] = None,
                 rds_configuration: Optional[pulumi.Input['KnowledgeBaseRdsConfigurationArgs']] = None):
        """
        The vector store service in which the knowledge base is stored.
        :param pulumi.Input['KnowledgeBaseStorageType'] type: The vector store service in which the knowledge base is stored.
        :param pulumi.Input['KnowledgeBaseMongoDbAtlasConfigurationArgs'] mongo_db_atlas_configuration: Contains the storage configuration of the knowledge base in MongoDB Atlas.
        :param pulumi.Input['KnowledgeBaseNeptuneAnalyticsConfigurationArgs'] neptune_analytics_configuration: Contains details about the Neptune Analytics configuration of the knowledge base in Amazon Neptune. For more information, see [Create a vector index in Amazon Neptune Analytics.](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-neptune.html) .
        :param pulumi.Input['KnowledgeBaseOpenSearchManagedClusterConfigurationArgs'] opensearch_managed_cluster_configuration: Contains details about the storage configuration of the knowledge base in OpenSearch Managed Cluster. For more information, see [Create a vector index in Amazon OpenSearch Service](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-osm.html) .
        :param pulumi.Input['KnowledgeBaseOpenSearchServerlessConfigurationArgs'] opensearch_serverless_configuration: Contains the storage configuration of the knowledge base in Amazon OpenSearch Service.
        :param pulumi.Input['KnowledgeBasePineconeConfigurationArgs'] pinecone_configuration: Contains the storage configuration of the knowledge base in Pinecone.
        :param pulumi.Input['KnowledgeBaseRdsConfigurationArgs'] rds_configuration: Contains details about the storage configuration of the knowledge base in Amazon RDS. For more information, see [Create a vector index in Amazon RDS](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-rds.html) .
        """
        pulumi.set(__self__, "type", type)
        if mongo_db_atlas_configuration is not None:
            pulumi.set(__self__, "mongo_db_atlas_configuration", mongo_db_atlas_configuration)
        if neptune_analytics_configuration is not None:
            pulumi.set(__self__, "neptune_analytics_configuration", neptune_analytics_configuration)
        if opensearch_managed_cluster_configuration is not None:
            pulumi.set(__self__, "opensearch_managed_cluster_configuration", opensearch_managed_cluster_configuration)
        if opensearch_serverless_configuration is not None:
            pulumi.set(__self__, "opensearch_serverless_configuration", opensearch_serverless_configuration)
        if pinecone_configuration is not None:
            pulumi.set(__self__, "pinecone_configuration", pinecone_configuration)
        if rds_configuration is not None:
            pulumi.set(__self__, "rds_configuration", rds_configuration)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['KnowledgeBaseStorageType']:
        """
        The vector store service in which the knowledge base is stored.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['KnowledgeBaseStorageType']):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="mongoDbAtlasConfiguration")
    def mongo_db_atlas_configuration(self) -> Optional[pulumi.Input['KnowledgeBaseMongoDbAtlasConfigurationArgs']]:
        """
        Contains the storage configuration of the knowledge base in MongoDB Atlas.
        """
        return pulumi.get(self, "mongo_db_atlas_configuration")

    @mongo_db_atlas_configuration.setter
    def mongo_db_atlas_configuration(self, value: Optional[pulumi.Input['KnowledgeBaseMongoDbAtlasConfigurationArgs']]):
        pulumi.set(self, "mongo_db_atlas_configuration", value)

    @_builtins.property
    @pulumi.getter(name="neptuneAnalyticsConfiguration")
    def neptune_analytics_configuration(self) -> Optional[pulumi.Input['KnowledgeBaseNeptuneAnalyticsConfigurationArgs']]:
        """
        Contains details about the Neptune Analytics configuration of the knowledge base in Amazon Neptune. For more information, see [Create a vector index in Amazon Neptune Analytics.](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-neptune.html) .
        """
        return pulumi.get(self, "neptune_analytics_configuration")

    @neptune_analytics_configuration.setter
    def neptune_analytics_configuration(self, value: Optional[pulumi.Input['KnowledgeBaseNeptuneAnalyticsConfigurationArgs']]):
        pulumi.set(self, "neptune_analytics_configuration", value)

    @_builtins.property
    @pulumi.getter(name="opensearchManagedClusterConfiguration")
    def opensearch_managed_cluster_configuration(self) -> Optional[pulumi.Input['KnowledgeBaseOpenSearchManagedClusterConfigurationArgs']]:
        """
        Contains details about the storage configuration of the knowledge base in OpenSearch Managed Cluster. For more information, see [Create a vector index in Amazon OpenSearch Service](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-osm.html) .
        """
        return pulumi.get(self, "opensearch_managed_cluster_configuration")

    @opensearch_managed_cluster_configuration.setter
    def opensearch_managed_cluster_configuration(self, value: Optional[pulumi.Input['KnowledgeBaseOpenSearchManagedClusterConfigurationArgs']]):
        pulumi.set(self, "opensearch_managed_cluster_configuration", value)

    @_builtins.property
    @pulumi.getter(name="opensearchServerlessConfiguration")
    def opensearch_serverless_configuration(self) -> Optional[pulumi.Input['KnowledgeBaseOpenSearchServerlessConfigurationArgs']]:
        """
        Contains the storage configuration of the knowledge base in Amazon OpenSearch Service.
        """
        return pulumi.get(self, "opensearch_serverless_configuration")

    @opensearch_serverless_configuration.setter
    def opensearch_serverless_configuration(self, value: Optional[pulumi.Input['KnowledgeBaseOpenSearchServerlessConfigurationArgs']]):
        pulumi.set(self, "opensearch_serverless_configuration", value)

    @_builtins.property
    @pulumi.getter(name="pineconeConfiguration")
    def pinecone_configuration(self) -> Optional[pulumi.Input['KnowledgeBasePineconeConfigurationArgs']]:
        """
        Contains the storage configuration of the knowledge base in Pinecone.
        """
        return pulumi.get(self, "pinecone_configuration")

    @pinecone_configuration.setter
    def pinecone_configuration(self, value: Optional[pulumi.Input['KnowledgeBasePineconeConfigurationArgs']]):
        pulumi.set(self, "pinecone_configuration", value)

    @_builtins.property
    @pulumi.getter(name="rdsConfiguration")
    def rds_configuration(self) -> Optional[pulumi.Input['KnowledgeBaseRdsConfigurationArgs']]:
        """
        Contains details about the storage configuration of the knowledge base in Amazon RDS. For more information, see [Create a vector index in Amazon RDS](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-rds.html) .
        """
        return pulumi.get(self, "rds_configuration")

    @rds_configuration.setter
    def rds_configuration(self, value: Optional[pulumi.Input['KnowledgeBaseRdsConfigurationArgs']]):
        pulumi.set(self, "rds_configuration", value)


if not MYPY:
    class KnowledgeBaseSupplementalDataStorageConfigurationArgsDict(TypedDict):
        """
        Configurations for supplemental data storage.
        """
        supplemental_data_storage_locations: pulumi.Input[Sequence[pulumi.Input['KnowledgeBaseSupplementalDataStorageLocationArgsDict']]]
elif False:
    KnowledgeBaseSupplementalDataStorageConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KnowledgeBaseSupplementalDataStorageConfigurationArgs:
    def __init__(__self__, *,
                 supplemental_data_storage_locations: pulumi.Input[Sequence[pulumi.Input['KnowledgeBaseSupplementalDataStorageLocationArgs']]]):
        """
        Configurations for supplemental data storage.
        """
        pulumi.set(__self__, "supplemental_data_storage_locations", supplemental_data_storage_locations)

    @_builtins.property
    @pulumi.getter(name="supplementalDataStorageLocations")
    def supplemental_data_storage_locations(self) -> pulumi.Input[Sequence[pulumi.Input['KnowledgeBaseSupplementalDataStorageLocationArgs']]]:
        return pulumi.get(self, "supplemental_data_storage_locations")

    @supplemental_data_storage_locations.setter
    def supplemental_data_storage_locations(self, value: pulumi.Input[Sequence[pulumi.Input['KnowledgeBaseSupplementalDataStorageLocationArgs']]]):
        pulumi.set(self, "supplemental_data_storage_locations", value)


if not MYPY:
    class KnowledgeBaseSupplementalDataStorageLocationArgsDict(TypedDict):
        """
        Supplemental data storage location.
        """
        supplemental_data_storage_location_type: pulumi.Input['KnowledgeBaseSupplementalDataStorageLocationType']
        s3_location: NotRequired[pulumi.Input['KnowledgeBaseS3LocationArgsDict']]
elif False:
    KnowledgeBaseSupplementalDataStorageLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KnowledgeBaseSupplementalDataStorageLocationArgs:
    def __init__(__self__, *,
                 supplemental_data_storage_location_type: pulumi.Input['KnowledgeBaseSupplementalDataStorageLocationType'],
                 s3_location: Optional[pulumi.Input['KnowledgeBaseS3LocationArgs']] = None):
        """
        Supplemental data storage location.
        """
        pulumi.set(__self__, "supplemental_data_storage_location_type", supplemental_data_storage_location_type)
        if s3_location is not None:
            pulumi.set(__self__, "s3_location", s3_location)

    @_builtins.property
    @pulumi.getter(name="supplementalDataStorageLocationType")
    def supplemental_data_storage_location_type(self) -> pulumi.Input['KnowledgeBaseSupplementalDataStorageLocationType']:
        return pulumi.get(self, "supplemental_data_storage_location_type")

    @supplemental_data_storage_location_type.setter
    def supplemental_data_storage_location_type(self, value: pulumi.Input['KnowledgeBaseSupplementalDataStorageLocationType']):
        pulumi.set(self, "supplemental_data_storage_location_type", value)

    @_builtins.property
    @pulumi.getter(name="s3Location")
    def s3_location(self) -> Optional[pulumi.Input['KnowledgeBaseS3LocationArgs']]:
        return pulumi.get(self, "s3_location")

    @s3_location.setter
    def s3_location(self, value: Optional[pulumi.Input['KnowledgeBaseS3LocationArgs']]):
        pulumi.set(self, "s3_location", value)


if not MYPY:
    class KnowledgeBaseVectorKnowledgeBaseConfigurationArgsDict(TypedDict):
        """
        Contains details about the model used to create vector embeddings for the knowledge base.
        """
        embedding_model_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the model used to create vector embeddings for the knowledge base.
        """
        embedding_model_configuration: NotRequired[pulumi.Input['KnowledgeBaseEmbeddingModelConfigurationArgsDict']]
        """
        The embeddings model configuration details for the vector model used in Knowledge Base.
        """
        supplemental_data_storage_configuration: NotRequired[pulumi.Input['KnowledgeBaseSupplementalDataStorageConfigurationArgsDict']]
        """
        If you include multimodal data from your data source, use this object to specify configurations for the storage location of the images extracted from your documents. These images can be retrieved and returned to the end user. They can also be used in generation when using [RetrieveAndGenerate](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html) .
        """
elif False:
    KnowledgeBaseVectorKnowledgeBaseConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KnowledgeBaseVectorKnowledgeBaseConfigurationArgs:
    def __init__(__self__, *,
                 embedding_model_arn: pulumi.Input[_builtins.str],
                 embedding_model_configuration: Optional[pulumi.Input['KnowledgeBaseEmbeddingModelConfigurationArgs']] = None,
                 supplemental_data_storage_configuration: Optional[pulumi.Input['KnowledgeBaseSupplementalDataStorageConfigurationArgs']] = None):
        """
        Contains details about the model used to create vector embeddings for the knowledge base.
        :param pulumi.Input[_builtins.str] embedding_model_arn: The ARN of the model used to create vector embeddings for the knowledge base.
        :param pulumi.Input['KnowledgeBaseEmbeddingModelConfigurationArgs'] embedding_model_configuration: The embeddings model configuration details for the vector model used in Knowledge Base.
        :param pulumi.Input['KnowledgeBaseSupplementalDataStorageConfigurationArgs'] supplemental_data_storage_configuration: If you include multimodal data from your data source, use this object to specify configurations for the storage location of the images extracted from your documents. These images can be retrieved and returned to the end user. They can also be used in generation when using [RetrieveAndGenerate](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html) .
        """
        pulumi.set(__self__, "embedding_model_arn", embedding_model_arn)
        if embedding_model_configuration is not None:
            pulumi.set(__self__, "embedding_model_configuration", embedding_model_configuration)
        if supplemental_data_storage_configuration is not None:
            pulumi.set(__self__, "supplemental_data_storage_configuration", supplemental_data_storage_configuration)

    @_builtins.property
    @pulumi.getter(name="embeddingModelArn")
    def embedding_model_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the model used to create vector embeddings for the knowledge base.
        """
        return pulumi.get(self, "embedding_model_arn")

    @embedding_model_arn.setter
    def embedding_model_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "embedding_model_arn", value)

    @_builtins.property
    @pulumi.getter(name="embeddingModelConfiguration")
    def embedding_model_configuration(self) -> Optional[pulumi.Input['KnowledgeBaseEmbeddingModelConfigurationArgs']]:
        """
        The embeddings model configuration details for the vector model used in Knowledge Base.
        """
        return pulumi.get(self, "embedding_model_configuration")

    @embedding_model_configuration.setter
    def embedding_model_configuration(self, value: Optional[pulumi.Input['KnowledgeBaseEmbeddingModelConfigurationArgs']]):
        pulumi.set(self, "embedding_model_configuration", value)

    @_builtins.property
    @pulumi.getter(name="supplementalDataStorageConfiguration")
    def supplemental_data_storage_configuration(self) -> Optional[pulumi.Input['KnowledgeBaseSupplementalDataStorageConfigurationArgs']]:
        """
        If you include multimodal data from your data source, use this object to specify configurations for the storage location of the images extracted from your documents. These images can be retrieved and returned to the end user. They can also be used in generation when using [RetrieveAndGenerate](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html) .
        """
        return pulumi.get(self, "supplemental_data_storage_configuration")

    @supplemental_data_storage_configuration.setter
    def supplemental_data_storage_configuration(self, value: Optional[pulumi.Input['KnowledgeBaseSupplementalDataStorageConfigurationArgs']]):
        pulumi.set(self, "supplemental_data_storage_configuration", value)


if not MYPY:
    class PromptAdditionalModelRequestFieldsArgsDict(TypedDict):
        """
        Contains model-specific configurations
        """
        pass
elif False:
    PromptAdditionalModelRequestFieldsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PromptAdditionalModelRequestFieldsArgs:
    def __init__(__self__):
        """
        Contains model-specific configurations
        """
        pass


if not MYPY:
    class PromptAgentResourceArgsDict(TypedDict):
        """
        Target Agent to invoke with Prompt
        """
        agent_identifier: pulumi.Input[_builtins.str]
        """
        Arn representation of the Agent Alias.
        """
elif False:
    PromptAgentResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PromptAgentResourceArgs:
    def __init__(__self__, *,
                 agent_identifier: pulumi.Input[_builtins.str]):
        """
        Target Agent to invoke with Prompt
        :param pulumi.Input[_builtins.str] agent_identifier: Arn representation of the Agent Alias.
        """
        pulumi.set(__self__, "agent_identifier", agent_identifier)

    @_builtins.property
    @pulumi.getter(name="agentIdentifier")
    def agent_identifier(self) -> pulumi.Input[_builtins.str]:
        """
        Arn representation of the Agent Alias.
        """
        return pulumi.get(self, "agent_identifier")

    @agent_identifier.setter
    def agent_identifier(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "agent_identifier", value)


if not MYPY:
    class PromptAnyToolChoiceArgsDict(TypedDict):
        """
        Any Tool choice
        """
        pass
elif False:
    PromptAnyToolChoiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PromptAnyToolChoiceArgs:
    def __init__(__self__):
        """
        Any Tool choice
        """
        pass


if not MYPY:
    class PromptAutoToolChoiceArgsDict(TypedDict):
        """
        Auto Tool choice
        """
        pass
elif False:
    PromptAutoToolChoiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PromptAutoToolChoiceArgs:
    def __init__(__self__):
        """
        Auto Tool choice
        """
        pass


if not MYPY:
    class PromptCachePointBlockArgsDict(TypedDict):
        """
        CachePointBlock
        """
        type: pulumi.Input['PromptCachePointType']
elif False:
    PromptCachePointBlockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PromptCachePointBlockArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['PromptCachePointType']):
        """
        CachePointBlock
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['PromptCachePointType']:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['PromptCachePointType']):
        pulumi.set(self, "type", value)


if not MYPY:
    class PromptChatPromptTemplateConfigurationArgsDict(TypedDict):
        """
        Configuration for chat prompt template
        """
        messages: pulumi.Input[Sequence[pulumi.Input['PromptMessageArgsDict']]]
        """
        List of messages for chat prompt template
        """
        input_variables: NotRequired[pulumi.Input[Sequence[pulumi.Input['PromptInputVariableArgsDict']]]]
        """
        List of input variables
        """
        system: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union['PromptSystemContentBlock0PropertiesArgsDict', 'PromptSystemContentBlock1PropertiesArgsDict']]]]]
        """
        Configuration for chat prompt template
        """
        tool_configuration: NotRequired[pulumi.Input['PromptToolConfigurationArgsDict']]
elif False:
    PromptChatPromptTemplateConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PromptChatPromptTemplateConfigurationArgs:
    def __init__(__self__, *,
                 messages: pulumi.Input[Sequence[pulumi.Input['PromptMessageArgs']]],
                 input_variables: Optional[pulumi.Input[Sequence[pulumi.Input['PromptInputVariableArgs']]]] = None,
                 system: Optional[pulumi.Input[Sequence[pulumi.Input[Union['PromptSystemContentBlock0PropertiesArgs', 'PromptSystemContentBlock1PropertiesArgs']]]]] = None,
                 tool_configuration: Optional[pulumi.Input['PromptToolConfigurationArgs']] = None):
        """
        Configuration for chat prompt template
        :param pulumi.Input[Sequence[pulumi.Input['PromptMessageArgs']]] messages: List of messages for chat prompt template
        :param pulumi.Input[Sequence[pulumi.Input['PromptInputVariableArgs']]] input_variables: List of input variables
        :param pulumi.Input[Sequence[pulumi.Input[Union['PromptSystemContentBlock0PropertiesArgs', 'PromptSystemContentBlock1PropertiesArgs']]]] system: Configuration for chat prompt template
        """
        pulumi.set(__self__, "messages", messages)
        if input_variables is not None:
            pulumi.set(__self__, "input_variables", input_variables)
        if system is not None:
            pulumi.set(__self__, "system", system)
        if tool_configuration is not None:
            pulumi.set(__self__, "tool_configuration", tool_configuration)

    @_builtins.property
    @pulumi.getter
    def messages(self) -> pulumi.Input[Sequence[pulumi.Input['PromptMessageArgs']]]:
        """
        List of messages for chat prompt template
        """
        return pulumi.get(self, "messages")

    @messages.setter
    def messages(self, value: pulumi.Input[Sequence[pulumi.Input['PromptMessageArgs']]]):
        pulumi.set(self, "messages", value)

    @_builtins.property
    @pulumi.getter(name="inputVariables")
    def input_variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PromptInputVariableArgs']]]]:
        """
        List of input variables
        """
        return pulumi.get(self, "input_variables")

    @input_variables.setter
    def input_variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PromptInputVariableArgs']]]]):
        pulumi.set(self, "input_variables", value)

    @_builtins.property
    @pulumi.getter
    def system(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union['PromptSystemContentBlock0PropertiesArgs', 'PromptSystemContentBlock1PropertiesArgs']]]]]:
        """
        Configuration for chat prompt template
        """
        return pulumi.get(self, "system")

    @system.setter
    def system(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union['PromptSystemContentBlock0PropertiesArgs', 'PromptSystemContentBlock1PropertiesArgs']]]]]):
        pulumi.set(self, "system", value)

    @_builtins.property
    @pulumi.getter(name="toolConfiguration")
    def tool_configuration(self) -> Optional[pulumi.Input['PromptToolConfigurationArgs']]:
        return pulumi.get(self, "tool_configuration")

    @tool_configuration.setter
    def tool_configuration(self, value: Optional[pulumi.Input['PromptToolConfigurationArgs']]):
        pulumi.set(self, "tool_configuration", value)


if not MYPY:
    class PromptContentBlock0PropertiesArgsDict(TypedDict):
        """
        Configuration for chat prompt template
        """
        text: pulumi.Input[_builtins.str]
        """
        Configuration for chat prompt template
        """
elif False:
    PromptContentBlock0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PromptContentBlock0PropertiesArgs:
    def __init__(__self__, *,
                 text: pulumi.Input[_builtins.str]):
        """
        Configuration for chat prompt template
        :param pulumi.Input[_builtins.str] text: Configuration for chat prompt template
        """
        pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def text(self) -> pulumi.Input[_builtins.str]:
        """
        Configuration for chat prompt template
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "text", value)


if not MYPY:
    class PromptContentBlock1PropertiesArgsDict(TypedDict):
        """
        Configuration for chat prompt template
        """
        cache_point: pulumi.Input['PromptCachePointBlockArgsDict']
elif False:
    PromptContentBlock1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PromptContentBlock1PropertiesArgs:
    def __init__(__self__, *,
                 cache_point: pulumi.Input['PromptCachePointBlockArgs']):
        """
        Configuration for chat prompt template
        """
        pulumi.set(__self__, "cache_point", cache_point)

    @_builtins.property
    @pulumi.getter(name="cachePoint")
    def cache_point(self) -> pulumi.Input['PromptCachePointBlockArgs']:
        return pulumi.get(self, "cache_point")

    @cache_point.setter
    def cache_point(self, value: pulumi.Input['PromptCachePointBlockArgs']):
        pulumi.set(self, "cache_point", value)


if not MYPY:
    class PromptGenAiResourcePropertiesArgsDict(TypedDict):
        """
        Target resource to invoke with Prompt
        """
        agent: pulumi.Input['PromptAgentResourceArgsDict']
elif False:
    PromptGenAiResourcePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PromptGenAiResourcePropertiesArgs:
    def __init__(__self__, *,
                 agent: pulumi.Input['PromptAgentResourceArgs']):
        """
        Target resource to invoke with Prompt
        """
        pulumi.set(__self__, "agent", agent)

    @_builtins.property
    @pulumi.getter
    def agent(self) -> pulumi.Input['PromptAgentResourceArgs']:
        return pulumi.get(self, "agent")

    @agent.setter
    def agent(self, value: pulumi.Input['PromptAgentResourceArgs']):
        pulumi.set(self, "agent", value)


if not MYPY:
    class PromptInferenceConfigurationPropertiesArgsDict(TypedDict):
        """
        Model inference configuration
        """
        text: pulumi.Input['PromptModelInferenceConfigurationArgsDict']
elif False:
    PromptInferenceConfigurationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PromptInferenceConfigurationPropertiesArgs:
    def __init__(__self__, *,
                 text: pulumi.Input['PromptModelInferenceConfigurationArgs']):
        """
        Model inference configuration
        """
        pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def text(self) -> pulumi.Input['PromptModelInferenceConfigurationArgs']:
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input['PromptModelInferenceConfigurationArgs']):
        pulumi.set(self, "text", value)


if not MYPY:
    class PromptInputVariableArgsDict(TypedDict):
        """
        Input variable
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name for an input variable
        """
elif False:
    PromptInputVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PromptInputVariableArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Input variable
        :param pulumi.Input[_builtins.str] name: Name for an input variable
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name for an input variable
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PromptMessageArgsDict(TypedDict):
        """
        Chat prompt Message
        """
        content: pulumi.Input[Sequence[pulumi.Input[Union['PromptContentBlock0PropertiesArgsDict', 'PromptContentBlock1PropertiesArgsDict']]]]
        """
        List of Content Blocks
        """
        role: pulumi.Input['PromptConversationRole']
elif False:
    PromptMessageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PromptMessageArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[Sequence[pulumi.Input[Union['PromptContentBlock0PropertiesArgs', 'PromptContentBlock1PropertiesArgs']]]],
                 role: pulumi.Input['PromptConversationRole']):
        """
        Chat prompt Message
        :param pulumi.Input[Sequence[pulumi.Input[Union['PromptContentBlock0PropertiesArgs', 'PromptContentBlock1PropertiesArgs']]]] content: List of Content Blocks
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "role", role)

    @_builtins.property
    @pulumi.getter
    def content(self) -> pulumi.Input[Sequence[pulumi.Input[Union['PromptContentBlock0PropertiesArgs', 'PromptContentBlock1PropertiesArgs']]]]:
        """
        List of Content Blocks
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[Sequence[pulumi.Input[Union['PromptContentBlock0PropertiesArgs', 'PromptContentBlock1PropertiesArgs']]]]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter
    def role(self) -> pulumi.Input['PromptConversationRole']:
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: pulumi.Input['PromptConversationRole']):
        pulumi.set(self, "role", value)


if not MYPY:
    class PromptMetadataEntryArgsDict(TypedDict):
        """
        Contains a key-value pair that defines a metadata tag and value to attach to a prompt variant.
        """
        key: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    PromptMetadataEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PromptMetadataEntryArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        Contains a key-value pair that defines a metadata tag and value to attach to a prompt variant.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PromptModelInferenceConfigurationArgsDict(TypedDict):
        """
        Prompt model inference configuration
        """
        max_tokens: NotRequired[pulumi.Input[_builtins.float]]
        """
        Maximum length of output
        """
        stop_sequences: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of stop sequences
        """
        temperature: NotRequired[pulumi.Input[_builtins.float]]
        """
        Controls randomness, higher values increase diversity
        """
        top_p: NotRequired[pulumi.Input[_builtins.float]]
        """
        Cumulative probability cutoff for token selection
        """
elif False:
    PromptModelInferenceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PromptModelInferenceConfigurationArgs:
    def __init__(__self__, *,
                 max_tokens: Optional[pulumi.Input[_builtins.float]] = None,
                 stop_sequences: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 temperature: Optional[pulumi.Input[_builtins.float]] = None,
                 top_p: Optional[pulumi.Input[_builtins.float]] = None):
        """
        Prompt model inference configuration
        :param pulumi.Input[_builtins.float] max_tokens: Maximum length of output
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] stop_sequences: List of stop sequences
        :param pulumi.Input[_builtins.float] temperature: Controls randomness, higher values increase diversity
        :param pulumi.Input[_builtins.float] top_p: Cumulative probability cutoff for token selection
        """
        if max_tokens is not None:
            pulumi.set(__self__, "max_tokens", max_tokens)
        if stop_sequences is not None:
            pulumi.set(__self__, "stop_sequences", stop_sequences)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)
        if top_p is not None:
            pulumi.set(__self__, "top_p", top_p)

    @_builtins.property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Maximum length of output
        """
        return pulumi.get(self, "max_tokens")

    @max_tokens.setter
    def max_tokens(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "max_tokens", value)

    @_builtins.property
    @pulumi.getter(name="stopSequences")
    def stop_sequences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of stop sequences
        """
        return pulumi.get(self, "stop_sequences")

    @stop_sequences.setter
    def stop_sequences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "stop_sequences", value)

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Controls randomness, higher values increase diversity
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "temperature", value)

    @_builtins.property
    @pulumi.getter(name="topP")
    def top_p(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Cumulative probability cutoff for token selection
        """
        return pulumi.get(self, "top_p")

    @top_p.setter
    def top_p(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "top_p", value)


if not MYPY:
    class PromptSpecificToolChoiceArgsDict(TypedDict):
        """
        Specific Tool choice
        """
        name: pulumi.Input[_builtins.str]
        """
        Tool name
        """
elif False:
    PromptSpecificToolChoiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PromptSpecificToolChoiceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        Specific Tool choice
        :param pulumi.Input[_builtins.str] name: Tool name
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Tool name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PromptSystemContentBlock0PropertiesArgsDict(TypedDict):
        """
        Configuration for chat prompt template
        """
        text: pulumi.Input[_builtins.str]
        """
        Configuration for chat prompt template
        """
elif False:
    PromptSystemContentBlock0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PromptSystemContentBlock0PropertiesArgs:
    def __init__(__self__, *,
                 text: pulumi.Input[_builtins.str]):
        """
        Configuration for chat prompt template
        :param pulumi.Input[_builtins.str] text: Configuration for chat prompt template
        """
        pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def text(self) -> pulumi.Input[_builtins.str]:
        """
        Configuration for chat prompt template
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "text", value)


if not MYPY:
    class PromptSystemContentBlock1PropertiesArgsDict(TypedDict):
        """
        Configuration for chat prompt template
        """
        cache_point: pulumi.Input['PromptCachePointBlockArgsDict']
elif False:
    PromptSystemContentBlock1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PromptSystemContentBlock1PropertiesArgs:
    def __init__(__self__, *,
                 cache_point: pulumi.Input['PromptCachePointBlockArgs']):
        """
        Configuration for chat prompt template
        """
        pulumi.set(__self__, "cache_point", cache_point)

    @_builtins.property
    @pulumi.getter(name="cachePoint")
    def cache_point(self) -> pulumi.Input['PromptCachePointBlockArgs']:
        return pulumi.get(self, "cache_point")

    @cache_point.setter
    def cache_point(self, value: pulumi.Input['PromptCachePointBlockArgs']):
        pulumi.set(self, "cache_point", value)


if not MYPY:
    class PromptTemplateConfiguration0PropertiesArgsDict(TypedDict):
        """
        Prompt template configuration
        """
        text: pulumi.Input['PromptTextPromptTemplateConfigurationArgsDict']
elif False:
    PromptTemplateConfiguration0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PromptTemplateConfiguration0PropertiesArgs:
    def __init__(__self__, *,
                 text: pulumi.Input['PromptTextPromptTemplateConfigurationArgs']):
        """
        Prompt template configuration
        """
        pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def text(self) -> pulumi.Input['PromptTextPromptTemplateConfigurationArgs']:
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input['PromptTextPromptTemplateConfigurationArgs']):
        pulumi.set(self, "text", value)


if not MYPY:
    class PromptTemplateConfiguration1PropertiesArgsDict(TypedDict):
        """
        Prompt template configuration
        """
        chat: pulumi.Input['PromptChatPromptTemplateConfigurationArgsDict']
elif False:
    PromptTemplateConfiguration1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PromptTemplateConfiguration1PropertiesArgs:
    def __init__(__self__, *,
                 chat: pulumi.Input['PromptChatPromptTemplateConfigurationArgs']):
        """
        Prompt template configuration
        """
        pulumi.set(__self__, "chat", chat)

    @_builtins.property
    @pulumi.getter
    def chat(self) -> pulumi.Input['PromptChatPromptTemplateConfigurationArgs']:
        return pulumi.get(self, "chat")

    @chat.setter
    def chat(self, value: pulumi.Input['PromptChatPromptTemplateConfigurationArgs']):
        pulumi.set(self, "chat", value)


if not MYPY:
    class PromptTextPromptTemplateConfigurationArgsDict(TypedDict):
        """
        Configuration for text prompt template
        """
        cache_point: NotRequired[pulumi.Input['PromptCachePointBlockArgsDict']]
        input_variables: NotRequired[pulumi.Input[Sequence[pulumi.Input['PromptInputVariableArgsDict']]]]
        """
        List of input variables
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        Prompt content for String prompt template
        """
        text_s3_location: NotRequired[pulumi.Input['PromptTextS3LocationArgsDict']]
elif False:
    PromptTextPromptTemplateConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PromptTextPromptTemplateConfigurationArgs:
    def __init__(__self__, *,
                 cache_point: Optional[pulumi.Input['PromptCachePointBlockArgs']] = None,
                 input_variables: Optional[pulumi.Input[Sequence[pulumi.Input['PromptInputVariableArgs']]]] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None,
                 text_s3_location: Optional[pulumi.Input['PromptTextS3LocationArgs']] = None):
        """
        Configuration for text prompt template
        :param pulumi.Input[Sequence[pulumi.Input['PromptInputVariableArgs']]] input_variables: List of input variables
        :param pulumi.Input[_builtins.str] text: Prompt content for String prompt template
        """
        if cache_point is not None:
            pulumi.set(__self__, "cache_point", cache_point)
        if input_variables is not None:
            pulumi.set(__self__, "input_variables", input_variables)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if text_s3_location is not None:
            pulumi.set(__self__, "text_s3_location", text_s3_location)

    @_builtins.property
    @pulumi.getter(name="cachePoint")
    def cache_point(self) -> Optional[pulumi.Input['PromptCachePointBlockArgs']]:
        return pulumi.get(self, "cache_point")

    @cache_point.setter
    def cache_point(self, value: Optional[pulumi.Input['PromptCachePointBlockArgs']]):
        pulumi.set(self, "cache_point", value)

    @_builtins.property
    @pulumi.getter(name="inputVariables")
    def input_variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PromptInputVariableArgs']]]]:
        """
        List of input variables
        """
        return pulumi.get(self, "input_variables")

    @input_variables.setter
    def input_variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PromptInputVariableArgs']]]]):
        pulumi.set(self, "input_variables", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Prompt content for String prompt template
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)

    @_builtins.property
    @pulumi.getter(name="textS3Location")
    def text_s3_location(self) -> Optional[pulumi.Input['PromptTextS3LocationArgs']]:
        return pulumi.get(self, "text_s3_location")

    @text_s3_location.setter
    def text_s3_location(self, value: Optional[pulumi.Input['PromptTextS3LocationArgs']]):
        pulumi.set(self, "text_s3_location", value)


if not MYPY:
    class PromptTextS3LocationArgsDict(TypedDict):
        """
        The identifier for the S3 resource.
        """
        bucket: pulumi.Input[_builtins.str]
        """
        A bucket in S3
        """
        key: pulumi.Input[_builtins.str]
        """
        A object key in S3
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The version of the the S3 object to use
        """
elif False:
    PromptTextS3LocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PromptTextS3LocationArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[_builtins.str],
                 key: pulumi.Input[_builtins.str],
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The identifier for the S3 resource.
        :param pulumi.Input[_builtins.str] bucket: A bucket in S3
        :param pulumi.Input[_builtins.str] key: A object key in S3
        :param pulumi.Input[_builtins.str] version: The version of the the S3 object to use
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "key", key)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[_builtins.str]:
        """
        A bucket in S3
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        A object key in S3
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The version of the the S3 object to use
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class PromptTool0PropertiesArgsDict(TypedDict):
        """
        Tool details
        """
        tool_spec: pulumi.Input['PromptToolSpecificationArgsDict']
elif False:
    PromptTool0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PromptTool0PropertiesArgs:
    def __init__(__self__, *,
                 tool_spec: pulumi.Input['PromptToolSpecificationArgs']):
        """
        Tool details
        """
        pulumi.set(__self__, "tool_spec", tool_spec)

    @_builtins.property
    @pulumi.getter(name="toolSpec")
    def tool_spec(self) -> pulumi.Input['PromptToolSpecificationArgs']:
        return pulumi.get(self, "tool_spec")

    @tool_spec.setter
    def tool_spec(self, value: pulumi.Input['PromptToolSpecificationArgs']):
        pulumi.set(self, "tool_spec", value)


if not MYPY:
    class PromptTool1PropertiesArgsDict(TypedDict):
        """
        Tool details
        """
        cache_point: pulumi.Input['PromptCachePointBlockArgsDict']
elif False:
    PromptTool1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PromptTool1PropertiesArgs:
    def __init__(__self__, *,
                 cache_point: pulumi.Input['PromptCachePointBlockArgs']):
        """
        Tool details
        """
        pulumi.set(__self__, "cache_point", cache_point)

    @_builtins.property
    @pulumi.getter(name="cachePoint")
    def cache_point(self) -> pulumi.Input['PromptCachePointBlockArgs']:
        return pulumi.get(self, "cache_point")

    @cache_point.setter
    def cache_point(self, value: pulumi.Input['PromptCachePointBlockArgs']):
        pulumi.set(self, "cache_point", value)


if not MYPY:
    class PromptToolChoice0PropertiesArgsDict(TypedDict):
        """
        Tool choice
        """
        auto: pulumi.Input['PromptAutoToolChoiceArgsDict']
elif False:
    PromptToolChoice0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PromptToolChoice0PropertiesArgs:
    def __init__(__self__, *,
                 auto: pulumi.Input['PromptAutoToolChoiceArgs']):
        """
        Tool choice
        """
        pulumi.set(__self__, "auto", auto)

    @_builtins.property
    @pulumi.getter
    def auto(self) -> pulumi.Input['PromptAutoToolChoiceArgs']:
        return pulumi.get(self, "auto")

    @auto.setter
    def auto(self, value: pulumi.Input['PromptAutoToolChoiceArgs']):
        pulumi.set(self, "auto", value)


if not MYPY:
    class PromptToolChoice1PropertiesArgsDict(TypedDict):
        """
        Tool choice
        """
        any: pulumi.Input['PromptAnyToolChoiceArgsDict']
elif False:
    PromptToolChoice1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PromptToolChoice1PropertiesArgs:
    def __init__(__self__, *,
                 any: pulumi.Input['PromptAnyToolChoiceArgs']):
        """
        Tool choice
        """
        pulumi.set(__self__, "any", any)

    @_builtins.property
    @pulumi.getter
    def any(self) -> pulumi.Input['PromptAnyToolChoiceArgs']:
        return pulumi.get(self, "any")

    @any.setter
    def any(self, value: pulumi.Input['PromptAnyToolChoiceArgs']):
        pulumi.set(self, "any", value)


if not MYPY:
    class PromptToolChoice2PropertiesArgsDict(TypedDict):
        """
        Tool choice
        """
        tool: pulumi.Input['PromptSpecificToolChoiceArgsDict']
elif False:
    PromptToolChoice2PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PromptToolChoice2PropertiesArgs:
    def __init__(__self__, *,
                 tool: pulumi.Input['PromptSpecificToolChoiceArgs']):
        """
        Tool choice
        """
        pulumi.set(__self__, "tool", tool)

    @_builtins.property
    @pulumi.getter
    def tool(self) -> pulumi.Input['PromptSpecificToolChoiceArgs']:
        return pulumi.get(self, "tool")

    @tool.setter
    def tool(self, value: pulumi.Input['PromptSpecificToolChoiceArgs']):
        pulumi.set(self, "tool", value)


if not MYPY:
    class PromptToolConfigurationArgsDict(TypedDict):
        """
        Tool configuration
        """
        tools: pulumi.Input[Sequence[pulumi.Input[Union['PromptTool0PropertiesArgsDict', 'PromptTool1PropertiesArgsDict']]]]
        """
        List of Tools
        """
        tool_choice: NotRequired[pulumi.Input[Union['PromptToolChoice0PropertiesArgsDict', 'PromptToolChoice1PropertiesArgsDict', 'PromptToolChoice2PropertiesArgsDict']]]
elif False:
    PromptToolConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PromptToolConfigurationArgs:
    def __init__(__self__, *,
                 tools: pulumi.Input[Sequence[pulumi.Input[Union['PromptTool0PropertiesArgs', 'PromptTool1PropertiesArgs']]]],
                 tool_choice: Optional[pulumi.Input[Union['PromptToolChoice0PropertiesArgs', 'PromptToolChoice1PropertiesArgs', 'PromptToolChoice2PropertiesArgs']]] = None):
        """
        Tool configuration
        :param pulumi.Input[Sequence[pulumi.Input[Union['PromptTool0PropertiesArgs', 'PromptTool1PropertiesArgs']]]] tools: List of Tools
        """
        pulumi.set(__self__, "tools", tools)
        if tool_choice is not None:
            pulumi.set(__self__, "tool_choice", tool_choice)

    @_builtins.property
    @pulumi.getter
    def tools(self) -> pulumi.Input[Sequence[pulumi.Input[Union['PromptTool0PropertiesArgs', 'PromptTool1PropertiesArgs']]]]:
        """
        List of Tools
        """
        return pulumi.get(self, "tools")

    @tools.setter
    def tools(self, value: pulumi.Input[Sequence[pulumi.Input[Union['PromptTool0PropertiesArgs', 'PromptTool1PropertiesArgs']]]]):
        pulumi.set(self, "tools", value)

    @_builtins.property
    @pulumi.getter(name="toolChoice")
    def tool_choice(self) -> Optional[pulumi.Input[Union['PromptToolChoice0PropertiesArgs', 'PromptToolChoice1PropertiesArgs', 'PromptToolChoice2PropertiesArgs']]]:
        return pulumi.get(self, "tool_choice")

    @tool_choice.setter
    def tool_choice(self, value: Optional[pulumi.Input[Union['PromptToolChoice0PropertiesArgs', 'PromptToolChoice1PropertiesArgs', 'PromptToolChoice2PropertiesArgs']]]):
        pulumi.set(self, "tool_choice", value)


if not MYPY:
    class PromptToolInputSchemaPropertiesArgsDict(TypedDict):
        """
        Tool input schema json
        """
        json: Any
elif False:
    PromptToolInputSchemaPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PromptToolInputSchemaPropertiesArgs:
    def __init__(__self__, *,
                 json: Any):
        """
        Tool input schema json
        """
        pulumi.set(__self__, "json", json)

    @_builtins.property
    @pulumi.getter
    def json(self) -> Any:
        return pulumi.get(self, "json")

    @json.setter
    def json(self, value: Any):
        pulumi.set(self, "json", value)


if not MYPY:
    class PromptToolSpecificationArgsDict(TypedDict):
        """
        Tool specification
        """
        input_schema: pulumi.Input['PromptToolInputSchemaPropertiesArgsDict']
        name: pulumi.Input[_builtins.str]
        """
        Tool name
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PromptToolSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PromptToolSpecificationArgs:
    def __init__(__self__, *,
                 input_schema: pulumi.Input['PromptToolInputSchemaPropertiesArgs'],
                 name: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Tool specification
        :param pulumi.Input[_builtins.str] name: Tool name
        """
        pulumi.set(__self__, "input_schema", input_schema)
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter(name="inputSchema")
    def input_schema(self) -> pulumi.Input['PromptToolInputSchemaPropertiesArgs']:
        return pulumi.get(self, "input_schema")

    @input_schema.setter
    def input_schema(self, value: pulumi.Input['PromptToolInputSchemaPropertiesArgs']):
        pulumi.set(self, "input_schema", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Tool name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class PromptVariantArgsDict(TypedDict):
        """
        Prompt variant
        """
        name: pulumi.Input[_builtins.str]
        """
        Name for a variant.
        """
        template_configuration: pulumi.Input[Union['PromptTemplateConfiguration0PropertiesArgsDict', 'PromptTemplateConfiguration1PropertiesArgsDict']]
        """
        Contains configurations for the prompt template.
        """
        template_type: pulumi.Input['PromptTemplateType']
        """
        The type of prompt template to use.
        """
        additional_model_request_fields: NotRequired[pulumi.Input['PromptAdditionalModelRequestFieldsArgsDict']]
        """
        Contains model-specific inference configurations that aren't in the `inferenceConfiguration` field. To see model-specific inference parameters, see [Inference request parameters and response fields for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html) .
        """
        gen_ai_resource: NotRequired[pulumi.Input['PromptGenAiResourcePropertiesArgsDict']]
        """
        Specifies a generative AI resource with which to use the prompt.
        """
        inference_configuration: NotRequired[pulumi.Input['PromptInferenceConfigurationPropertiesArgsDict']]
        """
        Contains inference configurations for the prompt variant.
        """
        metadata: NotRequired[pulumi.Input[Sequence[pulumi.Input['PromptMetadataEntryArgsDict']]]]
        """
        An array of objects, each containing a key-value pair that defines a metadata tag and value to attach to a prompt variant.
        """
        model_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ARN or Id of a Bedrock Foundational Model or Inference Profile, or the ARN of a imported model, or a provisioned throughput ARN for custom models.
        """
elif False:
    PromptVariantArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PromptVariantArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 template_configuration: pulumi.Input[Union['PromptTemplateConfiguration0PropertiesArgs', 'PromptTemplateConfiguration1PropertiesArgs']],
                 template_type: pulumi.Input['PromptTemplateType'],
                 additional_model_request_fields: Optional[pulumi.Input['PromptAdditionalModelRequestFieldsArgs']] = None,
                 gen_ai_resource: Optional[pulumi.Input['PromptGenAiResourcePropertiesArgs']] = None,
                 inference_configuration: Optional[pulumi.Input['PromptInferenceConfigurationPropertiesArgs']] = None,
                 metadata: Optional[pulumi.Input[Sequence[pulumi.Input['PromptMetadataEntryArgs']]]] = None,
                 model_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Prompt variant
        :param pulumi.Input[_builtins.str] name: Name for a variant.
        :param pulumi.Input[Union['PromptTemplateConfiguration0PropertiesArgs', 'PromptTemplateConfiguration1PropertiesArgs']] template_configuration: Contains configurations for the prompt template.
        :param pulumi.Input['PromptTemplateType'] template_type: The type of prompt template to use.
        :param pulumi.Input['PromptAdditionalModelRequestFieldsArgs'] additional_model_request_fields: Contains model-specific inference configurations that aren't in the `inferenceConfiguration` field. To see model-specific inference parameters, see [Inference request parameters and response fields for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html) .
        :param pulumi.Input['PromptGenAiResourcePropertiesArgs'] gen_ai_resource: Specifies a generative AI resource with which to use the prompt.
        :param pulumi.Input['PromptInferenceConfigurationPropertiesArgs'] inference_configuration: Contains inference configurations for the prompt variant.
        :param pulumi.Input[Sequence[pulumi.Input['PromptMetadataEntryArgs']]] metadata: An array of objects, each containing a key-value pair that defines a metadata tag and value to attach to a prompt variant.
        :param pulumi.Input[_builtins.str] model_id: ARN or Id of a Bedrock Foundational Model or Inference Profile, or the ARN of a imported model, or a provisioned throughput ARN for custom models.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "template_configuration", template_configuration)
        pulumi.set(__self__, "template_type", template_type)
        if additional_model_request_fields is not None:
            pulumi.set(__self__, "additional_model_request_fields", additional_model_request_fields)
        if gen_ai_resource is not None:
            pulumi.set(__self__, "gen_ai_resource", gen_ai_resource)
        if inference_configuration is not None:
            pulumi.set(__self__, "inference_configuration", inference_configuration)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if model_id is not None:
            pulumi.set(__self__, "model_id", model_id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name for a variant.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="templateConfiguration")
    def template_configuration(self) -> pulumi.Input[Union['PromptTemplateConfiguration0PropertiesArgs', 'PromptTemplateConfiguration1PropertiesArgs']]:
        """
        Contains configurations for the prompt template.
        """
        return pulumi.get(self, "template_configuration")

    @template_configuration.setter
    def template_configuration(self, value: pulumi.Input[Union['PromptTemplateConfiguration0PropertiesArgs', 'PromptTemplateConfiguration1PropertiesArgs']]):
        pulumi.set(self, "template_configuration", value)

    @_builtins.property
    @pulumi.getter(name="templateType")
    def template_type(self) -> pulumi.Input['PromptTemplateType']:
        """
        The type of prompt template to use.
        """
        return pulumi.get(self, "template_type")

    @template_type.setter
    def template_type(self, value: pulumi.Input['PromptTemplateType']):
        pulumi.set(self, "template_type", value)

    @_builtins.property
    @pulumi.getter(name="additionalModelRequestFields")
    def additional_model_request_fields(self) -> Optional[pulumi.Input['PromptAdditionalModelRequestFieldsArgs']]:
        """
        Contains model-specific inference configurations that aren't in the `inferenceConfiguration` field. To see model-specific inference parameters, see [Inference request parameters and response fields for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html) .
        """
        return pulumi.get(self, "additional_model_request_fields")

    @additional_model_request_fields.setter
    def additional_model_request_fields(self, value: Optional[pulumi.Input['PromptAdditionalModelRequestFieldsArgs']]):
        pulumi.set(self, "additional_model_request_fields", value)

    @_builtins.property
    @pulumi.getter(name="genAiResource")
    def gen_ai_resource(self) -> Optional[pulumi.Input['PromptGenAiResourcePropertiesArgs']]:
        """
        Specifies a generative AI resource with which to use the prompt.
        """
        return pulumi.get(self, "gen_ai_resource")

    @gen_ai_resource.setter
    def gen_ai_resource(self, value: Optional[pulumi.Input['PromptGenAiResourcePropertiesArgs']]):
        pulumi.set(self, "gen_ai_resource", value)

    @_builtins.property
    @pulumi.getter(name="inferenceConfiguration")
    def inference_configuration(self) -> Optional[pulumi.Input['PromptInferenceConfigurationPropertiesArgs']]:
        """
        Contains inference configurations for the prompt variant.
        """
        return pulumi.get(self, "inference_configuration")

    @inference_configuration.setter
    def inference_configuration(self, value: Optional[pulumi.Input['PromptInferenceConfigurationPropertiesArgs']]):
        pulumi.set(self, "inference_configuration", value)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PromptMetadataEntryArgs']]]]:
        """
        An array of objects, each containing a key-value pair that defines a metadata tag and value to attach to a prompt variant.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PromptMetadataEntryArgs']]]]):
        pulumi.set(self, "metadata", value)

    @_builtins.property
    @pulumi.getter(name="modelId")
    def model_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ARN or Id of a Bedrock Foundational Model or Inference Profile, or the ARN of a imported model, or a provisioned throughput ARN for custom models.
        """
        return pulumi.get(self, "model_id")

    @model_id.setter
    def model_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model_id", value)


