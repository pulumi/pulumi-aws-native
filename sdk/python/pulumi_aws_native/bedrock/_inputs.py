# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from ._enums import *

__all__ = [
    'AgentActionGroupExecutor0PropertiesArgs',
    'AgentActionGroupExecutor1PropertiesArgs',
    'AgentActionGroupArgs',
    'AgentAliasRoutingConfigurationListItemArgs',
    'AgentApiSchema0PropertiesArgs',
    'AgentApiSchema1PropertiesArgs',
    'AgentFunctionSchemaArgs',
    'AgentFunctionArgs',
    'AgentGuardrailConfigurationArgs',
    'AgentInferenceConfigurationArgs',
    'AgentKnowledgeBaseArgs',
    'AgentParameterDetailArgs',
    'AgentPromptConfigurationArgs',
    'AgentPromptOverrideConfigurationArgs',
    'AgentS3IdentifierArgs',
    'DataSourceBedrockFoundationModelConfigurationArgs',
    'DataSourceChunkingConfigurationArgs',
    'DataSourceConfigurationArgs',
    'DataSourceConfluenceCrawlerConfigurationArgs',
    'DataSourceConfluenceDataSourceConfigurationArgs',
    'DataSourceConfluenceSourceConfigurationArgs',
    'DataSourceCrawlFilterConfigurationArgs',
    'DataSourceCustomTransformationConfigurationArgs',
    'DataSourceFixedSizeChunkingConfigurationArgs',
    'DataSourceHierarchicalChunkingConfigurationArgs',
    'DataSourceHierarchicalChunkingLevelConfigurationArgs',
    'DataSourceIntermediateStorageArgs',
    'DataSourceParsingConfigurationArgs',
    'DataSourceParsingPromptArgs',
    'DataSourcePatternObjectFilterConfigurationArgs',
    'DataSourcePatternObjectFilterArgs',
    'DataSourceS3DataSourceConfigurationArgs',
    'DataSourceS3LocationArgs',
    'DataSourceSalesforceCrawlerConfigurationArgs',
    'DataSourceSalesforceDataSourceConfigurationArgs',
    'DataSourceSalesforceSourceConfigurationArgs',
    'DataSourceSeedUrlArgs',
    'DataSourceSemanticChunkingConfigurationArgs',
    'DataSourceServerSideEncryptionConfigurationArgs',
    'DataSourceSharePointCrawlerConfigurationArgs',
    'DataSourceSharePointDataSourceConfigurationArgs',
    'DataSourceSharePointSourceConfigurationArgs',
    'DataSourceTransformationFunctionArgs',
    'DataSourceTransformationLambdaConfigurationArgs',
    'DataSourceTransformationArgs',
    'DataSourceUrlConfigurationArgs',
    'DataSourceVectorIngestionConfigurationArgs',
    'DataSourceWebCrawlerConfigurationArgs',
    'DataSourceWebCrawlerLimitsArgs',
    'DataSourceWebDataSourceConfigurationArgs',
    'DataSourceWebSourceConfigurationArgs',
    'FlowAliasRoutingConfigurationListItemArgs',
    'FlowConditionFlowNodeConfigurationArgs',
    'FlowConditionalConnectionConfigurationArgs',
    'FlowConditionArgs',
    'FlowConnectionConfiguration0PropertiesArgs',
    'FlowConnectionConfiguration1PropertiesArgs',
    'FlowConnectionArgs',
    'FlowDataConnectionConfigurationArgs',
    'FlowDefinitionArgs',
    'FlowInputFlowNodeConfigurationArgs',
    'FlowKnowledgeBaseFlowNodeConfigurationArgs',
    'FlowLambdaFunctionFlowNodeConfigurationArgs',
    'FlowLexFlowNodeConfigurationArgs',
    'FlowNodeConfiguration0PropertiesArgs',
    'FlowNodeConfiguration1PropertiesArgs',
    'FlowNodeConfiguration2PropertiesArgs',
    'FlowNodeConfiguration3PropertiesArgs',
    'FlowNodeConfiguration4PropertiesArgs',
    'FlowNodeConfiguration5PropertiesArgs',
    'FlowNodeConfiguration6PropertiesArgs',
    'FlowNodeInputArgs',
    'FlowNodeOutputArgs',
    'FlowNodeArgs',
    'FlowOutputFlowNodeConfigurationArgs',
    'FlowPromptFlowNodeConfigurationArgs',
    'FlowPromptFlowNodeInlineConfigurationArgs',
    'FlowPromptFlowNodeResourceConfigurationArgs',
    'FlowPromptFlowNodeSourceConfiguration0PropertiesArgs',
    'FlowPromptFlowNodeSourceConfiguration1PropertiesArgs',
    'FlowPromptInferenceConfigurationPropertiesArgs',
    'FlowPromptInputVariableArgs',
    'FlowPromptModelInferenceConfigurationArgs',
    'FlowPromptTemplateConfigurationPropertiesArgs',
    'FlowS3LocationArgs',
    'FlowTextPromptTemplateConfigurationArgs',
    'GuardrailContentFilterConfigArgs',
    'GuardrailContentPolicyConfigArgs',
    'GuardrailContextualGroundingFilterConfigArgs',
    'GuardrailContextualGroundingPolicyConfigArgs',
    'GuardrailManagedWordsConfigArgs',
    'GuardrailPiiEntityConfigArgs',
    'GuardrailRegexConfigArgs',
    'GuardrailSensitiveInformationPolicyConfigArgs',
    'GuardrailTopicConfigArgs',
    'GuardrailTopicPolicyConfigArgs',
    'GuardrailWordConfigArgs',
    'GuardrailWordPolicyConfigArgs',
    'KnowledgeBaseBedrockEmbeddingModelConfigurationArgs',
    'KnowledgeBaseConfigurationArgs',
    'KnowledgeBaseEmbeddingModelConfigurationArgs',
    'KnowledgeBaseMongoDbAtlasConfigurationArgs',
    'KnowledgeBaseMongoDbAtlasFieldMappingArgs',
    'KnowledgeBaseOpenSearchServerlessConfigurationArgs',
    'KnowledgeBaseOpenSearchServerlessFieldMappingArgs',
    'KnowledgeBasePineconeConfigurationArgs',
    'KnowledgeBasePineconeFieldMappingArgs',
    'KnowledgeBaseRdsConfigurationArgs',
    'KnowledgeBaseRdsFieldMappingArgs',
    'KnowledgeBaseStorageConfigurationArgs',
    'KnowledgeBaseVectorKnowledgeBaseConfigurationArgs',
    'PromptInferenceConfigurationPropertiesArgs',
    'PromptInputVariableArgs',
    'PromptModelInferenceConfigurationArgs',
    'PromptTemplateConfigurationPropertiesArgs',
    'PromptTextPromptTemplateConfigurationArgs',
    'PromptTextS3LocationArgs',
    'PromptVariantArgs',
]

@pulumi.input_type
class AgentActionGroupExecutor0PropertiesArgs:
    def __init__(__self__, *,
                 lambda_: pulumi.Input[str]):
        """
        Type of Executors for an Action Group
        :param pulumi.Input[str] lambda_: ARN of a Lambda.
        """
        pulumi.set(__self__, "lambda_", lambda_)

    @property
    @pulumi.getter(name="lambda")
    def lambda_(self) -> pulumi.Input[str]:
        """
        ARN of a Lambda.
        """
        return pulumi.get(self, "lambda_")

    @lambda_.setter
    def lambda_(self, value: pulumi.Input[str]):
        pulumi.set(self, "lambda_", value)


@pulumi.input_type
class AgentActionGroupExecutor1PropertiesArgs:
    def __init__(__self__, *,
                 custom_control: pulumi.Input['AgentCustomControlMethod']):
        """
        Type of Executors for an Action Group
        """
        pulumi.set(__self__, "custom_control", custom_control)

    @property
    @pulumi.getter(name="customControl")
    def custom_control(self) -> pulumi.Input['AgentCustomControlMethod']:
        return pulumi.get(self, "custom_control")

    @custom_control.setter
    def custom_control(self, value: pulumi.Input['AgentCustomControlMethod']):
        pulumi.set(self, "custom_control", value)


@pulumi.input_type
class AgentActionGroupArgs:
    def __init__(__self__, *,
                 action_group_name: pulumi.Input[str],
                 action_group_executor: Optional[pulumi.Input[Union['AgentActionGroupExecutor0PropertiesArgs', 'AgentActionGroupExecutor1PropertiesArgs']]] = None,
                 action_group_state: Optional[pulumi.Input['AgentActionGroupState']] = None,
                 api_schema: Optional[pulumi.Input[Union['AgentApiSchema0PropertiesArgs', 'AgentApiSchema1PropertiesArgs']]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 function_schema: Optional[pulumi.Input['AgentFunctionSchemaArgs']] = None,
                 parent_action_group_signature: Optional[pulumi.Input['AgentActionGroupSignature']] = None,
                 skip_resource_in_use_check_on_delete: Optional[pulumi.Input[bool]] = None):
        """
        Contains the information of an Agent Action Group
        :param pulumi.Input[str] action_group_name: Name of the action group
        :param pulumi.Input[Union['AgentActionGroupExecutor0PropertiesArgs', 'AgentActionGroupExecutor1PropertiesArgs']] action_group_executor: The Amazon Resource Name (ARN) of the Lambda function containing the business logic that is carried out upon invoking the action or the custom control method for handling the information elicited from the user.
        :param pulumi.Input['AgentActionGroupState'] action_group_state: Specifies whether the action group is available for the agent to invoke or not when sending an [InvokeAgent](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html) request.
        :param pulumi.Input[Union['AgentApiSchema0PropertiesArgs', 'AgentApiSchema1PropertiesArgs']] api_schema: Contains either details about the S3 object containing the OpenAPI schema for the action group or the JSON or YAML-formatted payload defining the schema. For more information, see [Action group OpenAPI schemas](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-api-schema.html) .
        :param pulumi.Input[str] description: Description of action group
        :param pulumi.Input['AgentFunctionSchemaArgs'] function_schema: Defines functions that each define parameters that the agent needs to invoke from the user. Each function represents an action in an action group.
        :param pulumi.Input['AgentActionGroupSignature'] parent_action_group_signature: If this field is set as `AMAZON.UserInput` , the agent can request the user for additional information when trying to complete a task. The `description` , `apiSchema` , and `actionGroupExecutor` fields must be blank for this action group.
               
               During orchestration, if the agent determines that it needs to invoke an API in an action group, but doesn't have enough information to complete the API request, it will invoke this action group instead and return an [Observation](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Observation.html) reprompting the user for more information.
        :param pulumi.Input[bool] skip_resource_in_use_check_on_delete: Specifies whether to allow deleting action group while it is in use.
        """
        pulumi.set(__self__, "action_group_name", action_group_name)
        if action_group_executor is not None:
            pulumi.set(__self__, "action_group_executor", action_group_executor)
        if action_group_state is not None:
            pulumi.set(__self__, "action_group_state", action_group_state)
        if api_schema is not None:
            pulumi.set(__self__, "api_schema", api_schema)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if function_schema is not None:
            pulumi.set(__self__, "function_schema", function_schema)
        if parent_action_group_signature is not None:
            pulumi.set(__self__, "parent_action_group_signature", parent_action_group_signature)
        if skip_resource_in_use_check_on_delete is not None:
            pulumi.set(__self__, "skip_resource_in_use_check_on_delete", skip_resource_in_use_check_on_delete)

    @property
    @pulumi.getter(name="actionGroupName")
    def action_group_name(self) -> pulumi.Input[str]:
        """
        Name of the action group
        """
        return pulumi.get(self, "action_group_name")

    @action_group_name.setter
    def action_group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "action_group_name", value)

    @property
    @pulumi.getter(name="actionGroupExecutor")
    def action_group_executor(self) -> Optional[pulumi.Input[Union['AgentActionGroupExecutor0PropertiesArgs', 'AgentActionGroupExecutor1PropertiesArgs']]]:
        """
        The Amazon Resource Name (ARN) of the Lambda function containing the business logic that is carried out upon invoking the action or the custom control method for handling the information elicited from the user.
        """
        return pulumi.get(self, "action_group_executor")

    @action_group_executor.setter
    def action_group_executor(self, value: Optional[pulumi.Input[Union['AgentActionGroupExecutor0PropertiesArgs', 'AgentActionGroupExecutor1PropertiesArgs']]]):
        pulumi.set(self, "action_group_executor", value)

    @property
    @pulumi.getter(name="actionGroupState")
    def action_group_state(self) -> Optional[pulumi.Input['AgentActionGroupState']]:
        """
        Specifies whether the action group is available for the agent to invoke or not when sending an [InvokeAgent](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html) request.
        """
        return pulumi.get(self, "action_group_state")

    @action_group_state.setter
    def action_group_state(self, value: Optional[pulumi.Input['AgentActionGroupState']]):
        pulumi.set(self, "action_group_state", value)

    @property
    @pulumi.getter(name="apiSchema")
    def api_schema(self) -> Optional[pulumi.Input[Union['AgentApiSchema0PropertiesArgs', 'AgentApiSchema1PropertiesArgs']]]:
        """
        Contains either details about the S3 object containing the OpenAPI schema for the action group or the JSON or YAML-formatted payload defining the schema. For more information, see [Action group OpenAPI schemas](https://docs.aws.amazon.com/bedrock/latest/userguide/agents-api-schema.html) .
        """
        return pulumi.get(self, "api_schema")

    @api_schema.setter
    def api_schema(self, value: Optional[pulumi.Input[Union['AgentApiSchema0PropertiesArgs', 'AgentApiSchema1PropertiesArgs']]]):
        pulumi.set(self, "api_schema", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of action group
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="functionSchema")
    def function_schema(self) -> Optional[pulumi.Input['AgentFunctionSchemaArgs']]:
        """
        Defines functions that each define parameters that the agent needs to invoke from the user. Each function represents an action in an action group.
        """
        return pulumi.get(self, "function_schema")

    @function_schema.setter
    def function_schema(self, value: Optional[pulumi.Input['AgentFunctionSchemaArgs']]):
        pulumi.set(self, "function_schema", value)

    @property
    @pulumi.getter(name="parentActionGroupSignature")
    def parent_action_group_signature(self) -> Optional[pulumi.Input['AgentActionGroupSignature']]:
        """
        If this field is set as `AMAZON.UserInput` , the agent can request the user for additional information when trying to complete a task. The `description` , `apiSchema` , and `actionGroupExecutor` fields must be blank for this action group.

        During orchestration, if the agent determines that it needs to invoke an API in an action group, but doesn't have enough information to complete the API request, it will invoke this action group instead and return an [Observation](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Observation.html) reprompting the user for more information.
        """
        return pulumi.get(self, "parent_action_group_signature")

    @parent_action_group_signature.setter
    def parent_action_group_signature(self, value: Optional[pulumi.Input['AgentActionGroupSignature']]):
        pulumi.set(self, "parent_action_group_signature", value)

    @property
    @pulumi.getter(name="skipResourceInUseCheckOnDelete")
    def skip_resource_in_use_check_on_delete(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether to allow deleting action group while it is in use.
        """
        return pulumi.get(self, "skip_resource_in_use_check_on_delete")

    @skip_resource_in_use_check_on_delete.setter
    def skip_resource_in_use_check_on_delete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "skip_resource_in_use_check_on_delete", value)


@pulumi.input_type
class AgentAliasRoutingConfigurationListItemArgs:
    def __init__(__self__, *,
                 agent_version: pulumi.Input[str]):
        """
        Details about the routing configuration for an Agent alias.
        :param pulumi.Input[str] agent_version: Agent Version.
        """
        pulumi.set(__self__, "agent_version", agent_version)

    @property
    @pulumi.getter(name="agentVersion")
    def agent_version(self) -> pulumi.Input[str]:
        """
        Agent Version.
        """
        return pulumi.get(self, "agent_version")

    @agent_version.setter
    def agent_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "agent_version", value)


@pulumi.input_type
class AgentApiSchema0PropertiesArgs:
    def __init__(__self__, *,
                 s3: pulumi.Input['AgentS3IdentifierArgs']):
        """
        Contains information about the API Schema for the Action Group
        """
        pulumi.set(__self__, "s3", s3)

    @property
    @pulumi.getter
    def s3(self) -> pulumi.Input['AgentS3IdentifierArgs']:
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: pulumi.Input['AgentS3IdentifierArgs']):
        pulumi.set(self, "s3", value)


@pulumi.input_type
class AgentApiSchema1PropertiesArgs:
    def __init__(__self__, *,
                 payload: pulumi.Input[str]):
        """
        Contains information about the API Schema for the Action Group
        :param pulumi.Input[str] payload: String OpenAPI Payload
        """
        pulumi.set(__self__, "payload", payload)

    @property
    @pulumi.getter
    def payload(self) -> pulumi.Input[str]:
        """
        String OpenAPI Payload
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: pulumi.Input[str]):
        pulumi.set(self, "payload", value)


@pulumi.input_type
class AgentFunctionSchemaArgs:
    def __init__(__self__, *,
                 functions: pulumi.Input[Sequence[pulumi.Input['AgentFunctionArgs']]]):
        """
        Schema of Functions
        :param pulumi.Input[Sequence[pulumi.Input['AgentFunctionArgs']]] functions: List of Function definitions
        """
        pulumi.set(__self__, "functions", functions)

    @property
    @pulumi.getter
    def functions(self) -> pulumi.Input[Sequence[pulumi.Input['AgentFunctionArgs']]]:
        """
        List of Function definitions
        """
        return pulumi.get(self, "functions")

    @functions.setter
    def functions(self, value: pulumi.Input[Sequence[pulumi.Input['AgentFunctionArgs']]]):
        pulumi.set(self, "functions", value)


@pulumi.input_type
class AgentFunctionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input['AgentParameterDetailArgs']]]] = None):
        """
        Function definition
        :param pulumi.Input[str] name: Name for a resource.
        :param pulumi.Input[str] description: Description of function
        :param pulumi.Input[Mapping[str, pulumi.Input['AgentParameterDetailArgs']]] parameters: The parameters that the agent elicits from the user to fulfill the function.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name for a resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of function
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['AgentParameterDetailArgs']]]]:
        """
        The parameters that the agent elicits from the user to fulfill the function.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['AgentParameterDetailArgs']]]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class AgentGuardrailConfigurationArgs:
    def __init__(__self__, *,
                 guardrail_identifier: Optional[pulumi.Input[str]] = None,
                 guardrail_version: Optional[pulumi.Input[str]] = None):
        """
        Configuration for a guardrail.
        :param pulumi.Input[str] guardrail_identifier: Identifier for the guardrail, could be the id or the arn
        :param pulumi.Input[str] guardrail_version: Version of the guardrail
        """
        if guardrail_identifier is not None:
            pulumi.set(__self__, "guardrail_identifier", guardrail_identifier)
        if guardrail_version is not None:
            pulumi.set(__self__, "guardrail_version", guardrail_version)

    @property
    @pulumi.getter(name="guardrailIdentifier")
    def guardrail_identifier(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier for the guardrail, could be the id or the arn
        """
        return pulumi.get(self, "guardrail_identifier")

    @guardrail_identifier.setter
    def guardrail_identifier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "guardrail_identifier", value)

    @property
    @pulumi.getter(name="guardrailVersion")
    def guardrail_version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of the guardrail
        """
        return pulumi.get(self, "guardrail_version")

    @guardrail_version.setter
    def guardrail_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "guardrail_version", value)


@pulumi.input_type
class AgentInferenceConfigurationArgs:
    def __init__(__self__, *,
                 maximum_length: Optional[pulumi.Input[float]] = None,
                 stop_sequences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 temperature: Optional[pulumi.Input[float]] = None,
                 top_k: Optional[pulumi.Input[float]] = None,
                 top_p: Optional[pulumi.Input[float]] = None):
        """
        Configuration for inference in prompt configuration
        :param pulumi.Input[float] maximum_length: Maximum length of output
        :param pulumi.Input[Sequence[pulumi.Input[str]]] stop_sequences: List of stop sequences
        :param pulumi.Input[float] temperature: Controls randomness, higher values increase diversity
        :param pulumi.Input[float] top_k: Sample from the k most likely next tokens
        :param pulumi.Input[float] top_p: Cumulative probability cutoff for token selection
        """
        if maximum_length is not None:
            pulumi.set(__self__, "maximum_length", maximum_length)
        if stop_sequences is not None:
            pulumi.set(__self__, "stop_sequences", stop_sequences)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)
        if top_k is not None:
            pulumi.set(__self__, "top_k", top_k)
        if top_p is not None:
            pulumi.set(__self__, "top_p", top_p)

    @property
    @pulumi.getter(name="maximumLength")
    def maximum_length(self) -> Optional[pulumi.Input[float]]:
        """
        Maximum length of output
        """
        return pulumi.get(self, "maximum_length")

    @maximum_length.setter
    def maximum_length(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "maximum_length", value)

    @property
    @pulumi.getter(name="stopSequences")
    def stop_sequences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of stop sequences
        """
        return pulumi.get(self, "stop_sequences")

    @stop_sequences.setter
    def stop_sequences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "stop_sequences", value)

    @property
    @pulumi.getter
    def temperature(self) -> Optional[pulumi.Input[float]]:
        """
        Controls randomness, higher values increase diversity
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "temperature", value)

    @property
    @pulumi.getter(name="topK")
    def top_k(self) -> Optional[pulumi.Input[float]]:
        """
        Sample from the k most likely next tokens
        """
        return pulumi.get(self, "top_k")

    @top_k.setter
    def top_k(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "top_k", value)

    @property
    @pulumi.getter(name="topP")
    def top_p(self) -> Optional[pulumi.Input[float]]:
        """
        Cumulative probability cutoff for token selection
        """
        return pulumi.get(self, "top_p")

    @top_p.setter
    def top_p(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "top_p", value)


@pulumi.input_type
class AgentKnowledgeBaseArgs:
    def __init__(__self__, *,
                 description: pulumi.Input[str],
                 knowledge_base_id: pulumi.Input[str],
                 knowledge_base_state: Optional[pulumi.Input['AgentKnowledgeBaseState']] = None):
        """
        Agent Knowledge Base
        :param pulumi.Input[str] description: Description of the Resource.
        :param pulumi.Input[str] knowledge_base_id: Identifier for a resource.
        :param pulumi.Input['AgentKnowledgeBaseState'] knowledge_base_state: Specifies whether to use the knowledge base or not when sending an [InvokeAgent](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html) request.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "knowledge_base_id", knowledge_base_id)
        if knowledge_base_state is not None:
            pulumi.set(__self__, "knowledge_base_state", knowledge_base_state)

    @property
    @pulumi.getter
    def description(self) -> pulumi.Input[str]:
        """
        Description of the Resource.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: pulumi.Input[str]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="knowledgeBaseId")
    def knowledge_base_id(self) -> pulumi.Input[str]:
        """
        Identifier for a resource.
        """
        return pulumi.get(self, "knowledge_base_id")

    @knowledge_base_id.setter
    def knowledge_base_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "knowledge_base_id", value)

    @property
    @pulumi.getter(name="knowledgeBaseState")
    def knowledge_base_state(self) -> Optional[pulumi.Input['AgentKnowledgeBaseState']]:
        """
        Specifies whether to use the knowledge base or not when sending an [InvokeAgent](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html) request.
        """
        return pulumi.get(self, "knowledge_base_state")

    @knowledge_base_state.setter
    def knowledge_base_state(self, value: Optional[pulumi.Input['AgentKnowledgeBaseState']]):
        pulumi.set(self, "knowledge_base_state", value)


@pulumi.input_type
class AgentParameterDetailArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['AgentType'],
                 description: Optional[pulumi.Input[str]] = None,
                 required: Optional[pulumi.Input[bool]] = None):
        """
        Parameter detail
        :param pulumi.Input['AgentType'] type: The data type of the parameter.
        :param pulumi.Input[str] description: Description of function parameter.
        :param pulumi.Input[bool] required: Information about if a parameter is required for function call. Default to false.
        """
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input['AgentType']:
        """
        The data type of the parameter.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['AgentType']):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of function parameter.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[bool]]:
        """
        Information about if a parameter is required for function call. Default to false.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "required", value)


@pulumi.input_type
class AgentPromptConfigurationArgs:
    def __init__(__self__, *,
                 base_prompt_template: Optional[pulumi.Input[str]] = None,
                 inference_configuration: Optional[pulumi.Input['AgentInferenceConfigurationArgs']] = None,
                 parser_mode: Optional[pulumi.Input['AgentCreationMode']] = None,
                 prompt_creation_mode: Optional[pulumi.Input['AgentCreationMode']] = None,
                 prompt_state: Optional[pulumi.Input['AgentPromptState']] = None,
                 prompt_type: Optional[pulumi.Input['AgentPromptType']] = None):
        """
        BasePromptConfiguration per Prompt Type.
        :param pulumi.Input[str] base_prompt_template: Base Prompt Template.
        :param pulumi.Input['AgentInferenceConfigurationArgs'] inference_configuration: Contains inference parameters to use when the agent invokes a foundation model in the part of the agent sequence defined by the `promptType` . For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html) .
        :param pulumi.Input['AgentCreationMode'] parser_mode: Specifies whether to override the default parser Lambda function when parsing the raw foundation model output in the part of the agent sequence defined by the `promptType` . If you set the field as `OVERRIDEN` , the `overrideLambda` field in the [PromptOverrideConfiguration](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PromptOverrideConfiguration.html) must be specified with the ARN of a Lambda function.
        :param pulumi.Input['AgentCreationMode'] prompt_creation_mode: Specifies whether to override the default prompt template for this `promptType` . Set this value to `OVERRIDDEN` to use the prompt that you provide in the `basePromptTemplate` . If you leave it as `DEFAULT` , the agent uses a default prompt template.
        :param pulumi.Input['AgentPromptState'] prompt_state: Specifies whether to allow the agent to carry out the step specified in the `promptType` . If you set this value to `DISABLED` , the agent skips that step. The default state for each `promptType` is as follows.
               
               - `PRE_PROCESSING` – `ENABLED`
               - `ORCHESTRATION` – `ENABLED`
               - `KNOWLEDGE_BASE_RESPONSE_GENERATION` – `ENABLED`
               - `POST_PROCESSING` – `DISABLED`
        :param pulumi.Input['AgentPromptType'] prompt_type: The step in the agent sequence that this prompt configuration applies to.
        """
        if base_prompt_template is not None:
            pulumi.set(__self__, "base_prompt_template", base_prompt_template)
        if inference_configuration is not None:
            pulumi.set(__self__, "inference_configuration", inference_configuration)
        if parser_mode is not None:
            pulumi.set(__self__, "parser_mode", parser_mode)
        if prompt_creation_mode is not None:
            pulumi.set(__self__, "prompt_creation_mode", prompt_creation_mode)
        if prompt_state is not None:
            pulumi.set(__self__, "prompt_state", prompt_state)
        if prompt_type is not None:
            pulumi.set(__self__, "prompt_type", prompt_type)

    @property
    @pulumi.getter(name="basePromptTemplate")
    def base_prompt_template(self) -> Optional[pulumi.Input[str]]:
        """
        Base Prompt Template.
        """
        return pulumi.get(self, "base_prompt_template")

    @base_prompt_template.setter
    def base_prompt_template(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "base_prompt_template", value)

    @property
    @pulumi.getter(name="inferenceConfiguration")
    def inference_configuration(self) -> Optional[pulumi.Input['AgentInferenceConfigurationArgs']]:
        """
        Contains inference parameters to use when the agent invokes a foundation model in the part of the agent sequence defined by the `promptType` . For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html) .
        """
        return pulumi.get(self, "inference_configuration")

    @inference_configuration.setter
    def inference_configuration(self, value: Optional[pulumi.Input['AgentInferenceConfigurationArgs']]):
        pulumi.set(self, "inference_configuration", value)

    @property
    @pulumi.getter(name="parserMode")
    def parser_mode(self) -> Optional[pulumi.Input['AgentCreationMode']]:
        """
        Specifies whether to override the default parser Lambda function when parsing the raw foundation model output in the part of the agent sequence defined by the `promptType` . If you set the field as `OVERRIDEN` , the `overrideLambda` field in the [PromptOverrideConfiguration](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PromptOverrideConfiguration.html) must be specified with the ARN of a Lambda function.
        """
        return pulumi.get(self, "parser_mode")

    @parser_mode.setter
    def parser_mode(self, value: Optional[pulumi.Input['AgentCreationMode']]):
        pulumi.set(self, "parser_mode", value)

    @property
    @pulumi.getter(name="promptCreationMode")
    def prompt_creation_mode(self) -> Optional[pulumi.Input['AgentCreationMode']]:
        """
        Specifies whether to override the default prompt template for this `promptType` . Set this value to `OVERRIDDEN` to use the prompt that you provide in the `basePromptTemplate` . If you leave it as `DEFAULT` , the agent uses a default prompt template.
        """
        return pulumi.get(self, "prompt_creation_mode")

    @prompt_creation_mode.setter
    def prompt_creation_mode(self, value: Optional[pulumi.Input['AgentCreationMode']]):
        pulumi.set(self, "prompt_creation_mode", value)

    @property
    @pulumi.getter(name="promptState")
    def prompt_state(self) -> Optional[pulumi.Input['AgentPromptState']]:
        """
        Specifies whether to allow the agent to carry out the step specified in the `promptType` . If you set this value to `DISABLED` , the agent skips that step. The default state for each `promptType` is as follows.

        - `PRE_PROCESSING` – `ENABLED`
        - `ORCHESTRATION` – `ENABLED`
        - `KNOWLEDGE_BASE_RESPONSE_GENERATION` – `ENABLED`
        - `POST_PROCESSING` – `DISABLED`
        """
        return pulumi.get(self, "prompt_state")

    @prompt_state.setter
    def prompt_state(self, value: Optional[pulumi.Input['AgentPromptState']]):
        pulumi.set(self, "prompt_state", value)

    @property
    @pulumi.getter(name="promptType")
    def prompt_type(self) -> Optional[pulumi.Input['AgentPromptType']]:
        """
        The step in the agent sequence that this prompt configuration applies to.
        """
        return pulumi.get(self, "prompt_type")

    @prompt_type.setter
    def prompt_type(self, value: Optional[pulumi.Input['AgentPromptType']]):
        pulumi.set(self, "prompt_type", value)


@pulumi.input_type
class AgentPromptOverrideConfigurationArgs:
    def __init__(__self__, *,
                 prompt_configurations: pulumi.Input[Sequence[pulumi.Input['AgentPromptConfigurationArgs']]],
                 override_lambda: Optional[pulumi.Input[str]] = None):
        """
        Configuration for prompt override.
        :param pulumi.Input[Sequence[pulumi.Input['AgentPromptConfigurationArgs']]] prompt_configurations: List of BasePromptConfiguration
        :param pulumi.Input[str] override_lambda: ARN of a Lambda.
        """
        pulumi.set(__self__, "prompt_configurations", prompt_configurations)
        if override_lambda is not None:
            pulumi.set(__self__, "override_lambda", override_lambda)

    @property
    @pulumi.getter(name="promptConfigurations")
    def prompt_configurations(self) -> pulumi.Input[Sequence[pulumi.Input['AgentPromptConfigurationArgs']]]:
        """
        List of BasePromptConfiguration
        """
        return pulumi.get(self, "prompt_configurations")

    @prompt_configurations.setter
    def prompt_configurations(self, value: pulumi.Input[Sequence[pulumi.Input['AgentPromptConfigurationArgs']]]):
        pulumi.set(self, "prompt_configurations", value)

    @property
    @pulumi.getter(name="overrideLambda")
    def override_lambda(self) -> Optional[pulumi.Input[str]]:
        """
        ARN of a Lambda.
        """
        return pulumi.get(self, "override_lambda")

    @override_lambda.setter
    def override_lambda(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "override_lambda", value)


@pulumi.input_type
class AgentS3IdentifierArgs:
    def __init__(__self__, *,
                 s3_bucket_name: Optional[pulumi.Input[str]] = None,
                 s3_object_key: Optional[pulumi.Input[str]] = None):
        """
        The identifier for the S3 resource.
        :param pulumi.Input[str] s3_bucket_name: A bucket in S3.
        :param pulumi.Input[str] s3_object_key: A object key in S3.
        """
        if s3_bucket_name is not None:
            pulumi.set(__self__, "s3_bucket_name", s3_bucket_name)
        if s3_object_key is not None:
            pulumi.set(__self__, "s3_object_key", s3_object_key)

    @property
    @pulumi.getter(name="s3BucketName")
    def s3_bucket_name(self) -> Optional[pulumi.Input[str]]:
        """
        A bucket in S3.
        """
        return pulumi.get(self, "s3_bucket_name")

    @s3_bucket_name.setter
    def s3_bucket_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_bucket_name", value)

    @property
    @pulumi.getter(name="s3ObjectKey")
    def s3_object_key(self) -> Optional[pulumi.Input[str]]:
        """
        A object key in S3.
        """
        return pulumi.get(self, "s3_object_key")

    @s3_object_key.setter
    def s3_object_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s3_object_key", value)


@pulumi.input_type
class DataSourceBedrockFoundationModelConfigurationArgs:
    def __init__(__self__, *,
                 model_arn: pulumi.Input[str],
                 parsing_prompt: Optional[pulumi.Input['DataSourceParsingPromptArgs']] = None):
        """
        Settings for a foundation model used to parse documents for a data source.
        :param pulumi.Input[str] model_arn: The model's ARN.
        :param pulumi.Input['DataSourceParsingPromptArgs'] parsing_prompt: Instructions for interpreting the contents of a document.
        """
        pulumi.set(__self__, "model_arn", model_arn)
        if parsing_prompt is not None:
            pulumi.set(__self__, "parsing_prompt", parsing_prompt)

    @property
    @pulumi.getter(name="modelArn")
    def model_arn(self) -> pulumi.Input[str]:
        """
        The model's ARN.
        """
        return pulumi.get(self, "model_arn")

    @model_arn.setter
    def model_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "model_arn", value)

    @property
    @pulumi.getter(name="parsingPrompt")
    def parsing_prompt(self) -> Optional[pulumi.Input['DataSourceParsingPromptArgs']]:
        """
        Instructions for interpreting the contents of a document.
        """
        return pulumi.get(self, "parsing_prompt")

    @parsing_prompt.setter
    def parsing_prompt(self, value: Optional[pulumi.Input['DataSourceParsingPromptArgs']]):
        pulumi.set(self, "parsing_prompt", value)


@pulumi.input_type
class DataSourceChunkingConfigurationArgs:
    def __init__(__self__, *,
                 chunking_strategy: pulumi.Input['DataSourceChunkingStrategy'],
                 fixed_size_chunking_configuration: Optional[pulumi.Input['DataSourceFixedSizeChunkingConfigurationArgs']] = None,
                 hierarchical_chunking_configuration: Optional[pulumi.Input['DataSourceHierarchicalChunkingConfigurationArgs']] = None,
                 semantic_chunking_configuration: Optional[pulumi.Input['DataSourceSemanticChunkingConfigurationArgs']] = None):
        """
        Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried.
        :param pulumi.Input['DataSourceChunkingStrategy'] chunking_strategy: Knowledge base can split your source data into chunks. A *chunk* refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried. You have the following options for chunking your data. If you opt for `NONE` , then you may want to pre-process your files by splitting them up such that each file corresponds to a chunk.
               
               - `FIXED_SIZE` – Amazon Bedrock splits your source data into chunks of the approximate size that you set in the `fixedSizeChunkingConfiguration` .
               - `HIERARCHICAL` – Split documents into layers of chunks where the first layer contains large chunks, and the second layer contains smaller chunks derived from the first layer.
               - `SEMANTIC` – Split documents into chunks based on groups of similar content derived with natural language processing.
               - `NONE` – Amazon Bedrock treats each file as one chunk. If you choose this option, you may want to pre-process your documents by splitting them into separate files.
        :param pulumi.Input['DataSourceFixedSizeChunkingConfigurationArgs'] fixed_size_chunking_configuration: Configurations for when you choose fixed-size chunking. If you set the `chunkingStrategy` as `NONE` , exclude this field.
        :param pulumi.Input['DataSourceHierarchicalChunkingConfigurationArgs'] hierarchical_chunking_configuration: Settings for hierarchical document chunking for a data source. Hierarchical chunking splits documents into layers of chunks where the first layer contains large chunks, and the second layer contains smaller chunks derived from the first layer.
        :param pulumi.Input['DataSourceSemanticChunkingConfigurationArgs'] semantic_chunking_configuration: Settings for semantic document chunking for a data source. Semantic chunking splits a document into into smaller documents based on groups of similar content derived from the text with natural language processing.
        """
        pulumi.set(__self__, "chunking_strategy", chunking_strategy)
        if fixed_size_chunking_configuration is not None:
            pulumi.set(__self__, "fixed_size_chunking_configuration", fixed_size_chunking_configuration)
        if hierarchical_chunking_configuration is not None:
            pulumi.set(__self__, "hierarchical_chunking_configuration", hierarchical_chunking_configuration)
        if semantic_chunking_configuration is not None:
            pulumi.set(__self__, "semantic_chunking_configuration", semantic_chunking_configuration)

    @property
    @pulumi.getter(name="chunkingStrategy")
    def chunking_strategy(self) -> pulumi.Input['DataSourceChunkingStrategy']:
        """
        Knowledge base can split your source data into chunks. A *chunk* refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried. You have the following options for chunking your data. If you opt for `NONE` , then you may want to pre-process your files by splitting them up such that each file corresponds to a chunk.

        - `FIXED_SIZE` – Amazon Bedrock splits your source data into chunks of the approximate size that you set in the `fixedSizeChunkingConfiguration` .
        - `HIERARCHICAL` – Split documents into layers of chunks where the first layer contains large chunks, and the second layer contains smaller chunks derived from the first layer.
        - `SEMANTIC` – Split documents into chunks based on groups of similar content derived with natural language processing.
        - `NONE` – Amazon Bedrock treats each file as one chunk. If you choose this option, you may want to pre-process your documents by splitting them into separate files.
        """
        return pulumi.get(self, "chunking_strategy")

    @chunking_strategy.setter
    def chunking_strategy(self, value: pulumi.Input['DataSourceChunkingStrategy']):
        pulumi.set(self, "chunking_strategy", value)

    @property
    @pulumi.getter(name="fixedSizeChunkingConfiguration")
    def fixed_size_chunking_configuration(self) -> Optional[pulumi.Input['DataSourceFixedSizeChunkingConfigurationArgs']]:
        """
        Configurations for when you choose fixed-size chunking. If you set the `chunkingStrategy` as `NONE` , exclude this field.
        """
        return pulumi.get(self, "fixed_size_chunking_configuration")

    @fixed_size_chunking_configuration.setter
    def fixed_size_chunking_configuration(self, value: Optional[pulumi.Input['DataSourceFixedSizeChunkingConfigurationArgs']]):
        pulumi.set(self, "fixed_size_chunking_configuration", value)

    @property
    @pulumi.getter(name="hierarchicalChunkingConfiguration")
    def hierarchical_chunking_configuration(self) -> Optional[pulumi.Input['DataSourceHierarchicalChunkingConfigurationArgs']]:
        """
        Settings for hierarchical document chunking for a data source. Hierarchical chunking splits documents into layers of chunks where the first layer contains large chunks, and the second layer contains smaller chunks derived from the first layer.
        """
        return pulumi.get(self, "hierarchical_chunking_configuration")

    @hierarchical_chunking_configuration.setter
    def hierarchical_chunking_configuration(self, value: Optional[pulumi.Input['DataSourceHierarchicalChunkingConfigurationArgs']]):
        pulumi.set(self, "hierarchical_chunking_configuration", value)

    @property
    @pulumi.getter(name="semanticChunkingConfiguration")
    def semantic_chunking_configuration(self) -> Optional[pulumi.Input['DataSourceSemanticChunkingConfigurationArgs']]:
        """
        Settings for semantic document chunking for a data source. Semantic chunking splits a document into into smaller documents based on groups of similar content derived from the text with natural language processing.
        """
        return pulumi.get(self, "semantic_chunking_configuration")

    @semantic_chunking_configuration.setter
    def semantic_chunking_configuration(self, value: Optional[pulumi.Input['DataSourceSemanticChunkingConfigurationArgs']]):
        pulumi.set(self, "semantic_chunking_configuration", value)


@pulumi.input_type
class DataSourceConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['DataSourceType'],
                 confluence_configuration: Optional[pulumi.Input['DataSourceConfluenceDataSourceConfigurationArgs']] = None,
                 s3_configuration: Optional[pulumi.Input['DataSourceS3DataSourceConfigurationArgs']] = None,
                 salesforce_configuration: Optional[pulumi.Input['DataSourceSalesforceDataSourceConfigurationArgs']] = None,
                 share_point_configuration: Optional[pulumi.Input['DataSourceSharePointDataSourceConfigurationArgs']] = None,
                 web_configuration: Optional[pulumi.Input['DataSourceWebDataSourceConfigurationArgs']] = None):
        """
        Specifies a raw data source location to ingest.
        :param pulumi.Input['DataSourceType'] type: The type of data source.
        :param pulumi.Input['DataSourceConfluenceDataSourceConfigurationArgs'] confluence_configuration: The configuration information to connect to Confluence as your data source.
               
               > Confluence data source connector is in preview release and is subject to change.
        :param pulumi.Input['DataSourceS3DataSourceConfigurationArgs'] s3_configuration: The configuration information to connect to Amazon S3 as your data source.
        :param pulumi.Input['DataSourceSalesforceDataSourceConfigurationArgs'] salesforce_configuration: The configuration information to connect to Salesforce as your data source.
               
               > Salesforce data source connector is in preview release and is subject to change.
        :param pulumi.Input['DataSourceSharePointDataSourceConfigurationArgs'] share_point_configuration: The configuration information to connect to SharePoint as your data source.
               
               > SharePoint data source connector is in preview release and is subject to change.
        :param pulumi.Input['DataSourceWebDataSourceConfigurationArgs'] web_configuration: The configuration of web URLs to crawl for your data source. You should be authorized to crawl the URLs.
               
               > Crawling web URLs as your data source is in preview release and is subject to change.
        """
        pulumi.set(__self__, "type", type)
        if confluence_configuration is not None:
            pulumi.set(__self__, "confluence_configuration", confluence_configuration)
        if s3_configuration is not None:
            pulumi.set(__self__, "s3_configuration", s3_configuration)
        if salesforce_configuration is not None:
            pulumi.set(__self__, "salesforce_configuration", salesforce_configuration)
        if share_point_configuration is not None:
            pulumi.set(__self__, "share_point_configuration", share_point_configuration)
        if web_configuration is not None:
            pulumi.set(__self__, "web_configuration", web_configuration)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input['DataSourceType']:
        """
        The type of data source.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['DataSourceType']):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="confluenceConfiguration")
    def confluence_configuration(self) -> Optional[pulumi.Input['DataSourceConfluenceDataSourceConfigurationArgs']]:
        """
        The configuration information to connect to Confluence as your data source.

        > Confluence data source connector is in preview release and is subject to change.
        """
        return pulumi.get(self, "confluence_configuration")

    @confluence_configuration.setter
    def confluence_configuration(self, value: Optional[pulumi.Input['DataSourceConfluenceDataSourceConfigurationArgs']]):
        pulumi.set(self, "confluence_configuration", value)

    @property
    @pulumi.getter(name="s3Configuration")
    def s3_configuration(self) -> Optional[pulumi.Input['DataSourceS3DataSourceConfigurationArgs']]:
        """
        The configuration information to connect to Amazon S3 as your data source.
        """
        return pulumi.get(self, "s3_configuration")

    @s3_configuration.setter
    def s3_configuration(self, value: Optional[pulumi.Input['DataSourceS3DataSourceConfigurationArgs']]):
        pulumi.set(self, "s3_configuration", value)

    @property
    @pulumi.getter(name="salesforceConfiguration")
    def salesforce_configuration(self) -> Optional[pulumi.Input['DataSourceSalesforceDataSourceConfigurationArgs']]:
        """
        The configuration information to connect to Salesforce as your data source.

        > Salesforce data source connector is in preview release and is subject to change.
        """
        return pulumi.get(self, "salesforce_configuration")

    @salesforce_configuration.setter
    def salesforce_configuration(self, value: Optional[pulumi.Input['DataSourceSalesforceDataSourceConfigurationArgs']]):
        pulumi.set(self, "salesforce_configuration", value)

    @property
    @pulumi.getter(name="sharePointConfiguration")
    def share_point_configuration(self) -> Optional[pulumi.Input['DataSourceSharePointDataSourceConfigurationArgs']]:
        """
        The configuration information to connect to SharePoint as your data source.

        > SharePoint data source connector is in preview release and is subject to change.
        """
        return pulumi.get(self, "share_point_configuration")

    @share_point_configuration.setter
    def share_point_configuration(self, value: Optional[pulumi.Input['DataSourceSharePointDataSourceConfigurationArgs']]):
        pulumi.set(self, "share_point_configuration", value)

    @property
    @pulumi.getter(name="webConfiguration")
    def web_configuration(self) -> Optional[pulumi.Input['DataSourceWebDataSourceConfigurationArgs']]:
        """
        The configuration of web URLs to crawl for your data source. You should be authorized to crawl the URLs.

        > Crawling web URLs as your data source is in preview release and is subject to change.
        """
        return pulumi.get(self, "web_configuration")

    @web_configuration.setter
    def web_configuration(self, value: Optional[pulumi.Input['DataSourceWebDataSourceConfigurationArgs']]):
        pulumi.set(self, "web_configuration", value)


@pulumi.input_type
class DataSourceConfluenceCrawlerConfigurationArgs:
    def __init__(__self__, *,
                 filter_configuration: Optional[pulumi.Input['DataSourceCrawlFilterConfigurationArgs']] = None):
        """
        The configuration of the Confluence content. For example, configuring specific types of Confluence content.
        :param pulumi.Input['DataSourceCrawlFilterConfigurationArgs'] filter_configuration: The configuration of filtering the Confluence content. For example, configuring regular expression patterns to include or exclude certain content.
        """
        if filter_configuration is not None:
            pulumi.set(__self__, "filter_configuration", filter_configuration)

    @property
    @pulumi.getter(name="filterConfiguration")
    def filter_configuration(self) -> Optional[pulumi.Input['DataSourceCrawlFilterConfigurationArgs']]:
        """
        The configuration of filtering the Confluence content. For example, configuring regular expression patterns to include or exclude certain content.
        """
        return pulumi.get(self, "filter_configuration")

    @filter_configuration.setter
    def filter_configuration(self, value: Optional[pulumi.Input['DataSourceCrawlFilterConfigurationArgs']]):
        pulumi.set(self, "filter_configuration", value)


@pulumi.input_type
class DataSourceConfluenceDataSourceConfigurationArgs:
    def __init__(__self__, *,
                 source_configuration: pulumi.Input['DataSourceConfluenceSourceConfigurationArgs'],
                 crawler_configuration: Optional[pulumi.Input['DataSourceConfluenceCrawlerConfigurationArgs']] = None):
        """
        The configuration information to connect to Confluence as your data source.
        :param pulumi.Input['DataSourceConfluenceSourceConfigurationArgs'] source_configuration: The endpoint information to connect to your Confluence data source.
        :param pulumi.Input['DataSourceConfluenceCrawlerConfigurationArgs'] crawler_configuration: The configuration of the Confluence content. For example, configuring specific types of Confluence content.
        """
        pulumi.set(__self__, "source_configuration", source_configuration)
        if crawler_configuration is not None:
            pulumi.set(__self__, "crawler_configuration", crawler_configuration)

    @property
    @pulumi.getter(name="sourceConfiguration")
    def source_configuration(self) -> pulumi.Input['DataSourceConfluenceSourceConfigurationArgs']:
        """
        The endpoint information to connect to your Confluence data source.
        """
        return pulumi.get(self, "source_configuration")

    @source_configuration.setter
    def source_configuration(self, value: pulumi.Input['DataSourceConfluenceSourceConfigurationArgs']):
        pulumi.set(self, "source_configuration", value)

    @property
    @pulumi.getter(name="crawlerConfiguration")
    def crawler_configuration(self) -> Optional[pulumi.Input['DataSourceConfluenceCrawlerConfigurationArgs']]:
        """
        The configuration of the Confluence content. For example, configuring specific types of Confluence content.
        """
        return pulumi.get(self, "crawler_configuration")

    @crawler_configuration.setter
    def crawler_configuration(self, value: Optional[pulumi.Input['DataSourceConfluenceCrawlerConfigurationArgs']]):
        pulumi.set(self, "crawler_configuration", value)


@pulumi.input_type
class DataSourceConfluenceSourceConfigurationArgs:
    def __init__(__self__, *,
                 auth_type: pulumi.Input['DataSourceConfluenceSourceConfigurationAuthType'],
                 credentials_secret_arn: pulumi.Input[str],
                 host_type: pulumi.Input['DataSourceConfluenceSourceConfigurationHostType'],
                 host_url: pulumi.Input[str]):
        """
        The endpoint information to connect to your Confluence data source.
        :param pulumi.Input['DataSourceConfluenceSourceConfigurationAuthType'] auth_type: The supported authentication type to authenticate and connect to your Confluence instance.
        :param pulumi.Input[str] credentials_secret_arn: The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your Confluence instance URL. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see Confluence connection configuration.
        :param pulumi.Input['DataSourceConfluenceSourceConfigurationHostType'] host_type: The supported host type, whether online/cloud or server/on-premises.
        :param pulumi.Input[str] host_url: The Confluence host URL or instance URL.
        """
        pulumi.set(__self__, "auth_type", auth_type)
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "host_type", host_type)
        pulumi.set(__self__, "host_url", host_url)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> pulumi.Input['DataSourceConfluenceSourceConfigurationAuthType']:
        """
        The supported authentication type to authenticate and connect to your Confluence instance.
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: pulumi.Input['DataSourceConfluenceSourceConfigurationAuthType']):
        pulumi.set(self, "auth_type", value)

    @property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your Confluence instance URL. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see Confluence connection configuration.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @credentials_secret_arn.setter
    def credentials_secret_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "credentials_secret_arn", value)

    @property
    @pulumi.getter(name="hostType")
    def host_type(self) -> pulumi.Input['DataSourceConfluenceSourceConfigurationHostType']:
        """
        The supported host type, whether online/cloud or server/on-premises.
        """
        return pulumi.get(self, "host_type")

    @host_type.setter
    def host_type(self, value: pulumi.Input['DataSourceConfluenceSourceConfigurationHostType']):
        pulumi.set(self, "host_type", value)

    @property
    @pulumi.getter(name="hostUrl")
    def host_url(self) -> pulumi.Input[str]:
        """
        The Confluence host URL or instance URL.
        """
        return pulumi.get(self, "host_url")

    @host_url.setter
    def host_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "host_url", value)


@pulumi.input_type
class DataSourceCrawlFilterConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['DataSourceCrawlFilterConfigurationType'],
                 pattern_object_filter: Optional[pulumi.Input['DataSourcePatternObjectFilterConfigurationArgs']] = None):
        """
        The type of filtering that you want to apply to certain objects or content of the data source. For example, the PATTERN type is regular expression patterns you can apply to filter your content.
        :param pulumi.Input['DataSourceCrawlFilterConfigurationType'] type: The crawl filter type.
        :param pulumi.Input['DataSourcePatternObjectFilterConfigurationArgs'] pattern_object_filter: The configuration of filtering certain objects or content types of the data source.
        """
        pulumi.set(__self__, "type", type)
        if pattern_object_filter is not None:
            pulumi.set(__self__, "pattern_object_filter", pattern_object_filter)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input['DataSourceCrawlFilterConfigurationType']:
        """
        The crawl filter type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['DataSourceCrawlFilterConfigurationType']):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="patternObjectFilter")
    def pattern_object_filter(self) -> Optional[pulumi.Input['DataSourcePatternObjectFilterConfigurationArgs']]:
        """
        The configuration of filtering certain objects or content types of the data source.
        """
        return pulumi.get(self, "pattern_object_filter")

    @pattern_object_filter.setter
    def pattern_object_filter(self, value: Optional[pulumi.Input['DataSourcePatternObjectFilterConfigurationArgs']]):
        pulumi.set(self, "pattern_object_filter", value)


@pulumi.input_type
class DataSourceCustomTransformationConfigurationArgs:
    def __init__(__self__, *,
                 intermediate_storage: pulumi.Input['DataSourceIntermediateStorageArgs'],
                 transformations: pulumi.Input[Sequence[pulumi.Input['DataSourceTransformationArgs']]]):
        """
        Settings for customizing steps in the data source content ingestion pipeline.
        :param pulumi.Input['DataSourceIntermediateStorageArgs'] intermediate_storage: An S3 bucket path for input and output objects.
        :param pulumi.Input[Sequence[pulumi.Input['DataSourceTransformationArgs']]] transformations: A list of Lambda functions that process documents.
        """
        pulumi.set(__self__, "intermediate_storage", intermediate_storage)
        pulumi.set(__self__, "transformations", transformations)

    @property
    @pulumi.getter(name="intermediateStorage")
    def intermediate_storage(self) -> pulumi.Input['DataSourceIntermediateStorageArgs']:
        """
        An S3 bucket path for input and output objects.
        """
        return pulumi.get(self, "intermediate_storage")

    @intermediate_storage.setter
    def intermediate_storage(self, value: pulumi.Input['DataSourceIntermediateStorageArgs']):
        pulumi.set(self, "intermediate_storage", value)

    @property
    @pulumi.getter
    def transformations(self) -> pulumi.Input[Sequence[pulumi.Input['DataSourceTransformationArgs']]]:
        """
        A list of Lambda functions that process documents.
        """
        return pulumi.get(self, "transformations")

    @transformations.setter
    def transformations(self, value: pulumi.Input[Sequence[pulumi.Input['DataSourceTransformationArgs']]]):
        pulumi.set(self, "transformations", value)


@pulumi.input_type
class DataSourceFixedSizeChunkingConfigurationArgs:
    def __init__(__self__, *,
                 max_tokens: pulumi.Input[int],
                 overlap_percentage: pulumi.Input[int]):
        """
        Configurations for when you choose fixed-size chunking. If you set the chunkingStrategy as NONE, exclude this field.
        :param pulumi.Input[int] max_tokens: The maximum number of tokens to include in a chunk.
        :param pulumi.Input[int] overlap_percentage: The percentage of overlap between adjacent chunks of a data source.
        """
        pulumi.set(__self__, "max_tokens", max_tokens)
        pulumi.set(__self__, "overlap_percentage", overlap_percentage)

    @property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> pulumi.Input[int]:
        """
        The maximum number of tokens to include in a chunk.
        """
        return pulumi.get(self, "max_tokens")

    @max_tokens.setter
    def max_tokens(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_tokens", value)

    @property
    @pulumi.getter(name="overlapPercentage")
    def overlap_percentage(self) -> pulumi.Input[int]:
        """
        The percentage of overlap between adjacent chunks of a data source.
        """
        return pulumi.get(self, "overlap_percentage")

    @overlap_percentage.setter
    def overlap_percentage(self, value: pulumi.Input[int]):
        pulumi.set(self, "overlap_percentage", value)


@pulumi.input_type
class DataSourceHierarchicalChunkingConfigurationArgs:
    def __init__(__self__, *,
                 level_configurations: pulumi.Input[Sequence[pulumi.Input['DataSourceHierarchicalChunkingLevelConfigurationArgs']]],
                 overlap_tokens: pulumi.Input[int]):
        """
        Configurations for when you choose hierarchical chunking. If you set the chunkingStrategy as NONE, exclude this field.
        :param pulumi.Input[Sequence[pulumi.Input['DataSourceHierarchicalChunkingLevelConfigurationArgs']]] level_configurations: Token settings for each layer.
        :param pulumi.Input[int] overlap_tokens: The number of tokens to repeat across chunks in the same layer.
        """
        pulumi.set(__self__, "level_configurations", level_configurations)
        pulumi.set(__self__, "overlap_tokens", overlap_tokens)

    @property
    @pulumi.getter(name="levelConfigurations")
    def level_configurations(self) -> pulumi.Input[Sequence[pulumi.Input['DataSourceHierarchicalChunkingLevelConfigurationArgs']]]:
        """
        Token settings for each layer.
        """
        return pulumi.get(self, "level_configurations")

    @level_configurations.setter
    def level_configurations(self, value: pulumi.Input[Sequence[pulumi.Input['DataSourceHierarchicalChunkingLevelConfigurationArgs']]]):
        pulumi.set(self, "level_configurations", value)

    @property
    @pulumi.getter(name="overlapTokens")
    def overlap_tokens(self) -> pulumi.Input[int]:
        """
        The number of tokens to repeat across chunks in the same layer.
        """
        return pulumi.get(self, "overlap_tokens")

    @overlap_tokens.setter
    def overlap_tokens(self, value: pulumi.Input[int]):
        pulumi.set(self, "overlap_tokens", value)


@pulumi.input_type
class DataSourceHierarchicalChunkingLevelConfigurationArgs:
    def __init__(__self__, *,
                 max_tokens: pulumi.Input[int]):
        """
        Token settings for a layer in a hierarchical chunking configuration.
        :param pulumi.Input[int] max_tokens: The maximum number of tokens that a chunk can contain in this layer.
        """
        pulumi.set(__self__, "max_tokens", max_tokens)

    @property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> pulumi.Input[int]:
        """
        The maximum number of tokens that a chunk can contain in this layer.
        """
        return pulumi.get(self, "max_tokens")

    @max_tokens.setter
    def max_tokens(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_tokens", value)


@pulumi.input_type
class DataSourceIntermediateStorageArgs:
    def __init__(__self__, *,
                 s3_location: pulumi.Input['DataSourceS3LocationArgs']):
        """
        A location for storing content from data sources temporarily as it is processed by custom components in the ingestion pipeline.
        :param pulumi.Input['DataSourceS3LocationArgs'] s3_location: An S3 bucket path.
        """
        pulumi.set(__self__, "s3_location", s3_location)

    @property
    @pulumi.getter(name="s3Location")
    def s3_location(self) -> pulumi.Input['DataSourceS3LocationArgs']:
        """
        An S3 bucket path.
        """
        return pulumi.get(self, "s3_location")

    @s3_location.setter
    def s3_location(self, value: pulumi.Input['DataSourceS3LocationArgs']):
        pulumi.set(self, "s3_location", value)


@pulumi.input_type
class DataSourceParsingConfigurationArgs:
    def __init__(__self__, *,
                 parsing_strategy: pulumi.Input['DataSourceParsingStrategy'],
                 bedrock_foundation_model_configuration: Optional[pulumi.Input['DataSourceBedrockFoundationModelConfigurationArgs']] = None):
        """
        Settings for parsing document contents
        :param pulumi.Input['DataSourceParsingStrategy'] parsing_strategy: The parsing strategy for the data source.
        :param pulumi.Input['DataSourceBedrockFoundationModelConfigurationArgs'] bedrock_foundation_model_configuration: Settings for a foundation model used to parse documents for a data source.
        """
        pulumi.set(__self__, "parsing_strategy", parsing_strategy)
        if bedrock_foundation_model_configuration is not None:
            pulumi.set(__self__, "bedrock_foundation_model_configuration", bedrock_foundation_model_configuration)

    @property
    @pulumi.getter(name="parsingStrategy")
    def parsing_strategy(self) -> pulumi.Input['DataSourceParsingStrategy']:
        """
        The parsing strategy for the data source.
        """
        return pulumi.get(self, "parsing_strategy")

    @parsing_strategy.setter
    def parsing_strategy(self, value: pulumi.Input['DataSourceParsingStrategy']):
        pulumi.set(self, "parsing_strategy", value)

    @property
    @pulumi.getter(name="bedrockFoundationModelConfiguration")
    def bedrock_foundation_model_configuration(self) -> Optional[pulumi.Input['DataSourceBedrockFoundationModelConfigurationArgs']]:
        """
        Settings for a foundation model used to parse documents for a data source.
        """
        return pulumi.get(self, "bedrock_foundation_model_configuration")

    @bedrock_foundation_model_configuration.setter
    def bedrock_foundation_model_configuration(self, value: Optional[pulumi.Input['DataSourceBedrockFoundationModelConfigurationArgs']]):
        pulumi.set(self, "bedrock_foundation_model_configuration", value)


@pulumi.input_type
class DataSourceParsingPromptArgs:
    def __init__(__self__, *,
                 parsing_prompt_text: pulumi.Input[str]):
        """
        Instructions for interpreting the contents of a document.
        :param pulumi.Input[str] parsing_prompt_text: Instructions for interpreting the contents of a document.
        """
        pulumi.set(__self__, "parsing_prompt_text", parsing_prompt_text)

    @property
    @pulumi.getter(name="parsingPromptText")
    def parsing_prompt_text(self) -> pulumi.Input[str]:
        """
        Instructions for interpreting the contents of a document.
        """
        return pulumi.get(self, "parsing_prompt_text")

    @parsing_prompt_text.setter
    def parsing_prompt_text(self, value: pulumi.Input[str]):
        pulumi.set(self, "parsing_prompt_text", value)


@pulumi.input_type
class DataSourcePatternObjectFilterConfigurationArgs:
    def __init__(__self__, *,
                 filters: pulumi.Input[Sequence[pulumi.Input['DataSourcePatternObjectFilterArgs']]]):
        """
        The configuration of specific filters applied to your data source content. You can filter out or include certain content.
        :param pulumi.Input[Sequence[pulumi.Input['DataSourcePatternObjectFilterArgs']]] filters: The configuration of specific filters applied to your data source content. You can filter out or include certain content.
        """
        pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def filters(self) -> pulumi.Input[Sequence[pulumi.Input['DataSourcePatternObjectFilterArgs']]]:
        """
        The configuration of specific filters applied to your data source content. You can filter out or include certain content.
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: pulumi.Input[Sequence[pulumi.Input['DataSourcePatternObjectFilterArgs']]]):
        pulumi.set(self, "filters", value)


@pulumi.input_type
class DataSourcePatternObjectFilterArgs:
    def __init__(__self__, *,
                 object_type: pulumi.Input[str],
                 exclusion_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 inclusion_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The specific filters applied to your data source content. You can filter out or include certain content.
        :param pulumi.Input[str] object_type: The supported object type or content type of the data source.
        """
        pulumi.set(__self__, "object_type", object_type)
        if exclusion_filters is not None:
            pulumi.set(__self__, "exclusion_filters", exclusion_filters)
        if inclusion_filters is not None:
            pulumi.set(__self__, "inclusion_filters", inclusion_filters)

    @property
    @pulumi.getter(name="objectType")
    def object_type(self) -> pulumi.Input[str]:
        """
        The supported object type or content type of the data source.
        """
        return pulumi.get(self, "object_type")

    @object_type.setter
    def object_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "object_type", value)

    @property
    @pulumi.getter(name="exclusionFilters")
    def exclusion_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "exclusion_filters")

    @exclusion_filters.setter
    def exclusion_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclusion_filters", value)

    @property
    @pulumi.getter(name="inclusionFilters")
    def inclusion_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "inclusion_filters")

    @inclusion_filters.setter
    def inclusion_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "inclusion_filters", value)


@pulumi.input_type
class DataSourceS3DataSourceConfigurationArgs:
    def __init__(__self__, *,
                 bucket_arn: pulumi.Input[str],
                 bucket_owner_account_id: Optional[pulumi.Input[str]] = None,
                 inclusion_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The configuration information to connect to Amazon S3 as your data source.
        :param pulumi.Input[str] bucket_arn: The ARN of the bucket that contains the data source.
        :param pulumi.Input[str] bucket_owner_account_id: The account ID for the owner of the S3 bucket.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] inclusion_prefixes: A list of S3 prefixes that define the object containing the data sources.
        """
        pulumi.set(__self__, "bucket_arn", bucket_arn)
        if bucket_owner_account_id is not None:
            pulumi.set(__self__, "bucket_owner_account_id", bucket_owner_account_id)
        if inclusion_prefixes is not None:
            pulumi.set(__self__, "inclusion_prefixes", inclusion_prefixes)

    @property
    @pulumi.getter(name="bucketArn")
    def bucket_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the bucket that contains the data source.
        """
        return pulumi.get(self, "bucket_arn")

    @bucket_arn.setter
    def bucket_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket_arn", value)

    @property
    @pulumi.getter(name="bucketOwnerAccountId")
    def bucket_owner_account_id(self) -> Optional[pulumi.Input[str]]:
        """
        The account ID for the owner of the S3 bucket.
        """
        return pulumi.get(self, "bucket_owner_account_id")

    @bucket_owner_account_id.setter
    def bucket_owner_account_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket_owner_account_id", value)

    @property
    @pulumi.getter(name="inclusionPrefixes")
    def inclusion_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of S3 prefixes that define the object containing the data sources.
        """
        return pulumi.get(self, "inclusion_prefixes")

    @inclusion_prefixes.setter
    def inclusion_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "inclusion_prefixes", value)


@pulumi.input_type
class DataSourceS3LocationArgs:
    def __init__(__self__, *,
                 uri: pulumi.Input[str]):
        """
        An Amazon S3 location.
        :param pulumi.Input[str] uri: The location's URI
        """
        pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def uri(self) -> pulumi.Input[str]:
        """
        The location's URI
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "uri", value)


@pulumi.input_type
class DataSourceSalesforceCrawlerConfigurationArgs:
    def __init__(__self__, *,
                 filter_configuration: Optional[pulumi.Input['DataSourceCrawlFilterConfigurationArgs']] = None):
        """
        The configuration of filtering the Salesforce content. For example, configuring regular expression patterns to include or exclude certain content.
        :param pulumi.Input['DataSourceCrawlFilterConfigurationArgs'] filter_configuration: The configuration of filtering the Salesforce content. For example, configuring regular expression patterns to include or exclude certain content.
        """
        if filter_configuration is not None:
            pulumi.set(__self__, "filter_configuration", filter_configuration)

    @property
    @pulumi.getter(name="filterConfiguration")
    def filter_configuration(self) -> Optional[pulumi.Input['DataSourceCrawlFilterConfigurationArgs']]:
        """
        The configuration of filtering the Salesforce content. For example, configuring regular expression patterns to include or exclude certain content.
        """
        return pulumi.get(self, "filter_configuration")

    @filter_configuration.setter
    def filter_configuration(self, value: Optional[pulumi.Input['DataSourceCrawlFilterConfigurationArgs']]):
        pulumi.set(self, "filter_configuration", value)


@pulumi.input_type
class DataSourceSalesforceDataSourceConfigurationArgs:
    def __init__(__self__, *,
                 source_configuration: pulumi.Input['DataSourceSalesforceSourceConfigurationArgs'],
                 crawler_configuration: Optional[pulumi.Input['DataSourceSalesforceCrawlerConfigurationArgs']] = None):
        """
        The configuration information to connect to Salesforce as your data source.
        :param pulumi.Input['DataSourceSalesforceSourceConfigurationArgs'] source_configuration: The endpoint information to connect to your Salesforce data source.
        :param pulumi.Input['DataSourceSalesforceCrawlerConfigurationArgs'] crawler_configuration: The configuration of the Salesforce content. For example, configuring specific types of Salesforce content.
        """
        pulumi.set(__self__, "source_configuration", source_configuration)
        if crawler_configuration is not None:
            pulumi.set(__self__, "crawler_configuration", crawler_configuration)

    @property
    @pulumi.getter(name="sourceConfiguration")
    def source_configuration(self) -> pulumi.Input['DataSourceSalesforceSourceConfigurationArgs']:
        """
        The endpoint information to connect to your Salesforce data source.
        """
        return pulumi.get(self, "source_configuration")

    @source_configuration.setter
    def source_configuration(self, value: pulumi.Input['DataSourceSalesforceSourceConfigurationArgs']):
        pulumi.set(self, "source_configuration", value)

    @property
    @pulumi.getter(name="crawlerConfiguration")
    def crawler_configuration(self) -> Optional[pulumi.Input['DataSourceSalesforceCrawlerConfigurationArgs']]:
        """
        The configuration of the Salesforce content. For example, configuring specific types of Salesforce content.
        """
        return pulumi.get(self, "crawler_configuration")

    @crawler_configuration.setter
    def crawler_configuration(self, value: Optional[pulumi.Input['DataSourceSalesforceCrawlerConfigurationArgs']]):
        pulumi.set(self, "crawler_configuration", value)


@pulumi.input_type
class DataSourceSalesforceSourceConfigurationArgs:
    def __init__(__self__, *,
                 auth_type: pulumi.Input['DataSourceSalesforceSourceConfigurationAuthType'],
                 credentials_secret_arn: pulumi.Input[str],
                 host_url: pulumi.Input[str]):
        """
        The endpoint information to connect to your Salesforce data source.
        :param pulumi.Input['DataSourceSalesforceSourceConfigurationAuthType'] auth_type: The supported authentication type to authenticate and connect to your Salesforce instance.
        :param pulumi.Input[str] credentials_secret_arn: The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your Salesforce instance URL. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see Salesforce connection configuration.
        :param pulumi.Input[str] host_url: The Salesforce host URL or instance URL.
        """
        pulumi.set(__self__, "auth_type", auth_type)
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "host_url", host_url)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> pulumi.Input['DataSourceSalesforceSourceConfigurationAuthType']:
        """
        The supported authentication type to authenticate and connect to your Salesforce instance.
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: pulumi.Input['DataSourceSalesforceSourceConfigurationAuthType']):
        pulumi.set(self, "auth_type", value)

    @property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your Salesforce instance URL. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see Salesforce connection configuration.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @credentials_secret_arn.setter
    def credentials_secret_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "credentials_secret_arn", value)

    @property
    @pulumi.getter(name="hostUrl")
    def host_url(self) -> pulumi.Input[str]:
        """
        The Salesforce host URL or instance URL.
        """
        return pulumi.get(self, "host_url")

    @host_url.setter
    def host_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "host_url", value)


@pulumi.input_type
class DataSourceSeedUrlArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str]):
        """
        A seed url object.
        :param pulumi.Input[str] url: A web url.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        A web url.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class DataSourceSemanticChunkingConfigurationArgs:
    def __init__(__self__, *,
                 breakpoint_percentile_threshold: pulumi.Input[int],
                 buffer_size: pulumi.Input[int],
                 max_tokens: pulumi.Input[int]):
        """
        Configurations for when you choose semantic chunking. If you set the chunkingStrategy as NONE, exclude this field.
        :param pulumi.Input[int] breakpoint_percentile_threshold: The dissimilarity threshold for splitting chunks.
        :param pulumi.Input[int] buffer_size: The buffer size.
        :param pulumi.Input[int] max_tokens: The maximum number of tokens that a chunk can contain.
        """
        pulumi.set(__self__, "breakpoint_percentile_threshold", breakpoint_percentile_threshold)
        pulumi.set(__self__, "buffer_size", buffer_size)
        pulumi.set(__self__, "max_tokens", max_tokens)

    @property
    @pulumi.getter(name="breakpointPercentileThreshold")
    def breakpoint_percentile_threshold(self) -> pulumi.Input[int]:
        """
        The dissimilarity threshold for splitting chunks.
        """
        return pulumi.get(self, "breakpoint_percentile_threshold")

    @breakpoint_percentile_threshold.setter
    def breakpoint_percentile_threshold(self, value: pulumi.Input[int]):
        pulumi.set(self, "breakpoint_percentile_threshold", value)

    @property
    @pulumi.getter(name="bufferSize")
    def buffer_size(self) -> pulumi.Input[int]:
        """
        The buffer size.
        """
        return pulumi.get(self, "buffer_size")

    @buffer_size.setter
    def buffer_size(self, value: pulumi.Input[int]):
        pulumi.set(self, "buffer_size", value)

    @property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> pulumi.Input[int]:
        """
        The maximum number of tokens that a chunk can contain.
        """
        return pulumi.get(self, "max_tokens")

    @max_tokens.setter
    def max_tokens(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_tokens", value)


@pulumi.input_type
class DataSourceServerSideEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 kms_key_arn: Optional[pulumi.Input[str]] = None):
        """
        Contains details about the server-side encryption for the data source.
        :param pulumi.Input[str] kms_key_arn: The ARN of the AWS KMS key used to encrypt the resource.
        """
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The ARN of the AWS KMS key used to encrypt the resource.
        """
        return pulumi.get(self, "kms_key_arn")

    @kms_key_arn.setter
    def kms_key_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_arn", value)


@pulumi.input_type
class DataSourceSharePointCrawlerConfigurationArgs:
    def __init__(__self__, *,
                 filter_configuration: Optional[pulumi.Input['DataSourceCrawlFilterConfigurationArgs']] = None):
        """
        The configuration of the SharePoint content. For example, configuring specific types of SharePoint content.
        :param pulumi.Input['DataSourceCrawlFilterConfigurationArgs'] filter_configuration: The configuration of filtering the SharePoint content. For example, configuring regular expression patterns to include or exclude certain content.
        """
        if filter_configuration is not None:
            pulumi.set(__self__, "filter_configuration", filter_configuration)

    @property
    @pulumi.getter(name="filterConfiguration")
    def filter_configuration(self) -> Optional[pulumi.Input['DataSourceCrawlFilterConfigurationArgs']]:
        """
        The configuration of filtering the SharePoint content. For example, configuring regular expression patterns to include or exclude certain content.
        """
        return pulumi.get(self, "filter_configuration")

    @filter_configuration.setter
    def filter_configuration(self, value: Optional[pulumi.Input['DataSourceCrawlFilterConfigurationArgs']]):
        pulumi.set(self, "filter_configuration", value)


@pulumi.input_type
class DataSourceSharePointDataSourceConfigurationArgs:
    def __init__(__self__, *,
                 source_configuration: pulumi.Input['DataSourceSharePointSourceConfigurationArgs'],
                 crawler_configuration: Optional[pulumi.Input['DataSourceSharePointCrawlerConfigurationArgs']] = None):
        """
        The configuration information to connect to SharePoint as your data source.
        :param pulumi.Input['DataSourceSharePointSourceConfigurationArgs'] source_configuration: The endpoint information to connect to your SharePoint data source.
        :param pulumi.Input['DataSourceSharePointCrawlerConfigurationArgs'] crawler_configuration: The configuration of the SharePoint content. For example, configuring specific types of SharePoint content.
        """
        pulumi.set(__self__, "source_configuration", source_configuration)
        if crawler_configuration is not None:
            pulumi.set(__self__, "crawler_configuration", crawler_configuration)

    @property
    @pulumi.getter(name="sourceConfiguration")
    def source_configuration(self) -> pulumi.Input['DataSourceSharePointSourceConfigurationArgs']:
        """
        The endpoint information to connect to your SharePoint data source.
        """
        return pulumi.get(self, "source_configuration")

    @source_configuration.setter
    def source_configuration(self, value: pulumi.Input['DataSourceSharePointSourceConfigurationArgs']):
        pulumi.set(self, "source_configuration", value)

    @property
    @pulumi.getter(name="crawlerConfiguration")
    def crawler_configuration(self) -> Optional[pulumi.Input['DataSourceSharePointCrawlerConfigurationArgs']]:
        """
        The configuration of the SharePoint content. For example, configuring specific types of SharePoint content.
        """
        return pulumi.get(self, "crawler_configuration")

    @crawler_configuration.setter
    def crawler_configuration(self, value: Optional[pulumi.Input['DataSourceSharePointCrawlerConfigurationArgs']]):
        pulumi.set(self, "crawler_configuration", value)


@pulumi.input_type
class DataSourceSharePointSourceConfigurationArgs:
    def __init__(__self__, *,
                 auth_type: pulumi.Input['DataSourceSharePointSourceConfigurationAuthType'],
                 credentials_secret_arn: pulumi.Input[str],
                 domain: pulumi.Input[str],
                 host_type: pulumi.Input['DataSourceSharePointSourceConfigurationHostType'],
                 site_urls: pulumi.Input[Sequence[pulumi.Input[str]]],
                 tenant_id: Optional[pulumi.Input[str]] = None):
        """
        The endpoint information to connect to your SharePoint data source.
        :param pulumi.Input['DataSourceSharePointSourceConfigurationAuthType'] auth_type: The supported authentication type to authenticate and connect to your SharePoint site/sites.
        :param pulumi.Input[str] credentials_secret_arn: The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your SharePoint site/sites. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see SharePoint connection configuration.
        :param pulumi.Input[str] domain: The domain of your SharePoint instance or site URL/URLs.
        :param pulumi.Input['DataSourceSharePointSourceConfigurationHostType'] host_type: The supported host type, whether online/cloud or server/on-premises.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] site_urls: A list of one or more SharePoint site URLs.
        :param pulumi.Input[str] tenant_id: The identifier of your Microsoft 365 tenant.
        """
        pulumi.set(__self__, "auth_type", auth_type)
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "host_type", host_type)
        pulumi.set(__self__, "site_urls", site_urls)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> pulumi.Input['DataSourceSharePointSourceConfigurationAuthType']:
        """
        The supported authentication type to authenticate and connect to your SharePoint site/sites.
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: pulumi.Input['DataSourceSharePointSourceConfigurationAuthType']):
        pulumi.set(self, "auth_type", value)

    @property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your SharePoint site/sites. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see SharePoint connection configuration.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @credentials_secret_arn.setter
    def credentials_secret_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "credentials_secret_arn", value)

    @property
    @pulumi.getter
    def domain(self) -> pulumi.Input[str]:
        """
        The domain of your SharePoint instance or site URL/URLs.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter(name="hostType")
    def host_type(self) -> pulumi.Input['DataSourceSharePointSourceConfigurationHostType']:
        """
        The supported host type, whether online/cloud or server/on-premises.
        """
        return pulumi.get(self, "host_type")

    @host_type.setter
    def host_type(self, value: pulumi.Input['DataSourceSharePointSourceConfigurationHostType']):
        pulumi.set(self, "host_type", value)

    @property
    @pulumi.getter(name="siteUrls")
    def site_urls(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of one or more SharePoint site URLs.
        """
        return pulumi.get(self, "site_urls")

    @site_urls.setter
    def site_urls(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "site_urls", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[str]]:
        """
        The identifier of your Microsoft 365 tenant.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tenant_id", value)


@pulumi.input_type
class DataSourceTransformationFunctionArgs:
    def __init__(__self__, *,
                 transformation_lambda_configuration: pulumi.Input['DataSourceTransformationLambdaConfigurationArgs']):
        """
        A Lambda function that processes documents.
        :param pulumi.Input['DataSourceTransformationLambdaConfigurationArgs'] transformation_lambda_configuration: The Lambda function.
        """
        pulumi.set(__self__, "transformation_lambda_configuration", transformation_lambda_configuration)

    @property
    @pulumi.getter(name="transformationLambdaConfiguration")
    def transformation_lambda_configuration(self) -> pulumi.Input['DataSourceTransformationLambdaConfigurationArgs']:
        """
        The Lambda function.
        """
        return pulumi.get(self, "transformation_lambda_configuration")

    @transformation_lambda_configuration.setter
    def transformation_lambda_configuration(self, value: pulumi.Input['DataSourceTransformationLambdaConfigurationArgs']):
        pulumi.set(self, "transformation_lambda_configuration", value)


@pulumi.input_type
class DataSourceTransformationLambdaConfigurationArgs:
    def __init__(__self__, *,
                 lambda_arn: pulumi.Input[str]):
        """
        A Lambda function that processes documents.
        :param pulumi.Input[str] lambda_arn: The function's ARN identifier.
        """
        pulumi.set(__self__, "lambda_arn", lambda_arn)

    @property
    @pulumi.getter(name="lambdaArn")
    def lambda_arn(self) -> pulumi.Input[str]:
        """
        The function's ARN identifier.
        """
        return pulumi.get(self, "lambda_arn")

    @lambda_arn.setter
    def lambda_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "lambda_arn", value)


@pulumi.input_type
class DataSourceTransformationArgs:
    def __init__(__self__, *,
                 step_to_apply: pulumi.Input['DataSourceTransformationStepToApply'],
                 transformation_function: pulumi.Input['DataSourceTransformationFunctionArgs']):
        """
        A Lambda function that processes documents.
        :param pulumi.Input['DataSourceTransformationStepToApply'] step_to_apply: When the service applies the transformation.
        :param pulumi.Input['DataSourceTransformationFunctionArgs'] transformation_function: A Lambda function that processes documents.
        """
        pulumi.set(__self__, "step_to_apply", step_to_apply)
        pulumi.set(__self__, "transformation_function", transformation_function)

    @property
    @pulumi.getter(name="stepToApply")
    def step_to_apply(self) -> pulumi.Input['DataSourceTransformationStepToApply']:
        """
        When the service applies the transformation.
        """
        return pulumi.get(self, "step_to_apply")

    @step_to_apply.setter
    def step_to_apply(self, value: pulumi.Input['DataSourceTransformationStepToApply']):
        pulumi.set(self, "step_to_apply", value)

    @property
    @pulumi.getter(name="transformationFunction")
    def transformation_function(self) -> pulumi.Input['DataSourceTransformationFunctionArgs']:
        """
        A Lambda function that processes documents.
        """
        return pulumi.get(self, "transformation_function")

    @transformation_function.setter
    def transformation_function(self, value: pulumi.Input['DataSourceTransformationFunctionArgs']):
        pulumi.set(self, "transformation_function", value)


@pulumi.input_type
class DataSourceUrlConfigurationArgs:
    def __init__(__self__, *,
                 seed_urls: pulumi.Input[Sequence[pulumi.Input['DataSourceSeedUrlArgs']]]):
        """
        A url configuration.
        :param pulumi.Input[Sequence[pulumi.Input['DataSourceSeedUrlArgs']]] seed_urls: One or more seed or starting point URLs.
        """
        pulumi.set(__self__, "seed_urls", seed_urls)

    @property
    @pulumi.getter(name="seedUrls")
    def seed_urls(self) -> pulumi.Input[Sequence[pulumi.Input['DataSourceSeedUrlArgs']]]:
        """
        One or more seed or starting point URLs.
        """
        return pulumi.get(self, "seed_urls")

    @seed_urls.setter
    def seed_urls(self, value: pulumi.Input[Sequence[pulumi.Input['DataSourceSeedUrlArgs']]]):
        pulumi.set(self, "seed_urls", value)


@pulumi.input_type
class DataSourceVectorIngestionConfigurationArgs:
    def __init__(__self__, *,
                 chunking_configuration: Optional[pulumi.Input['DataSourceChunkingConfigurationArgs']] = None,
                 custom_transformation_configuration: Optional[pulumi.Input['DataSourceCustomTransformationConfigurationArgs']] = None,
                 parsing_configuration: Optional[pulumi.Input['DataSourceParsingConfigurationArgs']] = None):
        """
        Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried.
        :param pulumi.Input['DataSourceChunkingConfigurationArgs'] chunking_configuration: Details about how to chunk the documents in the data source. A *chunk* refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried.
        :param pulumi.Input['DataSourceCustomTransformationConfigurationArgs'] custom_transformation_configuration: A custom document transformer for parsed data source documents.
        :param pulumi.Input['DataSourceParsingConfigurationArgs'] parsing_configuration: A custom parser for data source documents.
        """
        if chunking_configuration is not None:
            pulumi.set(__self__, "chunking_configuration", chunking_configuration)
        if custom_transformation_configuration is not None:
            pulumi.set(__self__, "custom_transformation_configuration", custom_transformation_configuration)
        if parsing_configuration is not None:
            pulumi.set(__self__, "parsing_configuration", parsing_configuration)

    @property
    @pulumi.getter(name="chunkingConfiguration")
    def chunking_configuration(self) -> Optional[pulumi.Input['DataSourceChunkingConfigurationArgs']]:
        """
        Details about how to chunk the documents in the data source. A *chunk* refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried.
        """
        return pulumi.get(self, "chunking_configuration")

    @chunking_configuration.setter
    def chunking_configuration(self, value: Optional[pulumi.Input['DataSourceChunkingConfigurationArgs']]):
        pulumi.set(self, "chunking_configuration", value)

    @property
    @pulumi.getter(name="customTransformationConfiguration")
    def custom_transformation_configuration(self) -> Optional[pulumi.Input['DataSourceCustomTransformationConfigurationArgs']]:
        """
        A custom document transformer for parsed data source documents.
        """
        return pulumi.get(self, "custom_transformation_configuration")

    @custom_transformation_configuration.setter
    def custom_transformation_configuration(self, value: Optional[pulumi.Input['DataSourceCustomTransformationConfigurationArgs']]):
        pulumi.set(self, "custom_transformation_configuration", value)

    @property
    @pulumi.getter(name="parsingConfiguration")
    def parsing_configuration(self) -> Optional[pulumi.Input['DataSourceParsingConfigurationArgs']]:
        """
        A custom parser for data source documents.
        """
        return pulumi.get(self, "parsing_configuration")

    @parsing_configuration.setter
    def parsing_configuration(self, value: Optional[pulumi.Input['DataSourceParsingConfigurationArgs']]):
        pulumi.set(self, "parsing_configuration", value)


@pulumi.input_type
class DataSourceWebCrawlerConfigurationArgs:
    def __init__(__self__, *,
                 crawler_limits: Optional[pulumi.Input['DataSourceWebCrawlerLimitsArgs']] = None,
                 exclusion_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 inclusion_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 scope: Optional[pulumi.Input['DataSourceWebScopeType']] = None):
        """
        Configuration for the web crawler.
        :param pulumi.Input['DataSourceWebCrawlerLimitsArgs'] crawler_limits: The configuration of crawl limits for the web URLs.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclusion_filters: A list of one or more exclusion regular expression patterns to exclude certain URLs. If you specify an inclusion and exclusion filter/pattern and both match a URL, the exclusion filter takes precedence and the web content of the URL isn’t crawled.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] inclusion_filters: A list of one or more inclusion regular expression patterns to include certain URLs. If you specify an inclusion and exclusion filter/pattern and both match a URL, the exclusion filter takes precedence and the web content of the URL isn’t crawled.
        :param pulumi.Input['DataSourceWebScopeType'] scope: The scope of what is crawled for your URLs.
               
               You can choose to crawl only web pages that belong to the same host or primary domain. For example, only web pages that contain the seed URL "https://docs.aws.amazon.com/bedrock/latest/userguide/" and no other domains. You can choose to include sub domains in addition to the host or primary domain. For example, web pages that contain "aws.amazon.com" can also include sub domain "docs.aws.amazon.com".
        """
        if crawler_limits is not None:
            pulumi.set(__self__, "crawler_limits", crawler_limits)
        if exclusion_filters is not None:
            pulumi.set(__self__, "exclusion_filters", exclusion_filters)
        if inclusion_filters is not None:
            pulumi.set(__self__, "inclusion_filters", inclusion_filters)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter(name="crawlerLimits")
    def crawler_limits(self) -> Optional[pulumi.Input['DataSourceWebCrawlerLimitsArgs']]:
        """
        The configuration of crawl limits for the web URLs.
        """
        return pulumi.get(self, "crawler_limits")

    @crawler_limits.setter
    def crawler_limits(self, value: Optional[pulumi.Input['DataSourceWebCrawlerLimitsArgs']]):
        pulumi.set(self, "crawler_limits", value)

    @property
    @pulumi.getter(name="exclusionFilters")
    def exclusion_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of one or more exclusion regular expression patterns to exclude certain URLs. If you specify an inclusion and exclusion filter/pattern and both match a URL, the exclusion filter takes precedence and the web content of the URL isn’t crawled.
        """
        return pulumi.get(self, "exclusion_filters")

    @exclusion_filters.setter
    def exclusion_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclusion_filters", value)

    @property
    @pulumi.getter(name="inclusionFilters")
    def inclusion_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of one or more inclusion regular expression patterns to include certain URLs. If you specify an inclusion and exclusion filter/pattern and both match a URL, the exclusion filter takes precedence and the web content of the URL isn’t crawled.
        """
        return pulumi.get(self, "inclusion_filters")

    @inclusion_filters.setter
    def inclusion_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "inclusion_filters", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input['DataSourceWebScopeType']]:
        """
        The scope of what is crawled for your URLs.

        You can choose to crawl only web pages that belong to the same host or primary domain. For example, only web pages that contain the seed URL "https://docs.aws.amazon.com/bedrock/latest/userguide/" and no other domains. You can choose to include sub domains in addition to the host or primary domain. For example, web pages that contain "aws.amazon.com" can also include sub domain "docs.aws.amazon.com".
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input['DataSourceWebScopeType']]):
        pulumi.set(self, "scope", value)


@pulumi.input_type
class DataSourceWebCrawlerLimitsArgs:
    def __init__(__self__, *,
                 rate_limit: Optional[pulumi.Input[int]] = None):
        """
        Limit settings for the web crawler.
        :param pulumi.Input[int] rate_limit: Rate of web URLs retrieved per minute.
        """
        if rate_limit is not None:
            pulumi.set(__self__, "rate_limit", rate_limit)

    @property
    @pulumi.getter(name="rateLimit")
    def rate_limit(self) -> Optional[pulumi.Input[int]]:
        """
        Rate of web URLs retrieved per minute.
        """
        return pulumi.get(self, "rate_limit")

    @rate_limit.setter
    def rate_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "rate_limit", value)


@pulumi.input_type
class DataSourceWebDataSourceConfigurationArgs:
    def __init__(__self__, *,
                 source_configuration: pulumi.Input['DataSourceWebSourceConfigurationArgs'],
                 crawler_configuration: Optional[pulumi.Input['DataSourceWebCrawlerConfigurationArgs']] = None):
        """
        Configures a web data source location.
        :param pulumi.Input['DataSourceWebSourceConfigurationArgs'] source_configuration: The source configuration details for the web data source.
        :param pulumi.Input['DataSourceWebCrawlerConfigurationArgs'] crawler_configuration: The Web Crawler configuration details for the web data source.
        """
        pulumi.set(__self__, "source_configuration", source_configuration)
        if crawler_configuration is not None:
            pulumi.set(__self__, "crawler_configuration", crawler_configuration)

    @property
    @pulumi.getter(name="sourceConfiguration")
    def source_configuration(self) -> pulumi.Input['DataSourceWebSourceConfigurationArgs']:
        """
        The source configuration details for the web data source.
        """
        return pulumi.get(self, "source_configuration")

    @source_configuration.setter
    def source_configuration(self, value: pulumi.Input['DataSourceWebSourceConfigurationArgs']):
        pulumi.set(self, "source_configuration", value)

    @property
    @pulumi.getter(name="crawlerConfiguration")
    def crawler_configuration(self) -> Optional[pulumi.Input['DataSourceWebCrawlerConfigurationArgs']]:
        """
        The Web Crawler configuration details for the web data source.
        """
        return pulumi.get(self, "crawler_configuration")

    @crawler_configuration.setter
    def crawler_configuration(self, value: Optional[pulumi.Input['DataSourceWebCrawlerConfigurationArgs']]):
        pulumi.set(self, "crawler_configuration", value)


@pulumi.input_type
class DataSourceWebSourceConfigurationArgs:
    def __init__(__self__, *,
                 url_configuration: pulumi.Input['DataSourceUrlConfigurationArgs']):
        """
        A web source configuration.
        :param pulumi.Input['DataSourceUrlConfigurationArgs'] url_configuration: The configuration of the URL/URLs.
        """
        pulumi.set(__self__, "url_configuration", url_configuration)

    @property
    @pulumi.getter(name="urlConfiguration")
    def url_configuration(self) -> pulumi.Input['DataSourceUrlConfigurationArgs']:
        """
        The configuration of the URL/URLs.
        """
        return pulumi.get(self, "url_configuration")

    @url_configuration.setter
    def url_configuration(self, value: pulumi.Input['DataSourceUrlConfigurationArgs']):
        pulumi.set(self, "url_configuration", value)


@pulumi.input_type
class FlowAliasRoutingConfigurationListItemArgs:
    def __init__(__self__, *,
                 flow_version: Optional[pulumi.Input[str]] = None):
        """
        Details about the routing configuration for a Flow alias.
        :param pulumi.Input[str] flow_version: Version.
        """
        if flow_version is not None:
            pulumi.set(__self__, "flow_version", flow_version)

    @property
    @pulumi.getter(name="flowVersion")
    def flow_version(self) -> Optional[pulumi.Input[str]]:
        """
        Version.
        """
        return pulumi.get(self, "flow_version")

    @flow_version.setter
    def flow_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "flow_version", value)


@pulumi.input_type
class FlowConditionFlowNodeConfigurationArgs:
    def __init__(__self__, *,
                 conditions: pulumi.Input[Sequence[pulumi.Input['FlowConditionArgs']]]):
        """
        Condition flow node configuration
        :param pulumi.Input[Sequence[pulumi.Input['FlowConditionArgs']]] conditions: List of conditions in a condition node
        """
        pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> pulumi.Input[Sequence[pulumi.Input['FlowConditionArgs']]]:
        """
        List of conditions in a condition node
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: pulumi.Input[Sequence[pulumi.Input['FlowConditionArgs']]]):
        pulumi.set(self, "conditions", value)


@pulumi.input_type
class FlowConditionalConnectionConfigurationArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str]):
        """
        Conditional connection configuration
        :param pulumi.Input[str] condition: Name of a condition in a flow
        """
        pulumi.set(__self__, "condition", condition)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Name of a condition in a flow
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)


@pulumi.input_type
class FlowConditionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 expression: Optional[pulumi.Input[str]] = None):
        """
        Condition branch for a condition node
        :param pulumi.Input[str] name: Name of a condition in a flow
        :param pulumi.Input[str] expression: Expression for a condition in a flow
        """
        pulumi.set(__self__, "name", name)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of a condition in a flow
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[str]]:
        """
        Expression for a condition in a flow
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expression", value)


@pulumi.input_type
class FlowConnectionConfiguration0PropertiesArgs:
    def __init__(__self__, *,
                 data: pulumi.Input['FlowDataConnectionConfigurationArgs']):
        """
        Connection configuration
        """
        pulumi.set(__self__, "data", data)

    @property
    @pulumi.getter
    def data(self) -> pulumi.Input['FlowDataConnectionConfigurationArgs']:
        return pulumi.get(self, "data")

    @data.setter
    def data(self, value: pulumi.Input['FlowDataConnectionConfigurationArgs']):
        pulumi.set(self, "data", value)


@pulumi.input_type
class FlowConnectionConfiguration1PropertiesArgs:
    def __init__(__self__, *,
                 conditional: pulumi.Input['FlowConditionalConnectionConfigurationArgs']):
        """
        Connection configuration
        """
        pulumi.set(__self__, "conditional", conditional)

    @property
    @pulumi.getter
    def conditional(self) -> pulumi.Input['FlowConditionalConnectionConfigurationArgs']:
        return pulumi.get(self, "conditional")

    @conditional.setter
    def conditional(self, value: pulumi.Input['FlowConditionalConnectionConfigurationArgs']):
        pulumi.set(self, "conditional", value)


@pulumi.input_type
class FlowConnectionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 source: pulumi.Input[str],
                 target: pulumi.Input[str],
                 type: pulumi.Input['FlowConnectionType'],
                 configuration: Optional[pulumi.Input[Union['FlowConnectionConfiguration0PropertiesArgs', 'FlowConnectionConfiguration1PropertiesArgs']]] = None):
        """
        Flow connection
        :param pulumi.Input[str] name: Name of a connection in a flow
        :param pulumi.Input[str] source: Name of a node in a flow
        :param pulumi.Input[str] target: Name of a node in a flow
        :param pulumi.Input['FlowConnectionType'] type: Whether the source node that the connection begins from is a condition node ( `Conditional` ) or not ( `Data` ).
        :param pulumi.Input[Union['FlowConnectionConfiguration0PropertiesArgs', 'FlowConnectionConfiguration1PropertiesArgs']] configuration: The configuration of the connection.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "type", type)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of a connection in a flow
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[str]:
        """
        Name of a node in a flow
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        Name of a node in a flow
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input['FlowConnectionType']:
        """
        Whether the source node that the connection begins from is a condition node ( `Conditional` ) or not ( `Data` ).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['FlowConnectionType']):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def configuration(self) -> Optional[pulumi.Input[Union['FlowConnectionConfiguration0PropertiesArgs', 'FlowConnectionConfiguration1PropertiesArgs']]]:
        """
        The configuration of the connection.
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[pulumi.Input[Union['FlowConnectionConfiguration0PropertiesArgs', 'FlowConnectionConfiguration1PropertiesArgs']]]):
        pulumi.set(self, "configuration", value)


@pulumi.input_type
class FlowDataConnectionConfigurationArgs:
    def __init__(__self__, *,
                 source_output: pulumi.Input[str],
                 target_input: pulumi.Input[str]):
        """
        Data connection configuration
        :param pulumi.Input[str] source_output: Name of a node output in a flow
        :param pulumi.Input[str] target_input: Name of a node input in a flow
        """
        pulumi.set(__self__, "source_output", source_output)
        pulumi.set(__self__, "target_input", target_input)

    @property
    @pulumi.getter(name="sourceOutput")
    def source_output(self) -> pulumi.Input[str]:
        """
        Name of a node output in a flow
        """
        return pulumi.get(self, "source_output")

    @source_output.setter
    def source_output(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_output", value)

    @property
    @pulumi.getter(name="targetInput")
    def target_input(self) -> pulumi.Input[str]:
        """
        Name of a node input in a flow
        """
        return pulumi.get(self, "target_input")

    @target_input.setter
    def target_input(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_input", value)


@pulumi.input_type
class FlowDefinitionArgs:
    def __init__(__self__, *,
                 connections: Optional[pulumi.Input[Sequence[pulumi.Input['FlowConnectionArgs']]]] = None,
                 nodes: Optional[pulumi.Input[Sequence[pulumi.Input['FlowNodeArgs']]]] = None):
        """
        Flow definition
        :param pulumi.Input[Sequence[pulumi.Input['FlowConnectionArgs']]] connections: List of connections
        :param pulumi.Input[Sequence[pulumi.Input['FlowNodeArgs']]] nodes: List of nodes in a flow
        """
        if connections is not None:
            pulumi.set(__self__, "connections", connections)
        if nodes is not None:
            pulumi.set(__self__, "nodes", nodes)

    @property
    @pulumi.getter
    def connections(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FlowConnectionArgs']]]]:
        """
        List of connections
        """
        return pulumi.get(self, "connections")

    @connections.setter
    def connections(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FlowConnectionArgs']]]]):
        pulumi.set(self, "connections", value)

    @property
    @pulumi.getter
    def nodes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FlowNodeArgs']]]]:
        """
        List of nodes in a flow
        """
        return pulumi.get(self, "nodes")

    @nodes.setter
    def nodes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FlowNodeArgs']]]]):
        pulumi.set(self, "nodes", value)


@pulumi.input_type
class FlowInputFlowNodeConfigurationArgs:
    def __init__(__self__):
        """
        Input flow node configuration
        """
        pass


@pulumi.input_type
class FlowKnowledgeBaseFlowNodeConfigurationArgs:
    def __init__(__self__, *,
                 knowledge_base_id: pulumi.Input[str],
                 model_id: Optional[pulumi.Input[str]] = None):
        """
        Knowledge base flow node configuration
        :param pulumi.Input[str] knowledge_base_id: Identifier of the KnowledgeBase
        :param pulumi.Input[str] model_id: ARN or name of a Bedrock model.
        """
        pulumi.set(__self__, "knowledge_base_id", knowledge_base_id)
        if model_id is not None:
            pulumi.set(__self__, "model_id", model_id)

    @property
    @pulumi.getter(name="knowledgeBaseId")
    def knowledge_base_id(self) -> pulumi.Input[str]:
        """
        Identifier of the KnowledgeBase
        """
        return pulumi.get(self, "knowledge_base_id")

    @knowledge_base_id.setter
    def knowledge_base_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "knowledge_base_id", value)

    @property
    @pulumi.getter(name="modelId")
    def model_id(self) -> Optional[pulumi.Input[str]]:
        """
        ARN or name of a Bedrock model.
        """
        return pulumi.get(self, "model_id")

    @model_id.setter
    def model_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "model_id", value)


@pulumi.input_type
class FlowLambdaFunctionFlowNodeConfigurationArgs:
    def __init__(__self__, *,
                 lambda_arn: pulumi.Input[str]):
        """
        Lambda function flow node configuration
        :param pulumi.Input[str] lambda_arn: ARN of a Lambda.
        """
        pulumi.set(__self__, "lambda_arn", lambda_arn)

    @property
    @pulumi.getter(name="lambdaArn")
    def lambda_arn(self) -> pulumi.Input[str]:
        """
        ARN of a Lambda.
        """
        return pulumi.get(self, "lambda_arn")

    @lambda_arn.setter
    def lambda_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "lambda_arn", value)


@pulumi.input_type
class FlowLexFlowNodeConfigurationArgs:
    def __init__(__self__, *,
                 bot_alias_arn: pulumi.Input[str],
                 locale_id: pulumi.Input[str]):
        """
        Lex flow node configuration
        :param pulumi.Input[str] bot_alias_arn: ARN of a Lex bot alias
        :param pulumi.Input[str] locale_id: Lex bot locale id
        """
        pulumi.set(__self__, "bot_alias_arn", bot_alias_arn)
        pulumi.set(__self__, "locale_id", locale_id)

    @property
    @pulumi.getter(name="botAliasArn")
    def bot_alias_arn(self) -> pulumi.Input[str]:
        """
        ARN of a Lex bot alias
        """
        return pulumi.get(self, "bot_alias_arn")

    @bot_alias_arn.setter
    def bot_alias_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "bot_alias_arn", value)

    @property
    @pulumi.getter(name="localeId")
    def locale_id(self) -> pulumi.Input[str]:
        """
        Lex bot locale id
        """
        return pulumi.get(self, "locale_id")

    @locale_id.setter
    def locale_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "locale_id", value)


@pulumi.input_type
class FlowNodeConfiguration0PropertiesArgs:
    def __init__(__self__, *,
                 input: pulumi.Input['FlowInputFlowNodeConfigurationArgs']):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "input", input)

    @property
    @pulumi.getter
    def input(self) -> pulumi.Input['FlowInputFlowNodeConfigurationArgs']:
        return pulumi.get(self, "input")

    @input.setter
    def input(self, value: pulumi.Input['FlowInputFlowNodeConfigurationArgs']):
        pulumi.set(self, "input", value)


@pulumi.input_type
class FlowNodeConfiguration1PropertiesArgs:
    def __init__(__self__, *,
                 output: pulumi.Input['FlowOutputFlowNodeConfigurationArgs']):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "output", output)

    @property
    @pulumi.getter
    def output(self) -> pulumi.Input['FlowOutputFlowNodeConfigurationArgs']:
        return pulumi.get(self, "output")

    @output.setter
    def output(self, value: pulumi.Input['FlowOutputFlowNodeConfigurationArgs']):
        pulumi.set(self, "output", value)


@pulumi.input_type
class FlowNodeConfiguration2PropertiesArgs:
    def __init__(__self__, *,
                 knowledge_base: pulumi.Input['FlowKnowledgeBaseFlowNodeConfigurationArgs']):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "knowledge_base", knowledge_base)

    @property
    @pulumi.getter(name="knowledgeBase")
    def knowledge_base(self) -> pulumi.Input['FlowKnowledgeBaseFlowNodeConfigurationArgs']:
        return pulumi.get(self, "knowledge_base")

    @knowledge_base.setter
    def knowledge_base(self, value: pulumi.Input['FlowKnowledgeBaseFlowNodeConfigurationArgs']):
        pulumi.set(self, "knowledge_base", value)


@pulumi.input_type
class FlowNodeConfiguration3PropertiesArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input['FlowConditionFlowNodeConfigurationArgs']):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "condition", condition)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input['FlowConditionFlowNodeConfigurationArgs']:
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input['FlowConditionFlowNodeConfigurationArgs']):
        pulumi.set(self, "condition", value)


@pulumi.input_type
class FlowNodeConfiguration4PropertiesArgs:
    def __init__(__self__, *,
                 lex: pulumi.Input['FlowLexFlowNodeConfigurationArgs']):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "lex", lex)

    @property
    @pulumi.getter
    def lex(self) -> pulumi.Input['FlowLexFlowNodeConfigurationArgs']:
        return pulumi.get(self, "lex")

    @lex.setter
    def lex(self, value: pulumi.Input['FlowLexFlowNodeConfigurationArgs']):
        pulumi.set(self, "lex", value)


@pulumi.input_type
class FlowNodeConfiguration5PropertiesArgs:
    def __init__(__self__, *,
                 prompt: pulumi.Input['FlowPromptFlowNodeConfigurationArgs']):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "prompt", prompt)

    @property
    @pulumi.getter
    def prompt(self) -> pulumi.Input['FlowPromptFlowNodeConfigurationArgs']:
        return pulumi.get(self, "prompt")

    @prompt.setter
    def prompt(self, value: pulumi.Input['FlowPromptFlowNodeConfigurationArgs']):
        pulumi.set(self, "prompt", value)


@pulumi.input_type
class FlowNodeConfiguration6PropertiesArgs:
    def __init__(__self__, *,
                 lambda_function: pulumi.Input['FlowLambdaFunctionFlowNodeConfigurationArgs']):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "lambda_function", lambda_function)

    @property
    @pulumi.getter(name="lambdaFunction")
    def lambda_function(self) -> pulumi.Input['FlowLambdaFunctionFlowNodeConfigurationArgs']:
        return pulumi.get(self, "lambda_function")

    @lambda_function.setter
    def lambda_function(self, value: pulumi.Input['FlowLambdaFunctionFlowNodeConfigurationArgs']):
        pulumi.set(self, "lambda_function", value)


@pulumi.input_type
class FlowNodeInputArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 name: pulumi.Input[str],
                 type: pulumi.Input['FlowNodeIoDataType']):
        """
        Input to a node in a flow
        :param pulumi.Input[str] expression: Expression for a node input in a flow
        :param pulumi.Input[str] name: Name of a node input in a flow
        :param pulumi.Input['FlowNodeIoDataType'] type: The data type of the input. If the input doesn't match this type at runtime, a validation error will be thrown.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        """
        Expression for a node input in a flow
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of a node input in a flow
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input['FlowNodeIoDataType']:
        """
        The data type of the input. If the input doesn't match this type at runtime, a validation error will be thrown.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['FlowNodeIoDataType']):
        pulumi.set(self, "type", value)


@pulumi.input_type
class FlowNodeOutputArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input['FlowNodeIoDataType']):
        """
        Output of a node in a flow
        :param pulumi.Input[str] name: Name of a node output in a flow
        :param pulumi.Input['FlowNodeIoDataType'] type: The data type of the output. If the output doesn't match this type at runtime, a validation error will be thrown.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of a node output in a flow
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input['FlowNodeIoDataType']:
        """
        The data type of the output. If the output doesn't match this type at runtime, a validation error will be thrown.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['FlowNodeIoDataType']):
        pulumi.set(self, "type", value)


@pulumi.input_type
class FlowNodeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input['FlowNodeType'],
                 configuration: Optional[pulumi.Input[Union['FlowNodeConfiguration0PropertiesArgs', 'FlowNodeConfiguration1PropertiesArgs', 'FlowNodeConfiguration2PropertiesArgs', 'FlowNodeConfiguration3PropertiesArgs', 'FlowNodeConfiguration4PropertiesArgs', 'FlowNodeConfiguration5PropertiesArgs', 'FlowNodeConfiguration6PropertiesArgs']]] = None,
                 inputs: Optional[pulumi.Input[Sequence[pulumi.Input['FlowNodeInputArgs']]]] = None,
                 outputs: Optional[pulumi.Input[Sequence[pulumi.Input['FlowNodeOutputArgs']]]] = None):
        """
        Internal mixin for flow node
        :param pulumi.Input[str] name: Name of a node in a flow
        :param pulumi.Input['FlowNodeType'] type: The type of node. This value must match the name of the key that you provide in the configuration you provide in the `FlowNodeConfiguration` field.
        :param pulumi.Input[Union['FlowNodeConfiguration0PropertiesArgs', 'FlowNodeConfiguration1PropertiesArgs', 'FlowNodeConfiguration2PropertiesArgs', 'FlowNodeConfiguration3PropertiesArgs', 'FlowNodeConfiguration4PropertiesArgs', 'FlowNodeConfiguration5PropertiesArgs', 'FlowNodeConfiguration6PropertiesArgs']] configuration: Contains configurations for the node.
        :param pulumi.Input[Sequence[pulumi.Input['FlowNodeInputArgs']]] inputs: List of node inputs in a flow
        :param pulumi.Input[Sequence[pulumi.Input['FlowNodeOutputArgs']]] outputs: List of node outputs in a flow
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if inputs is not None:
            pulumi.set(__self__, "inputs", inputs)
        if outputs is not None:
            pulumi.set(__self__, "outputs", outputs)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of a node in a flow
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input['FlowNodeType']:
        """
        The type of node. This value must match the name of the key that you provide in the configuration you provide in the `FlowNodeConfiguration` field.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['FlowNodeType']):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def configuration(self) -> Optional[pulumi.Input[Union['FlowNodeConfiguration0PropertiesArgs', 'FlowNodeConfiguration1PropertiesArgs', 'FlowNodeConfiguration2PropertiesArgs', 'FlowNodeConfiguration3PropertiesArgs', 'FlowNodeConfiguration4PropertiesArgs', 'FlowNodeConfiguration5PropertiesArgs', 'FlowNodeConfiguration6PropertiesArgs']]]:
        """
        Contains configurations for the node.
        """
        return pulumi.get(self, "configuration")

    @configuration.setter
    def configuration(self, value: Optional[pulumi.Input[Union['FlowNodeConfiguration0PropertiesArgs', 'FlowNodeConfiguration1PropertiesArgs', 'FlowNodeConfiguration2PropertiesArgs', 'FlowNodeConfiguration3PropertiesArgs', 'FlowNodeConfiguration4PropertiesArgs', 'FlowNodeConfiguration5PropertiesArgs', 'FlowNodeConfiguration6PropertiesArgs']]]):
        pulumi.set(self, "configuration", value)

    @property
    @pulumi.getter
    def inputs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FlowNodeInputArgs']]]]:
        """
        List of node inputs in a flow
        """
        return pulumi.get(self, "inputs")

    @inputs.setter
    def inputs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FlowNodeInputArgs']]]]):
        pulumi.set(self, "inputs", value)

    @property
    @pulumi.getter
    def outputs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FlowNodeOutputArgs']]]]:
        """
        List of node outputs in a flow
        """
        return pulumi.get(self, "outputs")

    @outputs.setter
    def outputs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FlowNodeOutputArgs']]]]):
        pulumi.set(self, "outputs", value)


@pulumi.input_type
class FlowOutputFlowNodeConfigurationArgs:
    def __init__(__self__):
        """
        Output flow node configuration
        """
        pass


@pulumi.input_type
class FlowPromptFlowNodeConfigurationArgs:
    def __init__(__self__, *,
                 source_configuration: pulumi.Input[Union['FlowPromptFlowNodeSourceConfiguration0PropertiesArgs', 'FlowPromptFlowNodeSourceConfiguration1PropertiesArgs']]):
        """
        Prompt flow node configuration
        """
        pulumi.set(__self__, "source_configuration", source_configuration)

    @property
    @pulumi.getter(name="sourceConfiguration")
    def source_configuration(self) -> pulumi.Input[Union['FlowPromptFlowNodeSourceConfiguration0PropertiesArgs', 'FlowPromptFlowNodeSourceConfiguration1PropertiesArgs']]:
        return pulumi.get(self, "source_configuration")

    @source_configuration.setter
    def source_configuration(self, value: pulumi.Input[Union['FlowPromptFlowNodeSourceConfiguration0PropertiesArgs', 'FlowPromptFlowNodeSourceConfiguration1PropertiesArgs']]):
        pulumi.set(self, "source_configuration", value)


@pulumi.input_type
class FlowPromptFlowNodeInlineConfigurationArgs:
    def __init__(__self__, *,
                 model_id: pulumi.Input[str],
                 template_configuration: pulumi.Input['FlowPromptTemplateConfigurationPropertiesArgs'],
                 template_type: pulumi.Input['FlowPromptTemplateType'],
                 inference_configuration: Optional[pulumi.Input['FlowPromptInferenceConfigurationPropertiesArgs']] = None):
        """
        Inline prompt configuration for prompt node
        :param pulumi.Input[str] model_id: ARN or name of a Bedrock model.
        """
        pulumi.set(__self__, "model_id", model_id)
        pulumi.set(__self__, "template_configuration", template_configuration)
        pulumi.set(__self__, "template_type", template_type)
        if inference_configuration is not None:
            pulumi.set(__self__, "inference_configuration", inference_configuration)

    @property
    @pulumi.getter(name="modelId")
    def model_id(self) -> pulumi.Input[str]:
        """
        ARN or name of a Bedrock model.
        """
        return pulumi.get(self, "model_id")

    @model_id.setter
    def model_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "model_id", value)

    @property
    @pulumi.getter(name="templateConfiguration")
    def template_configuration(self) -> pulumi.Input['FlowPromptTemplateConfigurationPropertiesArgs']:
        return pulumi.get(self, "template_configuration")

    @template_configuration.setter
    def template_configuration(self, value: pulumi.Input['FlowPromptTemplateConfigurationPropertiesArgs']):
        pulumi.set(self, "template_configuration", value)

    @property
    @pulumi.getter(name="templateType")
    def template_type(self) -> pulumi.Input['FlowPromptTemplateType']:
        return pulumi.get(self, "template_type")

    @template_type.setter
    def template_type(self, value: pulumi.Input['FlowPromptTemplateType']):
        pulumi.set(self, "template_type", value)

    @property
    @pulumi.getter(name="inferenceConfiguration")
    def inference_configuration(self) -> Optional[pulumi.Input['FlowPromptInferenceConfigurationPropertiesArgs']]:
        return pulumi.get(self, "inference_configuration")

    @inference_configuration.setter
    def inference_configuration(self, value: Optional[pulumi.Input['FlowPromptInferenceConfigurationPropertiesArgs']]):
        pulumi.set(self, "inference_configuration", value)


@pulumi.input_type
class FlowPromptFlowNodeResourceConfigurationArgs:
    def __init__(__self__, *,
                 prompt_arn: pulumi.Input[str]):
        """
        Resource prompt configuration for prompt node
        :param pulumi.Input[str] prompt_arn: ARN of a prompt resource possibly with a version
        """
        pulumi.set(__self__, "prompt_arn", prompt_arn)

    @property
    @pulumi.getter(name="promptArn")
    def prompt_arn(self) -> pulumi.Input[str]:
        """
        ARN of a prompt resource possibly with a version
        """
        return pulumi.get(self, "prompt_arn")

    @prompt_arn.setter
    def prompt_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "prompt_arn", value)


@pulumi.input_type
class FlowPromptFlowNodeSourceConfiguration0PropertiesArgs:
    def __init__(__self__, *,
                 resource: pulumi.Input['FlowPromptFlowNodeResourceConfigurationArgs']):
        """
        Prompt source configuration for prompt node
        """
        pulumi.set(__self__, "resource", resource)

    @property
    @pulumi.getter
    def resource(self) -> pulumi.Input['FlowPromptFlowNodeResourceConfigurationArgs']:
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: pulumi.Input['FlowPromptFlowNodeResourceConfigurationArgs']):
        pulumi.set(self, "resource", value)


@pulumi.input_type
class FlowPromptFlowNodeSourceConfiguration1PropertiesArgs:
    def __init__(__self__, *,
                 inline: pulumi.Input['FlowPromptFlowNodeInlineConfigurationArgs']):
        """
        Prompt source configuration for prompt node
        """
        pulumi.set(__self__, "inline", inline)

    @property
    @pulumi.getter
    def inline(self) -> pulumi.Input['FlowPromptFlowNodeInlineConfigurationArgs']:
        return pulumi.get(self, "inline")

    @inline.setter
    def inline(self, value: pulumi.Input['FlowPromptFlowNodeInlineConfigurationArgs']):
        pulumi.set(self, "inline", value)


@pulumi.input_type
class FlowPromptInferenceConfigurationPropertiesArgs:
    def __init__(__self__, *,
                 text: pulumi.Input['FlowPromptModelInferenceConfigurationArgs']):
        """
        Model inference configuration
        """
        pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def text(self) -> pulumi.Input['FlowPromptModelInferenceConfigurationArgs']:
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input['FlowPromptModelInferenceConfigurationArgs']):
        pulumi.set(self, "text", value)


@pulumi.input_type
class FlowPromptInputVariableArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        Input variable
        :param pulumi.Input[str] name: Name for an input variable
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name for an input variable
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class FlowPromptModelInferenceConfigurationArgs:
    def __init__(__self__, *,
                 max_tokens: Optional[pulumi.Input[float]] = None,
                 stop_sequences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 temperature: Optional[pulumi.Input[float]] = None,
                 top_k: Optional[pulumi.Input[float]] = None,
                 top_p: Optional[pulumi.Input[float]] = None):
        """
        Prompt model inference configuration
        :param pulumi.Input[float] max_tokens: Maximum length of output
        :param pulumi.Input[Sequence[pulumi.Input[str]]] stop_sequences: List of stop sequences
        :param pulumi.Input[float] temperature: Controls randomness, higher values increase diversity
        :param pulumi.Input[float] top_k: Sample from the k most likely next tokens
        :param pulumi.Input[float] top_p: Cumulative probability cutoff for token selection
        """
        if max_tokens is not None:
            pulumi.set(__self__, "max_tokens", max_tokens)
        if stop_sequences is not None:
            pulumi.set(__self__, "stop_sequences", stop_sequences)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)
        if top_k is not None:
            pulumi.set(__self__, "top_k", top_k)
        if top_p is not None:
            pulumi.set(__self__, "top_p", top_p)

    @property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> Optional[pulumi.Input[float]]:
        """
        Maximum length of output
        """
        return pulumi.get(self, "max_tokens")

    @max_tokens.setter
    def max_tokens(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_tokens", value)

    @property
    @pulumi.getter(name="stopSequences")
    def stop_sequences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of stop sequences
        """
        return pulumi.get(self, "stop_sequences")

    @stop_sequences.setter
    def stop_sequences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "stop_sequences", value)

    @property
    @pulumi.getter
    def temperature(self) -> Optional[pulumi.Input[float]]:
        """
        Controls randomness, higher values increase diversity
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "temperature", value)

    @property
    @pulumi.getter(name="topK")
    def top_k(self) -> Optional[pulumi.Input[float]]:
        """
        Sample from the k most likely next tokens
        """
        return pulumi.get(self, "top_k")

    @top_k.setter
    def top_k(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "top_k", value)

    @property
    @pulumi.getter(name="topP")
    def top_p(self) -> Optional[pulumi.Input[float]]:
        """
        Cumulative probability cutoff for token selection
        """
        return pulumi.get(self, "top_p")

    @top_p.setter
    def top_p(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "top_p", value)


@pulumi.input_type
class FlowPromptTemplateConfigurationPropertiesArgs:
    def __init__(__self__, *,
                 text: pulumi.Input['FlowTextPromptTemplateConfigurationArgs']):
        """
        Prompt template configuration
        """
        pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def text(self) -> pulumi.Input['FlowTextPromptTemplateConfigurationArgs']:
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input['FlowTextPromptTemplateConfigurationArgs']):
        pulumi.set(self, "text", value)


@pulumi.input_type
class FlowS3LocationArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 key: pulumi.Input[str],
                 version: Optional[pulumi.Input[str]] = None):
        """
        A bucket, key and optional version pointing to an S3 object containing a UTF-8 encoded JSON string Definition with the same schema as the Definition property of this resource
        :param pulumi.Input[str] bucket: A bucket in S3
        :param pulumi.Input[str] key: A object key in S3
        :param pulumi.Input[str] version: The version of the the S3 object to use
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "key", key)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        A bucket in S3
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        A object key in S3
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of the the S3 object to use
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class FlowTextPromptTemplateConfigurationArgs:
    def __init__(__self__, *,
                 text: pulumi.Input[str],
                 input_variables: Optional[pulumi.Input[Sequence[pulumi.Input['FlowPromptInputVariableArgs']]]] = None):
        """
        Configuration for text prompt template
        :param pulumi.Input[str] text: Prompt content for String prompt template
        :param pulumi.Input[Sequence[pulumi.Input['FlowPromptInputVariableArgs']]] input_variables: List of input variables
        """
        pulumi.set(__self__, "text", text)
        if input_variables is not None:
            pulumi.set(__self__, "input_variables", input_variables)

    @property
    @pulumi.getter
    def text(self) -> pulumi.Input[str]:
        """
        Prompt content for String prompt template
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input[str]):
        pulumi.set(self, "text", value)

    @property
    @pulumi.getter(name="inputVariables")
    def input_variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FlowPromptInputVariableArgs']]]]:
        """
        List of input variables
        """
        return pulumi.get(self, "input_variables")

    @input_variables.setter
    def input_variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FlowPromptInputVariableArgs']]]]):
        pulumi.set(self, "input_variables", value)


@pulumi.input_type
class GuardrailContentFilterConfigArgs:
    def __init__(__self__, *,
                 input_strength: pulumi.Input['GuardrailFilterStrength'],
                 output_strength: pulumi.Input['GuardrailFilterStrength'],
                 type: pulumi.Input['GuardrailContentFilterType']):
        """
        Content filter config in content policy.
        :param pulumi.Input['GuardrailFilterStrength'] input_strength: The strength of the content filter to apply to prompts. As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.
        :param pulumi.Input['GuardrailFilterStrength'] output_strength: The strength of the content filter to apply to model responses. As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.
        :param pulumi.Input['GuardrailContentFilterType'] type: The harmful category that the content filter is applied to.
        """
        pulumi.set(__self__, "input_strength", input_strength)
        pulumi.set(__self__, "output_strength", output_strength)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="inputStrength")
    def input_strength(self) -> pulumi.Input['GuardrailFilterStrength']:
        """
        The strength of the content filter to apply to prompts. As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.
        """
        return pulumi.get(self, "input_strength")

    @input_strength.setter
    def input_strength(self, value: pulumi.Input['GuardrailFilterStrength']):
        pulumi.set(self, "input_strength", value)

    @property
    @pulumi.getter(name="outputStrength")
    def output_strength(self) -> pulumi.Input['GuardrailFilterStrength']:
        """
        The strength of the content filter to apply to model responses. As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.
        """
        return pulumi.get(self, "output_strength")

    @output_strength.setter
    def output_strength(self, value: pulumi.Input['GuardrailFilterStrength']):
        pulumi.set(self, "output_strength", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input['GuardrailContentFilterType']:
        """
        The harmful category that the content filter is applied to.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['GuardrailContentFilterType']):
        pulumi.set(self, "type", value)


@pulumi.input_type
class GuardrailContentPolicyConfigArgs:
    def __init__(__self__, *,
                 filters_config: pulumi.Input[Sequence[pulumi.Input['GuardrailContentFilterConfigArgs']]]):
        """
        Content policy config for a guardrail.
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailContentFilterConfigArgs']]] filters_config: List of content filter configs in content policy.
        """
        pulumi.set(__self__, "filters_config", filters_config)

    @property
    @pulumi.getter(name="filtersConfig")
    def filters_config(self) -> pulumi.Input[Sequence[pulumi.Input['GuardrailContentFilterConfigArgs']]]:
        """
        List of content filter configs in content policy.
        """
        return pulumi.get(self, "filters_config")

    @filters_config.setter
    def filters_config(self, value: pulumi.Input[Sequence[pulumi.Input['GuardrailContentFilterConfigArgs']]]):
        pulumi.set(self, "filters_config", value)


@pulumi.input_type
class GuardrailContextualGroundingFilterConfigArgs:
    def __init__(__self__, *,
                 threshold: pulumi.Input[float],
                 type: pulumi.Input['GuardrailContextualGroundingFilterType']):
        """
        A config for grounding filter.
        :param pulumi.Input[float] threshold: The threshold for this filter.
        :param pulumi.Input['GuardrailContextualGroundingFilterType'] type: The filter details for the guardrails contextual grounding filter.
        """
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[float]:
        """
        The threshold for this filter.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[float]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input['GuardrailContextualGroundingFilterType']:
        """
        The filter details for the guardrails contextual grounding filter.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['GuardrailContextualGroundingFilterType']):
        pulumi.set(self, "type", value)


@pulumi.input_type
class GuardrailContextualGroundingPolicyConfigArgs:
    def __init__(__self__, *,
                 filters_config: pulumi.Input[Sequence[pulumi.Input['GuardrailContextualGroundingFilterConfigArgs']]]):
        """
        Contextual grounding policy config for a guardrail.
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailContextualGroundingFilterConfigArgs']]] filters_config: List of contextual grounding filter configs.
        """
        pulumi.set(__self__, "filters_config", filters_config)

    @property
    @pulumi.getter(name="filtersConfig")
    def filters_config(self) -> pulumi.Input[Sequence[pulumi.Input['GuardrailContextualGroundingFilterConfigArgs']]]:
        """
        List of contextual grounding filter configs.
        """
        return pulumi.get(self, "filters_config")

    @filters_config.setter
    def filters_config(self, value: pulumi.Input[Sequence[pulumi.Input['GuardrailContextualGroundingFilterConfigArgs']]]):
        pulumi.set(self, "filters_config", value)


@pulumi.input_type
class GuardrailManagedWordsConfigArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['GuardrailManagedWordsType']):
        """
        A managed words config.
        :param pulumi.Input['GuardrailManagedWordsType'] type: The managed word type to configure for the guardrail.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input['GuardrailManagedWordsType']:
        """
        The managed word type to configure for the guardrail.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['GuardrailManagedWordsType']):
        pulumi.set(self, "type", value)


@pulumi.input_type
class GuardrailPiiEntityConfigArgs:
    def __init__(__self__, *,
                 action: pulumi.Input['GuardrailSensitiveInformationAction'],
                 type: pulumi.Input['GuardrailPiiEntityType']):
        """
        Pii entity configuration.
        :param pulumi.Input['GuardrailSensitiveInformationAction'] action: Configure guardrail action when the PII entity is detected.
        :param pulumi.Input['GuardrailPiiEntityType'] type: Configure guardrail type when the PII entity is detected.
               
               The following PIIs are used to block or mask sensitive information:
               
               - *General*
               
               - *ADDRESS*
               
               A physical address, such as "100 Main Street, Anytown, USA" or "Suite #12, Building 123". An address can include information such as the street, building, location, city, state, country, county, zip code, precinct, and neighborhood.
               - *AGE*
               
               An individual's age, including the quantity and unit of time. For example, in the phrase "I am 40 years old," Guarrails recognizes "40 years" as an age.
               - *NAME*
               
               An individual's name. This entity type does not include titles, such as Dr., Mr., Mrs., or Miss. guardrails doesn't apply this entity type to names that are part of organizations or addresses. For example, guardrails recognizes the "John Doe Organization" as an organization, and it recognizes "Jane Doe Street" as an address.
               - *EMAIL*
               
               An email address, such as *marymajor@email.com* .
               - *PHONE*
               
               A phone number. This entity type also includes fax and pager numbers.
               - *USERNAME*
               
               A user name that identifies an account, such as a login name, screen name, nick name, or handle.
               - *PASSWORD*
               
               An alphanumeric string that is used as a password, such as "* *very20special#pass** ".
               - *DRIVER_ID*
               
               The number assigned to a driver's license, which is an official document permitting an individual to operate one or more motorized vehicles on a public road. A driver's license number consists of alphanumeric characters.
               - *LICENSE_PLATE*
               
               A license plate for a vehicle is issued by the state or country where the vehicle is registered. The format for passenger vehicles is typically five to eight digits, consisting of upper-case letters and numbers. The format varies depending on the location of the issuing state or country.
               - *VEHICLE_IDENTIFICATION_NUMBER*
               
               A Vehicle Identification Number (VIN) uniquely identifies a vehicle. VIN content and format are defined in the *ISO 3779* specification. Each country has specific codes and formats for VINs.
               - *Finance*
               
               - *REDIT_DEBIT_CARD_CVV*
               
               A three-digit card verification code (CVV) that is present on VISA, MasterCard, and Discover credit and debit cards. For American Express credit or debit cards, the CVV is a four-digit numeric code.
               - *CREDIT_DEBIT_CARD_EXPIRY*
               
               The expiration date for a credit or debit card. This number is usually four digits long and is often formatted as *month/year* or *MM/YY* . Guardrails recognizes expiration dates such as *01/21* , *01/2021* , and *Jan 2021* .
               - *CREDIT_DEBIT_CARD_NUMBER*
               
               The number for a credit or debit card. These numbers can vary from 13 to 16 digits in length. However, Amazon Comprehend also recognizes credit or debit card numbers when only the last four digits are present.
               - *PIN*
               
               A four-digit personal identification number (PIN) with which you can access your bank account.
               - *INTERNATIONAL_BANK_ACCOUNT_NUMBER*
               
               An International Bank Account Number has specific formats in each country. For more information, see [www.iban.com/structure](https://docs.aws.amazon.com/https://www.iban.com/structure) .
               - *SWIFT_CODE*
               
               A SWIFT code is a standard format of Bank Identifier Code (BIC) used to specify a particular bank or branch. Banks use these codes for money transfers such as international wire transfers.
               
               SWIFT codes consist of eight or 11 characters. The 11-digit codes refer to specific branches, while eight-digit codes (or 11-digit codes ending in 'XXX') refer to the head or primary office.
               - *IT*
               
               - *IP_ADDRESS*
               
               An IPv4 address, such as *198.51.100.0* .
               - *MAC_ADDRESS*
               
               A *media access control* (MAC) address is a unique identifier assigned to a network interface controller (NIC).
               - *URL*
               
               A web address, such as *www.example.com* .
               - *AWS_ACCESS_KEY*
               
               A unique identifier that's associated with a secret access key; you use the access key ID and secret access key to sign programmatic AWS requests cryptographically.
               - *AWS_SECRET_KEY*
               
               A unique identifier that's associated with an access key. You use the access key ID and secret access key to sign programmatic AWS requests cryptographically.
               - *USA specific*
               
               - *US_BANK_ACCOUNT_NUMBER*
               
               A US bank account number, which is typically 10 to 12 digits long.
               - *US_BANK_ROUTING_NUMBER*
               
               A US bank account routing number. These are typically nine digits long,
               - *US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER*
               
               A US Individual Taxpayer Identification Number (ITIN) is a nine-digit number that starts with a "9" and contain a "7" or "8" as the fourth digit. An ITIN can be formatted with a space or a dash after the third and forth digits.
               - *US_PASSPORT_NUMBER*
               
               A US passport number. Passport numbers range from six to nine alphanumeric characters.
               - *US_SOCIAL_SECURITY_NUMBER*
               
               A US Social Security Number (SSN) is a nine-digit number that is issued to US citizens, permanent residents, and temporary working residents.
               - *Canada specific*
               
               - *CA_HEALTH_NUMBER*
               
               A Canadian Health Service Number is a 10-digit unique identifier, required for individuals to access healthcare benefits.
               - *CA_SOCIAL_INSURANCE_NUMBER*
               
               A Canadian Social Insurance Number (SIN) is a nine-digit unique identifier, required for individuals to access government programs and benefits.
               
               The SIN is formatted as three groups of three digits, such as *123-456-789* . A SIN can be validated through a simple check-digit process called the [Luhn algorithm](https://docs.aws.amazon.com/https://www.wikipedia.org/wiki/Luhn_algorithm) .
               - *UK Specific*
               
               - *UK_NATIONAL_HEALTH_SERVICE_NUMBER*
               
               A UK National Health Service Number is a 10-17 digit number, such as *485 777 3456* . The current system formats the 10-digit number with spaces after the third and sixth digits. The final digit is an error-detecting checksum.
               - *UK_NATIONAL_INSURANCE_NUMBER*
               
               A UK National Insurance Number (NINO) provides individuals with access to National Insurance (social security) benefits. It is also used for some purposes in the UK tax system.
               
               The number is nine digits long and starts with two letters, followed by six numbers and one letter. A NINO can be formatted with a space or a dash after the two letters and after the second, forth, and sixth digits.
               - *UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER*
               
               A UK Unique Taxpayer Reference (UTR) is a 10-digit number that identifies a taxpayer or a business.
               - *Custom*
               
               - *Regex filter* - You can use a regular expressions to define patterns for a guardrail to recognize and act upon such as serial number, booking ID etc..
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input['GuardrailSensitiveInformationAction']:
        """
        Configure guardrail action when the PII entity is detected.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input['GuardrailSensitiveInformationAction']):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input['GuardrailPiiEntityType']:
        """
        Configure guardrail type when the PII entity is detected.

        The following PIIs are used to block or mask sensitive information:

        - *General*

        - *ADDRESS*

        A physical address, such as "100 Main Street, Anytown, USA" or "Suite #12, Building 123". An address can include information such as the street, building, location, city, state, country, county, zip code, precinct, and neighborhood.
        - *AGE*

        An individual's age, including the quantity and unit of time. For example, in the phrase "I am 40 years old," Guarrails recognizes "40 years" as an age.
        - *NAME*

        An individual's name. This entity type does not include titles, such as Dr., Mr., Mrs., or Miss. guardrails doesn't apply this entity type to names that are part of organizations or addresses. For example, guardrails recognizes the "John Doe Organization" as an organization, and it recognizes "Jane Doe Street" as an address.
        - *EMAIL*

        An email address, such as *marymajor@email.com* .
        - *PHONE*

        A phone number. This entity type also includes fax and pager numbers.
        - *USERNAME*

        A user name that identifies an account, such as a login name, screen name, nick name, or handle.
        - *PASSWORD*

        An alphanumeric string that is used as a password, such as "* *very20special#pass** ".
        - *DRIVER_ID*

        The number assigned to a driver's license, which is an official document permitting an individual to operate one or more motorized vehicles on a public road. A driver's license number consists of alphanumeric characters.
        - *LICENSE_PLATE*

        A license plate for a vehicle is issued by the state or country where the vehicle is registered. The format for passenger vehicles is typically five to eight digits, consisting of upper-case letters and numbers. The format varies depending on the location of the issuing state or country.
        - *VEHICLE_IDENTIFICATION_NUMBER*

        A Vehicle Identification Number (VIN) uniquely identifies a vehicle. VIN content and format are defined in the *ISO 3779* specification. Each country has specific codes and formats for VINs.
        - *Finance*

        - *REDIT_DEBIT_CARD_CVV*

        A three-digit card verification code (CVV) that is present on VISA, MasterCard, and Discover credit and debit cards. For American Express credit or debit cards, the CVV is a four-digit numeric code.
        - *CREDIT_DEBIT_CARD_EXPIRY*

        The expiration date for a credit or debit card. This number is usually four digits long and is often formatted as *month/year* or *MM/YY* . Guardrails recognizes expiration dates such as *01/21* , *01/2021* , and *Jan 2021* .
        - *CREDIT_DEBIT_CARD_NUMBER*

        The number for a credit or debit card. These numbers can vary from 13 to 16 digits in length. However, Amazon Comprehend also recognizes credit or debit card numbers when only the last four digits are present.
        - *PIN*

        A four-digit personal identification number (PIN) with which you can access your bank account.
        - *INTERNATIONAL_BANK_ACCOUNT_NUMBER*

        An International Bank Account Number has specific formats in each country. For more information, see [www.iban.com/structure](https://docs.aws.amazon.com/https://www.iban.com/structure) .
        - *SWIFT_CODE*

        A SWIFT code is a standard format of Bank Identifier Code (BIC) used to specify a particular bank or branch. Banks use these codes for money transfers such as international wire transfers.

        SWIFT codes consist of eight or 11 characters. The 11-digit codes refer to specific branches, while eight-digit codes (or 11-digit codes ending in 'XXX') refer to the head or primary office.
        - *IT*

        - *IP_ADDRESS*

        An IPv4 address, such as *198.51.100.0* .
        - *MAC_ADDRESS*

        A *media access control* (MAC) address is a unique identifier assigned to a network interface controller (NIC).
        - *URL*

        A web address, such as *www.example.com* .
        - *AWS_ACCESS_KEY*

        A unique identifier that's associated with a secret access key; you use the access key ID and secret access key to sign programmatic AWS requests cryptographically.
        - *AWS_SECRET_KEY*

        A unique identifier that's associated with an access key. You use the access key ID and secret access key to sign programmatic AWS requests cryptographically.
        - *USA specific*

        - *US_BANK_ACCOUNT_NUMBER*

        A US bank account number, which is typically 10 to 12 digits long.
        - *US_BANK_ROUTING_NUMBER*

        A US bank account routing number. These are typically nine digits long,
        - *US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER*

        A US Individual Taxpayer Identification Number (ITIN) is a nine-digit number that starts with a "9" and contain a "7" or "8" as the fourth digit. An ITIN can be formatted with a space or a dash after the third and forth digits.
        - *US_PASSPORT_NUMBER*

        A US passport number. Passport numbers range from six to nine alphanumeric characters.
        - *US_SOCIAL_SECURITY_NUMBER*

        A US Social Security Number (SSN) is a nine-digit number that is issued to US citizens, permanent residents, and temporary working residents.
        - *Canada specific*

        - *CA_HEALTH_NUMBER*

        A Canadian Health Service Number is a 10-digit unique identifier, required for individuals to access healthcare benefits.
        - *CA_SOCIAL_INSURANCE_NUMBER*

        A Canadian Social Insurance Number (SIN) is a nine-digit unique identifier, required for individuals to access government programs and benefits.

        The SIN is formatted as three groups of three digits, such as *123-456-789* . A SIN can be validated through a simple check-digit process called the [Luhn algorithm](https://docs.aws.amazon.com/https://www.wikipedia.org/wiki/Luhn_algorithm) .
        - *UK Specific*

        - *UK_NATIONAL_HEALTH_SERVICE_NUMBER*

        A UK National Health Service Number is a 10-17 digit number, such as *485 777 3456* . The current system formats the 10-digit number with spaces after the third and sixth digits. The final digit is an error-detecting checksum.
        - *UK_NATIONAL_INSURANCE_NUMBER*

        A UK National Insurance Number (NINO) provides individuals with access to National Insurance (social security) benefits. It is also used for some purposes in the UK tax system.

        The number is nine digits long and starts with two letters, followed by six numbers and one letter. A NINO can be formatted with a space or a dash after the two letters and after the second, forth, and sixth digits.
        - *UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER*

        A UK Unique Taxpayer Reference (UTR) is a 10-digit number that identifies a taxpayer or a business.
        - *Custom*

        - *Regex filter* - You can use a regular expressions to define patterns for a guardrail to recognize and act upon such as serial number, booking ID etc..
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['GuardrailPiiEntityType']):
        pulumi.set(self, "type", value)


@pulumi.input_type
class GuardrailRegexConfigArgs:
    def __init__(__self__, *,
                 action: pulumi.Input['GuardrailSensitiveInformationAction'],
                 name: pulumi.Input[str],
                 pattern: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        """
        A regex configuration.
        :param pulumi.Input['GuardrailSensitiveInformationAction'] action: The guardrail action to configure when matching regular expression is detected.
        :param pulumi.Input[str] name: The regex name.
        :param pulumi.Input[str] pattern: The regex pattern.
        :param pulumi.Input[str] description: The regex description.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pattern", pattern)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input['GuardrailSensitiveInformationAction']:
        """
        The guardrail action to configure when matching regular expression is detected.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input['GuardrailSensitiveInformationAction']):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The regex name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def pattern(self) -> pulumi.Input[str]:
        """
        The regex pattern.
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: pulumi.Input[str]):
        pulumi.set(self, "pattern", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The regex description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


@pulumi.input_type
class GuardrailSensitiveInformationPolicyConfigArgs:
    def __init__(__self__, *,
                 pii_entities_config: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailPiiEntityConfigArgs']]]] = None,
                 regexes_config: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailRegexConfigArgs']]]] = None):
        """
        Sensitive information policy config for a guardrail.
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailPiiEntityConfigArgs']]] pii_entities_config: List of entities.
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailRegexConfigArgs']]] regexes_config: List of regex.
        """
        if pii_entities_config is not None:
            pulumi.set(__self__, "pii_entities_config", pii_entities_config)
        if regexes_config is not None:
            pulumi.set(__self__, "regexes_config", regexes_config)

    @property
    @pulumi.getter(name="piiEntitiesConfig")
    def pii_entities_config(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailPiiEntityConfigArgs']]]]:
        """
        List of entities.
        """
        return pulumi.get(self, "pii_entities_config")

    @pii_entities_config.setter
    def pii_entities_config(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailPiiEntityConfigArgs']]]]):
        pulumi.set(self, "pii_entities_config", value)

    @property
    @pulumi.getter(name="regexesConfig")
    def regexes_config(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailRegexConfigArgs']]]]:
        """
        List of regex.
        """
        return pulumi.get(self, "regexes_config")

    @regexes_config.setter
    def regexes_config(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailRegexConfigArgs']]]]):
        pulumi.set(self, "regexes_config", value)


@pulumi.input_type
class GuardrailTopicConfigArgs:
    def __init__(__self__, *,
                 definition: pulumi.Input[str],
                 name: pulumi.Input[str],
                 type: pulumi.Input['GuardrailTopicType'],
                 examples: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Topic config in topic policy.
        :param pulumi.Input[str] definition: Definition of topic in topic policy
        :param pulumi.Input[str] name: Name of topic in topic policy
        :param pulumi.Input['GuardrailTopicType'] type: Specifies to deny the topic.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] examples: List of text examples
        """
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if examples is not None:
            pulumi.set(__self__, "examples", examples)

    @property
    @pulumi.getter
    def definition(self) -> pulumi.Input[str]:
        """
        Definition of topic in topic policy
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: pulumi.Input[str]):
        pulumi.set(self, "definition", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of topic in topic policy
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input['GuardrailTopicType']:
        """
        Specifies to deny the topic.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['GuardrailTopicType']):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def examples(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of text examples
        """
        return pulumi.get(self, "examples")

    @examples.setter
    def examples(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "examples", value)


@pulumi.input_type
class GuardrailTopicPolicyConfigArgs:
    def __init__(__self__, *,
                 topics_config: pulumi.Input[Sequence[pulumi.Input['GuardrailTopicConfigArgs']]]):
        """
        Topic policy config for a guardrail.
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailTopicConfigArgs']]] topics_config: List of topic configs in topic policy.
        """
        pulumi.set(__self__, "topics_config", topics_config)

    @property
    @pulumi.getter(name="topicsConfig")
    def topics_config(self) -> pulumi.Input[Sequence[pulumi.Input['GuardrailTopicConfigArgs']]]:
        """
        List of topic configs in topic policy.
        """
        return pulumi.get(self, "topics_config")

    @topics_config.setter
    def topics_config(self, value: pulumi.Input[Sequence[pulumi.Input['GuardrailTopicConfigArgs']]]):
        pulumi.set(self, "topics_config", value)


@pulumi.input_type
class GuardrailWordConfigArgs:
    def __init__(__self__, *,
                 text: pulumi.Input[str]):
        """
        A custom word config.
        :param pulumi.Input[str] text: The custom word text.
        """
        pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def text(self) -> pulumi.Input[str]:
        """
        The custom word text.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input[str]):
        pulumi.set(self, "text", value)


@pulumi.input_type
class GuardrailWordPolicyConfigArgs:
    def __init__(__self__, *,
                 managed_word_lists_config: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailManagedWordsConfigArgs']]]] = None,
                 words_config: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailWordConfigArgs']]]] = None):
        """
        Word policy config for a guardrail.
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailManagedWordsConfigArgs']]] managed_word_lists_config: A config for the list of managed words.
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailWordConfigArgs']]] words_config: List of custom word configs.
        """
        if managed_word_lists_config is not None:
            pulumi.set(__self__, "managed_word_lists_config", managed_word_lists_config)
        if words_config is not None:
            pulumi.set(__self__, "words_config", words_config)

    @property
    @pulumi.getter(name="managedWordListsConfig")
    def managed_word_lists_config(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailManagedWordsConfigArgs']]]]:
        """
        A config for the list of managed words.
        """
        return pulumi.get(self, "managed_word_lists_config")

    @managed_word_lists_config.setter
    def managed_word_lists_config(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailManagedWordsConfigArgs']]]]):
        pulumi.set(self, "managed_word_lists_config", value)

    @property
    @pulumi.getter(name="wordsConfig")
    def words_config(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailWordConfigArgs']]]]:
        """
        List of custom word configs.
        """
        return pulumi.get(self, "words_config")

    @words_config.setter
    def words_config(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GuardrailWordConfigArgs']]]]):
        pulumi.set(self, "words_config", value)


@pulumi.input_type
class KnowledgeBaseBedrockEmbeddingModelConfigurationArgs:
    def __init__(__self__, *,
                 dimensions: Optional[pulumi.Input[int]] = None):
        """
        The vector configuration details for the Bedrock embeddings model.
        :param pulumi.Input[int] dimensions: The dimensions details for the vector configuration used on the Bedrock embeddings model.
        """
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)

    @property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[int]]:
        """
        The dimensions details for the vector configuration used on the Bedrock embeddings model.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "dimensions", value)


@pulumi.input_type
class KnowledgeBaseConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['KnowledgeBaseType'],
                 vector_knowledge_base_configuration: pulumi.Input['KnowledgeBaseVectorKnowledgeBaseConfigurationArgs']):
        """
        Contains details about the embeddings model used for the knowledge base.
        :param pulumi.Input['KnowledgeBaseType'] type: The type of data that the data source is converted into for the knowledge base.
        :param pulumi.Input['KnowledgeBaseVectorKnowledgeBaseConfigurationArgs'] vector_knowledge_base_configuration: Contains details about the embeddings model that'sused to convert the data source.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vector_knowledge_base_configuration", vector_knowledge_base_configuration)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input['KnowledgeBaseType']:
        """
        The type of data that the data source is converted into for the knowledge base.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['KnowledgeBaseType']):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="vectorKnowledgeBaseConfiguration")
    def vector_knowledge_base_configuration(self) -> pulumi.Input['KnowledgeBaseVectorKnowledgeBaseConfigurationArgs']:
        """
        Contains details about the embeddings model that'sused to convert the data source.
        """
        return pulumi.get(self, "vector_knowledge_base_configuration")

    @vector_knowledge_base_configuration.setter
    def vector_knowledge_base_configuration(self, value: pulumi.Input['KnowledgeBaseVectorKnowledgeBaseConfigurationArgs']):
        pulumi.set(self, "vector_knowledge_base_configuration", value)


@pulumi.input_type
class KnowledgeBaseEmbeddingModelConfigurationArgs:
    def __init__(__self__, *,
                 bedrock_embedding_model_configuration: Optional[pulumi.Input['KnowledgeBaseBedrockEmbeddingModelConfigurationArgs']] = None):
        """
        The embeddings model configuration details for the vector model used in Knowledge Base.
        :param pulumi.Input['KnowledgeBaseBedrockEmbeddingModelConfigurationArgs'] bedrock_embedding_model_configuration: The vector configuration details on the Bedrock embeddings model.
        """
        if bedrock_embedding_model_configuration is not None:
            pulumi.set(__self__, "bedrock_embedding_model_configuration", bedrock_embedding_model_configuration)

    @property
    @pulumi.getter(name="bedrockEmbeddingModelConfiguration")
    def bedrock_embedding_model_configuration(self) -> Optional[pulumi.Input['KnowledgeBaseBedrockEmbeddingModelConfigurationArgs']]:
        """
        The vector configuration details on the Bedrock embeddings model.
        """
        return pulumi.get(self, "bedrock_embedding_model_configuration")

    @bedrock_embedding_model_configuration.setter
    def bedrock_embedding_model_configuration(self, value: Optional[pulumi.Input['KnowledgeBaseBedrockEmbeddingModelConfigurationArgs']]):
        pulumi.set(self, "bedrock_embedding_model_configuration", value)


@pulumi.input_type
class KnowledgeBaseMongoDbAtlasConfigurationArgs:
    def __init__(__self__, *,
                 collection_name: pulumi.Input[str],
                 credentials_secret_arn: pulumi.Input[str],
                 database_name: pulumi.Input[str],
                 endpoint: pulumi.Input[str],
                 field_mapping: pulumi.Input['KnowledgeBaseMongoDbAtlasFieldMappingArgs'],
                 vector_index_name: pulumi.Input[str],
                 endpoint_service_name: Optional[pulumi.Input[str]] = None):
        """
        Contains the storage configuration of the knowledge base in MongoDb Atlas Cloud.
        :param pulumi.Input[str] collection_name: Name of the collection within MongoDB Atlas.
        :param pulumi.Input[str] credentials_secret_arn: The ARN of the secret that you created in AWS Secrets Manager that is linked to your Amazon Mongo database.
        :param pulumi.Input[str] database_name: Name of the database within MongoDB Atlas.
        :param pulumi.Input[str] endpoint: MongoDB Atlas endpoint.
        :param pulumi.Input['KnowledgeBaseMongoDbAtlasFieldMappingArgs'] field_mapping: Contains the names of the fields to which to map information about the vector store.
        :param pulumi.Input[str] vector_index_name: Name of a MongoDB Atlas index.
        :param pulumi.Input[str] endpoint_service_name: MongoDB Atlas endpoint service name.
        """
        pulumi.set(__self__, "collection_name", collection_name)
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "field_mapping", field_mapping)
        pulumi.set(__self__, "vector_index_name", vector_index_name)
        if endpoint_service_name is not None:
            pulumi.set(__self__, "endpoint_service_name", endpoint_service_name)

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> pulumi.Input[str]:
        """
        Name of the collection within MongoDB Atlas.
        """
        return pulumi.get(self, "collection_name")

    @collection_name.setter
    def collection_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "collection_name", value)

    @property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the secret that you created in AWS Secrets Manager that is linked to your Amazon Mongo database.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @credentials_secret_arn.setter
    def credentials_secret_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "credentials_secret_arn", value)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[str]:
        """
        Name of the database within MongoDB Atlas.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[str]:
        """
        MongoDB Atlas endpoint.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> pulumi.Input['KnowledgeBaseMongoDbAtlasFieldMappingArgs']:
        """
        Contains the names of the fields to which to map information about the vector store.
        """
        return pulumi.get(self, "field_mapping")

    @field_mapping.setter
    def field_mapping(self, value: pulumi.Input['KnowledgeBaseMongoDbAtlasFieldMappingArgs']):
        pulumi.set(self, "field_mapping", value)

    @property
    @pulumi.getter(name="vectorIndexName")
    def vector_index_name(self) -> pulumi.Input[str]:
        """
        Name of a MongoDB Atlas index.
        """
        return pulumi.get(self, "vector_index_name")

    @vector_index_name.setter
    def vector_index_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "vector_index_name", value)

    @property
    @pulumi.getter(name="endpointServiceName")
    def endpoint_service_name(self) -> Optional[pulumi.Input[str]]:
        """
        MongoDB Atlas endpoint service name.
        """
        return pulumi.get(self, "endpoint_service_name")

    @endpoint_service_name.setter
    def endpoint_service_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint_service_name", value)


@pulumi.input_type
class KnowledgeBaseMongoDbAtlasFieldMappingArgs:
    def __init__(__self__, *,
                 metadata_field: pulumi.Input[str],
                 text_field: pulumi.Input[str],
                 vector_field: pulumi.Input[str]):
        """
        Contains the names of the fields to which to map information about the vector store.
        :param pulumi.Input[str] metadata_field: The name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param pulumi.Input[str] text_field: The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        :param pulumi.Input[str] vector_field: The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        pulumi.set(__self__, "metadata_field", metadata_field)
        pulumi.set(__self__, "text_field", text_field)
        pulumi.set(__self__, "vector_field", vector_field)

    @property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> pulumi.Input[str]:
        """
        The name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @metadata_field.setter
    def metadata_field(self, value: pulumi.Input[str]):
        pulumi.set(self, "metadata_field", value)

    @property
    @pulumi.getter(name="textField")
    def text_field(self) -> pulumi.Input[str]:
        """
        The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")

    @text_field.setter
    def text_field(self, value: pulumi.Input[str]):
        pulumi.set(self, "text_field", value)

    @property
    @pulumi.getter(name="vectorField")
    def vector_field(self) -> pulumi.Input[str]:
        """
        The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        return pulumi.get(self, "vector_field")

    @vector_field.setter
    def vector_field(self, value: pulumi.Input[str]):
        pulumi.set(self, "vector_field", value)


@pulumi.input_type
class KnowledgeBaseOpenSearchServerlessConfigurationArgs:
    def __init__(__self__, *,
                 collection_arn: pulumi.Input[str],
                 field_mapping: pulumi.Input['KnowledgeBaseOpenSearchServerlessFieldMappingArgs'],
                 vector_index_name: pulumi.Input[str]):
        """
        Contains the storage configuration of the knowledge base in Amazon OpenSearch Service.
        :param pulumi.Input[str] collection_arn: The ARN of the OpenSearch Service vector store.
        :param pulumi.Input['KnowledgeBaseOpenSearchServerlessFieldMappingArgs'] field_mapping: Contains the names of the fields to which to map information about the vector store.
        :param pulumi.Input[str] vector_index_name: The name of the vector store.
        """
        pulumi.set(__self__, "collection_arn", collection_arn)
        pulumi.set(__self__, "field_mapping", field_mapping)
        pulumi.set(__self__, "vector_index_name", vector_index_name)

    @property
    @pulumi.getter(name="collectionArn")
    def collection_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the OpenSearch Service vector store.
        """
        return pulumi.get(self, "collection_arn")

    @collection_arn.setter
    def collection_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "collection_arn", value)

    @property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> pulumi.Input['KnowledgeBaseOpenSearchServerlessFieldMappingArgs']:
        """
        Contains the names of the fields to which to map information about the vector store.
        """
        return pulumi.get(self, "field_mapping")

    @field_mapping.setter
    def field_mapping(self, value: pulumi.Input['KnowledgeBaseOpenSearchServerlessFieldMappingArgs']):
        pulumi.set(self, "field_mapping", value)

    @property
    @pulumi.getter(name="vectorIndexName")
    def vector_index_name(self) -> pulumi.Input[str]:
        """
        The name of the vector store.
        """
        return pulumi.get(self, "vector_index_name")

    @vector_index_name.setter
    def vector_index_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "vector_index_name", value)


@pulumi.input_type
class KnowledgeBaseOpenSearchServerlessFieldMappingArgs:
    def __init__(__self__, *,
                 metadata_field: pulumi.Input[str],
                 text_field: pulumi.Input[str],
                 vector_field: pulumi.Input[str]):
        """
        A mapping of Bedrock Knowledge Base fields to OpenSearch Serverless field names
        :param pulumi.Input[str] metadata_field: The name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param pulumi.Input[str] text_field: The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        :param pulumi.Input[str] vector_field: The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        pulumi.set(__self__, "metadata_field", metadata_field)
        pulumi.set(__self__, "text_field", text_field)
        pulumi.set(__self__, "vector_field", vector_field)

    @property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> pulumi.Input[str]:
        """
        The name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @metadata_field.setter
    def metadata_field(self, value: pulumi.Input[str]):
        pulumi.set(self, "metadata_field", value)

    @property
    @pulumi.getter(name="textField")
    def text_field(self) -> pulumi.Input[str]:
        """
        The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")

    @text_field.setter
    def text_field(self, value: pulumi.Input[str]):
        pulumi.set(self, "text_field", value)

    @property
    @pulumi.getter(name="vectorField")
    def vector_field(self) -> pulumi.Input[str]:
        """
        The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        return pulumi.get(self, "vector_field")

    @vector_field.setter
    def vector_field(self, value: pulumi.Input[str]):
        pulumi.set(self, "vector_field", value)


@pulumi.input_type
class KnowledgeBasePineconeConfigurationArgs:
    def __init__(__self__, *,
                 connection_string: pulumi.Input[str],
                 credentials_secret_arn: pulumi.Input[str],
                 field_mapping: pulumi.Input['KnowledgeBasePineconeFieldMappingArgs'],
                 namespace: Optional[pulumi.Input[str]] = None):
        """
        Contains the storage configuration of the knowledge base in Pinecone.
        :param pulumi.Input[str] connection_string: The endpoint URL for your index management page.
        :param pulumi.Input[str] credentials_secret_arn: The ARN of the secret that you created in AWS Secrets Manager that is linked to your Pinecone API key.
        :param pulumi.Input['KnowledgeBasePineconeFieldMappingArgs'] field_mapping: Contains the names of the fields to which to map information about the vector store.
        :param pulumi.Input[str] namespace: The namespace to be used to write new data to your database.
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "field_mapping", field_mapping)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> pulumi.Input[str]:
        """
        The endpoint URL for your index management page.
        """
        return pulumi.get(self, "connection_string")

    @connection_string.setter
    def connection_string(self, value: pulumi.Input[str]):
        pulumi.set(self, "connection_string", value)

    @property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the secret that you created in AWS Secrets Manager that is linked to your Pinecone API key.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @credentials_secret_arn.setter
    def credentials_secret_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "credentials_secret_arn", value)

    @property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> pulumi.Input['KnowledgeBasePineconeFieldMappingArgs']:
        """
        Contains the names of the fields to which to map information about the vector store.
        """
        return pulumi.get(self, "field_mapping")

    @field_mapping.setter
    def field_mapping(self, value: pulumi.Input['KnowledgeBasePineconeFieldMappingArgs']):
        pulumi.set(self, "field_mapping", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        The namespace to be used to write new data to your database.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)


@pulumi.input_type
class KnowledgeBasePineconeFieldMappingArgs:
    def __init__(__self__, *,
                 metadata_field: pulumi.Input[str],
                 text_field: pulumi.Input[str]):
        """
        Contains the names of the fields to which to map information about the vector store.
        :param pulumi.Input[str] metadata_field: The name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param pulumi.Input[str] text_field: The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        pulumi.set(__self__, "metadata_field", metadata_field)
        pulumi.set(__self__, "text_field", text_field)

    @property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> pulumi.Input[str]:
        """
        The name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @metadata_field.setter
    def metadata_field(self, value: pulumi.Input[str]):
        pulumi.set(self, "metadata_field", value)

    @property
    @pulumi.getter(name="textField")
    def text_field(self) -> pulumi.Input[str]:
        """
        The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")

    @text_field.setter
    def text_field(self, value: pulumi.Input[str]):
        pulumi.set(self, "text_field", value)


@pulumi.input_type
class KnowledgeBaseRdsConfigurationArgs:
    def __init__(__self__, *,
                 credentials_secret_arn: pulumi.Input[str],
                 database_name: pulumi.Input[str],
                 field_mapping: pulumi.Input['KnowledgeBaseRdsFieldMappingArgs'],
                 resource_arn: pulumi.Input[str],
                 table_name: pulumi.Input[str]):
        """
        Contains details about the storage configuration of the knowledge base in Amazon RDS. For more information, see Create a vector index in Amazon RDS.
        :param pulumi.Input[str] credentials_secret_arn: The ARN of the secret that you created in AWS Secrets Manager that is linked to your Amazon RDS database.
        :param pulumi.Input[str] database_name: The name of your Amazon RDS database.
        :param pulumi.Input['KnowledgeBaseRdsFieldMappingArgs'] field_mapping: Contains the names of the fields to which to map information about the vector store.
        :param pulumi.Input[str] resource_arn: The ARN of the vector store.
        :param pulumi.Input[str] table_name: The name of the table in the database.
        """
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "field_mapping", field_mapping)
        pulumi.set(__self__, "resource_arn", resource_arn)
        pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the secret that you created in AWS Secrets Manager that is linked to your Amazon RDS database.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @credentials_secret_arn.setter
    def credentials_secret_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "credentials_secret_arn", value)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[str]:
        """
        The name of your Amazon RDS database.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> pulumi.Input['KnowledgeBaseRdsFieldMappingArgs']:
        """
        Contains the names of the fields to which to map information about the vector store.
        """
        return pulumi.get(self, "field_mapping")

    @field_mapping.setter
    def field_mapping(self, value: pulumi.Input['KnowledgeBaseRdsFieldMappingArgs']):
        pulumi.set(self, "field_mapping", value)

    @property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the vector store.
        """
        return pulumi.get(self, "resource_arn")

    @resource_arn.setter
    def resource_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "resource_arn", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[str]:
        """
        The name of the table in the database.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "table_name", value)


@pulumi.input_type
class KnowledgeBaseRdsFieldMappingArgs:
    def __init__(__self__, *,
                 metadata_field: pulumi.Input[str],
                 primary_key_field: pulumi.Input[str],
                 text_field: pulumi.Input[str],
                 vector_field: pulumi.Input[str]):
        """
        Contains the names of the fields to which to map information about the vector store.
        :param pulumi.Input[str] metadata_field: The name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param pulumi.Input[str] primary_key_field: The name of the field in which Amazon Bedrock stores the ID for each entry.
        :param pulumi.Input[str] text_field: The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        :param pulumi.Input[str] vector_field: The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        pulumi.set(__self__, "metadata_field", metadata_field)
        pulumi.set(__self__, "primary_key_field", primary_key_field)
        pulumi.set(__self__, "text_field", text_field)
        pulumi.set(__self__, "vector_field", vector_field)

    @property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> pulumi.Input[str]:
        """
        The name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @metadata_field.setter
    def metadata_field(self, value: pulumi.Input[str]):
        pulumi.set(self, "metadata_field", value)

    @property
    @pulumi.getter(name="primaryKeyField")
    def primary_key_field(self) -> pulumi.Input[str]:
        """
        The name of the field in which Amazon Bedrock stores the ID for each entry.
        """
        return pulumi.get(self, "primary_key_field")

    @primary_key_field.setter
    def primary_key_field(self, value: pulumi.Input[str]):
        pulumi.set(self, "primary_key_field", value)

    @property
    @pulumi.getter(name="textField")
    def text_field(self) -> pulumi.Input[str]:
        """
        The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")

    @text_field.setter
    def text_field(self, value: pulumi.Input[str]):
        pulumi.set(self, "text_field", value)

    @property
    @pulumi.getter(name="vectorField")
    def vector_field(self) -> pulumi.Input[str]:
        """
        The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        return pulumi.get(self, "vector_field")

    @vector_field.setter
    def vector_field(self, value: pulumi.Input[str]):
        pulumi.set(self, "vector_field", value)


@pulumi.input_type
class KnowledgeBaseStorageConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input['KnowledgeBaseStorageType'],
                 mongo_db_atlas_configuration: Optional[pulumi.Input['KnowledgeBaseMongoDbAtlasConfigurationArgs']] = None,
                 opensearch_serverless_configuration: Optional[pulumi.Input['KnowledgeBaseOpenSearchServerlessConfigurationArgs']] = None,
                 pinecone_configuration: Optional[pulumi.Input['KnowledgeBasePineconeConfigurationArgs']] = None,
                 rds_configuration: Optional[pulumi.Input['KnowledgeBaseRdsConfigurationArgs']] = None):
        """
        The vector store service in which the knowledge base is stored.
        :param pulumi.Input['KnowledgeBaseStorageType'] type: The vector store service in which the knowledge base is stored.
        :param pulumi.Input['KnowledgeBaseMongoDbAtlasConfigurationArgs'] mongo_db_atlas_configuration: Contains the storage configuration of the knowledge base in MongoDB Atlas.
        :param pulumi.Input['KnowledgeBaseOpenSearchServerlessConfigurationArgs'] opensearch_serverless_configuration: Contains the storage configuration of the knowledge base in Amazon OpenSearch Service.
        :param pulumi.Input['KnowledgeBasePineconeConfigurationArgs'] pinecone_configuration: Contains the storage configuration of the knowledge base in Pinecone.
        :param pulumi.Input['KnowledgeBaseRdsConfigurationArgs'] rds_configuration: Contains details about the storage configuration of the knowledge base in Amazon RDS. For more information, see [Create a vector index in Amazon RDS](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-rds.html) .
        """
        pulumi.set(__self__, "type", type)
        if mongo_db_atlas_configuration is not None:
            pulumi.set(__self__, "mongo_db_atlas_configuration", mongo_db_atlas_configuration)
        if opensearch_serverless_configuration is not None:
            pulumi.set(__self__, "opensearch_serverless_configuration", opensearch_serverless_configuration)
        if pinecone_configuration is not None:
            pulumi.set(__self__, "pinecone_configuration", pinecone_configuration)
        if rds_configuration is not None:
            pulumi.set(__self__, "rds_configuration", rds_configuration)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input['KnowledgeBaseStorageType']:
        """
        The vector store service in which the knowledge base is stored.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['KnowledgeBaseStorageType']):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="mongoDbAtlasConfiguration")
    def mongo_db_atlas_configuration(self) -> Optional[pulumi.Input['KnowledgeBaseMongoDbAtlasConfigurationArgs']]:
        """
        Contains the storage configuration of the knowledge base in MongoDB Atlas.
        """
        return pulumi.get(self, "mongo_db_atlas_configuration")

    @mongo_db_atlas_configuration.setter
    def mongo_db_atlas_configuration(self, value: Optional[pulumi.Input['KnowledgeBaseMongoDbAtlasConfigurationArgs']]):
        pulumi.set(self, "mongo_db_atlas_configuration", value)

    @property
    @pulumi.getter(name="opensearchServerlessConfiguration")
    def opensearch_serverless_configuration(self) -> Optional[pulumi.Input['KnowledgeBaseOpenSearchServerlessConfigurationArgs']]:
        """
        Contains the storage configuration of the knowledge base in Amazon OpenSearch Service.
        """
        return pulumi.get(self, "opensearch_serverless_configuration")

    @opensearch_serverless_configuration.setter
    def opensearch_serverless_configuration(self, value: Optional[pulumi.Input['KnowledgeBaseOpenSearchServerlessConfigurationArgs']]):
        pulumi.set(self, "opensearch_serverless_configuration", value)

    @property
    @pulumi.getter(name="pineconeConfiguration")
    def pinecone_configuration(self) -> Optional[pulumi.Input['KnowledgeBasePineconeConfigurationArgs']]:
        """
        Contains the storage configuration of the knowledge base in Pinecone.
        """
        return pulumi.get(self, "pinecone_configuration")

    @pinecone_configuration.setter
    def pinecone_configuration(self, value: Optional[pulumi.Input['KnowledgeBasePineconeConfigurationArgs']]):
        pulumi.set(self, "pinecone_configuration", value)

    @property
    @pulumi.getter(name="rdsConfiguration")
    def rds_configuration(self) -> Optional[pulumi.Input['KnowledgeBaseRdsConfigurationArgs']]:
        """
        Contains details about the storage configuration of the knowledge base in Amazon RDS. For more information, see [Create a vector index in Amazon RDS](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-rds.html) .
        """
        return pulumi.get(self, "rds_configuration")

    @rds_configuration.setter
    def rds_configuration(self, value: Optional[pulumi.Input['KnowledgeBaseRdsConfigurationArgs']]):
        pulumi.set(self, "rds_configuration", value)


@pulumi.input_type
class KnowledgeBaseVectorKnowledgeBaseConfigurationArgs:
    def __init__(__self__, *,
                 embedding_model_arn: pulumi.Input[str],
                 embedding_model_configuration: Optional[pulumi.Input['KnowledgeBaseEmbeddingModelConfigurationArgs']] = None):
        """
        Contains details about the model used to create vector embeddings for the knowledge base.
        :param pulumi.Input[str] embedding_model_arn: The ARN of the model used to create vector embeddings for the knowledge base.
        :param pulumi.Input['KnowledgeBaseEmbeddingModelConfigurationArgs'] embedding_model_configuration: The embeddings model configuration details for the vector model used in Knowledge Base.
        """
        pulumi.set(__self__, "embedding_model_arn", embedding_model_arn)
        if embedding_model_configuration is not None:
            pulumi.set(__self__, "embedding_model_configuration", embedding_model_configuration)

    @property
    @pulumi.getter(name="embeddingModelArn")
    def embedding_model_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the model used to create vector embeddings for the knowledge base.
        """
        return pulumi.get(self, "embedding_model_arn")

    @embedding_model_arn.setter
    def embedding_model_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "embedding_model_arn", value)

    @property
    @pulumi.getter(name="embeddingModelConfiguration")
    def embedding_model_configuration(self) -> Optional[pulumi.Input['KnowledgeBaseEmbeddingModelConfigurationArgs']]:
        """
        The embeddings model configuration details for the vector model used in Knowledge Base.
        """
        return pulumi.get(self, "embedding_model_configuration")

    @embedding_model_configuration.setter
    def embedding_model_configuration(self, value: Optional[pulumi.Input['KnowledgeBaseEmbeddingModelConfigurationArgs']]):
        pulumi.set(self, "embedding_model_configuration", value)


@pulumi.input_type
class PromptInferenceConfigurationPropertiesArgs:
    def __init__(__self__, *,
                 text: pulumi.Input['PromptModelInferenceConfigurationArgs']):
        """
        Model inference configuration
        """
        pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def text(self) -> pulumi.Input['PromptModelInferenceConfigurationArgs']:
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input['PromptModelInferenceConfigurationArgs']):
        pulumi.set(self, "text", value)


@pulumi.input_type
class PromptInputVariableArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        Input variable
        :param pulumi.Input[str] name: Name for an input variable
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name for an input variable
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class PromptModelInferenceConfigurationArgs:
    def __init__(__self__, *,
                 max_tokens: Optional[pulumi.Input[float]] = None,
                 stop_sequences: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 temperature: Optional[pulumi.Input[float]] = None,
                 top_k: Optional[pulumi.Input[float]] = None,
                 top_p: Optional[pulumi.Input[float]] = None):
        """
        Prompt model inference configuration
        :param pulumi.Input[float] max_tokens: Maximum length of output
        :param pulumi.Input[Sequence[pulumi.Input[str]]] stop_sequences: List of stop sequences
        :param pulumi.Input[float] temperature: Controls randomness, higher values increase diversity
        :param pulumi.Input[float] top_k: Sample from the k most likely next tokens
        :param pulumi.Input[float] top_p: Cumulative probability cutoff for token selection
        """
        if max_tokens is not None:
            pulumi.set(__self__, "max_tokens", max_tokens)
        if stop_sequences is not None:
            pulumi.set(__self__, "stop_sequences", stop_sequences)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)
        if top_k is not None:
            pulumi.set(__self__, "top_k", top_k)
        if top_p is not None:
            pulumi.set(__self__, "top_p", top_p)

    @property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> Optional[pulumi.Input[float]]:
        """
        Maximum length of output
        """
        return pulumi.get(self, "max_tokens")

    @max_tokens.setter
    def max_tokens(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_tokens", value)

    @property
    @pulumi.getter(name="stopSequences")
    def stop_sequences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of stop sequences
        """
        return pulumi.get(self, "stop_sequences")

    @stop_sequences.setter
    def stop_sequences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "stop_sequences", value)

    @property
    @pulumi.getter
    def temperature(self) -> Optional[pulumi.Input[float]]:
        """
        Controls randomness, higher values increase diversity
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "temperature", value)

    @property
    @pulumi.getter(name="topK")
    def top_k(self) -> Optional[pulumi.Input[float]]:
        """
        Sample from the k most likely next tokens
        """
        return pulumi.get(self, "top_k")

    @top_k.setter
    def top_k(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "top_k", value)

    @property
    @pulumi.getter(name="topP")
    def top_p(self) -> Optional[pulumi.Input[float]]:
        """
        Cumulative probability cutoff for token selection
        """
        return pulumi.get(self, "top_p")

    @top_p.setter
    def top_p(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "top_p", value)


@pulumi.input_type
class PromptTemplateConfigurationPropertiesArgs:
    def __init__(__self__, *,
                 text: pulumi.Input['PromptTextPromptTemplateConfigurationArgs']):
        """
        Prompt template configuration
        """
        pulumi.set(__self__, "text", text)

    @property
    @pulumi.getter
    def text(self) -> pulumi.Input['PromptTextPromptTemplateConfigurationArgs']:
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input['PromptTextPromptTemplateConfigurationArgs']):
        pulumi.set(self, "text", value)


@pulumi.input_type
class PromptTextPromptTemplateConfigurationArgs:
    def __init__(__self__, *,
                 input_variables: Optional[pulumi.Input[Sequence[pulumi.Input['PromptInputVariableArgs']]]] = None,
                 text: Optional[pulumi.Input[str]] = None,
                 text_s3_location: Optional[pulumi.Input['PromptTextS3LocationArgs']] = None):
        """
        Configuration for text prompt template
        :param pulumi.Input[Sequence[pulumi.Input['PromptInputVariableArgs']]] input_variables: List of input variables
        :param pulumi.Input[str] text: Prompt content for String prompt template
        """
        if input_variables is not None:
            pulumi.set(__self__, "input_variables", input_variables)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if text_s3_location is not None:
            pulumi.set(__self__, "text_s3_location", text_s3_location)

    @property
    @pulumi.getter(name="inputVariables")
    def input_variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PromptInputVariableArgs']]]]:
        """
        List of input variables
        """
        return pulumi.get(self, "input_variables")

    @input_variables.setter
    def input_variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PromptInputVariableArgs']]]]):
        pulumi.set(self, "input_variables", value)

    @property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[str]]:
        """
        Prompt content for String prompt template
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text", value)

    @property
    @pulumi.getter(name="textS3Location")
    def text_s3_location(self) -> Optional[pulumi.Input['PromptTextS3LocationArgs']]:
        return pulumi.get(self, "text_s3_location")

    @text_s3_location.setter
    def text_s3_location(self, value: Optional[pulumi.Input['PromptTextS3LocationArgs']]):
        pulumi.set(self, "text_s3_location", value)


@pulumi.input_type
class PromptTextS3LocationArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 key: pulumi.Input[str],
                 version: Optional[pulumi.Input[str]] = None):
        """
        The identifier for the S3 resource.
        :param pulumi.Input[str] bucket: A bucket in S3
        :param pulumi.Input[str] key: A object key in S3
        :param pulumi.Input[str] version: The version of the the S3 object to use
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "key", key)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        A bucket in S3
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        A object key in S3
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of the the S3 object to use
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class PromptVariantArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 template_type: pulumi.Input['PromptTemplateType'],
                 inference_configuration: Optional[pulumi.Input['PromptInferenceConfigurationPropertiesArgs']] = None,
                 model_id: Optional[pulumi.Input[str]] = None,
                 template_configuration: Optional[pulumi.Input['PromptTemplateConfigurationPropertiesArgs']] = None):
        """
        Prompt variant
        :param pulumi.Input[str] name: Name for a variant.
        :param pulumi.Input['PromptTemplateType'] template_type: The type of prompt template to use.
        :param pulumi.Input['PromptInferenceConfigurationPropertiesArgs'] inference_configuration: Contains inference configurations for the prompt variant.
        :param pulumi.Input[str] model_id: ARN or name of a Bedrock model.
        :param pulumi.Input['PromptTemplateConfigurationPropertiesArgs'] template_configuration: Contains configurations for the prompt template.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "template_type", template_type)
        if inference_configuration is not None:
            pulumi.set(__self__, "inference_configuration", inference_configuration)
        if model_id is not None:
            pulumi.set(__self__, "model_id", model_id)
        if template_configuration is not None:
            pulumi.set(__self__, "template_configuration", template_configuration)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name for a variant.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="templateType")
    def template_type(self) -> pulumi.Input['PromptTemplateType']:
        """
        The type of prompt template to use.
        """
        return pulumi.get(self, "template_type")

    @template_type.setter
    def template_type(self, value: pulumi.Input['PromptTemplateType']):
        pulumi.set(self, "template_type", value)

    @property
    @pulumi.getter(name="inferenceConfiguration")
    def inference_configuration(self) -> Optional[pulumi.Input['PromptInferenceConfigurationPropertiesArgs']]:
        """
        Contains inference configurations for the prompt variant.
        """
        return pulumi.get(self, "inference_configuration")

    @inference_configuration.setter
    def inference_configuration(self, value: Optional[pulumi.Input['PromptInferenceConfigurationPropertiesArgs']]):
        pulumi.set(self, "inference_configuration", value)

    @property
    @pulumi.getter(name="modelId")
    def model_id(self) -> Optional[pulumi.Input[str]]:
        """
        ARN or name of a Bedrock model.
        """
        return pulumi.get(self, "model_id")

    @model_id.setter
    def model_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "model_id", value)

    @property
    @pulumi.getter(name="templateConfiguration")
    def template_configuration(self) -> Optional[pulumi.Input['PromptTemplateConfigurationPropertiesArgs']]:
        """
        Contains configurations for the prompt template.
        """
        return pulumi.get(self, "template_configuration")

    @template_configuration.setter
    def template_configuration(self, value: Optional[pulumi.Input['PromptTemplateConfigurationPropertiesArgs']]):
        pulumi.set(self, "template_configuration", value)


