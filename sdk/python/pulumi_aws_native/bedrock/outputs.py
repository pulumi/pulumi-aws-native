# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AgentActionGroup',
    'AgentActionGroupExecutor0Properties',
    'AgentActionGroupExecutor1Properties',
    'AgentAdditionalModelRequestFields',
    'AgentAliasHistoryEvent',
    'AgentAliasRoutingConfigurationListItem',
    'AgentApiSchema0Properties',
    'AgentApiSchema1Properties',
    'AgentCollaborator',
    'AgentCollaboratorAgentDescriptorProperties',
    'AgentCustomOrchestration',
    'AgentFunction',
    'AgentFunctionSchema',
    'AgentGuardrailConfiguration',
    'AgentInferenceConfiguration',
    'AgentKnowledgeBase',
    'AgentMemoryConfiguration',
    'AgentOrchestrationExecutor',
    'AgentParameterDetail',
    'AgentPromptConfiguration',
    'AgentPromptOverrideConfiguration',
    'AgentS3Identifier',
    'AgentSessionSummaryConfiguration',
    'ApplicationInferenceProfileInferenceProfileModel',
    'ApplicationInferenceProfileInferenceProfileModelSourceProperties',
    'AutomatedReasoningPolicyPolicyDefinition',
    'AutomatedReasoningPolicyPolicyDefinitionRule',
    'AutomatedReasoningPolicyPolicyDefinitionType',
    'AutomatedReasoningPolicyPolicyDefinitionTypeValue',
    'AutomatedReasoningPolicyPolicyDefinitionVariable',
    'DataAutomationProjectAudioExtractionCategory',
    'DataAutomationProjectAudioExtractionCategoryTypeConfiguration',
    'DataAutomationProjectAudioOverrideConfiguration',
    'DataAutomationProjectAudioStandardExtraction',
    'DataAutomationProjectAudioStandardGenerativeField',
    'DataAutomationProjectAudioStandardOutputConfiguration',
    'DataAutomationProjectBlueprintItem',
    'DataAutomationProjectChannelLabelingConfiguration',
    'DataAutomationProjectCustomOutputConfiguration',
    'DataAutomationProjectDocumentBoundingBox',
    'DataAutomationProjectDocumentExtractionGranularity',
    'DataAutomationProjectDocumentOutputAdditionalFileFormat',
    'DataAutomationProjectDocumentOutputFormat',
    'DataAutomationProjectDocumentOutputTextFormat',
    'DataAutomationProjectDocumentOverrideConfiguration',
    'DataAutomationProjectDocumentStandardExtraction',
    'DataAutomationProjectDocumentStandardGenerativeField',
    'DataAutomationProjectDocumentStandardOutputConfiguration',
    'DataAutomationProjectImageBoundingBox',
    'DataAutomationProjectImageExtractionCategory',
    'DataAutomationProjectImageOverrideConfiguration',
    'DataAutomationProjectImageStandardExtraction',
    'DataAutomationProjectImageStandardGenerativeField',
    'DataAutomationProjectImageStandardOutputConfiguration',
    'DataAutomationProjectModalityProcessingConfiguration',
    'DataAutomationProjectModalityRoutingConfiguration',
    'DataAutomationProjectOverrideConfiguration',
    'DataAutomationProjectSpeakerLabelingConfiguration',
    'DataAutomationProjectSplitterConfiguration',
    'DataAutomationProjectStandardOutputConfiguration',
    'DataAutomationProjectTranscriptConfiguration',
    'DataAutomationProjectVideoBoundingBox',
    'DataAutomationProjectVideoExtractionCategory',
    'DataAutomationProjectVideoOverrideConfiguration',
    'DataAutomationProjectVideoStandardExtraction',
    'DataAutomationProjectVideoStandardGenerativeField',
    'DataAutomationProjectVideoStandardOutputConfiguration',
    'DataSourceBedrockDataAutomationConfiguration',
    'DataSourceBedrockFoundationModelConfiguration',
    'DataSourceBedrockFoundationModelContextEnrichmentConfiguration',
    'DataSourceChunkingConfiguration',
    'DataSourceConfiguration',
    'DataSourceConfluenceCrawlerConfiguration',
    'DataSourceConfluenceDataSourceConfiguration',
    'DataSourceConfluenceSourceConfiguration',
    'DataSourceContextEnrichmentConfiguration',
    'DataSourceCrawlFilterConfiguration',
    'DataSourceCustomTransformationConfiguration',
    'DataSourceEnrichmentStrategyConfiguration',
    'DataSourceFixedSizeChunkingConfiguration',
    'DataSourceHierarchicalChunkingConfiguration',
    'DataSourceHierarchicalChunkingLevelConfiguration',
    'DataSourceIntermediateStorage',
    'DataSourceParsingConfiguration',
    'DataSourceParsingPrompt',
    'DataSourcePatternObjectFilter',
    'DataSourcePatternObjectFilterConfiguration',
    'DataSourceS3DataSourceConfiguration',
    'DataSourceS3Location',
    'DataSourceSalesforceCrawlerConfiguration',
    'DataSourceSalesforceDataSourceConfiguration',
    'DataSourceSalesforceSourceConfiguration',
    'DataSourceSeedUrl',
    'DataSourceSemanticChunkingConfiguration',
    'DataSourceServerSideEncryptionConfiguration',
    'DataSourceSharePointCrawlerConfiguration',
    'DataSourceSharePointDataSourceConfiguration',
    'DataSourceSharePointSourceConfiguration',
    'DataSourceTransformation',
    'DataSourceTransformationFunction',
    'DataSourceTransformationLambdaConfiguration',
    'DataSourceUrlConfiguration',
    'DataSourceVectorIngestionConfiguration',
    'DataSourceWebCrawlerConfiguration',
    'DataSourceWebCrawlerLimits',
    'DataSourceWebDataSourceConfiguration',
    'DataSourceWebSourceConfiguration',
    'FlowAdditionalModelRequestFields',
    'FlowAgentFlowNodeConfiguration',
    'FlowAliasConcurrencyConfiguration',
    'FlowAliasRoutingConfigurationListItem',
    'FlowCollectorFlowNodeConfiguration',
    'FlowCondition',
    'FlowConditionFlowNodeConfiguration',
    'FlowConditionalConnectionConfiguration',
    'FlowConnection',
    'FlowConnectionConfiguration0Properties',
    'FlowConnectionConfiguration1Properties',
    'FlowDataConnectionConfiguration',
    'FlowDefinition',
    'FlowFieldForReranking',
    'FlowGuardrailConfiguration',
    'FlowInlineCodeFlowNodeConfiguration',
    'FlowInputFlowNodeConfiguration',
    'FlowIteratorFlowNodeConfiguration',
    'FlowKnowledgeBaseFlowNodeConfiguration',
    'FlowKnowledgeBaseOrchestrationConfiguration',
    'FlowKnowledgeBasePromptTemplateProperties',
    'FlowLambdaFunctionFlowNodeConfiguration',
    'FlowLexFlowNodeConfiguration',
    'FlowLoopControllerFlowNodeConfiguration',
    'FlowLoopFlowNodeConfiguration',
    'FlowLoopInputFlowNodeConfiguration',
    'FlowMetadataConfigurationForReranking',
    'FlowNode',
    'FlowNodeConfiguration0Properties',
    'FlowNodeConfiguration10Properties',
    'FlowNodeConfiguration11Properties',
    'FlowNodeConfiguration12Properties',
    'FlowNodeConfiguration13Properties',
    'FlowNodeConfiguration14Properties',
    'FlowNodeConfiguration15Properties',
    'FlowNodeConfiguration1Properties',
    'FlowNodeConfiguration2Properties',
    'FlowNodeConfiguration3Properties',
    'FlowNodeConfiguration4Properties',
    'FlowNodeConfiguration5Properties',
    'FlowNodeConfiguration6Properties',
    'FlowNodeConfiguration7Properties',
    'FlowNodeConfiguration8Properties',
    'FlowNodeConfiguration9Properties',
    'FlowNodeInput',
    'FlowNodeOutput',
    'FlowOutputFlowNodeConfiguration',
    'FlowPerformanceConfiguration',
    'FlowPromptFlowNodeConfiguration',
    'FlowPromptFlowNodeInlineConfiguration',
    'FlowPromptFlowNodeResourceConfiguration',
    'FlowPromptFlowNodeSourceConfiguration0Properties',
    'FlowPromptFlowNodeSourceConfiguration1Properties',
    'FlowPromptInferenceConfigurationProperties',
    'FlowPromptInputVariable',
    'FlowPromptModelInferenceConfiguration',
    'FlowPromptTemplateConfigurationProperties',
    'FlowRerankingMetadataSelectiveModeConfiguration0Properties',
    'FlowRerankingMetadataSelectiveModeConfiguration1Properties',
    'FlowRetrievalFlowNodeConfiguration',
    'FlowRetrievalFlowNodeS3Configuration',
    'FlowRetrievalFlowNodeServiceConfigurationProperties',
    'FlowS3Location',
    'FlowStorageFlowNodeConfiguration',
    'FlowStorageFlowNodeS3Configuration',
    'FlowStorageFlowNodeServiceConfigurationProperties',
    'FlowTextPromptTemplateConfiguration',
    'FlowValidation',
    'FlowVectorSearchBedrockRerankingConfiguration',
    'FlowVectorSearchBedrockRerankingModelConfiguration',
    'FlowVectorSearchRerankingConfiguration',
    'FlowVersionAdditionalModelRequestFields',
    'FlowVersionAgentFlowNodeConfiguration',
    'FlowVersionCollectorFlowNodeConfiguration',
    'FlowVersionConditionFlowNodeConfiguration',
    'FlowVersionFieldForReranking',
    'FlowVersionFlowCondition',
    'FlowVersionFlowConditionalConnectionConfiguration',
    'FlowVersionFlowConnection',
    'FlowVersionFlowConnectionConfiguration0Properties',
    'FlowVersionFlowConnectionConfiguration1Properties',
    'FlowVersionFlowDataConnectionConfiguration',
    'FlowVersionFlowDefinition',
    'FlowVersionFlowNode',
    'FlowVersionFlowNodeConfiguration0Properties',
    'FlowVersionFlowNodeConfiguration10Properties',
    'FlowVersionFlowNodeConfiguration11Properties',
    'FlowVersionFlowNodeConfiguration12Properties',
    'FlowVersionFlowNodeConfiguration13Properties',
    'FlowVersionFlowNodeConfiguration14Properties',
    'FlowVersionFlowNodeConfiguration15Properties',
    'FlowVersionFlowNodeConfiguration1Properties',
    'FlowVersionFlowNodeConfiguration2Properties',
    'FlowVersionFlowNodeConfiguration3Properties',
    'FlowVersionFlowNodeConfiguration4Properties',
    'FlowVersionFlowNodeConfiguration5Properties',
    'FlowVersionFlowNodeConfiguration6Properties',
    'FlowVersionFlowNodeConfiguration7Properties',
    'FlowVersionFlowNodeConfiguration8Properties',
    'FlowVersionFlowNodeConfiguration9Properties',
    'FlowVersionFlowNodeInput',
    'FlowVersionFlowNodeOutput',
    'FlowVersionGuardrailConfiguration',
    'FlowVersionInlineCodeFlowNodeConfiguration',
    'FlowVersionInputFlowNodeConfiguration',
    'FlowVersionIteratorFlowNodeConfiguration',
    'FlowVersionKnowledgeBaseFlowNodeConfiguration',
    'FlowVersionKnowledgeBaseOrchestrationConfiguration',
    'FlowVersionKnowledgeBasePromptTemplateProperties',
    'FlowVersionLambdaFunctionFlowNodeConfiguration',
    'FlowVersionLexFlowNodeConfiguration',
    'FlowVersionLoopControllerFlowNodeConfiguration',
    'FlowVersionLoopFlowNodeConfiguration',
    'FlowVersionLoopInputFlowNodeConfiguration',
    'FlowVersionMetadataConfigurationForReranking',
    'FlowVersionOutputFlowNodeConfiguration',
    'FlowVersionPerformanceConfiguration',
    'FlowVersionPromptFlowNodeConfiguration',
    'FlowVersionPromptFlowNodeInlineConfiguration',
    'FlowVersionPromptFlowNodeResourceConfiguration',
    'FlowVersionPromptFlowNodeSourceConfiguration0Properties',
    'FlowVersionPromptFlowNodeSourceConfiguration1Properties',
    'FlowVersionPromptInferenceConfigurationProperties',
    'FlowVersionPromptInputVariable',
    'FlowVersionPromptModelInferenceConfiguration',
    'FlowVersionPromptTemplateConfigurationProperties',
    'FlowVersionRerankingMetadataSelectiveModeConfiguration0Properties',
    'FlowVersionRerankingMetadataSelectiveModeConfiguration1Properties',
    'FlowVersionRetrievalFlowNodeConfiguration',
    'FlowVersionRetrievalFlowNodeS3Configuration',
    'FlowVersionRetrievalFlowNodeServiceConfigurationProperties',
    'FlowVersionStorageFlowNodeConfiguration',
    'FlowVersionStorageFlowNodeS3Configuration',
    'FlowVersionStorageFlowNodeServiceConfigurationProperties',
    'FlowVersionTextPromptTemplateConfiguration',
    'FlowVersionVectorSearchBedrockRerankingConfiguration',
    'FlowVersionVectorSearchBedrockRerankingModelConfiguration',
    'FlowVersionVectorSearchRerankingConfiguration',
    'GuardrailAutomatedReasoningPolicyConfig',
    'GuardrailContentFilterConfig',
    'GuardrailContentPolicyConfig',
    'GuardrailContentPolicyConfigContentFiltersTierConfigProperties',
    'GuardrailContextualGroundingFilterConfig',
    'GuardrailContextualGroundingPolicyConfig',
    'GuardrailCrossRegionConfig',
    'GuardrailManagedWordsConfig',
    'GuardrailPiiEntityConfig',
    'GuardrailRegexConfig',
    'GuardrailSensitiveInformationPolicyConfig',
    'GuardrailTopicConfig',
    'GuardrailTopicPolicyConfig',
    'GuardrailTopicPolicyConfigTopicsTierConfigProperties',
    'GuardrailWordConfig',
    'GuardrailWordPolicyConfig',
    'IntelligentPromptRouterPromptRouterTargetModel',
    'IntelligentPromptRouterRoutingCriteria',
    'KnowledgeBaseBedrockEmbeddingModelConfiguration',
    'KnowledgeBaseConfiguration',
    'KnowledgeBaseCuratedQuery',
    'KnowledgeBaseEmbeddingModelConfiguration',
    'KnowledgeBaseKendraKnowledgeBaseConfiguration',
    'KnowledgeBaseMongoDbAtlasConfiguration',
    'KnowledgeBaseMongoDbAtlasFieldMapping',
    'KnowledgeBaseNeptuneAnalyticsConfiguration',
    'KnowledgeBaseNeptuneAnalyticsFieldMapping',
    'KnowledgeBaseOpenSearchManagedClusterConfiguration',
    'KnowledgeBaseOpenSearchManagedClusterFieldMapping',
    'KnowledgeBaseOpenSearchServerlessConfiguration',
    'KnowledgeBaseOpenSearchServerlessFieldMapping',
    'KnowledgeBasePineconeConfiguration',
    'KnowledgeBasePineconeFieldMapping',
    'KnowledgeBaseQueryGenerationColumn',
    'KnowledgeBaseQueryGenerationConfiguration',
    'KnowledgeBaseQueryGenerationContext',
    'KnowledgeBaseQueryGenerationTable',
    'KnowledgeBaseRdsConfiguration',
    'KnowledgeBaseRdsFieldMapping',
    'KnowledgeBaseRedshiftConfiguration',
    'KnowledgeBaseRedshiftProvisionedAuthConfiguration',
    'KnowledgeBaseRedshiftProvisionedConfiguration',
    'KnowledgeBaseRedshiftQueryEngineAwsDataCatalogStorageConfiguration',
    'KnowledgeBaseRedshiftQueryEngineConfiguration',
    'KnowledgeBaseRedshiftQueryEngineRedshiftStorageConfiguration',
    'KnowledgeBaseRedshiftQueryEngineStorageConfiguration',
    'KnowledgeBaseRedshiftServerlessAuthConfiguration',
    'KnowledgeBaseRedshiftServerlessConfiguration',
    'KnowledgeBaseS3Location',
    'KnowledgeBaseSqlKnowledgeBaseConfiguration',
    'KnowledgeBaseStorageConfiguration',
    'KnowledgeBaseSupplementalDataStorageConfiguration',
    'KnowledgeBaseSupplementalDataStorageLocation',
    'KnowledgeBaseVectorKnowledgeBaseConfiguration',
    'PromptAdditionalModelRequestFields',
    'PromptAgentResource',
    'PromptAnyToolChoice',
    'PromptAutoToolChoice',
    'PromptCachePointBlock',
    'PromptChatPromptTemplateConfiguration',
    'PromptContentBlock0Properties',
    'PromptContentBlock1Properties',
    'PromptGenAiResourceProperties',
    'PromptInferenceConfigurationProperties',
    'PromptInputVariable',
    'PromptMessage',
    'PromptMetadataEntry',
    'PromptModelInferenceConfiguration',
    'PromptSpecificToolChoice',
    'PromptSystemContentBlock0Properties',
    'PromptSystemContentBlock1Properties',
    'PromptTemplateConfiguration0Properties',
    'PromptTemplateConfiguration1Properties',
    'PromptTextPromptTemplateConfiguration',
    'PromptTextS3Location',
    'PromptTool0Properties',
    'PromptTool1Properties',
    'PromptToolChoice0Properties',
    'PromptToolChoice1Properties',
    'PromptToolChoice2Properties',
    'PromptToolConfiguration',
    'PromptToolInputSchemaProperties',
    'PromptToolSpecification',
    'PromptVariant',
    'PromptVersionAdditionalModelRequestFields',
    'PromptVersionAnyToolChoice',
    'PromptVersionAutoToolChoice',
    'PromptVersionCachePointBlock',
    'PromptVersionChatPromptTemplateConfiguration',
    'PromptVersionContentBlock0Properties',
    'PromptVersionContentBlock1Properties',
    'PromptVersionMessage',
    'PromptVersionPromptAgentResource',
    'PromptVersionPromptGenAiResourceProperties',
    'PromptVersionPromptInferenceConfigurationProperties',
    'PromptVersionPromptInputVariable',
    'PromptVersionPromptMetadataEntry',
    'PromptVersionPromptModelInferenceConfiguration',
    'PromptVersionPromptTemplateConfiguration0Properties',
    'PromptVersionPromptTemplateConfiguration1Properties',
    'PromptVersionPromptVariant',
    'PromptVersionSpecificToolChoice',
    'PromptVersionSystemContentBlock0Properties',
    'PromptVersionSystemContentBlock1Properties',
    'PromptVersionTextPromptTemplateConfiguration',
    'PromptVersionTool0Properties',
    'PromptVersionTool1Properties',
    'PromptVersionToolChoice0Properties',
    'PromptVersionToolChoice1Properties',
    'PromptVersionToolChoice2Properties',
    'PromptVersionToolConfiguration',
    'PromptVersionToolInputSchemaProperties',
    'PromptVersionToolSpecification',
]

@pulumi.output_type
class AgentActionGroup(dict):
    """
    Contains the information of an Agent Action Group
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionGroupName":
            suggest = "action_group_name"
        elif key == "actionGroupExecutor":
            suggest = "action_group_executor"
        elif key == "actionGroupState":
            suggest = "action_group_state"
        elif key == "apiSchema":
            suggest = "api_schema"
        elif key == "functionSchema":
            suggest = "function_schema"
        elif key == "parentActionGroupSignature":
            suggest = "parent_action_group_signature"
        elif key == "skipResourceInUseCheckOnDelete":
            suggest = "skip_resource_in_use_check_on_delete"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentActionGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentActionGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentActionGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_group_name: _builtins.str,
                 action_group_executor: Optional[Any] = None,
                 action_group_state: Optional['AgentActionGroupState'] = None,
                 api_schema: Optional[Any] = None,
                 description: Optional[_builtins.str] = None,
                 function_schema: Optional['outputs.AgentFunctionSchema'] = None,
                 parent_action_group_signature: Optional['AgentActionGroupSignature'] = None,
                 skip_resource_in_use_check_on_delete: Optional[_builtins.bool] = None):
        """
        Contains the information of an Agent Action Group
        :param _builtins.str action_group_name: Name of the action group
        :param Union['AgentActionGroupExecutor0Properties', 'AgentActionGroupExecutor1Properties'] action_group_executor: The Amazon Resource Name (ARN) of the Lambda function containing the business logic that is carried out upon invoking the action or the custom control method for handling the information elicited from the user.
        :param 'AgentActionGroupState' action_group_state: Specifies whether the action group is available for the agent to invoke or not when sending an [InvokeAgent](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html) request.
        :param Union['AgentApiSchema0Properties', 'AgentApiSchema1Properties'] api_schema: Contains either details about the S3 object containing the OpenAPI schema for the action group or the JSON or YAML-formatted payload defining the schema. For more information, see [Action group OpenAPI schemas](https://docs.aws.amazon.com//bedrock/latest/userguide/agents-api-schema.html) .
        :param _builtins.str description: Description of action group
        :param 'AgentFunctionSchema' function_schema: Contains details about the function schema for the action group or the JSON or YAML-formatted payload defining the schema.
        :param 'AgentActionGroupSignature' parent_action_group_signature: If this field is set as `AMAZON.UserInput` , the agent can request the user for additional information when trying to complete a task. The `description` , `apiSchema` , and `actionGroupExecutor` fields must be blank for this action group.
               
               During orchestration, if the agent determines that it needs to invoke an API in an action group, but doesn't have enough information to complete the API request, it will invoke this action group instead and return an [Observation](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Observation.html) reprompting the user for more information.
        :param _builtins.bool skip_resource_in_use_check_on_delete: Specifies whether to allow deleting action group while it is in use.
        """
        pulumi.set(__self__, "action_group_name", action_group_name)
        if action_group_executor is not None:
            pulumi.set(__self__, "action_group_executor", action_group_executor)
        if action_group_state is not None:
            pulumi.set(__self__, "action_group_state", action_group_state)
        if api_schema is not None:
            pulumi.set(__self__, "api_schema", api_schema)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if function_schema is not None:
            pulumi.set(__self__, "function_schema", function_schema)
        if parent_action_group_signature is not None:
            pulumi.set(__self__, "parent_action_group_signature", parent_action_group_signature)
        if skip_resource_in_use_check_on_delete is not None:
            pulumi.set(__self__, "skip_resource_in_use_check_on_delete", skip_resource_in_use_check_on_delete)

    @_builtins.property
    @pulumi.getter(name="actionGroupName")
    def action_group_name(self) -> _builtins.str:
        """
        Name of the action group
        """
        return pulumi.get(self, "action_group_name")

    @_builtins.property
    @pulumi.getter(name="actionGroupExecutor")
    def action_group_executor(self) -> Optional[Any]:
        """
        The Amazon Resource Name (ARN) of the Lambda function containing the business logic that is carried out upon invoking the action or the custom control method for handling the information elicited from the user.
        """
        return pulumi.get(self, "action_group_executor")

    @_builtins.property
    @pulumi.getter(name="actionGroupState")
    def action_group_state(self) -> Optional['AgentActionGroupState']:
        """
        Specifies whether the action group is available for the agent to invoke or not when sending an [InvokeAgent](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html) request.
        """
        return pulumi.get(self, "action_group_state")

    @_builtins.property
    @pulumi.getter(name="apiSchema")
    def api_schema(self) -> Optional[Any]:
        """
        Contains either details about the S3 object containing the OpenAPI schema for the action group or the JSON or YAML-formatted payload defining the schema. For more information, see [Action group OpenAPI schemas](https://docs.aws.amazon.com//bedrock/latest/userguide/agents-api-schema.html) .
        """
        return pulumi.get(self, "api_schema")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of action group
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="functionSchema")
    def function_schema(self) -> Optional['outputs.AgentFunctionSchema']:
        """
        Contains details about the function schema for the action group or the JSON or YAML-formatted payload defining the schema.
        """
        return pulumi.get(self, "function_schema")

    @_builtins.property
    @pulumi.getter(name="parentActionGroupSignature")
    def parent_action_group_signature(self) -> Optional['AgentActionGroupSignature']:
        """
        If this field is set as `AMAZON.UserInput` , the agent can request the user for additional information when trying to complete a task. The `description` , `apiSchema` , and `actionGroupExecutor` fields must be blank for this action group.

        During orchestration, if the agent determines that it needs to invoke an API in an action group, but doesn't have enough information to complete the API request, it will invoke this action group instead and return an [Observation](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_Observation.html) reprompting the user for more information.
        """
        return pulumi.get(self, "parent_action_group_signature")

    @_builtins.property
    @pulumi.getter(name="skipResourceInUseCheckOnDelete")
    def skip_resource_in_use_check_on_delete(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to allow deleting action group while it is in use.
        """
        return pulumi.get(self, "skip_resource_in_use_check_on_delete")


@pulumi.output_type
class AgentActionGroupExecutor0Properties(dict):
    """
    Type of Executors for an Action Group
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lambda":
            suggest = "lambda_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentActionGroupExecutor0Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentActionGroupExecutor0Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentActionGroupExecutor0Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lambda_: _builtins.str):
        """
        Type of Executors for an Action Group
        :param _builtins.str lambda_: ARN of a Lambda.
        """
        pulumi.set(__self__, "lambda_", lambda_)

    @_builtins.property
    @pulumi.getter(name="lambda")
    def lambda_(self) -> _builtins.str:
        """
        ARN of a Lambda.
        """
        return pulumi.get(self, "lambda_")


@pulumi.output_type
class AgentActionGroupExecutor1Properties(dict):
    """
    Type of Executors for an Action Group
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customControl":
            suggest = "custom_control"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentActionGroupExecutor1Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentActionGroupExecutor1Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentActionGroupExecutor1Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_control: 'AgentCustomControlMethod'):
        """
        Type of Executors for an Action Group
        """
        pulumi.set(__self__, "custom_control", custom_control)

    @_builtins.property
    @pulumi.getter(name="customControl")
    def custom_control(self) -> 'AgentCustomControlMethod':
        return pulumi.get(self, "custom_control")


@pulumi.output_type
class AgentAdditionalModelRequestFields(dict):
    """
    Additional Model Request Fields for Prompt Configuration
    """
    def __init__(__self__):
        """
        Additional Model Request Fields for Prompt Configuration
        """
        pass


@pulumi.output_type
class AgentAliasHistoryEvent(dict):
    """
    History event for an alias for an Agent.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endDate":
            suggest = "end_date"
        elif key == "routingConfiguration":
            suggest = "routing_configuration"
        elif key == "startDate":
            suggest = "start_date"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentAliasHistoryEvent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentAliasHistoryEvent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentAliasHistoryEvent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_date: Optional[_builtins.str] = None,
                 routing_configuration: Optional[Sequence['outputs.AgentAliasRoutingConfigurationListItem']] = None,
                 start_date: Optional[_builtins.str] = None):
        """
        History event for an alias for an Agent.
        :param _builtins.str end_date: Time Stamp.
        :param Sequence['AgentAliasRoutingConfigurationListItem'] routing_configuration: Routing configuration for an Agent alias.
        :param _builtins.str start_date: Time Stamp.
        """
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)
        if routing_configuration is not None:
            pulumi.set(__self__, "routing_configuration", routing_configuration)
        if start_date is not None:
            pulumi.set(__self__, "start_date", start_date)

    @_builtins.property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[_builtins.str]:
        """
        Time Stamp.
        """
        return pulumi.get(self, "end_date")

    @_builtins.property
    @pulumi.getter(name="routingConfiguration")
    def routing_configuration(self) -> Optional[Sequence['outputs.AgentAliasRoutingConfigurationListItem']]:
        """
        Routing configuration for an Agent alias.
        """
        return pulumi.get(self, "routing_configuration")

    @_builtins.property
    @pulumi.getter(name="startDate")
    def start_date(self) -> Optional[_builtins.str]:
        """
        Time Stamp.
        """
        return pulumi.get(self, "start_date")


@pulumi.output_type
class AgentAliasRoutingConfigurationListItem(dict):
    """
    Details about the routing configuration for an Agent alias.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "agentVersion":
            suggest = "agent_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentAliasRoutingConfigurationListItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentAliasRoutingConfigurationListItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentAliasRoutingConfigurationListItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 agent_version: _builtins.str):
        """
        Details about the routing configuration for an Agent alias.
        :param _builtins.str agent_version: Agent Version.
        """
        pulumi.set(__self__, "agent_version", agent_version)

    @_builtins.property
    @pulumi.getter(name="agentVersion")
    def agent_version(self) -> _builtins.str:
        """
        Agent Version.
        """
        return pulumi.get(self, "agent_version")


@pulumi.output_type
class AgentApiSchema0Properties(dict):
    """
    Contains information about the API Schema for the Action Group
    """
    def __init__(__self__, *,
                 s3: 'outputs.AgentS3Identifier'):
        """
        Contains information about the API Schema for the Action Group
        """
        pulumi.set(__self__, "s3", s3)

    @_builtins.property
    @pulumi.getter
    def s3(self) -> 'outputs.AgentS3Identifier':
        return pulumi.get(self, "s3")


@pulumi.output_type
class AgentApiSchema1Properties(dict):
    """
    Contains information about the API Schema for the Action Group
    """
    def __init__(__self__, *,
                 payload: _builtins.str):
        """
        Contains information about the API Schema for the Action Group
        :param _builtins.str payload: String OpenAPI Payload
        """
        pulumi.set(__self__, "payload", payload)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> _builtins.str:
        """
        String OpenAPI Payload
        """
        return pulumi.get(self, "payload")


@pulumi.output_type
class AgentCollaborator(dict):
    """
    Agent Collaborator
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "agentDescriptor":
            suggest = "agent_descriptor"
        elif key == "collaborationInstruction":
            suggest = "collaboration_instruction"
        elif key == "collaboratorName":
            suggest = "collaborator_name"
        elif key == "relayConversationHistory":
            suggest = "relay_conversation_history"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentCollaborator. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentCollaborator.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentCollaborator.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 agent_descriptor: 'outputs.AgentCollaboratorAgentDescriptorProperties',
                 collaboration_instruction: _builtins.str,
                 collaborator_name: _builtins.str,
                 relay_conversation_history: Optional['AgentRelayConversationHistory'] = None):
        """
        Agent Collaborator
        :param 'AgentCollaboratorAgentDescriptorProperties' agent_descriptor: Agent descriptor for agent collaborator
        :param _builtins.str collaboration_instruction: Agent collaborator instruction
        :param _builtins.str collaborator_name: Agent collaborator name
        :param 'AgentRelayConversationHistory' relay_conversation_history: The collaborator's relay conversation history.
        """
        pulumi.set(__self__, "agent_descriptor", agent_descriptor)
        pulumi.set(__self__, "collaboration_instruction", collaboration_instruction)
        pulumi.set(__self__, "collaborator_name", collaborator_name)
        if relay_conversation_history is not None:
            pulumi.set(__self__, "relay_conversation_history", relay_conversation_history)

    @_builtins.property
    @pulumi.getter(name="agentDescriptor")
    def agent_descriptor(self) -> 'outputs.AgentCollaboratorAgentDescriptorProperties':
        """
        Agent descriptor for agent collaborator
        """
        return pulumi.get(self, "agent_descriptor")

    @_builtins.property
    @pulumi.getter(name="collaborationInstruction")
    def collaboration_instruction(self) -> _builtins.str:
        """
        Agent collaborator instruction
        """
        return pulumi.get(self, "collaboration_instruction")

    @_builtins.property
    @pulumi.getter(name="collaboratorName")
    def collaborator_name(self) -> _builtins.str:
        """
        Agent collaborator name
        """
        return pulumi.get(self, "collaborator_name")

    @_builtins.property
    @pulumi.getter(name="relayConversationHistory")
    def relay_conversation_history(self) -> Optional['AgentRelayConversationHistory']:
        """
        The collaborator's relay conversation history.
        """
        return pulumi.get(self, "relay_conversation_history")


@pulumi.output_type
class AgentCollaboratorAgentDescriptorProperties(dict):
    """
    Agent descriptor for agent collaborator
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aliasArn":
            suggest = "alias_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentCollaboratorAgentDescriptorProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentCollaboratorAgentDescriptorProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentCollaboratorAgentDescriptorProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alias_arn: Optional[_builtins.str] = None):
        """
        Agent descriptor for agent collaborator
        :param _builtins.str alias_arn: Alias ARN for agent descriptor
        """
        if alias_arn is not None:
            pulumi.set(__self__, "alias_arn", alias_arn)

    @_builtins.property
    @pulumi.getter(name="aliasArn")
    def alias_arn(self) -> Optional[_builtins.str]:
        """
        Alias ARN for agent descriptor
        """
        return pulumi.get(self, "alias_arn")


@pulumi.output_type
class AgentCustomOrchestration(dict):
    """
    Structure for custom orchestration
    """
    def __init__(__self__, *,
                 executor: Optional['outputs.AgentOrchestrationExecutor'] = None):
        """
        Structure for custom orchestration
        :param 'AgentOrchestrationExecutor' executor: The structure of the executor invoking the actions in custom orchestration.
        """
        if executor is not None:
            pulumi.set(__self__, "executor", executor)

    @_builtins.property
    @pulumi.getter
    def executor(self) -> Optional['outputs.AgentOrchestrationExecutor']:
        """
        The structure of the executor invoking the actions in custom orchestration.
        """
        return pulumi.get(self, "executor")


@pulumi.output_type
class AgentFunction(dict):
    """
    Function definition
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requireConfirmation":
            suggest = "require_confirmation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentFunction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentFunction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentFunction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 parameters: Optional[Mapping[str, 'outputs.AgentParameterDetail']] = None,
                 require_confirmation: Optional['AgentRequireConfirmation'] = None):
        """
        Function definition
        :param _builtins.str name: Name for a resource.
        :param _builtins.str description: Description of function
        :param Mapping[str, 'AgentParameterDetail'] parameters: The parameters that the agent elicits from the user to fulfill the function.
        :param 'AgentRequireConfirmation' require_confirmation: Contains information if user confirmation is required to invoke the function.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if require_confirmation is not None:
            pulumi.set(__self__, "require_confirmation", require_confirmation)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name for a resource.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of function
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Mapping[str, 'outputs.AgentParameterDetail']]:
        """
        The parameters that the agent elicits from the user to fulfill the function.
        """
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter(name="requireConfirmation")
    def require_confirmation(self) -> Optional['AgentRequireConfirmation']:
        """
        Contains information if user confirmation is required to invoke the function.
        """
        return pulumi.get(self, "require_confirmation")


@pulumi.output_type
class AgentFunctionSchema(dict):
    """
    Schema of Functions
    """
    def __init__(__self__, *,
                 functions: Sequence['outputs.AgentFunction']):
        """
        Schema of Functions
        :param Sequence['AgentFunction'] functions: List of Function definitions
        """
        pulumi.set(__self__, "functions", functions)

    @_builtins.property
    @pulumi.getter
    def functions(self) -> Sequence['outputs.AgentFunction']:
        """
        List of Function definitions
        """
        return pulumi.get(self, "functions")


@pulumi.output_type
class AgentGuardrailConfiguration(dict):
    """
    Configuration for a guardrail.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "guardrailIdentifier":
            suggest = "guardrail_identifier"
        elif key == "guardrailVersion":
            suggest = "guardrail_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentGuardrailConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentGuardrailConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentGuardrailConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 guardrail_identifier: Optional[_builtins.str] = None,
                 guardrail_version: Optional[_builtins.str] = None):
        """
        Configuration for a guardrail.
        :param _builtins.str guardrail_identifier: Identifier for the guardrail, could be the id or the arn
        :param _builtins.str guardrail_version: Version of the guardrail
        """
        if guardrail_identifier is not None:
            pulumi.set(__self__, "guardrail_identifier", guardrail_identifier)
        if guardrail_version is not None:
            pulumi.set(__self__, "guardrail_version", guardrail_version)

    @_builtins.property
    @pulumi.getter(name="guardrailIdentifier")
    def guardrail_identifier(self) -> Optional[_builtins.str]:
        """
        Identifier for the guardrail, could be the id or the arn
        """
        return pulumi.get(self, "guardrail_identifier")

    @_builtins.property
    @pulumi.getter(name="guardrailVersion")
    def guardrail_version(self) -> Optional[_builtins.str]:
        """
        Version of the guardrail
        """
        return pulumi.get(self, "guardrail_version")


@pulumi.output_type
class AgentInferenceConfiguration(dict):
    """
    Configuration for inference in prompt configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maximumLength":
            suggest = "maximum_length"
        elif key == "stopSequences":
            suggest = "stop_sequences"
        elif key == "topK":
            suggest = "top_k"
        elif key == "topP":
            suggest = "top_p"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentInferenceConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentInferenceConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentInferenceConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 maximum_length: Optional[_builtins.float] = None,
                 stop_sequences: Optional[Sequence[_builtins.str]] = None,
                 temperature: Optional[_builtins.float] = None,
                 top_k: Optional[_builtins.float] = None,
                 top_p: Optional[_builtins.float] = None):
        """
        Configuration for inference in prompt configuration
        :param _builtins.float maximum_length: Maximum length of output
        :param Sequence[_builtins.str] stop_sequences: List of stop sequences
        :param _builtins.float temperature: Controls randomness, higher values increase diversity
        :param _builtins.float top_k: Sample from the k most likely next tokens
        :param _builtins.float top_p: Cumulative probability cutoff for token selection
        """
        if maximum_length is not None:
            pulumi.set(__self__, "maximum_length", maximum_length)
        if stop_sequences is not None:
            pulumi.set(__self__, "stop_sequences", stop_sequences)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)
        if top_k is not None:
            pulumi.set(__self__, "top_k", top_k)
        if top_p is not None:
            pulumi.set(__self__, "top_p", top_p)

    @_builtins.property
    @pulumi.getter(name="maximumLength")
    def maximum_length(self) -> Optional[_builtins.float]:
        """
        Maximum length of output
        """
        return pulumi.get(self, "maximum_length")

    @_builtins.property
    @pulumi.getter(name="stopSequences")
    def stop_sequences(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of stop sequences
        """
        return pulumi.get(self, "stop_sequences")

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[_builtins.float]:
        """
        Controls randomness, higher values increase diversity
        """
        return pulumi.get(self, "temperature")

    @_builtins.property
    @pulumi.getter(name="topK")
    def top_k(self) -> Optional[_builtins.float]:
        """
        Sample from the k most likely next tokens
        """
        return pulumi.get(self, "top_k")

    @_builtins.property
    @pulumi.getter(name="topP")
    def top_p(self) -> Optional[_builtins.float]:
        """
        Cumulative probability cutoff for token selection
        """
        return pulumi.get(self, "top_p")


@pulumi.output_type
class AgentKnowledgeBase(dict):
    """
    Agent Knowledge Base
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "knowledgeBaseId":
            suggest = "knowledge_base_id"
        elif key == "knowledgeBaseState":
            suggest = "knowledge_base_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentKnowledgeBase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentKnowledgeBase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentKnowledgeBase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: _builtins.str,
                 knowledge_base_id: _builtins.str,
                 knowledge_base_state: Optional['AgentKnowledgeBaseState'] = None):
        """
        Agent Knowledge Base
        :param _builtins.str description: Description of the Resource.
        :param _builtins.str knowledge_base_id: Identifier for a resource.
        :param 'AgentKnowledgeBaseState' knowledge_base_state: Specifies whether to use the knowledge base or not when sending an [InvokeAgent](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html) request.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "knowledge_base_id", knowledge_base_id)
        if knowledge_base_state is not None:
            pulumi.set(__self__, "knowledge_base_state", knowledge_base_state)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of the Resource.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="knowledgeBaseId")
    def knowledge_base_id(self) -> _builtins.str:
        """
        Identifier for a resource.
        """
        return pulumi.get(self, "knowledge_base_id")

    @_builtins.property
    @pulumi.getter(name="knowledgeBaseState")
    def knowledge_base_state(self) -> Optional['AgentKnowledgeBaseState']:
        """
        Specifies whether to use the knowledge base or not when sending an [InvokeAgent](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_InvokeAgent.html) request.
        """
        return pulumi.get(self, "knowledge_base_state")


@pulumi.output_type
class AgentMemoryConfiguration(dict):
    """
    Configuration for memory storage
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enabledMemoryTypes":
            suggest = "enabled_memory_types"
        elif key == "sessionSummaryConfiguration":
            suggest = "session_summary_configuration"
        elif key == "storageDays":
            suggest = "storage_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentMemoryConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentMemoryConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentMemoryConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled_memory_types: Optional[Sequence['AgentMemoryType']] = None,
                 session_summary_configuration: Optional['outputs.AgentSessionSummaryConfiguration'] = None,
                 storage_days: Optional[_builtins.float] = None):
        """
        Configuration for memory storage
        :param Sequence['AgentMemoryType'] enabled_memory_types: The type of memory that is stored.
        :param 'AgentSessionSummaryConfiguration' session_summary_configuration: Contains the configuration for SESSION_SUMMARY memory type enabled for the agent.
        :param _builtins.float storage_days: Maximum number of days to store session details
        """
        if enabled_memory_types is not None:
            pulumi.set(__self__, "enabled_memory_types", enabled_memory_types)
        if session_summary_configuration is not None:
            pulumi.set(__self__, "session_summary_configuration", session_summary_configuration)
        if storage_days is not None:
            pulumi.set(__self__, "storage_days", storage_days)

    @_builtins.property
    @pulumi.getter(name="enabledMemoryTypes")
    def enabled_memory_types(self) -> Optional[Sequence['AgentMemoryType']]:
        """
        The type of memory that is stored.
        """
        return pulumi.get(self, "enabled_memory_types")

    @_builtins.property
    @pulumi.getter(name="sessionSummaryConfiguration")
    def session_summary_configuration(self) -> Optional['outputs.AgentSessionSummaryConfiguration']:
        """
        Contains the configuration for SESSION_SUMMARY memory type enabled for the agent.
        """
        return pulumi.get(self, "session_summary_configuration")

    @_builtins.property
    @pulumi.getter(name="storageDays")
    def storage_days(self) -> Optional[_builtins.float]:
        """
        Maximum number of days to store session details
        """
        return pulumi.get(self, "storage_days")


@pulumi.output_type
class AgentOrchestrationExecutor(dict):
    """
    Types of executors for custom orchestration strategy
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lambda":
            suggest = "lambda_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentOrchestrationExecutor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentOrchestrationExecutor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentOrchestrationExecutor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lambda_: _builtins.str):
        """
        Types of executors for custom orchestration strategy
        :param _builtins.str lambda_: ARN of a Lambda.
        """
        pulumi.set(__self__, "lambda_", lambda_)

    @_builtins.property
    @pulumi.getter(name="lambda")
    def lambda_(self) -> _builtins.str:
        """
        ARN of a Lambda.
        """
        return pulumi.get(self, "lambda_")


@pulumi.output_type
class AgentParameterDetail(dict):
    """
    Parameter detail
    """
    def __init__(__self__, *,
                 type: 'AgentType',
                 description: Optional[_builtins.str] = None,
                 required: Optional[_builtins.bool] = None):
        """
        Parameter detail
        :param 'AgentType' type: The data type of the parameter.
        :param _builtins.str description: Description of function parameter.
        :param _builtins.bool required: Information about if a parameter is required for function call. Default to false.
        """
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'AgentType':
        """
        The data type of the parameter.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of function parameter.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[_builtins.bool]:
        """
        Information about if a parameter is required for function call. Default to false.
        """
        return pulumi.get(self, "required")


@pulumi.output_type
class AgentPromptConfiguration(dict):
    """
    BasePromptConfiguration per Prompt Type.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalModelRequestFields":
            suggest = "additional_model_request_fields"
        elif key == "basePromptTemplate":
            suggest = "base_prompt_template"
        elif key == "foundationModel":
            suggest = "foundation_model"
        elif key == "inferenceConfiguration":
            suggest = "inference_configuration"
        elif key == "parserMode":
            suggest = "parser_mode"
        elif key == "promptCreationMode":
            suggest = "prompt_creation_mode"
        elif key == "promptState":
            suggest = "prompt_state"
        elif key == "promptType":
            suggest = "prompt_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentPromptConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentPromptConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentPromptConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_model_request_fields: Optional['outputs.AgentAdditionalModelRequestFields'] = None,
                 base_prompt_template: Optional[_builtins.str] = None,
                 foundation_model: Optional[_builtins.str] = None,
                 inference_configuration: Optional['outputs.AgentInferenceConfiguration'] = None,
                 parser_mode: Optional['AgentCreationMode'] = None,
                 prompt_creation_mode: Optional['AgentCreationMode'] = None,
                 prompt_state: Optional['AgentPromptState'] = None,
                 prompt_type: Optional['AgentPromptType'] = None):
        """
        BasePromptConfiguration per Prompt Type.
        :param 'AgentAdditionalModelRequestFields' additional_model_request_fields: If the Converse or ConverseStream operations support the model, `additionalModelRequestFields` contains additional inference parameters, beyond the base set of inference parameters in the `inferenceConfiguration` field.
               
               For more information, see [Inference request parameters and response fields for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html) .
        :param _builtins.str base_prompt_template: Base Prompt Template.
        :param _builtins.str foundation_model: The agent's foundation model.
        :param 'AgentInferenceConfiguration' inference_configuration: Contains inference parameters to use when the agent invokes a foundation model in the part of the agent sequence defined by the `promptType` . For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html) .
        :param 'AgentCreationMode' parser_mode: Specifies whether to override the default parser Lambda function when parsing the raw foundation model output in the part of the agent sequence defined by the `promptType` . If you set the field as `OVERRIDDEN` , the `overrideLambda` field in the [PromptOverrideConfiguration](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PromptOverrideConfiguration.html) must be specified with the ARN of a Lambda function.
        :param 'AgentCreationMode' prompt_creation_mode: Specifies whether to override the default prompt template for this `promptType` . Set this value to `OVERRIDDEN` to use the prompt that you provide in the `basePromptTemplate` . If you leave it as `DEFAULT` , the agent uses a default prompt template.
        :param 'AgentPromptState' prompt_state: Specifies whether to allow the inline agent to carry out the step specified in the `promptType` . If you set this value to `DISABLED` , the agent skips that step. The default state for each `promptType` is as follows.
               
               - `PRE_PROCESSING`  `ENABLED`
               - `ORCHESTRATION`  `ENABLED`
               - `KNOWLEDGE_BASE_RESPONSE_GENERATION`  `ENABLED`
               - `POST_PROCESSING`  `DISABLED`
        :param 'AgentPromptType' prompt_type: The step in the agent sequence that this prompt configuration applies to.
        """
        if additional_model_request_fields is not None:
            pulumi.set(__self__, "additional_model_request_fields", additional_model_request_fields)
        if base_prompt_template is not None:
            pulumi.set(__self__, "base_prompt_template", base_prompt_template)
        if foundation_model is not None:
            pulumi.set(__self__, "foundation_model", foundation_model)
        if inference_configuration is not None:
            pulumi.set(__self__, "inference_configuration", inference_configuration)
        if parser_mode is not None:
            pulumi.set(__self__, "parser_mode", parser_mode)
        if prompt_creation_mode is not None:
            pulumi.set(__self__, "prompt_creation_mode", prompt_creation_mode)
        if prompt_state is not None:
            pulumi.set(__self__, "prompt_state", prompt_state)
        if prompt_type is not None:
            pulumi.set(__self__, "prompt_type", prompt_type)

    @_builtins.property
    @pulumi.getter(name="additionalModelRequestFields")
    def additional_model_request_fields(self) -> Optional['outputs.AgentAdditionalModelRequestFields']:
        """
        If the Converse or ConverseStream operations support the model, `additionalModelRequestFields` contains additional inference parameters, beyond the base set of inference parameters in the `inferenceConfiguration` field.

        For more information, see [Inference request parameters and response fields for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html) .
        """
        return pulumi.get(self, "additional_model_request_fields")

    @_builtins.property
    @pulumi.getter(name="basePromptTemplate")
    def base_prompt_template(self) -> Optional[_builtins.str]:
        """
        Base Prompt Template.
        """
        return pulumi.get(self, "base_prompt_template")

    @_builtins.property
    @pulumi.getter(name="foundationModel")
    def foundation_model(self) -> Optional[_builtins.str]:
        """
        The agent's foundation model.
        """
        return pulumi.get(self, "foundation_model")

    @_builtins.property
    @pulumi.getter(name="inferenceConfiguration")
    def inference_configuration(self) -> Optional['outputs.AgentInferenceConfiguration']:
        """
        Contains inference parameters to use when the agent invokes a foundation model in the part of the agent sequence defined by the `promptType` . For more information, see [Inference parameters for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html) .
        """
        return pulumi.get(self, "inference_configuration")

    @_builtins.property
    @pulumi.getter(name="parserMode")
    def parser_mode(self) -> Optional['AgentCreationMode']:
        """
        Specifies whether to override the default parser Lambda function when parsing the raw foundation model output in the part of the agent sequence defined by the `promptType` . If you set the field as `OVERRIDDEN` , the `overrideLambda` field in the [PromptOverrideConfiguration](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent_PromptOverrideConfiguration.html) must be specified with the ARN of a Lambda function.
        """
        return pulumi.get(self, "parser_mode")

    @_builtins.property
    @pulumi.getter(name="promptCreationMode")
    def prompt_creation_mode(self) -> Optional['AgentCreationMode']:
        """
        Specifies whether to override the default prompt template for this `promptType` . Set this value to `OVERRIDDEN` to use the prompt that you provide in the `basePromptTemplate` . If you leave it as `DEFAULT` , the agent uses a default prompt template.
        """
        return pulumi.get(self, "prompt_creation_mode")

    @_builtins.property
    @pulumi.getter(name="promptState")
    def prompt_state(self) -> Optional['AgentPromptState']:
        """
        Specifies whether to allow the inline agent to carry out the step specified in the `promptType` . If you set this value to `DISABLED` , the agent skips that step. The default state for each `promptType` is as follows.

        - `PRE_PROCESSING`  `ENABLED`
        - `ORCHESTRATION`  `ENABLED`
        - `KNOWLEDGE_BASE_RESPONSE_GENERATION`  `ENABLED`
        - `POST_PROCESSING`  `DISABLED`
        """
        return pulumi.get(self, "prompt_state")

    @_builtins.property
    @pulumi.getter(name="promptType")
    def prompt_type(self) -> Optional['AgentPromptType']:
        """
        The step in the agent sequence that this prompt configuration applies to.
        """
        return pulumi.get(self, "prompt_type")


@pulumi.output_type
class AgentPromptOverrideConfiguration(dict):
    """
    Configuration for prompt override.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "promptConfigurations":
            suggest = "prompt_configurations"
        elif key == "overrideLambda":
            suggest = "override_lambda"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentPromptOverrideConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentPromptOverrideConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentPromptOverrideConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prompt_configurations: Sequence['outputs.AgentPromptConfiguration'],
                 override_lambda: Optional[_builtins.str] = None):
        """
        Configuration for prompt override.
        :param Sequence['AgentPromptConfiguration'] prompt_configurations: List of BasePromptConfiguration
        :param _builtins.str override_lambda: ARN of a Lambda.
        """
        pulumi.set(__self__, "prompt_configurations", prompt_configurations)
        if override_lambda is not None:
            pulumi.set(__self__, "override_lambda", override_lambda)

    @_builtins.property
    @pulumi.getter(name="promptConfigurations")
    def prompt_configurations(self) -> Sequence['outputs.AgentPromptConfiguration']:
        """
        List of BasePromptConfiguration
        """
        return pulumi.get(self, "prompt_configurations")

    @_builtins.property
    @pulumi.getter(name="overrideLambda")
    def override_lambda(self) -> Optional[_builtins.str]:
        """
        ARN of a Lambda.
        """
        return pulumi.get(self, "override_lambda")


@pulumi.output_type
class AgentS3Identifier(dict):
    """
    The identifier for the S3 resource.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "s3BucketName":
            suggest = "s3_bucket_name"
        elif key == "s3ObjectKey":
            suggest = "s3_object_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentS3Identifier. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentS3Identifier.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentS3Identifier.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 s3_bucket_name: Optional[_builtins.str] = None,
                 s3_object_key: Optional[_builtins.str] = None):
        """
        The identifier for the S3 resource.
        :param _builtins.str s3_bucket_name: A bucket in S3.
        :param _builtins.str s3_object_key: A object key in S3.
        """
        if s3_bucket_name is not None:
            pulumi.set(__self__, "s3_bucket_name", s3_bucket_name)
        if s3_object_key is not None:
            pulumi.set(__self__, "s3_object_key", s3_object_key)

    @_builtins.property
    @pulumi.getter(name="s3BucketName")
    def s3_bucket_name(self) -> Optional[_builtins.str]:
        """
        A bucket in S3.
        """
        return pulumi.get(self, "s3_bucket_name")

    @_builtins.property
    @pulumi.getter(name="s3ObjectKey")
    def s3_object_key(self) -> Optional[_builtins.str]:
        """
        A object key in S3.
        """
        return pulumi.get(self, "s3_object_key")


@pulumi.output_type
class AgentSessionSummaryConfiguration(dict):
    """
    Configuration for Session Summarization
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxRecentSessions":
            suggest = "max_recent_sessions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentSessionSummaryConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentSessionSummaryConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentSessionSummaryConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_recent_sessions: Optional[_builtins.float] = None):
        """
        Configuration for Session Summarization
        :param _builtins.float max_recent_sessions: Maximum number of Sessions to Summarize
        """
        if max_recent_sessions is not None:
            pulumi.set(__self__, "max_recent_sessions", max_recent_sessions)

    @_builtins.property
    @pulumi.getter(name="maxRecentSessions")
    def max_recent_sessions(self) -> Optional[_builtins.float]:
        """
        Maximum number of Sessions to Summarize
        """
        return pulumi.get(self, "max_recent_sessions")


@pulumi.output_type
class ApplicationInferenceProfileInferenceProfileModel(dict):
    """
    Model configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "modelArn":
            suggest = "model_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationInferenceProfileInferenceProfileModel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationInferenceProfileInferenceProfileModel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationInferenceProfileInferenceProfileModel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 model_arn: Optional[_builtins.str] = None):
        """
        Model configuration
        :param _builtins.str model_arn: ARN for Foundation Models in Bedrock. These models can be used as base models for model customization jobs
        """
        if model_arn is not None:
            pulumi.set(__self__, "model_arn", model_arn)

    @_builtins.property
    @pulumi.getter(name="modelArn")
    def model_arn(self) -> Optional[_builtins.str]:
        """
        ARN for Foundation Models in Bedrock. These models can be used as base models for model customization jobs
        """
        return pulumi.get(self, "model_arn")


@pulumi.output_type
class ApplicationInferenceProfileInferenceProfileModelSourceProperties(dict):
    """
    Various ways to encode a list of models in a CreateInferenceProfile request
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "copyFrom":
            suggest = "copy_from"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApplicationInferenceProfileInferenceProfileModelSourceProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApplicationInferenceProfileInferenceProfileModelSourceProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApplicationInferenceProfileInferenceProfileModelSourceProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 copy_from: _builtins.str):
        """
        Various ways to encode a list of models in a CreateInferenceProfile request
        :param _builtins.str copy_from: Source arns for a custom inference profile to copy its regional load balancing config from. This
               can either be a foundation model or predefined inference profile ARN.
        """
        pulumi.set(__self__, "copy_from", copy_from)

    @_builtins.property
    @pulumi.getter(name="copyFrom")
    def copy_from(self) -> _builtins.str:
        """
        Source arns for a custom inference profile to copy its regional load balancing config from. This
        can either be a foundation model or predefined inference profile ARN.
        """
        return pulumi.get(self, "copy_from")


@pulumi.output_type
class AutomatedReasoningPolicyPolicyDefinition(dict):
    def __init__(__self__, *,
                 rules: Optional[Sequence['outputs.AutomatedReasoningPolicyPolicyDefinitionRule']] = None,
                 types: Optional[Sequence['outputs.AutomatedReasoningPolicyPolicyDefinitionType']] = None,
                 variables: Optional[Sequence['outputs.AutomatedReasoningPolicyPolicyDefinitionVariable']] = None,
                 version: Optional[_builtins.str] = None):
        """
        :param Sequence['AutomatedReasoningPolicyPolicyDefinitionRule'] rules: The rules definition block of an AutomatedReasoningPolicyDefinition.
        :param Sequence['AutomatedReasoningPolicyPolicyDefinitionType'] types: The types definition block of an AutomatedReasoningPolicyDefinition.
        :param Sequence['AutomatedReasoningPolicyPolicyDefinitionVariable'] variables: The variables definition block of an AutomatedReasoningPolicyDefinition.
        :param _builtins.str version: The policy format version.
        """
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if types is not None:
            pulumi.set(__self__, "types", types)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.AutomatedReasoningPolicyPolicyDefinitionRule']]:
        """
        The rules definition block of an AutomatedReasoningPolicyDefinition.
        """
        return pulumi.get(self, "rules")

    @_builtins.property
    @pulumi.getter
    def types(self) -> Optional[Sequence['outputs.AutomatedReasoningPolicyPolicyDefinitionType']]:
        """
        The types definition block of an AutomatedReasoningPolicyDefinition.
        """
        return pulumi.get(self, "types")

    @_builtins.property
    @pulumi.getter
    def variables(self) -> Optional[Sequence['outputs.AutomatedReasoningPolicyPolicyDefinitionVariable']]:
        """
        The variables definition block of an AutomatedReasoningPolicyDefinition.
        """
        return pulumi.get(self, "variables")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        The policy format version.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class AutomatedReasoningPolicyPolicyDefinitionRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alternateExpression":
            suggest = "alternate_expression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomatedReasoningPolicyPolicyDefinitionRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomatedReasoningPolicyPolicyDefinitionRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomatedReasoningPolicyPolicyDefinitionRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expression: _builtins.str,
                 id: _builtins.str,
                 alternate_expression: Optional[_builtins.str] = None):
        """
        :param _builtins.str expression: The SMT expression for this rule
        :param _builtins.str id: A unique id within the PolicyDefinition
        :param _builtins.str alternate_expression: An alternate expression for this rule
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "id", id)
        if alternate_expression is not None:
            pulumi.set(__self__, "alternate_expression", alternate_expression)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        The SMT expression for this rule
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        A unique id within the PolicyDefinition
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="alternateExpression")
    def alternate_expression(self) -> Optional[_builtins.str]:
        """
        An alternate expression for this rule
        """
        return pulumi.get(self, "alternate_expression")


@pulumi.output_type
class AutomatedReasoningPolicyPolicyDefinitionType(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence['outputs.AutomatedReasoningPolicyPolicyDefinitionTypeValue'],
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: A name for this type.
        :param Sequence['AutomatedReasoningPolicyPolicyDefinitionTypeValue'] values: A list of valid values for this type.
        :param _builtins.str description: A natural language description of this type.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A name for this type.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence['outputs.AutomatedReasoningPolicyPolicyDefinitionTypeValue']:
        """
        A list of valid values for this type.
        """
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A natural language description of this type.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class AutomatedReasoningPolicyPolicyDefinitionTypeValue(dict):
    def __init__(__self__, *,
                 value: _builtins.str,
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str value: The value of the type value.
        :param _builtins.str description: A natural language description of the type's value.
        """
        pulumi.set(__self__, "value", value)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of the type value.
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        A natural language description of the type's value.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class AutomatedReasoningPolicyPolicyDefinitionVariable(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 name: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str description: A natural language description of this variable.
        :param _builtins.str name: A name from this variable.
        :param _builtins.str type: A type for this variable.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        A natural language description of this variable.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A name from this variable.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        A type for this variable.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DataAutomationProjectAudioExtractionCategory(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "typeConfiguration":
            suggest = "type_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataAutomationProjectAudioExtractionCategory. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataAutomationProjectAudioExtractionCategory.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataAutomationProjectAudioExtractionCategory.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 state: 'DataAutomationProjectState',
                 type_configuration: Optional['outputs.DataAutomationProjectAudioExtractionCategoryTypeConfiguration'] = None,
                 types: Optional[Sequence['DataAutomationProjectAudioExtractionCategoryType']] = None):
        """
        :param 'DataAutomationProjectState' state: Whether generating categorical data from audio is enabled.
        :param 'DataAutomationProjectAudioExtractionCategoryTypeConfiguration' type_configuration: This element contains information about extractions from different types. Used to enable speaker and channel labeling for transcripts.
        :param Sequence['DataAutomationProjectAudioExtractionCategoryType'] types: The types of data to generate.
        """
        pulumi.set(__self__, "state", state)
        if type_configuration is not None:
            pulumi.set(__self__, "type_configuration", type_configuration)
        if types is not None:
            pulumi.set(__self__, "types", types)

    @_builtins.property
    @pulumi.getter
    def state(self) -> 'DataAutomationProjectState':
        """
        Whether generating categorical data from audio is enabled.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="typeConfiguration")
    def type_configuration(self) -> Optional['outputs.DataAutomationProjectAudioExtractionCategoryTypeConfiguration']:
        """
        This element contains information about extractions from different types. Used to enable speaker and channel labeling for transcripts.
        """
        return pulumi.get(self, "type_configuration")

    @_builtins.property
    @pulumi.getter
    def types(self) -> Optional[Sequence['DataAutomationProjectAudioExtractionCategoryType']]:
        """
        The types of data to generate.
        """
        return pulumi.get(self, "types")


@pulumi.output_type
class DataAutomationProjectAudioExtractionCategoryTypeConfiguration(dict):
    def __init__(__self__, *,
                 transcript: Optional['outputs.DataAutomationProjectTranscriptConfiguration'] = None):
        """
        :param 'DataAutomationProjectTranscriptConfiguration' transcript: This element allows you to configure different extractions for your transcript data, such as speaker and channel labeling.
        """
        if transcript is not None:
            pulumi.set(__self__, "transcript", transcript)

    @_builtins.property
    @pulumi.getter
    def transcript(self) -> Optional['outputs.DataAutomationProjectTranscriptConfiguration']:
        """
        This element allows you to configure different extractions for your transcript data, such as speaker and channel labeling.
        """
        return pulumi.get(self, "transcript")


@pulumi.output_type
class DataAutomationProjectAudioOverrideConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "modalityProcessing":
            suggest = "modality_processing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataAutomationProjectAudioOverrideConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataAutomationProjectAudioOverrideConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataAutomationProjectAudioOverrideConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 modality_processing: Optional['outputs.DataAutomationProjectModalityProcessingConfiguration'] = None):
        """
        :param 'DataAutomationProjectModalityProcessingConfiguration' modality_processing: Sets modality processing for audio files. All modalities are enabled by default.
        """
        if modality_processing is not None:
            pulumi.set(__self__, "modality_processing", modality_processing)

    @_builtins.property
    @pulumi.getter(name="modalityProcessing")
    def modality_processing(self) -> Optional['outputs.DataAutomationProjectModalityProcessingConfiguration']:
        """
        Sets modality processing for audio files. All modalities are enabled by default.
        """
        return pulumi.get(self, "modality_processing")


@pulumi.output_type
class DataAutomationProjectAudioStandardExtraction(dict):
    def __init__(__self__, *,
                 category: 'outputs.DataAutomationProjectAudioExtractionCategory'):
        """
        :param 'DataAutomationProjectAudioExtractionCategory' category: Settings for generating data from audio.
        """
        pulumi.set(__self__, "category", category)

    @_builtins.property
    @pulumi.getter
    def category(self) -> 'outputs.DataAutomationProjectAudioExtractionCategory':
        """
        Settings for generating data from audio.
        """
        return pulumi.get(self, "category")


@pulumi.output_type
class DataAutomationProjectAudioStandardGenerativeField(dict):
    def __init__(__self__, *,
                 state: 'DataAutomationProjectState',
                 types: Optional[Sequence['DataAutomationProjectAudioStandardGenerativeFieldType']] = None):
        """
        :param 'DataAutomationProjectState' state: Whether generating descriptions is enabled for audio.
        :param Sequence['DataAutomationProjectAudioStandardGenerativeFieldType'] types: The types of description to generate.
        """
        pulumi.set(__self__, "state", state)
        if types is not None:
            pulumi.set(__self__, "types", types)

    @_builtins.property
    @pulumi.getter
    def state(self) -> 'DataAutomationProjectState':
        """
        Whether generating descriptions is enabled for audio.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def types(self) -> Optional[Sequence['DataAutomationProjectAudioStandardGenerativeFieldType']]:
        """
        The types of description to generate.
        """
        return pulumi.get(self, "types")


@pulumi.output_type
class DataAutomationProjectAudioStandardOutputConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "generativeField":
            suggest = "generative_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataAutomationProjectAudioStandardOutputConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataAutomationProjectAudioStandardOutputConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataAutomationProjectAudioStandardOutputConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 extraction: Optional['outputs.DataAutomationProjectAudioStandardExtraction'] = None,
                 generative_field: Optional['outputs.DataAutomationProjectAudioStandardGenerativeField'] = None):
        """
        :param 'DataAutomationProjectAudioStandardExtraction' extraction: Settings for populating data fields that describe the audio.
        :param 'DataAutomationProjectAudioStandardGenerativeField' generative_field: Whether to generate descriptions of the data.
        """
        if extraction is not None:
            pulumi.set(__self__, "extraction", extraction)
        if generative_field is not None:
            pulumi.set(__self__, "generative_field", generative_field)

    @_builtins.property
    @pulumi.getter
    def extraction(self) -> Optional['outputs.DataAutomationProjectAudioStandardExtraction']:
        """
        Settings for populating data fields that describe the audio.
        """
        return pulumi.get(self, "extraction")

    @_builtins.property
    @pulumi.getter(name="generativeField")
    def generative_field(self) -> Optional['outputs.DataAutomationProjectAudioStandardGenerativeField']:
        """
        Whether to generate descriptions of the data.
        """
        return pulumi.get(self, "generative_field")


@pulumi.output_type
class DataAutomationProjectBlueprintItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blueprintArn":
            suggest = "blueprint_arn"
        elif key == "blueprintStage":
            suggest = "blueprint_stage"
        elif key == "blueprintVersion":
            suggest = "blueprint_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataAutomationProjectBlueprintItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataAutomationProjectBlueprintItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataAutomationProjectBlueprintItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 blueprint_arn: _builtins.str,
                 blueprint_stage: Optional['DataAutomationProjectBlueprintStage'] = None,
                 blueprint_version: Optional[_builtins.str] = None):
        """
        :param _builtins.str blueprint_arn: ARN of a Blueprint
        :param 'DataAutomationProjectBlueprintStage' blueprint_stage: The blueprint's stage.
        :param _builtins.str blueprint_version: Blueprint Version
        """
        pulumi.set(__self__, "blueprint_arn", blueprint_arn)
        if blueprint_stage is not None:
            pulumi.set(__self__, "blueprint_stage", blueprint_stage)
        if blueprint_version is not None:
            pulumi.set(__self__, "blueprint_version", blueprint_version)

    @_builtins.property
    @pulumi.getter(name="blueprintArn")
    def blueprint_arn(self) -> _builtins.str:
        """
        ARN of a Blueprint
        """
        return pulumi.get(self, "blueprint_arn")

    @_builtins.property
    @pulumi.getter(name="blueprintStage")
    def blueprint_stage(self) -> Optional['DataAutomationProjectBlueprintStage']:
        """
        The blueprint's stage.
        """
        return pulumi.get(self, "blueprint_stage")

    @_builtins.property
    @pulumi.getter(name="blueprintVersion")
    def blueprint_version(self) -> Optional[_builtins.str]:
        """
        Blueprint Version
        """
        return pulumi.get(self, "blueprint_version")


@pulumi.output_type
class DataAutomationProjectChannelLabelingConfiguration(dict):
    def __init__(__self__, *,
                 state: 'DataAutomationProjectState'):
        """
        :param 'DataAutomationProjectState' state: State of channel labeling, either enabled or disabled.
        """
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> 'DataAutomationProjectState':
        """
        State of channel labeling, either enabled or disabled.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DataAutomationProjectCustomOutputConfiguration(dict):
    """
    Custom output configuration
    """
    def __init__(__self__, *,
                 blueprints: Optional[Sequence['outputs.DataAutomationProjectBlueprintItem']] = None):
        """
        Custom output configuration
        :param Sequence['DataAutomationProjectBlueprintItem'] blueprints: A list of blueprints.
        """
        if blueprints is not None:
            pulumi.set(__self__, "blueprints", blueprints)

    @_builtins.property
    @pulumi.getter
    def blueprints(self) -> Optional[Sequence['outputs.DataAutomationProjectBlueprintItem']]:
        """
        A list of blueprints.
        """
        return pulumi.get(self, "blueprints")


@pulumi.output_type
class DataAutomationProjectDocumentBoundingBox(dict):
    def __init__(__self__, *,
                 state: 'DataAutomationProjectState'):
        """
        :param 'DataAutomationProjectState' state: Whether bounding boxes are enabled for documents.
        """
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> 'DataAutomationProjectState':
        """
        Whether bounding boxes are enabled for documents.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DataAutomationProjectDocumentExtractionGranularity(dict):
    def __init__(__self__, *,
                 types: Optional[Sequence['DataAutomationProjectDocumentExtractionGranularityType']] = None):
        """
        :param Sequence['DataAutomationProjectDocumentExtractionGranularityType'] types: Granularity settings for documents.
        """
        if types is not None:
            pulumi.set(__self__, "types", types)

    @_builtins.property
    @pulumi.getter
    def types(self) -> Optional[Sequence['DataAutomationProjectDocumentExtractionGranularityType']]:
        """
        Granularity settings for documents.
        """
        return pulumi.get(self, "types")


@pulumi.output_type
class DataAutomationProjectDocumentOutputAdditionalFileFormat(dict):
    def __init__(__self__, *,
                 state: 'DataAutomationProjectState'):
        """
        :param 'DataAutomationProjectState' state: Whether additional file formats are enabled for a project.
        """
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> 'DataAutomationProjectState':
        """
        Whether additional file formats are enabled for a project.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DataAutomationProjectDocumentOutputFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalFileFormat":
            suggest = "additional_file_format"
        elif key == "textFormat":
            suggest = "text_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataAutomationProjectDocumentOutputFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataAutomationProjectDocumentOutputFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataAutomationProjectDocumentOutputFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_file_format: 'outputs.DataAutomationProjectDocumentOutputAdditionalFileFormat',
                 text_format: 'outputs.DataAutomationProjectDocumentOutputTextFormat'):
        """
        :param 'DataAutomationProjectDocumentOutputAdditionalFileFormat' additional_file_format: Output settings for additional file formats.
        :param 'DataAutomationProjectDocumentOutputTextFormat' text_format: An output text format.
        """
        pulumi.set(__self__, "additional_file_format", additional_file_format)
        pulumi.set(__self__, "text_format", text_format)

    @_builtins.property
    @pulumi.getter(name="additionalFileFormat")
    def additional_file_format(self) -> 'outputs.DataAutomationProjectDocumentOutputAdditionalFileFormat':
        """
        Output settings for additional file formats.
        """
        return pulumi.get(self, "additional_file_format")

    @_builtins.property
    @pulumi.getter(name="textFormat")
    def text_format(self) -> 'outputs.DataAutomationProjectDocumentOutputTextFormat':
        """
        An output text format.
        """
        return pulumi.get(self, "text_format")


@pulumi.output_type
class DataAutomationProjectDocumentOutputTextFormat(dict):
    def __init__(__self__, *,
                 types: Optional[Sequence['DataAutomationProjectDocumentOutputTextFormatType']] = None):
        """
        :param Sequence['DataAutomationProjectDocumentOutputTextFormatType'] types: The types of output text to generate.
        """
        if types is not None:
            pulumi.set(__self__, "types", types)

    @_builtins.property
    @pulumi.getter
    def types(self) -> Optional[Sequence['DataAutomationProjectDocumentOutputTextFormatType']]:
        """
        The types of output text to generate.
        """
        return pulumi.get(self, "types")


@pulumi.output_type
class DataAutomationProjectDocumentOverrideConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "modalityProcessing":
            suggest = "modality_processing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataAutomationProjectDocumentOverrideConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataAutomationProjectDocumentOverrideConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataAutomationProjectDocumentOverrideConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 modality_processing: Optional['outputs.DataAutomationProjectModalityProcessingConfiguration'] = None,
                 splitter: Optional['outputs.DataAutomationProjectSplitterConfiguration'] = None):
        """
        :param 'DataAutomationProjectModalityProcessingConfiguration' modality_processing: Sets modality processing for document files. All modalities are enabled by default.
        :param 'DataAutomationProjectSplitterConfiguration' splitter: Whether document splitter is enabled for a project.
        """
        if modality_processing is not None:
            pulumi.set(__self__, "modality_processing", modality_processing)
        if splitter is not None:
            pulumi.set(__self__, "splitter", splitter)

    @_builtins.property
    @pulumi.getter(name="modalityProcessing")
    def modality_processing(self) -> Optional['outputs.DataAutomationProjectModalityProcessingConfiguration']:
        """
        Sets modality processing for document files. All modalities are enabled by default.
        """
        return pulumi.get(self, "modality_processing")

    @_builtins.property
    @pulumi.getter
    def splitter(self) -> Optional['outputs.DataAutomationProjectSplitterConfiguration']:
        """
        Whether document splitter is enabled for a project.
        """
        return pulumi.get(self, "splitter")


@pulumi.output_type
class DataAutomationProjectDocumentStandardExtraction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "boundingBox":
            suggest = "bounding_box"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataAutomationProjectDocumentStandardExtraction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataAutomationProjectDocumentStandardExtraction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataAutomationProjectDocumentStandardExtraction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bounding_box: 'outputs.DataAutomationProjectDocumentBoundingBox',
                 granularity: 'outputs.DataAutomationProjectDocumentExtractionGranularity'):
        """
        :param 'DataAutomationProjectDocumentBoundingBox' bounding_box: Whether to generate bounding boxes.
        :param 'DataAutomationProjectDocumentExtractionGranularity' granularity: Which granularities to generate data for.
        """
        pulumi.set(__self__, "bounding_box", bounding_box)
        pulumi.set(__self__, "granularity", granularity)

    @_builtins.property
    @pulumi.getter(name="boundingBox")
    def bounding_box(self) -> 'outputs.DataAutomationProjectDocumentBoundingBox':
        """
        Whether to generate bounding boxes.
        """
        return pulumi.get(self, "bounding_box")

    @_builtins.property
    @pulumi.getter
    def granularity(self) -> 'outputs.DataAutomationProjectDocumentExtractionGranularity':
        """
        Which granularities to generate data for.
        """
        return pulumi.get(self, "granularity")


@pulumi.output_type
class DataAutomationProjectDocumentStandardGenerativeField(dict):
    def __init__(__self__, *,
                 state: 'DataAutomationProjectState'):
        """
        :param 'DataAutomationProjectState' state: Whether generating descriptions is enabled for documents.
        """
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> 'DataAutomationProjectState':
        """
        Whether generating descriptions is enabled for documents.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DataAutomationProjectDocumentStandardOutputConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "generativeField":
            suggest = "generative_field"
        elif key == "outputFormat":
            suggest = "output_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataAutomationProjectDocumentStandardOutputConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataAutomationProjectDocumentStandardOutputConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataAutomationProjectDocumentStandardOutputConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 extraction: Optional['outputs.DataAutomationProjectDocumentStandardExtraction'] = None,
                 generative_field: Optional['outputs.DataAutomationProjectDocumentStandardGenerativeField'] = None,
                 output_format: Optional['outputs.DataAutomationProjectDocumentOutputFormat'] = None):
        """
        :param 'DataAutomationProjectDocumentStandardExtraction' extraction: Settings for populating data fields that describe the document.
        :param 'DataAutomationProjectDocumentStandardGenerativeField' generative_field: Whether to generate descriptions.
        :param 'DataAutomationProjectDocumentOutputFormat' output_format: The output format to generate.
        """
        if extraction is not None:
            pulumi.set(__self__, "extraction", extraction)
        if generative_field is not None:
            pulumi.set(__self__, "generative_field", generative_field)
        if output_format is not None:
            pulumi.set(__self__, "output_format", output_format)

    @_builtins.property
    @pulumi.getter
    def extraction(self) -> Optional['outputs.DataAutomationProjectDocumentStandardExtraction']:
        """
        Settings for populating data fields that describe the document.
        """
        return pulumi.get(self, "extraction")

    @_builtins.property
    @pulumi.getter(name="generativeField")
    def generative_field(self) -> Optional['outputs.DataAutomationProjectDocumentStandardGenerativeField']:
        """
        Whether to generate descriptions.
        """
        return pulumi.get(self, "generative_field")

    @_builtins.property
    @pulumi.getter(name="outputFormat")
    def output_format(self) -> Optional['outputs.DataAutomationProjectDocumentOutputFormat']:
        """
        The output format to generate.
        """
        return pulumi.get(self, "output_format")


@pulumi.output_type
class DataAutomationProjectImageBoundingBox(dict):
    def __init__(__self__, *,
                 state: 'DataAutomationProjectState'):
        """
        :param 'DataAutomationProjectState' state: Bounding box settings for a project.
        """
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> 'DataAutomationProjectState':
        """
        Bounding box settings for a project.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DataAutomationProjectImageExtractionCategory(dict):
    def __init__(__self__, *,
                 state: 'DataAutomationProjectState',
                 types: Optional[Sequence['DataAutomationProjectImageExtractionCategoryType']] = None):
        """
        :param 'DataAutomationProjectState' state: Whether generating categorical data from images is enabled.
        :param Sequence['DataAutomationProjectImageExtractionCategoryType'] types: The types of data to generate.
        """
        pulumi.set(__self__, "state", state)
        if types is not None:
            pulumi.set(__self__, "types", types)

    @_builtins.property
    @pulumi.getter
    def state(self) -> 'DataAutomationProjectState':
        """
        Whether generating categorical data from images is enabled.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def types(self) -> Optional[Sequence['DataAutomationProjectImageExtractionCategoryType']]:
        """
        The types of data to generate.
        """
        return pulumi.get(self, "types")


@pulumi.output_type
class DataAutomationProjectImageOverrideConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "modalityProcessing":
            suggest = "modality_processing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataAutomationProjectImageOverrideConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataAutomationProjectImageOverrideConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataAutomationProjectImageOverrideConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 modality_processing: Optional['outputs.DataAutomationProjectModalityProcessingConfiguration'] = None):
        """
        :param 'DataAutomationProjectModalityProcessingConfiguration' modality_processing: Sets modality processing for image files. All modalities are enabled by default.
        """
        if modality_processing is not None:
            pulumi.set(__self__, "modality_processing", modality_processing)

    @_builtins.property
    @pulumi.getter(name="modalityProcessing")
    def modality_processing(self) -> Optional['outputs.DataAutomationProjectModalityProcessingConfiguration']:
        """
        Sets modality processing for image files. All modalities are enabled by default.
        """
        return pulumi.get(self, "modality_processing")


@pulumi.output_type
class DataAutomationProjectImageStandardExtraction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "boundingBox":
            suggest = "bounding_box"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataAutomationProjectImageStandardExtraction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataAutomationProjectImageStandardExtraction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataAutomationProjectImageStandardExtraction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bounding_box: 'outputs.DataAutomationProjectImageBoundingBox',
                 category: 'outputs.DataAutomationProjectImageExtractionCategory'):
        """
        :param 'DataAutomationProjectImageBoundingBox' bounding_box: Settings for generating bounding boxes.
        :param 'DataAutomationProjectImageExtractionCategory' category: Settings for generating categorical data.
        """
        pulumi.set(__self__, "bounding_box", bounding_box)
        pulumi.set(__self__, "category", category)

    @_builtins.property
    @pulumi.getter(name="boundingBox")
    def bounding_box(self) -> 'outputs.DataAutomationProjectImageBoundingBox':
        """
        Settings for generating bounding boxes.
        """
        return pulumi.get(self, "bounding_box")

    @_builtins.property
    @pulumi.getter
    def category(self) -> 'outputs.DataAutomationProjectImageExtractionCategory':
        """
        Settings for generating categorical data.
        """
        return pulumi.get(self, "category")


@pulumi.output_type
class DataAutomationProjectImageStandardGenerativeField(dict):
    def __init__(__self__, *,
                 state: 'DataAutomationProjectState',
                 types: Optional[Sequence['DataAutomationProjectImageStandardGenerativeFieldType']] = None):
        """
        :param 'DataAutomationProjectState' state: Whether generating descriptions is enabled for images.
        :param Sequence['DataAutomationProjectImageStandardGenerativeFieldType'] types: Settings for generating descriptions of images.
        """
        pulumi.set(__self__, "state", state)
        if types is not None:
            pulumi.set(__self__, "types", types)

    @_builtins.property
    @pulumi.getter
    def state(self) -> 'DataAutomationProjectState':
        """
        Whether generating descriptions is enabled for images.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def types(self) -> Optional[Sequence['DataAutomationProjectImageStandardGenerativeFieldType']]:
        """
        Settings for generating descriptions of images.
        """
        return pulumi.get(self, "types")


@pulumi.output_type
class DataAutomationProjectImageStandardOutputConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "generativeField":
            suggest = "generative_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataAutomationProjectImageStandardOutputConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataAutomationProjectImageStandardOutputConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataAutomationProjectImageStandardOutputConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 extraction: Optional['outputs.DataAutomationProjectImageStandardExtraction'] = None,
                 generative_field: Optional['outputs.DataAutomationProjectImageStandardGenerativeField'] = None):
        """
        :param 'DataAutomationProjectImageStandardExtraction' extraction: Settings for populating data fields that describe the image.
        :param 'DataAutomationProjectImageStandardGenerativeField' generative_field: Whether to generate descriptions of the data.
        """
        if extraction is not None:
            pulumi.set(__self__, "extraction", extraction)
        if generative_field is not None:
            pulumi.set(__self__, "generative_field", generative_field)

    @_builtins.property
    @pulumi.getter
    def extraction(self) -> Optional['outputs.DataAutomationProjectImageStandardExtraction']:
        """
        Settings for populating data fields that describe the image.
        """
        return pulumi.get(self, "extraction")

    @_builtins.property
    @pulumi.getter(name="generativeField")
    def generative_field(self) -> Optional['outputs.DataAutomationProjectImageStandardGenerativeField']:
        """
        Whether to generate descriptions of the data.
        """
        return pulumi.get(self, "generative_field")


@pulumi.output_type
class DataAutomationProjectModalityProcessingConfiguration(dict):
    def __init__(__self__, *,
                 state: Optional['DataAutomationProjectState'] = None):
        """
        :param 'DataAutomationProjectState' state: Stores the state of the modality for your project, set to either enabled or disabled
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional['DataAutomationProjectState']:
        """
        Stores the state of the modality for your project, set to either enabled or disabled
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DataAutomationProjectModalityRoutingConfiguration(dict):
    """
    Modality routing configuration
    """
    def __init__(__self__, *,
                 jpeg: Optional['DataAutomationProjectDesiredModality'] = None,
                 mov: Optional['DataAutomationProjectDesiredModality'] = None,
                 mp4: Optional['DataAutomationProjectDesiredModality'] = None,
                 png: Optional['DataAutomationProjectDesiredModality'] = None):
        """
        Modality routing configuration
        :param 'DataAutomationProjectDesiredModality' jpeg: Sets whether JPEG files are routed to document or image processing.
        :param 'DataAutomationProjectDesiredModality' mov: Sets whether MOV files are routed to audio or video processing.
        :param 'DataAutomationProjectDesiredModality' mp4: Sets whether MP4 files are routed to audio or video processing.
        :param 'DataAutomationProjectDesiredModality' png: Sets whether PNG files are routed to document or image processing.
        """
        if jpeg is not None:
            pulumi.set(__self__, "jpeg", jpeg)
        if mov is not None:
            pulumi.set(__self__, "mov", mov)
        if mp4 is not None:
            pulumi.set(__self__, "mp4", mp4)
        if png is not None:
            pulumi.set(__self__, "png", png)

    @_builtins.property
    @pulumi.getter
    def jpeg(self) -> Optional['DataAutomationProjectDesiredModality']:
        """
        Sets whether JPEG files are routed to document or image processing.
        """
        return pulumi.get(self, "jpeg")

    @_builtins.property
    @pulumi.getter
    def mov(self) -> Optional['DataAutomationProjectDesiredModality']:
        """
        Sets whether MOV files are routed to audio or video processing.
        """
        return pulumi.get(self, "mov")

    @_builtins.property
    @pulumi.getter
    def mp4(self) -> Optional['DataAutomationProjectDesiredModality']:
        """
        Sets whether MP4 files are routed to audio or video processing.
        """
        return pulumi.get(self, "mp4")

    @_builtins.property
    @pulumi.getter
    def png(self) -> Optional['DataAutomationProjectDesiredModality']:
        """
        Sets whether PNG files are routed to document or image processing.
        """
        return pulumi.get(self, "png")


@pulumi.output_type
class DataAutomationProjectOverrideConfiguration(dict):
    """
    Override configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "modalityRouting":
            suggest = "modality_routing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataAutomationProjectOverrideConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataAutomationProjectOverrideConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataAutomationProjectOverrideConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio: Optional['outputs.DataAutomationProjectAudioOverrideConfiguration'] = None,
                 document: Optional['outputs.DataAutomationProjectDocumentOverrideConfiguration'] = None,
                 image: Optional['outputs.DataAutomationProjectImageOverrideConfiguration'] = None,
                 modality_routing: Optional['outputs.DataAutomationProjectModalityRoutingConfiguration'] = None,
                 video: Optional['outputs.DataAutomationProjectVideoOverrideConfiguration'] = None):
        """
        Override configuration
        :param 'DataAutomationProjectAudioOverrideConfiguration' audio: This element declares whether your project will process audio files.
        :param 'DataAutomationProjectDocumentOverrideConfiguration' document: Additional settings for a project.
        :param 'DataAutomationProjectImageOverrideConfiguration' image: This element declares whether your project will process image files.
        :param 'DataAutomationProjectModalityRoutingConfiguration' modality_routing: Lets you set which modalities certain file types are processed as.
        :param 'DataAutomationProjectVideoOverrideConfiguration' video: This element declares whether your project will process video files.
        """
        if audio is not None:
            pulumi.set(__self__, "audio", audio)
        if document is not None:
            pulumi.set(__self__, "document", document)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if modality_routing is not None:
            pulumi.set(__self__, "modality_routing", modality_routing)
        if video is not None:
            pulumi.set(__self__, "video", video)

    @_builtins.property
    @pulumi.getter
    def audio(self) -> Optional['outputs.DataAutomationProjectAudioOverrideConfiguration']:
        """
        This element declares whether your project will process audio files.
        """
        return pulumi.get(self, "audio")

    @_builtins.property
    @pulumi.getter
    def document(self) -> Optional['outputs.DataAutomationProjectDocumentOverrideConfiguration']:
        """
        Additional settings for a project.
        """
        return pulumi.get(self, "document")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional['outputs.DataAutomationProjectImageOverrideConfiguration']:
        """
        This element declares whether your project will process image files.
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter(name="modalityRouting")
    def modality_routing(self) -> Optional['outputs.DataAutomationProjectModalityRoutingConfiguration']:
        """
        Lets you set which modalities certain file types are processed as.
        """
        return pulumi.get(self, "modality_routing")

    @_builtins.property
    @pulumi.getter
    def video(self) -> Optional['outputs.DataAutomationProjectVideoOverrideConfiguration']:
        """
        This element declares whether your project will process video files.
        """
        return pulumi.get(self, "video")


@pulumi.output_type
class DataAutomationProjectSpeakerLabelingConfiguration(dict):
    def __init__(__self__, *,
                 state: 'DataAutomationProjectState'):
        """
        :param 'DataAutomationProjectState' state: State of speaker labeling, either enabled or disabled.
        """
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> 'DataAutomationProjectState':
        """
        State of speaker labeling, either enabled or disabled.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DataAutomationProjectSplitterConfiguration(dict):
    def __init__(__self__, *,
                 state: Optional['DataAutomationProjectState'] = None):
        """
        :param 'DataAutomationProjectState' state: Whether document splitter is enabled for a project.
        """
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional['DataAutomationProjectState']:
        """
        Whether document splitter is enabled for a project.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DataAutomationProjectStandardOutputConfiguration(dict):
    """
    Standard output configuration
    """
    def __init__(__self__, *,
                 audio: Optional['outputs.DataAutomationProjectAudioStandardOutputConfiguration'] = None,
                 document: Optional['outputs.DataAutomationProjectDocumentStandardOutputConfiguration'] = None,
                 image: Optional['outputs.DataAutomationProjectImageStandardOutputConfiguration'] = None,
                 video: Optional['outputs.DataAutomationProjectVideoStandardOutputConfiguration'] = None):
        """
        Standard output configuration
        :param 'DataAutomationProjectAudioStandardOutputConfiguration' audio: Settings for processing audio.
        :param 'DataAutomationProjectDocumentStandardOutputConfiguration' document: Settings for processing documents.
        :param 'DataAutomationProjectImageStandardOutputConfiguration' image: Settings for processing images.
        :param 'DataAutomationProjectVideoStandardOutputConfiguration' video: Settings for processing video.
        """
        if audio is not None:
            pulumi.set(__self__, "audio", audio)
        if document is not None:
            pulumi.set(__self__, "document", document)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if video is not None:
            pulumi.set(__self__, "video", video)

    @_builtins.property
    @pulumi.getter
    def audio(self) -> Optional['outputs.DataAutomationProjectAudioStandardOutputConfiguration']:
        """
        Settings for processing audio.
        """
        return pulumi.get(self, "audio")

    @_builtins.property
    @pulumi.getter
    def document(self) -> Optional['outputs.DataAutomationProjectDocumentStandardOutputConfiguration']:
        """
        Settings for processing documents.
        """
        return pulumi.get(self, "document")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional['outputs.DataAutomationProjectImageStandardOutputConfiguration']:
        """
        Settings for processing images.
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter
    def video(self) -> Optional['outputs.DataAutomationProjectVideoStandardOutputConfiguration']:
        """
        Settings for processing video.
        """
        return pulumi.get(self, "video")


@pulumi.output_type
class DataAutomationProjectTranscriptConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "channelLabeling":
            suggest = "channel_labeling"
        elif key == "speakerLabeling":
            suggest = "speaker_labeling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataAutomationProjectTranscriptConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataAutomationProjectTranscriptConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataAutomationProjectTranscriptConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 channel_labeling: Optional['outputs.DataAutomationProjectChannelLabelingConfiguration'] = None,
                 speaker_labeling: Optional['outputs.DataAutomationProjectSpeakerLabelingConfiguration'] = None):
        """
        :param 'DataAutomationProjectChannelLabelingConfiguration' channel_labeling: Enables channel labeling. Each audio channel will be labeled with a number, and the transcript will indicate which channel is being used.
        :param 'DataAutomationProjectSpeakerLabelingConfiguration' speaker_labeling: Enables speaker labeling. Each speaker within a transcript will recieve a number, and the transcript will note which speaker is talking.
        """
        if channel_labeling is not None:
            pulumi.set(__self__, "channel_labeling", channel_labeling)
        if speaker_labeling is not None:
            pulumi.set(__self__, "speaker_labeling", speaker_labeling)

    @_builtins.property
    @pulumi.getter(name="channelLabeling")
    def channel_labeling(self) -> Optional['outputs.DataAutomationProjectChannelLabelingConfiguration']:
        """
        Enables channel labeling. Each audio channel will be labeled with a number, and the transcript will indicate which channel is being used.
        """
        return pulumi.get(self, "channel_labeling")

    @_builtins.property
    @pulumi.getter(name="speakerLabeling")
    def speaker_labeling(self) -> Optional['outputs.DataAutomationProjectSpeakerLabelingConfiguration']:
        """
        Enables speaker labeling. Each speaker within a transcript will recieve a number, and the transcript will note which speaker is talking.
        """
        return pulumi.get(self, "speaker_labeling")


@pulumi.output_type
class DataAutomationProjectVideoBoundingBox(dict):
    def __init__(__self__, *,
                 state: 'DataAutomationProjectState'):
        """
        :param 'DataAutomationProjectState' state: Whether bounding boxes are enabled for video.
        """
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def state(self) -> 'DataAutomationProjectState':
        """
        Whether bounding boxes are enabled for video.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class DataAutomationProjectVideoExtractionCategory(dict):
    def __init__(__self__, *,
                 state: 'DataAutomationProjectState',
                 types: Optional[Sequence['DataAutomationProjectVideoExtractionCategoryType']] = None):
        """
        :param 'DataAutomationProjectState' state: Whether generating categorical data from video is enabled.
        :param Sequence['DataAutomationProjectVideoExtractionCategoryType'] types: The types of data to generate.
        """
        pulumi.set(__self__, "state", state)
        if types is not None:
            pulumi.set(__self__, "types", types)

    @_builtins.property
    @pulumi.getter
    def state(self) -> 'DataAutomationProjectState':
        """
        Whether generating categorical data from video is enabled.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def types(self) -> Optional[Sequence['DataAutomationProjectVideoExtractionCategoryType']]:
        """
        The types of data to generate.
        """
        return pulumi.get(self, "types")


@pulumi.output_type
class DataAutomationProjectVideoOverrideConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "modalityProcessing":
            suggest = "modality_processing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataAutomationProjectVideoOverrideConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataAutomationProjectVideoOverrideConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataAutomationProjectVideoOverrideConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 modality_processing: Optional['outputs.DataAutomationProjectModalityProcessingConfiguration'] = None):
        """
        :param 'DataAutomationProjectModalityProcessingConfiguration' modality_processing: Sets modality processing for video files. All modalities are enabled by default.
        """
        if modality_processing is not None:
            pulumi.set(__self__, "modality_processing", modality_processing)

    @_builtins.property
    @pulumi.getter(name="modalityProcessing")
    def modality_processing(self) -> Optional['outputs.DataAutomationProjectModalityProcessingConfiguration']:
        """
        Sets modality processing for video files. All modalities are enabled by default.
        """
        return pulumi.get(self, "modality_processing")


@pulumi.output_type
class DataAutomationProjectVideoStandardExtraction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "boundingBox":
            suggest = "bounding_box"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataAutomationProjectVideoStandardExtraction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataAutomationProjectVideoStandardExtraction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataAutomationProjectVideoStandardExtraction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bounding_box: 'outputs.DataAutomationProjectVideoBoundingBox',
                 category: 'outputs.DataAutomationProjectVideoExtractionCategory'):
        """
        :param 'DataAutomationProjectVideoBoundingBox' bounding_box: Settings for generating bounding boxes.
        :param 'DataAutomationProjectVideoExtractionCategory' category: Settings for generating categorical data.
        """
        pulumi.set(__self__, "bounding_box", bounding_box)
        pulumi.set(__self__, "category", category)

    @_builtins.property
    @pulumi.getter(name="boundingBox")
    def bounding_box(self) -> 'outputs.DataAutomationProjectVideoBoundingBox':
        """
        Settings for generating bounding boxes.
        """
        return pulumi.get(self, "bounding_box")

    @_builtins.property
    @pulumi.getter
    def category(self) -> 'outputs.DataAutomationProjectVideoExtractionCategory':
        """
        Settings for generating categorical data.
        """
        return pulumi.get(self, "category")


@pulumi.output_type
class DataAutomationProjectVideoStandardGenerativeField(dict):
    def __init__(__self__, *,
                 state: 'DataAutomationProjectState',
                 types: Optional[Sequence['DataAutomationProjectVideoStandardGenerativeFieldType']] = None):
        """
        :param 'DataAutomationProjectState' state: Whether generating descriptions is enabled for video.
        :param Sequence['DataAutomationProjectVideoStandardGenerativeFieldType'] types: The types of description to generate.
        """
        pulumi.set(__self__, "state", state)
        if types is not None:
            pulumi.set(__self__, "types", types)

    @_builtins.property
    @pulumi.getter
    def state(self) -> 'DataAutomationProjectState':
        """
        Whether generating descriptions is enabled for video.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def types(self) -> Optional[Sequence['DataAutomationProjectVideoStandardGenerativeFieldType']]:
        """
        The types of description to generate.
        """
        return pulumi.get(self, "types")


@pulumi.output_type
class DataAutomationProjectVideoStandardOutputConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "generativeField":
            suggest = "generative_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataAutomationProjectVideoStandardOutputConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataAutomationProjectVideoStandardOutputConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataAutomationProjectVideoStandardOutputConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 extraction: Optional['outputs.DataAutomationProjectVideoStandardExtraction'] = None,
                 generative_field: Optional['outputs.DataAutomationProjectVideoStandardGenerativeField'] = None):
        """
        :param 'DataAutomationProjectVideoStandardExtraction' extraction: Settings for populating data fields that describe the video.
        :param 'DataAutomationProjectVideoStandardGenerativeField' generative_field: Whether to generate descriptions of the video.
        """
        if extraction is not None:
            pulumi.set(__self__, "extraction", extraction)
        if generative_field is not None:
            pulumi.set(__self__, "generative_field", generative_field)

    @_builtins.property
    @pulumi.getter
    def extraction(self) -> Optional['outputs.DataAutomationProjectVideoStandardExtraction']:
        """
        Settings for populating data fields that describe the video.
        """
        return pulumi.get(self, "extraction")

    @_builtins.property
    @pulumi.getter(name="generativeField")
    def generative_field(self) -> Optional['outputs.DataAutomationProjectVideoStandardGenerativeField']:
        """
        Whether to generate descriptions of the video.
        """
        return pulumi.get(self, "generative_field")


@pulumi.output_type
class DataSourceBedrockDataAutomationConfiguration(dict):
    """
    Settings for a Bedrock Data Automation used to parse documents for a data source.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parsingModality":
            suggest = "parsing_modality"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceBedrockDataAutomationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceBedrockDataAutomationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceBedrockDataAutomationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parsing_modality: Optional['DataSourceParsingModality'] = None):
        """
        Settings for a Bedrock Data Automation used to parse documents for a data source.
        :param 'DataSourceParsingModality' parsing_modality: Specifies whether to enable parsing of multimodal data, including both text and/or images.
        """
        if parsing_modality is not None:
            pulumi.set(__self__, "parsing_modality", parsing_modality)

    @_builtins.property
    @pulumi.getter(name="parsingModality")
    def parsing_modality(self) -> Optional['DataSourceParsingModality']:
        """
        Specifies whether to enable parsing of multimodal data, including both text and/or images.
        """
        return pulumi.get(self, "parsing_modality")


@pulumi.output_type
class DataSourceBedrockFoundationModelConfiguration(dict):
    """
    Settings for a foundation model used to parse documents for a data source.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "modelArn":
            suggest = "model_arn"
        elif key == "parsingModality":
            suggest = "parsing_modality"
        elif key == "parsingPrompt":
            suggest = "parsing_prompt"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceBedrockFoundationModelConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceBedrockFoundationModelConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceBedrockFoundationModelConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 model_arn: _builtins.str,
                 parsing_modality: Optional['DataSourceParsingModality'] = None,
                 parsing_prompt: Optional['outputs.DataSourceParsingPrompt'] = None):
        """
        Settings for a foundation model used to parse documents for a data source.
        :param _builtins.str model_arn: The ARN of the foundation model to use for parsing.
        :param 'DataSourceParsingModality' parsing_modality: Specifies whether to enable parsing of multimodal data, including both text and/or images.
        :param 'DataSourceParsingPrompt' parsing_prompt: Instructions for interpreting the contents of a document.
        """
        pulumi.set(__self__, "model_arn", model_arn)
        if parsing_modality is not None:
            pulumi.set(__self__, "parsing_modality", parsing_modality)
        if parsing_prompt is not None:
            pulumi.set(__self__, "parsing_prompt", parsing_prompt)

    @_builtins.property
    @pulumi.getter(name="modelArn")
    def model_arn(self) -> _builtins.str:
        """
        The ARN of the foundation model to use for parsing.
        """
        return pulumi.get(self, "model_arn")

    @_builtins.property
    @pulumi.getter(name="parsingModality")
    def parsing_modality(self) -> Optional['DataSourceParsingModality']:
        """
        Specifies whether to enable parsing of multimodal data, including both text and/or images.
        """
        return pulumi.get(self, "parsing_modality")

    @_builtins.property
    @pulumi.getter(name="parsingPrompt")
    def parsing_prompt(self) -> Optional['outputs.DataSourceParsingPrompt']:
        """
        Instructions for interpreting the contents of a document.
        """
        return pulumi.get(self, "parsing_prompt")


@pulumi.output_type
class DataSourceBedrockFoundationModelContextEnrichmentConfiguration(dict):
    """
    Bedrock Foundation Model configuration to be used for Context Enrichment.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enrichmentStrategyConfiguration":
            suggest = "enrichment_strategy_configuration"
        elif key == "modelArn":
            suggest = "model_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceBedrockFoundationModelContextEnrichmentConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceBedrockFoundationModelContextEnrichmentConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceBedrockFoundationModelContextEnrichmentConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enrichment_strategy_configuration: 'outputs.DataSourceEnrichmentStrategyConfiguration',
                 model_arn: _builtins.str):
        """
        Bedrock Foundation Model configuration to be used for Context Enrichment.
        :param 'DataSourceEnrichmentStrategyConfiguration' enrichment_strategy_configuration: The enrichment stategy used to provide additional context. For example, Neptune GraphRAG uses Amazon Bedrock foundation models to perform chunk entity extraction.
        :param _builtins.str model_arn: The Amazon Resource Name (ARN) of the model used to create vector embeddings for the knowledge base.
        """
        pulumi.set(__self__, "enrichment_strategy_configuration", enrichment_strategy_configuration)
        pulumi.set(__self__, "model_arn", model_arn)

    @_builtins.property
    @pulumi.getter(name="enrichmentStrategyConfiguration")
    def enrichment_strategy_configuration(self) -> 'outputs.DataSourceEnrichmentStrategyConfiguration':
        """
        The enrichment stategy used to provide additional context. For example, Neptune GraphRAG uses Amazon Bedrock foundation models to perform chunk entity extraction.
        """
        return pulumi.get(self, "enrichment_strategy_configuration")

    @_builtins.property
    @pulumi.getter(name="modelArn")
    def model_arn(self) -> _builtins.str:
        """
        The Amazon Resource Name (ARN) of the model used to create vector embeddings for the knowledge base.
        """
        return pulumi.get(self, "model_arn")


@pulumi.output_type
class DataSourceChunkingConfiguration(dict):
    """
    Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chunkingStrategy":
            suggest = "chunking_strategy"
        elif key == "fixedSizeChunkingConfiguration":
            suggest = "fixed_size_chunking_configuration"
        elif key == "hierarchicalChunkingConfiguration":
            suggest = "hierarchical_chunking_configuration"
        elif key == "semanticChunkingConfiguration":
            suggest = "semantic_chunking_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceChunkingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceChunkingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceChunkingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 chunking_strategy: 'DataSourceChunkingStrategy',
                 fixed_size_chunking_configuration: Optional['outputs.DataSourceFixedSizeChunkingConfiguration'] = None,
                 hierarchical_chunking_configuration: Optional['outputs.DataSourceHierarchicalChunkingConfiguration'] = None,
                 semantic_chunking_configuration: Optional['outputs.DataSourceSemanticChunkingConfiguration'] = None):
        """
        Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried.
        :param 'DataSourceChunkingStrategy' chunking_strategy: Knowledge base can split your source data into chunks. A *chunk* refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried. You have the following options for chunking your data. If you opt for `NONE` , then you may want to pre-process your files by splitting them up such that each file corresponds to a chunk.
               
               - `FIXED_SIZE`  Amazon Bedrock splits your source data into chunks of the approximate size that you set in the `fixedSizeChunkingConfiguration` .
               - `HIERARCHICAL`  Split documents into layers of chunks where the first layer contains large chunks, and the second layer contains smaller chunks derived from the first layer.
               - `SEMANTIC`  Split documents into chunks based on groups of similar content derived with natural language processing.
               - `NONE`  Amazon Bedrock treats each file as one chunk. If you choose this option, you may want to pre-process your documents by splitting them into separate files.
        :param 'DataSourceFixedSizeChunkingConfiguration' fixed_size_chunking_configuration: Configurations for when you choose fixed-size chunking. If you set the `chunkingStrategy` as `NONE` , exclude this field.
        :param 'DataSourceHierarchicalChunkingConfiguration' hierarchical_chunking_configuration: Settings for hierarchical document chunking for a data source. Hierarchical chunking splits documents into layers of chunks where the first layer contains large chunks, and the second layer contains smaller chunks derived from the first layer.
        :param 'DataSourceSemanticChunkingConfiguration' semantic_chunking_configuration: Settings for semantic document chunking for a data source. Semantic chunking splits a document into into smaller documents based on groups of similar content derived from the text with natural language processing.
        """
        pulumi.set(__self__, "chunking_strategy", chunking_strategy)
        if fixed_size_chunking_configuration is not None:
            pulumi.set(__self__, "fixed_size_chunking_configuration", fixed_size_chunking_configuration)
        if hierarchical_chunking_configuration is not None:
            pulumi.set(__self__, "hierarchical_chunking_configuration", hierarchical_chunking_configuration)
        if semantic_chunking_configuration is not None:
            pulumi.set(__self__, "semantic_chunking_configuration", semantic_chunking_configuration)

    @_builtins.property
    @pulumi.getter(name="chunkingStrategy")
    def chunking_strategy(self) -> 'DataSourceChunkingStrategy':
        """
        Knowledge base can split your source data into chunks. A *chunk* refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried. You have the following options for chunking your data. If you opt for `NONE` , then you may want to pre-process your files by splitting them up such that each file corresponds to a chunk.

        - `FIXED_SIZE`  Amazon Bedrock splits your source data into chunks of the approximate size that you set in the `fixedSizeChunkingConfiguration` .
        - `HIERARCHICAL`  Split documents into layers of chunks where the first layer contains large chunks, and the second layer contains smaller chunks derived from the first layer.
        - `SEMANTIC`  Split documents into chunks based on groups of similar content derived with natural language processing.
        - `NONE`  Amazon Bedrock treats each file as one chunk. If you choose this option, you may want to pre-process your documents by splitting them into separate files.
        """
        return pulumi.get(self, "chunking_strategy")

    @_builtins.property
    @pulumi.getter(name="fixedSizeChunkingConfiguration")
    def fixed_size_chunking_configuration(self) -> Optional['outputs.DataSourceFixedSizeChunkingConfiguration']:
        """
        Configurations for when you choose fixed-size chunking. If you set the `chunkingStrategy` as `NONE` , exclude this field.
        """
        return pulumi.get(self, "fixed_size_chunking_configuration")

    @_builtins.property
    @pulumi.getter(name="hierarchicalChunkingConfiguration")
    def hierarchical_chunking_configuration(self) -> Optional['outputs.DataSourceHierarchicalChunkingConfiguration']:
        """
        Settings for hierarchical document chunking for a data source. Hierarchical chunking splits documents into layers of chunks where the first layer contains large chunks, and the second layer contains smaller chunks derived from the first layer.
        """
        return pulumi.get(self, "hierarchical_chunking_configuration")

    @_builtins.property
    @pulumi.getter(name="semanticChunkingConfiguration")
    def semantic_chunking_configuration(self) -> Optional['outputs.DataSourceSemanticChunkingConfiguration']:
        """
        Settings for semantic document chunking for a data source. Semantic chunking splits a document into into smaller documents based on groups of similar content derived from the text with natural language processing.
        """
        return pulumi.get(self, "semantic_chunking_configuration")


@pulumi.output_type
class DataSourceConfiguration(dict):
    """
    Specifies a raw data source location to ingest.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "confluenceConfiguration":
            suggest = "confluence_configuration"
        elif key == "s3Configuration":
            suggest = "s3_configuration"
        elif key == "salesforceConfiguration":
            suggest = "salesforce_configuration"
        elif key == "sharePointConfiguration":
            suggest = "share_point_configuration"
        elif key == "webConfiguration":
            suggest = "web_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: 'DataSourceType',
                 confluence_configuration: Optional['outputs.DataSourceConfluenceDataSourceConfiguration'] = None,
                 s3_configuration: Optional['outputs.DataSourceS3DataSourceConfiguration'] = None,
                 salesforce_configuration: Optional['outputs.DataSourceSalesforceDataSourceConfiguration'] = None,
                 share_point_configuration: Optional['outputs.DataSourceSharePointDataSourceConfiguration'] = None,
                 web_configuration: Optional['outputs.DataSourceWebDataSourceConfiguration'] = None):
        """
        Specifies a raw data source location to ingest.
        :param 'DataSourceType' type: The type of data source.
        :param 'DataSourceConfluenceDataSourceConfiguration' confluence_configuration: The configuration information to connect to Confluence as your data source.
               
               > Confluence data source connector is in preview release and is subject to change.
        :param 'DataSourceS3DataSourceConfiguration' s3_configuration: The configuration information to connect to Amazon S3 as your data source.
        :param 'DataSourceSalesforceDataSourceConfiguration' salesforce_configuration: The configuration information to connect to Salesforce as your data source.
               
               > Salesforce data source connector is in preview release and is subject to change.
        :param 'DataSourceSharePointDataSourceConfiguration' share_point_configuration: The configuration information to connect to SharePoint as your data source.
               
               > SharePoint data source connector is in preview release and is subject to change.
        :param 'DataSourceWebDataSourceConfiguration' web_configuration: The configuration of web URLs to crawl for your data source. You should be authorized to crawl the URLs.
               
               > Crawling web URLs as your data source is in preview release and is subject to change.
        """
        pulumi.set(__self__, "type", type)
        if confluence_configuration is not None:
            pulumi.set(__self__, "confluence_configuration", confluence_configuration)
        if s3_configuration is not None:
            pulumi.set(__self__, "s3_configuration", s3_configuration)
        if salesforce_configuration is not None:
            pulumi.set(__self__, "salesforce_configuration", salesforce_configuration)
        if share_point_configuration is not None:
            pulumi.set(__self__, "share_point_configuration", share_point_configuration)
        if web_configuration is not None:
            pulumi.set(__self__, "web_configuration", web_configuration)

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'DataSourceType':
        """
        The type of data source.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="confluenceConfiguration")
    def confluence_configuration(self) -> Optional['outputs.DataSourceConfluenceDataSourceConfiguration']:
        """
        The configuration information to connect to Confluence as your data source.

        > Confluence data source connector is in preview release and is subject to change.
        """
        return pulumi.get(self, "confluence_configuration")

    @_builtins.property
    @pulumi.getter(name="s3Configuration")
    def s3_configuration(self) -> Optional['outputs.DataSourceS3DataSourceConfiguration']:
        """
        The configuration information to connect to Amazon S3 as your data source.
        """
        return pulumi.get(self, "s3_configuration")

    @_builtins.property
    @pulumi.getter(name="salesforceConfiguration")
    def salesforce_configuration(self) -> Optional['outputs.DataSourceSalesforceDataSourceConfiguration']:
        """
        The configuration information to connect to Salesforce as your data source.

        > Salesforce data source connector is in preview release and is subject to change.
        """
        return pulumi.get(self, "salesforce_configuration")

    @_builtins.property
    @pulumi.getter(name="sharePointConfiguration")
    def share_point_configuration(self) -> Optional['outputs.DataSourceSharePointDataSourceConfiguration']:
        """
        The configuration information to connect to SharePoint as your data source.

        > SharePoint data source connector is in preview release and is subject to change.
        """
        return pulumi.get(self, "share_point_configuration")

    @_builtins.property
    @pulumi.getter(name="webConfiguration")
    def web_configuration(self) -> Optional['outputs.DataSourceWebDataSourceConfiguration']:
        """
        The configuration of web URLs to crawl for your data source. You should be authorized to crawl the URLs.

        > Crawling web URLs as your data source is in preview release and is subject to change.
        """
        return pulumi.get(self, "web_configuration")


@pulumi.output_type
class DataSourceConfluenceCrawlerConfiguration(dict):
    """
    The configuration of the Confluence content. For example, configuring specific types of Confluence content.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterConfiguration":
            suggest = "filter_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceConfluenceCrawlerConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceConfluenceCrawlerConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceConfluenceCrawlerConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_configuration: Optional['outputs.DataSourceCrawlFilterConfiguration'] = None):
        """
        The configuration of the Confluence content. For example, configuring specific types of Confluence content.
        :param 'DataSourceCrawlFilterConfiguration' filter_configuration: The configuration of filtering the Confluence content. For example, configuring regular expression patterns to include or exclude certain content.
        """
        if filter_configuration is not None:
            pulumi.set(__self__, "filter_configuration", filter_configuration)

    @_builtins.property
    @pulumi.getter(name="filterConfiguration")
    def filter_configuration(self) -> Optional['outputs.DataSourceCrawlFilterConfiguration']:
        """
        The configuration of filtering the Confluence content. For example, configuring regular expression patterns to include or exclude certain content.
        """
        return pulumi.get(self, "filter_configuration")


@pulumi.output_type
class DataSourceConfluenceDataSourceConfiguration(dict):
    """
    The configuration information to connect to Confluence as your data source.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceConfiguration":
            suggest = "source_configuration"
        elif key == "crawlerConfiguration":
            suggest = "crawler_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceConfluenceDataSourceConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceConfluenceDataSourceConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceConfluenceDataSourceConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_configuration: 'outputs.DataSourceConfluenceSourceConfiguration',
                 crawler_configuration: Optional['outputs.DataSourceConfluenceCrawlerConfiguration'] = None):
        """
        The configuration information to connect to Confluence as your data source.
        :param 'DataSourceConfluenceSourceConfiguration' source_configuration: The endpoint information to connect to your Confluence data source.
        :param 'DataSourceConfluenceCrawlerConfiguration' crawler_configuration: The configuration of the Confluence content. For example, configuring specific types of Confluence content.
        """
        pulumi.set(__self__, "source_configuration", source_configuration)
        if crawler_configuration is not None:
            pulumi.set(__self__, "crawler_configuration", crawler_configuration)

    @_builtins.property
    @pulumi.getter(name="sourceConfiguration")
    def source_configuration(self) -> 'outputs.DataSourceConfluenceSourceConfiguration':
        """
        The endpoint information to connect to your Confluence data source.
        """
        return pulumi.get(self, "source_configuration")

    @_builtins.property
    @pulumi.getter(name="crawlerConfiguration")
    def crawler_configuration(self) -> Optional['outputs.DataSourceConfluenceCrawlerConfiguration']:
        """
        The configuration of the Confluence content. For example, configuring specific types of Confluence content.
        """
        return pulumi.get(self, "crawler_configuration")


@pulumi.output_type
class DataSourceConfluenceSourceConfiguration(dict):
    """
    The endpoint information to connect to your Confluence data source.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authType":
            suggest = "auth_type"
        elif key == "credentialsSecretArn":
            suggest = "credentials_secret_arn"
        elif key == "hostType":
            suggest = "host_type"
        elif key == "hostUrl":
            suggest = "host_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceConfluenceSourceConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceConfluenceSourceConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceConfluenceSourceConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_type: 'DataSourceConfluenceSourceConfigurationAuthType',
                 credentials_secret_arn: _builtins.str,
                 host_type: 'DataSourceConfluenceSourceConfigurationHostType',
                 host_url: _builtins.str):
        """
        The endpoint information to connect to your Confluence data source.
        :param 'DataSourceConfluenceSourceConfigurationAuthType' auth_type: The supported authentication type to authenticate and connect to your Confluence instance.
        :param _builtins.str credentials_secret_arn: The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your Confluence instance URL. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see Confluence connection configuration.
        :param 'DataSourceConfluenceSourceConfigurationHostType' host_type: The supported host type, whether online/cloud or server/on-premises.
        :param _builtins.str host_url: The Confluence host URL or instance URL.
        """
        pulumi.set(__self__, "auth_type", auth_type)
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "host_type", host_type)
        pulumi.set(__self__, "host_url", host_url)

    @_builtins.property
    @pulumi.getter(name="authType")
    def auth_type(self) -> 'DataSourceConfluenceSourceConfigurationAuthType':
        """
        The supported authentication type to authenticate and connect to your Confluence instance.
        """
        return pulumi.get(self, "auth_type")

    @_builtins.property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> _builtins.str:
        """
        The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your Confluence instance URL. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see Confluence connection configuration.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @_builtins.property
    @pulumi.getter(name="hostType")
    def host_type(self) -> 'DataSourceConfluenceSourceConfigurationHostType':
        """
        The supported host type, whether online/cloud or server/on-premises.
        """
        return pulumi.get(self, "host_type")

    @_builtins.property
    @pulumi.getter(name="hostUrl")
    def host_url(self) -> _builtins.str:
        """
        The Confluence host URL or instance URL.
        """
        return pulumi.get(self, "host_url")


@pulumi.output_type
class DataSourceContextEnrichmentConfiguration(dict):
    """
    Additional Enrichment Configuration for example when using GraphRag.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bedrockFoundationModelConfiguration":
            suggest = "bedrock_foundation_model_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceContextEnrichmentConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceContextEnrichmentConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceContextEnrichmentConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: 'DataSourceContextEnrichmentType',
                 bedrock_foundation_model_configuration: Optional['outputs.DataSourceBedrockFoundationModelContextEnrichmentConfiguration'] = None):
        """
        Additional Enrichment Configuration for example when using GraphRag.
        :param 'DataSourceContextEnrichmentType' type: The method used for context enrichment. It must be Amazon Bedrock foundation models.
        :param 'DataSourceBedrockFoundationModelContextEnrichmentConfiguration' bedrock_foundation_model_configuration: The configuration of the Amazon Bedrock foundation model used for context enrichment.
        """
        pulumi.set(__self__, "type", type)
        if bedrock_foundation_model_configuration is not None:
            pulumi.set(__self__, "bedrock_foundation_model_configuration", bedrock_foundation_model_configuration)

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'DataSourceContextEnrichmentType':
        """
        The method used for context enrichment. It must be Amazon Bedrock foundation models.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="bedrockFoundationModelConfiguration")
    def bedrock_foundation_model_configuration(self) -> Optional['outputs.DataSourceBedrockFoundationModelContextEnrichmentConfiguration']:
        """
        The configuration of the Amazon Bedrock foundation model used for context enrichment.
        """
        return pulumi.get(self, "bedrock_foundation_model_configuration")


@pulumi.output_type
class DataSourceCrawlFilterConfiguration(dict):
    """
    The type of filtering that you want to apply to certain objects or content of the data source. For example, the PATTERN type is regular expression patterns you can apply to filter your content.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "patternObjectFilter":
            suggest = "pattern_object_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceCrawlFilterConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceCrawlFilterConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceCrawlFilterConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: 'DataSourceCrawlFilterConfigurationType',
                 pattern_object_filter: Optional['outputs.DataSourcePatternObjectFilterConfiguration'] = None):
        """
        The type of filtering that you want to apply to certain objects or content of the data source. For example, the PATTERN type is regular expression patterns you can apply to filter your content.
        :param 'DataSourceCrawlFilterConfigurationType' type: The crawl filter type.
        :param 'DataSourcePatternObjectFilterConfiguration' pattern_object_filter: The configuration of filtering certain objects or content types of the data source.
        """
        pulumi.set(__self__, "type", type)
        if pattern_object_filter is not None:
            pulumi.set(__self__, "pattern_object_filter", pattern_object_filter)

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'DataSourceCrawlFilterConfigurationType':
        """
        The crawl filter type.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="patternObjectFilter")
    def pattern_object_filter(self) -> Optional['outputs.DataSourcePatternObjectFilterConfiguration']:
        """
        The configuration of filtering certain objects or content types of the data source.
        """
        return pulumi.get(self, "pattern_object_filter")


@pulumi.output_type
class DataSourceCustomTransformationConfiguration(dict):
    """
    Settings for customizing steps in the data source content ingestion pipeline.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "intermediateStorage":
            suggest = "intermediate_storage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceCustomTransformationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceCustomTransformationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceCustomTransformationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 intermediate_storage: 'outputs.DataSourceIntermediateStorage',
                 transformations: Sequence['outputs.DataSourceTransformation']):
        """
        Settings for customizing steps in the data source content ingestion pipeline.
        :param 'DataSourceIntermediateStorage' intermediate_storage: An S3 bucket path for input and output objects.
        :param Sequence['DataSourceTransformation'] transformations: A list of Lambda functions that process documents.
        """
        pulumi.set(__self__, "intermediate_storage", intermediate_storage)
        pulumi.set(__self__, "transformations", transformations)

    @_builtins.property
    @pulumi.getter(name="intermediateStorage")
    def intermediate_storage(self) -> 'outputs.DataSourceIntermediateStorage':
        """
        An S3 bucket path for input and output objects.
        """
        return pulumi.get(self, "intermediate_storage")

    @_builtins.property
    @pulumi.getter
    def transformations(self) -> Sequence['outputs.DataSourceTransformation']:
        """
        A list of Lambda functions that process documents.
        """
        return pulumi.get(self, "transformations")


@pulumi.output_type
class DataSourceEnrichmentStrategyConfiguration(dict):
    """
    Strategy to be used when using Bedrock Foundation Model for Context Enrichment.
    """
    def __init__(__self__, *,
                 method: 'DataSourceEnrichmentStrategyMethod'):
        """
        Strategy to be used when using Bedrock Foundation Model for Context Enrichment.
        :param 'DataSourceEnrichmentStrategyMethod' method: The method used for the context enrichment strategy.
        """
        pulumi.set(__self__, "method", method)

    @_builtins.property
    @pulumi.getter
    def method(self) -> 'DataSourceEnrichmentStrategyMethod':
        """
        The method used for the context enrichment strategy.
        """
        return pulumi.get(self, "method")


@pulumi.output_type
class DataSourceFixedSizeChunkingConfiguration(dict):
    """
    Configurations for when you choose fixed-size chunking. If you set the chunkingStrategy as NONE, exclude this field.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxTokens":
            suggest = "max_tokens"
        elif key == "overlapPercentage":
            suggest = "overlap_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceFixedSizeChunkingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceFixedSizeChunkingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceFixedSizeChunkingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_tokens: _builtins.int,
                 overlap_percentage: _builtins.int):
        """
        Configurations for when you choose fixed-size chunking. If you set the chunkingStrategy as NONE, exclude this field.
        :param _builtins.int max_tokens: The maximum number of tokens to include in a chunk.
        :param _builtins.int overlap_percentage: The percentage of overlap between adjacent chunks of a data source.
        """
        pulumi.set(__self__, "max_tokens", max_tokens)
        pulumi.set(__self__, "overlap_percentage", overlap_percentage)

    @_builtins.property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> _builtins.int:
        """
        The maximum number of tokens to include in a chunk.
        """
        return pulumi.get(self, "max_tokens")

    @_builtins.property
    @pulumi.getter(name="overlapPercentage")
    def overlap_percentage(self) -> _builtins.int:
        """
        The percentage of overlap between adjacent chunks of a data source.
        """
        return pulumi.get(self, "overlap_percentage")


@pulumi.output_type
class DataSourceHierarchicalChunkingConfiguration(dict):
    """
    Configurations for when you choose hierarchical chunking. If you set the chunkingStrategy as NONE, exclude this field.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "levelConfigurations":
            suggest = "level_configurations"
        elif key == "overlapTokens":
            suggest = "overlap_tokens"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceHierarchicalChunkingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceHierarchicalChunkingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceHierarchicalChunkingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 level_configurations: Sequence['outputs.DataSourceHierarchicalChunkingLevelConfiguration'],
                 overlap_tokens: _builtins.int):
        """
        Configurations for when you choose hierarchical chunking. If you set the chunkingStrategy as NONE, exclude this field.
        :param Sequence['DataSourceHierarchicalChunkingLevelConfiguration'] level_configurations: Token settings for each layer.
        :param _builtins.int overlap_tokens: The number of tokens to repeat across chunks in the same layer.
        """
        pulumi.set(__self__, "level_configurations", level_configurations)
        pulumi.set(__self__, "overlap_tokens", overlap_tokens)

    @_builtins.property
    @pulumi.getter(name="levelConfigurations")
    def level_configurations(self) -> Sequence['outputs.DataSourceHierarchicalChunkingLevelConfiguration']:
        """
        Token settings for each layer.
        """
        return pulumi.get(self, "level_configurations")

    @_builtins.property
    @pulumi.getter(name="overlapTokens")
    def overlap_tokens(self) -> _builtins.int:
        """
        The number of tokens to repeat across chunks in the same layer.
        """
        return pulumi.get(self, "overlap_tokens")


@pulumi.output_type
class DataSourceHierarchicalChunkingLevelConfiguration(dict):
    """
    Token settings for a layer in a hierarchical chunking configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxTokens":
            suggest = "max_tokens"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceHierarchicalChunkingLevelConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceHierarchicalChunkingLevelConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceHierarchicalChunkingLevelConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_tokens: _builtins.int):
        """
        Token settings for a layer in a hierarchical chunking configuration.
        :param _builtins.int max_tokens: The maximum number of tokens that a chunk can contain in this layer.
        """
        pulumi.set(__self__, "max_tokens", max_tokens)

    @_builtins.property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> _builtins.int:
        """
        The maximum number of tokens that a chunk can contain in this layer.
        """
        return pulumi.get(self, "max_tokens")


@pulumi.output_type
class DataSourceIntermediateStorage(dict):
    """
    A location for storing content from data sources temporarily as it is processed by custom components in the ingestion pipeline.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "s3Location":
            suggest = "s3_location"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceIntermediateStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceIntermediateStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceIntermediateStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 s3_location: 'outputs.DataSourceS3Location'):
        """
        A location for storing content from data sources temporarily as it is processed by custom components in the ingestion pipeline.
        :param 'DataSourceS3Location' s3_location: An S3 bucket path.
        """
        pulumi.set(__self__, "s3_location", s3_location)

    @_builtins.property
    @pulumi.getter(name="s3Location")
    def s3_location(self) -> 'outputs.DataSourceS3Location':
        """
        An S3 bucket path.
        """
        return pulumi.get(self, "s3_location")


@pulumi.output_type
class DataSourceParsingConfiguration(dict):
    """
    Settings for parsing document contents
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parsingStrategy":
            suggest = "parsing_strategy"
        elif key == "bedrockDataAutomationConfiguration":
            suggest = "bedrock_data_automation_configuration"
        elif key == "bedrockFoundationModelConfiguration":
            suggest = "bedrock_foundation_model_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceParsingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceParsingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceParsingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parsing_strategy: 'DataSourceParsingStrategy',
                 bedrock_data_automation_configuration: Optional['outputs.DataSourceBedrockDataAutomationConfiguration'] = None,
                 bedrock_foundation_model_configuration: Optional['outputs.DataSourceBedrockFoundationModelConfiguration'] = None):
        """
        Settings for parsing document contents
        :param 'DataSourceParsingStrategy' parsing_strategy: The parsing strategy for the data source.
        :param 'DataSourceBedrockDataAutomationConfiguration' bedrock_data_automation_configuration: If you specify `BEDROCK_DATA_AUTOMATION` as the parsing strategy for ingesting your data source, use this object to modify configurations for using the Amazon Bedrock Data Automation parser.
        :param 'DataSourceBedrockFoundationModelConfiguration' bedrock_foundation_model_configuration: If you specify `BEDROCK_FOUNDATION_MODEL` as the parsing strategy for ingesting your data source, use this object to modify configurations for using a foundation model to parse documents.
        """
        pulumi.set(__self__, "parsing_strategy", parsing_strategy)
        if bedrock_data_automation_configuration is not None:
            pulumi.set(__self__, "bedrock_data_automation_configuration", bedrock_data_automation_configuration)
        if bedrock_foundation_model_configuration is not None:
            pulumi.set(__self__, "bedrock_foundation_model_configuration", bedrock_foundation_model_configuration)

    @_builtins.property
    @pulumi.getter(name="parsingStrategy")
    def parsing_strategy(self) -> 'DataSourceParsingStrategy':
        """
        The parsing strategy for the data source.
        """
        return pulumi.get(self, "parsing_strategy")

    @_builtins.property
    @pulumi.getter(name="bedrockDataAutomationConfiguration")
    def bedrock_data_automation_configuration(self) -> Optional['outputs.DataSourceBedrockDataAutomationConfiguration']:
        """
        If you specify `BEDROCK_DATA_AUTOMATION` as the parsing strategy for ingesting your data source, use this object to modify configurations for using the Amazon Bedrock Data Automation parser.
        """
        return pulumi.get(self, "bedrock_data_automation_configuration")

    @_builtins.property
    @pulumi.getter(name="bedrockFoundationModelConfiguration")
    def bedrock_foundation_model_configuration(self) -> Optional['outputs.DataSourceBedrockFoundationModelConfiguration']:
        """
        If you specify `BEDROCK_FOUNDATION_MODEL` as the parsing strategy for ingesting your data source, use this object to modify configurations for using a foundation model to parse documents.
        """
        return pulumi.get(self, "bedrock_foundation_model_configuration")


@pulumi.output_type
class DataSourceParsingPrompt(dict):
    """
    Instructions for interpreting the contents of a document.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parsingPromptText":
            suggest = "parsing_prompt_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceParsingPrompt. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceParsingPrompt.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceParsingPrompt.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 parsing_prompt_text: _builtins.str):
        """
        Instructions for interpreting the contents of a document.
        :param _builtins.str parsing_prompt_text: Instructions for interpreting the contents of a document.
        """
        pulumi.set(__self__, "parsing_prompt_text", parsing_prompt_text)

    @_builtins.property
    @pulumi.getter(name="parsingPromptText")
    def parsing_prompt_text(self) -> _builtins.str:
        """
        Instructions for interpreting the contents of a document.
        """
        return pulumi.get(self, "parsing_prompt_text")


@pulumi.output_type
class DataSourcePatternObjectFilter(dict):
    """
    The specific filters applied to your data source content. You can filter out or include certain content.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "objectType":
            suggest = "object_type"
        elif key == "exclusionFilters":
            suggest = "exclusion_filters"
        elif key == "inclusionFilters":
            suggest = "inclusion_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourcePatternObjectFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourcePatternObjectFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourcePatternObjectFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 object_type: _builtins.str,
                 exclusion_filters: Optional[Sequence[_builtins.str]] = None,
                 inclusion_filters: Optional[Sequence[_builtins.str]] = None):
        """
        The specific filters applied to your data source content. You can filter out or include certain content.
        :param _builtins.str object_type: The supported object type or content type of the data source.
        """
        pulumi.set(__self__, "object_type", object_type)
        if exclusion_filters is not None:
            pulumi.set(__self__, "exclusion_filters", exclusion_filters)
        if inclusion_filters is not None:
            pulumi.set(__self__, "inclusion_filters", inclusion_filters)

    @_builtins.property
    @pulumi.getter(name="objectType")
    def object_type(self) -> _builtins.str:
        """
        The supported object type or content type of the data source.
        """
        return pulumi.get(self, "object_type")

    @_builtins.property
    @pulumi.getter(name="exclusionFilters")
    def exclusion_filters(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "exclusion_filters")

    @_builtins.property
    @pulumi.getter(name="inclusionFilters")
    def inclusion_filters(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "inclusion_filters")


@pulumi.output_type
class DataSourcePatternObjectFilterConfiguration(dict):
    """
    The configuration of specific filters applied to your data source content. You can filter out or include certain content.
    """
    def __init__(__self__, *,
                 filters: Sequence['outputs.DataSourcePatternObjectFilter']):
        """
        The configuration of specific filters applied to your data source content. You can filter out or include certain content.
        :param Sequence['DataSourcePatternObjectFilter'] filters: The configuration of specific filters applied to your data source content. You can filter out or include certain content.
        """
        pulumi.set(__self__, "filters", filters)

    @_builtins.property
    @pulumi.getter
    def filters(self) -> Sequence['outputs.DataSourcePatternObjectFilter']:
        """
        The configuration of specific filters applied to your data source content. You can filter out or include certain content.
        """
        return pulumi.get(self, "filters")


@pulumi.output_type
class DataSourceS3DataSourceConfiguration(dict):
    """
    The configuration information to connect to Amazon S3 as your data source.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketArn":
            suggest = "bucket_arn"
        elif key == "bucketOwnerAccountId":
            suggest = "bucket_owner_account_id"
        elif key == "inclusionPrefixes":
            suggest = "inclusion_prefixes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceS3DataSourceConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceS3DataSourceConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceS3DataSourceConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_arn: _builtins.str,
                 bucket_owner_account_id: Optional[_builtins.str] = None,
                 inclusion_prefixes: Optional[Sequence[_builtins.str]] = None):
        """
        The configuration information to connect to Amazon S3 as your data source.
        :param _builtins.str bucket_arn: The ARN of the bucket that contains the data source.
        :param _builtins.str bucket_owner_account_id: The account ID for the owner of the S3 bucket.
        :param Sequence[_builtins.str] inclusion_prefixes: A list of S3 prefixes that define the object containing the data sources.
        """
        pulumi.set(__self__, "bucket_arn", bucket_arn)
        if bucket_owner_account_id is not None:
            pulumi.set(__self__, "bucket_owner_account_id", bucket_owner_account_id)
        if inclusion_prefixes is not None:
            pulumi.set(__self__, "inclusion_prefixes", inclusion_prefixes)

    @_builtins.property
    @pulumi.getter(name="bucketArn")
    def bucket_arn(self) -> _builtins.str:
        """
        The ARN of the bucket that contains the data source.
        """
        return pulumi.get(self, "bucket_arn")

    @_builtins.property
    @pulumi.getter(name="bucketOwnerAccountId")
    def bucket_owner_account_id(self) -> Optional[_builtins.str]:
        """
        The account ID for the owner of the S3 bucket.
        """
        return pulumi.get(self, "bucket_owner_account_id")

    @_builtins.property
    @pulumi.getter(name="inclusionPrefixes")
    def inclusion_prefixes(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of S3 prefixes that define the object containing the data sources.
        """
        return pulumi.get(self, "inclusion_prefixes")


@pulumi.output_type
class DataSourceS3Location(dict):
    """
    An Amazon S3 location.
    """
    def __init__(__self__, *,
                 uri: _builtins.str):
        """
        An Amazon S3 location.
        :param _builtins.str uri: The location's URI
        """
        pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> _builtins.str:
        """
        The location's URI
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class DataSourceSalesforceCrawlerConfiguration(dict):
    """
    The configuration of filtering the Salesforce content. For example, configuring regular expression patterns to include or exclude certain content.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterConfiguration":
            suggest = "filter_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceSalesforceCrawlerConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceSalesforceCrawlerConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceSalesforceCrawlerConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_configuration: Optional['outputs.DataSourceCrawlFilterConfiguration'] = None):
        """
        The configuration of filtering the Salesforce content. For example, configuring regular expression patterns to include or exclude certain content.
        :param 'DataSourceCrawlFilterConfiguration' filter_configuration: The configuration of filtering the Salesforce content. For example, configuring regular expression patterns to include or exclude certain content.
        """
        if filter_configuration is not None:
            pulumi.set(__self__, "filter_configuration", filter_configuration)

    @_builtins.property
    @pulumi.getter(name="filterConfiguration")
    def filter_configuration(self) -> Optional['outputs.DataSourceCrawlFilterConfiguration']:
        """
        The configuration of filtering the Salesforce content. For example, configuring regular expression patterns to include or exclude certain content.
        """
        return pulumi.get(self, "filter_configuration")


@pulumi.output_type
class DataSourceSalesforceDataSourceConfiguration(dict):
    """
    The configuration information to connect to Salesforce as your data source.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceConfiguration":
            suggest = "source_configuration"
        elif key == "crawlerConfiguration":
            suggest = "crawler_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceSalesforceDataSourceConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceSalesforceDataSourceConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceSalesforceDataSourceConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_configuration: 'outputs.DataSourceSalesforceSourceConfiguration',
                 crawler_configuration: Optional['outputs.DataSourceSalesforceCrawlerConfiguration'] = None):
        """
        The configuration information to connect to Salesforce as your data source.
        :param 'DataSourceSalesforceSourceConfiguration' source_configuration: The endpoint information to connect to your Salesforce data source.
        :param 'DataSourceSalesforceCrawlerConfiguration' crawler_configuration: The configuration of the Salesforce content. For example, configuring specific types of Salesforce content.
        """
        pulumi.set(__self__, "source_configuration", source_configuration)
        if crawler_configuration is not None:
            pulumi.set(__self__, "crawler_configuration", crawler_configuration)

    @_builtins.property
    @pulumi.getter(name="sourceConfiguration")
    def source_configuration(self) -> 'outputs.DataSourceSalesforceSourceConfiguration':
        """
        The endpoint information to connect to your Salesforce data source.
        """
        return pulumi.get(self, "source_configuration")

    @_builtins.property
    @pulumi.getter(name="crawlerConfiguration")
    def crawler_configuration(self) -> Optional['outputs.DataSourceSalesforceCrawlerConfiguration']:
        """
        The configuration of the Salesforce content. For example, configuring specific types of Salesforce content.
        """
        return pulumi.get(self, "crawler_configuration")


@pulumi.output_type
class DataSourceSalesforceSourceConfiguration(dict):
    """
    The endpoint information to connect to your Salesforce data source.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authType":
            suggest = "auth_type"
        elif key == "credentialsSecretArn":
            suggest = "credentials_secret_arn"
        elif key == "hostUrl":
            suggest = "host_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceSalesforceSourceConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceSalesforceSourceConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceSalesforceSourceConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_type: 'DataSourceSalesforceSourceConfigurationAuthType',
                 credentials_secret_arn: _builtins.str,
                 host_url: _builtins.str):
        """
        The endpoint information to connect to your Salesforce data source.
        :param 'DataSourceSalesforceSourceConfigurationAuthType' auth_type: The supported authentication type to authenticate and connect to your Salesforce instance.
        :param _builtins.str credentials_secret_arn: The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your Salesforce instance URL. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see Salesforce connection configuration.
        :param _builtins.str host_url: The Salesforce host URL or instance URL.
        """
        pulumi.set(__self__, "auth_type", auth_type)
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "host_url", host_url)

    @_builtins.property
    @pulumi.getter(name="authType")
    def auth_type(self) -> 'DataSourceSalesforceSourceConfigurationAuthType':
        """
        The supported authentication type to authenticate and connect to your Salesforce instance.
        """
        return pulumi.get(self, "auth_type")

    @_builtins.property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> _builtins.str:
        """
        The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your Salesforce instance URL. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see Salesforce connection configuration.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @_builtins.property
    @pulumi.getter(name="hostUrl")
    def host_url(self) -> _builtins.str:
        """
        The Salesforce host URL or instance URL.
        """
        return pulumi.get(self, "host_url")


@pulumi.output_type
class DataSourceSeedUrl(dict):
    """
    A seed url object.
    """
    def __init__(__self__, *,
                 url: _builtins.str):
        """
        A seed url object.
        :param _builtins.str url: A web url.
        """
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        A web url.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class DataSourceSemanticChunkingConfiguration(dict):
    """
    Configurations for when you choose semantic chunking. If you set the chunkingStrategy as NONE, exclude this field.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "breakpointPercentileThreshold":
            suggest = "breakpoint_percentile_threshold"
        elif key == "bufferSize":
            suggest = "buffer_size"
        elif key == "maxTokens":
            suggest = "max_tokens"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceSemanticChunkingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceSemanticChunkingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceSemanticChunkingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 breakpoint_percentile_threshold: _builtins.int,
                 buffer_size: _builtins.int,
                 max_tokens: _builtins.int):
        """
        Configurations for when you choose semantic chunking. If you set the chunkingStrategy as NONE, exclude this field.
        :param _builtins.int breakpoint_percentile_threshold: The dissimilarity threshold for splitting chunks.
        :param _builtins.int buffer_size: The buffer size.
        :param _builtins.int max_tokens: The maximum number of tokens that a chunk can contain.
        """
        pulumi.set(__self__, "breakpoint_percentile_threshold", breakpoint_percentile_threshold)
        pulumi.set(__self__, "buffer_size", buffer_size)
        pulumi.set(__self__, "max_tokens", max_tokens)

    @_builtins.property
    @pulumi.getter(name="breakpointPercentileThreshold")
    def breakpoint_percentile_threshold(self) -> _builtins.int:
        """
        The dissimilarity threshold for splitting chunks.
        """
        return pulumi.get(self, "breakpoint_percentile_threshold")

    @_builtins.property
    @pulumi.getter(name="bufferSize")
    def buffer_size(self) -> _builtins.int:
        """
        The buffer size.
        """
        return pulumi.get(self, "buffer_size")

    @_builtins.property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> _builtins.int:
        """
        The maximum number of tokens that a chunk can contain.
        """
        return pulumi.get(self, "max_tokens")


@pulumi.output_type
class DataSourceServerSideEncryptionConfiguration(dict):
    """
    Contains details about the server-side encryption for the data source.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKeyArn":
            suggest = "kms_key_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceServerSideEncryptionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceServerSideEncryptionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceServerSideEncryptionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key_arn: Optional[_builtins.str] = None):
        """
        Contains details about the server-side encryption for the data source.
        :param _builtins.str kms_key_arn: The ARN of the AWS KMS key used to encrypt the resource.
        """
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[_builtins.str]:
        """
        The ARN of the AWS KMS key used to encrypt the resource.
        """
        return pulumi.get(self, "kms_key_arn")


@pulumi.output_type
class DataSourceSharePointCrawlerConfiguration(dict):
    """
    The configuration of the SharePoint content. For example, configuring specific types of SharePoint content.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterConfiguration":
            suggest = "filter_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceSharePointCrawlerConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceSharePointCrawlerConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceSharePointCrawlerConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_configuration: Optional['outputs.DataSourceCrawlFilterConfiguration'] = None):
        """
        The configuration of the SharePoint content. For example, configuring specific types of SharePoint content.
        :param 'DataSourceCrawlFilterConfiguration' filter_configuration: The configuration of filtering the SharePoint content. For example, configuring regular expression patterns to include or exclude certain content.
        """
        if filter_configuration is not None:
            pulumi.set(__self__, "filter_configuration", filter_configuration)

    @_builtins.property
    @pulumi.getter(name="filterConfiguration")
    def filter_configuration(self) -> Optional['outputs.DataSourceCrawlFilterConfiguration']:
        """
        The configuration of filtering the SharePoint content. For example, configuring regular expression patterns to include or exclude certain content.
        """
        return pulumi.get(self, "filter_configuration")


@pulumi.output_type
class DataSourceSharePointDataSourceConfiguration(dict):
    """
    The configuration information to connect to SharePoint as your data source.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceConfiguration":
            suggest = "source_configuration"
        elif key == "crawlerConfiguration":
            suggest = "crawler_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceSharePointDataSourceConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceSharePointDataSourceConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceSharePointDataSourceConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_configuration: 'outputs.DataSourceSharePointSourceConfiguration',
                 crawler_configuration: Optional['outputs.DataSourceSharePointCrawlerConfiguration'] = None):
        """
        The configuration information to connect to SharePoint as your data source.
        :param 'DataSourceSharePointSourceConfiguration' source_configuration: The endpoint information to connect to your SharePoint data source.
        :param 'DataSourceSharePointCrawlerConfiguration' crawler_configuration: The configuration of the SharePoint content. For example, configuring specific types of SharePoint content.
        """
        pulumi.set(__self__, "source_configuration", source_configuration)
        if crawler_configuration is not None:
            pulumi.set(__self__, "crawler_configuration", crawler_configuration)

    @_builtins.property
    @pulumi.getter(name="sourceConfiguration")
    def source_configuration(self) -> 'outputs.DataSourceSharePointSourceConfiguration':
        """
        The endpoint information to connect to your SharePoint data source.
        """
        return pulumi.get(self, "source_configuration")

    @_builtins.property
    @pulumi.getter(name="crawlerConfiguration")
    def crawler_configuration(self) -> Optional['outputs.DataSourceSharePointCrawlerConfiguration']:
        """
        The configuration of the SharePoint content. For example, configuring specific types of SharePoint content.
        """
        return pulumi.get(self, "crawler_configuration")


@pulumi.output_type
class DataSourceSharePointSourceConfiguration(dict):
    """
    The endpoint information to connect to your SharePoint data source.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authType":
            suggest = "auth_type"
        elif key == "credentialsSecretArn":
            suggest = "credentials_secret_arn"
        elif key == "hostType":
            suggest = "host_type"
        elif key == "siteUrls":
            suggest = "site_urls"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceSharePointSourceConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceSharePointSourceConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceSharePointSourceConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_type: 'DataSourceSharePointSourceConfigurationAuthType',
                 credentials_secret_arn: _builtins.str,
                 domain: _builtins.str,
                 host_type: 'DataSourceSharePointSourceConfigurationHostType',
                 site_urls: Sequence[_builtins.str],
                 tenant_id: Optional[_builtins.str] = None):
        """
        The endpoint information to connect to your SharePoint data source.
        :param 'DataSourceSharePointSourceConfigurationAuthType' auth_type: The supported authentication type to authenticate and connect to your SharePoint site/sites.
        :param _builtins.str credentials_secret_arn: The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your SharePoint site/sites. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see SharePoint connection configuration.
        :param _builtins.str domain: The domain of your SharePoint instance or site URL/URLs.
        :param 'DataSourceSharePointSourceConfigurationHostType' host_type: The supported host type, whether online/cloud or server/on-premises.
        :param Sequence[_builtins.str] site_urls: A list of one or more SharePoint site URLs.
        :param _builtins.str tenant_id: The identifier of your Microsoft 365 tenant.
        """
        pulumi.set(__self__, "auth_type", auth_type)
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "host_type", host_type)
        pulumi.set(__self__, "site_urls", site_urls)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter(name="authType")
    def auth_type(self) -> 'DataSourceSharePointSourceConfigurationAuthType':
        """
        The supported authentication type to authenticate and connect to your SharePoint site/sites.
        """
        return pulumi.get(self, "auth_type")

    @_builtins.property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> _builtins.str:
        """
        The Amazon Resource Name of an AWS Secrets Manager secret that stores your authentication credentials for your SharePoint site/sites. For more information on the key-value pairs that must be included in your secret, depending on your authentication type, see SharePoint connection configuration.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @_builtins.property
    @pulumi.getter
    def domain(self) -> _builtins.str:
        """
        The domain of your SharePoint instance or site URL/URLs.
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter(name="hostType")
    def host_type(self) -> 'DataSourceSharePointSourceConfigurationHostType':
        """
        The supported host type, whether online/cloud or server/on-premises.
        """
        return pulumi.get(self, "host_type")

    @_builtins.property
    @pulumi.getter(name="siteUrls")
    def site_urls(self) -> Sequence[_builtins.str]:
        """
        A list of one or more SharePoint site URLs.
        """
        return pulumi.get(self, "site_urls")

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[_builtins.str]:
        """
        The identifier of your Microsoft 365 tenant.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class DataSourceTransformation(dict):
    """
    A Lambda function that processes documents.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "stepToApply":
            suggest = "step_to_apply"
        elif key == "transformationFunction":
            suggest = "transformation_function"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceTransformation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceTransformation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceTransformation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 step_to_apply: 'DataSourceTransformationStepToApply',
                 transformation_function: 'outputs.DataSourceTransformationFunction'):
        """
        A Lambda function that processes documents.
        :param 'DataSourceTransformationStepToApply' step_to_apply: When the service applies the transformation.
        :param 'DataSourceTransformationFunction' transformation_function: A Lambda function that processes documents.
        """
        pulumi.set(__self__, "step_to_apply", step_to_apply)
        pulumi.set(__self__, "transformation_function", transformation_function)

    @_builtins.property
    @pulumi.getter(name="stepToApply")
    def step_to_apply(self) -> 'DataSourceTransformationStepToApply':
        """
        When the service applies the transformation.
        """
        return pulumi.get(self, "step_to_apply")

    @_builtins.property
    @pulumi.getter(name="transformationFunction")
    def transformation_function(self) -> 'outputs.DataSourceTransformationFunction':
        """
        A Lambda function that processes documents.
        """
        return pulumi.get(self, "transformation_function")


@pulumi.output_type
class DataSourceTransformationFunction(dict):
    """
    A Lambda function that processes documents.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "transformationLambdaConfiguration":
            suggest = "transformation_lambda_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceTransformationFunction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceTransformationFunction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceTransformationFunction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 transformation_lambda_configuration: 'outputs.DataSourceTransformationLambdaConfiguration'):
        """
        A Lambda function that processes documents.
        :param 'DataSourceTransformationLambdaConfiguration' transformation_lambda_configuration: The Lambda function.
        """
        pulumi.set(__self__, "transformation_lambda_configuration", transformation_lambda_configuration)

    @_builtins.property
    @pulumi.getter(name="transformationLambdaConfiguration")
    def transformation_lambda_configuration(self) -> 'outputs.DataSourceTransformationLambdaConfiguration':
        """
        The Lambda function.
        """
        return pulumi.get(self, "transformation_lambda_configuration")


@pulumi.output_type
class DataSourceTransformationLambdaConfiguration(dict):
    """
    A Lambda function that processes documents.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lambdaArn":
            suggest = "lambda_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceTransformationLambdaConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceTransformationLambdaConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceTransformationLambdaConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lambda_arn: _builtins.str):
        """
        A Lambda function that processes documents.
        :param _builtins.str lambda_arn: The function's ARN identifier.
        """
        pulumi.set(__self__, "lambda_arn", lambda_arn)

    @_builtins.property
    @pulumi.getter(name="lambdaArn")
    def lambda_arn(self) -> _builtins.str:
        """
        The function's ARN identifier.
        """
        return pulumi.get(self, "lambda_arn")


@pulumi.output_type
class DataSourceUrlConfiguration(dict):
    """
    A url configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "seedUrls":
            suggest = "seed_urls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceUrlConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceUrlConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceUrlConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 seed_urls: Sequence['outputs.DataSourceSeedUrl']):
        """
        A url configuration.
        :param Sequence['DataSourceSeedUrl'] seed_urls: One or more seed or starting point URLs.
        """
        pulumi.set(__self__, "seed_urls", seed_urls)

    @_builtins.property
    @pulumi.getter(name="seedUrls")
    def seed_urls(self) -> Sequence['outputs.DataSourceSeedUrl']:
        """
        One or more seed or starting point URLs.
        """
        return pulumi.get(self, "seed_urls")


@pulumi.output_type
class DataSourceVectorIngestionConfiguration(dict):
    """
    Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chunkingConfiguration":
            suggest = "chunking_configuration"
        elif key == "contextEnrichmentConfiguration":
            suggest = "context_enrichment_configuration"
        elif key == "customTransformationConfiguration":
            suggest = "custom_transformation_configuration"
        elif key == "parsingConfiguration":
            suggest = "parsing_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceVectorIngestionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceVectorIngestionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceVectorIngestionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 chunking_configuration: Optional['outputs.DataSourceChunkingConfiguration'] = None,
                 context_enrichment_configuration: Optional['outputs.DataSourceContextEnrichmentConfiguration'] = None,
                 custom_transformation_configuration: Optional['outputs.DataSourceCustomTransformationConfiguration'] = None,
                 parsing_configuration: Optional['outputs.DataSourceParsingConfiguration'] = None):
        """
        Details about how to chunk the documents in the data source. A chunk refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried.
        :param 'DataSourceChunkingConfiguration' chunking_configuration: Details about how to chunk the documents in the data source. A *chunk* refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried.
        :param 'DataSourceContextEnrichmentConfiguration' context_enrichment_configuration: The context enrichment configuration used for ingestion of the data into the vector store.
        :param 'DataSourceCustomTransformationConfiguration' custom_transformation_configuration: A custom document transformer for parsed data source documents.
        :param 'DataSourceParsingConfiguration' parsing_configuration: Configurations for a parser to use for parsing documents in your data source. If you exclude this field, the default parser will be used.
        """
        if chunking_configuration is not None:
            pulumi.set(__self__, "chunking_configuration", chunking_configuration)
        if context_enrichment_configuration is not None:
            pulumi.set(__self__, "context_enrichment_configuration", context_enrichment_configuration)
        if custom_transformation_configuration is not None:
            pulumi.set(__self__, "custom_transformation_configuration", custom_transformation_configuration)
        if parsing_configuration is not None:
            pulumi.set(__self__, "parsing_configuration", parsing_configuration)

    @_builtins.property
    @pulumi.getter(name="chunkingConfiguration")
    def chunking_configuration(self) -> Optional['outputs.DataSourceChunkingConfiguration']:
        """
        Details about how to chunk the documents in the data source. A *chunk* refers to an excerpt from a data source that is returned when the knowledge base that it belongs to is queried.
        """
        return pulumi.get(self, "chunking_configuration")

    @_builtins.property
    @pulumi.getter(name="contextEnrichmentConfiguration")
    def context_enrichment_configuration(self) -> Optional['outputs.DataSourceContextEnrichmentConfiguration']:
        """
        The context enrichment configuration used for ingestion of the data into the vector store.
        """
        return pulumi.get(self, "context_enrichment_configuration")

    @_builtins.property
    @pulumi.getter(name="customTransformationConfiguration")
    def custom_transformation_configuration(self) -> Optional['outputs.DataSourceCustomTransformationConfiguration']:
        """
        A custom document transformer for parsed data source documents.
        """
        return pulumi.get(self, "custom_transformation_configuration")

    @_builtins.property
    @pulumi.getter(name="parsingConfiguration")
    def parsing_configuration(self) -> Optional['outputs.DataSourceParsingConfiguration']:
        """
        Configurations for a parser to use for parsing documents in your data source. If you exclude this field, the default parser will be used.
        """
        return pulumi.get(self, "parsing_configuration")


@pulumi.output_type
class DataSourceWebCrawlerConfiguration(dict):
    """
    Configuration for the web crawler.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crawlerLimits":
            suggest = "crawler_limits"
        elif key == "exclusionFilters":
            suggest = "exclusion_filters"
        elif key == "inclusionFilters":
            suggest = "inclusion_filters"
        elif key == "userAgent":
            suggest = "user_agent"
        elif key == "userAgentHeader":
            suggest = "user_agent_header"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceWebCrawlerConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceWebCrawlerConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceWebCrawlerConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 crawler_limits: Optional['outputs.DataSourceWebCrawlerLimits'] = None,
                 exclusion_filters: Optional[Sequence[_builtins.str]] = None,
                 inclusion_filters: Optional[Sequence[_builtins.str]] = None,
                 scope: Optional['DataSourceWebScopeType'] = None,
                 user_agent: Optional[_builtins.str] = None,
                 user_agent_header: Optional[_builtins.str] = None):
        """
        Configuration for the web crawler.
        :param 'DataSourceWebCrawlerLimits' crawler_limits: The configuration of crawl limits for the web URLs.
        :param Sequence[_builtins.str] exclusion_filters: A list of one or more exclusion regular expression patterns to exclude certain URLs. If you specify an inclusion and exclusion filter/pattern and both match a URL, the exclusion filter takes precedence and the web content of the URL isnt crawled.
        :param Sequence[_builtins.str] inclusion_filters: A list of one or more inclusion regular expression patterns to include certain URLs. If you specify an inclusion and exclusion filter/pattern and both match a URL, the exclusion filter takes precedence and the web content of the URL isnt crawled.
        :param 'DataSourceWebScopeType' scope: The scope of what is crawled for your URLs.
               
               You can choose to crawl only web pages that belong to the same host or primary domain. For example, only web pages that contain the seed URL "https://docs.aws.amazon.com/bedrock/latest/userguide/" and no other domains. You can choose to include sub domains in addition to the host or primary domain. For example, web pages that contain "aws.amazon.com" can also include sub domain "docs.aws.amazon.com".
        :param _builtins.str user_agent: The suffix that will be included in the user agent header.
        :param _builtins.str user_agent_header: The full user agent header, including UUID and suffix.
        """
        if crawler_limits is not None:
            pulumi.set(__self__, "crawler_limits", crawler_limits)
        if exclusion_filters is not None:
            pulumi.set(__self__, "exclusion_filters", exclusion_filters)
        if inclusion_filters is not None:
            pulumi.set(__self__, "inclusion_filters", inclusion_filters)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if user_agent is not None:
            pulumi.set(__self__, "user_agent", user_agent)
        if user_agent_header is not None:
            pulumi.set(__self__, "user_agent_header", user_agent_header)

    @_builtins.property
    @pulumi.getter(name="crawlerLimits")
    def crawler_limits(self) -> Optional['outputs.DataSourceWebCrawlerLimits']:
        """
        The configuration of crawl limits for the web URLs.
        """
        return pulumi.get(self, "crawler_limits")

    @_builtins.property
    @pulumi.getter(name="exclusionFilters")
    def exclusion_filters(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of one or more exclusion regular expression patterns to exclude certain URLs. If you specify an inclusion and exclusion filter/pattern and both match a URL, the exclusion filter takes precedence and the web content of the URL isnt crawled.
        """
        return pulumi.get(self, "exclusion_filters")

    @_builtins.property
    @pulumi.getter(name="inclusionFilters")
    def inclusion_filters(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of one or more inclusion regular expression patterns to include certain URLs. If you specify an inclusion and exclusion filter/pattern and both match a URL, the exclusion filter takes precedence and the web content of the URL isnt crawled.
        """
        return pulumi.get(self, "inclusion_filters")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional['DataSourceWebScopeType']:
        """
        The scope of what is crawled for your URLs.

        You can choose to crawl only web pages that belong to the same host or primary domain. For example, only web pages that contain the seed URL "https://docs.aws.amazon.com/bedrock/latest/userguide/" and no other domains. You can choose to include sub domains in addition to the host or primary domain. For example, web pages that contain "aws.amazon.com" can also include sub domain "docs.aws.amazon.com".
        """
        return pulumi.get(self, "scope")

    @_builtins.property
    @pulumi.getter(name="userAgent")
    def user_agent(self) -> Optional[_builtins.str]:
        """
        The suffix that will be included in the user agent header.
        """
        return pulumi.get(self, "user_agent")

    @_builtins.property
    @pulumi.getter(name="userAgentHeader")
    def user_agent_header(self) -> Optional[_builtins.str]:
        """
        The full user agent header, including UUID and suffix.
        """
        return pulumi.get(self, "user_agent_header")


@pulumi.output_type
class DataSourceWebCrawlerLimits(dict):
    """
    Limit settings for the web crawler.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxPages":
            suggest = "max_pages"
        elif key == "rateLimit":
            suggest = "rate_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceWebCrawlerLimits. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceWebCrawlerLimits.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceWebCrawlerLimits.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_pages: Optional[_builtins.int] = None,
                 rate_limit: Optional[_builtins.int] = None):
        """
        Limit settings for the web crawler.
        :param _builtins.int max_pages: Maximum number of pages the crawler can crawl.
        :param _builtins.int rate_limit: Rate of web URLs retrieved per minute.
        """
        if max_pages is not None:
            pulumi.set(__self__, "max_pages", max_pages)
        if rate_limit is not None:
            pulumi.set(__self__, "rate_limit", rate_limit)

    @_builtins.property
    @pulumi.getter(name="maxPages")
    def max_pages(self) -> Optional[_builtins.int]:
        """
        Maximum number of pages the crawler can crawl.
        """
        return pulumi.get(self, "max_pages")

    @_builtins.property
    @pulumi.getter(name="rateLimit")
    def rate_limit(self) -> Optional[_builtins.int]:
        """
        Rate of web URLs retrieved per minute.
        """
        return pulumi.get(self, "rate_limit")


@pulumi.output_type
class DataSourceWebDataSourceConfiguration(dict):
    """
    Configures a web data source location.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceConfiguration":
            suggest = "source_configuration"
        elif key == "crawlerConfiguration":
            suggest = "crawler_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceWebDataSourceConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceWebDataSourceConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceWebDataSourceConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_configuration: 'outputs.DataSourceWebSourceConfiguration',
                 crawler_configuration: Optional['outputs.DataSourceWebCrawlerConfiguration'] = None):
        """
        Configures a web data source location.
        :param 'DataSourceWebSourceConfiguration' source_configuration: The source configuration details for the web data source.
        :param 'DataSourceWebCrawlerConfiguration' crawler_configuration: The Web Crawler configuration details for the web data source.
        """
        pulumi.set(__self__, "source_configuration", source_configuration)
        if crawler_configuration is not None:
            pulumi.set(__self__, "crawler_configuration", crawler_configuration)

    @_builtins.property
    @pulumi.getter(name="sourceConfiguration")
    def source_configuration(self) -> 'outputs.DataSourceWebSourceConfiguration':
        """
        The source configuration details for the web data source.
        """
        return pulumi.get(self, "source_configuration")

    @_builtins.property
    @pulumi.getter(name="crawlerConfiguration")
    def crawler_configuration(self) -> Optional['outputs.DataSourceWebCrawlerConfiguration']:
        """
        The Web Crawler configuration details for the web data source.
        """
        return pulumi.get(self, "crawler_configuration")


@pulumi.output_type
class DataSourceWebSourceConfiguration(dict):
    """
    A web source configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "urlConfiguration":
            suggest = "url_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataSourceWebSourceConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataSourceWebSourceConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataSourceWebSourceConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url_configuration: 'outputs.DataSourceUrlConfiguration'):
        """
        A web source configuration.
        :param 'DataSourceUrlConfiguration' url_configuration: The configuration of the URL/URLs.
        """
        pulumi.set(__self__, "url_configuration", url_configuration)

    @_builtins.property
    @pulumi.getter(name="urlConfiguration")
    def url_configuration(self) -> 'outputs.DataSourceUrlConfiguration':
        """
        The configuration of the URL/URLs.
        """
        return pulumi.get(self, "url_configuration")


@pulumi.output_type
class FlowAdditionalModelRequestFields(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class FlowAgentFlowNodeConfiguration(dict):
    """
    Agent flow node configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "agentAliasArn":
            suggest = "agent_alias_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowAgentFlowNodeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowAgentFlowNodeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowAgentFlowNodeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 agent_alias_arn: _builtins.str):
        """
        Agent flow node configuration
        :param _builtins.str agent_alias_arn: Arn representation of the Agent Alias.
        """
        pulumi.set(__self__, "agent_alias_arn", agent_alias_arn)

    @_builtins.property
    @pulumi.getter(name="agentAliasArn")
    def agent_alias_arn(self) -> _builtins.str:
        """
        Arn representation of the Agent Alias.
        """
        return pulumi.get(self, "agent_alias_arn")


@pulumi.output_type
class FlowAliasConcurrencyConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConcurrency":
            suggest = "max_concurrency"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowAliasConcurrencyConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowAliasConcurrencyConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowAliasConcurrencyConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: 'FlowAliasConcurrencyType',
                 max_concurrency: Optional[_builtins.float] = None):
        """
        :param 'FlowAliasConcurrencyType' type: The type of concurrency to use for parallel node execution. Specify one of the following options:
               
               - `Automatic` - Amazon Bedrock determines which nodes can be executed in parallel based on the flow definition and its dependencies.
               - `Manual` - You specify which nodes can be executed in parallel.
        :param _builtins.float max_concurrency: Number of nodes executed concurrently at a time
        """
        pulumi.set(__self__, "type", type)
        if max_concurrency is not None:
            pulumi.set(__self__, "max_concurrency", max_concurrency)

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'FlowAliasConcurrencyType':
        """
        The type of concurrency to use for parallel node execution. Specify one of the following options:

        - `Automatic` - Amazon Bedrock determines which nodes can be executed in parallel based on the flow definition and its dependencies.
        - `Manual` - You specify which nodes can be executed in parallel.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="maxConcurrency")
    def max_concurrency(self) -> Optional[_builtins.float]:
        """
        Number of nodes executed concurrently at a time
        """
        return pulumi.get(self, "max_concurrency")


@pulumi.output_type
class FlowAliasRoutingConfigurationListItem(dict):
    """
    Details about the routing configuration for a Flow alias.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "flowVersion":
            suggest = "flow_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowAliasRoutingConfigurationListItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowAliasRoutingConfigurationListItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowAliasRoutingConfigurationListItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 flow_version: Optional[_builtins.str] = None):
        """
        Details about the routing configuration for a Flow alias.
        :param _builtins.str flow_version: Version.
        """
        if flow_version is not None:
            pulumi.set(__self__, "flow_version", flow_version)

    @_builtins.property
    @pulumi.getter(name="flowVersion")
    def flow_version(self) -> Optional[_builtins.str]:
        """
        Version.
        """
        return pulumi.get(self, "flow_version")


@pulumi.output_type
class FlowCollectorFlowNodeConfiguration(dict):
    """
    Collector flow node configuration
    """
    def __init__(__self__):
        """
        Collector flow node configuration
        """
        pass


@pulumi.output_type
class FlowCondition(dict):
    """
    Condition branch for a condition node
    """
    def __init__(__self__, *,
                 name: _builtins.str,
                 expression: Optional[_builtins.str] = None):
        """
        Condition branch for a condition node
        :param _builtins.str name: Name of a condition in a flow
        :param _builtins.str expression: Expression for a condition in a flow
        """
        pulumi.set(__self__, "name", name)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of a condition in a flow
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[_builtins.str]:
        """
        Expression for a condition in a flow
        """
        return pulumi.get(self, "expression")


@pulumi.output_type
class FlowConditionFlowNodeConfiguration(dict):
    """
    Condition flow node configuration
    """
    def __init__(__self__, *,
                 conditions: Sequence['outputs.FlowCondition']):
        """
        Condition flow node configuration
        :param Sequence['FlowCondition'] conditions: List of conditions in a condition node
        """
        pulumi.set(__self__, "conditions", conditions)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.FlowCondition']:
        """
        List of conditions in a condition node
        """
        return pulumi.get(self, "conditions")


@pulumi.output_type
class FlowConditionalConnectionConfiguration(dict):
    """
    Conditional connection configuration
    """
    def __init__(__self__, *,
                 condition: _builtins.str):
        """
        Conditional connection configuration
        :param _builtins.str condition: Name of a condition in a flow
        """
        pulumi.set(__self__, "condition", condition)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> _builtins.str:
        """
        Name of a condition in a flow
        """
        return pulumi.get(self, "condition")


@pulumi.output_type
class FlowConnection(dict):
    """
    Flow connection
    """
    def __init__(__self__, *,
                 name: _builtins.str,
                 source: _builtins.str,
                 target: _builtins.str,
                 type: 'FlowConnectionType',
                 configuration: Optional[Any] = None):
        """
        Flow connection
        :param _builtins.str name: Name of a connection in a flow
        :param _builtins.str source: Name of a node in a flow
        :param _builtins.str target: Name of a node in a flow
        :param 'FlowConnectionType' type: Whether the source node that the connection begins from is a condition node ( `Conditional` ) or not ( `Data` ).
        :param Union['FlowConnectionConfiguration0Properties', 'FlowConnectionConfiguration1Properties'] configuration: The configuration of the connection.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "type", type)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of a connection in a flow
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        """
        Name of a node in a flow
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.str:
        """
        Name of a node in a flow
        """
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'FlowConnectionType':
        """
        Whether the source node that the connection begins from is a condition node ( `Conditional` ) or not ( `Data` ).
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> Optional[Any]:
        """
        The configuration of the connection.
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class FlowConnectionConfiguration0Properties(dict):
    """
    Connection configuration
    """
    def __init__(__self__, *,
                 data: 'outputs.FlowDataConnectionConfiguration'):
        """
        Connection configuration
        """
        pulumi.set(__self__, "data", data)

    @_builtins.property
    @pulumi.getter
    def data(self) -> 'outputs.FlowDataConnectionConfiguration':
        return pulumi.get(self, "data")


@pulumi.output_type
class FlowConnectionConfiguration1Properties(dict):
    """
    Connection configuration
    """
    def __init__(__self__, *,
                 conditional: 'outputs.FlowConditionalConnectionConfiguration'):
        """
        Connection configuration
        """
        pulumi.set(__self__, "conditional", conditional)

    @_builtins.property
    @pulumi.getter
    def conditional(self) -> 'outputs.FlowConditionalConnectionConfiguration':
        return pulumi.get(self, "conditional")


@pulumi.output_type
class FlowDataConnectionConfiguration(dict):
    """
    Data connection configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceOutput":
            suggest = "source_output"
        elif key == "targetInput":
            suggest = "target_input"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowDataConnectionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowDataConnectionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowDataConnectionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_output: _builtins.str,
                 target_input: _builtins.str):
        """
        Data connection configuration
        :param _builtins.str source_output: Name of a node output in a flow
        :param _builtins.str target_input: Name of a node input in a flow
        """
        pulumi.set(__self__, "source_output", source_output)
        pulumi.set(__self__, "target_input", target_input)

    @_builtins.property
    @pulumi.getter(name="sourceOutput")
    def source_output(self) -> _builtins.str:
        """
        Name of a node output in a flow
        """
        return pulumi.get(self, "source_output")

    @_builtins.property
    @pulumi.getter(name="targetInput")
    def target_input(self) -> _builtins.str:
        """
        Name of a node input in a flow
        """
        return pulumi.get(self, "target_input")


@pulumi.output_type
class FlowDefinition(dict):
    """
    Flow definition
    """
    def __init__(__self__, *,
                 connections: Optional[Sequence['outputs.FlowConnection']] = None,
                 nodes: Optional[Sequence['outputs.FlowNode']] = None):
        """
        Flow definition
        :param Sequence['FlowConnection'] connections: List of connections
        :param Sequence['FlowNode'] nodes: List of nodes in a flow
        """
        if connections is not None:
            pulumi.set(__self__, "connections", connections)
        if nodes is not None:
            pulumi.set(__self__, "nodes", nodes)

    @_builtins.property
    @pulumi.getter
    def connections(self) -> Optional[Sequence['outputs.FlowConnection']]:
        """
        List of connections
        """
        return pulumi.get(self, "connections")

    @_builtins.property
    @pulumi.getter
    def nodes(self) -> Optional[Sequence['outputs.FlowNode']]:
        """
        List of nodes in a flow
        """
        return pulumi.get(self, "nodes")


@pulumi.output_type
class FlowFieldForReranking(dict):
    """
    Field name for reranking
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowFieldForReranking. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowFieldForReranking.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowFieldForReranking.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_name: _builtins.str):
        """
        Field name for reranking
        :param _builtins.str field_name: Field name for reranking
        """
        pulumi.set(__self__, "field_name", field_name)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> _builtins.str:
        """
        Field name for reranking
        """
        return pulumi.get(self, "field_name")


@pulumi.output_type
class FlowGuardrailConfiguration(dict):
    """
    Configuration for a guardrail
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "guardrailIdentifier":
            suggest = "guardrail_identifier"
        elif key == "guardrailVersion":
            suggest = "guardrail_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowGuardrailConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowGuardrailConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowGuardrailConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 guardrail_identifier: Optional[_builtins.str] = None,
                 guardrail_version: Optional[_builtins.str] = None):
        """
        Configuration for a guardrail
        :param _builtins.str guardrail_identifier: Identifier for the guardrail, could be the id or the arn
        :param _builtins.str guardrail_version: Version of the guardrail
        """
        if guardrail_identifier is not None:
            pulumi.set(__self__, "guardrail_identifier", guardrail_identifier)
        if guardrail_version is not None:
            pulumi.set(__self__, "guardrail_version", guardrail_version)

    @_builtins.property
    @pulumi.getter(name="guardrailIdentifier")
    def guardrail_identifier(self) -> Optional[_builtins.str]:
        """
        Identifier for the guardrail, could be the id or the arn
        """
        return pulumi.get(self, "guardrail_identifier")

    @_builtins.property
    @pulumi.getter(name="guardrailVersion")
    def guardrail_version(self) -> Optional[_builtins.str]:
        """
        Version of the guardrail
        """
        return pulumi.get(self, "guardrail_version")


@pulumi.output_type
class FlowInlineCodeFlowNodeConfiguration(dict):
    """
    Inline code config strucuture, contains code configs
    """
    def __init__(__self__, *,
                 code: _builtins.str,
                 language: 'FlowSupportedLanguages'):
        """
        Inline code config strucuture, contains code configs
        :param _builtins.str code: The inline code entered by customers. max size is 5MB.
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "language", language)

    @_builtins.property
    @pulumi.getter
    def code(self) -> _builtins.str:
        """
        The inline code entered by customers. max size is 5MB.
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def language(self) -> 'FlowSupportedLanguages':
        return pulumi.get(self, "language")


@pulumi.output_type
class FlowInputFlowNodeConfiguration(dict):
    """
    Input flow node configuration
    """
    def __init__(__self__):
        """
        Input flow node configuration
        """
        pass


@pulumi.output_type
class FlowIteratorFlowNodeConfiguration(dict):
    """
    Iterator flow node configuration
    """
    def __init__(__self__):
        """
        Iterator flow node configuration
        """
        pass


@pulumi.output_type
class FlowKnowledgeBaseFlowNodeConfiguration(dict):
    """
    Knowledge base flow node configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "knowledgeBaseId":
            suggest = "knowledge_base_id"
        elif key == "guardrailConfiguration":
            suggest = "guardrail_configuration"
        elif key == "inferenceConfiguration":
            suggest = "inference_configuration"
        elif key == "modelId":
            suggest = "model_id"
        elif key == "numberOfResults":
            suggest = "number_of_results"
        elif key == "orchestrationConfiguration":
            suggest = "orchestration_configuration"
        elif key == "promptTemplate":
            suggest = "prompt_template"
        elif key == "rerankingConfiguration":
            suggest = "reranking_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowKnowledgeBaseFlowNodeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowKnowledgeBaseFlowNodeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowKnowledgeBaseFlowNodeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 knowledge_base_id: _builtins.str,
                 guardrail_configuration: Optional['outputs.FlowGuardrailConfiguration'] = None,
                 inference_configuration: Optional['outputs.FlowPromptInferenceConfigurationProperties'] = None,
                 model_id: Optional[_builtins.str] = None,
                 number_of_results: Optional[_builtins.float] = None,
                 orchestration_configuration: Optional['outputs.FlowKnowledgeBaseOrchestrationConfiguration'] = None,
                 prompt_template: Optional['outputs.FlowKnowledgeBasePromptTemplateProperties'] = None,
                 reranking_configuration: Optional['outputs.FlowVectorSearchRerankingConfiguration'] = None):
        """
        Knowledge base flow node configuration
        :param _builtins.str knowledge_base_id: Identifier of the KnowledgeBase
        :param _builtins.str model_id: ARN or Id of a Bedrock Foundational Model or Inference Profile, or the ARN of a imported model, or a provisioned throughput ARN for custom models.
        :param _builtins.float number_of_results: Number Of Results to Retrieve
        """
        pulumi.set(__self__, "knowledge_base_id", knowledge_base_id)
        if guardrail_configuration is not None:
            pulumi.set(__self__, "guardrail_configuration", guardrail_configuration)
        if inference_configuration is not None:
            pulumi.set(__self__, "inference_configuration", inference_configuration)
        if model_id is not None:
            pulumi.set(__self__, "model_id", model_id)
        if number_of_results is not None:
            pulumi.set(__self__, "number_of_results", number_of_results)
        if orchestration_configuration is not None:
            pulumi.set(__self__, "orchestration_configuration", orchestration_configuration)
        if prompt_template is not None:
            pulumi.set(__self__, "prompt_template", prompt_template)
        if reranking_configuration is not None:
            pulumi.set(__self__, "reranking_configuration", reranking_configuration)

    @_builtins.property
    @pulumi.getter(name="knowledgeBaseId")
    def knowledge_base_id(self) -> _builtins.str:
        """
        Identifier of the KnowledgeBase
        """
        return pulumi.get(self, "knowledge_base_id")

    @_builtins.property
    @pulumi.getter(name="guardrailConfiguration")
    def guardrail_configuration(self) -> Optional['outputs.FlowGuardrailConfiguration']:
        return pulumi.get(self, "guardrail_configuration")

    @_builtins.property
    @pulumi.getter(name="inferenceConfiguration")
    def inference_configuration(self) -> Optional['outputs.FlowPromptInferenceConfigurationProperties']:
        return pulumi.get(self, "inference_configuration")

    @_builtins.property
    @pulumi.getter(name="modelId")
    def model_id(self) -> Optional[_builtins.str]:
        """
        ARN or Id of a Bedrock Foundational Model or Inference Profile, or the ARN of a imported model, or a provisioned throughput ARN for custom models.
        """
        return pulumi.get(self, "model_id")

    @_builtins.property
    @pulumi.getter(name="numberOfResults")
    def number_of_results(self) -> Optional[_builtins.float]:
        """
        Number Of Results to Retrieve
        """
        return pulumi.get(self, "number_of_results")

    @_builtins.property
    @pulumi.getter(name="orchestrationConfiguration")
    def orchestration_configuration(self) -> Optional['outputs.FlowKnowledgeBaseOrchestrationConfiguration']:
        return pulumi.get(self, "orchestration_configuration")

    @_builtins.property
    @pulumi.getter(name="promptTemplate")
    def prompt_template(self) -> Optional['outputs.FlowKnowledgeBasePromptTemplateProperties']:
        return pulumi.get(self, "prompt_template")

    @_builtins.property
    @pulumi.getter(name="rerankingConfiguration")
    def reranking_configuration(self) -> Optional['outputs.FlowVectorSearchRerankingConfiguration']:
        return pulumi.get(self, "reranking_configuration")


@pulumi.output_type
class FlowKnowledgeBaseOrchestrationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalModelRequestFields":
            suggest = "additional_model_request_fields"
        elif key == "inferenceConfig":
            suggest = "inference_config"
        elif key == "performanceConfig":
            suggest = "performance_config"
        elif key == "promptTemplate":
            suggest = "prompt_template"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowKnowledgeBaseOrchestrationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowKnowledgeBaseOrchestrationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowKnowledgeBaseOrchestrationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_model_request_fields: Optional['outputs.FlowAdditionalModelRequestFields'] = None,
                 inference_config: Optional['outputs.FlowPromptInferenceConfigurationProperties'] = None,
                 performance_config: Optional['outputs.FlowPerformanceConfiguration'] = None,
                 prompt_template: Optional['outputs.FlowKnowledgeBasePromptTemplateProperties'] = None):
        if additional_model_request_fields is not None:
            pulumi.set(__self__, "additional_model_request_fields", additional_model_request_fields)
        if inference_config is not None:
            pulumi.set(__self__, "inference_config", inference_config)
        if performance_config is not None:
            pulumi.set(__self__, "performance_config", performance_config)
        if prompt_template is not None:
            pulumi.set(__self__, "prompt_template", prompt_template)

    @_builtins.property
    @pulumi.getter(name="additionalModelRequestFields")
    def additional_model_request_fields(self) -> Optional['outputs.FlowAdditionalModelRequestFields']:
        return pulumi.get(self, "additional_model_request_fields")

    @_builtins.property
    @pulumi.getter(name="inferenceConfig")
    def inference_config(self) -> Optional['outputs.FlowPromptInferenceConfigurationProperties']:
        return pulumi.get(self, "inference_config")

    @_builtins.property
    @pulumi.getter(name="performanceConfig")
    def performance_config(self) -> Optional['outputs.FlowPerformanceConfiguration']:
        return pulumi.get(self, "performance_config")

    @_builtins.property
    @pulumi.getter(name="promptTemplate")
    def prompt_template(self) -> Optional['outputs.FlowKnowledgeBasePromptTemplateProperties']:
        return pulumi.get(self, "prompt_template")


@pulumi.output_type
class FlowKnowledgeBasePromptTemplateProperties(dict):
    """
    Knowledge Base Prompt template
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textPromptTemplate":
            suggest = "text_prompt_template"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowKnowledgeBasePromptTemplateProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowKnowledgeBasePromptTemplateProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowKnowledgeBasePromptTemplateProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text_prompt_template: _builtins.str):
        """
        Knowledge Base Prompt template
        """
        pulumi.set(__self__, "text_prompt_template", text_prompt_template)

    @_builtins.property
    @pulumi.getter(name="textPromptTemplate")
    def text_prompt_template(self) -> _builtins.str:
        return pulumi.get(self, "text_prompt_template")


@pulumi.output_type
class FlowLambdaFunctionFlowNodeConfiguration(dict):
    """
    Lambda function flow node configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lambdaArn":
            suggest = "lambda_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowLambdaFunctionFlowNodeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowLambdaFunctionFlowNodeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowLambdaFunctionFlowNodeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lambda_arn: _builtins.str):
        """
        Lambda function flow node configuration
        :param _builtins.str lambda_arn: ARN of a Lambda.
        """
        pulumi.set(__self__, "lambda_arn", lambda_arn)

    @_builtins.property
    @pulumi.getter(name="lambdaArn")
    def lambda_arn(self) -> _builtins.str:
        """
        ARN of a Lambda.
        """
        return pulumi.get(self, "lambda_arn")


@pulumi.output_type
class FlowLexFlowNodeConfiguration(dict):
    """
    Lex flow node configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "botAliasArn":
            suggest = "bot_alias_arn"
        elif key == "localeId":
            suggest = "locale_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowLexFlowNodeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowLexFlowNodeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowLexFlowNodeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bot_alias_arn: _builtins.str,
                 locale_id: _builtins.str):
        """
        Lex flow node configuration
        :param _builtins.str bot_alias_arn: ARN of a Lex bot alias
        :param _builtins.str locale_id: Lex bot locale id
        """
        pulumi.set(__self__, "bot_alias_arn", bot_alias_arn)
        pulumi.set(__self__, "locale_id", locale_id)

    @_builtins.property
    @pulumi.getter(name="botAliasArn")
    def bot_alias_arn(self) -> _builtins.str:
        """
        ARN of a Lex bot alias
        """
        return pulumi.get(self, "bot_alias_arn")

    @_builtins.property
    @pulumi.getter(name="localeId")
    def locale_id(self) -> _builtins.str:
        """
        Lex bot locale id
        """
        return pulumi.get(self, "locale_id")


@pulumi.output_type
class FlowLoopControllerFlowNodeConfiguration(dict):
    """
    Configuration for the LoopController node, which manages loop execution
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "continueCondition":
            suggest = "continue_condition"
        elif key == "maxIterations":
            suggest = "max_iterations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowLoopControllerFlowNodeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowLoopControllerFlowNodeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowLoopControllerFlowNodeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 continue_condition: 'outputs.FlowCondition',
                 max_iterations: Optional[_builtins.float] = None):
        """
        Configuration for the LoopController node, which manages loop execution
        :param _builtins.float max_iterations: Maximum number of iterations the loop can perform
        """
        pulumi.set(__self__, "continue_condition", continue_condition)
        if max_iterations is not None:
            pulumi.set(__self__, "max_iterations", max_iterations)

    @_builtins.property
    @pulumi.getter(name="continueCondition")
    def continue_condition(self) -> 'outputs.FlowCondition':
        return pulumi.get(self, "continue_condition")

    @_builtins.property
    @pulumi.getter(name="maxIterations")
    def max_iterations(self) -> Optional[_builtins.float]:
        """
        Maximum number of iterations the loop can perform
        """
        return pulumi.get(self, "max_iterations")


@pulumi.output_type
class FlowLoopFlowNodeConfiguration(dict):
    """
    Loop node config, contains loop's internal definition
    """
    def __init__(__self__, *,
                 definition: 'outputs.FlowDefinition'):
        """
        Loop node config, contains loop's internal definition
        """
        pulumi.set(__self__, "definition", definition)

    @_builtins.property
    @pulumi.getter
    def definition(self) -> 'outputs.FlowDefinition':
        return pulumi.get(self, "definition")


@pulumi.output_type
class FlowLoopInputFlowNodeConfiguration(dict):
    """
    Configuration for the LoopInput node
    """
    def __init__(__self__):
        """
        Configuration for the LoopInput node
        """
        pass


@pulumi.output_type
class FlowMetadataConfigurationForReranking(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "selectionMode":
            suggest = "selection_mode"
        elif key == "selectiveModeConfiguration":
            suggest = "selective_mode_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowMetadataConfigurationForReranking. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowMetadataConfigurationForReranking.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowMetadataConfigurationForReranking.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 selection_mode: 'FlowRerankingMetadataSelectionMode',
                 selective_mode_configuration: Optional[Any] = None):
        pulumi.set(__self__, "selection_mode", selection_mode)
        if selective_mode_configuration is not None:
            pulumi.set(__self__, "selective_mode_configuration", selective_mode_configuration)

    @_builtins.property
    @pulumi.getter(name="selectionMode")
    def selection_mode(self) -> 'FlowRerankingMetadataSelectionMode':
        return pulumi.get(self, "selection_mode")

    @_builtins.property
    @pulumi.getter(name="selectiveModeConfiguration")
    def selective_mode_configuration(self) -> Optional[Any]:
        return pulumi.get(self, "selective_mode_configuration")


@pulumi.output_type
class FlowNode(dict):
    """
    Internal mixin for flow node
    """
    def __init__(__self__, *,
                 name: _builtins.str,
                 type: 'FlowNodeType',
                 configuration: Optional[Any] = None,
                 inputs: Optional[Sequence['outputs.FlowNodeInput']] = None,
                 outputs: Optional[Sequence['outputs.FlowNodeOutput']] = None):
        """
        Internal mixin for flow node
        :param _builtins.str name: Name of a node in a flow
        :param 'FlowNodeType' type: The type of node. This value must match the name of the key that you provide in the configuration you provide in the `FlowNodeConfiguration` field.
        :param Union['FlowNodeConfiguration0Properties', 'FlowNodeConfiguration1Properties', 'FlowNodeConfiguration2Properties', 'FlowNodeConfiguration3Properties', 'FlowNodeConfiguration4Properties', 'FlowNodeConfiguration5Properties', 'FlowNodeConfiguration6Properties', 'FlowNodeConfiguration7Properties', 'FlowNodeConfiguration8Properties', 'FlowNodeConfiguration9Properties', 'FlowNodeConfiguration10Properties', 'FlowNodeConfiguration11Properties', 'FlowNodeConfiguration12Properties', 'FlowNodeConfiguration13Properties', 'FlowNodeConfiguration14Properties', 'FlowNodeConfiguration15Properties'] configuration: Contains configurations for the node.
        :param Sequence['FlowNodeInput'] inputs: List of node inputs in a flow
        :param Sequence['FlowNodeOutput'] outputs: List of node outputs in a flow
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if inputs is not None:
            pulumi.set(__self__, "inputs", inputs)
        if outputs is not None:
            pulumi.set(__self__, "outputs", outputs)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of a node in a flow
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'FlowNodeType':
        """
        The type of node. This value must match the name of the key that you provide in the configuration you provide in the `FlowNodeConfiguration` field.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> Optional[Any]:
        """
        Contains configurations for the node.
        """
        return pulumi.get(self, "configuration")

    @_builtins.property
    @pulumi.getter
    def inputs(self) -> Optional[Sequence['outputs.FlowNodeInput']]:
        """
        List of node inputs in a flow
        """
        return pulumi.get(self, "inputs")

    @_builtins.property
    @pulumi.getter
    def outputs(self) -> Optional[Sequence['outputs.FlowNodeOutput']]:
        """
        List of node outputs in a flow
        """
        return pulumi.get(self, "outputs")


@pulumi.output_type
class FlowNodeConfiguration0Properties(dict):
    """
    Node configuration in a flow
    """
    def __init__(__self__, *,
                 input: 'outputs.FlowInputFlowNodeConfiguration'):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "input", input)

    @_builtins.property
    @pulumi.getter
    def input(self) -> 'outputs.FlowInputFlowNodeConfiguration':
        return pulumi.get(self, "input")


@pulumi.output_type
class FlowNodeConfiguration10Properties(dict):
    """
    Node configuration in a flow
    """
    def __init__(__self__, *,
                 collector: 'outputs.FlowCollectorFlowNodeConfiguration'):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "collector", collector)

    @_builtins.property
    @pulumi.getter
    def collector(self) -> 'outputs.FlowCollectorFlowNodeConfiguration':
        return pulumi.get(self, "collector")


@pulumi.output_type
class FlowNodeConfiguration11Properties(dict):
    """
    Node configuration in a flow
    """
    def __init__(__self__, *,
                 retrieval: 'outputs.FlowRetrievalFlowNodeConfiguration'):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "retrieval", retrieval)

    @_builtins.property
    @pulumi.getter
    def retrieval(self) -> 'outputs.FlowRetrievalFlowNodeConfiguration':
        return pulumi.get(self, "retrieval")


@pulumi.output_type
class FlowNodeConfiguration12Properties(dict):
    """
    Node configuration in a flow
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inlineCode":
            suggest = "inline_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowNodeConfiguration12Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowNodeConfiguration12Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowNodeConfiguration12Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inline_code: 'outputs.FlowInlineCodeFlowNodeConfiguration'):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "inline_code", inline_code)

    @_builtins.property
    @pulumi.getter(name="inlineCode")
    def inline_code(self) -> 'outputs.FlowInlineCodeFlowNodeConfiguration':
        return pulumi.get(self, "inline_code")


@pulumi.output_type
class FlowNodeConfiguration13Properties(dict):
    """
    Node configuration in a flow
    """
    def __init__(__self__, *,
                 loop: 'outputs.FlowLoopFlowNodeConfiguration'):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "loop", loop)

    @_builtins.property
    @pulumi.getter
    def loop(self) -> 'outputs.FlowLoopFlowNodeConfiguration':
        return pulumi.get(self, "loop")


@pulumi.output_type
class FlowNodeConfiguration14Properties(dict):
    """
    Node configuration in a flow
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loopInput":
            suggest = "loop_input"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowNodeConfiguration14Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowNodeConfiguration14Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowNodeConfiguration14Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 loop_input: 'outputs.FlowLoopInputFlowNodeConfiguration'):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "loop_input", loop_input)

    @_builtins.property
    @pulumi.getter(name="loopInput")
    def loop_input(self) -> 'outputs.FlowLoopInputFlowNodeConfiguration':
        return pulumi.get(self, "loop_input")


@pulumi.output_type
class FlowNodeConfiguration15Properties(dict):
    """
    Node configuration in a flow
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loopController":
            suggest = "loop_controller"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowNodeConfiguration15Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowNodeConfiguration15Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowNodeConfiguration15Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 loop_controller: 'outputs.FlowLoopControllerFlowNodeConfiguration'):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "loop_controller", loop_controller)

    @_builtins.property
    @pulumi.getter(name="loopController")
    def loop_controller(self) -> 'outputs.FlowLoopControllerFlowNodeConfiguration':
        return pulumi.get(self, "loop_controller")


@pulumi.output_type
class FlowNodeConfiguration1Properties(dict):
    """
    Node configuration in a flow
    """
    def __init__(__self__, *,
                 output: 'outputs.FlowOutputFlowNodeConfiguration'):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "output", output)

    @_builtins.property
    @pulumi.getter
    def output(self) -> 'outputs.FlowOutputFlowNodeConfiguration':
        return pulumi.get(self, "output")


@pulumi.output_type
class FlowNodeConfiguration2Properties(dict):
    """
    Node configuration in a flow
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "knowledgeBase":
            suggest = "knowledge_base"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowNodeConfiguration2Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowNodeConfiguration2Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowNodeConfiguration2Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 knowledge_base: 'outputs.FlowKnowledgeBaseFlowNodeConfiguration'):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "knowledge_base", knowledge_base)

    @_builtins.property
    @pulumi.getter(name="knowledgeBase")
    def knowledge_base(self) -> 'outputs.FlowKnowledgeBaseFlowNodeConfiguration':
        return pulumi.get(self, "knowledge_base")


@pulumi.output_type
class FlowNodeConfiguration3Properties(dict):
    """
    Node configuration in a flow
    """
    def __init__(__self__, *,
                 condition: 'outputs.FlowConditionFlowNodeConfiguration'):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "condition", condition)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> 'outputs.FlowConditionFlowNodeConfiguration':
        return pulumi.get(self, "condition")


@pulumi.output_type
class FlowNodeConfiguration4Properties(dict):
    """
    Node configuration in a flow
    """
    def __init__(__self__, *,
                 lex: 'outputs.FlowLexFlowNodeConfiguration'):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "lex", lex)

    @_builtins.property
    @pulumi.getter
    def lex(self) -> 'outputs.FlowLexFlowNodeConfiguration':
        return pulumi.get(self, "lex")


@pulumi.output_type
class FlowNodeConfiguration5Properties(dict):
    """
    Node configuration in a flow
    """
    def __init__(__self__, *,
                 prompt: 'outputs.FlowPromptFlowNodeConfiguration'):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "prompt", prompt)

    @_builtins.property
    @pulumi.getter
    def prompt(self) -> 'outputs.FlowPromptFlowNodeConfiguration':
        return pulumi.get(self, "prompt")


@pulumi.output_type
class FlowNodeConfiguration6Properties(dict):
    """
    Node configuration in a flow
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lambdaFunction":
            suggest = "lambda_function"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowNodeConfiguration6Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowNodeConfiguration6Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowNodeConfiguration6Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lambda_function: 'outputs.FlowLambdaFunctionFlowNodeConfiguration'):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "lambda_function", lambda_function)

    @_builtins.property
    @pulumi.getter(name="lambdaFunction")
    def lambda_function(self) -> 'outputs.FlowLambdaFunctionFlowNodeConfiguration':
        return pulumi.get(self, "lambda_function")


@pulumi.output_type
class FlowNodeConfiguration7Properties(dict):
    """
    Node configuration in a flow
    """
    def __init__(__self__, *,
                 agent: 'outputs.FlowAgentFlowNodeConfiguration'):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "agent", agent)

    @_builtins.property
    @pulumi.getter
    def agent(self) -> 'outputs.FlowAgentFlowNodeConfiguration':
        return pulumi.get(self, "agent")


@pulumi.output_type
class FlowNodeConfiguration8Properties(dict):
    """
    Node configuration in a flow
    """
    def __init__(__self__, *,
                 storage: 'outputs.FlowStorageFlowNodeConfiguration'):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "storage", storage)

    @_builtins.property
    @pulumi.getter
    def storage(self) -> 'outputs.FlowStorageFlowNodeConfiguration':
        return pulumi.get(self, "storage")


@pulumi.output_type
class FlowNodeConfiguration9Properties(dict):
    """
    Node configuration in a flow
    """
    def __init__(__self__, *,
                 iterator: 'outputs.FlowIteratorFlowNodeConfiguration'):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "iterator", iterator)

    @_builtins.property
    @pulumi.getter
    def iterator(self) -> 'outputs.FlowIteratorFlowNodeConfiguration':
        return pulumi.get(self, "iterator")


@pulumi.output_type
class FlowNodeInput(dict):
    """
    Input to a node in a flow
    """
    def __init__(__self__, *,
                 expression: _builtins.str,
                 name: _builtins.str,
                 type: 'FlowNodeIoDataType',
                 category: Optional['FlowNodeInputCategory'] = None):
        """
        Input to a node in a flow
        :param _builtins.str expression: Expression for a node input in a flow
        :param _builtins.str name: Name of a node input in a flow
        :param 'FlowNodeIoDataType' type: Specifies the data type of the input. If the input doesn't match this type at runtime, a validation error will be thrown.
        :param 'FlowNodeInputCategory' category: Specifies how input data flows between iterations in a DoWhile loop.
               
               - `LoopCondition` - Controls whether the loop continues by evaluating condition expressions against the input data. Use this category to define the condition that determines if the loop should continue.
               - `ReturnValueToLoopStart` - Defines data to pass back to the start of the loop's next iteration. Use this category for variables that you want to update for each loop iteration.
               - `ExitLoop` - Defines the value that's available once the loop ends. Use this category to expose loop results to nodes outside the loop.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if category is not None:
            pulumi.set(__self__, "category", category)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        Expression for a node input in a flow
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of a node input in a flow
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'FlowNodeIoDataType':
        """
        Specifies the data type of the input. If the input doesn't match this type at runtime, a validation error will be thrown.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def category(self) -> Optional['FlowNodeInputCategory']:
        """
        Specifies how input data flows between iterations in a DoWhile loop.

        - `LoopCondition` - Controls whether the loop continues by evaluating condition expressions against the input data. Use this category to define the condition that determines if the loop should continue.
        - `ReturnValueToLoopStart` - Defines data to pass back to the start of the loop's next iteration. Use this category for variables that you want to update for each loop iteration.
        - `ExitLoop` - Defines the value that's available once the loop ends. Use this category to expose loop results to nodes outside the loop.
        """
        return pulumi.get(self, "category")


@pulumi.output_type
class FlowNodeOutput(dict):
    """
    Output of a node in a flow
    """
    def __init__(__self__, *,
                 name: _builtins.str,
                 type: 'FlowNodeIoDataType'):
        """
        Output of a node in a flow
        :param _builtins.str name: Name of a node output in a flow
        :param 'FlowNodeIoDataType' type: The data type of the output. If the output doesn't match this type at runtime, a validation error will be thrown.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of a node output in a flow
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'FlowNodeIoDataType':
        """
        The data type of the output. If the output doesn't match this type at runtime, a validation error will be thrown.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class FlowOutputFlowNodeConfiguration(dict):
    """
    Output flow node configuration
    """
    def __init__(__self__):
        """
        Output flow node configuration
        """
        pass


@pulumi.output_type
class FlowPerformanceConfiguration(dict):
    def __init__(__self__, *,
                 latency: Optional['FlowPerformanceConfigurationLatency'] = None):
        if latency is not None:
            pulumi.set(__self__, "latency", latency)

    @_builtins.property
    @pulumi.getter
    def latency(self) -> Optional['FlowPerformanceConfigurationLatency']:
        return pulumi.get(self, "latency")


@pulumi.output_type
class FlowPromptFlowNodeConfiguration(dict):
    """
    Prompt flow node configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceConfiguration":
            suggest = "source_configuration"
        elif key == "guardrailConfiguration":
            suggest = "guardrail_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowPromptFlowNodeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowPromptFlowNodeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowPromptFlowNodeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_configuration: Any,
                 guardrail_configuration: Optional['outputs.FlowGuardrailConfiguration'] = None):
        """
        Prompt flow node configuration
        """
        pulumi.set(__self__, "source_configuration", source_configuration)
        if guardrail_configuration is not None:
            pulumi.set(__self__, "guardrail_configuration", guardrail_configuration)

    @_builtins.property
    @pulumi.getter(name="sourceConfiguration")
    def source_configuration(self) -> Any:
        return pulumi.get(self, "source_configuration")

    @_builtins.property
    @pulumi.getter(name="guardrailConfiguration")
    def guardrail_configuration(self) -> Optional['outputs.FlowGuardrailConfiguration']:
        return pulumi.get(self, "guardrail_configuration")


@pulumi.output_type
class FlowPromptFlowNodeInlineConfiguration(dict):
    """
    Inline prompt configuration for prompt node
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "modelId":
            suggest = "model_id"
        elif key == "templateConfiguration":
            suggest = "template_configuration"
        elif key == "templateType":
            suggest = "template_type"
        elif key == "inferenceConfiguration":
            suggest = "inference_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowPromptFlowNodeInlineConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowPromptFlowNodeInlineConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowPromptFlowNodeInlineConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 model_id: _builtins.str,
                 template_configuration: 'outputs.FlowPromptTemplateConfigurationProperties',
                 template_type: 'FlowPromptTemplateType',
                 inference_configuration: Optional['outputs.FlowPromptInferenceConfigurationProperties'] = None):
        """
        Inline prompt configuration for prompt node
        :param _builtins.str model_id: ARN or Id of a Bedrock Foundational Model or Inference Profile, or the ARN of a imported model, or a provisioned throughput ARN for custom models.
        """
        pulumi.set(__self__, "model_id", model_id)
        pulumi.set(__self__, "template_configuration", template_configuration)
        pulumi.set(__self__, "template_type", template_type)
        if inference_configuration is not None:
            pulumi.set(__self__, "inference_configuration", inference_configuration)

    @_builtins.property
    @pulumi.getter(name="modelId")
    def model_id(self) -> _builtins.str:
        """
        ARN or Id of a Bedrock Foundational Model or Inference Profile, or the ARN of a imported model, or a provisioned throughput ARN for custom models.
        """
        return pulumi.get(self, "model_id")

    @_builtins.property
    @pulumi.getter(name="templateConfiguration")
    def template_configuration(self) -> 'outputs.FlowPromptTemplateConfigurationProperties':
        return pulumi.get(self, "template_configuration")

    @_builtins.property
    @pulumi.getter(name="templateType")
    def template_type(self) -> 'FlowPromptTemplateType':
        return pulumi.get(self, "template_type")

    @_builtins.property
    @pulumi.getter(name="inferenceConfiguration")
    def inference_configuration(self) -> Optional['outputs.FlowPromptInferenceConfigurationProperties']:
        return pulumi.get(self, "inference_configuration")


@pulumi.output_type
class FlowPromptFlowNodeResourceConfiguration(dict):
    """
    Resource prompt configuration for prompt node
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "promptArn":
            suggest = "prompt_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowPromptFlowNodeResourceConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowPromptFlowNodeResourceConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowPromptFlowNodeResourceConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prompt_arn: _builtins.str):
        """
        Resource prompt configuration for prompt node
        :param _builtins.str prompt_arn: ARN of a prompt resource possibly with a version
        """
        pulumi.set(__self__, "prompt_arn", prompt_arn)

    @_builtins.property
    @pulumi.getter(name="promptArn")
    def prompt_arn(self) -> _builtins.str:
        """
        ARN of a prompt resource possibly with a version
        """
        return pulumi.get(self, "prompt_arn")


@pulumi.output_type
class FlowPromptFlowNodeSourceConfiguration0Properties(dict):
    """
    Prompt source configuration for prompt node
    """
    def __init__(__self__, *,
                 resource: 'outputs.FlowPromptFlowNodeResourceConfiguration'):
        """
        Prompt source configuration for prompt node
        """
        pulumi.set(__self__, "resource", resource)

    @_builtins.property
    @pulumi.getter
    def resource(self) -> 'outputs.FlowPromptFlowNodeResourceConfiguration':
        return pulumi.get(self, "resource")


@pulumi.output_type
class FlowPromptFlowNodeSourceConfiguration1Properties(dict):
    """
    Prompt source configuration for prompt node
    """
    def __init__(__self__, *,
                 inline: 'outputs.FlowPromptFlowNodeInlineConfiguration'):
        """
        Prompt source configuration for prompt node
        """
        pulumi.set(__self__, "inline", inline)

    @_builtins.property
    @pulumi.getter
    def inline(self) -> 'outputs.FlowPromptFlowNodeInlineConfiguration':
        return pulumi.get(self, "inline")


@pulumi.output_type
class FlowPromptInferenceConfigurationProperties(dict):
    """
    Model inference configuration
    """
    def __init__(__self__, *,
                 text: 'outputs.FlowPromptModelInferenceConfiguration'):
        """
        Model inference configuration
        """
        pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def text(self) -> 'outputs.FlowPromptModelInferenceConfiguration':
        return pulumi.get(self, "text")


@pulumi.output_type
class FlowPromptInputVariable(dict):
    """
    Input variable
    """
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        Input variable
        :param _builtins.str name: Name for an input variable
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name for an input variable
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class FlowPromptModelInferenceConfiguration(dict):
    """
    Prompt model inference configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxTokens":
            suggest = "max_tokens"
        elif key == "stopSequences":
            suggest = "stop_sequences"
        elif key == "topP":
            suggest = "top_p"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowPromptModelInferenceConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowPromptModelInferenceConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowPromptModelInferenceConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_tokens: Optional[_builtins.float] = None,
                 stop_sequences: Optional[Sequence[_builtins.str]] = None,
                 temperature: Optional[_builtins.float] = None,
                 top_p: Optional[_builtins.float] = None):
        """
        Prompt model inference configuration
        :param _builtins.float max_tokens: Maximum length of output
        :param Sequence[_builtins.str] stop_sequences: List of stop sequences
        :param _builtins.float temperature: Controls randomness, higher values increase diversity
        :param _builtins.float top_p: Cumulative probability cutoff for token selection
        """
        if max_tokens is not None:
            pulumi.set(__self__, "max_tokens", max_tokens)
        if stop_sequences is not None:
            pulumi.set(__self__, "stop_sequences", stop_sequences)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)
        if top_p is not None:
            pulumi.set(__self__, "top_p", top_p)

    @_builtins.property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> Optional[_builtins.float]:
        """
        Maximum length of output
        """
        return pulumi.get(self, "max_tokens")

    @_builtins.property
    @pulumi.getter(name="stopSequences")
    def stop_sequences(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of stop sequences
        """
        return pulumi.get(self, "stop_sequences")

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[_builtins.float]:
        """
        Controls randomness, higher values increase diversity
        """
        return pulumi.get(self, "temperature")

    @_builtins.property
    @pulumi.getter(name="topP")
    def top_p(self) -> Optional[_builtins.float]:
        """
        Cumulative probability cutoff for token selection
        """
        return pulumi.get(self, "top_p")


@pulumi.output_type
class FlowPromptTemplateConfigurationProperties(dict):
    """
    Prompt template configuration
    """
    def __init__(__self__, *,
                 text: 'outputs.FlowTextPromptTemplateConfiguration'):
        """
        Prompt template configuration
        """
        pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def text(self) -> 'outputs.FlowTextPromptTemplateConfiguration':
        return pulumi.get(self, "text")


@pulumi.output_type
class FlowRerankingMetadataSelectiveModeConfiguration0Properties(dict):
    """
    Reranking Metadata Selective Mode Configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldsToInclude":
            suggest = "fields_to_include"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowRerankingMetadataSelectiveModeConfiguration0Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowRerankingMetadataSelectiveModeConfiguration0Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowRerankingMetadataSelectiveModeConfiguration0Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fields_to_include: Sequence['outputs.FlowFieldForReranking']):
        """
        Reranking Metadata Selective Mode Configuration
        """
        pulumi.set(__self__, "fields_to_include", fields_to_include)

    @_builtins.property
    @pulumi.getter(name="fieldsToInclude")
    def fields_to_include(self) -> Sequence['outputs.FlowFieldForReranking']:
        return pulumi.get(self, "fields_to_include")


@pulumi.output_type
class FlowRerankingMetadataSelectiveModeConfiguration1Properties(dict):
    """
    Reranking Metadata Selective Mode Configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldsToExclude":
            suggest = "fields_to_exclude"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowRerankingMetadataSelectiveModeConfiguration1Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowRerankingMetadataSelectiveModeConfiguration1Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowRerankingMetadataSelectiveModeConfiguration1Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fields_to_exclude: Sequence['outputs.FlowFieldForReranking']):
        """
        Reranking Metadata Selective Mode Configuration
        """
        pulumi.set(__self__, "fields_to_exclude", fields_to_exclude)

    @_builtins.property
    @pulumi.getter(name="fieldsToExclude")
    def fields_to_exclude(self) -> Sequence['outputs.FlowFieldForReranking']:
        return pulumi.get(self, "fields_to_exclude")


@pulumi.output_type
class FlowRetrievalFlowNodeConfiguration(dict):
    """
    Retrieval flow node configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceConfiguration":
            suggest = "service_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowRetrievalFlowNodeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowRetrievalFlowNodeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowRetrievalFlowNodeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_configuration: 'outputs.FlowRetrievalFlowNodeServiceConfigurationProperties'):
        """
        Retrieval flow node configuration
        """
        pulumi.set(__self__, "service_configuration", service_configuration)

    @_builtins.property
    @pulumi.getter(name="serviceConfiguration")
    def service_configuration(self) -> 'outputs.FlowRetrievalFlowNodeServiceConfigurationProperties':
        return pulumi.get(self, "service_configuration")


@pulumi.output_type
class FlowRetrievalFlowNodeS3Configuration(dict):
    """
    s3 Retrieval configuration for Retrieval node
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowRetrievalFlowNodeS3Configuration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowRetrievalFlowNodeS3Configuration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowRetrievalFlowNodeS3Configuration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: _builtins.str):
        """
        s3 Retrieval configuration for Retrieval node
        :param _builtins.str bucket_name: bucket name of an s3 that will be used for Retrieval flow node configuration
        """
        pulumi.set(__self__, "bucket_name", bucket_name)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> _builtins.str:
        """
        bucket name of an s3 that will be used for Retrieval flow node configuration
        """
        return pulumi.get(self, "bucket_name")


@pulumi.output_type
class FlowRetrievalFlowNodeServiceConfigurationProperties(dict):
    """
    Retrieval service configuration for Retrieval node
    """
    def __init__(__self__, *,
                 s3: Optional['outputs.FlowRetrievalFlowNodeS3Configuration'] = None):
        """
        Retrieval service configuration for Retrieval node
        """
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional['outputs.FlowRetrievalFlowNodeS3Configuration']:
        return pulumi.get(self, "s3")


@pulumi.output_type
class FlowS3Location(dict):
    """
    A bucket, key and optional version pointing to an S3 object containing a UTF-8 encoded JSON string Definition with the same schema as the Definition property of this resource
    """
    def __init__(__self__, *,
                 bucket: _builtins.str,
                 key: _builtins.str,
                 version: Optional[_builtins.str] = None):
        """
        A bucket, key and optional version pointing to an S3 object containing a UTF-8 encoded JSON string Definition with the same schema as the Definition property of this resource
        :param _builtins.str bucket: A bucket in S3
        :param _builtins.str key: A object key in S3
        :param _builtins.str version: The version of the the S3 object to use
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "key", key)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        A bucket in S3
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        A object key in S3
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        The version of the the S3 object to use
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class FlowStorageFlowNodeConfiguration(dict):
    """
    Storage flow node configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceConfiguration":
            suggest = "service_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowStorageFlowNodeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowStorageFlowNodeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowStorageFlowNodeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_configuration: 'outputs.FlowStorageFlowNodeServiceConfigurationProperties'):
        """
        Storage flow node configuration
        """
        pulumi.set(__self__, "service_configuration", service_configuration)

    @_builtins.property
    @pulumi.getter(name="serviceConfiguration")
    def service_configuration(self) -> 'outputs.FlowStorageFlowNodeServiceConfigurationProperties':
        return pulumi.get(self, "service_configuration")


@pulumi.output_type
class FlowStorageFlowNodeS3Configuration(dict):
    """
    s3 storage configuration for storage node
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowStorageFlowNodeS3Configuration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowStorageFlowNodeS3Configuration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowStorageFlowNodeS3Configuration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: _builtins.str):
        """
        s3 storage configuration for storage node
        :param _builtins.str bucket_name: bucket name of an s3 that will be used for storage flow node configuration
        """
        pulumi.set(__self__, "bucket_name", bucket_name)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> _builtins.str:
        """
        bucket name of an s3 that will be used for storage flow node configuration
        """
        return pulumi.get(self, "bucket_name")


@pulumi.output_type
class FlowStorageFlowNodeServiceConfigurationProperties(dict):
    """
    storage service configuration for storage node
    """
    def __init__(__self__, *,
                 s3: Optional['outputs.FlowStorageFlowNodeS3Configuration'] = None):
        """
        storage service configuration for storage node
        """
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional['outputs.FlowStorageFlowNodeS3Configuration']:
        return pulumi.get(self, "s3")


@pulumi.output_type
class FlowTextPromptTemplateConfiguration(dict):
    """
    Configuration for text prompt template
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputVariables":
            suggest = "input_variables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowTextPromptTemplateConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowTextPromptTemplateConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowTextPromptTemplateConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text: _builtins.str,
                 input_variables: Optional[Sequence['outputs.FlowPromptInputVariable']] = None):
        """
        Configuration for text prompt template
        :param _builtins.str text: Prompt content for String prompt template
        :param Sequence['FlowPromptInputVariable'] input_variables: List of input variables
        """
        pulumi.set(__self__, "text", text)
        if input_variables is not None:
            pulumi.set(__self__, "input_variables", input_variables)

    @_builtins.property
    @pulumi.getter
    def text(self) -> _builtins.str:
        """
        Prompt content for String prompt template
        """
        return pulumi.get(self, "text")

    @_builtins.property
    @pulumi.getter(name="inputVariables")
    def input_variables(self) -> Optional[Sequence['outputs.FlowPromptInputVariable']]:
        """
        List of input variables
        """
        return pulumi.get(self, "input_variables")


@pulumi.output_type
class FlowValidation(dict):
    """
    Validation for Flow
    """
    def __init__(__self__, *,
                 message: _builtins.str):
        """
        Validation for Flow
        :param _builtins.str message: validation message
        """
        pulumi.set(__self__, "message", message)

    @_builtins.property
    @pulumi.getter
    def message(self) -> _builtins.str:
        """
        validation message
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class FlowVectorSearchBedrockRerankingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "modelConfiguration":
            suggest = "model_configuration"
        elif key == "metadataConfiguration":
            suggest = "metadata_configuration"
        elif key == "numberOfRerankedResults":
            suggest = "number_of_reranked_results"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowVectorSearchBedrockRerankingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowVectorSearchBedrockRerankingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowVectorSearchBedrockRerankingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 model_configuration: 'outputs.FlowVectorSearchBedrockRerankingModelConfiguration',
                 metadata_configuration: Optional['outputs.FlowMetadataConfigurationForReranking'] = None,
                 number_of_reranked_results: Optional[_builtins.float] = None):
        """
        :param _builtins.float number_of_reranked_results: Number Of Results For Reranking
        """
        pulumi.set(__self__, "model_configuration", model_configuration)
        if metadata_configuration is not None:
            pulumi.set(__self__, "metadata_configuration", metadata_configuration)
        if number_of_reranked_results is not None:
            pulumi.set(__self__, "number_of_reranked_results", number_of_reranked_results)

    @_builtins.property
    @pulumi.getter(name="modelConfiguration")
    def model_configuration(self) -> 'outputs.FlowVectorSearchBedrockRerankingModelConfiguration':
        return pulumi.get(self, "model_configuration")

    @_builtins.property
    @pulumi.getter(name="metadataConfiguration")
    def metadata_configuration(self) -> Optional['outputs.FlowMetadataConfigurationForReranking']:
        return pulumi.get(self, "metadata_configuration")

    @_builtins.property
    @pulumi.getter(name="numberOfRerankedResults")
    def number_of_reranked_results(self) -> Optional[_builtins.float]:
        """
        Number Of Results For Reranking
        """
        return pulumi.get(self, "number_of_reranked_results")


@pulumi.output_type
class FlowVectorSearchBedrockRerankingModelConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "modelArn":
            suggest = "model_arn"
        elif key == "additionalModelRequestFields":
            suggest = "additional_model_request_fields"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowVectorSearchBedrockRerankingModelConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowVectorSearchBedrockRerankingModelConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowVectorSearchBedrockRerankingModelConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 model_arn: _builtins.str,
                 additional_model_request_fields: Optional['outputs.FlowAdditionalModelRequestFields'] = None):
        pulumi.set(__self__, "model_arn", model_arn)
        if additional_model_request_fields is not None:
            pulumi.set(__self__, "additional_model_request_fields", additional_model_request_fields)

    @_builtins.property
    @pulumi.getter(name="modelArn")
    def model_arn(self) -> _builtins.str:
        return pulumi.get(self, "model_arn")

    @_builtins.property
    @pulumi.getter(name="additionalModelRequestFields")
    def additional_model_request_fields(self) -> Optional['outputs.FlowAdditionalModelRequestFields']:
        return pulumi.get(self, "additional_model_request_fields")


@pulumi.output_type
class FlowVectorSearchRerankingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bedrockRerankingConfiguration":
            suggest = "bedrock_reranking_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowVectorSearchRerankingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowVectorSearchRerankingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowVectorSearchRerankingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: 'FlowVectorSearchRerankingConfigurationType',
                 bedrock_reranking_configuration: Optional['outputs.FlowVectorSearchBedrockRerankingConfiguration'] = None):
        pulumi.set(__self__, "type", type)
        if bedrock_reranking_configuration is not None:
            pulumi.set(__self__, "bedrock_reranking_configuration", bedrock_reranking_configuration)

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'FlowVectorSearchRerankingConfigurationType':
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="bedrockRerankingConfiguration")
    def bedrock_reranking_configuration(self) -> Optional['outputs.FlowVectorSearchBedrockRerankingConfiguration']:
        return pulumi.get(self, "bedrock_reranking_configuration")


@pulumi.output_type
class FlowVersionAdditionalModelRequestFields(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class FlowVersionAgentFlowNodeConfiguration(dict):
    """
    Agent flow node configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "agentAliasArn":
            suggest = "agent_alias_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowVersionAgentFlowNodeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowVersionAgentFlowNodeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowVersionAgentFlowNodeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 agent_alias_arn: _builtins.str):
        """
        Agent flow node configuration
        :param _builtins.str agent_alias_arn: Arn representation of the Agent Alias.
        """
        pulumi.set(__self__, "agent_alias_arn", agent_alias_arn)

    @_builtins.property
    @pulumi.getter(name="agentAliasArn")
    def agent_alias_arn(self) -> _builtins.str:
        """
        Arn representation of the Agent Alias.
        """
        return pulumi.get(self, "agent_alias_arn")


@pulumi.output_type
class FlowVersionCollectorFlowNodeConfiguration(dict):
    """
    Collector flow node configuration
    """
    def __init__(__self__):
        """
        Collector flow node configuration
        """
        pass


@pulumi.output_type
class FlowVersionConditionFlowNodeConfiguration(dict):
    """
    Condition flow node configuration
    """
    def __init__(__self__, *,
                 conditions: Sequence['outputs.FlowVersionFlowCondition']):
        """
        Condition flow node configuration
        :param Sequence['FlowVersionFlowCondition'] conditions: List of conditions in a condition node
        """
        pulumi.set(__self__, "conditions", conditions)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.FlowVersionFlowCondition']:
        """
        List of conditions in a condition node
        """
        return pulumi.get(self, "conditions")


@pulumi.output_type
class FlowVersionFieldForReranking(dict):
    """
    Field name for reranking
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowVersionFieldForReranking. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowVersionFieldForReranking.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowVersionFieldForReranking.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_name: _builtins.str):
        """
        Field name for reranking
        :param _builtins.str field_name: Field name for reranking
        """
        pulumi.set(__self__, "field_name", field_name)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> _builtins.str:
        """
        Field name for reranking
        """
        return pulumi.get(self, "field_name")


@pulumi.output_type
class FlowVersionFlowCondition(dict):
    """
    Condition branch for a condition node
    """
    def __init__(__self__, *,
                 name: _builtins.str,
                 expression: Optional[_builtins.str] = None):
        """
        Condition branch for a condition node
        :param _builtins.str name: Name of a condition in a flow
        :param _builtins.str expression: Expression for a condition in a flow
        """
        pulumi.set(__self__, "name", name)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of a condition in a flow
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def expression(self) -> Optional[_builtins.str]:
        """
        Expression for a condition in a flow
        """
        return pulumi.get(self, "expression")


@pulumi.output_type
class FlowVersionFlowConditionalConnectionConfiguration(dict):
    """
    Conditional connection configuration
    """
    def __init__(__self__, *,
                 condition: _builtins.str):
        """
        Conditional connection configuration
        :param _builtins.str condition: Name of a condition in a flow
        """
        pulumi.set(__self__, "condition", condition)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> _builtins.str:
        """
        Name of a condition in a flow
        """
        return pulumi.get(self, "condition")


@pulumi.output_type
class FlowVersionFlowConnection(dict):
    """
    Flow connection
    """
    def __init__(__self__, *,
                 name: _builtins.str,
                 source: _builtins.str,
                 target: _builtins.str,
                 type: 'FlowVersionFlowConnectionType',
                 configuration: Optional[Any] = None):
        """
        Flow connection
        :param _builtins.str name: Name of a connection in a flow
        :param _builtins.str source: Name of a node in a flow
        :param _builtins.str target: Name of a node in a flow
        :param 'FlowVersionFlowConnectionType' type: Whether the source node that the connection begins from is a condition node ( `Conditional` ) or not ( `Data` ).
        :param Union['FlowVersionFlowConnectionConfiguration0Properties', 'FlowVersionFlowConnectionConfiguration1Properties'] configuration: The configuration of the connection.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "type", type)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of a connection in a flow
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        """
        Name of a node in a flow
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.str:
        """
        Name of a node in a flow
        """
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'FlowVersionFlowConnectionType':
        """
        Whether the source node that the connection begins from is a condition node ( `Conditional` ) or not ( `Data` ).
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> Optional[Any]:
        """
        The configuration of the connection.
        """
        return pulumi.get(self, "configuration")


@pulumi.output_type
class FlowVersionFlowConnectionConfiguration0Properties(dict):
    """
    Connection configuration
    """
    def __init__(__self__, *,
                 data: 'outputs.FlowVersionFlowDataConnectionConfiguration'):
        """
        Connection configuration
        """
        pulumi.set(__self__, "data", data)

    @_builtins.property
    @pulumi.getter
    def data(self) -> 'outputs.FlowVersionFlowDataConnectionConfiguration':
        return pulumi.get(self, "data")


@pulumi.output_type
class FlowVersionFlowConnectionConfiguration1Properties(dict):
    """
    Connection configuration
    """
    def __init__(__self__, *,
                 conditional: 'outputs.FlowVersionFlowConditionalConnectionConfiguration'):
        """
        Connection configuration
        """
        pulumi.set(__self__, "conditional", conditional)

    @_builtins.property
    @pulumi.getter
    def conditional(self) -> 'outputs.FlowVersionFlowConditionalConnectionConfiguration':
        return pulumi.get(self, "conditional")


@pulumi.output_type
class FlowVersionFlowDataConnectionConfiguration(dict):
    """
    Data connection configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceOutput":
            suggest = "source_output"
        elif key == "targetInput":
            suggest = "target_input"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowVersionFlowDataConnectionConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowVersionFlowDataConnectionConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowVersionFlowDataConnectionConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_output: _builtins.str,
                 target_input: _builtins.str):
        """
        Data connection configuration
        :param _builtins.str source_output: Name of a node output in a flow
        :param _builtins.str target_input: Name of a node input in a flow
        """
        pulumi.set(__self__, "source_output", source_output)
        pulumi.set(__self__, "target_input", target_input)

    @_builtins.property
    @pulumi.getter(name="sourceOutput")
    def source_output(self) -> _builtins.str:
        """
        Name of a node output in a flow
        """
        return pulumi.get(self, "source_output")

    @_builtins.property
    @pulumi.getter(name="targetInput")
    def target_input(self) -> _builtins.str:
        """
        Name of a node input in a flow
        """
        return pulumi.get(self, "target_input")


@pulumi.output_type
class FlowVersionFlowDefinition(dict):
    """
    Flow definition
    """
    def __init__(__self__, *,
                 connections: Optional[Sequence['outputs.FlowVersionFlowConnection']] = None,
                 nodes: Optional[Sequence['outputs.FlowVersionFlowNode']] = None):
        """
        Flow definition
        :param Sequence['FlowVersionFlowConnection'] connections: List of connections
        :param Sequence['FlowVersionFlowNode'] nodes: List of nodes in a flow
        """
        if connections is not None:
            pulumi.set(__self__, "connections", connections)
        if nodes is not None:
            pulumi.set(__self__, "nodes", nodes)

    @_builtins.property
    @pulumi.getter
    def connections(self) -> Optional[Sequence['outputs.FlowVersionFlowConnection']]:
        """
        List of connections
        """
        return pulumi.get(self, "connections")

    @_builtins.property
    @pulumi.getter
    def nodes(self) -> Optional[Sequence['outputs.FlowVersionFlowNode']]:
        """
        List of nodes in a flow
        """
        return pulumi.get(self, "nodes")


@pulumi.output_type
class FlowVersionFlowNode(dict):
    """
    Internal mixin for flow node
    """
    def __init__(__self__, *,
                 name: _builtins.str,
                 type: 'FlowVersionFlowNodeType',
                 configuration: Optional[Any] = None,
                 inputs: Optional[Sequence['outputs.FlowVersionFlowNodeInput']] = None,
                 outputs: Optional[Sequence['outputs.FlowVersionFlowNodeOutput']] = None):
        """
        Internal mixin for flow node
        :param _builtins.str name: Name of a node in a flow
        :param 'FlowVersionFlowNodeType' type: The type of node. This value must match the name of the key that you provide in the configuration you provide in the `FlowNodeConfiguration` field.
        :param Union['FlowVersionFlowNodeConfiguration0Properties', 'FlowVersionFlowNodeConfiguration1Properties', 'FlowVersionFlowNodeConfiguration2Properties', 'FlowVersionFlowNodeConfiguration3Properties', 'FlowVersionFlowNodeConfiguration4Properties', 'FlowVersionFlowNodeConfiguration5Properties', 'FlowVersionFlowNodeConfiguration6Properties', 'FlowVersionFlowNodeConfiguration7Properties', 'FlowVersionFlowNodeConfiguration8Properties', 'FlowVersionFlowNodeConfiguration9Properties', 'FlowVersionFlowNodeConfiguration10Properties', 'FlowVersionFlowNodeConfiguration11Properties', 'FlowVersionFlowNodeConfiguration12Properties', 'FlowVersionFlowNodeConfiguration13Properties', 'FlowVersionFlowNodeConfiguration14Properties', 'FlowVersionFlowNodeConfiguration15Properties'] configuration: Contains configurations for the node.
        :param Sequence['FlowVersionFlowNodeInput'] inputs: List of node inputs in a flow
        :param Sequence['FlowVersionFlowNodeOutput'] outputs: List of node outputs in a flow
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if configuration is not None:
            pulumi.set(__self__, "configuration", configuration)
        if inputs is not None:
            pulumi.set(__self__, "inputs", inputs)
        if outputs is not None:
            pulumi.set(__self__, "outputs", outputs)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of a node in a flow
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'FlowVersionFlowNodeType':
        """
        The type of node. This value must match the name of the key that you provide in the configuration you provide in the `FlowNodeConfiguration` field.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def configuration(self) -> Optional[Any]:
        """
        Contains configurations for the node.
        """
        return pulumi.get(self, "configuration")

    @_builtins.property
    @pulumi.getter
    def inputs(self) -> Optional[Sequence['outputs.FlowVersionFlowNodeInput']]:
        """
        List of node inputs in a flow
        """
        return pulumi.get(self, "inputs")

    @_builtins.property
    @pulumi.getter
    def outputs(self) -> Optional[Sequence['outputs.FlowVersionFlowNodeOutput']]:
        """
        List of node outputs in a flow
        """
        return pulumi.get(self, "outputs")


@pulumi.output_type
class FlowVersionFlowNodeConfiguration0Properties(dict):
    """
    Node configuration in a flow
    """
    def __init__(__self__, *,
                 input: 'outputs.FlowVersionInputFlowNodeConfiguration'):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "input", input)

    @_builtins.property
    @pulumi.getter
    def input(self) -> 'outputs.FlowVersionInputFlowNodeConfiguration':
        return pulumi.get(self, "input")


@pulumi.output_type
class FlowVersionFlowNodeConfiguration10Properties(dict):
    """
    Node configuration in a flow
    """
    def __init__(__self__, *,
                 iterator: 'outputs.FlowVersionIteratorFlowNodeConfiguration'):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "iterator", iterator)

    @_builtins.property
    @pulumi.getter
    def iterator(self) -> 'outputs.FlowVersionIteratorFlowNodeConfiguration':
        return pulumi.get(self, "iterator")


@pulumi.output_type
class FlowVersionFlowNodeConfiguration11Properties(dict):
    """
    Node configuration in a flow
    """
    def __init__(__self__, *,
                 collector: 'outputs.FlowVersionCollectorFlowNodeConfiguration'):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "collector", collector)

    @_builtins.property
    @pulumi.getter
    def collector(self) -> 'outputs.FlowVersionCollectorFlowNodeConfiguration':
        return pulumi.get(self, "collector")


@pulumi.output_type
class FlowVersionFlowNodeConfiguration12Properties(dict):
    """
    Node configuration in a flow
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inlineCode":
            suggest = "inline_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowVersionFlowNodeConfiguration12Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowVersionFlowNodeConfiguration12Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowVersionFlowNodeConfiguration12Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inline_code: 'outputs.FlowVersionInlineCodeFlowNodeConfiguration'):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "inline_code", inline_code)

    @_builtins.property
    @pulumi.getter(name="inlineCode")
    def inline_code(self) -> 'outputs.FlowVersionInlineCodeFlowNodeConfiguration':
        return pulumi.get(self, "inline_code")


@pulumi.output_type
class FlowVersionFlowNodeConfiguration13Properties(dict):
    """
    Node configuration in a flow
    """
    def __init__(__self__, *,
                 loop: 'outputs.FlowVersionLoopFlowNodeConfiguration'):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "loop", loop)

    @_builtins.property
    @pulumi.getter
    def loop(self) -> 'outputs.FlowVersionLoopFlowNodeConfiguration':
        return pulumi.get(self, "loop")


@pulumi.output_type
class FlowVersionFlowNodeConfiguration14Properties(dict):
    """
    Node configuration in a flow
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loopInput":
            suggest = "loop_input"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowVersionFlowNodeConfiguration14Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowVersionFlowNodeConfiguration14Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowVersionFlowNodeConfiguration14Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 loop_input: 'outputs.FlowVersionLoopInputFlowNodeConfiguration'):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "loop_input", loop_input)

    @_builtins.property
    @pulumi.getter(name="loopInput")
    def loop_input(self) -> 'outputs.FlowVersionLoopInputFlowNodeConfiguration':
        return pulumi.get(self, "loop_input")


@pulumi.output_type
class FlowVersionFlowNodeConfiguration15Properties(dict):
    """
    Node configuration in a flow
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loopController":
            suggest = "loop_controller"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowVersionFlowNodeConfiguration15Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowVersionFlowNodeConfiguration15Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowVersionFlowNodeConfiguration15Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 loop_controller: 'outputs.FlowVersionLoopControllerFlowNodeConfiguration'):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "loop_controller", loop_controller)

    @_builtins.property
    @pulumi.getter(name="loopController")
    def loop_controller(self) -> 'outputs.FlowVersionLoopControllerFlowNodeConfiguration':
        return pulumi.get(self, "loop_controller")


@pulumi.output_type
class FlowVersionFlowNodeConfiguration1Properties(dict):
    """
    Node configuration in a flow
    """
    def __init__(__self__, *,
                 output: 'outputs.FlowVersionOutputFlowNodeConfiguration'):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "output", output)

    @_builtins.property
    @pulumi.getter
    def output(self) -> 'outputs.FlowVersionOutputFlowNodeConfiguration':
        return pulumi.get(self, "output")


@pulumi.output_type
class FlowVersionFlowNodeConfiguration2Properties(dict):
    """
    Node configuration in a flow
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "knowledgeBase":
            suggest = "knowledge_base"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowVersionFlowNodeConfiguration2Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowVersionFlowNodeConfiguration2Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowVersionFlowNodeConfiguration2Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 knowledge_base: 'outputs.FlowVersionKnowledgeBaseFlowNodeConfiguration'):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "knowledge_base", knowledge_base)

    @_builtins.property
    @pulumi.getter(name="knowledgeBase")
    def knowledge_base(self) -> 'outputs.FlowVersionKnowledgeBaseFlowNodeConfiguration':
        return pulumi.get(self, "knowledge_base")


@pulumi.output_type
class FlowVersionFlowNodeConfiguration3Properties(dict):
    """
    Node configuration in a flow
    """
    def __init__(__self__, *,
                 condition: 'outputs.FlowVersionConditionFlowNodeConfiguration'):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "condition", condition)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> 'outputs.FlowVersionConditionFlowNodeConfiguration':
        return pulumi.get(self, "condition")


@pulumi.output_type
class FlowVersionFlowNodeConfiguration4Properties(dict):
    """
    Node configuration in a flow
    """
    def __init__(__self__, *,
                 lex: 'outputs.FlowVersionLexFlowNodeConfiguration'):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "lex", lex)

    @_builtins.property
    @pulumi.getter
    def lex(self) -> 'outputs.FlowVersionLexFlowNodeConfiguration':
        return pulumi.get(self, "lex")


@pulumi.output_type
class FlowVersionFlowNodeConfiguration5Properties(dict):
    """
    Node configuration in a flow
    """
    def __init__(__self__, *,
                 prompt: 'outputs.FlowVersionPromptFlowNodeConfiguration'):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "prompt", prompt)

    @_builtins.property
    @pulumi.getter
    def prompt(self) -> 'outputs.FlowVersionPromptFlowNodeConfiguration':
        return pulumi.get(self, "prompt")


@pulumi.output_type
class FlowVersionFlowNodeConfiguration6Properties(dict):
    """
    Node configuration in a flow
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lambdaFunction":
            suggest = "lambda_function"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowVersionFlowNodeConfiguration6Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowVersionFlowNodeConfiguration6Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowVersionFlowNodeConfiguration6Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lambda_function: 'outputs.FlowVersionLambdaFunctionFlowNodeConfiguration'):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "lambda_function", lambda_function)

    @_builtins.property
    @pulumi.getter(name="lambdaFunction")
    def lambda_function(self) -> 'outputs.FlowVersionLambdaFunctionFlowNodeConfiguration':
        return pulumi.get(self, "lambda_function")


@pulumi.output_type
class FlowVersionFlowNodeConfiguration7Properties(dict):
    """
    Node configuration in a flow
    """
    def __init__(__self__, *,
                 agent: 'outputs.FlowVersionAgentFlowNodeConfiguration'):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "agent", agent)

    @_builtins.property
    @pulumi.getter
    def agent(self) -> 'outputs.FlowVersionAgentFlowNodeConfiguration':
        return pulumi.get(self, "agent")


@pulumi.output_type
class FlowVersionFlowNodeConfiguration8Properties(dict):
    """
    Node configuration in a flow
    """
    def __init__(__self__, *,
                 storage: 'outputs.FlowVersionStorageFlowNodeConfiguration'):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "storage", storage)

    @_builtins.property
    @pulumi.getter
    def storage(self) -> 'outputs.FlowVersionStorageFlowNodeConfiguration':
        return pulumi.get(self, "storage")


@pulumi.output_type
class FlowVersionFlowNodeConfiguration9Properties(dict):
    """
    Node configuration in a flow
    """
    def __init__(__self__, *,
                 retrieval: 'outputs.FlowVersionRetrievalFlowNodeConfiguration'):
        """
        Node configuration in a flow
        """
        pulumi.set(__self__, "retrieval", retrieval)

    @_builtins.property
    @pulumi.getter
    def retrieval(self) -> 'outputs.FlowVersionRetrievalFlowNodeConfiguration':
        return pulumi.get(self, "retrieval")


@pulumi.output_type
class FlowVersionFlowNodeInput(dict):
    """
    Input to a node in a flow
    """
    def __init__(__self__, *,
                 expression: _builtins.str,
                 name: _builtins.str,
                 type: 'FlowVersionFlowNodeIoDataType'):
        """
        Input to a node in a flow
        :param _builtins.str expression: Expression for a node input in a flow
        :param _builtins.str name: Name of a node input in a flow
        :param 'FlowVersionFlowNodeIoDataType' type: Specifies the data type of the input. If the input doesn't match this type at runtime, a validation error will be thrown.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        Expression for a node input in a flow
        """
        return pulumi.get(self, "expression")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of a node input in a flow
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'FlowVersionFlowNodeIoDataType':
        """
        Specifies the data type of the input. If the input doesn't match this type at runtime, a validation error will be thrown.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class FlowVersionFlowNodeOutput(dict):
    """
    Output of a node in a flow
    """
    def __init__(__self__, *,
                 name: _builtins.str,
                 type: 'FlowVersionFlowNodeIoDataType'):
        """
        Output of a node in a flow
        :param _builtins.str name: Name of a node output in a flow
        :param 'FlowVersionFlowNodeIoDataType' type: The data type of the output. If the output doesn't match this type at runtime, a validation error will be thrown.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of a node output in a flow
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'FlowVersionFlowNodeIoDataType':
        """
        The data type of the output. If the output doesn't match this type at runtime, a validation error will be thrown.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class FlowVersionGuardrailConfiguration(dict):
    """
    Configuration for a guardrail
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "guardrailIdentifier":
            suggest = "guardrail_identifier"
        elif key == "guardrailVersion":
            suggest = "guardrail_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowVersionGuardrailConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowVersionGuardrailConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowVersionGuardrailConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 guardrail_identifier: Optional[_builtins.str] = None,
                 guardrail_version: Optional[_builtins.str] = None):
        """
        Configuration for a guardrail
        :param _builtins.str guardrail_identifier: Identifier for the guardrail, could be the id or the arn
        :param _builtins.str guardrail_version: Version of the guardrail
        """
        if guardrail_identifier is not None:
            pulumi.set(__self__, "guardrail_identifier", guardrail_identifier)
        if guardrail_version is not None:
            pulumi.set(__self__, "guardrail_version", guardrail_version)

    @_builtins.property
    @pulumi.getter(name="guardrailIdentifier")
    def guardrail_identifier(self) -> Optional[_builtins.str]:
        """
        Identifier for the guardrail, could be the id or the arn
        """
        return pulumi.get(self, "guardrail_identifier")

    @_builtins.property
    @pulumi.getter(name="guardrailVersion")
    def guardrail_version(self) -> Optional[_builtins.str]:
        """
        Version of the guardrail
        """
        return pulumi.get(self, "guardrail_version")


@pulumi.output_type
class FlowVersionInlineCodeFlowNodeConfiguration(dict):
    """
    Inline code config strucuture, contains code configs
    """
    def __init__(__self__, *,
                 code: _builtins.str,
                 language: 'FlowVersionSupportedLanguages'):
        """
        Inline code config strucuture, contains code configs
        :param _builtins.str code: The inline code entered by customers. max size is 5MB.
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "language", language)

    @_builtins.property
    @pulumi.getter
    def code(self) -> _builtins.str:
        """
        The inline code entered by customers. max size is 5MB.
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def language(self) -> 'FlowVersionSupportedLanguages':
        return pulumi.get(self, "language")


@pulumi.output_type
class FlowVersionInputFlowNodeConfiguration(dict):
    """
    Input flow node configuration
    """
    def __init__(__self__):
        """
        Input flow node configuration
        """
        pass


@pulumi.output_type
class FlowVersionIteratorFlowNodeConfiguration(dict):
    """
    Iterator flow node configuration
    """
    def __init__(__self__):
        """
        Iterator flow node configuration
        """
        pass


@pulumi.output_type
class FlowVersionKnowledgeBaseFlowNodeConfiguration(dict):
    """
    Knowledge base flow node configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "knowledgeBaseId":
            suggest = "knowledge_base_id"
        elif key == "guardrailConfiguration":
            suggest = "guardrail_configuration"
        elif key == "inferenceConfiguration":
            suggest = "inference_configuration"
        elif key == "modelId":
            suggest = "model_id"
        elif key == "numberOfResults":
            suggest = "number_of_results"
        elif key == "orchestrationConfiguration":
            suggest = "orchestration_configuration"
        elif key == "promptTemplate":
            suggest = "prompt_template"
        elif key == "rerankingConfiguration":
            suggest = "reranking_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowVersionKnowledgeBaseFlowNodeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowVersionKnowledgeBaseFlowNodeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowVersionKnowledgeBaseFlowNodeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 knowledge_base_id: _builtins.str,
                 guardrail_configuration: Optional['outputs.FlowVersionGuardrailConfiguration'] = None,
                 inference_configuration: Optional['outputs.FlowVersionPromptInferenceConfigurationProperties'] = None,
                 model_id: Optional[_builtins.str] = None,
                 number_of_results: Optional[_builtins.float] = None,
                 orchestration_configuration: Optional['outputs.FlowVersionKnowledgeBaseOrchestrationConfiguration'] = None,
                 prompt_template: Optional['outputs.FlowVersionKnowledgeBasePromptTemplateProperties'] = None,
                 reranking_configuration: Optional['outputs.FlowVersionVectorSearchRerankingConfiguration'] = None):
        """
        Knowledge base flow node configuration
        :param _builtins.str knowledge_base_id: Identifier of the KnowledgeBase
        :param _builtins.str model_id: ARN or Id of a Bedrock Foundational Model or Inference Profile, or the ARN of a imported model, or a provisioned throughput ARN for custom models.
        :param _builtins.float number_of_results: Number Of Results to Retrieve
        """
        pulumi.set(__self__, "knowledge_base_id", knowledge_base_id)
        if guardrail_configuration is not None:
            pulumi.set(__self__, "guardrail_configuration", guardrail_configuration)
        if inference_configuration is not None:
            pulumi.set(__self__, "inference_configuration", inference_configuration)
        if model_id is not None:
            pulumi.set(__self__, "model_id", model_id)
        if number_of_results is not None:
            pulumi.set(__self__, "number_of_results", number_of_results)
        if orchestration_configuration is not None:
            pulumi.set(__self__, "orchestration_configuration", orchestration_configuration)
        if prompt_template is not None:
            pulumi.set(__self__, "prompt_template", prompt_template)
        if reranking_configuration is not None:
            pulumi.set(__self__, "reranking_configuration", reranking_configuration)

    @_builtins.property
    @pulumi.getter(name="knowledgeBaseId")
    def knowledge_base_id(self) -> _builtins.str:
        """
        Identifier of the KnowledgeBase
        """
        return pulumi.get(self, "knowledge_base_id")

    @_builtins.property
    @pulumi.getter(name="guardrailConfiguration")
    def guardrail_configuration(self) -> Optional['outputs.FlowVersionGuardrailConfiguration']:
        return pulumi.get(self, "guardrail_configuration")

    @_builtins.property
    @pulumi.getter(name="inferenceConfiguration")
    def inference_configuration(self) -> Optional['outputs.FlowVersionPromptInferenceConfigurationProperties']:
        return pulumi.get(self, "inference_configuration")

    @_builtins.property
    @pulumi.getter(name="modelId")
    def model_id(self) -> Optional[_builtins.str]:
        """
        ARN or Id of a Bedrock Foundational Model or Inference Profile, or the ARN of a imported model, or a provisioned throughput ARN for custom models.
        """
        return pulumi.get(self, "model_id")

    @_builtins.property
    @pulumi.getter(name="numberOfResults")
    def number_of_results(self) -> Optional[_builtins.float]:
        """
        Number Of Results to Retrieve
        """
        return pulumi.get(self, "number_of_results")

    @_builtins.property
    @pulumi.getter(name="orchestrationConfiguration")
    def orchestration_configuration(self) -> Optional['outputs.FlowVersionKnowledgeBaseOrchestrationConfiguration']:
        return pulumi.get(self, "orchestration_configuration")

    @_builtins.property
    @pulumi.getter(name="promptTemplate")
    def prompt_template(self) -> Optional['outputs.FlowVersionKnowledgeBasePromptTemplateProperties']:
        return pulumi.get(self, "prompt_template")

    @_builtins.property
    @pulumi.getter(name="rerankingConfiguration")
    def reranking_configuration(self) -> Optional['outputs.FlowVersionVectorSearchRerankingConfiguration']:
        return pulumi.get(self, "reranking_configuration")


@pulumi.output_type
class FlowVersionKnowledgeBaseOrchestrationConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalModelRequestFields":
            suggest = "additional_model_request_fields"
        elif key == "inferenceConfig":
            suggest = "inference_config"
        elif key == "performanceConfig":
            suggest = "performance_config"
        elif key == "promptTemplate":
            suggest = "prompt_template"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowVersionKnowledgeBaseOrchestrationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowVersionKnowledgeBaseOrchestrationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowVersionKnowledgeBaseOrchestrationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_model_request_fields: Optional['outputs.FlowVersionAdditionalModelRequestFields'] = None,
                 inference_config: Optional['outputs.FlowVersionPromptInferenceConfigurationProperties'] = None,
                 performance_config: Optional['outputs.FlowVersionPerformanceConfiguration'] = None,
                 prompt_template: Optional['outputs.FlowVersionKnowledgeBasePromptTemplateProperties'] = None):
        if additional_model_request_fields is not None:
            pulumi.set(__self__, "additional_model_request_fields", additional_model_request_fields)
        if inference_config is not None:
            pulumi.set(__self__, "inference_config", inference_config)
        if performance_config is not None:
            pulumi.set(__self__, "performance_config", performance_config)
        if prompt_template is not None:
            pulumi.set(__self__, "prompt_template", prompt_template)

    @_builtins.property
    @pulumi.getter(name="additionalModelRequestFields")
    def additional_model_request_fields(self) -> Optional['outputs.FlowVersionAdditionalModelRequestFields']:
        return pulumi.get(self, "additional_model_request_fields")

    @_builtins.property
    @pulumi.getter(name="inferenceConfig")
    def inference_config(self) -> Optional['outputs.FlowVersionPromptInferenceConfigurationProperties']:
        return pulumi.get(self, "inference_config")

    @_builtins.property
    @pulumi.getter(name="performanceConfig")
    def performance_config(self) -> Optional['outputs.FlowVersionPerformanceConfiguration']:
        return pulumi.get(self, "performance_config")

    @_builtins.property
    @pulumi.getter(name="promptTemplate")
    def prompt_template(self) -> Optional['outputs.FlowVersionKnowledgeBasePromptTemplateProperties']:
        return pulumi.get(self, "prompt_template")


@pulumi.output_type
class FlowVersionKnowledgeBasePromptTemplateProperties(dict):
    """
    Knowledge Base Prompt template
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textPromptTemplate":
            suggest = "text_prompt_template"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowVersionKnowledgeBasePromptTemplateProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowVersionKnowledgeBasePromptTemplateProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowVersionKnowledgeBasePromptTemplateProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text_prompt_template: _builtins.str):
        """
        Knowledge Base Prompt template
        """
        pulumi.set(__self__, "text_prompt_template", text_prompt_template)

    @_builtins.property
    @pulumi.getter(name="textPromptTemplate")
    def text_prompt_template(self) -> _builtins.str:
        return pulumi.get(self, "text_prompt_template")


@pulumi.output_type
class FlowVersionLambdaFunctionFlowNodeConfiguration(dict):
    """
    Lambda function flow node configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lambdaArn":
            suggest = "lambda_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowVersionLambdaFunctionFlowNodeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowVersionLambdaFunctionFlowNodeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowVersionLambdaFunctionFlowNodeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lambda_arn: _builtins.str):
        """
        Lambda function flow node configuration
        :param _builtins.str lambda_arn: ARN of a Lambda.
        """
        pulumi.set(__self__, "lambda_arn", lambda_arn)

    @_builtins.property
    @pulumi.getter(name="lambdaArn")
    def lambda_arn(self) -> _builtins.str:
        """
        ARN of a Lambda.
        """
        return pulumi.get(self, "lambda_arn")


@pulumi.output_type
class FlowVersionLexFlowNodeConfiguration(dict):
    """
    Lex flow node configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "botAliasArn":
            suggest = "bot_alias_arn"
        elif key == "localeId":
            suggest = "locale_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowVersionLexFlowNodeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowVersionLexFlowNodeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowVersionLexFlowNodeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bot_alias_arn: _builtins.str,
                 locale_id: _builtins.str):
        """
        Lex flow node configuration
        :param _builtins.str bot_alias_arn: ARN of a Lex bot alias
        :param _builtins.str locale_id: Lex bot locale id
        """
        pulumi.set(__self__, "bot_alias_arn", bot_alias_arn)
        pulumi.set(__self__, "locale_id", locale_id)

    @_builtins.property
    @pulumi.getter(name="botAliasArn")
    def bot_alias_arn(self) -> _builtins.str:
        """
        ARN of a Lex bot alias
        """
        return pulumi.get(self, "bot_alias_arn")

    @_builtins.property
    @pulumi.getter(name="localeId")
    def locale_id(self) -> _builtins.str:
        """
        Lex bot locale id
        """
        return pulumi.get(self, "locale_id")


@pulumi.output_type
class FlowVersionLoopControllerFlowNodeConfiguration(dict):
    """
    Configuration for the LoopController node, which manages loop execution
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "continueCondition":
            suggest = "continue_condition"
        elif key == "maxIterations":
            suggest = "max_iterations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowVersionLoopControllerFlowNodeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowVersionLoopControllerFlowNodeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowVersionLoopControllerFlowNodeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 continue_condition: 'outputs.FlowVersionFlowCondition',
                 max_iterations: Optional[_builtins.float] = None):
        """
        Configuration for the LoopController node, which manages loop execution
        :param _builtins.float max_iterations: Maximum number of iterations the loop can perform
        """
        pulumi.set(__self__, "continue_condition", continue_condition)
        if max_iterations is not None:
            pulumi.set(__self__, "max_iterations", max_iterations)

    @_builtins.property
    @pulumi.getter(name="continueCondition")
    def continue_condition(self) -> 'outputs.FlowVersionFlowCondition':
        return pulumi.get(self, "continue_condition")

    @_builtins.property
    @pulumi.getter(name="maxIterations")
    def max_iterations(self) -> Optional[_builtins.float]:
        """
        Maximum number of iterations the loop can perform
        """
        return pulumi.get(self, "max_iterations")


@pulumi.output_type
class FlowVersionLoopFlowNodeConfiguration(dict):
    """
    Loop node config, contains loop's internal definition
    """
    def __init__(__self__, *,
                 definition: 'outputs.FlowVersionFlowDefinition'):
        """
        Loop node config, contains loop's internal definition
        """
        pulumi.set(__self__, "definition", definition)

    @_builtins.property
    @pulumi.getter
    def definition(self) -> 'outputs.FlowVersionFlowDefinition':
        return pulumi.get(self, "definition")


@pulumi.output_type
class FlowVersionLoopInputFlowNodeConfiguration(dict):
    """
    Configuration for the LoopInput node
    """
    def __init__(__self__):
        """
        Configuration for the LoopInput node
        """
        pass


@pulumi.output_type
class FlowVersionMetadataConfigurationForReranking(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "selectionMode":
            suggest = "selection_mode"
        elif key == "selectiveModeConfiguration":
            suggest = "selective_mode_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowVersionMetadataConfigurationForReranking. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowVersionMetadataConfigurationForReranking.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowVersionMetadataConfigurationForReranking.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 selection_mode: 'FlowVersionRerankingMetadataSelectionMode',
                 selective_mode_configuration: Optional[Any] = None):
        pulumi.set(__self__, "selection_mode", selection_mode)
        if selective_mode_configuration is not None:
            pulumi.set(__self__, "selective_mode_configuration", selective_mode_configuration)

    @_builtins.property
    @pulumi.getter(name="selectionMode")
    def selection_mode(self) -> 'FlowVersionRerankingMetadataSelectionMode':
        return pulumi.get(self, "selection_mode")

    @_builtins.property
    @pulumi.getter(name="selectiveModeConfiguration")
    def selective_mode_configuration(self) -> Optional[Any]:
        return pulumi.get(self, "selective_mode_configuration")


@pulumi.output_type
class FlowVersionOutputFlowNodeConfiguration(dict):
    """
    Output flow node configuration
    """
    def __init__(__self__):
        """
        Output flow node configuration
        """
        pass


@pulumi.output_type
class FlowVersionPerformanceConfiguration(dict):
    def __init__(__self__, *,
                 latency: Optional['FlowVersionPerformanceConfigurationLatency'] = None):
        if latency is not None:
            pulumi.set(__self__, "latency", latency)

    @_builtins.property
    @pulumi.getter
    def latency(self) -> Optional['FlowVersionPerformanceConfigurationLatency']:
        return pulumi.get(self, "latency")


@pulumi.output_type
class FlowVersionPromptFlowNodeConfiguration(dict):
    """
    Prompt flow node configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceConfiguration":
            suggest = "source_configuration"
        elif key == "guardrailConfiguration":
            suggest = "guardrail_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowVersionPromptFlowNodeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowVersionPromptFlowNodeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowVersionPromptFlowNodeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_configuration: Any,
                 guardrail_configuration: Optional['outputs.FlowVersionGuardrailConfiguration'] = None):
        """
        Prompt flow node configuration
        """
        pulumi.set(__self__, "source_configuration", source_configuration)
        if guardrail_configuration is not None:
            pulumi.set(__self__, "guardrail_configuration", guardrail_configuration)

    @_builtins.property
    @pulumi.getter(name="sourceConfiguration")
    def source_configuration(self) -> Any:
        return pulumi.get(self, "source_configuration")

    @_builtins.property
    @pulumi.getter(name="guardrailConfiguration")
    def guardrail_configuration(self) -> Optional['outputs.FlowVersionGuardrailConfiguration']:
        return pulumi.get(self, "guardrail_configuration")


@pulumi.output_type
class FlowVersionPromptFlowNodeInlineConfiguration(dict):
    """
    Inline prompt configuration for prompt node
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "modelId":
            suggest = "model_id"
        elif key == "templateConfiguration":
            suggest = "template_configuration"
        elif key == "templateType":
            suggest = "template_type"
        elif key == "inferenceConfiguration":
            suggest = "inference_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowVersionPromptFlowNodeInlineConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowVersionPromptFlowNodeInlineConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowVersionPromptFlowNodeInlineConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 model_id: _builtins.str,
                 template_configuration: 'outputs.FlowVersionPromptTemplateConfigurationProperties',
                 template_type: 'FlowVersionPromptTemplateType',
                 inference_configuration: Optional['outputs.FlowVersionPromptInferenceConfigurationProperties'] = None):
        """
        Inline prompt configuration for prompt node
        :param _builtins.str model_id: ARN or Id of a Bedrock Foundational Model or Inference Profile, or the ARN of a imported model, or a provisioned throughput ARN for custom models.
        """
        pulumi.set(__self__, "model_id", model_id)
        pulumi.set(__self__, "template_configuration", template_configuration)
        pulumi.set(__self__, "template_type", template_type)
        if inference_configuration is not None:
            pulumi.set(__self__, "inference_configuration", inference_configuration)

    @_builtins.property
    @pulumi.getter(name="modelId")
    def model_id(self) -> _builtins.str:
        """
        ARN or Id of a Bedrock Foundational Model or Inference Profile, or the ARN of a imported model, or a provisioned throughput ARN for custom models.
        """
        return pulumi.get(self, "model_id")

    @_builtins.property
    @pulumi.getter(name="templateConfiguration")
    def template_configuration(self) -> 'outputs.FlowVersionPromptTemplateConfigurationProperties':
        return pulumi.get(self, "template_configuration")

    @_builtins.property
    @pulumi.getter(name="templateType")
    def template_type(self) -> 'FlowVersionPromptTemplateType':
        return pulumi.get(self, "template_type")

    @_builtins.property
    @pulumi.getter(name="inferenceConfiguration")
    def inference_configuration(self) -> Optional['outputs.FlowVersionPromptInferenceConfigurationProperties']:
        return pulumi.get(self, "inference_configuration")


@pulumi.output_type
class FlowVersionPromptFlowNodeResourceConfiguration(dict):
    """
    Resource prompt configuration for prompt node
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "promptArn":
            suggest = "prompt_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowVersionPromptFlowNodeResourceConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowVersionPromptFlowNodeResourceConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowVersionPromptFlowNodeResourceConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prompt_arn: _builtins.str):
        """
        Resource prompt configuration for prompt node
        :param _builtins.str prompt_arn: ARN of a prompt resource possibly with a version
        """
        pulumi.set(__self__, "prompt_arn", prompt_arn)

    @_builtins.property
    @pulumi.getter(name="promptArn")
    def prompt_arn(self) -> _builtins.str:
        """
        ARN of a prompt resource possibly with a version
        """
        return pulumi.get(self, "prompt_arn")


@pulumi.output_type
class FlowVersionPromptFlowNodeSourceConfiguration0Properties(dict):
    """
    Prompt source configuration for prompt node
    """
    def __init__(__self__, *,
                 resource: 'outputs.FlowVersionPromptFlowNodeResourceConfiguration'):
        """
        Prompt source configuration for prompt node
        """
        pulumi.set(__self__, "resource", resource)

    @_builtins.property
    @pulumi.getter
    def resource(self) -> 'outputs.FlowVersionPromptFlowNodeResourceConfiguration':
        return pulumi.get(self, "resource")


@pulumi.output_type
class FlowVersionPromptFlowNodeSourceConfiguration1Properties(dict):
    """
    Prompt source configuration for prompt node
    """
    def __init__(__self__, *,
                 inline: 'outputs.FlowVersionPromptFlowNodeInlineConfiguration'):
        """
        Prompt source configuration for prompt node
        """
        pulumi.set(__self__, "inline", inline)

    @_builtins.property
    @pulumi.getter
    def inline(self) -> 'outputs.FlowVersionPromptFlowNodeInlineConfiguration':
        return pulumi.get(self, "inline")


@pulumi.output_type
class FlowVersionPromptInferenceConfigurationProperties(dict):
    """
    Model inference configuration
    """
    def __init__(__self__, *,
                 text: 'outputs.FlowVersionPromptModelInferenceConfiguration'):
        """
        Model inference configuration
        """
        pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def text(self) -> 'outputs.FlowVersionPromptModelInferenceConfiguration':
        return pulumi.get(self, "text")


@pulumi.output_type
class FlowVersionPromptInputVariable(dict):
    """
    Input variable
    """
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        Input variable
        :param _builtins.str name: Name for an input variable
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name for an input variable
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class FlowVersionPromptModelInferenceConfiguration(dict):
    """
    Prompt model inference configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxTokens":
            suggest = "max_tokens"
        elif key == "stopSequences":
            suggest = "stop_sequences"
        elif key == "topP":
            suggest = "top_p"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowVersionPromptModelInferenceConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowVersionPromptModelInferenceConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowVersionPromptModelInferenceConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_tokens: Optional[_builtins.float] = None,
                 stop_sequences: Optional[Sequence[_builtins.str]] = None,
                 temperature: Optional[_builtins.float] = None,
                 top_p: Optional[_builtins.float] = None):
        """
        Prompt model inference configuration
        :param _builtins.float max_tokens: Maximum length of output
        :param Sequence[_builtins.str] stop_sequences: List of stop sequences
        :param _builtins.float temperature: Controls randomness, higher values increase diversity
        :param _builtins.float top_p: Cumulative probability cutoff for token selection
        """
        if max_tokens is not None:
            pulumi.set(__self__, "max_tokens", max_tokens)
        if stop_sequences is not None:
            pulumi.set(__self__, "stop_sequences", stop_sequences)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)
        if top_p is not None:
            pulumi.set(__self__, "top_p", top_p)

    @_builtins.property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> Optional[_builtins.float]:
        """
        Maximum length of output
        """
        return pulumi.get(self, "max_tokens")

    @_builtins.property
    @pulumi.getter(name="stopSequences")
    def stop_sequences(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of stop sequences
        """
        return pulumi.get(self, "stop_sequences")

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[_builtins.float]:
        """
        Controls randomness, higher values increase diversity
        """
        return pulumi.get(self, "temperature")

    @_builtins.property
    @pulumi.getter(name="topP")
    def top_p(self) -> Optional[_builtins.float]:
        """
        Cumulative probability cutoff for token selection
        """
        return pulumi.get(self, "top_p")


@pulumi.output_type
class FlowVersionPromptTemplateConfigurationProperties(dict):
    """
    Prompt template configuration
    """
    def __init__(__self__, *,
                 text: 'outputs.FlowVersionTextPromptTemplateConfiguration'):
        """
        Prompt template configuration
        """
        pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def text(self) -> 'outputs.FlowVersionTextPromptTemplateConfiguration':
        return pulumi.get(self, "text")


@pulumi.output_type
class FlowVersionRerankingMetadataSelectiveModeConfiguration0Properties(dict):
    """
    Reranking Metadata Selective Mode Configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldsToInclude":
            suggest = "fields_to_include"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowVersionRerankingMetadataSelectiveModeConfiguration0Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowVersionRerankingMetadataSelectiveModeConfiguration0Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowVersionRerankingMetadataSelectiveModeConfiguration0Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fields_to_include: Sequence['outputs.FlowVersionFieldForReranking']):
        """
        Reranking Metadata Selective Mode Configuration
        """
        pulumi.set(__self__, "fields_to_include", fields_to_include)

    @_builtins.property
    @pulumi.getter(name="fieldsToInclude")
    def fields_to_include(self) -> Sequence['outputs.FlowVersionFieldForReranking']:
        return pulumi.get(self, "fields_to_include")


@pulumi.output_type
class FlowVersionRerankingMetadataSelectiveModeConfiguration1Properties(dict):
    """
    Reranking Metadata Selective Mode Configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldsToExclude":
            suggest = "fields_to_exclude"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowVersionRerankingMetadataSelectiveModeConfiguration1Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowVersionRerankingMetadataSelectiveModeConfiguration1Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowVersionRerankingMetadataSelectiveModeConfiguration1Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fields_to_exclude: Sequence['outputs.FlowVersionFieldForReranking']):
        """
        Reranking Metadata Selective Mode Configuration
        """
        pulumi.set(__self__, "fields_to_exclude", fields_to_exclude)

    @_builtins.property
    @pulumi.getter(name="fieldsToExclude")
    def fields_to_exclude(self) -> Sequence['outputs.FlowVersionFieldForReranking']:
        return pulumi.get(self, "fields_to_exclude")


@pulumi.output_type
class FlowVersionRetrievalFlowNodeConfiguration(dict):
    """
    Retrieval flow node configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceConfiguration":
            suggest = "service_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowVersionRetrievalFlowNodeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowVersionRetrievalFlowNodeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowVersionRetrievalFlowNodeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_configuration: 'outputs.FlowVersionRetrievalFlowNodeServiceConfigurationProperties'):
        """
        Retrieval flow node configuration
        """
        pulumi.set(__self__, "service_configuration", service_configuration)

    @_builtins.property
    @pulumi.getter(name="serviceConfiguration")
    def service_configuration(self) -> 'outputs.FlowVersionRetrievalFlowNodeServiceConfigurationProperties':
        return pulumi.get(self, "service_configuration")


@pulumi.output_type
class FlowVersionRetrievalFlowNodeS3Configuration(dict):
    """
    s3 Retrieval configuration for Retrieval node
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowVersionRetrievalFlowNodeS3Configuration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowVersionRetrievalFlowNodeS3Configuration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowVersionRetrievalFlowNodeS3Configuration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: _builtins.str):
        """
        s3 Retrieval configuration for Retrieval node
        :param _builtins.str bucket_name: bucket name of an s3 that will be used for Retrieval flow node configuration
        """
        pulumi.set(__self__, "bucket_name", bucket_name)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> _builtins.str:
        """
        bucket name of an s3 that will be used for Retrieval flow node configuration
        """
        return pulumi.get(self, "bucket_name")


@pulumi.output_type
class FlowVersionRetrievalFlowNodeServiceConfigurationProperties(dict):
    """
    Retrieval service configuration for Retrieval node
    """
    def __init__(__self__, *,
                 s3: Optional['outputs.FlowVersionRetrievalFlowNodeS3Configuration'] = None):
        """
        Retrieval service configuration for Retrieval node
        """
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional['outputs.FlowVersionRetrievalFlowNodeS3Configuration']:
        return pulumi.get(self, "s3")


@pulumi.output_type
class FlowVersionStorageFlowNodeConfiguration(dict):
    """
    Storage flow node configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceConfiguration":
            suggest = "service_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowVersionStorageFlowNodeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowVersionStorageFlowNodeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowVersionStorageFlowNodeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_configuration: 'outputs.FlowVersionStorageFlowNodeServiceConfigurationProperties'):
        """
        Storage flow node configuration
        """
        pulumi.set(__self__, "service_configuration", service_configuration)

    @_builtins.property
    @pulumi.getter(name="serviceConfiguration")
    def service_configuration(self) -> 'outputs.FlowVersionStorageFlowNodeServiceConfigurationProperties':
        return pulumi.get(self, "service_configuration")


@pulumi.output_type
class FlowVersionStorageFlowNodeS3Configuration(dict):
    """
    s3 storage configuration for storage node
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowVersionStorageFlowNodeS3Configuration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowVersionStorageFlowNodeS3Configuration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowVersionStorageFlowNodeS3Configuration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: _builtins.str):
        """
        s3 storage configuration for storage node
        :param _builtins.str bucket_name: bucket name of an s3 that will be used for storage flow node configuration
        """
        pulumi.set(__self__, "bucket_name", bucket_name)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> _builtins.str:
        """
        bucket name of an s3 that will be used for storage flow node configuration
        """
        return pulumi.get(self, "bucket_name")


@pulumi.output_type
class FlowVersionStorageFlowNodeServiceConfigurationProperties(dict):
    """
    storage service configuration for storage node
    """
    def __init__(__self__, *,
                 s3: Optional['outputs.FlowVersionStorageFlowNodeS3Configuration'] = None):
        """
        storage service configuration for storage node
        """
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional['outputs.FlowVersionStorageFlowNodeS3Configuration']:
        return pulumi.get(self, "s3")


@pulumi.output_type
class FlowVersionTextPromptTemplateConfiguration(dict):
    """
    Configuration for text prompt template
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputVariables":
            suggest = "input_variables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowVersionTextPromptTemplateConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowVersionTextPromptTemplateConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowVersionTextPromptTemplateConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text: _builtins.str,
                 input_variables: Optional[Sequence['outputs.FlowVersionPromptInputVariable']] = None):
        """
        Configuration for text prompt template
        :param _builtins.str text: Prompt content for String prompt template
        :param Sequence['FlowVersionPromptInputVariable'] input_variables: List of input variables
        """
        pulumi.set(__self__, "text", text)
        if input_variables is not None:
            pulumi.set(__self__, "input_variables", input_variables)

    @_builtins.property
    @pulumi.getter
    def text(self) -> _builtins.str:
        """
        Prompt content for String prompt template
        """
        return pulumi.get(self, "text")

    @_builtins.property
    @pulumi.getter(name="inputVariables")
    def input_variables(self) -> Optional[Sequence['outputs.FlowVersionPromptInputVariable']]:
        """
        List of input variables
        """
        return pulumi.get(self, "input_variables")


@pulumi.output_type
class FlowVersionVectorSearchBedrockRerankingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "modelConfiguration":
            suggest = "model_configuration"
        elif key == "metadataConfiguration":
            suggest = "metadata_configuration"
        elif key == "numberOfRerankedResults":
            suggest = "number_of_reranked_results"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowVersionVectorSearchBedrockRerankingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowVersionVectorSearchBedrockRerankingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowVersionVectorSearchBedrockRerankingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 model_configuration: 'outputs.FlowVersionVectorSearchBedrockRerankingModelConfiguration',
                 metadata_configuration: Optional['outputs.FlowVersionMetadataConfigurationForReranking'] = None,
                 number_of_reranked_results: Optional[_builtins.float] = None):
        """
        :param _builtins.float number_of_reranked_results: Number Of Results For Reranking
        """
        pulumi.set(__self__, "model_configuration", model_configuration)
        if metadata_configuration is not None:
            pulumi.set(__self__, "metadata_configuration", metadata_configuration)
        if number_of_reranked_results is not None:
            pulumi.set(__self__, "number_of_reranked_results", number_of_reranked_results)

    @_builtins.property
    @pulumi.getter(name="modelConfiguration")
    def model_configuration(self) -> 'outputs.FlowVersionVectorSearchBedrockRerankingModelConfiguration':
        return pulumi.get(self, "model_configuration")

    @_builtins.property
    @pulumi.getter(name="metadataConfiguration")
    def metadata_configuration(self) -> Optional['outputs.FlowVersionMetadataConfigurationForReranking']:
        return pulumi.get(self, "metadata_configuration")

    @_builtins.property
    @pulumi.getter(name="numberOfRerankedResults")
    def number_of_reranked_results(self) -> Optional[_builtins.float]:
        """
        Number Of Results For Reranking
        """
        return pulumi.get(self, "number_of_reranked_results")


@pulumi.output_type
class FlowVersionVectorSearchBedrockRerankingModelConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "modelArn":
            suggest = "model_arn"
        elif key == "additionalModelRequestFields":
            suggest = "additional_model_request_fields"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowVersionVectorSearchBedrockRerankingModelConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowVersionVectorSearchBedrockRerankingModelConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowVersionVectorSearchBedrockRerankingModelConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 model_arn: _builtins.str,
                 additional_model_request_fields: Optional['outputs.FlowVersionAdditionalModelRequestFields'] = None):
        pulumi.set(__self__, "model_arn", model_arn)
        if additional_model_request_fields is not None:
            pulumi.set(__self__, "additional_model_request_fields", additional_model_request_fields)

    @_builtins.property
    @pulumi.getter(name="modelArn")
    def model_arn(self) -> _builtins.str:
        return pulumi.get(self, "model_arn")

    @_builtins.property
    @pulumi.getter(name="additionalModelRequestFields")
    def additional_model_request_fields(self) -> Optional['outputs.FlowVersionAdditionalModelRequestFields']:
        return pulumi.get(self, "additional_model_request_fields")


@pulumi.output_type
class FlowVersionVectorSearchRerankingConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bedrockRerankingConfiguration":
            suggest = "bedrock_reranking_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FlowVersionVectorSearchRerankingConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FlowVersionVectorSearchRerankingConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FlowVersionVectorSearchRerankingConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: 'FlowVersionVectorSearchRerankingConfigurationType',
                 bedrock_reranking_configuration: Optional['outputs.FlowVersionVectorSearchBedrockRerankingConfiguration'] = None):
        pulumi.set(__self__, "type", type)
        if bedrock_reranking_configuration is not None:
            pulumi.set(__self__, "bedrock_reranking_configuration", bedrock_reranking_configuration)

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'FlowVersionVectorSearchRerankingConfigurationType':
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="bedrockRerankingConfiguration")
    def bedrock_reranking_configuration(self) -> Optional['outputs.FlowVersionVectorSearchBedrockRerankingConfiguration']:
        return pulumi.get(self, "bedrock_reranking_configuration")


@pulumi.output_type
class GuardrailAutomatedReasoningPolicyConfig(dict):
    """
    Optional configuration for integrating Automated Reasoning policies with the guardrail.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "confidenceThreshold":
            suggest = "confidence_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardrailAutomatedReasoningPolicyConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardrailAutomatedReasoningPolicyConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardrailAutomatedReasoningPolicyConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 policies: Sequence[_builtins.str],
                 confidence_threshold: Optional[_builtins.float] = None):
        """
        Optional configuration for integrating Automated Reasoning policies with the guardrail.
        :param Sequence[_builtins.str] policies: The list of Automated Reasoning policy ARNs to include in the guardrail configuration
        :param _builtins.float confidence_threshold: The confidence threshold for triggering guardrail actions based on Automated Reasoning policy violations.
        """
        pulumi.set(__self__, "policies", policies)
        if confidence_threshold is not None:
            pulumi.set(__self__, "confidence_threshold", confidence_threshold)

    @_builtins.property
    @pulumi.getter
    def policies(self) -> Sequence[_builtins.str]:
        """
        The list of Automated Reasoning policy ARNs to include in the guardrail configuration
        """
        return pulumi.get(self, "policies")

    @_builtins.property
    @pulumi.getter(name="confidenceThreshold")
    def confidence_threshold(self) -> Optional[_builtins.float]:
        """
        The confidence threshold for triggering guardrail actions based on Automated Reasoning policy violations.
        """
        return pulumi.get(self, "confidence_threshold")


@pulumi.output_type
class GuardrailContentFilterConfig(dict):
    """
    Content filter config in content policy.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputStrength":
            suggest = "input_strength"
        elif key == "outputStrength":
            suggest = "output_strength"
        elif key == "inputAction":
            suggest = "input_action"
        elif key == "inputEnabled":
            suggest = "input_enabled"
        elif key == "inputModalities":
            suggest = "input_modalities"
        elif key == "outputAction":
            suggest = "output_action"
        elif key == "outputEnabled":
            suggest = "output_enabled"
        elif key == "outputModalities":
            suggest = "output_modalities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardrailContentFilterConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardrailContentFilterConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardrailContentFilterConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input_strength: 'GuardrailFilterStrength',
                 output_strength: 'GuardrailFilterStrength',
                 type: 'GuardrailContentFilterType',
                 input_action: Optional['GuardrailContentFilterAction'] = None,
                 input_enabled: Optional[_builtins.bool] = None,
                 input_modalities: Optional[Sequence['GuardrailModality']] = None,
                 output_action: Optional['GuardrailContentFilterAction'] = None,
                 output_enabled: Optional[_builtins.bool] = None,
                 output_modalities: Optional[Sequence['GuardrailModality']] = None):
        """
        Content filter config in content policy.
        :param 'GuardrailFilterStrength' input_strength: The strength of the content filter to apply to prompts. As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.
        :param 'GuardrailFilterStrength' output_strength: The strength of the content filter to apply to model responses. As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.
        :param 'GuardrailContentFilterType' type: The harmful category that the content filter is applied to.
        :param 'GuardrailContentFilterAction' input_action: Specifies the action to take when harmful content is detected. Supported values include:
               
               - `BLOCK`  Block the content and replace it with blocked messaging.
               - `NONE`  Take no action but return detection information in the trace response.
        :param _builtins.bool input_enabled: Specifies whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        :param Sequence['GuardrailModality'] input_modalities: List of modalities
        :param 'GuardrailContentFilterAction' output_action: Specifies the action to take when harmful content is detected in the output. Supported values include:
               
               - `BLOCK`  Block the content and replace it with blocked messaging.
               - `NONE`  Take no action but return detection information in the trace response.
        :param _builtins.bool output_enabled: Specifies whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        :param Sequence['GuardrailModality'] output_modalities: List of modalities
        """
        pulumi.set(__self__, "input_strength", input_strength)
        pulumi.set(__self__, "output_strength", output_strength)
        pulumi.set(__self__, "type", type)
        if input_action is not None:
            pulumi.set(__self__, "input_action", input_action)
        if input_enabled is not None:
            pulumi.set(__self__, "input_enabled", input_enabled)
        if input_modalities is not None:
            pulumi.set(__self__, "input_modalities", input_modalities)
        if output_action is not None:
            pulumi.set(__self__, "output_action", output_action)
        if output_enabled is not None:
            pulumi.set(__self__, "output_enabled", output_enabled)
        if output_modalities is not None:
            pulumi.set(__self__, "output_modalities", output_modalities)

    @_builtins.property
    @pulumi.getter(name="inputStrength")
    def input_strength(self) -> 'GuardrailFilterStrength':
        """
        The strength of the content filter to apply to prompts. As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.
        """
        return pulumi.get(self, "input_strength")

    @_builtins.property
    @pulumi.getter(name="outputStrength")
    def output_strength(self) -> 'GuardrailFilterStrength':
        """
        The strength of the content filter to apply to model responses. As you increase the filter strength, the likelihood of filtering harmful content increases and the probability of seeing harmful content in your application reduces.
        """
        return pulumi.get(self, "output_strength")

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'GuardrailContentFilterType':
        """
        The harmful category that the content filter is applied to.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="inputAction")
    def input_action(self) -> Optional['GuardrailContentFilterAction']:
        """
        Specifies the action to take when harmful content is detected. Supported values include:

        - `BLOCK`  Block the content and replace it with blocked messaging.
        - `NONE`  Take no action but return detection information in the trace response.
        """
        return pulumi.get(self, "input_action")

    @_builtins.property
    @pulumi.getter(name="inputEnabled")
    def input_enabled(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        return pulumi.get(self, "input_enabled")

    @_builtins.property
    @pulumi.getter(name="inputModalities")
    def input_modalities(self) -> Optional[Sequence['GuardrailModality']]:
        """
        List of modalities
        """
        return pulumi.get(self, "input_modalities")

    @_builtins.property
    @pulumi.getter(name="outputAction")
    def output_action(self) -> Optional['GuardrailContentFilterAction']:
        """
        Specifies the action to take when harmful content is detected in the output. Supported values include:

        - `BLOCK`  Block the content and replace it with blocked messaging.
        - `NONE`  Take no action but return detection information in the trace response.
        """
        return pulumi.get(self, "output_action")

    @_builtins.property
    @pulumi.getter(name="outputEnabled")
    def output_enabled(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        return pulumi.get(self, "output_enabled")

    @_builtins.property
    @pulumi.getter(name="outputModalities")
    def output_modalities(self) -> Optional[Sequence['GuardrailModality']]:
        """
        List of modalities
        """
        return pulumi.get(self, "output_modalities")


@pulumi.output_type
class GuardrailContentPolicyConfig(dict):
    """
    Content policy config for a guardrail.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filtersConfig":
            suggest = "filters_config"
        elif key == "contentFiltersTierConfig":
            suggest = "content_filters_tier_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardrailContentPolicyConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardrailContentPolicyConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardrailContentPolicyConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filters_config: Sequence['outputs.GuardrailContentFilterConfig'],
                 content_filters_tier_config: Optional['outputs.GuardrailContentPolicyConfigContentFiltersTierConfigProperties'] = None):
        """
        Content policy config for a guardrail.
        :param Sequence['GuardrailContentFilterConfig'] filters_config: List of content filter configs in content policy.
        :param 'GuardrailContentPolicyConfigContentFiltersTierConfigProperties' content_filters_tier_config: Guardrail tier config for content policy
        """
        pulumi.set(__self__, "filters_config", filters_config)
        if content_filters_tier_config is not None:
            pulumi.set(__self__, "content_filters_tier_config", content_filters_tier_config)

    @_builtins.property
    @pulumi.getter(name="filtersConfig")
    def filters_config(self) -> Sequence['outputs.GuardrailContentFilterConfig']:
        """
        List of content filter configs in content policy.
        """
        return pulumi.get(self, "filters_config")

    @_builtins.property
    @pulumi.getter(name="contentFiltersTierConfig")
    def content_filters_tier_config(self) -> Optional['outputs.GuardrailContentPolicyConfigContentFiltersTierConfigProperties']:
        """
        Guardrail tier config for content policy
        """
        return pulumi.get(self, "content_filters_tier_config")


@pulumi.output_type
class GuardrailContentPolicyConfigContentFiltersTierConfigProperties(dict):
    """
    Guardrail tier config for content policy
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tierName":
            suggest = "tier_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardrailContentPolicyConfigContentFiltersTierConfigProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardrailContentPolicyConfigContentFiltersTierConfigProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardrailContentPolicyConfigContentFiltersTierConfigProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tier_name: 'GuardrailContentFiltersTierName'):
        """
        Guardrail tier config for content policy
        """
        pulumi.set(__self__, "tier_name", tier_name)

    @_builtins.property
    @pulumi.getter(name="tierName")
    def tier_name(self) -> 'GuardrailContentFiltersTierName':
        return pulumi.get(self, "tier_name")


@pulumi.output_type
class GuardrailContextualGroundingFilterConfig(dict):
    """
    A config for grounding filter.
    """
    def __init__(__self__, *,
                 threshold: _builtins.float,
                 type: 'GuardrailContextualGroundingFilterType',
                 action: Optional['GuardrailContextualGroundingAction'] = None,
                 enabled: Optional[_builtins.bool] = None):
        """
        A config for grounding filter.
        :param _builtins.float threshold: The threshold for this filter.
        :param 'GuardrailContextualGroundingFilterType' type: The filter details for the guardrails contextual grounding filter.
        :param 'GuardrailContextualGroundingAction' action: Specifies the action to take when content fails the contextual grounding evaluation. Supported values include:
               
               - `BLOCK`  Block the content and replace it with blocked messaging.
               - `NONE`  Take no action but return detection information in the trace response.
        :param _builtins.bool enabled: Specifies whether to enable contextual grounding evaluation. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "type", type)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> _builtins.float:
        """
        The threshold for this filter.
        """
        return pulumi.get(self, "threshold")

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'GuardrailContextualGroundingFilterType':
        """
        The filter details for the guardrails contextual grounding filter.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional['GuardrailContextualGroundingAction']:
        """
        Specifies the action to take when content fails the contextual grounding evaluation. Supported values include:

        - `BLOCK`  Block the content and replace it with blocked messaging.
        - `NONE`  Take no action but return detection information in the trace response.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to enable contextual grounding evaluation. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GuardrailContextualGroundingPolicyConfig(dict):
    """
    Contextual grounding policy config for a guardrail.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filtersConfig":
            suggest = "filters_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardrailContextualGroundingPolicyConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardrailContextualGroundingPolicyConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardrailContextualGroundingPolicyConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filters_config: Sequence['outputs.GuardrailContextualGroundingFilterConfig']):
        """
        Contextual grounding policy config for a guardrail.
        :param Sequence['GuardrailContextualGroundingFilterConfig'] filters_config: List of contextual grounding filter configs.
        """
        pulumi.set(__self__, "filters_config", filters_config)

    @_builtins.property
    @pulumi.getter(name="filtersConfig")
    def filters_config(self) -> Sequence['outputs.GuardrailContextualGroundingFilterConfig']:
        """
        List of contextual grounding filter configs.
        """
        return pulumi.get(self, "filters_config")


@pulumi.output_type
class GuardrailCrossRegionConfig(dict):
    """
    The system-defined guardrail profile that youre using with your guardrail
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "guardrailProfileArn":
            suggest = "guardrail_profile_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardrailCrossRegionConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardrailCrossRegionConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardrailCrossRegionConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 guardrail_profile_arn: _builtins.str):
        """
        The system-defined guardrail profile that youre using with your guardrail
        :param _builtins.str guardrail_profile_arn: The Amazon Resource Name (ARN) of the guardrail profile
        """
        pulumi.set(__self__, "guardrail_profile_arn", guardrail_profile_arn)

    @_builtins.property
    @pulumi.getter(name="guardrailProfileArn")
    def guardrail_profile_arn(self) -> _builtins.str:
        """
        The Amazon Resource Name (ARN) of the guardrail profile
        """
        return pulumi.get(self, "guardrail_profile_arn")


@pulumi.output_type
class GuardrailManagedWordsConfig(dict):
    """
    A managed words config.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputAction":
            suggest = "input_action"
        elif key == "inputEnabled":
            suggest = "input_enabled"
        elif key == "outputAction":
            suggest = "output_action"
        elif key == "outputEnabled":
            suggest = "output_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardrailManagedWordsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardrailManagedWordsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardrailManagedWordsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: 'GuardrailManagedWordsType',
                 input_action: Optional['GuardrailWordAction'] = None,
                 input_enabled: Optional[_builtins.bool] = None,
                 output_action: Optional['GuardrailWordAction'] = None,
                 output_enabled: Optional[_builtins.bool] = None):
        """
        A managed words config.
        :param 'GuardrailManagedWordsType' type: The managed word type to configure for the guardrail.
        :param 'GuardrailWordAction' input_action: Specifies the action to take when harmful content is detected in the input. Supported values include:
               
               - `BLOCK`  Block the content and replace it with blocked messaging.
               - `NONE`  Take no action but return detection information in the trace response.
        :param _builtins.bool input_enabled: Specifies whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        :param 'GuardrailWordAction' output_action: Specifies the action to take when harmful content is detected in the output. Supported values include:
               
               - `BLOCK`  Block the content and replace it with blocked messaging.
               - `NONE`  Take no action but return detection information in the trace response.
        :param _builtins.bool output_enabled: Specifies whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        pulumi.set(__self__, "type", type)
        if input_action is not None:
            pulumi.set(__self__, "input_action", input_action)
        if input_enabled is not None:
            pulumi.set(__self__, "input_enabled", input_enabled)
        if output_action is not None:
            pulumi.set(__self__, "output_action", output_action)
        if output_enabled is not None:
            pulumi.set(__self__, "output_enabled", output_enabled)

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'GuardrailManagedWordsType':
        """
        The managed word type to configure for the guardrail.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="inputAction")
    def input_action(self) -> Optional['GuardrailWordAction']:
        """
        Specifies the action to take when harmful content is detected in the input. Supported values include:

        - `BLOCK`  Block the content and replace it with blocked messaging.
        - `NONE`  Take no action but return detection information in the trace response.
        """
        return pulumi.get(self, "input_action")

    @_builtins.property
    @pulumi.getter(name="inputEnabled")
    def input_enabled(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        return pulumi.get(self, "input_enabled")

    @_builtins.property
    @pulumi.getter(name="outputAction")
    def output_action(self) -> Optional['GuardrailWordAction']:
        """
        Specifies the action to take when harmful content is detected in the output. Supported values include:

        - `BLOCK`  Block the content and replace it with blocked messaging.
        - `NONE`  Take no action but return detection information in the trace response.
        """
        return pulumi.get(self, "output_action")

    @_builtins.property
    @pulumi.getter(name="outputEnabled")
    def output_enabled(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        return pulumi.get(self, "output_enabled")


@pulumi.output_type
class GuardrailPiiEntityConfig(dict):
    """
    Pii entity configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputAction":
            suggest = "input_action"
        elif key == "inputEnabled":
            suggest = "input_enabled"
        elif key == "outputAction":
            suggest = "output_action"
        elif key == "outputEnabled":
            suggest = "output_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardrailPiiEntityConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardrailPiiEntityConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardrailPiiEntityConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: 'GuardrailSensitiveInformationAction',
                 type: 'GuardrailPiiEntityType',
                 input_action: Optional['GuardrailSensitiveInformationAction'] = None,
                 input_enabled: Optional[_builtins.bool] = None,
                 output_action: Optional['GuardrailSensitiveInformationAction'] = None,
                 output_enabled: Optional[_builtins.bool] = None):
        """
        Pii entity configuration.
        :param 'GuardrailSensitiveInformationAction' action: Configure guardrail action when the PII entity is detected.
        :param 'GuardrailPiiEntityType' type: Configure guardrail type when the PII entity is detected.
               
               The following PIIs are used to block or mask sensitive information:
               
               - *General*
               
               - *ADDRESS*
               
               A physical address, such as "100 Main Street, Anytown, USA" or "Suite #12, Building 123". An address can include information such as the street, building, location, city, state, country, county, zip code, precinct, and neighborhood.
               - *AGE*
               
               An individual's age, including the quantity and unit of time. For example, in the phrase "I am 40 years old," Guardrails recognizes "40 years" as an age.
               - *NAME*
               
               An individual's name. This entity type does not include titles, such as Dr., Mr., Mrs., or Miss. guardrails doesn't apply this entity type to names that are part of organizations or addresses. For example, guardrails recognizes the "John Doe Organization" as an organization, and it recognizes "Jane Doe Street" as an address.
               - *EMAIL*
               
               An email address, such as *marymajor@email.com* .
               - *PHONE*
               
               A phone number. This entity type also includes fax and pager numbers.
               - *USERNAME*
               
               A user name that identifies an account, such as a login name, screen name, nick name, or handle.
               - *PASSWORD*
               
               An alphanumeric string that is used as a password, such as "* *very20special#pass** ".
               - *DRIVER_ID*
               
               The number assigned to a driver's license, which is an official document permitting an individual to operate one or more motorized vehicles on a public road. A driver's license number consists of alphanumeric characters.
               - *LICENSE_PLATE*
               
               A license plate for a vehicle is issued by the state or country where the vehicle is registered. The format for passenger vehicles is typically five to eight digits, consisting of upper-case letters and numbers. The format varies depending on the location of the issuing state or country.
               - *VEHICLE_IDENTIFICATION_NUMBER*
               
               A Vehicle Identification Number (VIN) uniquely identifies a vehicle. VIN content and format are defined in the *ISO 3779* specification. Each country has specific codes and formats for VINs.
               - *Finance*
               
               - *CREDIT_DEBIT_CARD_CVV*
               
               A three-digit card verification code (CVV) that is present on VISA, MasterCard, and Discover credit and debit cards. For American Express credit or debit cards, the CVV is a four-digit numeric code.
               - *CREDIT_DEBIT_CARD_EXPIRY*
               
               The expiration date for a credit or debit card. This number is usually four digits long and is often formatted as *month/year* or *MM/YY* . Guardrails recognizes expiration dates such as *01/21* , *01/2021* , and *Jan 2021* .
               - *CREDIT_DEBIT_CARD_NUMBER*
               
               The number for a credit or debit card. These numbers can vary from 13 to 16 digits in length. However, Amazon Comprehend also recognizes credit or debit card numbers when only the last four digits are present.
               - *PIN*
               
               A four-digit personal identification number (PIN) with which you can access your bank account.
               - *INTERNATIONAL_BANK_ACCOUNT_NUMBER*
               
               An International Bank Account Number has specific formats in each country. For more information, see [www.iban.com/structure](https://docs.aws.amazon.com/https://www.iban.com/structure) .
               - *SWIFT_CODE*
               
               A SWIFT code is a standard format of Bank Identifier Code (BIC) used to specify a particular bank or branch. Banks use these codes for money transfers such as international wire transfers.
               
               SWIFT codes consist of eight or 11 characters. The 11-digit codes refer to specific branches, while eight-digit codes (or 11-digit codes ending in 'XXX') refer to the head or primary office.
               - *IT*
               
               - *IP_ADDRESS*
               
               An IPv4 address, such as *198.51.100.0* .
               - *MAC_ADDRESS*
               
               A *media access control* (MAC) address is a unique identifier assigned to a network interface controller (NIC).
               - *URL*
               
               A web address, such as *www.example.com* .
               - *AWS_ACCESS_KEY*
               
               A unique identifier that's associated with a secret access key; you use the access key ID and secret access key to sign programmatic AWS requests cryptographically.
               - *AWS_SECRET_KEY*
               
               A unique identifier that's associated with an access key. You use the access key ID and secret access key to sign programmatic AWS requests cryptographically.
               - *USA specific*
               
               - *US_BANK_ACCOUNT_NUMBER*
               
               A US bank account number, which is typically 10 to 12 digits long.
               - *US_BANK_ROUTING_NUMBER*
               
               A US bank account routing number. These are typically nine digits long,
               - *US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER*
               
               A US Individual Taxpayer Identification Number (ITIN) is a nine-digit number that starts with a "9" and contain a "7" or "8" as the fourth digit. An ITIN can be formatted with a space or a dash after the third and forth digits.
               - *US_PASSPORT_NUMBER*
               
               A US passport number. Passport numbers range from six to nine alphanumeric characters.
               - *US_SOCIAL_SECURITY_NUMBER*
               
               A US Social Security Number (SSN) is a nine-digit number that is issued to US citizens, permanent residents, and temporary working residents.
               - *Canada specific*
               
               - *CA_HEALTH_NUMBER*
               
               A Canadian Health Service Number is a 10-digit unique identifier, required for individuals to access healthcare benefits.
               - *CA_SOCIAL_INSURANCE_NUMBER*
               
               A Canadian Social Insurance Number (SIN) is a nine-digit unique identifier, required for individuals to access government programs and benefits.
               
               The SIN is formatted as three groups of three digits, such as *123-456-789* . A SIN can be validated through a simple check-digit process called the [Luhn algorithm](https://docs.aws.amazon.com/https://www.wikipedia.org/wiki/Luhn_algorithm) .
               - *UK Specific*
               
               - *UK_NATIONAL_HEALTH_SERVICE_NUMBER*
               
               A UK National Health Service Number is a 10-17 digit number, such as *485 777 3456* . The current system formats the 10-digit number with spaces after the third and sixth digits. The final digit is an error-detecting checksum.
               - *UK_NATIONAL_INSURANCE_NUMBER*
               
               A UK National Insurance Number (NINO) provides individuals with access to National Insurance (social security) benefits. It is also used for some purposes in the UK tax system.
               
               The number is nine digits long and starts with two letters, followed by six numbers and one letter. A NINO can be formatted with a space or a dash after the two letters and after the second, forth, and sixth digits.
               - *UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER*
               
               A UK Unique Taxpayer Reference (UTR) is a 10-digit number that identifies a taxpayer or a business.
               - *Custom*
               
               - *Regex filter* - You can use a regular expressions to define patterns for a guardrail to recognize and act upon such as serial number, booking ID etc..
        :param 'GuardrailSensitiveInformationAction' input_action: Specifies the action to take when harmful content is detected in the input. Supported values include:
               
               - `BLOCK`  Block the content and replace it with blocked messaging.
               - `ANONYMIZE`  Mask the content and replace it with identifier tags.
               - `NONE`  Take no action but return detection information in the trace response.
        :param _builtins.bool input_enabled: Specifies whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        :param 'GuardrailSensitiveInformationAction' output_action: Specifies the action to take when harmful content is detected in the output. Supported values include:
               
               - `BLOCK`  Block the content and replace it with blocked messaging.
               - `ANONYMIZE`  Mask the content and replace it with identifier tags.
               - `NONE`  Take no action but return detection information in the trace response.
        :param _builtins.bool output_enabled: Indicates whether guardrail evaluation is enabled on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "type", type)
        if input_action is not None:
            pulumi.set(__self__, "input_action", input_action)
        if input_enabled is not None:
            pulumi.set(__self__, "input_enabled", input_enabled)
        if output_action is not None:
            pulumi.set(__self__, "output_action", output_action)
        if output_enabled is not None:
            pulumi.set(__self__, "output_enabled", output_enabled)

    @_builtins.property
    @pulumi.getter
    def action(self) -> 'GuardrailSensitiveInformationAction':
        """
        Configure guardrail action when the PII entity is detected.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'GuardrailPiiEntityType':
        """
        Configure guardrail type when the PII entity is detected.

        The following PIIs are used to block or mask sensitive information:

        - *General*

        - *ADDRESS*

        A physical address, such as "100 Main Street, Anytown, USA" or "Suite #12, Building 123". An address can include information such as the street, building, location, city, state, country, county, zip code, precinct, and neighborhood.
        - *AGE*

        An individual's age, including the quantity and unit of time. For example, in the phrase "I am 40 years old," Guardrails recognizes "40 years" as an age.
        - *NAME*

        An individual's name. This entity type does not include titles, such as Dr., Mr., Mrs., or Miss. guardrails doesn't apply this entity type to names that are part of organizations or addresses. For example, guardrails recognizes the "John Doe Organization" as an organization, and it recognizes "Jane Doe Street" as an address.
        - *EMAIL*

        An email address, such as *marymajor@email.com* .
        - *PHONE*

        A phone number. This entity type also includes fax and pager numbers.
        - *USERNAME*

        A user name that identifies an account, such as a login name, screen name, nick name, or handle.
        - *PASSWORD*

        An alphanumeric string that is used as a password, such as "* *very20special#pass** ".
        - *DRIVER_ID*

        The number assigned to a driver's license, which is an official document permitting an individual to operate one or more motorized vehicles on a public road. A driver's license number consists of alphanumeric characters.
        - *LICENSE_PLATE*

        A license plate for a vehicle is issued by the state or country where the vehicle is registered. The format for passenger vehicles is typically five to eight digits, consisting of upper-case letters and numbers. The format varies depending on the location of the issuing state or country.
        - *VEHICLE_IDENTIFICATION_NUMBER*

        A Vehicle Identification Number (VIN) uniquely identifies a vehicle. VIN content and format are defined in the *ISO 3779* specification. Each country has specific codes and formats for VINs.
        - *Finance*

        - *CREDIT_DEBIT_CARD_CVV*

        A three-digit card verification code (CVV) that is present on VISA, MasterCard, and Discover credit and debit cards. For American Express credit or debit cards, the CVV is a four-digit numeric code.
        - *CREDIT_DEBIT_CARD_EXPIRY*

        The expiration date for a credit or debit card. This number is usually four digits long and is often formatted as *month/year* or *MM/YY* . Guardrails recognizes expiration dates such as *01/21* , *01/2021* , and *Jan 2021* .
        - *CREDIT_DEBIT_CARD_NUMBER*

        The number for a credit or debit card. These numbers can vary from 13 to 16 digits in length. However, Amazon Comprehend also recognizes credit or debit card numbers when only the last four digits are present.
        - *PIN*

        A four-digit personal identification number (PIN) with which you can access your bank account.
        - *INTERNATIONAL_BANK_ACCOUNT_NUMBER*

        An International Bank Account Number has specific formats in each country. For more information, see [www.iban.com/structure](https://docs.aws.amazon.com/https://www.iban.com/structure) .
        - *SWIFT_CODE*

        A SWIFT code is a standard format of Bank Identifier Code (BIC) used to specify a particular bank or branch. Banks use these codes for money transfers such as international wire transfers.

        SWIFT codes consist of eight or 11 characters. The 11-digit codes refer to specific branches, while eight-digit codes (or 11-digit codes ending in 'XXX') refer to the head or primary office.
        - *IT*

        - *IP_ADDRESS*

        An IPv4 address, such as *198.51.100.0* .
        - *MAC_ADDRESS*

        A *media access control* (MAC) address is a unique identifier assigned to a network interface controller (NIC).
        - *URL*

        A web address, such as *www.example.com* .
        - *AWS_ACCESS_KEY*

        A unique identifier that's associated with a secret access key; you use the access key ID and secret access key to sign programmatic AWS requests cryptographically.
        - *AWS_SECRET_KEY*

        A unique identifier that's associated with an access key. You use the access key ID and secret access key to sign programmatic AWS requests cryptographically.
        - *USA specific*

        - *US_BANK_ACCOUNT_NUMBER*

        A US bank account number, which is typically 10 to 12 digits long.
        - *US_BANK_ROUTING_NUMBER*

        A US bank account routing number. These are typically nine digits long,
        - *US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER*

        A US Individual Taxpayer Identification Number (ITIN) is a nine-digit number that starts with a "9" and contain a "7" or "8" as the fourth digit. An ITIN can be formatted with a space or a dash after the third and forth digits.
        - *US_PASSPORT_NUMBER*

        A US passport number. Passport numbers range from six to nine alphanumeric characters.
        - *US_SOCIAL_SECURITY_NUMBER*

        A US Social Security Number (SSN) is a nine-digit number that is issued to US citizens, permanent residents, and temporary working residents.
        - *Canada specific*

        - *CA_HEALTH_NUMBER*

        A Canadian Health Service Number is a 10-digit unique identifier, required for individuals to access healthcare benefits.
        - *CA_SOCIAL_INSURANCE_NUMBER*

        A Canadian Social Insurance Number (SIN) is a nine-digit unique identifier, required for individuals to access government programs and benefits.

        The SIN is formatted as three groups of three digits, such as *123-456-789* . A SIN can be validated through a simple check-digit process called the [Luhn algorithm](https://docs.aws.amazon.com/https://www.wikipedia.org/wiki/Luhn_algorithm) .
        - *UK Specific*

        - *UK_NATIONAL_HEALTH_SERVICE_NUMBER*

        A UK National Health Service Number is a 10-17 digit number, such as *485 777 3456* . The current system formats the 10-digit number with spaces after the third and sixth digits. The final digit is an error-detecting checksum.
        - *UK_NATIONAL_INSURANCE_NUMBER*

        A UK National Insurance Number (NINO) provides individuals with access to National Insurance (social security) benefits. It is also used for some purposes in the UK tax system.

        The number is nine digits long and starts with two letters, followed by six numbers and one letter. A NINO can be formatted with a space or a dash after the two letters and after the second, forth, and sixth digits.
        - *UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER*

        A UK Unique Taxpayer Reference (UTR) is a 10-digit number that identifies a taxpayer or a business.
        - *Custom*

        - *Regex filter* - You can use a regular expressions to define patterns for a guardrail to recognize and act upon such as serial number, booking ID etc..
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="inputAction")
    def input_action(self) -> Optional['GuardrailSensitiveInformationAction']:
        """
        Specifies the action to take when harmful content is detected in the input. Supported values include:

        - `BLOCK`  Block the content and replace it with blocked messaging.
        - `ANONYMIZE`  Mask the content and replace it with identifier tags.
        - `NONE`  Take no action but return detection information in the trace response.
        """
        return pulumi.get(self, "input_action")

    @_builtins.property
    @pulumi.getter(name="inputEnabled")
    def input_enabled(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        return pulumi.get(self, "input_enabled")

    @_builtins.property
    @pulumi.getter(name="outputAction")
    def output_action(self) -> Optional['GuardrailSensitiveInformationAction']:
        """
        Specifies the action to take when harmful content is detected in the output. Supported values include:

        - `BLOCK`  Block the content and replace it with blocked messaging.
        - `ANONYMIZE`  Mask the content and replace it with identifier tags.
        - `NONE`  Take no action but return detection information in the trace response.
        """
        return pulumi.get(self, "output_action")

    @_builtins.property
    @pulumi.getter(name="outputEnabled")
    def output_enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates whether guardrail evaluation is enabled on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        return pulumi.get(self, "output_enabled")


@pulumi.output_type
class GuardrailRegexConfig(dict):
    """
    A regex configuration.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputAction":
            suggest = "input_action"
        elif key == "inputEnabled":
            suggest = "input_enabled"
        elif key == "outputAction":
            suggest = "output_action"
        elif key == "outputEnabled":
            suggest = "output_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardrailRegexConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardrailRegexConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardrailRegexConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: 'GuardrailSensitiveInformationAction',
                 name: _builtins.str,
                 pattern: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 input_action: Optional['GuardrailSensitiveInformationAction'] = None,
                 input_enabled: Optional[_builtins.bool] = None,
                 output_action: Optional['GuardrailSensitiveInformationAction'] = None,
                 output_enabled: Optional[_builtins.bool] = None):
        """
        A regex configuration.
        :param 'GuardrailSensitiveInformationAction' action: The guardrail action to configure when matching regular expression is detected.
        :param _builtins.str name: The regex name.
        :param _builtins.str pattern: The regex pattern.
        :param _builtins.str description: The regex description.
        :param 'GuardrailSensitiveInformationAction' input_action: Specifies the action to take when harmful content is detected in the input. Supported values include:
               
               - `BLOCK`  Block the content and replace it with blocked messaging.
               - `NONE`  Take no action but return detection information in the trace response.
        :param _builtins.bool input_enabled: Specifies whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        :param 'GuardrailSensitiveInformationAction' output_action: Specifies the action to take when harmful content is detected in the output. Supported values include:
               
               - `BLOCK`  Block the content and replace it with blocked messaging.
               - `NONE`  Take no action but return detection information in the trace response.
        :param _builtins.bool output_enabled: Specifies whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pattern", pattern)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if input_action is not None:
            pulumi.set(__self__, "input_action", input_action)
        if input_enabled is not None:
            pulumi.set(__self__, "input_enabled", input_enabled)
        if output_action is not None:
            pulumi.set(__self__, "output_action", output_action)
        if output_enabled is not None:
            pulumi.set(__self__, "output_enabled", output_enabled)

    @_builtins.property
    @pulumi.getter
    def action(self) -> 'GuardrailSensitiveInformationAction':
        """
        The guardrail action to configure when matching regular expression is detected.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The regex name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def pattern(self) -> _builtins.str:
        """
        The regex pattern.
        """
        return pulumi.get(self, "pattern")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The regex description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="inputAction")
    def input_action(self) -> Optional['GuardrailSensitiveInformationAction']:
        """
        Specifies the action to take when harmful content is detected in the input. Supported values include:

        - `BLOCK`  Block the content and replace it with blocked messaging.
        - `NONE`  Take no action but return detection information in the trace response.
        """
        return pulumi.get(self, "input_action")

    @_builtins.property
    @pulumi.getter(name="inputEnabled")
    def input_enabled(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        return pulumi.get(self, "input_enabled")

    @_builtins.property
    @pulumi.getter(name="outputAction")
    def output_action(self) -> Optional['GuardrailSensitiveInformationAction']:
        """
        Specifies the action to take when harmful content is detected in the output. Supported values include:

        - `BLOCK`  Block the content and replace it with blocked messaging.
        - `NONE`  Take no action but return detection information in the trace response.
        """
        return pulumi.get(self, "output_action")

    @_builtins.property
    @pulumi.getter(name="outputEnabled")
    def output_enabled(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        return pulumi.get(self, "output_enabled")


@pulumi.output_type
class GuardrailSensitiveInformationPolicyConfig(dict):
    """
    Sensitive information policy config for a guardrail.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "piiEntitiesConfig":
            suggest = "pii_entities_config"
        elif key == "regexesConfig":
            suggest = "regexes_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardrailSensitiveInformationPolicyConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardrailSensitiveInformationPolicyConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardrailSensitiveInformationPolicyConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pii_entities_config: Optional[Sequence['outputs.GuardrailPiiEntityConfig']] = None,
                 regexes_config: Optional[Sequence['outputs.GuardrailRegexConfig']] = None):
        """
        Sensitive information policy config for a guardrail.
        :param Sequence['GuardrailPiiEntityConfig'] pii_entities_config: List of entities.
        :param Sequence['GuardrailRegexConfig'] regexes_config: List of regex.
        """
        if pii_entities_config is not None:
            pulumi.set(__self__, "pii_entities_config", pii_entities_config)
        if regexes_config is not None:
            pulumi.set(__self__, "regexes_config", regexes_config)

    @_builtins.property
    @pulumi.getter(name="piiEntitiesConfig")
    def pii_entities_config(self) -> Optional[Sequence['outputs.GuardrailPiiEntityConfig']]:
        """
        List of entities.
        """
        return pulumi.get(self, "pii_entities_config")

    @_builtins.property
    @pulumi.getter(name="regexesConfig")
    def regexes_config(self) -> Optional[Sequence['outputs.GuardrailRegexConfig']]:
        """
        List of regex.
        """
        return pulumi.get(self, "regexes_config")


@pulumi.output_type
class GuardrailTopicConfig(dict):
    """
    Topic config in topic policy.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputAction":
            suggest = "input_action"
        elif key == "inputEnabled":
            suggest = "input_enabled"
        elif key == "outputAction":
            suggest = "output_action"
        elif key == "outputEnabled":
            suggest = "output_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardrailTopicConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardrailTopicConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardrailTopicConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 definition: _builtins.str,
                 name: _builtins.str,
                 type: 'GuardrailTopicType',
                 examples: Optional[Sequence[_builtins.str]] = None,
                 input_action: Optional['GuardrailTopicAction'] = None,
                 input_enabled: Optional[_builtins.bool] = None,
                 output_action: Optional['GuardrailTopicAction'] = None,
                 output_enabled: Optional[_builtins.bool] = None):
        """
        Topic config in topic policy.
        :param _builtins.str definition: Definition of topic in topic policy
        :param _builtins.str name: Name of topic in topic policy
        :param 'GuardrailTopicType' type: Specifies to deny the topic.
        :param Sequence[_builtins.str] examples: List of text examples
        :param 'GuardrailTopicAction' input_action: Specifies the action to take when harmful content is detected in the input. Supported values include:
               
               - `BLOCK`  Block the content and replace it with blocked messaging.
               - `NONE`  Take no action but return detection information in the trace response.
        :param _builtins.bool input_enabled: Specifies whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        :param 'GuardrailTopicAction' output_action: Specifies the action to take when harmful content is detected in the output. Supported values include:
               
               - `BLOCK`  Block the content and replace it with blocked messaging.
               - `NONE`  Take no action but return detection information in the trace response.
        :param _builtins.bool output_enabled: Specifies whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        pulumi.set(__self__, "definition", definition)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if examples is not None:
            pulumi.set(__self__, "examples", examples)
        if input_action is not None:
            pulumi.set(__self__, "input_action", input_action)
        if input_enabled is not None:
            pulumi.set(__self__, "input_enabled", input_enabled)
        if output_action is not None:
            pulumi.set(__self__, "output_action", output_action)
        if output_enabled is not None:
            pulumi.set(__self__, "output_enabled", output_enabled)

    @_builtins.property
    @pulumi.getter
    def definition(self) -> _builtins.str:
        """
        Definition of topic in topic policy
        """
        return pulumi.get(self, "definition")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of topic in topic policy
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'GuardrailTopicType':
        """
        Specifies to deny the topic.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def examples(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of text examples
        """
        return pulumi.get(self, "examples")

    @_builtins.property
    @pulumi.getter(name="inputAction")
    def input_action(self) -> Optional['GuardrailTopicAction']:
        """
        Specifies the action to take when harmful content is detected in the input. Supported values include:

        - `BLOCK`  Block the content and replace it with blocked messaging.
        - `NONE`  Take no action but return detection information in the trace response.
        """
        return pulumi.get(self, "input_action")

    @_builtins.property
    @pulumi.getter(name="inputEnabled")
    def input_enabled(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to enable guardrail evaluation on the input. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        return pulumi.get(self, "input_enabled")

    @_builtins.property
    @pulumi.getter(name="outputAction")
    def output_action(self) -> Optional['GuardrailTopicAction']:
        """
        Specifies the action to take when harmful content is detected in the output. Supported values include:

        - `BLOCK`  Block the content and replace it with blocked messaging.
        - `NONE`  Take no action but return detection information in the trace response.
        """
        return pulumi.get(self, "output_action")

    @_builtins.property
    @pulumi.getter(name="outputEnabled")
    def output_enabled(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        return pulumi.get(self, "output_enabled")


@pulumi.output_type
class GuardrailTopicPolicyConfig(dict):
    """
    Topic policy config for a guardrail.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "topicsConfig":
            suggest = "topics_config"
        elif key == "topicsTierConfig":
            suggest = "topics_tier_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardrailTopicPolicyConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardrailTopicPolicyConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardrailTopicPolicyConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 topics_config: Sequence['outputs.GuardrailTopicConfig'],
                 topics_tier_config: Optional['outputs.GuardrailTopicPolicyConfigTopicsTierConfigProperties'] = None):
        """
        Topic policy config for a guardrail.
        :param Sequence['GuardrailTopicConfig'] topics_config: List of topic configs in topic policy.
        :param 'GuardrailTopicPolicyConfigTopicsTierConfigProperties' topics_tier_config: Guardrail tier config for topic policy
        """
        pulumi.set(__self__, "topics_config", topics_config)
        if topics_tier_config is not None:
            pulumi.set(__self__, "topics_tier_config", topics_tier_config)

    @_builtins.property
    @pulumi.getter(name="topicsConfig")
    def topics_config(self) -> Sequence['outputs.GuardrailTopicConfig']:
        """
        List of topic configs in topic policy.
        """
        return pulumi.get(self, "topics_config")

    @_builtins.property
    @pulumi.getter(name="topicsTierConfig")
    def topics_tier_config(self) -> Optional['outputs.GuardrailTopicPolicyConfigTopicsTierConfigProperties']:
        """
        Guardrail tier config for topic policy
        """
        return pulumi.get(self, "topics_tier_config")


@pulumi.output_type
class GuardrailTopicPolicyConfigTopicsTierConfigProperties(dict):
    """
    Guardrail tier config for topic policy
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tierName":
            suggest = "tier_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardrailTopicPolicyConfigTopicsTierConfigProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardrailTopicPolicyConfigTopicsTierConfigProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardrailTopicPolicyConfigTopicsTierConfigProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tier_name: 'GuardrailTopicsTierName'):
        """
        Guardrail tier config for topic policy
        """
        pulumi.set(__self__, "tier_name", tier_name)

    @_builtins.property
    @pulumi.getter(name="tierName")
    def tier_name(self) -> 'GuardrailTopicsTierName':
        return pulumi.get(self, "tier_name")


@pulumi.output_type
class GuardrailWordConfig(dict):
    """
    A custom word config.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputAction":
            suggest = "input_action"
        elif key == "inputEnabled":
            suggest = "input_enabled"
        elif key == "outputAction":
            suggest = "output_action"
        elif key == "outputEnabled":
            suggest = "output_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardrailWordConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardrailWordConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardrailWordConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text: _builtins.str,
                 input_action: Optional['GuardrailWordAction'] = None,
                 input_enabled: Optional[_builtins.bool] = None,
                 output_action: Optional['GuardrailWordAction'] = None,
                 output_enabled: Optional[_builtins.bool] = None):
        """
        A custom word config.
        :param _builtins.str text: The custom word text.
        :param 'GuardrailWordAction' input_action: Specifies the action to take when harmful content is detected in the input. Supported values include:
               
               - `BLOCK`  Block the content and replace it with blocked messaging.
               - `NONE`  Take no action but return detection information in the trace response.
        :param _builtins.bool input_enabled: Specifies whether to enable guardrail evaluation on the intput. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        :param 'GuardrailWordAction' output_action: Specifies the action to take when harmful content is detected in the output. Supported values include:
               
               - `BLOCK`  Block the content and replace it with blocked messaging.
               - `NONE`  Take no action but return detection information in the trace response.
        :param _builtins.bool output_enabled: Specifies whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        pulumi.set(__self__, "text", text)
        if input_action is not None:
            pulumi.set(__self__, "input_action", input_action)
        if input_enabled is not None:
            pulumi.set(__self__, "input_enabled", input_enabled)
        if output_action is not None:
            pulumi.set(__self__, "output_action", output_action)
        if output_enabled is not None:
            pulumi.set(__self__, "output_enabled", output_enabled)

    @_builtins.property
    @pulumi.getter
    def text(self) -> _builtins.str:
        """
        The custom word text.
        """
        return pulumi.get(self, "text")

    @_builtins.property
    @pulumi.getter(name="inputAction")
    def input_action(self) -> Optional['GuardrailWordAction']:
        """
        Specifies the action to take when harmful content is detected in the input. Supported values include:

        - `BLOCK`  Block the content and replace it with blocked messaging.
        - `NONE`  Take no action but return detection information in the trace response.
        """
        return pulumi.get(self, "input_action")

    @_builtins.property
    @pulumi.getter(name="inputEnabled")
    def input_enabled(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to enable guardrail evaluation on the intput. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        return pulumi.get(self, "input_enabled")

    @_builtins.property
    @pulumi.getter(name="outputAction")
    def output_action(self) -> Optional['GuardrailWordAction']:
        """
        Specifies the action to take when harmful content is detected in the output. Supported values include:

        - `BLOCK`  Block the content and replace it with blocked messaging.
        - `NONE`  Take no action but return detection information in the trace response.
        """
        return pulumi.get(self, "output_action")

    @_builtins.property
    @pulumi.getter(name="outputEnabled")
    def output_enabled(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to enable guardrail evaluation on the output. When disabled, you aren't charged for the evaluation. The evaluation doesn't appear in the response.
        """
        return pulumi.get(self, "output_enabled")


@pulumi.output_type
class GuardrailWordPolicyConfig(dict):
    """
    Word policy config for a guardrail.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managedWordListsConfig":
            suggest = "managed_word_lists_config"
        elif key == "wordsConfig":
            suggest = "words_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardrailWordPolicyConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardrailWordPolicyConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardrailWordPolicyConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 managed_word_lists_config: Optional[Sequence['outputs.GuardrailManagedWordsConfig']] = None,
                 words_config: Optional[Sequence['outputs.GuardrailWordConfig']] = None):
        """
        Word policy config for a guardrail.
        :param Sequence['GuardrailManagedWordsConfig'] managed_word_lists_config: A config for the list of managed words.
        :param Sequence['GuardrailWordConfig'] words_config: List of custom word configs.
        """
        if managed_word_lists_config is not None:
            pulumi.set(__self__, "managed_word_lists_config", managed_word_lists_config)
        if words_config is not None:
            pulumi.set(__self__, "words_config", words_config)

    @_builtins.property
    @pulumi.getter(name="managedWordListsConfig")
    def managed_word_lists_config(self) -> Optional[Sequence['outputs.GuardrailManagedWordsConfig']]:
        """
        A config for the list of managed words.
        """
        return pulumi.get(self, "managed_word_lists_config")

    @_builtins.property
    @pulumi.getter(name="wordsConfig")
    def words_config(self) -> Optional[Sequence['outputs.GuardrailWordConfig']]:
        """
        List of custom word configs.
        """
        return pulumi.get(self, "words_config")


@pulumi.output_type
class IntelligentPromptRouterPromptRouterTargetModel(dict):
    """
    Model configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "modelArn":
            suggest = "model_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntelligentPromptRouterPromptRouterTargetModel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntelligentPromptRouterPromptRouterTargetModel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntelligentPromptRouterPromptRouterTargetModel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 model_arn: _builtins.str):
        """
        Model configuration
        :param _builtins.str model_arn: Arn of underlying model which are added in the Prompt Router.
        """
        pulumi.set(__self__, "model_arn", model_arn)

    @_builtins.property
    @pulumi.getter(name="modelArn")
    def model_arn(self) -> _builtins.str:
        """
        Arn of underlying model which are added in the Prompt Router.
        """
        return pulumi.get(self, "model_arn")


@pulumi.output_type
class IntelligentPromptRouterRoutingCriteria(dict):
    """
    Represents the criteria used for routing requests.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "responseQualityDifference":
            suggest = "response_quality_difference"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntelligentPromptRouterRoutingCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntelligentPromptRouterRoutingCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntelligentPromptRouterRoutingCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 response_quality_difference: _builtins.float):
        """
        Represents the criteria used for routing requests.
        :param _builtins.float response_quality_difference: The criteria's response quality difference.
        """
        pulumi.set(__self__, "response_quality_difference", response_quality_difference)

    @_builtins.property
    @pulumi.getter(name="responseQualityDifference")
    def response_quality_difference(self) -> _builtins.float:
        """
        The criteria's response quality difference.
        """
        return pulumi.get(self, "response_quality_difference")


@pulumi.output_type
class KnowledgeBaseBedrockEmbeddingModelConfiguration(dict):
    """
    The vector configuration details for the Bedrock embeddings model.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "embeddingDataType":
            suggest = "embedding_data_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseBedrockEmbeddingModelConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseBedrockEmbeddingModelConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseBedrockEmbeddingModelConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dimensions: Optional[_builtins.int] = None,
                 embedding_data_type: Optional['KnowledgeBaseBedrockEmbeddingModelConfigurationEmbeddingDataType'] = None):
        """
        The vector configuration details for the Bedrock embeddings model.
        :param _builtins.int dimensions: The dimensions details for the vector configuration used on the Bedrock embeddings model.
        :param 'KnowledgeBaseBedrockEmbeddingModelConfigurationEmbeddingDataType' embedding_data_type: The data type for the vectors when using a model to convert text into vector embeddings.
        """
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if embedding_data_type is not None:
            pulumi.set(__self__, "embedding_data_type", embedding_data_type)

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional[_builtins.int]:
        """
        The dimensions details for the vector configuration used on the Bedrock embeddings model.
        """
        return pulumi.get(self, "dimensions")

    @_builtins.property
    @pulumi.getter(name="embeddingDataType")
    def embedding_data_type(self) -> Optional['KnowledgeBaseBedrockEmbeddingModelConfigurationEmbeddingDataType']:
        """
        The data type for the vectors when using a model to convert text into vector embeddings.
        """
        return pulumi.get(self, "embedding_data_type")


@pulumi.output_type
class KnowledgeBaseConfiguration(dict):
    """
    Contains details about the embeddings model used for the knowledge base.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kendraKnowledgeBaseConfiguration":
            suggest = "kendra_knowledge_base_configuration"
        elif key == "sqlKnowledgeBaseConfiguration":
            suggest = "sql_knowledge_base_configuration"
        elif key == "vectorKnowledgeBaseConfiguration":
            suggest = "vector_knowledge_base_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: 'KnowledgeBaseType',
                 kendra_knowledge_base_configuration: Optional['outputs.KnowledgeBaseKendraKnowledgeBaseConfiguration'] = None,
                 sql_knowledge_base_configuration: Optional['outputs.KnowledgeBaseSqlKnowledgeBaseConfiguration'] = None,
                 vector_knowledge_base_configuration: Optional['outputs.KnowledgeBaseVectorKnowledgeBaseConfiguration'] = None):
        """
        Contains details about the embeddings model used for the knowledge base.
        :param 'KnowledgeBaseType' type: The type of data that the data source is converted into for the knowledge base.
        :param 'KnowledgeBaseKendraKnowledgeBaseConfiguration' kendra_knowledge_base_configuration: Settings for an Amazon Kendra knowledge base.
        :param 'KnowledgeBaseSqlKnowledgeBaseConfiguration' sql_knowledge_base_configuration: Specifies configurations for a knowledge base connected to an SQL database.
        :param 'KnowledgeBaseVectorKnowledgeBaseConfiguration' vector_knowledge_base_configuration: Contains details about the model that's used to convert the data source into vector embeddings.
        """
        pulumi.set(__self__, "type", type)
        if kendra_knowledge_base_configuration is not None:
            pulumi.set(__self__, "kendra_knowledge_base_configuration", kendra_knowledge_base_configuration)
        if sql_knowledge_base_configuration is not None:
            pulumi.set(__self__, "sql_knowledge_base_configuration", sql_knowledge_base_configuration)
        if vector_knowledge_base_configuration is not None:
            pulumi.set(__self__, "vector_knowledge_base_configuration", vector_knowledge_base_configuration)

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'KnowledgeBaseType':
        """
        The type of data that the data source is converted into for the knowledge base.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="kendraKnowledgeBaseConfiguration")
    def kendra_knowledge_base_configuration(self) -> Optional['outputs.KnowledgeBaseKendraKnowledgeBaseConfiguration']:
        """
        Settings for an Amazon Kendra knowledge base.
        """
        return pulumi.get(self, "kendra_knowledge_base_configuration")

    @_builtins.property
    @pulumi.getter(name="sqlKnowledgeBaseConfiguration")
    def sql_knowledge_base_configuration(self) -> Optional['outputs.KnowledgeBaseSqlKnowledgeBaseConfiguration']:
        """
        Specifies configurations for a knowledge base connected to an SQL database.
        """
        return pulumi.get(self, "sql_knowledge_base_configuration")

    @_builtins.property
    @pulumi.getter(name="vectorKnowledgeBaseConfiguration")
    def vector_knowledge_base_configuration(self) -> Optional['outputs.KnowledgeBaseVectorKnowledgeBaseConfiguration']:
        """
        Contains details about the model that's used to convert the data source into vector embeddings.
        """
        return pulumi.get(self, "vector_knowledge_base_configuration")


@pulumi.output_type
class KnowledgeBaseCuratedQuery(dict):
    """
    Curated query or question and answer pair
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "naturalLanguage":
            suggest = "natural_language"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseCuratedQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseCuratedQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseCuratedQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 natural_language: _builtins.str,
                 sql: _builtins.str):
        """
        Curated query or question and answer pair
        """
        pulumi.set(__self__, "natural_language", natural_language)
        pulumi.set(__self__, "sql", sql)

    @_builtins.property
    @pulumi.getter(name="naturalLanguage")
    def natural_language(self) -> _builtins.str:
        return pulumi.get(self, "natural_language")

    @_builtins.property
    @pulumi.getter
    def sql(self) -> _builtins.str:
        return pulumi.get(self, "sql")


@pulumi.output_type
class KnowledgeBaseEmbeddingModelConfiguration(dict):
    """
    The embeddings model configuration details for the vector model used in Knowledge Base.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bedrockEmbeddingModelConfiguration":
            suggest = "bedrock_embedding_model_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseEmbeddingModelConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseEmbeddingModelConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseEmbeddingModelConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bedrock_embedding_model_configuration: Optional['outputs.KnowledgeBaseBedrockEmbeddingModelConfiguration'] = None):
        """
        The embeddings model configuration details for the vector model used in Knowledge Base.
        :param 'KnowledgeBaseBedrockEmbeddingModelConfiguration' bedrock_embedding_model_configuration: The vector configuration details on the Bedrock embeddings model.
        """
        if bedrock_embedding_model_configuration is not None:
            pulumi.set(__self__, "bedrock_embedding_model_configuration", bedrock_embedding_model_configuration)

    @_builtins.property
    @pulumi.getter(name="bedrockEmbeddingModelConfiguration")
    def bedrock_embedding_model_configuration(self) -> Optional['outputs.KnowledgeBaseBedrockEmbeddingModelConfiguration']:
        """
        The vector configuration details on the Bedrock embeddings model.
        """
        return pulumi.get(self, "bedrock_embedding_model_configuration")


@pulumi.output_type
class KnowledgeBaseKendraKnowledgeBaseConfiguration(dict):
    """
    Configurations for a Kendra knowledge base
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kendraIndexArn":
            suggest = "kendra_index_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseKendraKnowledgeBaseConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseKendraKnowledgeBaseConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseKendraKnowledgeBaseConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kendra_index_arn: _builtins.str):
        """
        Configurations for a Kendra knowledge base
        :param _builtins.str kendra_index_arn: The ARN of the Amazon Kendra index.
        """
        pulumi.set(__self__, "kendra_index_arn", kendra_index_arn)

    @_builtins.property
    @pulumi.getter(name="kendraIndexArn")
    def kendra_index_arn(self) -> _builtins.str:
        """
        The ARN of the Amazon Kendra index.
        """
        return pulumi.get(self, "kendra_index_arn")


@pulumi.output_type
class KnowledgeBaseMongoDbAtlasConfiguration(dict):
    """
    Contains the storage configuration of the knowledge base in MongoDb Atlas Cloud.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "collectionName":
            suggest = "collection_name"
        elif key == "credentialsSecretArn":
            suggest = "credentials_secret_arn"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "fieldMapping":
            suggest = "field_mapping"
        elif key == "vectorIndexName":
            suggest = "vector_index_name"
        elif key == "endpointServiceName":
            suggest = "endpoint_service_name"
        elif key == "textIndexName":
            suggest = "text_index_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseMongoDbAtlasConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseMongoDbAtlasConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseMongoDbAtlasConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collection_name: _builtins.str,
                 credentials_secret_arn: _builtins.str,
                 database_name: _builtins.str,
                 endpoint: _builtins.str,
                 field_mapping: 'outputs.KnowledgeBaseMongoDbAtlasFieldMapping',
                 vector_index_name: _builtins.str,
                 endpoint_service_name: Optional[_builtins.str] = None,
                 text_index_name: Optional[_builtins.str] = None):
        """
        Contains the storage configuration of the knowledge base in MongoDb Atlas Cloud.
        :param _builtins.str collection_name: Name of the collection within MongoDB Atlas.
        :param _builtins.str credentials_secret_arn: The ARN of the secret that you created in AWS Secrets Manager that is linked to your Amazon Mongo database.
        :param _builtins.str database_name: Name of the database within MongoDB Atlas.
        :param _builtins.str endpoint: MongoDB Atlas endpoint.
        :param 'KnowledgeBaseMongoDbAtlasFieldMapping' field_mapping: Contains the names of the fields to which to map information about the vector store.
        :param _builtins.str vector_index_name: Name of a MongoDB Atlas index.
        :param _builtins.str endpoint_service_name: MongoDB Atlas endpoint service name.
        :param _builtins.str text_index_name: Name of a MongoDB Atlas text index.
        """
        pulumi.set(__self__, "collection_name", collection_name)
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "field_mapping", field_mapping)
        pulumi.set(__self__, "vector_index_name", vector_index_name)
        if endpoint_service_name is not None:
            pulumi.set(__self__, "endpoint_service_name", endpoint_service_name)
        if text_index_name is not None:
            pulumi.set(__self__, "text_index_name", text_index_name)

    @_builtins.property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> _builtins.str:
        """
        Name of the collection within MongoDB Atlas.
        """
        return pulumi.get(self, "collection_name")

    @_builtins.property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> _builtins.str:
        """
        The ARN of the secret that you created in AWS Secrets Manager that is linked to your Amazon Mongo database.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        """
        Name of the database within MongoDB Atlas.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        MongoDB Atlas endpoint.
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> 'outputs.KnowledgeBaseMongoDbAtlasFieldMapping':
        """
        Contains the names of the fields to which to map information about the vector store.
        """
        return pulumi.get(self, "field_mapping")

    @_builtins.property
    @pulumi.getter(name="vectorIndexName")
    def vector_index_name(self) -> _builtins.str:
        """
        Name of a MongoDB Atlas index.
        """
        return pulumi.get(self, "vector_index_name")

    @_builtins.property
    @pulumi.getter(name="endpointServiceName")
    def endpoint_service_name(self) -> Optional[_builtins.str]:
        """
        MongoDB Atlas endpoint service name.
        """
        return pulumi.get(self, "endpoint_service_name")

    @_builtins.property
    @pulumi.getter(name="textIndexName")
    def text_index_name(self) -> Optional[_builtins.str]:
        """
        Name of a MongoDB Atlas text index.
        """
        return pulumi.get(self, "text_index_name")


@pulumi.output_type
class KnowledgeBaseMongoDbAtlasFieldMapping(dict):
    """
    Contains the names of the fields to which to map information about the vector store.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metadataField":
            suggest = "metadata_field"
        elif key == "textField":
            suggest = "text_field"
        elif key == "vectorField":
            suggest = "vector_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseMongoDbAtlasFieldMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseMongoDbAtlasFieldMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseMongoDbAtlasFieldMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metadata_field: _builtins.str,
                 text_field: _builtins.str,
                 vector_field: _builtins.str):
        """
        Contains the names of the fields to which to map information about the vector store.
        :param _builtins.str metadata_field: The name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param _builtins.str text_field: The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        :param _builtins.str vector_field: The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        pulumi.set(__self__, "metadata_field", metadata_field)
        pulumi.set(__self__, "text_field", text_field)
        pulumi.set(__self__, "vector_field", vector_field)

    @_builtins.property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> _builtins.str:
        """
        The name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @_builtins.property
    @pulumi.getter(name="textField")
    def text_field(self) -> _builtins.str:
        """
        The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")

    @_builtins.property
    @pulumi.getter(name="vectorField")
    def vector_field(self) -> _builtins.str:
        """
        The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        return pulumi.get(self, "vector_field")


@pulumi.output_type
class KnowledgeBaseNeptuneAnalyticsConfiguration(dict):
    """
    Contains the configurations to use Neptune Analytics as Vector Store.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldMapping":
            suggest = "field_mapping"
        elif key == "graphArn":
            suggest = "graph_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseNeptuneAnalyticsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseNeptuneAnalyticsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseNeptuneAnalyticsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_mapping: 'outputs.KnowledgeBaseNeptuneAnalyticsFieldMapping',
                 graph_arn: _builtins.str):
        """
        Contains the configurations to use Neptune Analytics as Vector Store.
        :param 'KnowledgeBaseNeptuneAnalyticsFieldMapping' field_mapping: Contains the names of the fields to which to map information about the vector store.
        :param _builtins.str graph_arn: ARN for Neptune Analytics graph database.
        """
        pulumi.set(__self__, "field_mapping", field_mapping)
        pulumi.set(__self__, "graph_arn", graph_arn)

    @_builtins.property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> 'outputs.KnowledgeBaseNeptuneAnalyticsFieldMapping':
        """
        Contains the names of the fields to which to map information about the vector store.
        """
        return pulumi.get(self, "field_mapping")

    @_builtins.property
    @pulumi.getter(name="graphArn")
    def graph_arn(self) -> _builtins.str:
        """
        ARN for Neptune Analytics graph database.
        """
        return pulumi.get(self, "graph_arn")


@pulumi.output_type
class KnowledgeBaseNeptuneAnalyticsFieldMapping(dict):
    """
    A mapping of Bedrock Knowledge Base fields to Neptune Analytics fields.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metadataField":
            suggest = "metadata_field"
        elif key == "textField":
            suggest = "text_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseNeptuneAnalyticsFieldMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseNeptuneAnalyticsFieldMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseNeptuneAnalyticsFieldMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metadata_field: _builtins.str,
                 text_field: _builtins.str):
        """
        A mapping of Bedrock Knowledge Base fields to Neptune Analytics fields.
        :param _builtins.str metadata_field: The name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param _builtins.str text_field: The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        pulumi.set(__self__, "metadata_field", metadata_field)
        pulumi.set(__self__, "text_field", text_field)

    @_builtins.property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> _builtins.str:
        """
        The name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @_builtins.property
    @pulumi.getter(name="textField")
    def text_field(self) -> _builtins.str:
        """
        The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")


@pulumi.output_type
class KnowledgeBaseOpenSearchManagedClusterConfiguration(dict):
    """
    Contains the storage configuration of the knowledge base in Amazon OpenSearch Service.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "domainArn":
            suggest = "domain_arn"
        elif key == "domainEndpoint":
            suggest = "domain_endpoint"
        elif key == "fieldMapping":
            suggest = "field_mapping"
        elif key == "vectorIndexName":
            suggest = "vector_index_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseOpenSearchManagedClusterConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseOpenSearchManagedClusterConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseOpenSearchManagedClusterConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain_arn: _builtins.str,
                 domain_endpoint: _builtins.str,
                 field_mapping: 'outputs.KnowledgeBaseOpenSearchManagedClusterFieldMapping',
                 vector_index_name: _builtins.str):
        """
        Contains the storage configuration of the knowledge base in Amazon OpenSearch Service.
        :param _builtins.str domain_arn: The Amazon Resource Name (ARN) of the OpenSearch domain.
        :param _builtins.str domain_endpoint: The endpoint URL the OpenSearch domain.
        :param 'KnowledgeBaseOpenSearchManagedClusterFieldMapping' field_mapping: Contains the names of the fields to which to map information about the vector store.
        :param _builtins.str vector_index_name: The name of the vector store.
        """
        pulumi.set(__self__, "domain_arn", domain_arn)
        pulumi.set(__self__, "domain_endpoint", domain_endpoint)
        pulumi.set(__self__, "field_mapping", field_mapping)
        pulumi.set(__self__, "vector_index_name", vector_index_name)

    @_builtins.property
    @pulumi.getter(name="domainArn")
    def domain_arn(self) -> _builtins.str:
        """
        The Amazon Resource Name (ARN) of the OpenSearch domain.
        """
        return pulumi.get(self, "domain_arn")

    @_builtins.property
    @pulumi.getter(name="domainEndpoint")
    def domain_endpoint(self) -> _builtins.str:
        """
        The endpoint URL the OpenSearch domain.
        """
        return pulumi.get(self, "domain_endpoint")

    @_builtins.property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> 'outputs.KnowledgeBaseOpenSearchManagedClusterFieldMapping':
        """
        Contains the names of the fields to which to map information about the vector store.
        """
        return pulumi.get(self, "field_mapping")

    @_builtins.property
    @pulumi.getter(name="vectorIndexName")
    def vector_index_name(self) -> _builtins.str:
        """
        The name of the vector store.
        """
        return pulumi.get(self, "vector_index_name")


@pulumi.output_type
class KnowledgeBaseOpenSearchManagedClusterFieldMapping(dict):
    """
    A mapping of Bedrock Knowledge Base fields to OpenSearch Managed Cluster field names
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metadataField":
            suggest = "metadata_field"
        elif key == "textField":
            suggest = "text_field"
        elif key == "vectorField":
            suggest = "vector_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseOpenSearchManagedClusterFieldMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseOpenSearchManagedClusterFieldMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseOpenSearchManagedClusterFieldMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metadata_field: _builtins.str,
                 text_field: _builtins.str,
                 vector_field: _builtins.str):
        """
        A mapping of Bedrock Knowledge Base fields to OpenSearch Managed Cluster field names
        :param _builtins.str metadata_field: The name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param _builtins.str text_field: The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        :param _builtins.str vector_field: The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        pulumi.set(__self__, "metadata_field", metadata_field)
        pulumi.set(__self__, "text_field", text_field)
        pulumi.set(__self__, "vector_field", vector_field)

    @_builtins.property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> _builtins.str:
        """
        The name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @_builtins.property
    @pulumi.getter(name="textField")
    def text_field(self) -> _builtins.str:
        """
        The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")

    @_builtins.property
    @pulumi.getter(name="vectorField")
    def vector_field(self) -> _builtins.str:
        """
        The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        return pulumi.get(self, "vector_field")


@pulumi.output_type
class KnowledgeBaseOpenSearchServerlessConfiguration(dict):
    """
    Contains the storage configuration of the knowledge base in Amazon OpenSearch Service.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "collectionArn":
            suggest = "collection_arn"
        elif key == "fieldMapping":
            suggest = "field_mapping"
        elif key == "vectorIndexName":
            suggest = "vector_index_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseOpenSearchServerlessConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseOpenSearchServerlessConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseOpenSearchServerlessConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collection_arn: _builtins.str,
                 field_mapping: 'outputs.KnowledgeBaseOpenSearchServerlessFieldMapping',
                 vector_index_name: _builtins.str):
        """
        Contains the storage configuration of the knowledge base in Amazon OpenSearch Service.
        :param _builtins.str collection_arn: The ARN of the OpenSearch Service vector store.
        :param 'KnowledgeBaseOpenSearchServerlessFieldMapping' field_mapping: Contains the names of the fields to which to map information about the vector store.
        :param _builtins.str vector_index_name: The name of the vector store.
        """
        pulumi.set(__self__, "collection_arn", collection_arn)
        pulumi.set(__self__, "field_mapping", field_mapping)
        pulumi.set(__self__, "vector_index_name", vector_index_name)

    @_builtins.property
    @pulumi.getter(name="collectionArn")
    def collection_arn(self) -> _builtins.str:
        """
        The ARN of the OpenSearch Service vector store.
        """
        return pulumi.get(self, "collection_arn")

    @_builtins.property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> 'outputs.KnowledgeBaseOpenSearchServerlessFieldMapping':
        """
        Contains the names of the fields to which to map information about the vector store.
        """
        return pulumi.get(self, "field_mapping")

    @_builtins.property
    @pulumi.getter(name="vectorIndexName")
    def vector_index_name(self) -> _builtins.str:
        """
        The name of the vector store.
        """
        return pulumi.get(self, "vector_index_name")


@pulumi.output_type
class KnowledgeBaseOpenSearchServerlessFieldMapping(dict):
    """
    A mapping of Bedrock Knowledge Base fields to OpenSearch Serverless field names
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metadataField":
            suggest = "metadata_field"
        elif key == "textField":
            suggest = "text_field"
        elif key == "vectorField":
            suggest = "vector_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseOpenSearchServerlessFieldMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseOpenSearchServerlessFieldMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseOpenSearchServerlessFieldMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metadata_field: _builtins.str,
                 text_field: _builtins.str,
                 vector_field: _builtins.str):
        """
        A mapping of Bedrock Knowledge Base fields to OpenSearch Serverless field names
        :param _builtins.str metadata_field: The name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param _builtins.str text_field: The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        :param _builtins.str vector_field: The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        pulumi.set(__self__, "metadata_field", metadata_field)
        pulumi.set(__self__, "text_field", text_field)
        pulumi.set(__self__, "vector_field", vector_field)

    @_builtins.property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> _builtins.str:
        """
        The name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @_builtins.property
    @pulumi.getter(name="textField")
    def text_field(self) -> _builtins.str:
        """
        The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")

    @_builtins.property
    @pulumi.getter(name="vectorField")
    def vector_field(self) -> _builtins.str:
        """
        The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        return pulumi.get(self, "vector_field")


@pulumi.output_type
class KnowledgeBasePineconeConfiguration(dict):
    """
    Contains the storage configuration of the knowledge base in Pinecone.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionString":
            suggest = "connection_string"
        elif key == "credentialsSecretArn":
            suggest = "credentials_secret_arn"
        elif key == "fieldMapping":
            suggest = "field_mapping"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBasePineconeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBasePineconeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBasePineconeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_string: _builtins.str,
                 credentials_secret_arn: _builtins.str,
                 field_mapping: 'outputs.KnowledgeBasePineconeFieldMapping',
                 namespace: Optional[_builtins.str] = None):
        """
        Contains the storage configuration of the knowledge base in Pinecone.
        :param _builtins.str connection_string: The endpoint URL for your index management page.
        :param _builtins.str credentials_secret_arn: The ARN of the secret that you created in AWS Secrets Manager that is linked to your Pinecone API key.
        :param 'KnowledgeBasePineconeFieldMapping' field_mapping: Contains the names of the fields to which to map information about the vector store.
        :param _builtins.str namespace: The namespace to be used to write new data to your database.
        """
        pulumi.set(__self__, "connection_string", connection_string)
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "field_mapping", field_mapping)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @_builtins.property
    @pulumi.getter(name="connectionString")
    def connection_string(self) -> _builtins.str:
        """
        The endpoint URL for your index management page.
        """
        return pulumi.get(self, "connection_string")

    @_builtins.property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> _builtins.str:
        """
        The ARN of the secret that you created in AWS Secrets Manager that is linked to your Pinecone API key.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @_builtins.property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> 'outputs.KnowledgeBasePineconeFieldMapping':
        """
        Contains the names of the fields to which to map information about the vector store.
        """
        return pulumi.get(self, "field_mapping")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        The namespace to be used to write new data to your database.
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class KnowledgeBasePineconeFieldMapping(dict):
    """
    Contains the names of the fields to which to map information about the vector store.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metadataField":
            suggest = "metadata_field"
        elif key == "textField":
            suggest = "text_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBasePineconeFieldMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBasePineconeFieldMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBasePineconeFieldMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metadata_field: _builtins.str,
                 text_field: _builtins.str):
        """
        Contains the names of the fields to which to map information about the vector store.
        :param _builtins.str metadata_field: The name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param _builtins.str text_field: The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        pulumi.set(__self__, "metadata_field", metadata_field)
        pulumi.set(__self__, "text_field", text_field)

    @_builtins.property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> _builtins.str:
        """
        The name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @_builtins.property
    @pulumi.getter(name="textField")
    def text_field(self) -> _builtins.str:
        """
        The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")


@pulumi.output_type
class KnowledgeBaseQueryGenerationColumn(dict):
    """
    Redshift query generation column
    """
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 inclusion: Optional['KnowledgeBaseInclusionType'] = None,
                 name: Optional[_builtins.str] = None):
        """
        Redshift query generation column
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if inclusion is not None:
            pulumi.set(__self__, "inclusion", inclusion)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def inclusion(self) -> Optional['KnowledgeBaseInclusionType']:
        return pulumi.get(self, "inclusion")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class KnowledgeBaseQueryGenerationConfiguration(dict):
    """
    Configurations for generating Redshift engine queries
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "executionTimeoutSeconds":
            suggest = "execution_timeout_seconds"
        elif key == "generationContext":
            suggest = "generation_context"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseQueryGenerationConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseQueryGenerationConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseQueryGenerationConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 execution_timeout_seconds: Optional[_builtins.int] = None,
                 generation_context: Optional['outputs.KnowledgeBaseQueryGenerationContext'] = None):
        """
        Configurations for generating Redshift engine queries
        :param _builtins.int execution_timeout_seconds: The time after which query generation will time out.
        :param 'KnowledgeBaseQueryGenerationContext' generation_context: Specifies configurations for context to use during query generation.
        """
        if execution_timeout_seconds is not None:
            pulumi.set(__self__, "execution_timeout_seconds", execution_timeout_seconds)
        if generation_context is not None:
            pulumi.set(__self__, "generation_context", generation_context)

    @_builtins.property
    @pulumi.getter(name="executionTimeoutSeconds")
    def execution_timeout_seconds(self) -> Optional[_builtins.int]:
        """
        The time after which query generation will time out.
        """
        return pulumi.get(self, "execution_timeout_seconds")

    @_builtins.property
    @pulumi.getter(name="generationContext")
    def generation_context(self) -> Optional['outputs.KnowledgeBaseQueryGenerationContext']:
        """
        Specifies configurations for context to use during query generation.
        """
        return pulumi.get(self, "generation_context")


@pulumi.output_type
class KnowledgeBaseQueryGenerationContext(dict):
    """
    Context used to improve query generation
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "curatedQueries":
            suggest = "curated_queries"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseQueryGenerationContext. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseQueryGenerationContext.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseQueryGenerationContext.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 curated_queries: Optional[Sequence['outputs.KnowledgeBaseCuratedQuery']] = None,
                 tables: Optional[Sequence['outputs.KnowledgeBaseQueryGenerationTable']] = None):
        """
        Context used to improve query generation
        :param Sequence['KnowledgeBaseCuratedQuery'] curated_queries: An array of objects, each of which defines information about example queries to help the query engine generate appropriate SQL queries.
        :param Sequence['KnowledgeBaseQueryGenerationTable'] tables: An array of objects, each of which defines information about a table in the database.
        """
        if curated_queries is not None:
            pulumi.set(__self__, "curated_queries", curated_queries)
        if tables is not None:
            pulumi.set(__self__, "tables", tables)

    @_builtins.property
    @pulumi.getter(name="curatedQueries")
    def curated_queries(self) -> Optional[Sequence['outputs.KnowledgeBaseCuratedQuery']]:
        """
        An array of objects, each of which defines information about example queries to help the query engine generate appropriate SQL queries.
        """
        return pulumi.get(self, "curated_queries")

    @_builtins.property
    @pulumi.getter
    def tables(self) -> Optional[Sequence['outputs.KnowledgeBaseQueryGenerationTable']]:
        """
        An array of objects, each of which defines information about a table in the database.
        """
        return pulumi.get(self, "tables")


@pulumi.output_type
class KnowledgeBaseQueryGenerationTable(dict):
    """
    Tables used for Redshift query generation context
    """
    def __init__(__self__, *,
                 name: _builtins.str,
                 columns: Optional[Sequence['outputs.KnowledgeBaseQueryGenerationColumn']] = None,
                 description: Optional[_builtins.str] = None,
                 inclusion: Optional['KnowledgeBaseInclusionType'] = None):
        """
        Tables used for Redshift query generation context
        """
        pulumi.set(__self__, "name", name)
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if inclusion is not None:
            pulumi.set(__self__, "inclusion", inclusion)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def columns(self) -> Optional[Sequence['outputs.KnowledgeBaseQueryGenerationColumn']]:
        return pulumi.get(self, "columns")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def inclusion(self) -> Optional['KnowledgeBaseInclusionType']:
        return pulumi.get(self, "inclusion")


@pulumi.output_type
class KnowledgeBaseRdsConfiguration(dict):
    """
    Contains details about the storage configuration of the knowledge base in Amazon RDS. For more information, see Create a vector index in Amazon RDS.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "credentialsSecretArn":
            suggest = "credentials_secret_arn"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "fieldMapping":
            suggest = "field_mapping"
        elif key == "resourceArn":
            suggest = "resource_arn"
        elif key == "tableName":
            suggest = "table_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseRdsConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseRdsConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseRdsConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials_secret_arn: _builtins.str,
                 database_name: _builtins.str,
                 field_mapping: 'outputs.KnowledgeBaseRdsFieldMapping',
                 resource_arn: _builtins.str,
                 table_name: _builtins.str):
        """
        Contains details about the storage configuration of the knowledge base in Amazon RDS. For more information, see Create a vector index in Amazon RDS.
        :param _builtins.str credentials_secret_arn: The ARN of the secret that you created in AWS Secrets Manager that is linked to your Amazon RDS database.
        :param _builtins.str database_name: The name of your Amazon RDS database.
        :param 'KnowledgeBaseRdsFieldMapping' field_mapping: Contains the names of the fields to which to map information about the vector store.
        :param _builtins.str resource_arn: The ARN of the vector store.
        :param _builtins.str table_name: The name of the table in the database.
        """
        pulumi.set(__self__, "credentials_secret_arn", credentials_secret_arn)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "field_mapping", field_mapping)
        pulumi.set(__self__, "resource_arn", resource_arn)
        pulumi.set(__self__, "table_name", table_name)

    @_builtins.property
    @pulumi.getter(name="credentialsSecretArn")
    def credentials_secret_arn(self) -> _builtins.str:
        """
        The ARN of the secret that you created in AWS Secrets Manager that is linked to your Amazon RDS database.
        """
        return pulumi.get(self, "credentials_secret_arn")

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        """
        The name of your Amazon RDS database.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="fieldMapping")
    def field_mapping(self) -> 'outputs.KnowledgeBaseRdsFieldMapping':
        """
        Contains the names of the fields to which to map information about the vector store.
        """
        return pulumi.get(self, "field_mapping")

    @_builtins.property
    @pulumi.getter(name="resourceArn")
    def resource_arn(self) -> _builtins.str:
        """
        The ARN of the vector store.
        """
        return pulumi.get(self, "resource_arn")

    @_builtins.property
    @pulumi.getter(name="tableName")
    def table_name(self) -> _builtins.str:
        """
        The name of the table in the database.
        """
        return pulumi.get(self, "table_name")


@pulumi.output_type
class KnowledgeBaseRdsFieldMapping(dict):
    """
    Contains the names of the fields to which to map information about the vector store.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metadataField":
            suggest = "metadata_field"
        elif key == "primaryKeyField":
            suggest = "primary_key_field"
        elif key == "textField":
            suggest = "text_field"
        elif key == "vectorField":
            suggest = "vector_field"
        elif key == "customMetadataField":
            suggest = "custom_metadata_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseRdsFieldMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseRdsFieldMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseRdsFieldMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metadata_field: _builtins.str,
                 primary_key_field: _builtins.str,
                 text_field: _builtins.str,
                 vector_field: _builtins.str,
                 custom_metadata_field: Optional[_builtins.str] = None):
        """
        Contains the names of the fields to which to map information about the vector store.
        :param _builtins.str metadata_field: The name of the field in which Amazon Bedrock stores metadata about the vector store.
        :param _builtins.str primary_key_field: The name of the field in which Amazon Bedrock stores the ID for each entry.
        :param _builtins.str text_field: The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        :param _builtins.str vector_field: The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        :param _builtins.str custom_metadata_field: The name of the field in which Amazon Bedrock stores custom metadata about the vector store.
        """
        pulumi.set(__self__, "metadata_field", metadata_field)
        pulumi.set(__self__, "primary_key_field", primary_key_field)
        pulumi.set(__self__, "text_field", text_field)
        pulumi.set(__self__, "vector_field", vector_field)
        if custom_metadata_field is not None:
            pulumi.set(__self__, "custom_metadata_field", custom_metadata_field)

    @_builtins.property
    @pulumi.getter(name="metadataField")
    def metadata_field(self) -> _builtins.str:
        """
        The name of the field in which Amazon Bedrock stores metadata about the vector store.
        """
        return pulumi.get(self, "metadata_field")

    @_builtins.property
    @pulumi.getter(name="primaryKeyField")
    def primary_key_field(self) -> _builtins.str:
        """
        The name of the field in which Amazon Bedrock stores the ID for each entry.
        """
        return pulumi.get(self, "primary_key_field")

    @_builtins.property
    @pulumi.getter(name="textField")
    def text_field(self) -> _builtins.str:
        """
        The name of the field in which Amazon Bedrock stores the raw text from your data. The text is split according to the chunking strategy you choose.
        """
        return pulumi.get(self, "text_field")

    @_builtins.property
    @pulumi.getter(name="vectorField")
    def vector_field(self) -> _builtins.str:
        """
        The name of the field in which Amazon Bedrock stores the vector embeddings for your data sources.
        """
        return pulumi.get(self, "vector_field")

    @_builtins.property
    @pulumi.getter(name="customMetadataField")
    def custom_metadata_field(self) -> Optional[_builtins.str]:
        """
        The name of the field in which Amazon Bedrock stores custom metadata about the vector store.
        """
        return pulumi.get(self, "custom_metadata_field")


@pulumi.output_type
class KnowledgeBaseRedshiftConfiguration(dict):
    """
    Configurations for a Redshift knowledge base
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryEngineConfiguration":
            suggest = "query_engine_configuration"
        elif key == "storageConfigurations":
            suggest = "storage_configurations"
        elif key == "queryGenerationConfiguration":
            suggest = "query_generation_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseRedshiftConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseRedshiftConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseRedshiftConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query_engine_configuration: 'outputs.KnowledgeBaseRedshiftQueryEngineConfiguration',
                 storage_configurations: Sequence['outputs.KnowledgeBaseRedshiftQueryEngineStorageConfiguration'],
                 query_generation_configuration: Optional['outputs.KnowledgeBaseQueryGenerationConfiguration'] = None):
        """
        Configurations for a Redshift knowledge base
        :param 'KnowledgeBaseRedshiftQueryEngineConfiguration' query_engine_configuration: Specifies configurations for an Amazon Redshift query engine.
        :param Sequence['KnowledgeBaseRedshiftQueryEngineStorageConfiguration'] storage_configurations: Specifies configurations for Amazon Redshift database storage.
        :param 'KnowledgeBaseQueryGenerationConfiguration' query_generation_configuration: Specifies configurations for generating queries.
        """
        pulumi.set(__self__, "query_engine_configuration", query_engine_configuration)
        pulumi.set(__self__, "storage_configurations", storage_configurations)
        if query_generation_configuration is not None:
            pulumi.set(__self__, "query_generation_configuration", query_generation_configuration)

    @_builtins.property
    @pulumi.getter(name="queryEngineConfiguration")
    def query_engine_configuration(self) -> 'outputs.KnowledgeBaseRedshiftQueryEngineConfiguration':
        """
        Specifies configurations for an Amazon Redshift query engine.
        """
        return pulumi.get(self, "query_engine_configuration")

    @_builtins.property
    @pulumi.getter(name="storageConfigurations")
    def storage_configurations(self) -> Sequence['outputs.KnowledgeBaseRedshiftQueryEngineStorageConfiguration']:
        """
        Specifies configurations for Amazon Redshift database storage.
        """
        return pulumi.get(self, "storage_configurations")

    @_builtins.property
    @pulumi.getter(name="queryGenerationConfiguration")
    def query_generation_configuration(self) -> Optional['outputs.KnowledgeBaseQueryGenerationConfiguration']:
        """
        Specifies configurations for generating queries.
        """
        return pulumi.get(self, "query_generation_configuration")


@pulumi.output_type
class KnowledgeBaseRedshiftProvisionedAuthConfiguration(dict):
    """
    Configurations for Redshift query engine provisioned auth setup
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseUser":
            suggest = "database_user"
        elif key == "usernamePasswordSecretArn":
            suggest = "username_password_secret_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseRedshiftProvisionedAuthConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseRedshiftProvisionedAuthConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseRedshiftProvisionedAuthConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: 'KnowledgeBaseRedshiftProvisionedAuthType',
                 database_user: Optional[_builtins.str] = None,
                 username_password_secret_arn: Optional[_builtins.str] = None):
        """
        Configurations for Redshift query engine provisioned auth setup
        :param 'KnowledgeBaseRedshiftProvisionedAuthType' type: The type of authentication to use.
        :param _builtins.str database_user: Redshift database user
        :param _builtins.str username_password_secret_arn: The ARN of an Secrets Manager secret for authentication.
        """
        pulumi.set(__self__, "type", type)
        if database_user is not None:
            pulumi.set(__self__, "database_user", database_user)
        if username_password_secret_arn is not None:
            pulumi.set(__self__, "username_password_secret_arn", username_password_secret_arn)

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'KnowledgeBaseRedshiftProvisionedAuthType':
        """
        The type of authentication to use.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="databaseUser")
    def database_user(self) -> Optional[_builtins.str]:
        """
        Redshift database user
        """
        return pulumi.get(self, "database_user")

    @_builtins.property
    @pulumi.getter(name="usernamePasswordSecretArn")
    def username_password_secret_arn(self) -> Optional[_builtins.str]:
        """
        The ARN of an Secrets Manager secret for authentication.
        """
        return pulumi.get(self, "username_password_secret_arn")


@pulumi.output_type
class KnowledgeBaseRedshiftProvisionedConfiguration(dict):
    """
    Configurations for provisioned Redshift query engine
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authConfiguration":
            suggest = "auth_configuration"
        elif key == "clusterIdentifier":
            suggest = "cluster_identifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseRedshiftProvisionedConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseRedshiftProvisionedConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseRedshiftProvisionedConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_configuration: 'outputs.KnowledgeBaseRedshiftProvisionedAuthConfiguration',
                 cluster_identifier: _builtins.str):
        """
        Configurations for provisioned Redshift query engine
        :param 'KnowledgeBaseRedshiftProvisionedAuthConfiguration' auth_configuration: Specifies configurations for authentication to Amazon Redshift.
        :param _builtins.str cluster_identifier: The ID of the Amazon Redshift cluster.
        """
        pulumi.set(__self__, "auth_configuration", auth_configuration)
        pulumi.set(__self__, "cluster_identifier", cluster_identifier)

    @_builtins.property
    @pulumi.getter(name="authConfiguration")
    def auth_configuration(self) -> 'outputs.KnowledgeBaseRedshiftProvisionedAuthConfiguration':
        """
        Specifies configurations for authentication to Amazon Redshift.
        """
        return pulumi.get(self, "auth_configuration")

    @_builtins.property
    @pulumi.getter(name="clusterIdentifier")
    def cluster_identifier(self) -> _builtins.str:
        """
        The ID of the Amazon Redshift cluster.
        """
        return pulumi.get(self, "cluster_identifier")


@pulumi.output_type
class KnowledgeBaseRedshiftQueryEngineAwsDataCatalogStorageConfiguration(dict):
    """
    Configurations for Redshift query engine AWS Data Catalog backed storage
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tableNames":
            suggest = "table_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseRedshiftQueryEngineAwsDataCatalogStorageConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseRedshiftQueryEngineAwsDataCatalogStorageConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseRedshiftQueryEngineAwsDataCatalogStorageConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 table_names: Sequence[_builtins.str]):
        """
        Configurations for Redshift query engine AWS Data Catalog backed storage
        """
        pulumi.set(__self__, "table_names", table_names)

    @_builtins.property
    @pulumi.getter(name="tableNames")
    def table_names(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "table_names")


@pulumi.output_type
class KnowledgeBaseRedshiftQueryEngineConfiguration(dict):
    """
    Configurations for Redshift query engine
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "provisionedConfiguration":
            suggest = "provisioned_configuration"
        elif key == "serverlessConfiguration":
            suggest = "serverless_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseRedshiftQueryEngineConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseRedshiftQueryEngineConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseRedshiftQueryEngineConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: 'KnowledgeBaseRedshiftQueryEngineType',
                 provisioned_configuration: Optional['outputs.KnowledgeBaseRedshiftProvisionedConfiguration'] = None,
                 serverless_configuration: Optional['outputs.KnowledgeBaseRedshiftServerlessConfiguration'] = None):
        """
        Configurations for Redshift query engine
        :param 'KnowledgeBaseRedshiftQueryEngineType' type: The type of query engine.
        :param 'KnowledgeBaseRedshiftProvisionedConfiguration' provisioned_configuration: Specifies configurations for a provisioned Amazon Redshift query engine.
        :param 'KnowledgeBaseRedshiftServerlessConfiguration' serverless_configuration: Specifies configurations for a serverless Amazon Redshift query engine.
        """
        pulumi.set(__self__, "type", type)
        if provisioned_configuration is not None:
            pulumi.set(__self__, "provisioned_configuration", provisioned_configuration)
        if serverless_configuration is not None:
            pulumi.set(__self__, "serverless_configuration", serverless_configuration)

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'KnowledgeBaseRedshiftQueryEngineType':
        """
        The type of query engine.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="provisionedConfiguration")
    def provisioned_configuration(self) -> Optional['outputs.KnowledgeBaseRedshiftProvisionedConfiguration']:
        """
        Specifies configurations for a provisioned Amazon Redshift query engine.
        """
        return pulumi.get(self, "provisioned_configuration")

    @_builtins.property
    @pulumi.getter(name="serverlessConfiguration")
    def serverless_configuration(self) -> Optional['outputs.KnowledgeBaseRedshiftServerlessConfiguration']:
        """
        Specifies configurations for a serverless Amazon Redshift query engine.
        """
        return pulumi.get(self, "serverless_configuration")


@pulumi.output_type
class KnowledgeBaseRedshiftQueryEngineRedshiftStorageConfiguration(dict):
    """
    Configurations for Redshift query engine Redshift backed storage
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseRedshiftQueryEngineRedshiftStorageConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseRedshiftQueryEngineRedshiftStorageConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseRedshiftQueryEngineRedshiftStorageConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: _builtins.str):
        """
        Configurations for Redshift query engine Redshift backed storage
        """
        pulumi.set(__self__, "database_name", database_name)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        return pulumi.get(self, "database_name")


@pulumi.output_type
class KnowledgeBaseRedshiftQueryEngineStorageConfiguration(dict):
    """
    Configurations for available Redshift query engine storage types
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsDataCatalogConfiguration":
            suggest = "aws_data_catalog_configuration"
        elif key == "redshiftConfiguration":
            suggest = "redshift_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseRedshiftQueryEngineStorageConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseRedshiftQueryEngineStorageConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseRedshiftQueryEngineStorageConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: 'KnowledgeBaseRedshiftQueryEngineStorageType',
                 aws_data_catalog_configuration: Optional['outputs.KnowledgeBaseRedshiftQueryEngineAwsDataCatalogStorageConfiguration'] = None,
                 redshift_configuration: Optional['outputs.KnowledgeBaseRedshiftQueryEngineRedshiftStorageConfiguration'] = None):
        """
        Configurations for available Redshift query engine storage types
        """
        pulumi.set(__self__, "type", type)
        if aws_data_catalog_configuration is not None:
            pulumi.set(__self__, "aws_data_catalog_configuration", aws_data_catalog_configuration)
        if redshift_configuration is not None:
            pulumi.set(__self__, "redshift_configuration", redshift_configuration)

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'KnowledgeBaseRedshiftQueryEngineStorageType':
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="awsDataCatalogConfiguration")
    def aws_data_catalog_configuration(self) -> Optional['outputs.KnowledgeBaseRedshiftQueryEngineAwsDataCatalogStorageConfiguration']:
        return pulumi.get(self, "aws_data_catalog_configuration")

    @_builtins.property
    @pulumi.getter(name="redshiftConfiguration")
    def redshift_configuration(self) -> Optional['outputs.KnowledgeBaseRedshiftQueryEngineRedshiftStorageConfiguration']:
        return pulumi.get(self, "redshift_configuration")


@pulumi.output_type
class KnowledgeBaseRedshiftServerlessAuthConfiguration(dict):
    """
    Configurations for Redshift query engine serverless auth setup
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "usernamePasswordSecretArn":
            suggest = "username_password_secret_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseRedshiftServerlessAuthConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseRedshiftServerlessAuthConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseRedshiftServerlessAuthConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: 'KnowledgeBaseRedshiftServerlessAuthType',
                 username_password_secret_arn: Optional[_builtins.str] = None):
        """
        Configurations for Redshift query engine serverless auth setup
        :param 'KnowledgeBaseRedshiftServerlessAuthType' type: The type of authentication to use.
        :param _builtins.str username_password_secret_arn: The ARN of an Secrets Manager secret for authentication.
        """
        pulumi.set(__self__, "type", type)
        if username_password_secret_arn is not None:
            pulumi.set(__self__, "username_password_secret_arn", username_password_secret_arn)

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'KnowledgeBaseRedshiftServerlessAuthType':
        """
        The type of authentication to use.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="usernamePasswordSecretArn")
    def username_password_secret_arn(self) -> Optional[_builtins.str]:
        """
        The ARN of an Secrets Manager secret for authentication.
        """
        return pulumi.get(self, "username_password_secret_arn")


@pulumi.output_type
class KnowledgeBaseRedshiftServerlessConfiguration(dict):
    """
    Configurations for serverless Redshift query engine
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authConfiguration":
            suggest = "auth_configuration"
        elif key == "workgroupArn":
            suggest = "workgroup_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseRedshiftServerlessConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseRedshiftServerlessConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseRedshiftServerlessConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_configuration: 'outputs.KnowledgeBaseRedshiftServerlessAuthConfiguration',
                 workgroup_arn: _builtins.str):
        """
        Configurations for serverless Redshift query engine
        :param 'KnowledgeBaseRedshiftServerlessAuthConfiguration' auth_configuration: Specifies configurations for authentication to an Amazon Redshift provisioned data warehouse.
        :param _builtins.str workgroup_arn: The ARN of the Amazon Redshift workgroup.
        """
        pulumi.set(__self__, "auth_configuration", auth_configuration)
        pulumi.set(__self__, "workgroup_arn", workgroup_arn)

    @_builtins.property
    @pulumi.getter(name="authConfiguration")
    def auth_configuration(self) -> 'outputs.KnowledgeBaseRedshiftServerlessAuthConfiguration':
        """
        Specifies configurations for authentication to an Amazon Redshift provisioned data warehouse.
        """
        return pulumi.get(self, "auth_configuration")

    @_builtins.property
    @pulumi.getter(name="workgroupArn")
    def workgroup_arn(self) -> _builtins.str:
        """
        The ARN of the Amazon Redshift workgroup.
        """
        return pulumi.get(self, "workgroup_arn")


@pulumi.output_type
class KnowledgeBaseS3Location(dict):
    """
    An Amazon S3 location.
    """
    def __init__(__self__, *,
                 uri: _builtins.str):
        """
        An Amazon S3 location.
        :param _builtins.str uri: The location's URI
        """
        pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> _builtins.str:
        """
        The location's URI
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class KnowledgeBaseSqlKnowledgeBaseConfiguration(dict):
    """
    Configurations for a SQL knowledge base
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "redshiftConfiguration":
            suggest = "redshift_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseSqlKnowledgeBaseConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseSqlKnowledgeBaseConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseSqlKnowledgeBaseConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: 'KnowledgeBaseQueryEngineType',
                 redshift_configuration: Optional['outputs.KnowledgeBaseRedshiftConfiguration'] = None):
        """
        Configurations for a SQL knowledge base
        :param 'KnowledgeBaseQueryEngineType' type: The type of SQL database to connect to the knowledge base.
        :param 'KnowledgeBaseRedshiftConfiguration' redshift_configuration: Specifies configurations for a knowledge base connected to an Amazon Redshift database.
        """
        pulumi.set(__self__, "type", type)
        if redshift_configuration is not None:
            pulumi.set(__self__, "redshift_configuration", redshift_configuration)

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'KnowledgeBaseQueryEngineType':
        """
        The type of SQL database to connect to the knowledge base.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="redshiftConfiguration")
    def redshift_configuration(self) -> Optional['outputs.KnowledgeBaseRedshiftConfiguration']:
        """
        Specifies configurations for a knowledge base connected to an Amazon Redshift database.
        """
        return pulumi.get(self, "redshift_configuration")


@pulumi.output_type
class KnowledgeBaseStorageConfiguration(dict):
    """
    The vector store service in which the knowledge base is stored.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mongoDbAtlasConfiguration":
            suggest = "mongo_db_atlas_configuration"
        elif key == "neptuneAnalyticsConfiguration":
            suggest = "neptune_analytics_configuration"
        elif key == "opensearchManagedClusterConfiguration":
            suggest = "opensearch_managed_cluster_configuration"
        elif key == "opensearchServerlessConfiguration":
            suggest = "opensearch_serverless_configuration"
        elif key == "pineconeConfiguration":
            suggest = "pinecone_configuration"
        elif key == "rdsConfiguration":
            suggest = "rds_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseStorageConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseStorageConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseStorageConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: 'KnowledgeBaseStorageType',
                 mongo_db_atlas_configuration: Optional['outputs.KnowledgeBaseMongoDbAtlasConfiguration'] = None,
                 neptune_analytics_configuration: Optional['outputs.KnowledgeBaseNeptuneAnalyticsConfiguration'] = None,
                 opensearch_managed_cluster_configuration: Optional['outputs.KnowledgeBaseOpenSearchManagedClusterConfiguration'] = None,
                 opensearch_serverless_configuration: Optional['outputs.KnowledgeBaseOpenSearchServerlessConfiguration'] = None,
                 pinecone_configuration: Optional['outputs.KnowledgeBasePineconeConfiguration'] = None,
                 rds_configuration: Optional['outputs.KnowledgeBaseRdsConfiguration'] = None):
        """
        The vector store service in which the knowledge base is stored.
        :param 'KnowledgeBaseStorageType' type: The vector store service in which the knowledge base is stored.
        :param 'KnowledgeBaseMongoDbAtlasConfiguration' mongo_db_atlas_configuration: Contains the storage configuration of the knowledge base in MongoDB Atlas.
        :param 'KnowledgeBaseNeptuneAnalyticsConfiguration' neptune_analytics_configuration: Contains details about the Neptune Analytics configuration of the knowledge base in Amazon Neptune. For more information, see [Create a vector index in Amazon Neptune Analytics.](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-neptune.html) .
        :param 'KnowledgeBaseOpenSearchManagedClusterConfiguration' opensearch_managed_cluster_configuration: Contains details about the storage configuration of the knowledge base in OpenSearch Managed Cluster. For more information, see [Create a vector index in Amazon OpenSearch Service](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-osm.html) .
        :param 'KnowledgeBaseOpenSearchServerlessConfiguration' opensearch_serverless_configuration: Contains the storage configuration of the knowledge base in Amazon OpenSearch Service.
        :param 'KnowledgeBasePineconeConfiguration' pinecone_configuration: Contains the storage configuration of the knowledge base in Pinecone.
        :param 'KnowledgeBaseRdsConfiguration' rds_configuration: Contains details about the storage configuration of the knowledge base in Amazon RDS. For more information, see [Create a vector index in Amazon RDS](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-rds.html) .
        """
        pulumi.set(__self__, "type", type)
        if mongo_db_atlas_configuration is not None:
            pulumi.set(__self__, "mongo_db_atlas_configuration", mongo_db_atlas_configuration)
        if neptune_analytics_configuration is not None:
            pulumi.set(__self__, "neptune_analytics_configuration", neptune_analytics_configuration)
        if opensearch_managed_cluster_configuration is not None:
            pulumi.set(__self__, "opensearch_managed_cluster_configuration", opensearch_managed_cluster_configuration)
        if opensearch_serverless_configuration is not None:
            pulumi.set(__self__, "opensearch_serverless_configuration", opensearch_serverless_configuration)
        if pinecone_configuration is not None:
            pulumi.set(__self__, "pinecone_configuration", pinecone_configuration)
        if rds_configuration is not None:
            pulumi.set(__self__, "rds_configuration", rds_configuration)

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'KnowledgeBaseStorageType':
        """
        The vector store service in which the knowledge base is stored.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="mongoDbAtlasConfiguration")
    def mongo_db_atlas_configuration(self) -> Optional['outputs.KnowledgeBaseMongoDbAtlasConfiguration']:
        """
        Contains the storage configuration of the knowledge base in MongoDB Atlas.
        """
        return pulumi.get(self, "mongo_db_atlas_configuration")

    @_builtins.property
    @pulumi.getter(name="neptuneAnalyticsConfiguration")
    def neptune_analytics_configuration(self) -> Optional['outputs.KnowledgeBaseNeptuneAnalyticsConfiguration']:
        """
        Contains details about the Neptune Analytics configuration of the knowledge base in Amazon Neptune. For more information, see [Create a vector index in Amazon Neptune Analytics.](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-neptune.html) .
        """
        return pulumi.get(self, "neptune_analytics_configuration")

    @_builtins.property
    @pulumi.getter(name="opensearchManagedClusterConfiguration")
    def opensearch_managed_cluster_configuration(self) -> Optional['outputs.KnowledgeBaseOpenSearchManagedClusterConfiguration']:
        """
        Contains details about the storage configuration of the knowledge base in OpenSearch Managed Cluster. For more information, see [Create a vector index in Amazon OpenSearch Service](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-osm.html) .
        """
        return pulumi.get(self, "opensearch_managed_cluster_configuration")

    @_builtins.property
    @pulumi.getter(name="opensearchServerlessConfiguration")
    def opensearch_serverless_configuration(self) -> Optional['outputs.KnowledgeBaseOpenSearchServerlessConfiguration']:
        """
        Contains the storage configuration of the knowledge base in Amazon OpenSearch Service.
        """
        return pulumi.get(self, "opensearch_serverless_configuration")

    @_builtins.property
    @pulumi.getter(name="pineconeConfiguration")
    def pinecone_configuration(self) -> Optional['outputs.KnowledgeBasePineconeConfiguration']:
        """
        Contains the storage configuration of the knowledge base in Pinecone.
        """
        return pulumi.get(self, "pinecone_configuration")

    @_builtins.property
    @pulumi.getter(name="rdsConfiguration")
    def rds_configuration(self) -> Optional['outputs.KnowledgeBaseRdsConfiguration']:
        """
        Contains details about the storage configuration of the knowledge base in Amazon RDS. For more information, see [Create a vector index in Amazon RDS](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-setup-rds.html) .
        """
        return pulumi.get(self, "rds_configuration")


@pulumi.output_type
class KnowledgeBaseSupplementalDataStorageConfiguration(dict):
    """
    Configurations for supplemental data storage.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "supplementalDataStorageLocations":
            suggest = "supplemental_data_storage_locations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseSupplementalDataStorageConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseSupplementalDataStorageConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseSupplementalDataStorageConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 supplemental_data_storage_locations: Sequence['outputs.KnowledgeBaseSupplementalDataStorageLocation']):
        """
        Configurations for supplemental data storage.
        """
        pulumi.set(__self__, "supplemental_data_storage_locations", supplemental_data_storage_locations)

    @_builtins.property
    @pulumi.getter(name="supplementalDataStorageLocations")
    def supplemental_data_storage_locations(self) -> Sequence['outputs.KnowledgeBaseSupplementalDataStorageLocation']:
        return pulumi.get(self, "supplemental_data_storage_locations")


@pulumi.output_type
class KnowledgeBaseSupplementalDataStorageLocation(dict):
    """
    Supplemental data storage location.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "supplementalDataStorageLocationType":
            suggest = "supplemental_data_storage_location_type"
        elif key == "s3Location":
            suggest = "s3_location"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseSupplementalDataStorageLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseSupplementalDataStorageLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseSupplementalDataStorageLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 supplemental_data_storage_location_type: 'KnowledgeBaseSupplementalDataStorageLocationType',
                 s3_location: Optional['outputs.KnowledgeBaseS3Location'] = None):
        """
        Supplemental data storage location.
        """
        pulumi.set(__self__, "supplemental_data_storage_location_type", supplemental_data_storage_location_type)
        if s3_location is not None:
            pulumi.set(__self__, "s3_location", s3_location)

    @_builtins.property
    @pulumi.getter(name="supplementalDataStorageLocationType")
    def supplemental_data_storage_location_type(self) -> 'KnowledgeBaseSupplementalDataStorageLocationType':
        return pulumi.get(self, "supplemental_data_storage_location_type")

    @_builtins.property
    @pulumi.getter(name="s3Location")
    def s3_location(self) -> Optional['outputs.KnowledgeBaseS3Location']:
        return pulumi.get(self, "s3_location")


@pulumi.output_type
class KnowledgeBaseVectorKnowledgeBaseConfiguration(dict):
    """
    Contains details about the model used to create vector embeddings for the knowledge base.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "embeddingModelArn":
            suggest = "embedding_model_arn"
        elif key == "embeddingModelConfiguration":
            suggest = "embedding_model_configuration"
        elif key == "supplementalDataStorageConfiguration":
            suggest = "supplemental_data_storage_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KnowledgeBaseVectorKnowledgeBaseConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KnowledgeBaseVectorKnowledgeBaseConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KnowledgeBaseVectorKnowledgeBaseConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 embedding_model_arn: _builtins.str,
                 embedding_model_configuration: Optional['outputs.KnowledgeBaseEmbeddingModelConfiguration'] = None,
                 supplemental_data_storage_configuration: Optional['outputs.KnowledgeBaseSupplementalDataStorageConfiguration'] = None):
        """
        Contains details about the model used to create vector embeddings for the knowledge base.
        :param _builtins.str embedding_model_arn: The ARN of the model used to create vector embeddings for the knowledge base.
        :param 'KnowledgeBaseEmbeddingModelConfiguration' embedding_model_configuration: The embeddings model configuration details for the vector model used in Knowledge Base.
        :param 'KnowledgeBaseSupplementalDataStorageConfiguration' supplemental_data_storage_configuration: If you include multimodal data from your data source, use this object to specify configurations for the storage location of the images extracted from your documents. These images can be retrieved and returned to the end user. They can also be used in generation when using [RetrieveAndGenerate](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html) .
        """
        pulumi.set(__self__, "embedding_model_arn", embedding_model_arn)
        if embedding_model_configuration is not None:
            pulumi.set(__self__, "embedding_model_configuration", embedding_model_configuration)
        if supplemental_data_storage_configuration is not None:
            pulumi.set(__self__, "supplemental_data_storage_configuration", supplemental_data_storage_configuration)

    @_builtins.property
    @pulumi.getter(name="embeddingModelArn")
    def embedding_model_arn(self) -> _builtins.str:
        """
        The ARN of the model used to create vector embeddings for the knowledge base.
        """
        return pulumi.get(self, "embedding_model_arn")

    @_builtins.property
    @pulumi.getter(name="embeddingModelConfiguration")
    def embedding_model_configuration(self) -> Optional['outputs.KnowledgeBaseEmbeddingModelConfiguration']:
        """
        The embeddings model configuration details for the vector model used in Knowledge Base.
        """
        return pulumi.get(self, "embedding_model_configuration")

    @_builtins.property
    @pulumi.getter(name="supplementalDataStorageConfiguration")
    def supplemental_data_storage_configuration(self) -> Optional['outputs.KnowledgeBaseSupplementalDataStorageConfiguration']:
        """
        If you include multimodal data from your data source, use this object to specify configurations for the storage location of the images extracted from your documents. These images can be retrieved and returned to the end user. They can also be used in generation when using [RetrieveAndGenerate](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_agent-runtime_RetrieveAndGenerate.html) .
        """
        return pulumi.get(self, "supplemental_data_storage_configuration")


@pulumi.output_type
class PromptAdditionalModelRequestFields(dict):
    """
    Contains model-specific configurations
    """
    def __init__(__self__):
        """
        Contains model-specific configurations
        """
        pass


@pulumi.output_type
class PromptAgentResource(dict):
    """
    Target Agent to invoke with Prompt
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "agentIdentifier":
            suggest = "agent_identifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PromptAgentResource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PromptAgentResource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PromptAgentResource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 agent_identifier: _builtins.str):
        """
        Target Agent to invoke with Prompt
        :param _builtins.str agent_identifier: Arn representation of the Agent Alias.
        """
        pulumi.set(__self__, "agent_identifier", agent_identifier)

    @_builtins.property
    @pulumi.getter(name="agentIdentifier")
    def agent_identifier(self) -> _builtins.str:
        """
        Arn representation of the Agent Alias.
        """
        return pulumi.get(self, "agent_identifier")


@pulumi.output_type
class PromptAnyToolChoice(dict):
    """
    Any Tool choice
    """
    def __init__(__self__):
        """
        Any Tool choice
        """
        pass


@pulumi.output_type
class PromptAutoToolChoice(dict):
    """
    Auto Tool choice
    """
    def __init__(__self__):
        """
        Auto Tool choice
        """
        pass


@pulumi.output_type
class PromptCachePointBlock(dict):
    """
    CachePointBlock
    """
    def __init__(__self__, *,
                 type: 'PromptCachePointType'):
        """
        CachePointBlock
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'PromptCachePointType':
        return pulumi.get(self, "type")


@pulumi.output_type
class PromptChatPromptTemplateConfiguration(dict):
    """
    Configuration for chat prompt template
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputVariables":
            suggest = "input_variables"
        elif key == "toolConfiguration":
            suggest = "tool_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PromptChatPromptTemplateConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PromptChatPromptTemplateConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PromptChatPromptTemplateConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 messages: Sequence['outputs.PromptMessage'],
                 input_variables: Optional[Sequence['outputs.PromptInputVariable']] = None,
                 system: Optional[Sequence[Any]] = None,
                 tool_configuration: Optional['outputs.PromptToolConfiguration'] = None):
        """
        Configuration for chat prompt template
        :param Sequence['PromptMessage'] messages: List of messages for chat prompt template
        :param Sequence['PromptInputVariable'] input_variables: List of input variables
        :param Sequence[Union['PromptSystemContentBlock0Properties', 'PromptSystemContentBlock1Properties']] system: Configuration for chat prompt template
        """
        pulumi.set(__self__, "messages", messages)
        if input_variables is not None:
            pulumi.set(__self__, "input_variables", input_variables)
        if system is not None:
            pulumi.set(__self__, "system", system)
        if tool_configuration is not None:
            pulumi.set(__self__, "tool_configuration", tool_configuration)

    @_builtins.property
    @pulumi.getter
    def messages(self) -> Sequence['outputs.PromptMessage']:
        """
        List of messages for chat prompt template
        """
        return pulumi.get(self, "messages")

    @_builtins.property
    @pulumi.getter(name="inputVariables")
    def input_variables(self) -> Optional[Sequence['outputs.PromptInputVariable']]:
        """
        List of input variables
        """
        return pulumi.get(self, "input_variables")

    @_builtins.property
    @pulumi.getter
    def system(self) -> Optional[Sequence[Any]]:
        """
        Configuration for chat prompt template
        """
        return pulumi.get(self, "system")

    @_builtins.property
    @pulumi.getter(name="toolConfiguration")
    def tool_configuration(self) -> Optional['outputs.PromptToolConfiguration']:
        return pulumi.get(self, "tool_configuration")


@pulumi.output_type
class PromptContentBlock0Properties(dict):
    """
    Configuration for chat prompt template
    """
    def __init__(__self__, *,
                 text: _builtins.str):
        """
        Configuration for chat prompt template
        :param _builtins.str text: Configuration for chat prompt template
        """
        pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def text(self) -> _builtins.str:
        """
        Configuration for chat prompt template
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class PromptContentBlock1Properties(dict):
    """
    Configuration for chat prompt template
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cachePoint":
            suggest = "cache_point"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PromptContentBlock1Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PromptContentBlock1Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PromptContentBlock1Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cache_point: 'outputs.PromptCachePointBlock'):
        """
        Configuration for chat prompt template
        """
        pulumi.set(__self__, "cache_point", cache_point)

    @_builtins.property
    @pulumi.getter(name="cachePoint")
    def cache_point(self) -> 'outputs.PromptCachePointBlock':
        return pulumi.get(self, "cache_point")


@pulumi.output_type
class PromptGenAiResourceProperties(dict):
    """
    Target resource to invoke with Prompt
    """
    def __init__(__self__, *,
                 agent: 'outputs.PromptAgentResource'):
        """
        Target resource to invoke with Prompt
        """
        pulumi.set(__self__, "agent", agent)

    @_builtins.property
    @pulumi.getter
    def agent(self) -> 'outputs.PromptAgentResource':
        return pulumi.get(self, "agent")


@pulumi.output_type
class PromptInferenceConfigurationProperties(dict):
    """
    Model inference configuration
    """
    def __init__(__self__, *,
                 text: 'outputs.PromptModelInferenceConfiguration'):
        """
        Model inference configuration
        """
        pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def text(self) -> 'outputs.PromptModelInferenceConfiguration':
        return pulumi.get(self, "text")


@pulumi.output_type
class PromptInputVariable(dict):
    """
    Input variable
    """
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        Input variable
        :param _builtins.str name: Name for an input variable
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name for an input variable
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PromptMessage(dict):
    """
    Chat prompt Message
    """
    def __init__(__self__, *,
                 content: Sequence[Any],
                 role: 'PromptConversationRole'):
        """
        Chat prompt Message
        :param Sequence[Union['PromptContentBlock0Properties', 'PromptContentBlock1Properties']] content: List of Content Blocks
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "role", role)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Sequence[Any]:
        """
        List of Content Blocks
        """
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter
    def role(self) -> 'PromptConversationRole':
        return pulumi.get(self, "role")


@pulumi.output_type
class PromptMetadataEntry(dict):
    """
    Contains a key-value pair that defines a metadata tag and value to attach to a prompt variant.
    """
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        Contains a key-value pair that defines a metadata tag and value to attach to a prompt variant.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class PromptModelInferenceConfiguration(dict):
    """
    Prompt model inference configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxTokens":
            suggest = "max_tokens"
        elif key == "stopSequences":
            suggest = "stop_sequences"
        elif key == "topP":
            suggest = "top_p"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PromptModelInferenceConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PromptModelInferenceConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PromptModelInferenceConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_tokens: Optional[_builtins.float] = None,
                 stop_sequences: Optional[Sequence[_builtins.str]] = None,
                 temperature: Optional[_builtins.float] = None,
                 top_p: Optional[_builtins.float] = None):
        """
        Prompt model inference configuration
        :param _builtins.float max_tokens: Maximum length of output
        :param Sequence[_builtins.str] stop_sequences: List of stop sequences
        :param _builtins.float temperature: Controls randomness, higher values increase diversity
        :param _builtins.float top_p: Cumulative probability cutoff for token selection
        """
        if max_tokens is not None:
            pulumi.set(__self__, "max_tokens", max_tokens)
        if stop_sequences is not None:
            pulumi.set(__self__, "stop_sequences", stop_sequences)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)
        if top_p is not None:
            pulumi.set(__self__, "top_p", top_p)

    @_builtins.property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> Optional[_builtins.float]:
        """
        Maximum length of output
        """
        return pulumi.get(self, "max_tokens")

    @_builtins.property
    @pulumi.getter(name="stopSequences")
    def stop_sequences(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of stop sequences
        """
        return pulumi.get(self, "stop_sequences")

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[_builtins.float]:
        """
        Controls randomness, higher values increase diversity
        """
        return pulumi.get(self, "temperature")

    @_builtins.property
    @pulumi.getter(name="topP")
    def top_p(self) -> Optional[_builtins.float]:
        """
        Cumulative probability cutoff for token selection
        """
        return pulumi.get(self, "top_p")


@pulumi.output_type
class PromptSpecificToolChoice(dict):
    """
    Specific Tool choice
    """
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        Specific Tool choice
        :param _builtins.str name: Tool name
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Tool name
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PromptSystemContentBlock0Properties(dict):
    """
    Configuration for chat prompt template
    """
    def __init__(__self__, *,
                 text: _builtins.str):
        """
        Configuration for chat prompt template
        :param _builtins.str text: Configuration for chat prompt template
        """
        pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def text(self) -> _builtins.str:
        """
        Configuration for chat prompt template
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class PromptSystemContentBlock1Properties(dict):
    """
    Configuration for chat prompt template
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cachePoint":
            suggest = "cache_point"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PromptSystemContentBlock1Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PromptSystemContentBlock1Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PromptSystemContentBlock1Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cache_point: 'outputs.PromptCachePointBlock'):
        """
        Configuration for chat prompt template
        """
        pulumi.set(__self__, "cache_point", cache_point)

    @_builtins.property
    @pulumi.getter(name="cachePoint")
    def cache_point(self) -> 'outputs.PromptCachePointBlock':
        return pulumi.get(self, "cache_point")


@pulumi.output_type
class PromptTemplateConfiguration0Properties(dict):
    """
    Prompt template configuration
    """
    def __init__(__self__, *,
                 text: 'outputs.PromptTextPromptTemplateConfiguration'):
        """
        Prompt template configuration
        """
        pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def text(self) -> 'outputs.PromptTextPromptTemplateConfiguration':
        return pulumi.get(self, "text")


@pulumi.output_type
class PromptTemplateConfiguration1Properties(dict):
    """
    Prompt template configuration
    """
    def __init__(__self__, *,
                 chat: 'outputs.PromptChatPromptTemplateConfiguration'):
        """
        Prompt template configuration
        """
        pulumi.set(__self__, "chat", chat)

    @_builtins.property
    @pulumi.getter
    def chat(self) -> 'outputs.PromptChatPromptTemplateConfiguration':
        return pulumi.get(self, "chat")


@pulumi.output_type
class PromptTextPromptTemplateConfiguration(dict):
    """
    Configuration for text prompt template
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cachePoint":
            suggest = "cache_point"
        elif key == "inputVariables":
            suggest = "input_variables"
        elif key == "textS3Location":
            suggest = "text_s3_location"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PromptTextPromptTemplateConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PromptTextPromptTemplateConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PromptTextPromptTemplateConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cache_point: Optional['outputs.PromptCachePointBlock'] = None,
                 input_variables: Optional[Sequence['outputs.PromptInputVariable']] = None,
                 text: Optional[_builtins.str] = None,
                 text_s3_location: Optional['outputs.PromptTextS3Location'] = None):
        """
        Configuration for text prompt template
        :param Sequence['PromptInputVariable'] input_variables: List of input variables
        :param _builtins.str text: Prompt content for String prompt template
        """
        if cache_point is not None:
            pulumi.set(__self__, "cache_point", cache_point)
        if input_variables is not None:
            pulumi.set(__self__, "input_variables", input_variables)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if text_s3_location is not None:
            pulumi.set(__self__, "text_s3_location", text_s3_location)

    @_builtins.property
    @pulumi.getter(name="cachePoint")
    def cache_point(self) -> Optional['outputs.PromptCachePointBlock']:
        return pulumi.get(self, "cache_point")

    @_builtins.property
    @pulumi.getter(name="inputVariables")
    def input_variables(self) -> Optional[Sequence['outputs.PromptInputVariable']]:
        """
        List of input variables
        """
        return pulumi.get(self, "input_variables")

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[_builtins.str]:
        """
        Prompt content for String prompt template
        """
        return pulumi.get(self, "text")

    @_builtins.property
    @pulumi.getter(name="textS3Location")
    def text_s3_location(self) -> Optional['outputs.PromptTextS3Location']:
        return pulumi.get(self, "text_s3_location")


@pulumi.output_type
class PromptTextS3Location(dict):
    """
    The identifier for the S3 resource.
    """
    def __init__(__self__, *,
                 bucket: _builtins.str,
                 key: _builtins.str,
                 version: Optional[_builtins.str] = None):
        """
        The identifier for the S3 resource.
        :param _builtins.str bucket: A bucket in S3
        :param _builtins.str key: A object key in S3
        :param _builtins.str version: The version of the the S3 object to use
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "key", key)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        A bucket in S3
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        A object key in S3
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        The version of the the S3 object to use
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class PromptTool0Properties(dict):
    """
    Tool details
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "toolSpec":
            suggest = "tool_spec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PromptTool0Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PromptTool0Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PromptTool0Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tool_spec: 'outputs.PromptToolSpecification'):
        """
        Tool details
        """
        pulumi.set(__self__, "tool_spec", tool_spec)

    @_builtins.property
    @pulumi.getter(name="toolSpec")
    def tool_spec(self) -> 'outputs.PromptToolSpecification':
        return pulumi.get(self, "tool_spec")


@pulumi.output_type
class PromptTool1Properties(dict):
    """
    Tool details
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cachePoint":
            suggest = "cache_point"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PromptTool1Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PromptTool1Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PromptTool1Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cache_point: 'outputs.PromptCachePointBlock'):
        """
        Tool details
        """
        pulumi.set(__self__, "cache_point", cache_point)

    @_builtins.property
    @pulumi.getter(name="cachePoint")
    def cache_point(self) -> 'outputs.PromptCachePointBlock':
        return pulumi.get(self, "cache_point")


@pulumi.output_type
class PromptToolChoice0Properties(dict):
    """
    Tool choice
    """
    def __init__(__self__, *,
                 auto: 'outputs.PromptAutoToolChoice'):
        """
        Tool choice
        """
        pulumi.set(__self__, "auto", auto)

    @_builtins.property
    @pulumi.getter
    def auto(self) -> 'outputs.PromptAutoToolChoice':
        return pulumi.get(self, "auto")


@pulumi.output_type
class PromptToolChoice1Properties(dict):
    """
    Tool choice
    """
    def __init__(__self__, *,
                 any: 'outputs.PromptAnyToolChoice'):
        """
        Tool choice
        """
        pulumi.set(__self__, "any", any)

    @_builtins.property
    @pulumi.getter
    def any(self) -> 'outputs.PromptAnyToolChoice':
        return pulumi.get(self, "any")


@pulumi.output_type
class PromptToolChoice2Properties(dict):
    """
    Tool choice
    """
    def __init__(__self__, *,
                 tool: 'outputs.PromptSpecificToolChoice'):
        """
        Tool choice
        """
        pulumi.set(__self__, "tool", tool)

    @_builtins.property
    @pulumi.getter
    def tool(self) -> 'outputs.PromptSpecificToolChoice':
        return pulumi.get(self, "tool")


@pulumi.output_type
class PromptToolConfiguration(dict):
    """
    Tool configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "toolChoice":
            suggest = "tool_choice"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PromptToolConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PromptToolConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PromptToolConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tools: Sequence[Any],
                 tool_choice: Optional[Any] = None):
        """
        Tool configuration
        :param Sequence[Union['PromptTool0Properties', 'PromptTool1Properties']] tools: List of Tools
        """
        pulumi.set(__self__, "tools", tools)
        if tool_choice is not None:
            pulumi.set(__self__, "tool_choice", tool_choice)

    @_builtins.property
    @pulumi.getter
    def tools(self) -> Sequence[Any]:
        """
        List of Tools
        """
        return pulumi.get(self, "tools")

    @_builtins.property
    @pulumi.getter(name="toolChoice")
    def tool_choice(self) -> Optional[Any]:
        return pulumi.get(self, "tool_choice")


@pulumi.output_type
class PromptToolInputSchemaProperties(dict):
    """
    Tool input schema json
    """
    def __init__(__self__, *,
                 json: Any):
        """
        Tool input schema json
        """
        pulumi.set(__self__, "json", json)

    @_builtins.property
    @pulumi.getter
    def json(self) -> Any:
        return pulumi.get(self, "json")


@pulumi.output_type
class PromptToolSpecification(dict):
    """
    Tool specification
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputSchema":
            suggest = "input_schema"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PromptToolSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PromptToolSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PromptToolSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input_schema: 'outputs.PromptToolInputSchemaProperties',
                 name: _builtins.str,
                 description: Optional[_builtins.str] = None):
        """
        Tool specification
        :param _builtins.str name: Tool name
        """
        pulumi.set(__self__, "input_schema", input_schema)
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter(name="inputSchema")
    def input_schema(self) -> 'outputs.PromptToolInputSchemaProperties':
        return pulumi.get(self, "input_schema")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Tool name
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class PromptVariant(dict):
    """
    Prompt variant
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "templateConfiguration":
            suggest = "template_configuration"
        elif key == "templateType":
            suggest = "template_type"
        elif key == "additionalModelRequestFields":
            suggest = "additional_model_request_fields"
        elif key == "genAiResource":
            suggest = "gen_ai_resource"
        elif key == "inferenceConfiguration":
            suggest = "inference_configuration"
        elif key == "modelId":
            suggest = "model_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PromptVariant. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PromptVariant.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PromptVariant.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 template_configuration: Any,
                 template_type: 'PromptTemplateType',
                 additional_model_request_fields: Optional['outputs.PromptAdditionalModelRequestFields'] = None,
                 gen_ai_resource: Optional['outputs.PromptGenAiResourceProperties'] = None,
                 inference_configuration: Optional['outputs.PromptInferenceConfigurationProperties'] = None,
                 metadata: Optional[Sequence['outputs.PromptMetadataEntry']] = None,
                 model_id: Optional[_builtins.str] = None):
        """
        Prompt variant
        :param _builtins.str name: Name for a variant.
        :param Union['PromptTemplateConfiguration0Properties', 'PromptTemplateConfiguration1Properties'] template_configuration: Contains configurations for the prompt template.
        :param 'PromptTemplateType' template_type: The type of prompt template to use.
        :param 'PromptAdditionalModelRequestFields' additional_model_request_fields: Contains model-specific inference configurations that aren't in the `inferenceConfiguration` field. To see model-specific inference parameters, see [Inference request parameters and response fields for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html) .
        :param 'PromptGenAiResourceProperties' gen_ai_resource: Specifies a generative AI resource with which to use the prompt.
        :param 'PromptInferenceConfigurationProperties' inference_configuration: Contains inference configurations for the prompt variant.
        :param Sequence['PromptMetadataEntry'] metadata: An array of objects, each containing a key-value pair that defines a metadata tag and value to attach to a prompt variant.
        :param _builtins.str model_id: ARN or Id of a Bedrock Foundational Model or Inference Profile, or the ARN of a imported model, or a provisioned throughput ARN for custom models.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "template_configuration", template_configuration)
        pulumi.set(__self__, "template_type", template_type)
        if additional_model_request_fields is not None:
            pulumi.set(__self__, "additional_model_request_fields", additional_model_request_fields)
        if gen_ai_resource is not None:
            pulumi.set(__self__, "gen_ai_resource", gen_ai_resource)
        if inference_configuration is not None:
            pulumi.set(__self__, "inference_configuration", inference_configuration)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if model_id is not None:
            pulumi.set(__self__, "model_id", model_id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name for a variant.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="templateConfiguration")
    def template_configuration(self) -> Any:
        """
        Contains configurations for the prompt template.
        """
        return pulumi.get(self, "template_configuration")

    @_builtins.property
    @pulumi.getter(name="templateType")
    def template_type(self) -> 'PromptTemplateType':
        """
        The type of prompt template to use.
        """
        return pulumi.get(self, "template_type")

    @_builtins.property
    @pulumi.getter(name="additionalModelRequestFields")
    def additional_model_request_fields(self) -> Optional['outputs.PromptAdditionalModelRequestFields']:
        """
        Contains model-specific inference configurations that aren't in the `inferenceConfiguration` field. To see model-specific inference parameters, see [Inference request parameters and response fields for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html) .
        """
        return pulumi.get(self, "additional_model_request_fields")

    @_builtins.property
    @pulumi.getter(name="genAiResource")
    def gen_ai_resource(self) -> Optional['outputs.PromptGenAiResourceProperties']:
        """
        Specifies a generative AI resource with which to use the prompt.
        """
        return pulumi.get(self, "gen_ai_resource")

    @_builtins.property
    @pulumi.getter(name="inferenceConfiguration")
    def inference_configuration(self) -> Optional['outputs.PromptInferenceConfigurationProperties']:
        """
        Contains inference configurations for the prompt variant.
        """
        return pulumi.get(self, "inference_configuration")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[Sequence['outputs.PromptMetadataEntry']]:
        """
        An array of objects, each containing a key-value pair that defines a metadata tag and value to attach to a prompt variant.
        """
        return pulumi.get(self, "metadata")

    @_builtins.property
    @pulumi.getter(name="modelId")
    def model_id(self) -> Optional[_builtins.str]:
        """
        ARN or Id of a Bedrock Foundational Model or Inference Profile, or the ARN of a imported model, or a provisioned throughput ARN for custom models.
        """
        return pulumi.get(self, "model_id")


@pulumi.output_type
class PromptVersionAdditionalModelRequestFields(dict):
    """
    Contains model-specific configurations
    """
    def __init__(__self__):
        """
        Contains model-specific configurations
        """
        pass


@pulumi.output_type
class PromptVersionAnyToolChoice(dict):
    """
    Any Tool choice
    """
    def __init__(__self__):
        """
        Any Tool choice
        """
        pass


@pulumi.output_type
class PromptVersionAutoToolChoice(dict):
    """
    Auto Tool choice
    """
    def __init__(__self__):
        """
        Auto Tool choice
        """
        pass


@pulumi.output_type
class PromptVersionCachePointBlock(dict):
    """
    CachePointBlock
    """
    def __init__(__self__, *,
                 type: 'PromptVersionCachePointType'):
        """
        CachePointBlock
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'PromptVersionCachePointType':
        return pulumi.get(self, "type")


@pulumi.output_type
class PromptVersionChatPromptTemplateConfiguration(dict):
    """
    Configuration for chat prompt template
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputVariables":
            suggest = "input_variables"
        elif key == "toolConfiguration":
            suggest = "tool_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PromptVersionChatPromptTemplateConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PromptVersionChatPromptTemplateConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PromptVersionChatPromptTemplateConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 messages: Sequence['outputs.PromptVersionMessage'],
                 input_variables: Optional[Sequence['outputs.PromptVersionPromptInputVariable']] = None,
                 system: Optional[Sequence[Any]] = None,
                 tool_configuration: Optional['outputs.PromptVersionToolConfiguration'] = None):
        """
        Configuration for chat prompt template
        :param Sequence['PromptVersionMessage'] messages: List of messages for chat prompt template
        :param Sequence['PromptVersionPromptInputVariable'] input_variables: List of input variables
        :param Sequence[Union['PromptVersionSystemContentBlock0Properties', 'PromptVersionSystemContentBlock1Properties']] system: Configuration for chat prompt template
        """
        pulumi.set(__self__, "messages", messages)
        if input_variables is not None:
            pulumi.set(__self__, "input_variables", input_variables)
        if system is not None:
            pulumi.set(__self__, "system", system)
        if tool_configuration is not None:
            pulumi.set(__self__, "tool_configuration", tool_configuration)

    @_builtins.property
    @pulumi.getter
    def messages(self) -> Sequence['outputs.PromptVersionMessage']:
        """
        List of messages for chat prompt template
        """
        return pulumi.get(self, "messages")

    @_builtins.property
    @pulumi.getter(name="inputVariables")
    def input_variables(self) -> Optional[Sequence['outputs.PromptVersionPromptInputVariable']]:
        """
        List of input variables
        """
        return pulumi.get(self, "input_variables")

    @_builtins.property
    @pulumi.getter
    def system(self) -> Optional[Sequence[Any]]:
        """
        Configuration for chat prompt template
        """
        return pulumi.get(self, "system")

    @_builtins.property
    @pulumi.getter(name="toolConfiguration")
    def tool_configuration(self) -> Optional['outputs.PromptVersionToolConfiguration']:
        return pulumi.get(self, "tool_configuration")


@pulumi.output_type
class PromptVersionContentBlock0Properties(dict):
    """
    Configuration for chat prompt template
    """
    def __init__(__self__, *,
                 text: _builtins.str):
        """
        Configuration for chat prompt template
        :param _builtins.str text: Configuration for chat prompt template
        """
        pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def text(self) -> _builtins.str:
        """
        Configuration for chat prompt template
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class PromptVersionContentBlock1Properties(dict):
    """
    Configuration for chat prompt template
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cachePoint":
            suggest = "cache_point"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PromptVersionContentBlock1Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PromptVersionContentBlock1Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PromptVersionContentBlock1Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cache_point: 'outputs.PromptVersionCachePointBlock'):
        """
        Configuration for chat prompt template
        """
        pulumi.set(__self__, "cache_point", cache_point)

    @_builtins.property
    @pulumi.getter(name="cachePoint")
    def cache_point(self) -> 'outputs.PromptVersionCachePointBlock':
        return pulumi.get(self, "cache_point")


@pulumi.output_type
class PromptVersionMessage(dict):
    """
    Chat prompt Message
    """
    def __init__(__self__, *,
                 content: Sequence[Any],
                 role: 'PromptVersionConversationRole'):
        """
        Chat prompt Message
        :param Sequence[Union['PromptVersionContentBlock0Properties', 'PromptVersionContentBlock1Properties']] content: List of Content Blocks
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "role", role)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Sequence[Any]:
        """
        List of Content Blocks
        """
        return pulumi.get(self, "content")

    @_builtins.property
    @pulumi.getter
    def role(self) -> 'PromptVersionConversationRole':
        return pulumi.get(self, "role")


@pulumi.output_type
class PromptVersionPromptAgentResource(dict):
    """
    Target Agent to invoke with Prompt
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "agentIdentifier":
            suggest = "agent_identifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PromptVersionPromptAgentResource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PromptVersionPromptAgentResource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PromptVersionPromptAgentResource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 agent_identifier: _builtins.str):
        """
        Target Agent to invoke with Prompt
        :param _builtins.str agent_identifier: Arn representation of the Agent Alias.
        """
        pulumi.set(__self__, "agent_identifier", agent_identifier)

    @_builtins.property
    @pulumi.getter(name="agentIdentifier")
    def agent_identifier(self) -> _builtins.str:
        """
        Arn representation of the Agent Alias.
        """
        return pulumi.get(self, "agent_identifier")


@pulumi.output_type
class PromptVersionPromptGenAiResourceProperties(dict):
    """
    Target resource to invoke with Prompt
    """
    def __init__(__self__, *,
                 agent: 'outputs.PromptVersionPromptAgentResource'):
        """
        Target resource to invoke with Prompt
        """
        pulumi.set(__self__, "agent", agent)

    @_builtins.property
    @pulumi.getter
    def agent(self) -> 'outputs.PromptVersionPromptAgentResource':
        return pulumi.get(self, "agent")


@pulumi.output_type
class PromptVersionPromptInferenceConfigurationProperties(dict):
    """
    Model inference configuration
    """
    def __init__(__self__, *,
                 text: 'outputs.PromptVersionPromptModelInferenceConfiguration'):
        """
        Model inference configuration
        """
        pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def text(self) -> 'outputs.PromptVersionPromptModelInferenceConfiguration':
        return pulumi.get(self, "text")


@pulumi.output_type
class PromptVersionPromptInputVariable(dict):
    """
    Input variable
    """
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        Input variable
        :param _builtins.str name: Name for an input variable
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name for an input variable
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PromptVersionPromptMetadataEntry(dict):
    """
    Contains a key-value pair that defines a metadata tag and value to attach to a prompt variant.
    """
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        Contains a key-value pair that defines a metadata tag and value to attach to a prompt variant.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class PromptVersionPromptModelInferenceConfiguration(dict):
    """
    Prompt model inference configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxTokens":
            suggest = "max_tokens"
        elif key == "stopSequences":
            suggest = "stop_sequences"
        elif key == "topP":
            suggest = "top_p"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PromptVersionPromptModelInferenceConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PromptVersionPromptModelInferenceConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PromptVersionPromptModelInferenceConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_tokens: Optional[_builtins.float] = None,
                 stop_sequences: Optional[Sequence[_builtins.str]] = None,
                 temperature: Optional[_builtins.float] = None,
                 top_p: Optional[_builtins.float] = None):
        """
        Prompt model inference configuration
        :param _builtins.float max_tokens: Maximum length of output
        :param Sequence[_builtins.str] stop_sequences: List of stop sequences
        :param _builtins.float temperature: Controls randomness, higher values increase diversity
        :param _builtins.float top_p: Cumulative probability cutoff for token selection
        """
        if max_tokens is not None:
            pulumi.set(__self__, "max_tokens", max_tokens)
        if stop_sequences is not None:
            pulumi.set(__self__, "stop_sequences", stop_sequences)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)
        if top_p is not None:
            pulumi.set(__self__, "top_p", top_p)

    @_builtins.property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> Optional[_builtins.float]:
        """
        Maximum length of output
        """
        return pulumi.get(self, "max_tokens")

    @_builtins.property
    @pulumi.getter(name="stopSequences")
    def stop_sequences(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of stop sequences
        """
        return pulumi.get(self, "stop_sequences")

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[_builtins.float]:
        """
        Controls randomness, higher values increase diversity
        """
        return pulumi.get(self, "temperature")

    @_builtins.property
    @pulumi.getter(name="topP")
    def top_p(self) -> Optional[_builtins.float]:
        """
        Cumulative probability cutoff for token selection
        """
        return pulumi.get(self, "top_p")


@pulumi.output_type
class PromptVersionPromptTemplateConfiguration0Properties(dict):
    """
    Prompt template configuration
    """
    def __init__(__self__, *,
                 text: 'outputs.PromptVersionTextPromptTemplateConfiguration'):
        """
        Prompt template configuration
        """
        pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def text(self) -> 'outputs.PromptVersionTextPromptTemplateConfiguration':
        return pulumi.get(self, "text")


@pulumi.output_type
class PromptVersionPromptTemplateConfiguration1Properties(dict):
    """
    Prompt template configuration
    """
    def __init__(__self__, *,
                 chat: 'outputs.PromptVersionChatPromptTemplateConfiguration'):
        """
        Prompt template configuration
        """
        pulumi.set(__self__, "chat", chat)

    @_builtins.property
    @pulumi.getter
    def chat(self) -> 'outputs.PromptVersionChatPromptTemplateConfiguration':
        return pulumi.get(self, "chat")


@pulumi.output_type
class PromptVersionPromptVariant(dict):
    """
    Prompt variant
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "templateConfiguration":
            suggest = "template_configuration"
        elif key == "templateType":
            suggest = "template_type"
        elif key == "additionalModelRequestFields":
            suggest = "additional_model_request_fields"
        elif key == "genAiResource":
            suggest = "gen_ai_resource"
        elif key == "inferenceConfiguration":
            suggest = "inference_configuration"
        elif key == "modelId":
            suggest = "model_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PromptVersionPromptVariant. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PromptVersionPromptVariant.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PromptVersionPromptVariant.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 template_configuration: Any,
                 template_type: 'PromptVersionPromptTemplateType',
                 additional_model_request_fields: Optional['outputs.PromptVersionAdditionalModelRequestFields'] = None,
                 gen_ai_resource: Optional['outputs.PromptVersionPromptGenAiResourceProperties'] = None,
                 inference_configuration: Optional['outputs.PromptVersionPromptInferenceConfigurationProperties'] = None,
                 metadata: Optional[Sequence['outputs.PromptVersionPromptMetadataEntry']] = None,
                 model_id: Optional[_builtins.str] = None):
        """
        Prompt variant
        :param _builtins.str name: Name for a variant.
        :param Union['PromptVersionPromptTemplateConfiguration0Properties', 'PromptVersionPromptTemplateConfiguration1Properties'] template_configuration: Contains configurations for the prompt template.
        :param 'PromptVersionPromptTemplateType' template_type: The type of prompt template to use.
        :param 'PromptVersionAdditionalModelRequestFields' additional_model_request_fields: Contains model-specific inference configurations that aren't in the `inferenceConfiguration` field. To see model-specific inference parameters, see [Inference request parameters and response fields for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html) .
        :param 'PromptVersionPromptGenAiResourceProperties' gen_ai_resource: Specifies a generative AI resource with which to use the prompt.
        :param 'PromptVersionPromptInferenceConfigurationProperties' inference_configuration: Contains inference configurations for the prompt variant.
        :param Sequence['PromptVersionPromptMetadataEntry'] metadata: An array of objects, each containing a key-value pair that defines a metadata tag and value to attach to a prompt variant.
        :param _builtins.str model_id: ARN or Id of a Bedrock Foundational Model or Inference Profile, or the ARN of a imported model, or a provisioned throughput ARN for custom models.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "template_configuration", template_configuration)
        pulumi.set(__self__, "template_type", template_type)
        if additional_model_request_fields is not None:
            pulumi.set(__self__, "additional_model_request_fields", additional_model_request_fields)
        if gen_ai_resource is not None:
            pulumi.set(__self__, "gen_ai_resource", gen_ai_resource)
        if inference_configuration is not None:
            pulumi.set(__self__, "inference_configuration", inference_configuration)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if model_id is not None:
            pulumi.set(__self__, "model_id", model_id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name for a variant.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="templateConfiguration")
    def template_configuration(self) -> Any:
        """
        Contains configurations for the prompt template.
        """
        return pulumi.get(self, "template_configuration")

    @_builtins.property
    @pulumi.getter(name="templateType")
    def template_type(self) -> 'PromptVersionPromptTemplateType':
        """
        The type of prompt template to use.
        """
        return pulumi.get(self, "template_type")

    @_builtins.property
    @pulumi.getter(name="additionalModelRequestFields")
    def additional_model_request_fields(self) -> Optional['outputs.PromptVersionAdditionalModelRequestFields']:
        """
        Contains model-specific inference configurations that aren't in the `inferenceConfiguration` field. To see model-specific inference parameters, see [Inference request parameters and response fields for foundation models](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html) .
        """
        return pulumi.get(self, "additional_model_request_fields")

    @_builtins.property
    @pulumi.getter(name="genAiResource")
    def gen_ai_resource(self) -> Optional['outputs.PromptVersionPromptGenAiResourceProperties']:
        """
        Specifies a generative AI resource with which to use the prompt.
        """
        return pulumi.get(self, "gen_ai_resource")

    @_builtins.property
    @pulumi.getter(name="inferenceConfiguration")
    def inference_configuration(self) -> Optional['outputs.PromptVersionPromptInferenceConfigurationProperties']:
        """
        Contains inference configurations for the prompt variant.
        """
        return pulumi.get(self, "inference_configuration")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[Sequence['outputs.PromptVersionPromptMetadataEntry']]:
        """
        An array of objects, each containing a key-value pair that defines a metadata tag and value to attach to a prompt variant.
        """
        return pulumi.get(self, "metadata")

    @_builtins.property
    @pulumi.getter(name="modelId")
    def model_id(self) -> Optional[_builtins.str]:
        """
        ARN or Id of a Bedrock Foundational Model or Inference Profile, or the ARN of a imported model, or a provisioned throughput ARN for custom models.
        """
        return pulumi.get(self, "model_id")


@pulumi.output_type
class PromptVersionSpecificToolChoice(dict):
    """
    Specific Tool choice
    """
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        Specific Tool choice
        :param _builtins.str name: Tool name
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Tool name
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PromptVersionSystemContentBlock0Properties(dict):
    """
    Configuration for chat prompt template
    """
    def __init__(__self__, *,
                 text: _builtins.str):
        """
        Configuration for chat prompt template
        :param _builtins.str text: Configuration for chat prompt template
        """
        pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def text(self) -> _builtins.str:
        """
        Configuration for chat prompt template
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class PromptVersionSystemContentBlock1Properties(dict):
    """
    Configuration for chat prompt template
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cachePoint":
            suggest = "cache_point"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PromptVersionSystemContentBlock1Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PromptVersionSystemContentBlock1Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PromptVersionSystemContentBlock1Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cache_point: 'outputs.PromptVersionCachePointBlock'):
        """
        Configuration for chat prompt template
        """
        pulumi.set(__self__, "cache_point", cache_point)

    @_builtins.property
    @pulumi.getter(name="cachePoint")
    def cache_point(self) -> 'outputs.PromptVersionCachePointBlock':
        return pulumi.get(self, "cache_point")


@pulumi.output_type
class PromptVersionTextPromptTemplateConfiguration(dict):
    """
    Configuration for text prompt template
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cachePoint":
            suggest = "cache_point"
        elif key == "inputVariables":
            suggest = "input_variables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PromptVersionTextPromptTemplateConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PromptVersionTextPromptTemplateConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PromptVersionTextPromptTemplateConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text: _builtins.str,
                 cache_point: Optional['outputs.PromptVersionCachePointBlock'] = None,
                 input_variables: Optional[Sequence['outputs.PromptVersionPromptInputVariable']] = None):
        """
        Configuration for text prompt template
        :param _builtins.str text: Prompt content for String prompt template
        :param Sequence['PromptVersionPromptInputVariable'] input_variables: List of input variables
        """
        pulumi.set(__self__, "text", text)
        if cache_point is not None:
            pulumi.set(__self__, "cache_point", cache_point)
        if input_variables is not None:
            pulumi.set(__self__, "input_variables", input_variables)

    @_builtins.property
    @pulumi.getter
    def text(self) -> _builtins.str:
        """
        Prompt content for String prompt template
        """
        return pulumi.get(self, "text")

    @_builtins.property
    @pulumi.getter(name="cachePoint")
    def cache_point(self) -> Optional['outputs.PromptVersionCachePointBlock']:
        return pulumi.get(self, "cache_point")

    @_builtins.property
    @pulumi.getter(name="inputVariables")
    def input_variables(self) -> Optional[Sequence['outputs.PromptVersionPromptInputVariable']]:
        """
        List of input variables
        """
        return pulumi.get(self, "input_variables")


@pulumi.output_type
class PromptVersionTool0Properties(dict):
    """
    Tool details
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "toolSpec":
            suggest = "tool_spec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PromptVersionTool0Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PromptVersionTool0Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PromptVersionTool0Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tool_spec: 'outputs.PromptVersionToolSpecification'):
        """
        Tool details
        """
        pulumi.set(__self__, "tool_spec", tool_spec)

    @_builtins.property
    @pulumi.getter(name="toolSpec")
    def tool_spec(self) -> 'outputs.PromptVersionToolSpecification':
        return pulumi.get(self, "tool_spec")


@pulumi.output_type
class PromptVersionTool1Properties(dict):
    """
    Tool details
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cachePoint":
            suggest = "cache_point"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PromptVersionTool1Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PromptVersionTool1Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PromptVersionTool1Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cache_point: 'outputs.PromptVersionCachePointBlock'):
        """
        Tool details
        """
        pulumi.set(__self__, "cache_point", cache_point)

    @_builtins.property
    @pulumi.getter(name="cachePoint")
    def cache_point(self) -> 'outputs.PromptVersionCachePointBlock':
        return pulumi.get(self, "cache_point")


@pulumi.output_type
class PromptVersionToolChoice0Properties(dict):
    """
    Tool choice
    """
    def __init__(__self__, *,
                 auto: 'outputs.PromptVersionAutoToolChoice'):
        """
        Tool choice
        """
        pulumi.set(__self__, "auto", auto)

    @_builtins.property
    @pulumi.getter
    def auto(self) -> 'outputs.PromptVersionAutoToolChoice':
        return pulumi.get(self, "auto")


@pulumi.output_type
class PromptVersionToolChoice1Properties(dict):
    """
    Tool choice
    """
    def __init__(__self__, *,
                 any: 'outputs.PromptVersionAnyToolChoice'):
        """
        Tool choice
        """
        pulumi.set(__self__, "any", any)

    @_builtins.property
    @pulumi.getter
    def any(self) -> 'outputs.PromptVersionAnyToolChoice':
        return pulumi.get(self, "any")


@pulumi.output_type
class PromptVersionToolChoice2Properties(dict):
    """
    Tool choice
    """
    def __init__(__self__, *,
                 tool: 'outputs.PromptVersionSpecificToolChoice'):
        """
        Tool choice
        """
        pulumi.set(__self__, "tool", tool)

    @_builtins.property
    @pulumi.getter
    def tool(self) -> 'outputs.PromptVersionSpecificToolChoice':
        return pulumi.get(self, "tool")


@pulumi.output_type
class PromptVersionToolConfiguration(dict):
    """
    Tool configuration
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "toolChoice":
            suggest = "tool_choice"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PromptVersionToolConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PromptVersionToolConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PromptVersionToolConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tools: Sequence[Any],
                 tool_choice: Optional[Any] = None):
        """
        Tool configuration
        :param Sequence[Union['PromptVersionTool0Properties', 'PromptVersionTool1Properties']] tools: List of Tools
        """
        pulumi.set(__self__, "tools", tools)
        if tool_choice is not None:
            pulumi.set(__self__, "tool_choice", tool_choice)

    @_builtins.property
    @pulumi.getter
    def tools(self) -> Sequence[Any]:
        """
        List of Tools
        """
        return pulumi.get(self, "tools")

    @_builtins.property
    @pulumi.getter(name="toolChoice")
    def tool_choice(self) -> Optional[Any]:
        return pulumi.get(self, "tool_choice")


@pulumi.output_type
class PromptVersionToolInputSchemaProperties(dict):
    """
    Tool input schema json
    """
    def __init__(__self__, *,
                 json: Any):
        """
        Tool input schema json
        """
        pulumi.set(__self__, "json", json)

    @_builtins.property
    @pulumi.getter
    def json(self) -> Any:
        return pulumi.get(self, "json")


@pulumi.output_type
class PromptVersionToolSpecification(dict):
    """
    Tool specification
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputSchema":
            suggest = "input_schema"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PromptVersionToolSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PromptVersionToolSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PromptVersionToolSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input_schema: 'outputs.PromptVersionToolInputSchemaProperties',
                 name: _builtins.str,
                 description: Optional[_builtins.str] = None):
        """
        Tool specification
        :param _builtins.str name: Tool name
        """
        pulumi.set(__self__, "input_schema", input_schema)
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter(name="inputSchema")
    def input_schema(self) -> 'outputs.PromptVersionToolInputSchemaProperties':
        return pulumi.get(self, "input_schema")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Tool name
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")


