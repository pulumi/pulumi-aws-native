# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'BridgeEgressGatewayBridgeArgs',
    'BridgeEgressGatewayBridgeArgsDict',
    'BridgeFailoverConfigArgs',
    'BridgeFailoverConfigArgsDict',
    'BridgeFlowSourceArgs',
    'BridgeFlowSourceArgsDict',
    'BridgeIngressGatewayBridgeArgs',
    'BridgeIngressGatewayBridgeArgsDict',
    'BridgeMulticastSourceSettingsArgs',
    'BridgeMulticastSourceSettingsArgsDict',
    'BridgeNetworkOutputArgs',
    'BridgeNetworkOutputArgsDict',
    'BridgeNetworkSourceArgs',
    'BridgeNetworkSourceArgsDict',
    'BridgeOutputResourceBridgeNetworkOutputArgs',
    'BridgeOutputResourceBridgeNetworkOutputArgsDict',
    'BridgeOutputArgs',
    'BridgeOutputArgsDict',
    'BridgeSourceBridgeFlowSourceArgs',
    'BridgeSourceBridgeFlowSourceArgsDict',
    'BridgeSourceBridgeNetworkSourceArgs',
    'BridgeSourceBridgeNetworkSourceArgsDict',
    'BridgeSourceMulticastSourceSettingsArgs',
    'BridgeSourceMulticastSourceSettingsArgsDict',
    'BridgeSourcePriorityArgs',
    'BridgeSourcePriorityArgsDict',
    'BridgeSourceVpcInterfaceAttachmentArgs',
    'BridgeSourceVpcInterfaceAttachmentArgsDict',
    'BridgeSourceArgs',
    'BridgeSourceArgsDict',
    'BridgeVpcInterfaceAttachmentArgs',
    'BridgeVpcInterfaceAttachmentArgsDict',
    'FlowAudioMonitoringSettingArgs',
    'FlowAudioMonitoringSettingArgsDict',
    'FlowAutomaticEncryptionKeyConfigurationArgs',
    'FlowAutomaticEncryptionKeyConfigurationArgsDict',
    'FlowBlackFramesArgs',
    'FlowBlackFramesArgsDict',
    'FlowEncryptionArgs',
    'FlowEncryptionArgsDict',
    'FlowEntitlementEncryptionArgs',
    'FlowEntitlementEncryptionArgsDict',
    'FlowFailoverConfigSourcePriorityPropertiesArgs',
    'FlowFailoverConfigSourcePriorityPropertiesArgsDict',
    'FlowFailoverConfigArgs',
    'FlowFailoverConfigArgsDict',
    'FlowFmtpArgs',
    'FlowFmtpArgsDict',
    'FlowFrozenFramesArgs',
    'FlowFrozenFramesArgsDict',
    'FlowGatewayBridgeSourceArgs',
    'FlowGatewayBridgeSourceArgsDict',
    'FlowInputConfigurationArgs',
    'FlowInputConfigurationArgsDict',
    'FlowInterfaceArgs',
    'FlowInterfaceArgsDict',
    'FlowMaintenanceArgs',
    'FlowMaintenanceArgsDict',
    'FlowMediaStreamAttributesArgs',
    'FlowMediaStreamAttributesArgsDict',
    'FlowMediaStreamSourceConfigurationArgs',
    'FlowMediaStreamSourceConfigurationArgsDict',
    'FlowMediaStreamArgs',
    'FlowMediaStreamArgsDict',
    'FlowNdiConfigArgs',
    'FlowNdiConfigArgsDict',
    'FlowNdiDiscoveryServerConfigArgs',
    'FlowNdiDiscoveryServerConfigArgsDict',
    'FlowOutputAutomaticEncryptionKeyConfigurationArgs',
    'FlowOutputAutomaticEncryptionKeyConfigurationArgsDict',
    'FlowOutputDestinationConfigurationArgs',
    'FlowOutputDestinationConfigurationArgsDict',
    'FlowOutputEncodingParametersArgs',
    'FlowOutputEncodingParametersArgsDict',
    'FlowOutputEncryptionArgs',
    'FlowOutputEncryptionArgsDict',
    'FlowOutputFlowTransitEncryptionKeyConfiguration0PropertiesArgs',
    'FlowOutputFlowTransitEncryptionKeyConfiguration0PropertiesArgsDict',
    'FlowOutputFlowTransitEncryptionKeyConfiguration1PropertiesArgs',
    'FlowOutputFlowTransitEncryptionKeyConfiguration1PropertiesArgsDict',
    'FlowOutputFlowTransitEncryptionArgs',
    'FlowOutputFlowTransitEncryptionArgsDict',
    'FlowOutputInterfaceArgs',
    'FlowOutputInterfaceArgsDict',
    'FlowOutputMediaStreamOutputConfigurationArgs',
    'FlowOutputMediaStreamOutputConfigurationArgsDict',
    'FlowOutputSecretsManagerEncryptionKeyConfigurationArgs',
    'FlowOutputSecretsManagerEncryptionKeyConfigurationArgsDict',
    'FlowOutputVpcInterfaceAttachmentArgs',
    'FlowOutputVpcInterfaceAttachmentArgsDict',
    'FlowSecretsManagerEncryptionKeyConfigurationArgs',
    'FlowSecretsManagerEncryptionKeyConfigurationArgsDict',
    'FlowSilentAudioArgs',
    'FlowSilentAudioArgsDict',
    'FlowSourceEncryptionArgs',
    'FlowSourceEncryptionArgsDict',
    'FlowSourceGatewayBridgeSourceArgs',
    'FlowSourceGatewayBridgeSourceArgsDict',
    'FlowSourceMonitoringConfigArgs',
    'FlowSourceMonitoringConfigArgsDict',
    'FlowSourceVpcInterfaceAttachmentArgs',
    'FlowSourceVpcInterfaceAttachmentArgsDict',
    'FlowSourceArgs',
    'FlowSourceArgsDict',
    'FlowTransitEncryptionKeyConfiguration0PropertiesArgs',
    'FlowTransitEncryptionKeyConfiguration0PropertiesArgsDict',
    'FlowTransitEncryptionKeyConfiguration1PropertiesArgs',
    'FlowTransitEncryptionKeyConfiguration1PropertiesArgsDict',
    'FlowTransitEncryptionArgs',
    'FlowTransitEncryptionArgsDict',
    'FlowVideoMonitoringSettingArgs',
    'FlowVideoMonitoringSettingArgsDict',
    'FlowVpcInterfaceAttachmentArgs',
    'FlowVpcInterfaceAttachmentArgsDict',
    'FlowVpcInterfaceArgs',
    'FlowVpcInterfaceArgsDict',
    'GatewayNetworkArgs',
    'GatewayNetworkArgsDict',
    'RouterInputAutomaticEncryptionKeyConfigurationArgs',
    'RouterInputAutomaticEncryptionKeyConfigurationArgsDict',
    'RouterInputConfiguration0PropertiesArgs',
    'RouterInputConfiguration0PropertiesArgsDict',
    'RouterInputConfiguration1PropertiesArgs',
    'RouterInputConfiguration1PropertiesArgsDict',
    'RouterInputConfiguration2PropertiesArgs',
    'RouterInputConfiguration2PropertiesArgsDict',
    'RouterInputConfiguration3PropertiesArgs',
    'RouterInputConfiguration3PropertiesArgsDict',
    'RouterInputDefaultMaintenanceConfigurationArgs',
    'RouterInputDefaultMaintenanceConfigurationArgsDict',
    'RouterInputFailoverRouterInputConfigurationArgs',
    'RouterInputFailoverRouterInputConfigurationArgsDict',
    'RouterInputFailoverRouterInputProtocolConfiguration0PropertiesArgs',
    'RouterInputFailoverRouterInputProtocolConfiguration0PropertiesArgsDict',
    'RouterInputFailoverRouterInputProtocolConfiguration1PropertiesArgs',
    'RouterInputFailoverRouterInputProtocolConfiguration1PropertiesArgsDict',
    'RouterInputFailoverRouterInputProtocolConfiguration2PropertiesArgs',
    'RouterInputFailoverRouterInputProtocolConfiguration2PropertiesArgsDict',
    'RouterInputFailoverRouterInputProtocolConfiguration3PropertiesArgs',
    'RouterInputFailoverRouterInputProtocolConfiguration3PropertiesArgsDict',
    'RouterInputFlowTransitEncryptionKeyConfiguration0PropertiesArgs',
    'RouterInputFlowTransitEncryptionKeyConfiguration0PropertiesArgsDict',
    'RouterInputFlowTransitEncryptionKeyConfiguration1PropertiesArgs',
    'RouterInputFlowTransitEncryptionKeyConfiguration1PropertiesArgsDict',
    'RouterInputFlowTransitEncryptionArgs',
    'RouterInputFlowTransitEncryptionArgsDict',
    'RouterInputMaintenanceConfiguration0PropertiesArgs',
    'RouterInputMaintenanceConfiguration0PropertiesArgsDict',
    'RouterInputMaintenanceConfiguration1PropertiesArgs',
    'RouterInputMaintenanceConfiguration1PropertiesArgsDict',
    'RouterInputMediaConnectFlowRouterInputConfigurationArgs',
    'RouterInputMediaConnectFlowRouterInputConfigurationArgsDict',
    'RouterInputMergeRouterInputConfigurationArgs',
    'RouterInputMergeRouterInputConfigurationArgsDict',
    'RouterInputMergeRouterInputProtocolConfiguration0PropertiesArgs',
    'RouterInputMergeRouterInputProtocolConfiguration0PropertiesArgsDict',
    'RouterInputMergeRouterInputProtocolConfiguration1PropertiesArgs',
    'RouterInputMergeRouterInputProtocolConfiguration1PropertiesArgsDict',
    'RouterInputPreferredDayTimeMaintenanceConfigurationArgs',
    'RouterInputPreferredDayTimeMaintenanceConfigurationArgsDict',
    'RouterInputProtocolConfiguration0PropertiesArgs',
    'RouterInputProtocolConfiguration0PropertiesArgsDict',
    'RouterInputProtocolConfiguration1PropertiesArgs',
    'RouterInputProtocolConfiguration1PropertiesArgsDict',
    'RouterInputProtocolConfiguration2PropertiesArgs',
    'RouterInputProtocolConfiguration2PropertiesArgsDict',
    'RouterInputProtocolConfiguration3PropertiesArgs',
    'RouterInputProtocolConfiguration3PropertiesArgsDict',
    'RouterInputRistRouterInputConfigurationArgs',
    'RouterInputRistRouterInputConfigurationArgsDict',
    'RouterInputRtpRouterInputConfigurationArgs',
    'RouterInputRtpRouterInputConfigurationArgsDict',
    'RouterInputSecretsManagerEncryptionKeyConfigurationArgs',
    'RouterInputSecretsManagerEncryptionKeyConfigurationArgsDict',
    'RouterInputSrtCallerRouterInputConfigurationArgs',
    'RouterInputSrtCallerRouterInputConfigurationArgsDict',
    'RouterInputSrtDecryptionConfigurationArgs',
    'RouterInputSrtDecryptionConfigurationArgsDict',
    'RouterInputSrtListenerRouterInputConfigurationArgs',
    'RouterInputSrtListenerRouterInputConfigurationArgsDict',
    'RouterInputStandardRouterInputConfigurationArgs',
    'RouterInputStandardRouterInputConfigurationArgsDict',
    'RouterInputTransitEncryptionKeyConfiguration0PropertiesArgs',
    'RouterInputTransitEncryptionKeyConfiguration0PropertiesArgsDict',
    'RouterInputTransitEncryptionKeyConfiguration1PropertiesArgs',
    'RouterInputTransitEncryptionKeyConfiguration1PropertiesArgsDict',
    'RouterInputTransitEncryptionArgs',
    'RouterInputTransitEncryptionArgsDict',
    'RouterNetworkInterfaceConfiguration0PropertiesArgs',
    'RouterNetworkInterfaceConfiguration0PropertiesArgsDict',
    'RouterNetworkInterfaceConfiguration1PropertiesArgs',
    'RouterNetworkInterfaceConfiguration1PropertiesArgsDict',
    'RouterNetworkInterfacePublicRouterNetworkInterfaceConfigurationArgs',
    'RouterNetworkInterfacePublicRouterNetworkInterfaceConfigurationArgsDict',
    'RouterNetworkInterfacePublicRouterNetworkInterfaceRuleArgs',
    'RouterNetworkInterfacePublicRouterNetworkInterfaceRuleArgsDict',
    'RouterNetworkInterfaceVpcRouterNetworkInterfaceConfigurationArgs',
    'RouterNetworkInterfaceVpcRouterNetworkInterfaceConfigurationArgsDict',
    'RouterOutputResourceAutomaticEncryptionKeyConfigurationArgs',
    'RouterOutputResourceAutomaticEncryptionKeyConfigurationArgsDict',
    'RouterOutputResourceDefaultMaintenanceConfigurationArgs',
    'RouterOutputResourceDefaultMaintenanceConfigurationArgsDict',
    'RouterOutputResourceFlowTransitEncryptionKeyConfiguration0PropertiesArgs',
    'RouterOutputResourceFlowTransitEncryptionKeyConfiguration0PropertiesArgsDict',
    'RouterOutputResourceFlowTransitEncryptionKeyConfiguration1PropertiesArgs',
    'RouterOutputResourceFlowTransitEncryptionKeyConfiguration1PropertiesArgsDict',
    'RouterOutputResourceFlowTransitEncryptionArgs',
    'RouterOutputResourceFlowTransitEncryptionArgsDict',
    'RouterOutputResourceMaintenanceConfiguration0PropertiesArgs',
    'RouterOutputResourceMaintenanceConfiguration0PropertiesArgsDict',
    'RouterOutputResourceMaintenanceConfiguration1PropertiesArgs',
    'RouterOutputResourceMaintenanceConfiguration1PropertiesArgsDict',
    'RouterOutputResourceMediaConnectFlowRouterOutputConfigurationArgs',
    'RouterOutputResourceMediaConnectFlowRouterOutputConfigurationArgsDict',
    'RouterOutputResourceMediaLiveInputRouterOutputConfigurationArgs',
    'RouterOutputResourceMediaLiveInputRouterOutputConfigurationArgsDict',
    'RouterOutputResourceMediaLiveTransitEncryptionKeyConfiguration0PropertiesArgs',
    'RouterOutputResourceMediaLiveTransitEncryptionKeyConfiguration0PropertiesArgsDict',
    'RouterOutputResourceMediaLiveTransitEncryptionKeyConfiguration1PropertiesArgs',
    'RouterOutputResourceMediaLiveTransitEncryptionKeyConfiguration1PropertiesArgsDict',
    'RouterOutputResourceMediaLiveTransitEncryptionArgs',
    'RouterOutputResourceMediaLiveTransitEncryptionArgsDict',
    'RouterOutputResourcePreferredDayTimeMaintenanceConfigurationArgs',
    'RouterOutputResourcePreferredDayTimeMaintenanceConfigurationArgsDict',
    'RouterOutputResourceRistRouterOutputConfigurationArgs',
    'RouterOutputResourceRistRouterOutputConfigurationArgsDict',
    'RouterOutputResourceRouterOutputConfiguration0PropertiesArgs',
    'RouterOutputResourceRouterOutputConfiguration0PropertiesArgsDict',
    'RouterOutputResourceRouterOutputConfiguration1PropertiesArgs',
    'RouterOutputResourceRouterOutputConfiguration1PropertiesArgsDict',
    'RouterOutputResourceRouterOutputConfiguration2PropertiesArgs',
    'RouterOutputResourceRouterOutputConfiguration2PropertiesArgsDict',
    'RouterOutputResourceRouterOutputProtocolConfiguration0PropertiesArgs',
    'RouterOutputResourceRouterOutputProtocolConfiguration0PropertiesArgsDict',
    'RouterOutputResourceRouterOutputProtocolConfiguration1PropertiesArgs',
    'RouterOutputResourceRouterOutputProtocolConfiguration1PropertiesArgsDict',
    'RouterOutputResourceRouterOutputProtocolConfiguration2PropertiesArgs',
    'RouterOutputResourceRouterOutputProtocolConfiguration2PropertiesArgsDict',
    'RouterOutputResourceRouterOutputProtocolConfiguration3PropertiesArgs',
    'RouterOutputResourceRouterOutputProtocolConfiguration3PropertiesArgsDict',
    'RouterOutputResourceRtpRouterOutputConfigurationArgs',
    'RouterOutputResourceRtpRouterOutputConfigurationArgsDict',
    'RouterOutputResourceSecretsManagerEncryptionKeyConfigurationArgs',
    'RouterOutputResourceSecretsManagerEncryptionKeyConfigurationArgsDict',
    'RouterOutputResourceSrtCallerRouterOutputConfigurationArgs',
    'RouterOutputResourceSrtCallerRouterOutputConfigurationArgsDict',
    'RouterOutputResourceSrtEncryptionConfigurationArgs',
    'RouterOutputResourceSrtEncryptionConfigurationArgsDict',
    'RouterOutputResourceSrtListenerRouterOutputConfigurationArgs',
    'RouterOutputResourceSrtListenerRouterOutputConfigurationArgsDict',
    'RouterOutputResourceStandardRouterOutputConfigurationArgs',
    'RouterOutputResourceStandardRouterOutputConfigurationArgsDict',
]

MYPY = False

if not MYPY:
    class BridgeEgressGatewayBridgeArgsDict(TypedDict):
        max_bitrate: pulumi.Input[_builtins.int]
        """
        The maximum expected bitrate of the egress bridge.
        """
elif False:
    BridgeEgressGatewayBridgeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BridgeEgressGatewayBridgeArgs:
    def __init__(__self__, *,
                 max_bitrate: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] max_bitrate: The maximum expected bitrate of the egress bridge.
        """
        pulumi.set(__self__, "max_bitrate", max_bitrate)

    @_builtins.property
    @pulumi.getter(name="maxBitrate")
    def max_bitrate(self) -> pulumi.Input[_builtins.int]:
        """
        The maximum expected bitrate of the egress bridge.
        """
        return pulumi.get(self, "max_bitrate")

    @max_bitrate.setter
    def max_bitrate(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max_bitrate", value)


if not MYPY:
    class BridgeFailoverConfigArgsDict(TypedDict):
        """
        The settings for source failover.
        """
        failover_mode: pulumi.Input['BridgeFailoverModeEnum']
        """
        The type of failover you choose for this flow. FAILOVER allows switching between different streams.
        """
        source_priority: NotRequired[pulumi.Input['BridgeSourcePriorityArgsDict']]
        """
        The priority you want to assign to a source. You can have a primary stream and a backup stream or two equally prioritized streams.
        """
        state: NotRequired[pulumi.Input['BridgeFailoverConfigStateEnum']]
        """
        The state of source failover on the flow. If the state is inactive, the flow can have only one source. If the state is active, the flow can have one or two sources.
        """
elif False:
    BridgeFailoverConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BridgeFailoverConfigArgs:
    def __init__(__self__, *,
                 failover_mode: pulumi.Input['BridgeFailoverModeEnum'],
                 source_priority: Optional[pulumi.Input['BridgeSourcePriorityArgs']] = None,
                 state: Optional[pulumi.Input['BridgeFailoverConfigStateEnum']] = None):
        """
        The settings for source failover.
        :param pulumi.Input['BridgeFailoverModeEnum'] failover_mode: The type of failover you choose for this flow. FAILOVER allows switching between different streams.
        :param pulumi.Input['BridgeSourcePriorityArgs'] source_priority: The priority you want to assign to a source. You can have a primary stream and a backup stream or two equally prioritized streams.
        :param pulumi.Input['BridgeFailoverConfigStateEnum'] state: The state of source failover on the flow. If the state is inactive, the flow can have only one source. If the state is active, the flow can have one or two sources.
        """
        pulumi.set(__self__, "failover_mode", failover_mode)
        if source_priority is not None:
            pulumi.set(__self__, "source_priority", source_priority)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="failoverMode")
    def failover_mode(self) -> pulumi.Input['BridgeFailoverModeEnum']:
        """
        The type of failover you choose for this flow. FAILOVER allows switching between different streams.
        """
        return pulumi.get(self, "failover_mode")

    @failover_mode.setter
    def failover_mode(self, value: pulumi.Input['BridgeFailoverModeEnum']):
        pulumi.set(self, "failover_mode", value)

    @_builtins.property
    @pulumi.getter(name="sourcePriority")
    def source_priority(self) -> Optional[pulumi.Input['BridgeSourcePriorityArgs']]:
        """
        The priority you want to assign to a source. You can have a primary stream and a backup stream or two equally prioritized streams.
        """
        return pulumi.get(self, "source_priority")

    @source_priority.setter
    def source_priority(self, value: Optional[pulumi.Input['BridgeSourcePriorityArgs']]):
        pulumi.set(self, "source_priority", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input['BridgeFailoverConfigStateEnum']]:
        """
        The state of source failover on the flow. If the state is inactive, the flow can have only one source. If the state is active, the flow can have one or two sources.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input['BridgeFailoverConfigStateEnum']]):
        pulumi.set(self, "state", value)


if not MYPY:
    class BridgeFlowSourceArgsDict(TypedDict):
        """
        The source of the bridge. A flow source originates in MediaConnect as an existing cloud flow.
        """
        flow_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the cloud flow used as a source of this bridge.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the flow source.
        """
        flow_vpc_interface_attachment: NotRequired[pulumi.Input['BridgeVpcInterfaceAttachmentArgsDict']]
        """
        The name of the VPC interface attachment to use for this source.
        """
elif False:
    BridgeFlowSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BridgeFlowSourceArgs:
    def __init__(__self__, *,
                 flow_arn: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 flow_vpc_interface_attachment: Optional[pulumi.Input['BridgeVpcInterfaceAttachmentArgs']] = None):
        """
        The source of the bridge. A flow source originates in MediaConnect as an existing cloud flow.
        :param pulumi.Input[_builtins.str] flow_arn: The ARN of the cloud flow used as a source of this bridge.
        :param pulumi.Input[_builtins.str] name: The name of the flow source.
        :param pulumi.Input['BridgeVpcInterfaceAttachmentArgs'] flow_vpc_interface_attachment: The name of the VPC interface attachment to use for this source.
        """
        pulumi.set(__self__, "flow_arn", flow_arn)
        pulumi.set(__self__, "name", name)
        if flow_vpc_interface_attachment is not None:
            pulumi.set(__self__, "flow_vpc_interface_attachment", flow_vpc_interface_attachment)

    @_builtins.property
    @pulumi.getter(name="flowArn")
    def flow_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the cloud flow used as a source of this bridge.
        """
        return pulumi.get(self, "flow_arn")

    @flow_arn.setter
    def flow_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "flow_arn", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the flow source.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="flowVpcInterfaceAttachment")
    def flow_vpc_interface_attachment(self) -> Optional[pulumi.Input['BridgeVpcInterfaceAttachmentArgs']]:
        """
        The name of the VPC interface attachment to use for this source.
        """
        return pulumi.get(self, "flow_vpc_interface_attachment")

    @flow_vpc_interface_attachment.setter
    def flow_vpc_interface_attachment(self, value: Optional[pulumi.Input['BridgeVpcInterfaceAttachmentArgs']]):
        pulumi.set(self, "flow_vpc_interface_attachment", value)


if not MYPY:
    class BridgeIngressGatewayBridgeArgsDict(TypedDict):
        max_bitrate: pulumi.Input[_builtins.int]
        """
        The maximum expected bitrate of the ingress bridge.
        """
        max_outputs: pulumi.Input[_builtins.int]
        """
        The maximum number of outputs on the ingress bridge.
        """
elif False:
    BridgeIngressGatewayBridgeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BridgeIngressGatewayBridgeArgs:
    def __init__(__self__, *,
                 max_bitrate: pulumi.Input[_builtins.int],
                 max_outputs: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] max_bitrate: The maximum expected bitrate of the ingress bridge.
        :param pulumi.Input[_builtins.int] max_outputs: The maximum number of outputs on the ingress bridge.
        """
        pulumi.set(__self__, "max_bitrate", max_bitrate)
        pulumi.set(__self__, "max_outputs", max_outputs)

    @_builtins.property
    @pulumi.getter(name="maxBitrate")
    def max_bitrate(self) -> pulumi.Input[_builtins.int]:
        """
        The maximum expected bitrate of the ingress bridge.
        """
        return pulumi.get(self, "max_bitrate")

    @max_bitrate.setter
    def max_bitrate(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max_bitrate", value)

    @_builtins.property
    @pulumi.getter(name="maxOutputs")
    def max_outputs(self) -> pulumi.Input[_builtins.int]:
        """
        The maximum number of outputs on the ingress bridge.
        """
        return pulumi.get(self, "max_outputs")

    @max_outputs.setter
    def max_outputs(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max_outputs", value)


if not MYPY:
    class BridgeMulticastSourceSettingsArgsDict(TypedDict):
        """
        The settings related to the multicast source.
        """
        multicast_source_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP address of the source for source-specific multicast (SSM).
        """
elif False:
    BridgeMulticastSourceSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BridgeMulticastSourceSettingsArgs:
    def __init__(__self__, *,
                 multicast_source_ip: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The settings related to the multicast source.
        :param pulumi.Input[_builtins.str] multicast_source_ip: The IP address of the source for source-specific multicast (SSM).
        """
        if multicast_source_ip is not None:
            pulumi.set(__self__, "multicast_source_ip", multicast_source_ip)

    @_builtins.property
    @pulumi.getter(name="multicastSourceIp")
    def multicast_source_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP address of the source for source-specific multicast (SSM).
        """
        return pulumi.get(self, "multicast_source_ip")

    @multicast_source_ip.setter
    def multicast_source_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "multicast_source_ip", value)


if not MYPY:
    class BridgeNetworkOutputArgsDict(TypedDict):
        """
        The output of the bridge. A network output is delivered to your premises.
        """
        ip_address: pulumi.Input[_builtins.str]
        """
        The network output IP Address.
        """
        name: pulumi.Input[_builtins.str]
        """
        The network output name.
        """
        network_name: pulumi.Input[_builtins.str]
        """
        The network output's gateway network name.
        """
        port: pulumi.Input[_builtins.int]
        """
        The network output port.
        """
        protocol: pulumi.Input['BridgeProtocolEnum']
        """
        The network output protocol.
        """
        ttl: pulumi.Input[_builtins.int]
        """
        The network output TTL.
        """
elif False:
    BridgeNetworkOutputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BridgeNetworkOutputArgs:
    def __init__(__self__, *,
                 ip_address: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 network_name: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int],
                 protocol: pulumi.Input['BridgeProtocolEnum'],
                 ttl: pulumi.Input[_builtins.int]):
        """
        The output of the bridge. A network output is delivered to your premises.
        :param pulumi.Input[_builtins.str] ip_address: The network output IP Address.
        :param pulumi.Input[_builtins.str] name: The network output name.
        :param pulumi.Input[_builtins.str] network_name: The network output's gateway network name.
        :param pulumi.Input[_builtins.int] port: The network output port.
        :param pulumi.Input['BridgeProtocolEnum'] protocol: The network output protocol.
        :param pulumi.Input[_builtins.int] ttl: The network output TTL.
        """
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_name", network_name)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> pulumi.Input[_builtins.str]:
        """
        The network output IP Address.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip_address", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The network output name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="networkName")
    def network_name(self) -> pulumi.Input[_builtins.str]:
        """
        The network output's gateway network name.
        """
        return pulumi.get(self, "network_name")

    @network_name.setter
    def network_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "network_name", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        The network output port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> pulumi.Input['BridgeProtocolEnum']:
        """
        The network output protocol.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input['BridgeProtocolEnum']):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> pulumi.Input[_builtins.int]:
        """
        The network output TTL.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "ttl", value)


if not MYPY:
    class BridgeNetworkSourceArgsDict(TypedDict):
        """
        The source of the bridge. A network source originates at your premises.
        """
        multicast_ip: pulumi.Input[_builtins.str]
        """
        The network source multicast IP.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the network source.
        """
        network_name: pulumi.Input[_builtins.str]
        """
        The network source's gateway network name.
        """
        port: pulumi.Input[_builtins.int]
        """
        The network source port.
        """
        protocol: pulumi.Input['BridgeProtocolEnum']
        """
        The network source protocol.
        """
        multicast_source_settings: NotRequired[pulumi.Input['BridgeMulticastSourceSettingsArgsDict']]
        """
        The settings related to the multicast source.
        """
elif False:
    BridgeNetworkSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BridgeNetworkSourceArgs:
    def __init__(__self__, *,
                 multicast_ip: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 network_name: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int],
                 protocol: pulumi.Input['BridgeProtocolEnum'],
                 multicast_source_settings: Optional[pulumi.Input['BridgeMulticastSourceSettingsArgs']] = None):
        """
        The source of the bridge. A network source originates at your premises.
        :param pulumi.Input[_builtins.str] multicast_ip: The network source multicast IP.
        :param pulumi.Input[_builtins.str] name: The name of the network source.
        :param pulumi.Input[_builtins.str] network_name: The network source's gateway network name.
        :param pulumi.Input[_builtins.int] port: The network source port.
        :param pulumi.Input['BridgeProtocolEnum'] protocol: The network source protocol.
        :param pulumi.Input['BridgeMulticastSourceSettingsArgs'] multicast_source_settings: The settings related to the multicast source.
        """
        pulumi.set(__self__, "multicast_ip", multicast_ip)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "network_name", network_name)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        if multicast_source_settings is not None:
            pulumi.set(__self__, "multicast_source_settings", multicast_source_settings)

    @_builtins.property
    @pulumi.getter(name="multicastIp")
    def multicast_ip(self) -> pulumi.Input[_builtins.str]:
        """
        The network source multicast IP.
        """
        return pulumi.get(self, "multicast_ip")

    @multicast_ip.setter
    def multicast_ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "multicast_ip", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the network source.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="networkName")
    def network_name(self) -> pulumi.Input[_builtins.str]:
        """
        The network source's gateway network name.
        """
        return pulumi.get(self, "network_name")

    @network_name.setter
    def network_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "network_name", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        The network source port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> pulumi.Input['BridgeProtocolEnum']:
        """
        The network source protocol.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input['BridgeProtocolEnum']):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="multicastSourceSettings")
    def multicast_source_settings(self) -> Optional[pulumi.Input['BridgeMulticastSourceSettingsArgs']]:
        """
        The settings related to the multicast source.
        """
        return pulumi.get(self, "multicast_source_settings")

    @multicast_source_settings.setter
    def multicast_source_settings(self, value: Optional[pulumi.Input['BridgeMulticastSourceSettingsArgs']]):
        pulumi.set(self, "multicast_source_settings", value)


if not MYPY:
    class BridgeOutputResourceBridgeNetworkOutputArgsDict(TypedDict):
        """
        The output of the bridge. A network output is delivered to your premises.
        """
        ip_address: pulumi.Input[_builtins.str]
        """
        The network output IP Address.
        """
        network_name: pulumi.Input[_builtins.str]
        """
        The network output's gateway network name.
        """
        port: pulumi.Input[_builtins.int]
        """
        The network output port.
        """
        protocol: pulumi.Input['BridgeOutputResourceBridgeNetworkOutputProtocol']
        """
        The network output protocol.
        """
        ttl: pulumi.Input[_builtins.int]
        """
        The network output TTL.
        """
elif False:
    BridgeOutputResourceBridgeNetworkOutputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BridgeOutputResourceBridgeNetworkOutputArgs:
    def __init__(__self__, *,
                 ip_address: pulumi.Input[_builtins.str],
                 network_name: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int],
                 protocol: pulumi.Input['BridgeOutputResourceBridgeNetworkOutputProtocol'],
                 ttl: pulumi.Input[_builtins.int]):
        """
        The output of the bridge. A network output is delivered to your premises.
        :param pulumi.Input[_builtins.str] ip_address: The network output IP Address.
        :param pulumi.Input[_builtins.str] network_name: The network output's gateway network name.
        :param pulumi.Input[_builtins.int] port: The network output port.
        :param pulumi.Input['BridgeOutputResourceBridgeNetworkOutputProtocol'] protocol: The network output protocol.
        :param pulumi.Input[_builtins.int] ttl: The network output TTL.
        """
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "network_name", network_name)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> pulumi.Input[_builtins.str]:
        """
        The network output IP Address.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip_address", value)

    @_builtins.property
    @pulumi.getter(name="networkName")
    def network_name(self) -> pulumi.Input[_builtins.str]:
        """
        The network output's gateway network name.
        """
        return pulumi.get(self, "network_name")

    @network_name.setter
    def network_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "network_name", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        The network output port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> pulumi.Input['BridgeOutputResourceBridgeNetworkOutputProtocol']:
        """
        The network output protocol.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input['BridgeOutputResourceBridgeNetworkOutputProtocol']):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> pulumi.Input[_builtins.int]:
        """
        The network output TTL.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "ttl", value)


if not MYPY:
    class BridgeOutputArgsDict(TypedDict):
        """
        The output of the bridge.
        """
        network_output: NotRequired[pulumi.Input['BridgeNetworkOutputArgsDict']]
        """
        The output of the bridge. A network output is delivered to your premises.
        """
elif False:
    BridgeOutputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BridgeOutputArgs:
    def __init__(__self__, *,
                 network_output: Optional[pulumi.Input['BridgeNetworkOutputArgs']] = None):
        """
        The output of the bridge.
        :param pulumi.Input['BridgeNetworkOutputArgs'] network_output: The output of the bridge. A network output is delivered to your premises.
        """
        if network_output is not None:
            pulumi.set(__self__, "network_output", network_output)

    @_builtins.property
    @pulumi.getter(name="networkOutput")
    def network_output(self) -> Optional[pulumi.Input['BridgeNetworkOutputArgs']]:
        """
        The output of the bridge. A network output is delivered to your premises.
        """
        return pulumi.get(self, "network_output")

    @network_output.setter
    def network_output(self, value: Optional[pulumi.Input['BridgeNetworkOutputArgs']]):
        pulumi.set(self, "network_output", value)


if not MYPY:
    class BridgeSourceBridgeFlowSourceArgsDict(TypedDict):
        """
        The source of the bridge. A flow source originates in MediaConnect as an existing cloud flow.
        """
        flow_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the cloud flow used as a source of this bridge.
        """
        flow_vpc_interface_attachment: NotRequired[pulumi.Input['BridgeSourceVpcInterfaceAttachmentArgsDict']]
        """
        The name of the VPC interface attachment to use for this source.
        """
elif False:
    BridgeSourceBridgeFlowSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BridgeSourceBridgeFlowSourceArgs:
    def __init__(__self__, *,
                 flow_arn: pulumi.Input[_builtins.str],
                 flow_vpc_interface_attachment: Optional[pulumi.Input['BridgeSourceVpcInterfaceAttachmentArgs']] = None):
        """
        The source of the bridge. A flow source originates in MediaConnect as an existing cloud flow.
        :param pulumi.Input[_builtins.str] flow_arn: The ARN of the cloud flow used as a source of this bridge.
        :param pulumi.Input['BridgeSourceVpcInterfaceAttachmentArgs'] flow_vpc_interface_attachment: The name of the VPC interface attachment to use for this source.
        """
        pulumi.set(__self__, "flow_arn", flow_arn)
        if flow_vpc_interface_attachment is not None:
            pulumi.set(__self__, "flow_vpc_interface_attachment", flow_vpc_interface_attachment)

    @_builtins.property
    @pulumi.getter(name="flowArn")
    def flow_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the cloud flow used as a source of this bridge.
        """
        return pulumi.get(self, "flow_arn")

    @flow_arn.setter
    def flow_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "flow_arn", value)

    @_builtins.property
    @pulumi.getter(name="flowVpcInterfaceAttachment")
    def flow_vpc_interface_attachment(self) -> Optional[pulumi.Input['BridgeSourceVpcInterfaceAttachmentArgs']]:
        """
        The name of the VPC interface attachment to use for this source.
        """
        return pulumi.get(self, "flow_vpc_interface_attachment")

    @flow_vpc_interface_attachment.setter
    def flow_vpc_interface_attachment(self, value: Optional[pulumi.Input['BridgeSourceVpcInterfaceAttachmentArgs']]):
        pulumi.set(self, "flow_vpc_interface_attachment", value)


if not MYPY:
    class BridgeSourceBridgeNetworkSourceArgsDict(TypedDict):
        """
        The source of the bridge. A network source originates at your premises.
        """
        multicast_ip: pulumi.Input[_builtins.str]
        """
        The network source multicast IP.
        """
        network_name: pulumi.Input[_builtins.str]
        """
        The network source's gateway network name.
        """
        port: pulumi.Input[_builtins.int]
        """
        The network source port.
        """
        protocol: pulumi.Input['BridgeSourceProtocolEnum']
        """
        The network source protocol.
        """
        multicast_source_settings: NotRequired[pulumi.Input['BridgeSourceMulticastSourceSettingsArgsDict']]
        """
        The settings related to the multicast source.
        """
elif False:
    BridgeSourceBridgeNetworkSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BridgeSourceBridgeNetworkSourceArgs:
    def __init__(__self__, *,
                 multicast_ip: pulumi.Input[_builtins.str],
                 network_name: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int],
                 protocol: pulumi.Input['BridgeSourceProtocolEnum'],
                 multicast_source_settings: Optional[pulumi.Input['BridgeSourceMulticastSourceSettingsArgs']] = None):
        """
        The source of the bridge. A network source originates at your premises.
        :param pulumi.Input[_builtins.str] multicast_ip: The network source multicast IP.
        :param pulumi.Input[_builtins.str] network_name: The network source's gateway network name.
        :param pulumi.Input[_builtins.int] port: The network source port.
        :param pulumi.Input['BridgeSourceProtocolEnum'] protocol: The network source protocol.
        :param pulumi.Input['BridgeSourceMulticastSourceSettingsArgs'] multicast_source_settings: The settings related to the multicast source.
        """
        pulumi.set(__self__, "multicast_ip", multicast_ip)
        pulumi.set(__self__, "network_name", network_name)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        if multicast_source_settings is not None:
            pulumi.set(__self__, "multicast_source_settings", multicast_source_settings)

    @_builtins.property
    @pulumi.getter(name="multicastIp")
    def multicast_ip(self) -> pulumi.Input[_builtins.str]:
        """
        The network source multicast IP.
        """
        return pulumi.get(self, "multicast_ip")

    @multicast_ip.setter
    def multicast_ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "multicast_ip", value)

    @_builtins.property
    @pulumi.getter(name="networkName")
    def network_name(self) -> pulumi.Input[_builtins.str]:
        """
        The network source's gateway network name.
        """
        return pulumi.get(self, "network_name")

    @network_name.setter
    def network_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "network_name", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        The network source port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> pulumi.Input['BridgeSourceProtocolEnum']:
        """
        The network source protocol.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input['BridgeSourceProtocolEnum']):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="multicastSourceSettings")
    def multicast_source_settings(self) -> Optional[pulumi.Input['BridgeSourceMulticastSourceSettingsArgs']]:
        """
        The settings related to the multicast source.
        """
        return pulumi.get(self, "multicast_source_settings")

    @multicast_source_settings.setter
    def multicast_source_settings(self, value: Optional[pulumi.Input['BridgeSourceMulticastSourceSettingsArgs']]):
        pulumi.set(self, "multicast_source_settings", value)


if not MYPY:
    class BridgeSourceMulticastSourceSettingsArgsDict(TypedDict):
        """
        The settings related to the multicast source.
        """
        multicast_source_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP address of the source for source-specific multicast (SSM).
        """
elif False:
    BridgeSourceMulticastSourceSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BridgeSourceMulticastSourceSettingsArgs:
    def __init__(__self__, *,
                 multicast_source_ip: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The settings related to the multicast source.
        :param pulumi.Input[_builtins.str] multicast_source_ip: The IP address of the source for source-specific multicast (SSM).
        """
        if multicast_source_ip is not None:
            pulumi.set(__self__, "multicast_source_ip", multicast_source_ip)

    @_builtins.property
    @pulumi.getter(name="multicastSourceIp")
    def multicast_source_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP address of the source for source-specific multicast (SSM).
        """
        return pulumi.get(self, "multicast_source_ip")

    @multicast_source_ip.setter
    def multicast_source_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "multicast_source_ip", value)


if not MYPY:
    class BridgeSourcePriorityArgsDict(TypedDict):
        """
        The priority you want to assign to a source. You can have a primary stream and a backup stream or two equally prioritized streams.
        """
        primary_source: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the source you choose as the primary source for this flow.
        """
elif False:
    BridgeSourcePriorityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BridgeSourcePriorityArgs:
    def __init__(__self__, *,
                 primary_source: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The priority you want to assign to a source. You can have a primary stream and a backup stream or two equally prioritized streams.
        :param pulumi.Input[_builtins.str] primary_source: The name of the source you choose as the primary source for this flow.
        """
        if primary_source is not None:
            pulumi.set(__self__, "primary_source", primary_source)

    @_builtins.property
    @pulumi.getter(name="primarySource")
    def primary_source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the source you choose as the primary source for this flow.
        """
        return pulumi.get(self, "primary_source")

    @primary_source.setter
    def primary_source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "primary_source", value)


if not MYPY:
    class BridgeSourceVpcInterfaceAttachmentArgsDict(TypedDict):
        """
        The settings for attaching a VPC interface to an resource.
        """
        vpc_interface_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the VPC interface to use for this resource.
        """
elif False:
    BridgeSourceVpcInterfaceAttachmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BridgeSourceVpcInterfaceAttachmentArgs:
    def __init__(__self__, *,
                 vpc_interface_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The settings for attaching a VPC interface to an resource.
        :param pulumi.Input[_builtins.str] vpc_interface_name: The name of the VPC interface to use for this resource.
        """
        if vpc_interface_name is not None:
            pulumi.set(__self__, "vpc_interface_name", vpc_interface_name)

    @_builtins.property
    @pulumi.getter(name="vpcInterfaceName")
    def vpc_interface_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the VPC interface to use for this resource.
        """
        return pulumi.get(self, "vpc_interface_name")

    @vpc_interface_name.setter
    def vpc_interface_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vpc_interface_name", value)


if not MYPY:
    class BridgeSourceArgsDict(TypedDict):
        """
        The bridge's source.
        """
        flow_source: NotRequired[pulumi.Input['BridgeFlowSourceArgsDict']]
        """
        The source of the bridge. A flow source originates in MediaConnect as an existing cloud flow.
        """
        network_source: NotRequired[pulumi.Input['BridgeNetworkSourceArgsDict']]
        """
        The source of the bridge. A network source originates at your premises.
        """
elif False:
    BridgeSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BridgeSourceArgs:
    def __init__(__self__, *,
                 flow_source: Optional[pulumi.Input['BridgeFlowSourceArgs']] = None,
                 network_source: Optional[pulumi.Input['BridgeNetworkSourceArgs']] = None):
        """
        The bridge's source.
        :param pulumi.Input['BridgeFlowSourceArgs'] flow_source: The source of the bridge. A flow source originates in MediaConnect as an existing cloud flow.
        :param pulumi.Input['BridgeNetworkSourceArgs'] network_source: The source of the bridge. A network source originates at your premises.
        """
        if flow_source is not None:
            pulumi.set(__self__, "flow_source", flow_source)
        if network_source is not None:
            pulumi.set(__self__, "network_source", network_source)

    @_builtins.property
    @pulumi.getter(name="flowSource")
    def flow_source(self) -> Optional[pulumi.Input['BridgeFlowSourceArgs']]:
        """
        The source of the bridge. A flow source originates in MediaConnect as an existing cloud flow.
        """
        return pulumi.get(self, "flow_source")

    @flow_source.setter
    def flow_source(self, value: Optional[pulumi.Input['BridgeFlowSourceArgs']]):
        pulumi.set(self, "flow_source", value)

    @_builtins.property
    @pulumi.getter(name="networkSource")
    def network_source(self) -> Optional[pulumi.Input['BridgeNetworkSourceArgs']]:
        """
        The source of the bridge. A network source originates at your premises.
        """
        return pulumi.get(self, "network_source")

    @network_source.setter
    def network_source(self, value: Optional[pulumi.Input['BridgeNetworkSourceArgs']]):
        pulumi.set(self, "network_source", value)


if not MYPY:
    class BridgeVpcInterfaceAttachmentArgsDict(TypedDict):
        """
        The settings for attaching a VPC interface to an resource.
        """
        vpc_interface_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the VPC interface to use for this resource.
        """
elif False:
    BridgeVpcInterfaceAttachmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BridgeVpcInterfaceAttachmentArgs:
    def __init__(__self__, *,
                 vpc_interface_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The settings for attaching a VPC interface to an resource.
        :param pulumi.Input[_builtins.str] vpc_interface_name: The name of the VPC interface to use for this resource.
        """
        if vpc_interface_name is not None:
            pulumi.set(__self__, "vpc_interface_name", vpc_interface_name)

    @_builtins.property
    @pulumi.getter(name="vpcInterfaceName")
    def vpc_interface_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the VPC interface to use for this resource.
        """
        return pulumi.get(self, "vpc_interface_name")

    @vpc_interface_name.setter
    def vpc_interface_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vpc_interface_name", value)


if not MYPY:
    class FlowAudioMonitoringSettingArgsDict(TypedDict):
        """
        Specifies the configuration for audio stream metrics monitoring.
        """
        silent_audio: NotRequired[pulumi.Input['FlowSilentAudioArgsDict']]
        """
        Detects periods of silence.
        """
elif False:
    FlowAudioMonitoringSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowAudioMonitoringSettingArgs:
    def __init__(__self__, *,
                 silent_audio: Optional[pulumi.Input['FlowSilentAudioArgs']] = None):
        """
        Specifies the configuration for audio stream metrics monitoring.
        :param pulumi.Input['FlowSilentAudioArgs'] silent_audio: Detects periods of silence.
        """
        if silent_audio is not None:
            pulumi.set(__self__, "silent_audio", silent_audio)

    @_builtins.property
    @pulumi.getter(name="silentAudio")
    def silent_audio(self) -> Optional[pulumi.Input['FlowSilentAudioArgs']]:
        """
        Detects periods of silence.
        """
        return pulumi.get(self, "silent_audio")

    @silent_audio.setter
    def silent_audio(self, value: Optional[pulumi.Input['FlowSilentAudioArgs']]):
        pulumi.set(self, "silent_audio", value)


if not MYPY:
    class FlowAutomaticEncryptionKeyConfigurationArgsDict(TypedDict):
        """
        Configuration settings for automatic encryption key management, where MediaConnect handles key creation and rotation.
        """
        pass
elif False:
    FlowAutomaticEncryptionKeyConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowAutomaticEncryptionKeyConfigurationArgs:
    def __init__(__self__):
        """
        Configuration settings for automatic encryption key management, where MediaConnect handles key creation and rotation.
        """
        pass


if not MYPY:
    class FlowBlackFramesArgsDict(TypedDict):
        """
        Configures settings for the BlackFrames metric.
        """
        state: NotRequired[pulumi.Input['FlowBlackFramesState']]
        """
        Indicates whether the BlackFrames metric is enabled or disabled.
        """
        threshold_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of consecutive seconds of black frames that triggers an event or alert.
        """
elif False:
    FlowBlackFramesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowBlackFramesArgs:
    def __init__(__self__, *,
                 state: Optional[pulumi.Input['FlowBlackFramesState']] = None,
                 threshold_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        Configures settings for the BlackFrames metric.
        :param pulumi.Input['FlowBlackFramesState'] state: Indicates whether the BlackFrames metric is enabled or disabled.
        :param pulumi.Input[_builtins.int] threshold_seconds: Specifies the number of consecutive seconds of black frames that triggers an event or alert.
        """
        if state is not None:
            pulumi.set(__self__, "state", state)
        if threshold_seconds is not None:
            pulumi.set(__self__, "threshold_seconds", threshold_seconds)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input['FlowBlackFramesState']]:
        """
        Indicates whether the BlackFrames metric is enabled or disabled.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input['FlowBlackFramesState']]):
        pulumi.set(self, "state", value)

    @_builtins.property
    @pulumi.getter(name="thresholdSeconds")
    def threshold_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of consecutive seconds of black frames that triggers an event or alert.
        """
        return pulumi.get(self, "threshold_seconds")

    @threshold_seconds.setter
    def threshold_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "threshold_seconds", value)


if not MYPY:
    class FlowEncryptionArgsDict(TypedDict):
        """
        Information about the encryption of the flow.
        """
        role_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the role that you created during setup (when you set up AWS Elemental MediaConnect as a trusted entity).
        """
        algorithm: NotRequired[pulumi.Input['FlowEncryptionAlgorithm']]
        """
        The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
        """
        constant_initialization_vector: NotRequired[pulumi.Input[_builtins.str]]
        """
        A 128-bit, 16-byte hex value represented by a 32-character string, to be used with the key for encrypting content. This parameter is not valid for static key encryption.
        """
        device_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of one of the devices that you configured with your digital rights management (DRM) platform key provider. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        """
        key_type: NotRequired[pulumi.Input['FlowEncryptionKeyType']]
        """
        The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        The AWS Region that the API Gateway proxy endpoint was created in. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        """
        resource_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        An identifier for the content. The service sends this value to the key server to identify the current endpoint. The resource ID is also known as the content ID. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        """
        secret_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
         The ARN of the secret that you created in AWS Secrets Manager to store the encryption key. This parameter is required for static key encryption and is not valid for SPEKE encryption.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL from the API Gateway proxy that you set up to talk to your key server. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        """
elif False:
    FlowEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowEncryptionArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[_builtins.str],
                 algorithm: Optional[pulumi.Input['FlowEncryptionAlgorithm']] = None,
                 constant_initialization_vector: Optional[pulumi.Input[_builtins.str]] = None,
                 device_id: Optional[pulumi.Input[_builtins.str]] = None,
                 key_type: Optional[pulumi.Input['FlowEncryptionKeyType']] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Information about the encryption of the flow.
        :param pulumi.Input[_builtins.str] role_arn: The ARN of the role that you created during setup (when you set up AWS Elemental MediaConnect as a trusted entity).
        :param pulumi.Input['FlowEncryptionAlgorithm'] algorithm: The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
        :param pulumi.Input[_builtins.str] constant_initialization_vector: A 128-bit, 16-byte hex value represented by a 32-character string, to be used with the key for encrypting content. This parameter is not valid for static key encryption.
        :param pulumi.Input[_builtins.str] device_id: The value of one of the devices that you configured with your digital rights management (DRM) platform key provider. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        :param pulumi.Input['FlowEncryptionKeyType'] key_type: The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
        :param pulumi.Input[_builtins.str] region: The AWS Region that the API Gateway proxy endpoint was created in. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        :param pulumi.Input[_builtins.str] resource_id: An identifier for the content. The service sends this value to the key server to identify the current endpoint. The resource ID is also known as the content ID. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        :param pulumi.Input[_builtins.str] secret_arn:  The ARN of the secret that you created in AWS Secrets Manager to store the encryption key. This parameter is required for static key encryption and is not valid for SPEKE encryption.
        :param pulumi.Input[_builtins.str] url: The URL from the API Gateway proxy that you set up to talk to your key server. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        """
        pulumi.set(__self__, "role_arn", role_arn)
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if constant_initialization_vector is not None:
            pulumi.set(__self__, "constant_initialization_vector", constant_initialization_vector)
        if device_id is not None:
            pulumi.set(__self__, "device_id", device_id)
        if key_type is not None:
            pulumi.set(__self__, "key_type", key_type)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if secret_arn is not None:
            pulumi.set(__self__, "secret_arn", secret_arn)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the role that you created during setup (when you set up AWS Elemental MediaConnect as a trusted entity).
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter
    def algorithm(self) -> Optional[pulumi.Input['FlowEncryptionAlgorithm']]:
        """
        The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: Optional[pulumi.Input['FlowEncryptionAlgorithm']]):
        pulumi.set(self, "algorithm", value)

    @_builtins.property
    @pulumi.getter(name="constantInitializationVector")
    def constant_initialization_vector(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A 128-bit, 16-byte hex value represented by a 32-character string, to be used with the key for encrypting content. This parameter is not valid for static key encryption.
        """
        return pulumi.get(self, "constant_initialization_vector")

    @constant_initialization_vector.setter
    def constant_initialization_vector(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "constant_initialization_vector", value)

    @_builtins.property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of one of the devices that you configured with your digital rights management (DRM) platform key provider. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        """
        return pulumi.get(self, "device_id")

    @device_id.setter
    def device_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device_id", value)

    @_builtins.property
    @pulumi.getter(name="keyType")
    def key_type(self) -> Optional[pulumi.Input['FlowEncryptionKeyType']]:
        """
        The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
        """
        return pulumi.get(self, "key_type")

    @key_type.setter
    def key_type(self, value: Optional[pulumi.Input['FlowEncryptionKeyType']]):
        pulumi.set(self, "key_type", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The AWS Region that the API Gateway proxy endpoint was created in. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An identifier for the content. The service sends this value to the key server to identify the current endpoint. The resource ID is also known as the content ID. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_id", value)

    @_builtins.property
    @pulumi.getter(name="secretArn")
    def secret_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
         The ARN of the secret that you created in AWS Secrets Manager to store the encryption key. This parameter is required for static key encryption and is not valid for SPEKE encryption.
        """
        return pulumi.get(self, "secret_arn")

    @secret_arn.setter
    def secret_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_arn", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL from the API Gateway proxy that you set up to talk to your key server. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class FlowEntitlementEncryptionArgsDict(TypedDict):
        """
        Information about the encryption of the flow.
        """
        algorithm: pulumi.Input['FlowEntitlementEncryptionAlgorithm']
        """
        The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
        """
        role_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the role that you created during setup (when you set up AWS Elemental MediaConnect as a trusted entity).
        """
        constant_initialization_vector: NotRequired[pulumi.Input[_builtins.str]]
        """
        A 128-bit, 16-byte hex value represented by a 32-character string, to be used with the key for encrypting content. This parameter is not valid for static key encryption.
        """
        device_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of one of the devices that you configured with your digital rights management (DRM) platform key provider. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        """
        key_type: NotRequired[pulumi.Input['FlowEntitlementEncryptionKeyType']]
        """
        The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        The AWS Region that the API Gateway proxy endpoint was created in. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        """
        resource_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        An identifier for the content. The service sends this value to the key server to identify the current endpoint. The resource ID is also known as the content ID. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        """
        secret_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
         The ARN of the secret that you created in AWS Secrets Manager to store the encryption key. This parameter is required for static key encryption and is not valid for SPEKE encryption.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL from the API Gateway proxy that you set up to talk to your key server. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        """
elif False:
    FlowEntitlementEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowEntitlementEncryptionArgs:
    def __init__(__self__, *,
                 algorithm: pulumi.Input['FlowEntitlementEncryptionAlgorithm'],
                 role_arn: pulumi.Input[_builtins.str],
                 constant_initialization_vector: Optional[pulumi.Input[_builtins.str]] = None,
                 device_id: Optional[pulumi.Input[_builtins.str]] = None,
                 key_type: Optional[pulumi.Input['FlowEntitlementEncryptionKeyType']] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Information about the encryption of the flow.
        :param pulumi.Input['FlowEntitlementEncryptionAlgorithm'] algorithm: The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
        :param pulumi.Input[_builtins.str] role_arn: The ARN of the role that you created during setup (when you set up AWS Elemental MediaConnect as a trusted entity).
        :param pulumi.Input[_builtins.str] constant_initialization_vector: A 128-bit, 16-byte hex value represented by a 32-character string, to be used with the key for encrypting content. This parameter is not valid for static key encryption.
        :param pulumi.Input[_builtins.str] device_id: The value of one of the devices that you configured with your digital rights management (DRM) platform key provider. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        :param pulumi.Input['FlowEntitlementEncryptionKeyType'] key_type: The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
        :param pulumi.Input[_builtins.str] region: The AWS Region that the API Gateway proxy endpoint was created in. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        :param pulumi.Input[_builtins.str] resource_id: An identifier for the content. The service sends this value to the key server to identify the current endpoint. The resource ID is also known as the content ID. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        :param pulumi.Input[_builtins.str] secret_arn:  The ARN of the secret that you created in AWS Secrets Manager to store the encryption key. This parameter is required for static key encryption and is not valid for SPEKE encryption.
        :param pulumi.Input[_builtins.str] url: The URL from the API Gateway proxy that you set up to talk to your key server. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        """
        pulumi.set(__self__, "algorithm", algorithm)
        pulumi.set(__self__, "role_arn", role_arn)
        if constant_initialization_vector is not None:
            pulumi.set(__self__, "constant_initialization_vector", constant_initialization_vector)
        if device_id is not None:
            pulumi.set(__self__, "device_id", device_id)
        if key_type is not None:
            pulumi.set(__self__, "key_type", key_type)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if secret_arn is not None:
            pulumi.set(__self__, "secret_arn", secret_arn)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def algorithm(self) -> pulumi.Input['FlowEntitlementEncryptionAlgorithm']:
        """
        The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: pulumi.Input['FlowEntitlementEncryptionAlgorithm']):
        pulumi.set(self, "algorithm", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the role that you created during setup (when you set up AWS Elemental MediaConnect as a trusted entity).
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="constantInitializationVector")
    def constant_initialization_vector(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A 128-bit, 16-byte hex value represented by a 32-character string, to be used with the key for encrypting content. This parameter is not valid for static key encryption.
        """
        return pulumi.get(self, "constant_initialization_vector")

    @constant_initialization_vector.setter
    def constant_initialization_vector(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "constant_initialization_vector", value)

    @_builtins.property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of one of the devices that you configured with your digital rights management (DRM) platform key provider. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        """
        return pulumi.get(self, "device_id")

    @device_id.setter
    def device_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device_id", value)

    @_builtins.property
    @pulumi.getter(name="keyType")
    def key_type(self) -> Optional[pulumi.Input['FlowEntitlementEncryptionKeyType']]:
        """
        The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
        """
        return pulumi.get(self, "key_type")

    @key_type.setter
    def key_type(self, value: Optional[pulumi.Input['FlowEntitlementEncryptionKeyType']]):
        pulumi.set(self, "key_type", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The AWS Region that the API Gateway proxy endpoint was created in. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An identifier for the content. The service sends this value to the key server to identify the current endpoint. The resource ID is also known as the content ID. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_id", value)

    @_builtins.property
    @pulumi.getter(name="secretArn")
    def secret_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
         The ARN of the secret that you created in AWS Secrets Manager to store the encryption key. This parameter is required for static key encryption and is not valid for SPEKE encryption.
        """
        return pulumi.get(self, "secret_arn")

    @secret_arn.setter
    def secret_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_arn", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL from the API Gateway proxy that you set up to talk to your key server. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class FlowFailoverConfigSourcePriorityPropertiesArgsDict(TypedDict):
        """
        The priority you want to assign to a source. You can have a primary stream and a backup stream or two equally prioritized streams.
        """
        primary_source: pulumi.Input[_builtins.str]
        """
        The name of the source you choose as the primary source for this flow.
        """
elif False:
    FlowFailoverConfigSourcePriorityPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowFailoverConfigSourcePriorityPropertiesArgs:
    def __init__(__self__, *,
                 primary_source: pulumi.Input[_builtins.str]):
        """
        The priority you want to assign to a source. You can have a primary stream and a backup stream or two equally prioritized streams.
        :param pulumi.Input[_builtins.str] primary_source: The name of the source you choose as the primary source for this flow.
        """
        pulumi.set(__self__, "primary_source", primary_source)

    @_builtins.property
    @pulumi.getter(name="primarySource")
    def primary_source(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the source you choose as the primary source for this flow.
        """
        return pulumi.get(self, "primary_source")

    @primary_source.setter
    def primary_source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "primary_source", value)


if not MYPY:
    class FlowFailoverConfigArgsDict(TypedDict):
        """
        The settings for source failover
        """
        failover_mode: NotRequired[pulumi.Input['FlowFailoverConfigFailoverMode']]
        """
        The type of failover you choose for this flow. MERGE combines the source streams into a single stream, allowing graceful recovery from any single-source loss. FAILOVER allows switching between different streams.
        """
        recovery_window: NotRequired[pulumi.Input[_builtins.int]]
        """
        Search window time to look for dash-7 packets
        """
        source_priority: NotRequired[pulumi.Input['FlowFailoverConfigSourcePriorityPropertiesArgsDict']]
        """
        The priority you want to assign to a source. You can have a primary stream and a backup stream or two equally prioritized streams.
        """
        state: NotRequired[pulumi.Input['FlowFailoverConfigState']]
        """
        The state of source failover on the flow. If the state is inactive, the flow can have only one source. If the state is active, the flow can have one or two sources.
        """
elif False:
    FlowFailoverConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowFailoverConfigArgs:
    def __init__(__self__, *,
                 failover_mode: Optional[pulumi.Input['FlowFailoverConfigFailoverMode']] = None,
                 recovery_window: Optional[pulumi.Input[_builtins.int]] = None,
                 source_priority: Optional[pulumi.Input['FlowFailoverConfigSourcePriorityPropertiesArgs']] = None,
                 state: Optional[pulumi.Input['FlowFailoverConfigState']] = None):
        """
        The settings for source failover
        :param pulumi.Input['FlowFailoverConfigFailoverMode'] failover_mode: The type of failover you choose for this flow. MERGE combines the source streams into a single stream, allowing graceful recovery from any single-source loss. FAILOVER allows switching between different streams.
        :param pulumi.Input[_builtins.int] recovery_window: Search window time to look for dash-7 packets
        :param pulumi.Input['FlowFailoverConfigSourcePriorityPropertiesArgs'] source_priority: The priority you want to assign to a source. You can have a primary stream and a backup stream or two equally prioritized streams.
        :param pulumi.Input['FlowFailoverConfigState'] state: The state of source failover on the flow. If the state is inactive, the flow can have only one source. If the state is active, the flow can have one or two sources.
        """
        if failover_mode is not None:
            pulumi.set(__self__, "failover_mode", failover_mode)
        if recovery_window is not None:
            pulumi.set(__self__, "recovery_window", recovery_window)
        if source_priority is not None:
            pulumi.set(__self__, "source_priority", source_priority)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="failoverMode")
    def failover_mode(self) -> Optional[pulumi.Input['FlowFailoverConfigFailoverMode']]:
        """
        The type of failover you choose for this flow. MERGE combines the source streams into a single stream, allowing graceful recovery from any single-source loss. FAILOVER allows switching between different streams.
        """
        return pulumi.get(self, "failover_mode")

    @failover_mode.setter
    def failover_mode(self, value: Optional[pulumi.Input['FlowFailoverConfigFailoverMode']]):
        pulumi.set(self, "failover_mode", value)

    @_builtins.property
    @pulumi.getter(name="recoveryWindow")
    def recovery_window(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Search window time to look for dash-7 packets
        """
        return pulumi.get(self, "recovery_window")

    @recovery_window.setter
    def recovery_window(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "recovery_window", value)

    @_builtins.property
    @pulumi.getter(name="sourcePriority")
    def source_priority(self) -> Optional[pulumi.Input['FlowFailoverConfigSourcePriorityPropertiesArgs']]:
        """
        The priority you want to assign to a source. You can have a primary stream and a backup stream or two equally prioritized streams.
        """
        return pulumi.get(self, "source_priority")

    @source_priority.setter
    def source_priority(self, value: Optional[pulumi.Input['FlowFailoverConfigSourcePriorityPropertiesArgs']]):
        pulumi.set(self, "source_priority", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input['FlowFailoverConfigState']]:
        """
        The state of source failover on the flow. If the state is inactive, the flow can have only one source. If the state is active, the flow can have one or two sources.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input['FlowFailoverConfigState']]):
        pulumi.set(self, "state", value)


if not MYPY:
    class FlowFmtpArgsDict(TypedDict):
        """
        A set of parameters that define the media stream.
        """
        channel_order: NotRequired[pulumi.Input[_builtins.str]]
        """
        The format of the audio channel.
        """
        colorimetry: NotRequired[pulumi.Input['FlowFmtpColorimetry']]
        """
        The format used for the representation of color.
        """
        exact_framerate: NotRequired[pulumi.Input[_builtins.str]]
        """
        The frame rate for the video stream, in frames/second. For example: 60000/1001.
        """
        par: NotRequired[pulumi.Input[_builtins.str]]
        """
        The pixel aspect ratio (PAR) of the video.
        """
        range: NotRequired[pulumi.Input['FlowFmtpRange']]
        """
        The encoding range of the video.
        """
        scan_mode: NotRequired[pulumi.Input['FlowFmtpScanMode']]
        """
        The type of compression that was used to smooth the video's appearance.
        """
        tcs: NotRequired[pulumi.Input['FlowFmtpTcs']]
        """
        The transfer characteristic system (TCS) that is used in the video.
        """
elif False:
    FlowFmtpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowFmtpArgs:
    def __init__(__self__, *,
                 channel_order: Optional[pulumi.Input[_builtins.str]] = None,
                 colorimetry: Optional[pulumi.Input['FlowFmtpColorimetry']] = None,
                 exact_framerate: Optional[pulumi.Input[_builtins.str]] = None,
                 par: Optional[pulumi.Input[_builtins.str]] = None,
                 range: Optional[pulumi.Input['FlowFmtpRange']] = None,
                 scan_mode: Optional[pulumi.Input['FlowFmtpScanMode']] = None,
                 tcs: Optional[pulumi.Input['FlowFmtpTcs']] = None):
        """
        A set of parameters that define the media stream.
        :param pulumi.Input[_builtins.str] channel_order: The format of the audio channel.
        :param pulumi.Input['FlowFmtpColorimetry'] colorimetry: The format used for the representation of color.
        :param pulumi.Input[_builtins.str] exact_framerate: The frame rate for the video stream, in frames/second. For example: 60000/1001.
        :param pulumi.Input[_builtins.str] par: The pixel aspect ratio (PAR) of the video.
        :param pulumi.Input['FlowFmtpRange'] range: The encoding range of the video.
        :param pulumi.Input['FlowFmtpScanMode'] scan_mode: The type of compression that was used to smooth the video's appearance.
        :param pulumi.Input['FlowFmtpTcs'] tcs: The transfer characteristic system (TCS) that is used in the video.
        """
        if channel_order is not None:
            pulumi.set(__self__, "channel_order", channel_order)
        if colorimetry is not None:
            pulumi.set(__self__, "colorimetry", colorimetry)
        if exact_framerate is not None:
            pulumi.set(__self__, "exact_framerate", exact_framerate)
        if par is not None:
            pulumi.set(__self__, "par", par)
        if range is not None:
            pulumi.set(__self__, "range", range)
        if scan_mode is not None:
            pulumi.set(__self__, "scan_mode", scan_mode)
        if tcs is not None:
            pulumi.set(__self__, "tcs", tcs)

    @_builtins.property
    @pulumi.getter(name="channelOrder")
    def channel_order(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The format of the audio channel.
        """
        return pulumi.get(self, "channel_order")

    @channel_order.setter
    def channel_order(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "channel_order", value)

    @_builtins.property
    @pulumi.getter
    def colorimetry(self) -> Optional[pulumi.Input['FlowFmtpColorimetry']]:
        """
        The format used for the representation of color.
        """
        return pulumi.get(self, "colorimetry")

    @colorimetry.setter
    def colorimetry(self, value: Optional[pulumi.Input['FlowFmtpColorimetry']]):
        pulumi.set(self, "colorimetry", value)

    @_builtins.property
    @pulumi.getter(name="exactFramerate")
    def exact_framerate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The frame rate for the video stream, in frames/second. For example: 60000/1001.
        """
        return pulumi.get(self, "exact_framerate")

    @exact_framerate.setter
    def exact_framerate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exact_framerate", value)

    @_builtins.property
    @pulumi.getter
    def par(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The pixel aspect ratio (PAR) of the video.
        """
        return pulumi.get(self, "par")

    @par.setter
    def par(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "par", value)

    @_builtins.property
    @pulumi.getter
    def range(self) -> Optional[pulumi.Input['FlowFmtpRange']]:
        """
        The encoding range of the video.
        """
        return pulumi.get(self, "range")

    @range.setter
    def range(self, value: Optional[pulumi.Input['FlowFmtpRange']]):
        pulumi.set(self, "range", value)

    @_builtins.property
    @pulumi.getter(name="scanMode")
    def scan_mode(self) -> Optional[pulumi.Input['FlowFmtpScanMode']]:
        """
        The type of compression that was used to smooth the video's appearance.
        """
        return pulumi.get(self, "scan_mode")

    @scan_mode.setter
    def scan_mode(self, value: Optional[pulumi.Input['FlowFmtpScanMode']]):
        pulumi.set(self, "scan_mode", value)

    @_builtins.property
    @pulumi.getter
    def tcs(self) -> Optional[pulumi.Input['FlowFmtpTcs']]:
        """
        The transfer characteristic system (TCS) that is used in the video.
        """
        return pulumi.get(self, "tcs")

    @tcs.setter
    def tcs(self, value: Optional[pulumi.Input['FlowFmtpTcs']]):
        pulumi.set(self, "tcs", value)


if not MYPY:
    class FlowFrozenFramesArgsDict(TypedDict):
        """
        Configures settings for the FrozenFrames metric.
        """
        state: NotRequired[pulumi.Input['FlowFrozenFramesState']]
        """
        Indicates whether the FrozenFrames metric is enabled or disabled.
        """
        threshold_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of consecutive seconds of a static image that triggers an event or alert.
        """
elif False:
    FlowFrozenFramesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowFrozenFramesArgs:
    def __init__(__self__, *,
                 state: Optional[pulumi.Input['FlowFrozenFramesState']] = None,
                 threshold_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        Configures settings for the FrozenFrames metric.
        :param pulumi.Input['FlowFrozenFramesState'] state: Indicates whether the FrozenFrames metric is enabled or disabled.
        :param pulumi.Input[_builtins.int] threshold_seconds: Specifies the number of consecutive seconds of a static image that triggers an event or alert.
        """
        if state is not None:
            pulumi.set(__self__, "state", state)
        if threshold_seconds is not None:
            pulumi.set(__self__, "threshold_seconds", threshold_seconds)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input['FlowFrozenFramesState']]:
        """
        Indicates whether the FrozenFrames metric is enabled or disabled.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input['FlowFrozenFramesState']]):
        pulumi.set(self, "state", value)

    @_builtins.property
    @pulumi.getter(name="thresholdSeconds")
    def threshold_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of consecutive seconds of a static image that triggers an event or alert.
        """
        return pulumi.get(self, "threshold_seconds")

    @threshold_seconds.setter
    def threshold_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "threshold_seconds", value)


if not MYPY:
    class FlowGatewayBridgeSourceArgsDict(TypedDict):
        """
        The source configuration for cloud flows receiving a stream from a bridge.
        """
        bridge_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the bridge feeding this flow.
        """
        vpc_interface_attachment: NotRequired[pulumi.Input['FlowVpcInterfaceAttachmentArgsDict']]
        """
        The name of the VPC interface attachment to use for this bridge source.
        """
elif False:
    FlowGatewayBridgeSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowGatewayBridgeSourceArgs:
    def __init__(__self__, *,
                 bridge_arn: pulumi.Input[_builtins.str],
                 vpc_interface_attachment: Optional[pulumi.Input['FlowVpcInterfaceAttachmentArgs']] = None):
        """
        The source configuration for cloud flows receiving a stream from a bridge.
        :param pulumi.Input[_builtins.str] bridge_arn: The ARN of the bridge feeding this flow.
        :param pulumi.Input['FlowVpcInterfaceAttachmentArgs'] vpc_interface_attachment: The name of the VPC interface attachment to use for this bridge source.
        """
        pulumi.set(__self__, "bridge_arn", bridge_arn)
        if vpc_interface_attachment is not None:
            pulumi.set(__self__, "vpc_interface_attachment", vpc_interface_attachment)

    @_builtins.property
    @pulumi.getter(name="bridgeArn")
    def bridge_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the bridge feeding this flow.
        """
        return pulumi.get(self, "bridge_arn")

    @bridge_arn.setter
    def bridge_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bridge_arn", value)

    @_builtins.property
    @pulumi.getter(name="vpcInterfaceAttachment")
    def vpc_interface_attachment(self) -> Optional[pulumi.Input['FlowVpcInterfaceAttachmentArgs']]:
        """
        The name of the VPC interface attachment to use for this bridge source.
        """
        return pulumi.get(self, "vpc_interface_attachment")

    @vpc_interface_attachment.setter
    def vpc_interface_attachment(self, value: Optional[pulumi.Input['FlowVpcInterfaceAttachmentArgs']]):
        pulumi.set(self, "vpc_interface_attachment", value)


if not MYPY:
    class FlowInputConfigurationArgsDict(TypedDict):
        """
        The transport parameters associated with an incoming media stream.
        """
        input_port: pulumi.Input[_builtins.int]
        """
        The port that the flow listens on for an incoming media stream.
        """
        interface: pulumi.Input['FlowInterfaceArgsDict']
        """
        The VPC interface where the media stream comes in from.
        """
elif False:
    FlowInputConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowInputConfigurationArgs:
    def __init__(__self__, *,
                 input_port: pulumi.Input[_builtins.int],
                 interface: pulumi.Input['FlowInterfaceArgs']):
        """
        The transport parameters associated with an incoming media stream.
        :param pulumi.Input[_builtins.int] input_port: The port that the flow listens on for an incoming media stream.
        :param pulumi.Input['FlowInterfaceArgs'] interface: The VPC interface where the media stream comes in from.
        """
        pulumi.set(__self__, "input_port", input_port)
        pulumi.set(__self__, "interface", interface)

    @_builtins.property
    @pulumi.getter(name="inputPort")
    def input_port(self) -> pulumi.Input[_builtins.int]:
        """
        The port that the flow listens on for an incoming media stream.
        """
        return pulumi.get(self, "input_port")

    @input_port.setter
    def input_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "input_port", value)

    @_builtins.property
    @pulumi.getter
    def interface(self) -> pulumi.Input['FlowInterfaceArgs']:
        """
        The VPC interface where the media stream comes in from.
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: pulumi.Input['FlowInterfaceArgs']):
        pulumi.set(self, "interface", value)


if not MYPY:
    class FlowInterfaceArgsDict(TypedDict):
        """
        The VPC interface that you want to use for the media stream associated with the output.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the VPC interface that you want to use for the media stream associated with the output.
        """
elif False:
    FlowInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowInterfaceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        The VPC interface that you want to use for the media stream associated with the output.
        :param pulumi.Input[_builtins.str] name: The name of the VPC interface that you want to use for the media stream associated with the output.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the VPC interface that you want to use for the media stream associated with the output.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class FlowMaintenanceArgsDict(TypedDict):
        """
        The maintenance setting of a flow.
        """
        maintenance_day: pulumi.Input['FlowMaintenanceMaintenanceDay']
        """
        A day of a week when the maintenance will happen. Use Monday/Tuesday/Wednesday/Thursday/Friday/Saturday/Sunday.
        """
        maintenance_start_hour: pulumi.Input[_builtins.str]
        """
        UTC time when the maintenance will happen. Use 24-hour HH:MM format. Minutes must be 00. Example: 13:00. The default value is 02:00.
        """
elif False:
    FlowMaintenanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowMaintenanceArgs:
    def __init__(__self__, *,
                 maintenance_day: pulumi.Input['FlowMaintenanceMaintenanceDay'],
                 maintenance_start_hour: pulumi.Input[_builtins.str]):
        """
        The maintenance setting of a flow.
        :param pulumi.Input['FlowMaintenanceMaintenanceDay'] maintenance_day: A day of a week when the maintenance will happen. Use Monday/Tuesday/Wednesday/Thursday/Friday/Saturday/Sunday.
        :param pulumi.Input[_builtins.str] maintenance_start_hour: UTC time when the maintenance will happen. Use 24-hour HH:MM format. Minutes must be 00. Example: 13:00. The default value is 02:00.
        """
        pulumi.set(__self__, "maintenance_day", maintenance_day)
        pulumi.set(__self__, "maintenance_start_hour", maintenance_start_hour)

    @_builtins.property
    @pulumi.getter(name="maintenanceDay")
    def maintenance_day(self) -> pulumi.Input['FlowMaintenanceMaintenanceDay']:
        """
        A day of a week when the maintenance will happen. Use Monday/Tuesday/Wednesday/Thursday/Friday/Saturday/Sunday.
        """
        return pulumi.get(self, "maintenance_day")

    @maintenance_day.setter
    def maintenance_day(self, value: pulumi.Input['FlowMaintenanceMaintenanceDay']):
        pulumi.set(self, "maintenance_day", value)

    @_builtins.property
    @pulumi.getter(name="maintenanceStartHour")
    def maintenance_start_hour(self) -> pulumi.Input[_builtins.str]:
        """
        UTC time when the maintenance will happen. Use 24-hour HH:MM format. Minutes must be 00. Example: 13:00. The default value is 02:00.
        """
        return pulumi.get(self, "maintenance_start_hour")

    @maintenance_start_hour.setter
    def maintenance_start_hour(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "maintenance_start_hour", value)


if not MYPY:
    class FlowMediaStreamAttributesArgsDict(TypedDict):
        """
        Attributes that are related to the media stream.
        """
        fmtp: NotRequired[pulumi.Input['FlowFmtpArgsDict']]
        """
        A set of parameters that define the media stream.
        """
        lang: NotRequired[pulumi.Input[_builtins.str]]
        """
        The audio language, in a format that is recognized by the receiver.
        """
elif False:
    FlowMediaStreamAttributesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowMediaStreamAttributesArgs:
    def __init__(__self__, *,
                 fmtp: Optional[pulumi.Input['FlowFmtpArgs']] = None,
                 lang: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Attributes that are related to the media stream.
        :param pulumi.Input['FlowFmtpArgs'] fmtp: A set of parameters that define the media stream.
        :param pulumi.Input[_builtins.str] lang: The audio language, in a format that is recognized by the receiver.
        """
        if fmtp is not None:
            pulumi.set(__self__, "fmtp", fmtp)
        if lang is not None:
            pulumi.set(__self__, "lang", lang)

    @_builtins.property
    @pulumi.getter
    def fmtp(self) -> Optional[pulumi.Input['FlowFmtpArgs']]:
        """
        A set of parameters that define the media stream.
        """
        return pulumi.get(self, "fmtp")

    @fmtp.setter
    def fmtp(self, value: Optional[pulumi.Input['FlowFmtpArgs']]):
        pulumi.set(self, "fmtp", value)

    @_builtins.property
    @pulumi.getter
    def lang(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The audio language, in a format that is recognized by the receiver.
        """
        return pulumi.get(self, "lang")

    @lang.setter
    def lang(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "lang", value)


if not MYPY:
    class FlowMediaStreamSourceConfigurationArgsDict(TypedDict):
        """
        The media stream that is associated with the source, and the parameters for that association.
        """
        encoding_name: pulumi.Input['FlowMediaStreamSourceConfigurationEncodingName']
        """
        The format that was used to encode the data. For ancillary data streams, set the encoding name to smpte291. For audio streams, set the encoding name to pcm. For video, 2110 streams, set the encoding name to raw. For video, JPEG XS streams, set the encoding name to jxsv.
        """
        media_stream_name: pulumi.Input[_builtins.str]
        """
        A name that helps you distinguish one media stream from another.
        """
        input_configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['FlowInputConfigurationArgsDict']]]]
        """
        The media streams that you want to associate with the source.
        """
elif False:
    FlowMediaStreamSourceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowMediaStreamSourceConfigurationArgs:
    def __init__(__self__, *,
                 encoding_name: pulumi.Input['FlowMediaStreamSourceConfigurationEncodingName'],
                 media_stream_name: pulumi.Input[_builtins.str],
                 input_configurations: Optional[pulumi.Input[Sequence[pulumi.Input['FlowInputConfigurationArgs']]]] = None):
        """
        The media stream that is associated with the source, and the parameters for that association.
        :param pulumi.Input['FlowMediaStreamSourceConfigurationEncodingName'] encoding_name: The format that was used to encode the data. For ancillary data streams, set the encoding name to smpte291. For audio streams, set the encoding name to pcm. For video, 2110 streams, set the encoding name to raw. For video, JPEG XS streams, set the encoding name to jxsv.
        :param pulumi.Input[_builtins.str] media_stream_name: A name that helps you distinguish one media stream from another.
        :param pulumi.Input[Sequence[pulumi.Input['FlowInputConfigurationArgs']]] input_configurations: The media streams that you want to associate with the source.
        """
        pulumi.set(__self__, "encoding_name", encoding_name)
        pulumi.set(__self__, "media_stream_name", media_stream_name)
        if input_configurations is not None:
            pulumi.set(__self__, "input_configurations", input_configurations)

    @_builtins.property
    @pulumi.getter(name="encodingName")
    def encoding_name(self) -> pulumi.Input['FlowMediaStreamSourceConfigurationEncodingName']:
        """
        The format that was used to encode the data. For ancillary data streams, set the encoding name to smpte291. For audio streams, set the encoding name to pcm. For video, 2110 streams, set the encoding name to raw. For video, JPEG XS streams, set the encoding name to jxsv.
        """
        return pulumi.get(self, "encoding_name")

    @encoding_name.setter
    def encoding_name(self, value: pulumi.Input['FlowMediaStreamSourceConfigurationEncodingName']):
        pulumi.set(self, "encoding_name", value)

    @_builtins.property
    @pulumi.getter(name="mediaStreamName")
    def media_stream_name(self) -> pulumi.Input[_builtins.str]:
        """
        A name that helps you distinguish one media stream from another.
        """
        return pulumi.get(self, "media_stream_name")

    @media_stream_name.setter
    def media_stream_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "media_stream_name", value)

    @_builtins.property
    @pulumi.getter(name="inputConfigurations")
    def input_configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FlowInputConfigurationArgs']]]]:
        """
        The media streams that you want to associate with the source.
        """
        return pulumi.get(self, "input_configurations")

    @input_configurations.setter
    def input_configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FlowInputConfigurationArgs']]]]):
        pulumi.set(self, "input_configurations", value)


if not MYPY:
    class FlowMediaStreamArgsDict(TypedDict):
        """
        A single track or stream of media that contains video, audio, or ancillary data. After you add a media stream to a flow, you can associate it with sources and outputs on that flow, as long as they use the CDI protocol or the ST 2110 JPEG XS protocol. Each source or output can consist of one or many media streams.
        """
        media_stream_id: pulumi.Input[_builtins.int]
        """
        A unique identifier for the media stream.
        """
        media_stream_name: pulumi.Input[_builtins.str]
        """
        A name that helps you distinguish one media stream from another.
        """
        media_stream_type: pulumi.Input['FlowMediaStreamMediaStreamType']
        """
        The type of media stream.
        """
        attributes: NotRequired[pulumi.Input['FlowMediaStreamAttributesArgsDict']]
        """
        Attributes that are related to the media stream.
        """
        clock_rate: NotRequired[pulumi.Input[_builtins.int]]
        """
        The sample rate for the stream. This value in measured in kHz.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description that can help you quickly identify what your media stream is used for.
        """
        fmt: NotRequired[pulumi.Input[_builtins.int]]
        """
        The format type number (sometimes referred to as RTP payload type) of the media stream. MediaConnect assigns this value to the media stream. For ST 2110 JPEG XS outputs, you need to provide this value to the receiver.
        """
        video_format: NotRequired[pulumi.Input['FlowMediaStreamVideoFormat']]
        """
        The resolution of the video.
        """
elif False:
    FlowMediaStreamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowMediaStreamArgs:
    def __init__(__self__, *,
                 media_stream_id: pulumi.Input[_builtins.int],
                 media_stream_name: pulumi.Input[_builtins.str],
                 media_stream_type: pulumi.Input['FlowMediaStreamMediaStreamType'],
                 attributes: Optional[pulumi.Input['FlowMediaStreamAttributesArgs']] = None,
                 clock_rate: Optional[pulumi.Input[_builtins.int]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 fmt: Optional[pulumi.Input[_builtins.int]] = None,
                 video_format: Optional[pulumi.Input['FlowMediaStreamVideoFormat']] = None):
        """
        A single track or stream of media that contains video, audio, or ancillary data. After you add a media stream to a flow, you can associate it with sources and outputs on that flow, as long as they use the CDI protocol or the ST 2110 JPEG XS protocol. Each source or output can consist of one or many media streams.
        :param pulumi.Input[_builtins.int] media_stream_id: A unique identifier for the media stream.
        :param pulumi.Input[_builtins.str] media_stream_name: A name that helps you distinguish one media stream from another.
        :param pulumi.Input['FlowMediaStreamMediaStreamType'] media_stream_type: The type of media stream.
        :param pulumi.Input['FlowMediaStreamAttributesArgs'] attributes: Attributes that are related to the media stream.
        :param pulumi.Input[_builtins.int] clock_rate: The sample rate for the stream. This value in measured in kHz.
        :param pulumi.Input[_builtins.str] description: A description that can help you quickly identify what your media stream is used for.
        :param pulumi.Input[_builtins.int] fmt: The format type number (sometimes referred to as RTP payload type) of the media stream. MediaConnect assigns this value to the media stream. For ST 2110 JPEG XS outputs, you need to provide this value to the receiver.
        :param pulumi.Input['FlowMediaStreamVideoFormat'] video_format: The resolution of the video.
        """
        pulumi.set(__self__, "media_stream_id", media_stream_id)
        pulumi.set(__self__, "media_stream_name", media_stream_name)
        pulumi.set(__self__, "media_stream_type", media_stream_type)
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if clock_rate is not None:
            pulumi.set(__self__, "clock_rate", clock_rate)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if fmt is not None:
            pulumi.set(__self__, "fmt", fmt)
        if video_format is not None:
            pulumi.set(__self__, "video_format", video_format)

    @_builtins.property
    @pulumi.getter(name="mediaStreamId")
    def media_stream_id(self) -> pulumi.Input[_builtins.int]:
        """
        A unique identifier for the media stream.
        """
        return pulumi.get(self, "media_stream_id")

    @media_stream_id.setter
    def media_stream_id(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "media_stream_id", value)

    @_builtins.property
    @pulumi.getter(name="mediaStreamName")
    def media_stream_name(self) -> pulumi.Input[_builtins.str]:
        """
        A name that helps you distinguish one media stream from another.
        """
        return pulumi.get(self, "media_stream_name")

    @media_stream_name.setter
    def media_stream_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "media_stream_name", value)

    @_builtins.property
    @pulumi.getter(name="mediaStreamType")
    def media_stream_type(self) -> pulumi.Input['FlowMediaStreamMediaStreamType']:
        """
        The type of media stream.
        """
        return pulumi.get(self, "media_stream_type")

    @media_stream_type.setter
    def media_stream_type(self, value: pulumi.Input['FlowMediaStreamMediaStreamType']):
        pulumi.set(self, "media_stream_type", value)

    @_builtins.property
    @pulumi.getter
    def attributes(self) -> Optional[pulumi.Input['FlowMediaStreamAttributesArgs']]:
        """
        Attributes that are related to the media stream.
        """
        return pulumi.get(self, "attributes")

    @attributes.setter
    def attributes(self, value: Optional[pulumi.Input['FlowMediaStreamAttributesArgs']]):
        pulumi.set(self, "attributes", value)

    @_builtins.property
    @pulumi.getter(name="clockRate")
    def clock_rate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The sample rate for the stream. This value in measured in kHz.
        """
        return pulumi.get(self, "clock_rate")

    @clock_rate.setter
    def clock_rate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "clock_rate", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description that can help you quickly identify what your media stream is used for.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def fmt(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The format type number (sometimes referred to as RTP payload type) of the media stream. MediaConnect assigns this value to the media stream. For ST 2110 JPEG XS outputs, you need to provide this value to the receiver.
        """
        return pulumi.get(self, "fmt")

    @fmt.setter
    def fmt(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "fmt", value)

    @_builtins.property
    @pulumi.getter(name="videoFormat")
    def video_format(self) -> Optional[pulumi.Input['FlowMediaStreamVideoFormat']]:
        """
        The resolution of the video.
        """
        return pulumi.get(self, "video_format")

    @video_format.setter
    def video_format(self, value: Optional[pulumi.Input['FlowMediaStreamVideoFormat']]):
        pulumi.set(self, "video_format", value)


if not MYPY:
    class FlowNdiConfigArgsDict(TypedDict):
        """
        Specifies the configuration settings for NDI outputs. Required when the flow includes NDI outputs.
        """
        machine_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A prefix for the names of the NDI sources that the flow creates. If a custom name isn't specified, MediaConnect generates a unique 12-character ID as the prefix.
        """
        ndi_discovery_servers: NotRequired[pulumi.Input[Sequence[pulumi.Input['FlowNdiDiscoveryServerConfigArgsDict']]]]
        """
        A list of up to three NDI discovery server configurations. While not required by the API, this configuration is necessary for NDI functionality to work properly.
        """
        ndi_state: NotRequired[pulumi.Input['FlowNdiConfigNdiState']]
        """
        A setting that controls whether NDI outputs can be used in the flow. Must be ENABLED to add NDI outputs. Default is DISABLED.
        """
elif False:
    FlowNdiConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowNdiConfigArgs:
    def __init__(__self__, *,
                 machine_name: Optional[pulumi.Input[_builtins.str]] = None,
                 ndi_discovery_servers: Optional[pulumi.Input[Sequence[pulumi.Input['FlowNdiDiscoveryServerConfigArgs']]]] = None,
                 ndi_state: Optional[pulumi.Input['FlowNdiConfigNdiState']] = None):
        """
        Specifies the configuration settings for NDI outputs. Required when the flow includes NDI outputs.
        :param pulumi.Input[_builtins.str] machine_name: A prefix for the names of the NDI sources that the flow creates. If a custom name isn't specified, MediaConnect generates a unique 12-character ID as the prefix.
        :param pulumi.Input[Sequence[pulumi.Input['FlowNdiDiscoveryServerConfigArgs']]] ndi_discovery_servers: A list of up to three NDI discovery server configurations. While not required by the API, this configuration is necessary for NDI functionality to work properly.
        :param pulumi.Input['FlowNdiConfigNdiState'] ndi_state: A setting that controls whether NDI outputs can be used in the flow. Must be ENABLED to add NDI outputs. Default is DISABLED.
        """
        if machine_name is not None:
            pulumi.set(__self__, "machine_name", machine_name)
        if ndi_discovery_servers is not None:
            pulumi.set(__self__, "ndi_discovery_servers", ndi_discovery_servers)
        if ndi_state is not None:
            pulumi.set(__self__, "ndi_state", ndi_state)

    @_builtins.property
    @pulumi.getter(name="machineName")
    def machine_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A prefix for the names of the NDI sources that the flow creates. If a custom name isn't specified, MediaConnect generates a unique 12-character ID as the prefix.
        """
        return pulumi.get(self, "machine_name")

    @machine_name.setter
    def machine_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "machine_name", value)

    @_builtins.property
    @pulumi.getter(name="ndiDiscoveryServers")
    def ndi_discovery_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FlowNdiDiscoveryServerConfigArgs']]]]:
        """
        A list of up to three NDI discovery server configurations. While not required by the API, this configuration is necessary for NDI functionality to work properly.
        """
        return pulumi.get(self, "ndi_discovery_servers")

    @ndi_discovery_servers.setter
    def ndi_discovery_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FlowNdiDiscoveryServerConfigArgs']]]]):
        pulumi.set(self, "ndi_discovery_servers", value)

    @_builtins.property
    @pulumi.getter(name="ndiState")
    def ndi_state(self) -> Optional[pulumi.Input['FlowNdiConfigNdiState']]:
        """
        A setting that controls whether NDI outputs can be used in the flow. Must be ENABLED to add NDI outputs. Default is DISABLED.
        """
        return pulumi.get(self, "ndi_state")

    @ndi_state.setter
    def ndi_state(self, value: Optional[pulumi.Input['FlowNdiConfigNdiState']]):
        pulumi.set(self, "ndi_state", value)


if not MYPY:
    class FlowNdiDiscoveryServerConfigArgsDict(TypedDict):
        """
        Specifies the configuration settings for individual NDI discovery servers. A maximum of 3 servers is allowed.
        """
        discovery_server_address: pulumi.Input[_builtins.str]
        """
        The unique network address of the NDI discovery server.
        """
        vpc_interface_adapter: pulumi.Input[_builtins.str]
        """
        The identifier for the Virtual Private Cloud (VPC) network interface used by the flow.
        """
        discovery_server_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port for the NDI discovery server. Defaults to 5959 if a custom port isn't specified.
        """
elif False:
    FlowNdiDiscoveryServerConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowNdiDiscoveryServerConfigArgs:
    def __init__(__self__, *,
                 discovery_server_address: pulumi.Input[_builtins.str],
                 vpc_interface_adapter: pulumi.Input[_builtins.str],
                 discovery_server_port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        Specifies the configuration settings for individual NDI discovery servers. A maximum of 3 servers is allowed.
        :param pulumi.Input[_builtins.str] discovery_server_address: The unique network address of the NDI discovery server.
        :param pulumi.Input[_builtins.str] vpc_interface_adapter: The identifier for the Virtual Private Cloud (VPC) network interface used by the flow.
        :param pulumi.Input[_builtins.int] discovery_server_port: The port for the NDI discovery server. Defaults to 5959 if a custom port isn't specified.
        """
        pulumi.set(__self__, "discovery_server_address", discovery_server_address)
        pulumi.set(__self__, "vpc_interface_adapter", vpc_interface_adapter)
        if discovery_server_port is not None:
            pulumi.set(__self__, "discovery_server_port", discovery_server_port)

    @_builtins.property
    @pulumi.getter(name="discoveryServerAddress")
    def discovery_server_address(self) -> pulumi.Input[_builtins.str]:
        """
        The unique network address of the NDI discovery server.
        """
        return pulumi.get(self, "discovery_server_address")

    @discovery_server_address.setter
    def discovery_server_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "discovery_server_address", value)

    @_builtins.property
    @pulumi.getter(name="vpcInterfaceAdapter")
    def vpc_interface_adapter(self) -> pulumi.Input[_builtins.str]:
        """
        The identifier for the Virtual Private Cloud (VPC) network interface used by the flow.
        """
        return pulumi.get(self, "vpc_interface_adapter")

    @vpc_interface_adapter.setter
    def vpc_interface_adapter(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vpc_interface_adapter", value)

    @_builtins.property
    @pulumi.getter(name="discoveryServerPort")
    def discovery_server_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port for the NDI discovery server. Defaults to 5959 if a custom port isn't specified.
        """
        return pulumi.get(self, "discovery_server_port")

    @discovery_server_port.setter
    def discovery_server_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "discovery_server_port", value)


if not MYPY:
    class FlowOutputAutomaticEncryptionKeyConfigurationArgsDict(TypedDict):
        """
        Configuration settings for automatic encryption key management, where MediaConnect handles key creation and rotation.
        """
        pass
elif False:
    FlowOutputAutomaticEncryptionKeyConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowOutputAutomaticEncryptionKeyConfigurationArgs:
    def __init__(__self__):
        """
        Configuration settings for automatic encryption key management, where MediaConnect handles key creation and rotation.
        """
        pass


if not MYPY:
    class FlowOutputDestinationConfigurationArgsDict(TypedDict):
        """
        The definition of a media stream that is associated with the output.
        """
        destination_ip: pulumi.Input[_builtins.str]
        """
        The IP address where contents of the media stream will be sent.
        """
        destination_port: pulumi.Input[_builtins.int]
        """
        The port to use when the content of the media stream is distributed to the output.
        """
        interface: pulumi.Input['FlowOutputInterfaceArgsDict']
        """
        The VPC interface that is used for the media stream associated with the output.
        """
elif False:
    FlowOutputDestinationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowOutputDestinationConfigurationArgs:
    def __init__(__self__, *,
                 destination_ip: pulumi.Input[_builtins.str],
                 destination_port: pulumi.Input[_builtins.int],
                 interface: pulumi.Input['FlowOutputInterfaceArgs']):
        """
        The definition of a media stream that is associated with the output.
        :param pulumi.Input[_builtins.str] destination_ip: The IP address where contents of the media stream will be sent.
        :param pulumi.Input[_builtins.int] destination_port: The port to use when the content of the media stream is distributed to the output.
        :param pulumi.Input['FlowOutputInterfaceArgs'] interface: The VPC interface that is used for the media stream associated with the output.
        """
        pulumi.set(__self__, "destination_ip", destination_ip)
        pulumi.set(__self__, "destination_port", destination_port)
        pulumi.set(__self__, "interface", interface)

    @_builtins.property
    @pulumi.getter(name="destinationIp")
    def destination_ip(self) -> pulumi.Input[_builtins.str]:
        """
        The IP address where contents of the media stream will be sent.
        """
        return pulumi.get(self, "destination_ip")

    @destination_ip.setter
    def destination_ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "destination_ip", value)

    @_builtins.property
    @pulumi.getter(name="destinationPort")
    def destination_port(self) -> pulumi.Input[_builtins.int]:
        """
        The port to use when the content of the media stream is distributed to the output.
        """
        return pulumi.get(self, "destination_port")

    @destination_port.setter
    def destination_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "destination_port", value)

    @_builtins.property
    @pulumi.getter
    def interface(self) -> pulumi.Input['FlowOutputInterfaceArgs']:
        """
        The VPC interface that is used for the media stream associated with the output.
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: pulumi.Input['FlowOutputInterfaceArgs']):
        pulumi.set(self, "interface", value)


if not MYPY:
    class FlowOutputEncodingParametersArgsDict(TypedDict):
        """
        A collection of parameters that determine how MediaConnect will convert the content. These fields only apply to outputs on flows that have a CDI source.
        """
        compression_factor: pulumi.Input[_builtins.float]
        """
        A value that is used to calculate compression for an output. The bitrate of the output is calculated as follows: Output bitrate = (1 / compressionFactor) * (source bitrate) This property only applies to outputs that use the ST 2110 JPEG XS protocol, with a flow source that uses the CDI protocol. Valid values are in the range of 3.0 to 10.0, inclusive.
        """
        encoder_profile: NotRequired[pulumi.Input['FlowOutputEncodingParametersEncoderProfile']]
        """
        A setting on the encoder that drives compression settings. This property only applies to video media streams associated with outputs that use the ST 2110 JPEG XS protocol, with a flow source that uses the CDI protocol.
        """
elif False:
    FlowOutputEncodingParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowOutputEncodingParametersArgs:
    def __init__(__self__, *,
                 compression_factor: pulumi.Input[_builtins.float],
                 encoder_profile: Optional[pulumi.Input['FlowOutputEncodingParametersEncoderProfile']] = None):
        """
        A collection of parameters that determine how MediaConnect will convert the content. These fields only apply to outputs on flows that have a CDI source.
        :param pulumi.Input[_builtins.float] compression_factor: A value that is used to calculate compression for an output. The bitrate of the output is calculated as follows: Output bitrate = (1 / compressionFactor) * (source bitrate) This property only applies to outputs that use the ST 2110 JPEG XS protocol, with a flow source that uses the CDI protocol. Valid values are in the range of 3.0 to 10.0, inclusive.
        :param pulumi.Input['FlowOutputEncodingParametersEncoderProfile'] encoder_profile: A setting on the encoder that drives compression settings. This property only applies to video media streams associated with outputs that use the ST 2110 JPEG XS protocol, with a flow source that uses the CDI protocol.
        """
        pulumi.set(__self__, "compression_factor", compression_factor)
        if encoder_profile is not None:
            pulumi.set(__self__, "encoder_profile", encoder_profile)

    @_builtins.property
    @pulumi.getter(name="compressionFactor")
    def compression_factor(self) -> pulumi.Input[_builtins.float]:
        """
        A value that is used to calculate compression for an output. The bitrate of the output is calculated as follows: Output bitrate = (1 / compressionFactor) * (source bitrate) This property only applies to outputs that use the ST 2110 JPEG XS protocol, with a flow source that uses the CDI protocol. Valid values are in the range of 3.0 to 10.0, inclusive.
        """
        return pulumi.get(self, "compression_factor")

    @compression_factor.setter
    def compression_factor(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "compression_factor", value)

    @_builtins.property
    @pulumi.getter(name="encoderProfile")
    def encoder_profile(self) -> Optional[pulumi.Input['FlowOutputEncodingParametersEncoderProfile']]:
        """
        A setting on the encoder that drives compression settings. This property only applies to video media streams associated with outputs that use the ST 2110 JPEG XS protocol, with a flow source that uses the CDI protocol.
        """
        return pulumi.get(self, "encoder_profile")

    @encoder_profile.setter
    def encoder_profile(self, value: Optional[pulumi.Input['FlowOutputEncodingParametersEncoderProfile']]):
        pulumi.set(self, "encoder_profile", value)


if not MYPY:
    class FlowOutputEncryptionArgsDict(TypedDict):
        """
        Information about the encryption of the flow.
        """
        role_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the role that you created during setup (when you set up AWS Elemental MediaConnect as a trusted entity).
        """
        secret_arn: pulumi.Input[_builtins.str]
        """
         The ARN of the secret that you created in AWS Secrets Manager to store the encryption key. This parameter is required for static key encryption and is not valid for SPEKE encryption.
        """
        algorithm: NotRequired[pulumi.Input['FlowOutputEncryptionAlgorithm']]
        """
        The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
        """
        key_type: NotRequired[pulumi.Input['FlowOutputEncryptionKeyType']]
        """
        The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
        """
elif False:
    FlowOutputEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowOutputEncryptionArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[_builtins.str],
                 secret_arn: pulumi.Input[_builtins.str],
                 algorithm: Optional[pulumi.Input['FlowOutputEncryptionAlgorithm']] = None,
                 key_type: Optional[pulumi.Input['FlowOutputEncryptionKeyType']] = None):
        """
        Information about the encryption of the flow.
        :param pulumi.Input[_builtins.str] role_arn: The ARN of the role that you created during setup (when you set up AWS Elemental MediaConnect as a trusted entity).
        :param pulumi.Input[_builtins.str] secret_arn:  The ARN of the secret that you created in AWS Secrets Manager to store the encryption key. This parameter is required for static key encryption and is not valid for SPEKE encryption.
        :param pulumi.Input['FlowOutputEncryptionAlgorithm'] algorithm: The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
        :param pulumi.Input['FlowOutputEncryptionKeyType'] key_type: The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
        """
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "secret_arn", secret_arn)
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if key_type is not None:
            pulumi.set(__self__, "key_type", key_type)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the role that you created during setup (when you set up AWS Elemental MediaConnect as a trusted entity).
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="secretArn")
    def secret_arn(self) -> pulumi.Input[_builtins.str]:
        """
         The ARN of the secret that you created in AWS Secrets Manager to store the encryption key. This parameter is required for static key encryption and is not valid for SPEKE encryption.
        """
        return pulumi.get(self, "secret_arn")

    @secret_arn.setter
    def secret_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_arn", value)

    @_builtins.property
    @pulumi.getter
    def algorithm(self) -> Optional[pulumi.Input['FlowOutputEncryptionAlgorithm']]:
        """
        The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: Optional[pulumi.Input['FlowOutputEncryptionAlgorithm']]):
        pulumi.set(self, "algorithm", value)

    @_builtins.property
    @pulumi.getter(name="keyType")
    def key_type(self) -> Optional[pulumi.Input['FlowOutputEncryptionKeyType']]:
        """
        The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
        """
        return pulumi.get(self, "key_type")

    @key_type.setter
    def key_type(self, value: Optional[pulumi.Input['FlowOutputEncryptionKeyType']]):
        pulumi.set(self, "key_type", value)


if not MYPY:
    class FlowOutputFlowTransitEncryptionKeyConfiguration0PropertiesArgsDict(TypedDict):
        """
        Configuration settings for flow transit encryption keys.
        """
        secrets_manager: pulumi.Input['FlowOutputSecretsManagerEncryptionKeyConfigurationArgsDict']
elif False:
    FlowOutputFlowTransitEncryptionKeyConfiguration0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowOutputFlowTransitEncryptionKeyConfiguration0PropertiesArgs:
    def __init__(__self__, *,
                 secrets_manager: pulumi.Input['FlowOutputSecretsManagerEncryptionKeyConfigurationArgs']):
        """
        Configuration settings for flow transit encryption keys.
        """
        pulumi.set(__self__, "secrets_manager", secrets_manager)

    @_builtins.property
    @pulumi.getter(name="secretsManager")
    def secrets_manager(self) -> pulumi.Input['FlowOutputSecretsManagerEncryptionKeyConfigurationArgs']:
        return pulumi.get(self, "secrets_manager")

    @secrets_manager.setter
    def secrets_manager(self, value: pulumi.Input['FlowOutputSecretsManagerEncryptionKeyConfigurationArgs']):
        pulumi.set(self, "secrets_manager", value)


if not MYPY:
    class FlowOutputFlowTransitEncryptionKeyConfiguration1PropertiesArgsDict(TypedDict):
        """
        Configuration settings for flow transit encryption keys.
        """
        automatic: pulumi.Input['FlowOutputAutomaticEncryptionKeyConfigurationArgsDict']
elif False:
    FlowOutputFlowTransitEncryptionKeyConfiguration1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowOutputFlowTransitEncryptionKeyConfiguration1PropertiesArgs:
    def __init__(__self__, *,
                 automatic: pulumi.Input['FlowOutputAutomaticEncryptionKeyConfigurationArgs']):
        """
        Configuration settings for flow transit encryption keys.
        """
        pulumi.set(__self__, "automatic", automatic)

    @_builtins.property
    @pulumi.getter
    def automatic(self) -> pulumi.Input['FlowOutputAutomaticEncryptionKeyConfigurationArgs']:
        return pulumi.get(self, "automatic")

    @automatic.setter
    def automatic(self, value: pulumi.Input['FlowOutputAutomaticEncryptionKeyConfigurationArgs']):
        pulumi.set(self, "automatic", value)


if not MYPY:
    class FlowOutputFlowTransitEncryptionArgsDict(TypedDict):
        """
        The configuration that defines how content is encrypted during transit between the MediaConnect router and a MediaConnect flow.
        """
        encryption_key_configuration: pulumi.Input[Union['FlowOutputFlowTransitEncryptionKeyConfiguration0PropertiesArgsDict', 'FlowOutputFlowTransitEncryptionKeyConfiguration1PropertiesArgsDict']]
        encryption_key_type: NotRequired[pulumi.Input['FlowOutputFlowTransitEncryptionKeyType']]
elif False:
    FlowOutputFlowTransitEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowOutputFlowTransitEncryptionArgs:
    def __init__(__self__, *,
                 encryption_key_configuration: pulumi.Input[Union['FlowOutputFlowTransitEncryptionKeyConfiguration0PropertiesArgs', 'FlowOutputFlowTransitEncryptionKeyConfiguration1PropertiesArgs']],
                 encryption_key_type: Optional[pulumi.Input['FlowOutputFlowTransitEncryptionKeyType']] = None):
        """
        The configuration that defines how content is encrypted during transit between the MediaConnect router and a MediaConnect flow.
        """
        pulumi.set(__self__, "encryption_key_configuration", encryption_key_configuration)
        if encryption_key_type is not None:
            pulumi.set(__self__, "encryption_key_type", encryption_key_type)

    @_builtins.property
    @pulumi.getter(name="encryptionKeyConfiguration")
    def encryption_key_configuration(self) -> pulumi.Input[Union['FlowOutputFlowTransitEncryptionKeyConfiguration0PropertiesArgs', 'FlowOutputFlowTransitEncryptionKeyConfiguration1PropertiesArgs']]:
        return pulumi.get(self, "encryption_key_configuration")

    @encryption_key_configuration.setter
    def encryption_key_configuration(self, value: pulumi.Input[Union['FlowOutputFlowTransitEncryptionKeyConfiguration0PropertiesArgs', 'FlowOutputFlowTransitEncryptionKeyConfiguration1PropertiesArgs']]):
        pulumi.set(self, "encryption_key_configuration", value)

    @_builtins.property
    @pulumi.getter(name="encryptionKeyType")
    def encryption_key_type(self) -> Optional[pulumi.Input['FlowOutputFlowTransitEncryptionKeyType']]:
        return pulumi.get(self, "encryption_key_type")

    @encryption_key_type.setter
    def encryption_key_type(self, value: Optional[pulumi.Input['FlowOutputFlowTransitEncryptionKeyType']]):
        pulumi.set(self, "encryption_key_type", value)


if not MYPY:
    class FlowOutputInterfaceArgsDict(TypedDict):
        """
        The VPC interface that you want to use for the media stream associated with the output.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the VPC interface that you want to use for the media stream associated with the output.
        """
elif False:
    FlowOutputInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowOutputInterfaceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        The VPC interface that you want to use for the media stream associated with the output.
        :param pulumi.Input[_builtins.str] name: The name of the VPC interface that you want to use for the media stream associated with the output.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the VPC interface that you want to use for the media stream associated with the output.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class FlowOutputMediaStreamOutputConfigurationArgsDict(TypedDict):
        """
        The media stream that is associated with the output, and the parameters for that association.
        """
        encoding_name: pulumi.Input['FlowOutputMediaStreamOutputConfigurationEncodingName']
        """
        The format that will be used to encode the data. For ancillary data streams, set the encoding name to smpte291. For audio streams, set the encoding name to pcm. For video streams on sources or outputs that use the CDI protocol, set the encoding name to raw. For video streams on sources or outputs that use the ST 2110 JPEG XS protocol, set the encoding name to jxsv.
        """
        media_stream_name: pulumi.Input[_builtins.str]
        """
        A name that helps you distinguish one media stream from another.
        """
        destination_configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['FlowOutputDestinationConfigurationArgsDict']]]]
        """
        The media streams that you want to associate with the output.
        """
        encoding_parameters: NotRequired[pulumi.Input['FlowOutputEncodingParametersArgsDict']]
        """
        A collection of parameters that determine how MediaConnect will convert the content. These fields only apply to outputs on flows that have a CDI source.
        """
elif False:
    FlowOutputMediaStreamOutputConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowOutputMediaStreamOutputConfigurationArgs:
    def __init__(__self__, *,
                 encoding_name: pulumi.Input['FlowOutputMediaStreamOutputConfigurationEncodingName'],
                 media_stream_name: pulumi.Input[_builtins.str],
                 destination_configurations: Optional[pulumi.Input[Sequence[pulumi.Input['FlowOutputDestinationConfigurationArgs']]]] = None,
                 encoding_parameters: Optional[pulumi.Input['FlowOutputEncodingParametersArgs']] = None):
        """
        The media stream that is associated with the output, and the parameters for that association.
        :param pulumi.Input['FlowOutputMediaStreamOutputConfigurationEncodingName'] encoding_name: The format that will be used to encode the data. For ancillary data streams, set the encoding name to smpte291. For audio streams, set the encoding name to pcm. For video streams on sources or outputs that use the CDI protocol, set the encoding name to raw. For video streams on sources or outputs that use the ST 2110 JPEG XS protocol, set the encoding name to jxsv.
        :param pulumi.Input[_builtins.str] media_stream_name: A name that helps you distinguish one media stream from another.
        :param pulumi.Input[Sequence[pulumi.Input['FlowOutputDestinationConfigurationArgs']]] destination_configurations: The media streams that you want to associate with the output.
        :param pulumi.Input['FlowOutputEncodingParametersArgs'] encoding_parameters: A collection of parameters that determine how MediaConnect will convert the content. These fields only apply to outputs on flows that have a CDI source.
        """
        pulumi.set(__self__, "encoding_name", encoding_name)
        pulumi.set(__self__, "media_stream_name", media_stream_name)
        if destination_configurations is not None:
            pulumi.set(__self__, "destination_configurations", destination_configurations)
        if encoding_parameters is not None:
            pulumi.set(__self__, "encoding_parameters", encoding_parameters)

    @_builtins.property
    @pulumi.getter(name="encodingName")
    def encoding_name(self) -> pulumi.Input['FlowOutputMediaStreamOutputConfigurationEncodingName']:
        """
        The format that will be used to encode the data. For ancillary data streams, set the encoding name to smpte291. For audio streams, set the encoding name to pcm. For video streams on sources or outputs that use the CDI protocol, set the encoding name to raw. For video streams on sources or outputs that use the ST 2110 JPEG XS protocol, set the encoding name to jxsv.
        """
        return pulumi.get(self, "encoding_name")

    @encoding_name.setter
    def encoding_name(self, value: pulumi.Input['FlowOutputMediaStreamOutputConfigurationEncodingName']):
        pulumi.set(self, "encoding_name", value)

    @_builtins.property
    @pulumi.getter(name="mediaStreamName")
    def media_stream_name(self) -> pulumi.Input[_builtins.str]:
        """
        A name that helps you distinguish one media stream from another.
        """
        return pulumi.get(self, "media_stream_name")

    @media_stream_name.setter
    def media_stream_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "media_stream_name", value)

    @_builtins.property
    @pulumi.getter(name="destinationConfigurations")
    def destination_configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FlowOutputDestinationConfigurationArgs']]]]:
        """
        The media streams that you want to associate with the output.
        """
        return pulumi.get(self, "destination_configurations")

    @destination_configurations.setter
    def destination_configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FlowOutputDestinationConfigurationArgs']]]]):
        pulumi.set(self, "destination_configurations", value)

    @_builtins.property
    @pulumi.getter(name="encodingParameters")
    def encoding_parameters(self) -> Optional[pulumi.Input['FlowOutputEncodingParametersArgs']]:
        """
        A collection of parameters that determine how MediaConnect will convert the content. These fields only apply to outputs on flows that have a CDI source.
        """
        return pulumi.get(self, "encoding_parameters")

    @encoding_parameters.setter
    def encoding_parameters(self, value: Optional[pulumi.Input['FlowOutputEncodingParametersArgs']]):
        pulumi.set(self, "encoding_parameters", value)


if not MYPY:
    class FlowOutputSecretsManagerEncryptionKeyConfigurationArgsDict(TypedDict):
        """
        The configuration settings for transit encryption of a flow output using AWS Secrets Manager, including the secret ARN and role ARN.
        """
        role_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the IAM role used for transit encryption to the router input using AWS Secrets Manager.
        """
        secret_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the AWS Secrets Manager secret used for transit encryption to the router input.
        """
elif False:
    FlowOutputSecretsManagerEncryptionKeyConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowOutputSecretsManagerEncryptionKeyConfigurationArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[_builtins.str],
                 secret_arn: pulumi.Input[_builtins.str]):
        """
        The configuration settings for transit encryption of a flow output using AWS Secrets Manager, including the secret ARN and role ARN.
        :param pulumi.Input[_builtins.str] role_arn: The ARN of the IAM role used for transit encryption to the router input using AWS Secrets Manager.
        :param pulumi.Input[_builtins.str] secret_arn: The ARN of the AWS Secrets Manager secret used for transit encryption to the router input.
        """
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "secret_arn", secret_arn)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the IAM role used for transit encryption to the router input using AWS Secrets Manager.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="secretArn")
    def secret_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the AWS Secrets Manager secret used for transit encryption to the router input.
        """
        return pulumi.get(self, "secret_arn")

    @secret_arn.setter
    def secret_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_arn", value)


if not MYPY:
    class FlowOutputVpcInterfaceAttachmentArgsDict(TypedDict):
        """
        The settings for attaching a VPC interface to an output.
        """
        vpc_interface_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the VPC interface to use for this output.
        """
elif False:
    FlowOutputVpcInterfaceAttachmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowOutputVpcInterfaceAttachmentArgs:
    def __init__(__self__, *,
                 vpc_interface_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The settings for attaching a VPC interface to an output.
        :param pulumi.Input[_builtins.str] vpc_interface_name: The name of the VPC interface to use for this output.
        """
        if vpc_interface_name is not None:
            pulumi.set(__self__, "vpc_interface_name", vpc_interface_name)

    @_builtins.property
    @pulumi.getter(name="vpcInterfaceName")
    def vpc_interface_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the VPC interface to use for this output.
        """
        return pulumi.get(self, "vpc_interface_name")

    @vpc_interface_name.setter
    def vpc_interface_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vpc_interface_name", value)


if not MYPY:
    class FlowSecretsManagerEncryptionKeyConfigurationArgsDict(TypedDict):
        """
        The configuration settings for transit encryption of a flow source using AWS Secrets Manager, including the secret ARN and role ARN.
        """
        role_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the IAM role used for transit encryption from the router output using AWS Secrets Manager.
        """
        secret_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the AWS Secrets Manager secret used for transit encryption from the router output.
        """
elif False:
    FlowSecretsManagerEncryptionKeyConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowSecretsManagerEncryptionKeyConfigurationArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[_builtins.str],
                 secret_arn: pulumi.Input[_builtins.str]):
        """
        The configuration settings for transit encryption of a flow source using AWS Secrets Manager, including the secret ARN and role ARN.
        :param pulumi.Input[_builtins.str] role_arn: The ARN of the IAM role used for transit encryption from the router output using AWS Secrets Manager.
        :param pulumi.Input[_builtins.str] secret_arn: The ARN of the AWS Secrets Manager secret used for transit encryption from the router output.
        """
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "secret_arn", secret_arn)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the IAM role used for transit encryption from the router output using AWS Secrets Manager.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="secretArn")
    def secret_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the AWS Secrets Manager secret used for transit encryption from the router output.
        """
        return pulumi.get(self, "secret_arn")

    @secret_arn.setter
    def secret_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_arn", value)


if not MYPY:
    class FlowSilentAudioArgsDict(TypedDict):
        """
        Configures settings for the SilentAudio metric.
        """
        state: NotRequired[pulumi.Input['FlowSilentAudioState']]
        """
        Indicates whether the SilentAudio metric is enabled or disabled.
        """
        threshold_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of consecutive seconds of silence that triggers an event or alert.
        """
elif False:
    FlowSilentAudioArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowSilentAudioArgs:
    def __init__(__self__, *,
                 state: Optional[pulumi.Input['FlowSilentAudioState']] = None,
                 threshold_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        Configures settings for the SilentAudio metric.
        :param pulumi.Input['FlowSilentAudioState'] state: Indicates whether the SilentAudio metric is enabled or disabled.
        :param pulumi.Input[_builtins.int] threshold_seconds: Specifies the number of consecutive seconds of silence that triggers an event or alert.
        """
        if state is not None:
            pulumi.set(__self__, "state", state)
        if threshold_seconds is not None:
            pulumi.set(__self__, "threshold_seconds", threshold_seconds)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input['FlowSilentAudioState']]:
        """
        Indicates whether the SilentAudio metric is enabled or disabled.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input['FlowSilentAudioState']]):
        pulumi.set(self, "state", value)

    @_builtins.property
    @pulumi.getter(name="thresholdSeconds")
    def threshold_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of consecutive seconds of silence that triggers an event or alert.
        """
        return pulumi.get(self, "threshold_seconds")

    @threshold_seconds.setter
    def threshold_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "threshold_seconds", value)


if not MYPY:
    class FlowSourceEncryptionArgsDict(TypedDict):
        """
        Information about the encryption of the flow.
        """
        role_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the role that you created during setup (when you set up AWS Elemental MediaConnect as a trusted entity).
        """
        algorithm: NotRequired[pulumi.Input['FlowSourceEncryptionAlgorithm']]
        """
        The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
        """
        constant_initialization_vector: NotRequired[pulumi.Input[_builtins.str]]
        """
        A 128-bit, 16-byte hex value represented by a 32-character string, to be used with the key for encrypting content. This parameter is not valid for static key encryption.
        """
        device_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of one of the devices that you configured with your digital rights management (DRM) platform key provider. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        """
        key_type: NotRequired[pulumi.Input['FlowSourceEncryptionKeyType']]
        """
        The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        The AWS Region that the API Gateway proxy endpoint was created in. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        """
        resource_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        An identifier for the content. The service sends this value to the key server to identify the current endpoint. The resource ID is also known as the content ID. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        """
        secret_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
         The ARN of the secret that you created in AWS Secrets Manager to store the encryption key. This parameter is required for static key encryption and is not valid for SPEKE encryption.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL from the API Gateway proxy that you set up to talk to your key server. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        """
elif False:
    FlowSourceEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowSourceEncryptionArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[_builtins.str],
                 algorithm: Optional[pulumi.Input['FlowSourceEncryptionAlgorithm']] = None,
                 constant_initialization_vector: Optional[pulumi.Input[_builtins.str]] = None,
                 device_id: Optional[pulumi.Input[_builtins.str]] = None,
                 key_type: Optional[pulumi.Input['FlowSourceEncryptionKeyType']] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 resource_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Information about the encryption of the flow.
        :param pulumi.Input[_builtins.str] role_arn: The ARN of the role that you created during setup (when you set up AWS Elemental MediaConnect as a trusted entity).
        :param pulumi.Input['FlowSourceEncryptionAlgorithm'] algorithm: The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
        :param pulumi.Input[_builtins.str] constant_initialization_vector: A 128-bit, 16-byte hex value represented by a 32-character string, to be used with the key for encrypting content. This parameter is not valid for static key encryption.
        :param pulumi.Input[_builtins.str] device_id: The value of one of the devices that you configured with your digital rights management (DRM) platform key provider. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        :param pulumi.Input['FlowSourceEncryptionKeyType'] key_type: The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
        :param pulumi.Input[_builtins.str] region: The AWS Region that the API Gateway proxy endpoint was created in. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        :param pulumi.Input[_builtins.str] resource_id: An identifier for the content. The service sends this value to the key server to identify the current endpoint. The resource ID is also known as the content ID. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        :param pulumi.Input[_builtins.str] secret_arn:  The ARN of the secret that you created in AWS Secrets Manager to store the encryption key. This parameter is required for static key encryption and is not valid for SPEKE encryption.
        :param pulumi.Input[_builtins.str] url: The URL from the API Gateway proxy that you set up to talk to your key server. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        """
        pulumi.set(__self__, "role_arn", role_arn)
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if constant_initialization_vector is not None:
            pulumi.set(__self__, "constant_initialization_vector", constant_initialization_vector)
        if device_id is not None:
            pulumi.set(__self__, "device_id", device_id)
        if key_type is not None:
            pulumi.set(__self__, "key_type", key_type)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if resource_id is not None:
            pulumi.set(__self__, "resource_id", resource_id)
        if secret_arn is not None:
            pulumi.set(__self__, "secret_arn", secret_arn)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the role that you created during setup (when you set up AWS Elemental MediaConnect as a trusted entity).
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter
    def algorithm(self) -> Optional[pulumi.Input['FlowSourceEncryptionAlgorithm']]:
        """
        The type of algorithm that is used for the encryption (such as aes128, aes192, or aes256).
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: Optional[pulumi.Input['FlowSourceEncryptionAlgorithm']]):
        pulumi.set(self, "algorithm", value)

    @_builtins.property
    @pulumi.getter(name="constantInitializationVector")
    def constant_initialization_vector(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A 128-bit, 16-byte hex value represented by a 32-character string, to be used with the key for encrypting content. This parameter is not valid for static key encryption.
        """
        return pulumi.get(self, "constant_initialization_vector")

    @constant_initialization_vector.setter
    def constant_initialization_vector(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "constant_initialization_vector", value)

    @_builtins.property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of one of the devices that you configured with your digital rights management (DRM) platform key provider. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        """
        return pulumi.get(self, "device_id")

    @device_id.setter
    def device_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "device_id", value)

    @_builtins.property
    @pulumi.getter(name="keyType")
    def key_type(self) -> Optional[pulumi.Input['FlowSourceEncryptionKeyType']]:
        """
        The type of key that is used for the encryption. If no keyType is provided, the service will use the default setting (static-key).
        """
        return pulumi.get(self, "key_type")

    @key_type.setter
    def key_type(self, value: Optional[pulumi.Input['FlowSourceEncryptionKeyType']]):
        pulumi.set(self, "key_type", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The AWS Region that the API Gateway proxy endpoint was created in. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An identifier for the content. The service sends this value to the key server to identify the current endpoint. The resource ID is also known as the content ID. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource_id", value)

    @_builtins.property
    @pulumi.getter(name="secretArn")
    def secret_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
         The ARN of the secret that you created in AWS Secrets Manager to store the encryption key. This parameter is required for static key encryption and is not valid for SPEKE encryption.
        """
        return pulumi.get(self, "secret_arn")

    @secret_arn.setter
    def secret_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_arn", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL from the API Gateway proxy that you set up to talk to your key server. This parameter is required for SPEKE encryption and is not valid for static key encryption.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class FlowSourceGatewayBridgeSourceArgsDict(TypedDict):
        """
        The source configuration for cloud flows receiving a stream from a bridge.
        """
        bridge_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the bridge feeding this flow.
        """
        vpc_interface_attachment: NotRequired[pulumi.Input['FlowSourceVpcInterfaceAttachmentArgsDict']]
        """
        The name of the VPC interface attachment to use for this bridge source.
        """
elif False:
    FlowSourceGatewayBridgeSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowSourceGatewayBridgeSourceArgs:
    def __init__(__self__, *,
                 bridge_arn: pulumi.Input[_builtins.str],
                 vpc_interface_attachment: Optional[pulumi.Input['FlowSourceVpcInterfaceAttachmentArgs']] = None):
        """
        The source configuration for cloud flows receiving a stream from a bridge.
        :param pulumi.Input[_builtins.str] bridge_arn: The ARN of the bridge feeding this flow.
        :param pulumi.Input['FlowSourceVpcInterfaceAttachmentArgs'] vpc_interface_attachment: The name of the VPC interface attachment to use for this bridge source.
        """
        pulumi.set(__self__, "bridge_arn", bridge_arn)
        if vpc_interface_attachment is not None:
            pulumi.set(__self__, "vpc_interface_attachment", vpc_interface_attachment)

    @_builtins.property
    @pulumi.getter(name="bridgeArn")
    def bridge_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the bridge feeding this flow.
        """
        return pulumi.get(self, "bridge_arn")

    @bridge_arn.setter
    def bridge_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bridge_arn", value)

    @_builtins.property
    @pulumi.getter(name="vpcInterfaceAttachment")
    def vpc_interface_attachment(self) -> Optional[pulumi.Input['FlowSourceVpcInterfaceAttachmentArgs']]:
        """
        The name of the VPC interface attachment to use for this bridge source.
        """
        return pulumi.get(self, "vpc_interface_attachment")

    @vpc_interface_attachment.setter
    def vpc_interface_attachment(self, value: Optional[pulumi.Input['FlowSourceVpcInterfaceAttachmentArgs']]):
        pulumi.set(self, "vpc_interface_attachment", value)


if not MYPY:
    class FlowSourceMonitoringConfigArgsDict(TypedDict):
        """
        The settings for source monitoring.
        """
        audio_monitoring_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['FlowAudioMonitoringSettingArgsDict']]]]
        """
        Contains the settings for audio stream metrics monitoring.
        """
        content_quality_analysis_state: NotRequired[pulumi.Input['FlowSourceMonitoringConfigContentQualityAnalysisState']]
        """
        Indicates whether content quality analysis is enabled or disabled.
        """
        thumbnail_state: NotRequired[pulumi.Input['FlowSourceMonitoringConfigThumbnailState']]
        """
        The state of thumbnail monitoring.
        """
        video_monitoring_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['FlowVideoMonitoringSettingArgsDict']]]]
        """
        Contains the settings for video stream metrics monitoring.
        """
elif False:
    FlowSourceMonitoringConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowSourceMonitoringConfigArgs:
    def __init__(__self__, *,
                 audio_monitoring_settings: Optional[pulumi.Input[Sequence[pulumi.Input['FlowAudioMonitoringSettingArgs']]]] = None,
                 content_quality_analysis_state: Optional[pulumi.Input['FlowSourceMonitoringConfigContentQualityAnalysisState']] = None,
                 thumbnail_state: Optional[pulumi.Input['FlowSourceMonitoringConfigThumbnailState']] = None,
                 video_monitoring_settings: Optional[pulumi.Input[Sequence[pulumi.Input['FlowVideoMonitoringSettingArgs']]]] = None):
        """
        The settings for source monitoring.
        :param pulumi.Input[Sequence[pulumi.Input['FlowAudioMonitoringSettingArgs']]] audio_monitoring_settings: Contains the settings for audio stream metrics monitoring.
        :param pulumi.Input['FlowSourceMonitoringConfigContentQualityAnalysisState'] content_quality_analysis_state: Indicates whether content quality analysis is enabled or disabled.
        :param pulumi.Input['FlowSourceMonitoringConfigThumbnailState'] thumbnail_state: The state of thumbnail monitoring.
        :param pulumi.Input[Sequence[pulumi.Input['FlowVideoMonitoringSettingArgs']]] video_monitoring_settings: Contains the settings for video stream metrics monitoring.
        """
        if audio_monitoring_settings is not None:
            pulumi.set(__self__, "audio_monitoring_settings", audio_monitoring_settings)
        if content_quality_analysis_state is not None:
            pulumi.set(__self__, "content_quality_analysis_state", content_quality_analysis_state)
        if thumbnail_state is not None:
            pulumi.set(__self__, "thumbnail_state", thumbnail_state)
        if video_monitoring_settings is not None:
            pulumi.set(__self__, "video_monitoring_settings", video_monitoring_settings)

    @_builtins.property
    @pulumi.getter(name="audioMonitoringSettings")
    def audio_monitoring_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FlowAudioMonitoringSettingArgs']]]]:
        """
        Contains the settings for audio stream metrics monitoring.
        """
        return pulumi.get(self, "audio_monitoring_settings")

    @audio_monitoring_settings.setter
    def audio_monitoring_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FlowAudioMonitoringSettingArgs']]]]):
        pulumi.set(self, "audio_monitoring_settings", value)

    @_builtins.property
    @pulumi.getter(name="contentQualityAnalysisState")
    def content_quality_analysis_state(self) -> Optional[pulumi.Input['FlowSourceMonitoringConfigContentQualityAnalysisState']]:
        """
        Indicates whether content quality analysis is enabled or disabled.
        """
        return pulumi.get(self, "content_quality_analysis_state")

    @content_quality_analysis_state.setter
    def content_quality_analysis_state(self, value: Optional[pulumi.Input['FlowSourceMonitoringConfigContentQualityAnalysisState']]):
        pulumi.set(self, "content_quality_analysis_state", value)

    @_builtins.property
    @pulumi.getter(name="thumbnailState")
    def thumbnail_state(self) -> Optional[pulumi.Input['FlowSourceMonitoringConfigThumbnailState']]:
        """
        The state of thumbnail monitoring.
        """
        return pulumi.get(self, "thumbnail_state")

    @thumbnail_state.setter
    def thumbnail_state(self, value: Optional[pulumi.Input['FlowSourceMonitoringConfigThumbnailState']]):
        pulumi.set(self, "thumbnail_state", value)

    @_builtins.property
    @pulumi.getter(name="videoMonitoringSettings")
    def video_monitoring_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FlowVideoMonitoringSettingArgs']]]]:
        """
        Contains the settings for video stream metrics monitoring.
        """
        return pulumi.get(self, "video_monitoring_settings")

    @video_monitoring_settings.setter
    def video_monitoring_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FlowVideoMonitoringSettingArgs']]]]):
        pulumi.set(self, "video_monitoring_settings", value)


if not MYPY:
    class FlowSourceVpcInterfaceAttachmentArgsDict(TypedDict):
        """
        The settings for attaching a VPC interface to an resource.
        """
        vpc_interface_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the VPC interface to use for this resource.
        """
elif False:
    FlowSourceVpcInterfaceAttachmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowSourceVpcInterfaceAttachmentArgs:
    def __init__(__self__, *,
                 vpc_interface_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The settings for attaching a VPC interface to an resource.
        :param pulumi.Input[_builtins.str] vpc_interface_name: The name of the VPC interface to use for this resource.
        """
        if vpc_interface_name is not None:
            pulumi.set(__self__, "vpc_interface_name", vpc_interface_name)

    @_builtins.property
    @pulumi.getter(name="vpcInterfaceName")
    def vpc_interface_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the VPC interface to use for this resource.
        """
        return pulumi.get(self, "vpc_interface_name")

    @vpc_interface_name.setter
    def vpc_interface_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vpc_interface_name", value)


if not MYPY:
    class FlowSourceArgsDict(TypedDict):
        """
        The settings for the source of the flow.
        """
        decryption: NotRequired[pulumi.Input['FlowEncryptionArgsDict']]
        """
        The type of decryption that is used on the content ingested from this source.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A description for the source. This value is not used or seen outside of the current AWS Elemental MediaConnect account.
        """
        entitlement_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ARN of the entitlement that allows you to subscribe to content that comes from another AWS account. The entitlement is set by the content originator and the ARN is generated as part of the originator's flow.
        """
        gateway_bridge_source: NotRequired[pulumi.Input['FlowGatewayBridgeSourceArgsDict']]
        """
        The source configuration for cloud flows receiving a stream from a bridge.
        """
        ingest_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP address that the flow will be listening on for incoming content.
        """
        ingest_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port that the flow will be listening on for incoming content.
        """
        max_bitrate: NotRequired[pulumi.Input[_builtins.int]]
        """
        The smoothing max bitrate for RIST, RTP, and RTP-FEC streams.
        """
        max_latency: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum latency in milliseconds. This parameter applies only to RIST-based and Zixi-based streams.
        """
        max_sync_buffer: NotRequired[pulumi.Input[_builtins.int]]
        """
        The size of the buffer (in milliseconds) to use to sync incoming source data.
        """
        media_stream_source_configurations: NotRequired[pulumi.Input[Sequence[pulumi.Input['FlowMediaStreamSourceConfigurationArgsDict']]]]
        """
        The media stream that is associated with the source, and the parameters for that association.
        """
        min_latency: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum latency in milliseconds.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the source.
        """
        protocol: NotRequired[pulumi.Input['FlowSourceProtocol']]
        """
        The protocol that is used by the source.
        """
        router_integration_state: NotRequired[pulumi.Input['FlowSourceRouterIntegrationState']]
        """
        Indicates if router integration is enabled or disabled on the flow source.
        """
        router_integration_transit_decryption: NotRequired[pulumi.Input['FlowTransitEncryptionArgsDict']]
        """
        The decryption configuration for the flow source when router integration is enabled.
        """
        sender_control_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port that the flow uses to send outbound requests to initiate connection with the sender for fujitsu-qos protocol.
        """
        sender_ip_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP address that the flow communicates with to initiate connection with the sender for fujitsu-qos protocol.
        """
        source_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ARN of the source.
        """
        source_ingest_port: NotRequired[pulumi.Input[_builtins.str]]
        """
        The port that the flow will be listening on for incoming content.(ReadOnly)
        """
        source_listener_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Source IP or domain name for SRT-caller protocol.
        """
        source_listener_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Source port for SRT-caller protocol.
        """
        stream_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The stream ID that you want to use for this transport. This parameter applies only to Zixi-based streams.
        """
        vpc_interface_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the VPC Interface this Source is configured with.
        """
        whitelist_cidr: NotRequired[pulumi.Input[_builtins.str]]
        """
        The range of IP addresses that should be allowed to contribute content to your source. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
        """
elif False:
    FlowSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowSourceArgs:
    def __init__(__self__, *,
                 decryption: Optional[pulumi.Input['FlowEncryptionArgs']] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 entitlement_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 gateway_bridge_source: Optional[pulumi.Input['FlowGatewayBridgeSourceArgs']] = None,
                 ingest_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 ingest_port: Optional[pulumi.Input[_builtins.int]] = None,
                 max_bitrate: Optional[pulumi.Input[_builtins.int]] = None,
                 max_latency: Optional[pulumi.Input[_builtins.int]] = None,
                 max_sync_buffer: Optional[pulumi.Input[_builtins.int]] = None,
                 media_stream_source_configurations: Optional[pulumi.Input[Sequence[pulumi.Input['FlowMediaStreamSourceConfigurationArgs']]]] = None,
                 min_latency: Optional[pulumi.Input[_builtins.int]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input['FlowSourceProtocol']] = None,
                 router_integration_state: Optional[pulumi.Input['FlowSourceRouterIntegrationState']] = None,
                 router_integration_transit_decryption: Optional[pulumi.Input['FlowTransitEncryptionArgs']] = None,
                 sender_control_port: Optional[pulumi.Input[_builtins.int]] = None,
                 sender_ip_address: Optional[pulumi.Input[_builtins.str]] = None,
                 source_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 source_ingest_port: Optional[pulumi.Input[_builtins.str]] = None,
                 source_listener_address: Optional[pulumi.Input[_builtins.str]] = None,
                 source_listener_port: Optional[pulumi.Input[_builtins.int]] = None,
                 stream_id: Optional[pulumi.Input[_builtins.str]] = None,
                 vpc_interface_name: Optional[pulumi.Input[_builtins.str]] = None,
                 whitelist_cidr: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The settings for the source of the flow.
        :param pulumi.Input['FlowEncryptionArgs'] decryption: The type of decryption that is used on the content ingested from this source.
        :param pulumi.Input[_builtins.str] description: A description for the source. This value is not used or seen outside of the current AWS Elemental MediaConnect account.
        :param pulumi.Input[_builtins.str] entitlement_arn: The ARN of the entitlement that allows you to subscribe to content that comes from another AWS account. The entitlement is set by the content originator and the ARN is generated as part of the originator's flow.
        :param pulumi.Input['FlowGatewayBridgeSourceArgs'] gateway_bridge_source: The source configuration for cloud flows receiving a stream from a bridge.
        :param pulumi.Input[_builtins.str] ingest_ip: The IP address that the flow will be listening on for incoming content.
        :param pulumi.Input[_builtins.int] ingest_port: The port that the flow will be listening on for incoming content.
        :param pulumi.Input[_builtins.int] max_bitrate: The smoothing max bitrate for RIST, RTP, and RTP-FEC streams.
        :param pulumi.Input[_builtins.int] max_latency: The maximum latency in milliseconds. This parameter applies only to RIST-based and Zixi-based streams.
        :param pulumi.Input[_builtins.int] max_sync_buffer: The size of the buffer (in milliseconds) to use to sync incoming source data.
        :param pulumi.Input[Sequence[pulumi.Input['FlowMediaStreamSourceConfigurationArgs']]] media_stream_source_configurations: The media stream that is associated with the source, and the parameters for that association.
        :param pulumi.Input[_builtins.int] min_latency: The minimum latency in milliseconds.
        :param pulumi.Input[_builtins.str] name: The name of the source.
        :param pulumi.Input['FlowSourceProtocol'] protocol: The protocol that is used by the source.
        :param pulumi.Input['FlowSourceRouterIntegrationState'] router_integration_state: Indicates if router integration is enabled or disabled on the flow source.
        :param pulumi.Input['FlowTransitEncryptionArgs'] router_integration_transit_decryption: The decryption configuration for the flow source when router integration is enabled.
        :param pulumi.Input[_builtins.int] sender_control_port: The port that the flow uses to send outbound requests to initiate connection with the sender for fujitsu-qos protocol.
        :param pulumi.Input[_builtins.str] sender_ip_address: The IP address that the flow communicates with to initiate connection with the sender for fujitsu-qos protocol.
        :param pulumi.Input[_builtins.str] source_arn: The ARN of the source.
        :param pulumi.Input[_builtins.str] source_ingest_port: The port that the flow will be listening on for incoming content.(ReadOnly)
        :param pulumi.Input[_builtins.str] source_listener_address: Source IP or domain name for SRT-caller protocol.
        :param pulumi.Input[_builtins.int] source_listener_port: Source port for SRT-caller protocol.
        :param pulumi.Input[_builtins.str] stream_id: The stream ID that you want to use for this transport. This parameter applies only to Zixi-based streams.
        :param pulumi.Input[_builtins.str] vpc_interface_name: The name of the VPC Interface this Source is configured with.
        :param pulumi.Input[_builtins.str] whitelist_cidr: The range of IP addresses that should be allowed to contribute content to your source. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
        """
        if decryption is not None:
            pulumi.set(__self__, "decryption", decryption)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if entitlement_arn is not None:
            pulumi.set(__self__, "entitlement_arn", entitlement_arn)
        if gateway_bridge_source is not None:
            pulumi.set(__self__, "gateway_bridge_source", gateway_bridge_source)
        if ingest_ip is not None:
            pulumi.set(__self__, "ingest_ip", ingest_ip)
        if ingest_port is not None:
            pulumi.set(__self__, "ingest_port", ingest_port)
        if max_bitrate is not None:
            pulumi.set(__self__, "max_bitrate", max_bitrate)
        if max_latency is not None:
            pulumi.set(__self__, "max_latency", max_latency)
        if max_sync_buffer is not None:
            pulumi.set(__self__, "max_sync_buffer", max_sync_buffer)
        if media_stream_source_configurations is not None:
            pulumi.set(__self__, "media_stream_source_configurations", media_stream_source_configurations)
        if min_latency is not None:
            pulumi.set(__self__, "min_latency", min_latency)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if router_integration_state is not None:
            pulumi.set(__self__, "router_integration_state", router_integration_state)
        if router_integration_transit_decryption is not None:
            pulumi.set(__self__, "router_integration_transit_decryption", router_integration_transit_decryption)
        if sender_control_port is not None:
            pulumi.set(__self__, "sender_control_port", sender_control_port)
        if sender_ip_address is not None:
            pulumi.set(__self__, "sender_ip_address", sender_ip_address)
        if source_arn is not None:
            pulumi.set(__self__, "source_arn", source_arn)
        if source_ingest_port is not None:
            pulumi.set(__self__, "source_ingest_port", source_ingest_port)
        if source_listener_address is not None:
            pulumi.set(__self__, "source_listener_address", source_listener_address)
        if source_listener_port is not None:
            pulumi.set(__self__, "source_listener_port", source_listener_port)
        if stream_id is not None:
            pulumi.set(__self__, "stream_id", stream_id)
        if vpc_interface_name is not None:
            pulumi.set(__self__, "vpc_interface_name", vpc_interface_name)
        if whitelist_cidr is not None:
            pulumi.set(__self__, "whitelist_cidr", whitelist_cidr)

    @_builtins.property
    @pulumi.getter
    def decryption(self) -> Optional[pulumi.Input['FlowEncryptionArgs']]:
        """
        The type of decryption that is used on the content ingested from this source.
        """
        return pulumi.get(self, "decryption")

    @decryption.setter
    def decryption(self, value: Optional[pulumi.Input['FlowEncryptionArgs']]):
        pulumi.set(self, "decryption", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A description for the source. This value is not used or seen outside of the current AWS Elemental MediaConnect account.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="entitlementArn")
    def entitlement_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ARN of the entitlement that allows you to subscribe to content that comes from another AWS account. The entitlement is set by the content originator and the ARN is generated as part of the originator's flow.
        """
        return pulumi.get(self, "entitlement_arn")

    @entitlement_arn.setter
    def entitlement_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "entitlement_arn", value)

    @_builtins.property
    @pulumi.getter(name="gatewayBridgeSource")
    def gateway_bridge_source(self) -> Optional[pulumi.Input['FlowGatewayBridgeSourceArgs']]:
        """
        The source configuration for cloud flows receiving a stream from a bridge.
        """
        return pulumi.get(self, "gateway_bridge_source")

    @gateway_bridge_source.setter
    def gateway_bridge_source(self, value: Optional[pulumi.Input['FlowGatewayBridgeSourceArgs']]):
        pulumi.set(self, "gateway_bridge_source", value)

    @_builtins.property
    @pulumi.getter(name="ingestIp")
    def ingest_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP address that the flow will be listening on for incoming content.
        """
        return pulumi.get(self, "ingest_ip")

    @ingest_ip.setter
    def ingest_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ingest_ip", value)

    @_builtins.property
    @pulumi.getter(name="ingestPort")
    def ingest_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port that the flow will be listening on for incoming content.
        """
        return pulumi.get(self, "ingest_port")

    @ingest_port.setter
    def ingest_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ingest_port", value)

    @_builtins.property
    @pulumi.getter(name="maxBitrate")
    def max_bitrate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The smoothing max bitrate for RIST, RTP, and RTP-FEC streams.
        """
        return pulumi.get(self, "max_bitrate")

    @max_bitrate.setter
    def max_bitrate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_bitrate", value)

    @_builtins.property
    @pulumi.getter(name="maxLatency")
    def max_latency(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum latency in milliseconds. This parameter applies only to RIST-based and Zixi-based streams.
        """
        return pulumi.get(self, "max_latency")

    @max_latency.setter
    def max_latency(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_latency", value)

    @_builtins.property
    @pulumi.getter(name="maxSyncBuffer")
    def max_sync_buffer(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The size of the buffer (in milliseconds) to use to sync incoming source data.
        """
        return pulumi.get(self, "max_sync_buffer")

    @max_sync_buffer.setter
    def max_sync_buffer(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_sync_buffer", value)

    @_builtins.property
    @pulumi.getter(name="mediaStreamSourceConfigurations")
    def media_stream_source_configurations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FlowMediaStreamSourceConfigurationArgs']]]]:
        """
        The media stream that is associated with the source, and the parameters for that association.
        """
        return pulumi.get(self, "media_stream_source_configurations")

    @media_stream_source_configurations.setter
    def media_stream_source_configurations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FlowMediaStreamSourceConfigurationArgs']]]]):
        pulumi.set(self, "media_stream_source_configurations", value)

    @_builtins.property
    @pulumi.getter(name="minLatency")
    def min_latency(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum latency in milliseconds.
        """
        return pulumi.get(self, "min_latency")

    @min_latency.setter
    def min_latency(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_latency", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the source.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input['FlowSourceProtocol']]:
        """
        The protocol that is used by the source.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input['FlowSourceProtocol']]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="routerIntegrationState")
    def router_integration_state(self) -> Optional[pulumi.Input['FlowSourceRouterIntegrationState']]:
        """
        Indicates if router integration is enabled or disabled on the flow source.
        """
        return pulumi.get(self, "router_integration_state")

    @router_integration_state.setter
    def router_integration_state(self, value: Optional[pulumi.Input['FlowSourceRouterIntegrationState']]):
        pulumi.set(self, "router_integration_state", value)

    @_builtins.property
    @pulumi.getter(name="routerIntegrationTransitDecryption")
    def router_integration_transit_decryption(self) -> Optional[pulumi.Input['FlowTransitEncryptionArgs']]:
        """
        The decryption configuration for the flow source when router integration is enabled.
        """
        return pulumi.get(self, "router_integration_transit_decryption")

    @router_integration_transit_decryption.setter
    def router_integration_transit_decryption(self, value: Optional[pulumi.Input['FlowTransitEncryptionArgs']]):
        pulumi.set(self, "router_integration_transit_decryption", value)

    @_builtins.property
    @pulumi.getter(name="senderControlPort")
    def sender_control_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port that the flow uses to send outbound requests to initiate connection with the sender for fujitsu-qos protocol.
        """
        return pulumi.get(self, "sender_control_port")

    @sender_control_port.setter
    def sender_control_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "sender_control_port", value)

    @_builtins.property
    @pulumi.getter(name="senderIpAddress")
    def sender_ip_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP address that the flow communicates with to initiate connection with the sender for fujitsu-qos protocol.
        """
        return pulumi.get(self, "sender_ip_address")

    @sender_ip_address.setter
    def sender_ip_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sender_ip_address", value)

    @_builtins.property
    @pulumi.getter(name="sourceArn")
    def source_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ARN of the source.
        """
        return pulumi.get(self, "source_arn")

    @source_arn.setter
    def source_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_arn", value)

    @_builtins.property
    @pulumi.getter(name="sourceIngestPort")
    def source_ingest_port(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The port that the flow will be listening on for incoming content.(ReadOnly)
        """
        return pulumi.get(self, "source_ingest_port")

    @source_ingest_port.setter
    def source_ingest_port(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_ingest_port", value)

    @_builtins.property
    @pulumi.getter(name="sourceListenerAddress")
    def source_listener_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Source IP or domain name for SRT-caller protocol.
        """
        return pulumi.get(self, "source_listener_address")

    @source_listener_address.setter
    def source_listener_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_listener_address", value)

    @_builtins.property
    @pulumi.getter(name="sourceListenerPort")
    def source_listener_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Source port for SRT-caller protocol.
        """
        return pulumi.get(self, "source_listener_port")

    @source_listener_port.setter
    def source_listener_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "source_listener_port", value)

    @_builtins.property
    @pulumi.getter(name="streamId")
    def stream_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The stream ID that you want to use for this transport. This parameter applies only to Zixi-based streams.
        """
        return pulumi.get(self, "stream_id")

    @stream_id.setter
    def stream_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "stream_id", value)

    @_builtins.property
    @pulumi.getter(name="vpcInterfaceName")
    def vpc_interface_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the VPC Interface this Source is configured with.
        """
        return pulumi.get(self, "vpc_interface_name")

    @vpc_interface_name.setter
    def vpc_interface_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vpc_interface_name", value)

    @_builtins.property
    @pulumi.getter(name="whitelistCidr")
    def whitelist_cidr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The range of IP addresses that should be allowed to contribute content to your source. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
        """
        return pulumi.get(self, "whitelist_cidr")

    @whitelist_cidr.setter
    def whitelist_cidr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "whitelist_cidr", value)


if not MYPY:
    class FlowTransitEncryptionKeyConfiguration0PropertiesArgsDict(TypedDict):
        """
        Configuration settings for flow transit encryption keys.
        """
        secrets_manager: pulumi.Input['FlowSecretsManagerEncryptionKeyConfigurationArgsDict']
elif False:
    FlowTransitEncryptionKeyConfiguration0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowTransitEncryptionKeyConfiguration0PropertiesArgs:
    def __init__(__self__, *,
                 secrets_manager: pulumi.Input['FlowSecretsManagerEncryptionKeyConfigurationArgs']):
        """
        Configuration settings for flow transit encryption keys.
        """
        pulumi.set(__self__, "secrets_manager", secrets_manager)

    @_builtins.property
    @pulumi.getter(name="secretsManager")
    def secrets_manager(self) -> pulumi.Input['FlowSecretsManagerEncryptionKeyConfigurationArgs']:
        return pulumi.get(self, "secrets_manager")

    @secrets_manager.setter
    def secrets_manager(self, value: pulumi.Input['FlowSecretsManagerEncryptionKeyConfigurationArgs']):
        pulumi.set(self, "secrets_manager", value)


if not MYPY:
    class FlowTransitEncryptionKeyConfiguration1PropertiesArgsDict(TypedDict):
        """
        Configuration settings for flow transit encryption keys.
        """
        automatic: pulumi.Input['FlowAutomaticEncryptionKeyConfigurationArgsDict']
elif False:
    FlowTransitEncryptionKeyConfiguration1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowTransitEncryptionKeyConfiguration1PropertiesArgs:
    def __init__(__self__, *,
                 automatic: pulumi.Input['FlowAutomaticEncryptionKeyConfigurationArgs']):
        """
        Configuration settings for flow transit encryption keys.
        """
        pulumi.set(__self__, "automatic", automatic)

    @_builtins.property
    @pulumi.getter
    def automatic(self) -> pulumi.Input['FlowAutomaticEncryptionKeyConfigurationArgs']:
        return pulumi.get(self, "automatic")

    @automatic.setter
    def automatic(self, value: pulumi.Input['FlowAutomaticEncryptionKeyConfigurationArgs']):
        pulumi.set(self, "automatic", value)


if not MYPY:
    class FlowTransitEncryptionArgsDict(TypedDict):
        """
        The configuration that defines how content is encrypted during transit between the MediaConnect router and a MediaConnect flow.
        """
        encryption_key_configuration: pulumi.Input[Union['FlowTransitEncryptionKeyConfiguration0PropertiesArgsDict', 'FlowTransitEncryptionKeyConfiguration1PropertiesArgsDict']]
        encryption_key_type: NotRequired[pulumi.Input['FlowTransitEncryptionKeyType']]
elif False:
    FlowTransitEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowTransitEncryptionArgs:
    def __init__(__self__, *,
                 encryption_key_configuration: pulumi.Input[Union['FlowTransitEncryptionKeyConfiguration0PropertiesArgs', 'FlowTransitEncryptionKeyConfiguration1PropertiesArgs']],
                 encryption_key_type: Optional[pulumi.Input['FlowTransitEncryptionKeyType']] = None):
        """
        The configuration that defines how content is encrypted during transit between the MediaConnect router and a MediaConnect flow.
        """
        pulumi.set(__self__, "encryption_key_configuration", encryption_key_configuration)
        if encryption_key_type is not None:
            pulumi.set(__self__, "encryption_key_type", encryption_key_type)

    @_builtins.property
    @pulumi.getter(name="encryptionKeyConfiguration")
    def encryption_key_configuration(self) -> pulumi.Input[Union['FlowTransitEncryptionKeyConfiguration0PropertiesArgs', 'FlowTransitEncryptionKeyConfiguration1PropertiesArgs']]:
        return pulumi.get(self, "encryption_key_configuration")

    @encryption_key_configuration.setter
    def encryption_key_configuration(self, value: pulumi.Input[Union['FlowTransitEncryptionKeyConfiguration0PropertiesArgs', 'FlowTransitEncryptionKeyConfiguration1PropertiesArgs']]):
        pulumi.set(self, "encryption_key_configuration", value)

    @_builtins.property
    @pulumi.getter(name="encryptionKeyType")
    def encryption_key_type(self) -> Optional[pulumi.Input['FlowTransitEncryptionKeyType']]:
        return pulumi.get(self, "encryption_key_type")

    @encryption_key_type.setter
    def encryption_key_type(self, value: Optional[pulumi.Input['FlowTransitEncryptionKeyType']]):
        pulumi.set(self, "encryption_key_type", value)


if not MYPY:
    class FlowVideoMonitoringSettingArgsDict(TypedDict):
        """
        Specifies the configuration for video stream metrics monitoring.
        """
        black_frames: NotRequired[pulumi.Input['FlowBlackFramesArgsDict']]
        """
        Detects video frames that are black.
        """
        frozen_frames: NotRequired[pulumi.Input['FlowFrozenFramesArgsDict']]
        """
        Detects video frames that have not changed.
        """
elif False:
    FlowVideoMonitoringSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowVideoMonitoringSettingArgs:
    def __init__(__self__, *,
                 black_frames: Optional[pulumi.Input['FlowBlackFramesArgs']] = None,
                 frozen_frames: Optional[pulumi.Input['FlowFrozenFramesArgs']] = None):
        """
        Specifies the configuration for video stream metrics monitoring.
        :param pulumi.Input['FlowBlackFramesArgs'] black_frames: Detects video frames that are black.
        :param pulumi.Input['FlowFrozenFramesArgs'] frozen_frames: Detects video frames that have not changed.
        """
        if black_frames is not None:
            pulumi.set(__self__, "black_frames", black_frames)
        if frozen_frames is not None:
            pulumi.set(__self__, "frozen_frames", frozen_frames)

    @_builtins.property
    @pulumi.getter(name="blackFrames")
    def black_frames(self) -> Optional[pulumi.Input['FlowBlackFramesArgs']]:
        """
        Detects video frames that are black.
        """
        return pulumi.get(self, "black_frames")

    @black_frames.setter
    def black_frames(self, value: Optional[pulumi.Input['FlowBlackFramesArgs']]):
        pulumi.set(self, "black_frames", value)

    @_builtins.property
    @pulumi.getter(name="frozenFrames")
    def frozen_frames(self) -> Optional[pulumi.Input['FlowFrozenFramesArgs']]:
        """
        Detects video frames that have not changed.
        """
        return pulumi.get(self, "frozen_frames")

    @frozen_frames.setter
    def frozen_frames(self, value: Optional[pulumi.Input['FlowFrozenFramesArgs']]):
        pulumi.set(self, "frozen_frames", value)


if not MYPY:
    class FlowVpcInterfaceAttachmentArgsDict(TypedDict):
        """
        The settings for attaching a VPC interface to an resource.
        """
        vpc_interface_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the VPC interface to use for this resource.
        """
elif False:
    FlowVpcInterfaceAttachmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowVpcInterfaceAttachmentArgs:
    def __init__(__self__, *,
                 vpc_interface_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The settings for attaching a VPC interface to an resource.
        :param pulumi.Input[_builtins.str] vpc_interface_name: The name of the VPC interface to use for this resource.
        """
        if vpc_interface_name is not None:
            pulumi.set(__self__, "vpc_interface_name", vpc_interface_name)

    @_builtins.property
    @pulumi.getter(name="vpcInterfaceName")
    def vpc_interface_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the VPC interface to use for this resource.
        """
        return pulumi.get(self, "vpc_interface_name")

    @vpc_interface_name.setter
    def vpc_interface_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vpc_interface_name", value)


if not MYPY:
    class FlowVpcInterfaceArgsDict(TypedDict):
        """
        The details of a VPC interface.
        """
        name: pulumi.Input[_builtins.str]
        """
        Immutable and has to be a unique against other VpcInterfaces in this Flow.
        """
        role_arn: pulumi.Input[_builtins.str]
        """
        Role Arn MediaConnect can assume to create ENIs in customer's account.
        """
        security_group_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Security Group IDs to be used on ENI.
        """
        subnet_id: pulumi.Input[_builtins.str]
        """
        Subnet must be in the AZ of the Flow
        """
        network_interface_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        IDs of the network interfaces created in customer's account by MediaConnect.
        """
        network_interface_type: NotRequired[pulumi.Input['FlowVpcInterfaceNetworkInterfaceType']]
        """
        The type of network adapter that you want MediaConnect to use on this interface. If you don't set this value, it defaults to ENA.
        """
elif False:
    FlowVpcInterfaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FlowVpcInterfaceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 role_arn: pulumi.Input[_builtins.str],
                 security_group_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 subnet_id: pulumi.Input[_builtins.str],
                 network_interface_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 network_interface_type: Optional[pulumi.Input['FlowVpcInterfaceNetworkInterfaceType']] = None):
        """
        The details of a VPC interface.
        :param pulumi.Input[_builtins.str] name: Immutable and has to be a unique against other VpcInterfaces in this Flow.
        :param pulumi.Input[_builtins.str] role_arn: Role Arn MediaConnect can assume to create ENIs in customer's account.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] security_group_ids: Security Group IDs to be used on ENI.
        :param pulumi.Input[_builtins.str] subnet_id: Subnet must be in the AZ of the Flow
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] network_interface_ids: IDs of the network interfaces created in customer's account by MediaConnect.
        :param pulumi.Input['FlowVpcInterfaceNetworkInterfaceType'] network_interface_type: The type of network adapter that you want MediaConnect to use on this interface. If you don't set this value, it defaults to ENA.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if network_interface_ids is not None:
            pulumi.set(__self__, "network_interface_ids", network_interface_ids)
        if network_interface_type is not None:
            pulumi.set(__self__, "network_interface_type", network_interface_type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Immutable and has to be a unique against other VpcInterfaces in this Flow.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        """
        Role Arn MediaConnect can assume to create ENIs in customer's account.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Security Group IDs to be used on ENI.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "security_group_ids", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[_builtins.str]:
        """
        Subnet must be in the AZ of the Flow
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subnet_id", value)

    @_builtins.property
    @pulumi.getter(name="networkInterfaceIds")
    def network_interface_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        IDs of the network interfaces created in customer's account by MediaConnect.
        """
        return pulumi.get(self, "network_interface_ids")

    @network_interface_ids.setter
    def network_interface_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "network_interface_ids", value)

    @_builtins.property
    @pulumi.getter(name="networkInterfaceType")
    def network_interface_type(self) -> Optional[pulumi.Input['FlowVpcInterfaceNetworkInterfaceType']]:
        """
        The type of network adapter that you want MediaConnect to use on this interface. If you don't set this value, it defaults to ENA.
        """
        return pulumi.get(self, "network_interface_type")

    @network_interface_type.setter
    def network_interface_type(self, value: Optional[pulumi.Input['FlowVpcInterfaceNetworkInterfaceType']]):
        pulumi.set(self, "network_interface_type", value)


if not MYPY:
    class GatewayNetworkArgsDict(TypedDict):
        """
        The network settings for a gateway.
        """
        cidr_block: pulumi.Input[_builtins.str]
        """
        A unique IP address range to use for this network. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the network. This name is used to reference the network and must be unique among networks in this gateway.
        """
elif False:
    GatewayNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GatewayNetworkArgs:
    def __init__(__self__, *,
                 cidr_block: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str]):
        """
        The network settings for a gateway.
        :param pulumi.Input[_builtins.str] cidr_block: A unique IP address range to use for this network. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
        :param pulumi.Input[_builtins.str] name: The name of the network. This name is used to reference the network and must be unique among networks in this gateway.
        """
        pulumi.set(__self__, "cidr_block", cidr_block)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> pulumi.Input[_builtins.str]:
        """
        A unique IP address range to use for this network. These IP addresses should be in the form of a Classless Inter-Domain Routing (CIDR) block; for example, 10.0.0.0/16.
        """
        return pulumi.get(self, "cidr_block")

    @cidr_block.setter
    def cidr_block(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cidr_block", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the network. This name is used to reference the network and must be unique among networks in this gateway.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RouterInputAutomaticEncryptionKeyConfigurationArgsDict(TypedDict):
        """
        Configuration settings for automatic encryption key management, where MediaConnect handles key creation and rotation.
        """
        pass
elif False:
    RouterInputAutomaticEncryptionKeyConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterInputAutomaticEncryptionKeyConfigurationArgs:
    def __init__(__self__):
        """
        Configuration settings for automatic encryption key management, where MediaConnect handles key creation and rotation.
        """
        pass


if not MYPY:
    class RouterInputConfiguration0PropertiesArgsDict(TypedDict):
        """
        The configuration settings for a router input.
        """
        standard: pulumi.Input['RouterInputStandardRouterInputConfigurationArgsDict']
elif False:
    RouterInputConfiguration0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterInputConfiguration0PropertiesArgs:
    def __init__(__self__, *,
                 standard: pulumi.Input['RouterInputStandardRouterInputConfigurationArgs']):
        """
        The configuration settings for a router input.
        """
        pulumi.set(__self__, "standard", standard)

    @_builtins.property
    @pulumi.getter
    def standard(self) -> pulumi.Input['RouterInputStandardRouterInputConfigurationArgs']:
        return pulumi.get(self, "standard")

    @standard.setter
    def standard(self, value: pulumi.Input['RouterInputStandardRouterInputConfigurationArgs']):
        pulumi.set(self, "standard", value)


if not MYPY:
    class RouterInputConfiguration1PropertiesArgsDict(TypedDict):
        """
        The configuration settings for a router input.
        """
        failover: pulumi.Input['RouterInputFailoverRouterInputConfigurationArgsDict']
elif False:
    RouterInputConfiguration1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterInputConfiguration1PropertiesArgs:
    def __init__(__self__, *,
                 failover: pulumi.Input['RouterInputFailoverRouterInputConfigurationArgs']):
        """
        The configuration settings for a router input.
        """
        pulumi.set(__self__, "failover", failover)

    @_builtins.property
    @pulumi.getter
    def failover(self) -> pulumi.Input['RouterInputFailoverRouterInputConfigurationArgs']:
        return pulumi.get(self, "failover")

    @failover.setter
    def failover(self, value: pulumi.Input['RouterInputFailoverRouterInputConfigurationArgs']):
        pulumi.set(self, "failover", value)


if not MYPY:
    class RouterInputConfiguration2PropertiesArgsDict(TypedDict):
        """
        The configuration settings for a router input.
        """
        merge: pulumi.Input['RouterInputMergeRouterInputConfigurationArgsDict']
elif False:
    RouterInputConfiguration2PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterInputConfiguration2PropertiesArgs:
    def __init__(__self__, *,
                 merge: pulumi.Input['RouterInputMergeRouterInputConfigurationArgs']):
        """
        The configuration settings for a router input.
        """
        pulumi.set(__self__, "merge", merge)

    @_builtins.property
    @pulumi.getter
    def merge(self) -> pulumi.Input['RouterInputMergeRouterInputConfigurationArgs']:
        return pulumi.get(self, "merge")

    @merge.setter
    def merge(self, value: pulumi.Input['RouterInputMergeRouterInputConfigurationArgs']):
        pulumi.set(self, "merge", value)


if not MYPY:
    class RouterInputConfiguration3PropertiesArgsDict(TypedDict):
        """
        The configuration settings for a router input.
        """
        media_connect_flow: pulumi.Input['RouterInputMediaConnectFlowRouterInputConfigurationArgsDict']
elif False:
    RouterInputConfiguration3PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterInputConfiguration3PropertiesArgs:
    def __init__(__self__, *,
                 media_connect_flow: pulumi.Input['RouterInputMediaConnectFlowRouterInputConfigurationArgs']):
        """
        The configuration settings for a router input.
        """
        pulumi.set(__self__, "media_connect_flow", media_connect_flow)

    @_builtins.property
    @pulumi.getter(name="mediaConnectFlow")
    def media_connect_flow(self) -> pulumi.Input['RouterInputMediaConnectFlowRouterInputConfigurationArgs']:
        return pulumi.get(self, "media_connect_flow")

    @media_connect_flow.setter
    def media_connect_flow(self, value: pulumi.Input['RouterInputMediaConnectFlowRouterInputConfigurationArgs']):
        pulumi.set(self, "media_connect_flow", value)


if not MYPY:
    class RouterInputDefaultMaintenanceConfigurationArgsDict(TypedDict):
        """
        Configuration settings for default maintenance scheduling.
        """
        pass
elif False:
    RouterInputDefaultMaintenanceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterInputDefaultMaintenanceConfigurationArgs:
    def __init__(__self__):
        """
        Configuration settings for default maintenance scheduling.
        """
        pass


if not MYPY:
    class RouterInputFailoverRouterInputConfigurationArgsDict(TypedDict):
        """
        Configuration settings for a failover router input that allows switching between two input sources.
        """
        network_interface_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the network interface to use for this failover router input.
        """
        protocol_configurations: pulumi.Input[Sequence[pulumi.Input[Union['RouterInputFailoverRouterInputProtocolConfiguration0PropertiesArgsDict', 'RouterInputFailoverRouterInputProtocolConfiguration1PropertiesArgsDict', 'RouterInputFailoverRouterInputProtocolConfiguration2PropertiesArgsDict', 'RouterInputFailoverRouterInputProtocolConfiguration3PropertiesArgsDict']]]]
        """
        A list of exactly two protocol configurations for the failover input sources. Both must use the same protocol type.
        """
        source_priority_mode: pulumi.Input['RouterInputFailoverInputSourcePriorityMode']
        primary_source_index: NotRequired[pulumi.Input[_builtins.int]]
        """
        The index (0 or 1) that specifies which source in the protocol configurations list is currently active. Used to control which of the two failover sources is currently selected. This field is ignored when sourcePriorityMode is set to NO_PRIORITY
        """
elif False:
    RouterInputFailoverRouterInputConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterInputFailoverRouterInputConfigurationArgs:
    def __init__(__self__, *,
                 network_interface_arn: pulumi.Input[_builtins.str],
                 protocol_configurations: pulumi.Input[Sequence[pulumi.Input[Union['RouterInputFailoverRouterInputProtocolConfiguration0PropertiesArgs', 'RouterInputFailoverRouterInputProtocolConfiguration1PropertiesArgs', 'RouterInputFailoverRouterInputProtocolConfiguration2PropertiesArgs', 'RouterInputFailoverRouterInputProtocolConfiguration3PropertiesArgs']]]],
                 source_priority_mode: pulumi.Input['RouterInputFailoverInputSourcePriorityMode'],
                 primary_source_index: Optional[pulumi.Input[_builtins.int]] = None):
        """
        Configuration settings for a failover router input that allows switching between two input sources.
        :param pulumi.Input[_builtins.str] network_interface_arn: The ARN of the network interface to use for this failover router input.
        :param pulumi.Input[Sequence[pulumi.Input[Union['RouterInputFailoverRouterInputProtocolConfiguration0PropertiesArgs', 'RouterInputFailoverRouterInputProtocolConfiguration1PropertiesArgs', 'RouterInputFailoverRouterInputProtocolConfiguration2PropertiesArgs', 'RouterInputFailoverRouterInputProtocolConfiguration3PropertiesArgs']]]] protocol_configurations: A list of exactly two protocol configurations for the failover input sources. Both must use the same protocol type.
        :param pulumi.Input[_builtins.int] primary_source_index: The index (0 or 1) that specifies which source in the protocol configurations list is currently active. Used to control which of the two failover sources is currently selected. This field is ignored when sourcePriorityMode is set to NO_PRIORITY
        """
        pulumi.set(__self__, "network_interface_arn", network_interface_arn)
        pulumi.set(__self__, "protocol_configurations", protocol_configurations)
        pulumi.set(__self__, "source_priority_mode", source_priority_mode)
        if primary_source_index is not None:
            pulumi.set(__self__, "primary_source_index", primary_source_index)

    @_builtins.property
    @pulumi.getter(name="networkInterfaceArn")
    def network_interface_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the network interface to use for this failover router input.
        """
        return pulumi.get(self, "network_interface_arn")

    @network_interface_arn.setter
    def network_interface_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "network_interface_arn", value)

    @_builtins.property
    @pulumi.getter(name="protocolConfigurations")
    def protocol_configurations(self) -> pulumi.Input[Sequence[pulumi.Input[Union['RouterInputFailoverRouterInputProtocolConfiguration0PropertiesArgs', 'RouterInputFailoverRouterInputProtocolConfiguration1PropertiesArgs', 'RouterInputFailoverRouterInputProtocolConfiguration2PropertiesArgs', 'RouterInputFailoverRouterInputProtocolConfiguration3PropertiesArgs']]]]:
        """
        A list of exactly two protocol configurations for the failover input sources. Both must use the same protocol type.
        """
        return pulumi.get(self, "protocol_configurations")

    @protocol_configurations.setter
    def protocol_configurations(self, value: pulumi.Input[Sequence[pulumi.Input[Union['RouterInputFailoverRouterInputProtocolConfiguration0PropertiesArgs', 'RouterInputFailoverRouterInputProtocolConfiguration1PropertiesArgs', 'RouterInputFailoverRouterInputProtocolConfiguration2PropertiesArgs', 'RouterInputFailoverRouterInputProtocolConfiguration3PropertiesArgs']]]]):
        pulumi.set(self, "protocol_configurations", value)

    @_builtins.property
    @pulumi.getter(name="sourcePriorityMode")
    def source_priority_mode(self) -> pulumi.Input['RouterInputFailoverInputSourcePriorityMode']:
        return pulumi.get(self, "source_priority_mode")

    @source_priority_mode.setter
    def source_priority_mode(self, value: pulumi.Input['RouterInputFailoverInputSourcePriorityMode']):
        pulumi.set(self, "source_priority_mode", value)

    @_builtins.property
    @pulumi.getter(name="primarySourceIndex")
    def primary_source_index(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The index (0 or 1) that specifies which source in the protocol configurations list is currently active. Used to control which of the two failover sources is currently selected. This field is ignored when sourcePriorityMode is set to NO_PRIORITY
        """
        return pulumi.get(self, "primary_source_index")

    @primary_source_index.setter
    def primary_source_index(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "primary_source_index", value)


if not MYPY:
    class RouterInputFailoverRouterInputProtocolConfiguration0PropertiesArgsDict(TypedDict):
        """
        Protocol configuration settings for failover router inputs.
        """
        rtp: pulumi.Input['RouterInputRtpRouterInputConfigurationArgsDict']
elif False:
    RouterInputFailoverRouterInputProtocolConfiguration0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterInputFailoverRouterInputProtocolConfiguration0PropertiesArgs:
    def __init__(__self__, *,
                 rtp: pulumi.Input['RouterInputRtpRouterInputConfigurationArgs']):
        """
        Protocol configuration settings for failover router inputs.
        """
        pulumi.set(__self__, "rtp", rtp)

    @_builtins.property
    @pulumi.getter
    def rtp(self) -> pulumi.Input['RouterInputRtpRouterInputConfigurationArgs']:
        return pulumi.get(self, "rtp")

    @rtp.setter
    def rtp(self, value: pulumi.Input['RouterInputRtpRouterInputConfigurationArgs']):
        pulumi.set(self, "rtp", value)


if not MYPY:
    class RouterInputFailoverRouterInputProtocolConfiguration1PropertiesArgsDict(TypedDict):
        """
        Protocol configuration settings for failover router inputs.
        """
        rist: pulumi.Input['RouterInputRistRouterInputConfigurationArgsDict']
elif False:
    RouterInputFailoverRouterInputProtocolConfiguration1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterInputFailoverRouterInputProtocolConfiguration1PropertiesArgs:
    def __init__(__self__, *,
                 rist: pulumi.Input['RouterInputRistRouterInputConfigurationArgs']):
        """
        Protocol configuration settings for failover router inputs.
        """
        pulumi.set(__self__, "rist", rist)

    @_builtins.property
    @pulumi.getter
    def rist(self) -> pulumi.Input['RouterInputRistRouterInputConfigurationArgs']:
        return pulumi.get(self, "rist")

    @rist.setter
    def rist(self, value: pulumi.Input['RouterInputRistRouterInputConfigurationArgs']):
        pulumi.set(self, "rist", value)


if not MYPY:
    class RouterInputFailoverRouterInputProtocolConfiguration2PropertiesArgsDict(TypedDict):
        """
        Protocol configuration settings for failover router inputs.
        """
        srt_listener: pulumi.Input['RouterInputSrtListenerRouterInputConfigurationArgsDict']
elif False:
    RouterInputFailoverRouterInputProtocolConfiguration2PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterInputFailoverRouterInputProtocolConfiguration2PropertiesArgs:
    def __init__(__self__, *,
                 srt_listener: pulumi.Input['RouterInputSrtListenerRouterInputConfigurationArgs']):
        """
        Protocol configuration settings for failover router inputs.
        """
        pulumi.set(__self__, "srt_listener", srt_listener)

    @_builtins.property
    @pulumi.getter(name="srtListener")
    def srt_listener(self) -> pulumi.Input['RouterInputSrtListenerRouterInputConfigurationArgs']:
        return pulumi.get(self, "srt_listener")

    @srt_listener.setter
    def srt_listener(self, value: pulumi.Input['RouterInputSrtListenerRouterInputConfigurationArgs']):
        pulumi.set(self, "srt_listener", value)


if not MYPY:
    class RouterInputFailoverRouterInputProtocolConfiguration3PropertiesArgsDict(TypedDict):
        """
        Protocol configuration settings for failover router inputs.
        """
        srt_caller: pulumi.Input['RouterInputSrtCallerRouterInputConfigurationArgsDict']
elif False:
    RouterInputFailoverRouterInputProtocolConfiguration3PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterInputFailoverRouterInputProtocolConfiguration3PropertiesArgs:
    def __init__(__self__, *,
                 srt_caller: pulumi.Input['RouterInputSrtCallerRouterInputConfigurationArgs']):
        """
        Protocol configuration settings for failover router inputs.
        """
        pulumi.set(__self__, "srt_caller", srt_caller)

    @_builtins.property
    @pulumi.getter(name="srtCaller")
    def srt_caller(self) -> pulumi.Input['RouterInputSrtCallerRouterInputConfigurationArgs']:
        return pulumi.get(self, "srt_caller")

    @srt_caller.setter
    def srt_caller(self, value: pulumi.Input['RouterInputSrtCallerRouterInputConfigurationArgs']):
        pulumi.set(self, "srt_caller", value)


if not MYPY:
    class RouterInputFlowTransitEncryptionKeyConfiguration0PropertiesArgsDict(TypedDict):
        """
        Configuration settings for flow transit encryption keys.
        """
        secrets_manager: pulumi.Input['RouterInputSecretsManagerEncryptionKeyConfigurationArgsDict']
elif False:
    RouterInputFlowTransitEncryptionKeyConfiguration0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterInputFlowTransitEncryptionKeyConfiguration0PropertiesArgs:
    def __init__(__self__, *,
                 secrets_manager: pulumi.Input['RouterInputSecretsManagerEncryptionKeyConfigurationArgs']):
        """
        Configuration settings for flow transit encryption keys.
        """
        pulumi.set(__self__, "secrets_manager", secrets_manager)

    @_builtins.property
    @pulumi.getter(name="secretsManager")
    def secrets_manager(self) -> pulumi.Input['RouterInputSecretsManagerEncryptionKeyConfigurationArgs']:
        return pulumi.get(self, "secrets_manager")

    @secrets_manager.setter
    def secrets_manager(self, value: pulumi.Input['RouterInputSecretsManagerEncryptionKeyConfigurationArgs']):
        pulumi.set(self, "secrets_manager", value)


if not MYPY:
    class RouterInputFlowTransitEncryptionKeyConfiguration1PropertiesArgsDict(TypedDict):
        """
        Configuration settings for flow transit encryption keys.
        """
        automatic: pulumi.Input['RouterInputAutomaticEncryptionKeyConfigurationArgsDict']
elif False:
    RouterInputFlowTransitEncryptionKeyConfiguration1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterInputFlowTransitEncryptionKeyConfiguration1PropertiesArgs:
    def __init__(__self__, *,
                 automatic: pulumi.Input['RouterInputAutomaticEncryptionKeyConfigurationArgs']):
        """
        Configuration settings for flow transit encryption keys.
        """
        pulumi.set(__self__, "automatic", automatic)

    @_builtins.property
    @pulumi.getter
    def automatic(self) -> pulumi.Input['RouterInputAutomaticEncryptionKeyConfigurationArgs']:
        return pulumi.get(self, "automatic")

    @automatic.setter
    def automatic(self, value: pulumi.Input['RouterInputAutomaticEncryptionKeyConfigurationArgs']):
        pulumi.set(self, "automatic", value)


if not MYPY:
    class RouterInputFlowTransitEncryptionArgsDict(TypedDict):
        """
        The configuration that defines how content is encrypted during transit between the MediaConnect router and a MediaConnect flow.
        """
        encryption_key_configuration: pulumi.Input[Union['RouterInputFlowTransitEncryptionKeyConfiguration0PropertiesArgsDict', 'RouterInputFlowTransitEncryptionKeyConfiguration1PropertiesArgsDict']]
        encryption_key_type: NotRequired[pulumi.Input['RouterInputFlowTransitEncryptionKeyType']]
elif False:
    RouterInputFlowTransitEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterInputFlowTransitEncryptionArgs:
    def __init__(__self__, *,
                 encryption_key_configuration: pulumi.Input[Union['RouterInputFlowTransitEncryptionKeyConfiguration0PropertiesArgs', 'RouterInputFlowTransitEncryptionKeyConfiguration1PropertiesArgs']],
                 encryption_key_type: Optional[pulumi.Input['RouterInputFlowTransitEncryptionKeyType']] = None):
        """
        The configuration that defines how content is encrypted during transit between the MediaConnect router and a MediaConnect flow.
        """
        pulumi.set(__self__, "encryption_key_configuration", encryption_key_configuration)
        if encryption_key_type is not None:
            pulumi.set(__self__, "encryption_key_type", encryption_key_type)

    @_builtins.property
    @pulumi.getter(name="encryptionKeyConfiguration")
    def encryption_key_configuration(self) -> pulumi.Input[Union['RouterInputFlowTransitEncryptionKeyConfiguration0PropertiesArgs', 'RouterInputFlowTransitEncryptionKeyConfiguration1PropertiesArgs']]:
        return pulumi.get(self, "encryption_key_configuration")

    @encryption_key_configuration.setter
    def encryption_key_configuration(self, value: pulumi.Input[Union['RouterInputFlowTransitEncryptionKeyConfiguration0PropertiesArgs', 'RouterInputFlowTransitEncryptionKeyConfiguration1PropertiesArgs']]):
        pulumi.set(self, "encryption_key_configuration", value)

    @_builtins.property
    @pulumi.getter(name="encryptionKeyType")
    def encryption_key_type(self) -> Optional[pulumi.Input['RouterInputFlowTransitEncryptionKeyType']]:
        return pulumi.get(self, "encryption_key_type")

    @encryption_key_type.setter
    def encryption_key_type(self, value: Optional[pulumi.Input['RouterInputFlowTransitEncryptionKeyType']]):
        pulumi.set(self, "encryption_key_type", value)


if not MYPY:
    class RouterInputMaintenanceConfiguration0PropertiesArgsDict(TypedDict):
        """
        The configuration settings for maintenance operations, including preferred maintenance windows and schedules.
        """
        preferred_day_time: pulumi.Input['RouterInputPreferredDayTimeMaintenanceConfigurationArgsDict']
elif False:
    RouterInputMaintenanceConfiguration0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterInputMaintenanceConfiguration0PropertiesArgs:
    def __init__(__self__, *,
                 preferred_day_time: pulumi.Input['RouterInputPreferredDayTimeMaintenanceConfigurationArgs']):
        """
        The configuration settings for maintenance operations, including preferred maintenance windows and schedules.
        """
        pulumi.set(__self__, "preferred_day_time", preferred_day_time)

    @_builtins.property
    @pulumi.getter(name="preferredDayTime")
    def preferred_day_time(self) -> pulumi.Input['RouterInputPreferredDayTimeMaintenanceConfigurationArgs']:
        return pulumi.get(self, "preferred_day_time")

    @preferred_day_time.setter
    def preferred_day_time(self, value: pulumi.Input['RouterInputPreferredDayTimeMaintenanceConfigurationArgs']):
        pulumi.set(self, "preferred_day_time", value)


if not MYPY:
    class RouterInputMaintenanceConfiguration1PropertiesArgsDict(TypedDict):
        """
        The configuration settings for maintenance operations, including preferred maintenance windows and schedules.
        """
        default: pulumi.Input['RouterInputDefaultMaintenanceConfigurationArgsDict']
elif False:
    RouterInputMaintenanceConfiguration1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterInputMaintenanceConfiguration1PropertiesArgs:
    def __init__(__self__, *,
                 default: pulumi.Input['RouterInputDefaultMaintenanceConfigurationArgs']):
        """
        The configuration settings for maintenance operations, including preferred maintenance windows and schedules.
        """
        pulumi.set(__self__, "default", default)

    @_builtins.property
    @pulumi.getter
    def default(self) -> pulumi.Input['RouterInputDefaultMaintenanceConfigurationArgs']:
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: pulumi.Input['RouterInputDefaultMaintenanceConfigurationArgs']):
        pulumi.set(self, "default", value)


if not MYPY:
    class RouterInputMediaConnectFlowRouterInputConfigurationArgsDict(TypedDict):
        """
        Configuration settings for connecting a router input to a flow output.
        """
        source_transit_decryption: pulumi.Input['RouterInputFlowTransitEncryptionArgsDict']
        flow_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ARN of the flow to connect to.
        """
        flow_output_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ARN of the flow output to connect to this router input.
        """
elif False:
    RouterInputMediaConnectFlowRouterInputConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterInputMediaConnectFlowRouterInputConfigurationArgs:
    def __init__(__self__, *,
                 source_transit_decryption: pulumi.Input['RouterInputFlowTransitEncryptionArgs'],
                 flow_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 flow_output_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Configuration settings for connecting a router input to a flow output.
        :param pulumi.Input[_builtins.str] flow_arn: The ARN of the flow to connect to.
        :param pulumi.Input[_builtins.str] flow_output_arn: The ARN of the flow output to connect to this router input.
        """
        pulumi.set(__self__, "source_transit_decryption", source_transit_decryption)
        if flow_arn is not None:
            pulumi.set(__self__, "flow_arn", flow_arn)
        if flow_output_arn is not None:
            pulumi.set(__self__, "flow_output_arn", flow_output_arn)

    @_builtins.property
    @pulumi.getter(name="sourceTransitDecryption")
    def source_transit_decryption(self) -> pulumi.Input['RouterInputFlowTransitEncryptionArgs']:
        return pulumi.get(self, "source_transit_decryption")

    @source_transit_decryption.setter
    def source_transit_decryption(self, value: pulumi.Input['RouterInputFlowTransitEncryptionArgs']):
        pulumi.set(self, "source_transit_decryption", value)

    @_builtins.property
    @pulumi.getter(name="flowArn")
    def flow_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ARN of the flow to connect to.
        """
        return pulumi.get(self, "flow_arn")

    @flow_arn.setter
    def flow_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "flow_arn", value)

    @_builtins.property
    @pulumi.getter(name="flowOutputArn")
    def flow_output_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ARN of the flow output to connect to this router input.
        """
        return pulumi.get(self, "flow_output_arn")

    @flow_output_arn.setter
    def flow_output_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "flow_output_arn", value)


if not MYPY:
    class RouterInputMergeRouterInputConfigurationArgsDict(TypedDict):
        """
        Configuration settings for a merge router input that combines two input sources.
        """
        merge_recovery_window_milliseconds: pulumi.Input[_builtins.int]
        """
        The time window in milliseconds for merging the two input sources.
        """
        network_interface_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the network interface to use for this merge router input.
        """
        protocol_configurations: pulumi.Input[Sequence[pulumi.Input[Union['RouterInputMergeRouterInputProtocolConfiguration0PropertiesArgsDict', 'RouterInputMergeRouterInputProtocolConfiguration1PropertiesArgsDict']]]]
        """
        A list of exactly two protocol configurations for the merge input sources. Both must use the same protocol type.
        """
elif False:
    RouterInputMergeRouterInputConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterInputMergeRouterInputConfigurationArgs:
    def __init__(__self__, *,
                 merge_recovery_window_milliseconds: pulumi.Input[_builtins.int],
                 network_interface_arn: pulumi.Input[_builtins.str],
                 protocol_configurations: pulumi.Input[Sequence[pulumi.Input[Union['RouterInputMergeRouterInputProtocolConfiguration0PropertiesArgs', 'RouterInputMergeRouterInputProtocolConfiguration1PropertiesArgs']]]]):
        """
        Configuration settings for a merge router input that combines two input sources.
        :param pulumi.Input[_builtins.int] merge_recovery_window_milliseconds: The time window in milliseconds for merging the two input sources.
        :param pulumi.Input[_builtins.str] network_interface_arn: The ARN of the network interface to use for this merge router input.
        :param pulumi.Input[Sequence[pulumi.Input[Union['RouterInputMergeRouterInputProtocolConfiguration0PropertiesArgs', 'RouterInputMergeRouterInputProtocolConfiguration1PropertiesArgs']]]] protocol_configurations: A list of exactly two protocol configurations for the merge input sources. Both must use the same protocol type.
        """
        pulumi.set(__self__, "merge_recovery_window_milliseconds", merge_recovery_window_milliseconds)
        pulumi.set(__self__, "network_interface_arn", network_interface_arn)
        pulumi.set(__self__, "protocol_configurations", protocol_configurations)

    @_builtins.property
    @pulumi.getter(name="mergeRecoveryWindowMilliseconds")
    def merge_recovery_window_milliseconds(self) -> pulumi.Input[_builtins.int]:
        """
        The time window in milliseconds for merging the two input sources.
        """
        return pulumi.get(self, "merge_recovery_window_milliseconds")

    @merge_recovery_window_milliseconds.setter
    def merge_recovery_window_milliseconds(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "merge_recovery_window_milliseconds", value)

    @_builtins.property
    @pulumi.getter(name="networkInterfaceArn")
    def network_interface_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the network interface to use for this merge router input.
        """
        return pulumi.get(self, "network_interface_arn")

    @network_interface_arn.setter
    def network_interface_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "network_interface_arn", value)

    @_builtins.property
    @pulumi.getter(name="protocolConfigurations")
    def protocol_configurations(self) -> pulumi.Input[Sequence[pulumi.Input[Union['RouterInputMergeRouterInputProtocolConfiguration0PropertiesArgs', 'RouterInputMergeRouterInputProtocolConfiguration1PropertiesArgs']]]]:
        """
        A list of exactly two protocol configurations for the merge input sources. Both must use the same protocol type.
        """
        return pulumi.get(self, "protocol_configurations")

    @protocol_configurations.setter
    def protocol_configurations(self, value: pulumi.Input[Sequence[pulumi.Input[Union['RouterInputMergeRouterInputProtocolConfiguration0PropertiesArgs', 'RouterInputMergeRouterInputProtocolConfiguration1PropertiesArgs']]]]):
        pulumi.set(self, "protocol_configurations", value)


if not MYPY:
    class RouterInputMergeRouterInputProtocolConfiguration0PropertiesArgsDict(TypedDict):
        """
        Protocol configuration settings for merge router inputs.
        """
        rtp: pulumi.Input['RouterInputRtpRouterInputConfigurationArgsDict']
elif False:
    RouterInputMergeRouterInputProtocolConfiguration0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterInputMergeRouterInputProtocolConfiguration0PropertiesArgs:
    def __init__(__self__, *,
                 rtp: pulumi.Input['RouterInputRtpRouterInputConfigurationArgs']):
        """
        Protocol configuration settings for merge router inputs.
        """
        pulumi.set(__self__, "rtp", rtp)

    @_builtins.property
    @pulumi.getter
    def rtp(self) -> pulumi.Input['RouterInputRtpRouterInputConfigurationArgs']:
        return pulumi.get(self, "rtp")

    @rtp.setter
    def rtp(self, value: pulumi.Input['RouterInputRtpRouterInputConfigurationArgs']):
        pulumi.set(self, "rtp", value)


if not MYPY:
    class RouterInputMergeRouterInputProtocolConfiguration1PropertiesArgsDict(TypedDict):
        """
        Protocol configuration settings for merge router inputs.
        """
        rist: pulumi.Input['RouterInputRistRouterInputConfigurationArgsDict']
elif False:
    RouterInputMergeRouterInputProtocolConfiguration1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterInputMergeRouterInputProtocolConfiguration1PropertiesArgs:
    def __init__(__self__, *,
                 rist: pulumi.Input['RouterInputRistRouterInputConfigurationArgs']):
        """
        Protocol configuration settings for merge router inputs.
        """
        pulumi.set(__self__, "rist", rist)

    @_builtins.property
    @pulumi.getter
    def rist(self) -> pulumi.Input['RouterInputRistRouterInputConfigurationArgs']:
        return pulumi.get(self, "rist")

    @rist.setter
    def rist(self, value: pulumi.Input['RouterInputRistRouterInputConfigurationArgs']):
        pulumi.set(self, "rist", value)


if not MYPY:
    class RouterInputPreferredDayTimeMaintenanceConfigurationArgsDict(TypedDict):
        """
        Configuration for preferred day and time maintenance settings.
        """
        day: pulumi.Input['RouterInputDay']
        time: pulumi.Input[_builtins.str]
        """
        The preferred time for maintenance operations.
        """
elif False:
    RouterInputPreferredDayTimeMaintenanceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterInputPreferredDayTimeMaintenanceConfigurationArgs:
    def __init__(__self__, *,
                 day: pulumi.Input['RouterInputDay'],
                 time: pulumi.Input[_builtins.str]):
        """
        Configuration for preferred day and time maintenance settings.
        :param pulumi.Input[_builtins.str] time: The preferred time for maintenance operations.
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "time", time)

    @_builtins.property
    @pulumi.getter
    def day(self) -> pulumi.Input['RouterInputDay']:
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: pulumi.Input['RouterInputDay']):
        pulumi.set(self, "day", value)

    @_builtins.property
    @pulumi.getter
    def time(self) -> pulumi.Input[_builtins.str]:
        """
        The preferred time for maintenance operations.
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "time", value)


if not MYPY:
    class RouterInputProtocolConfiguration0PropertiesArgsDict(TypedDict):
        """
        The protocol configuration settings for a router input.
        """
        rtp: pulumi.Input['RouterInputRtpRouterInputConfigurationArgsDict']
elif False:
    RouterInputProtocolConfiguration0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterInputProtocolConfiguration0PropertiesArgs:
    def __init__(__self__, *,
                 rtp: pulumi.Input['RouterInputRtpRouterInputConfigurationArgs']):
        """
        The protocol configuration settings for a router input.
        """
        pulumi.set(__self__, "rtp", rtp)

    @_builtins.property
    @pulumi.getter
    def rtp(self) -> pulumi.Input['RouterInputRtpRouterInputConfigurationArgs']:
        return pulumi.get(self, "rtp")

    @rtp.setter
    def rtp(self, value: pulumi.Input['RouterInputRtpRouterInputConfigurationArgs']):
        pulumi.set(self, "rtp", value)


if not MYPY:
    class RouterInputProtocolConfiguration1PropertiesArgsDict(TypedDict):
        """
        The protocol configuration settings for a router input.
        """
        rist: pulumi.Input['RouterInputRistRouterInputConfigurationArgsDict']
elif False:
    RouterInputProtocolConfiguration1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterInputProtocolConfiguration1PropertiesArgs:
    def __init__(__self__, *,
                 rist: pulumi.Input['RouterInputRistRouterInputConfigurationArgs']):
        """
        The protocol configuration settings for a router input.
        """
        pulumi.set(__self__, "rist", rist)

    @_builtins.property
    @pulumi.getter
    def rist(self) -> pulumi.Input['RouterInputRistRouterInputConfigurationArgs']:
        return pulumi.get(self, "rist")

    @rist.setter
    def rist(self, value: pulumi.Input['RouterInputRistRouterInputConfigurationArgs']):
        pulumi.set(self, "rist", value)


if not MYPY:
    class RouterInputProtocolConfiguration2PropertiesArgsDict(TypedDict):
        """
        The protocol configuration settings for a router input.
        """
        srt_listener: pulumi.Input['RouterInputSrtListenerRouterInputConfigurationArgsDict']
elif False:
    RouterInputProtocolConfiguration2PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterInputProtocolConfiguration2PropertiesArgs:
    def __init__(__self__, *,
                 srt_listener: pulumi.Input['RouterInputSrtListenerRouterInputConfigurationArgs']):
        """
        The protocol configuration settings for a router input.
        """
        pulumi.set(__self__, "srt_listener", srt_listener)

    @_builtins.property
    @pulumi.getter(name="srtListener")
    def srt_listener(self) -> pulumi.Input['RouterInputSrtListenerRouterInputConfigurationArgs']:
        return pulumi.get(self, "srt_listener")

    @srt_listener.setter
    def srt_listener(self, value: pulumi.Input['RouterInputSrtListenerRouterInputConfigurationArgs']):
        pulumi.set(self, "srt_listener", value)


if not MYPY:
    class RouterInputProtocolConfiguration3PropertiesArgsDict(TypedDict):
        """
        The protocol configuration settings for a router input.
        """
        srt_caller: pulumi.Input['RouterInputSrtCallerRouterInputConfigurationArgsDict']
elif False:
    RouterInputProtocolConfiguration3PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterInputProtocolConfiguration3PropertiesArgs:
    def __init__(__self__, *,
                 srt_caller: pulumi.Input['RouterInputSrtCallerRouterInputConfigurationArgs']):
        """
        The protocol configuration settings for a router input.
        """
        pulumi.set(__self__, "srt_caller", srt_caller)

    @_builtins.property
    @pulumi.getter(name="srtCaller")
    def srt_caller(self) -> pulumi.Input['RouterInputSrtCallerRouterInputConfigurationArgs']:
        return pulumi.get(self, "srt_caller")

    @srt_caller.setter
    def srt_caller(self, value: pulumi.Input['RouterInputSrtCallerRouterInputConfigurationArgs']):
        pulumi.set(self, "srt_caller", value)


if not MYPY:
    class RouterInputRistRouterInputConfigurationArgsDict(TypedDict):
        """
        The configuration settings for a router input using the RIST (Reliable Internet Stream Transport) protocol, including the port and recovery latency.
        """
        port: pulumi.Input[_builtins.int]
        """
        The port number used for the RIST protocol in the router input configuration.
        """
        recovery_latency_milliseconds: pulumi.Input[_builtins.int]
        """
        The recovery latency in milliseconds for the RIST protocol in the router input configuration.
        """
elif False:
    RouterInputRistRouterInputConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterInputRistRouterInputConfigurationArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[_builtins.int],
                 recovery_latency_milliseconds: pulumi.Input[_builtins.int]):
        """
        The configuration settings for a router input using the RIST (Reliable Internet Stream Transport) protocol, including the port and recovery latency.
        :param pulumi.Input[_builtins.int] port: The port number used for the RIST protocol in the router input configuration.
        :param pulumi.Input[_builtins.int] recovery_latency_milliseconds: The recovery latency in milliseconds for the RIST protocol in the router input configuration.
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "recovery_latency_milliseconds", recovery_latency_milliseconds)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        The port number used for the RIST protocol in the router input configuration.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="recoveryLatencyMilliseconds")
    def recovery_latency_milliseconds(self) -> pulumi.Input[_builtins.int]:
        """
        The recovery latency in milliseconds for the RIST protocol in the router input configuration.
        """
        return pulumi.get(self, "recovery_latency_milliseconds")

    @recovery_latency_milliseconds.setter
    def recovery_latency_milliseconds(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "recovery_latency_milliseconds", value)


if not MYPY:
    class RouterInputRtpRouterInputConfigurationArgsDict(TypedDict):
        """
        The configuration settings for a Router Input using the RTP (Real-Time Transport Protocol) protocol, including the port and forward error correction state.
        """
        port: pulumi.Input[_builtins.int]
        """
        The port number used for the RTP protocol in the router input configuration.
        """
        forward_error_correction: NotRequired[pulumi.Input['RouterInputForwardErrorCorrectionState']]
elif False:
    RouterInputRtpRouterInputConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterInputRtpRouterInputConfigurationArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[_builtins.int],
                 forward_error_correction: Optional[pulumi.Input['RouterInputForwardErrorCorrectionState']] = None):
        """
        The configuration settings for a Router Input using the RTP (Real-Time Transport Protocol) protocol, including the port and forward error correction state.
        :param pulumi.Input[_builtins.int] port: The port number used for the RTP protocol in the router input configuration.
        """
        pulumi.set(__self__, "port", port)
        if forward_error_correction is not None:
            pulumi.set(__self__, "forward_error_correction", forward_error_correction)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        The port number used for the RTP protocol in the router input configuration.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="forwardErrorCorrection")
    def forward_error_correction(self) -> Optional[pulumi.Input['RouterInputForwardErrorCorrectionState']]:
        return pulumi.get(self, "forward_error_correction")

    @forward_error_correction.setter
    def forward_error_correction(self, value: Optional[pulumi.Input['RouterInputForwardErrorCorrectionState']]):
        pulumi.set(self, "forward_error_correction", value)


if not MYPY:
    class RouterInputSecretsManagerEncryptionKeyConfigurationArgsDict(TypedDict):
        """
        The configuration settings for transit encryption using AWS Secrets Manager, including the secret ARN and role ARN.
        """
        role_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the IAM role assumed by MediaConnect to access the AWS Secrets Manager secret.
        """
        secret_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the AWS Secrets Manager secret used for transit encryption.
        """
elif False:
    RouterInputSecretsManagerEncryptionKeyConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterInputSecretsManagerEncryptionKeyConfigurationArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[_builtins.str],
                 secret_arn: pulumi.Input[_builtins.str]):
        """
        The configuration settings for transit encryption using AWS Secrets Manager, including the secret ARN and role ARN.
        :param pulumi.Input[_builtins.str] role_arn: The ARN of the IAM role assumed by MediaConnect to access the AWS Secrets Manager secret.
        :param pulumi.Input[_builtins.str] secret_arn: The ARN of the AWS Secrets Manager secret used for transit encryption.
        """
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "secret_arn", secret_arn)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the IAM role assumed by MediaConnect to access the AWS Secrets Manager secret.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="secretArn")
    def secret_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the AWS Secrets Manager secret used for transit encryption.
        """
        return pulumi.get(self, "secret_arn")

    @secret_arn.setter
    def secret_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_arn", value)


if not MYPY:
    class RouterInputSrtCallerRouterInputConfigurationArgsDict(TypedDict):
        """
        The configuration settings for a router input using the SRT (Secure Reliable Transport) protocol in caller mode, including the source address and port, minimum latency, stream ID, and decryption key configuration.
        """
        minimum_latency_milliseconds: pulumi.Input[_builtins.int]
        """
        The minimum latency in milliseconds for the SRT protocol in caller mode.
        """
        source_address: pulumi.Input[_builtins.str]
        """
        The source IP address for the SRT protocol in caller mode.
        """
        source_port: pulumi.Input[_builtins.int]
        """
        The source port number for the SRT protocol in caller mode.
        """
        decryption_configuration: NotRequired[pulumi.Input['RouterInputSrtDecryptionConfigurationArgsDict']]
        stream_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The stream ID for the SRT protocol in caller mode.
        """
elif False:
    RouterInputSrtCallerRouterInputConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterInputSrtCallerRouterInputConfigurationArgs:
    def __init__(__self__, *,
                 minimum_latency_milliseconds: pulumi.Input[_builtins.int],
                 source_address: pulumi.Input[_builtins.str],
                 source_port: pulumi.Input[_builtins.int],
                 decryption_configuration: Optional[pulumi.Input['RouterInputSrtDecryptionConfigurationArgs']] = None,
                 stream_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The configuration settings for a router input using the SRT (Secure Reliable Transport) protocol in caller mode, including the source address and port, minimum latency, stream ID, and decryption key configuration.
        :param pulumi.Input[_builtins.int] minimum_latency_milliseconds: The minimum latency in milliseconds for the SRT protocol in caller mode.
        :param pulumi.Input[_builtins.str] source_address: The source IP address for the SRT protocol in caller mode.
        :param pulumi.Input[_builtins.int] source_port: The source port number for the SRT protocol in caller mode.
        :param pulumi.Input[_builtins.str] stream_id: The stream ID for the SRT protocol in caller mode.
        """
        pulumi.set(__self__, "minimum_latency_milliseconds", minimum_latency_milliseconds)
        pulumi.set(__self__, "source_address", source_address)
        pulumi.set(__self__, "source_port", source_port)
        if decryption_configuration is not None:
            pulumi.set(__self__, "decryption_configuration", decryption_configuration)
        if stream_id is not None:
            pulumi.set(__self__, "stream_id", stream_id)

    @_builtins.property
    @pulumi.getter(name="minimumLatencyMilliseconds")
    def minimum_latency_milliseconds(self) -> pulumi.Input[_builtins.int]:
        """
        The minimum latency in milliseconds for the SRT protocol in caller mode.
        """
        return pulumi.get(self, "minimum_latency_milliseconds")

    @minimum_latency_milliseconds.setter
    def minimum_latency_milliseconds(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "minimum_latency_milliseconds", value)

    @_builtins.property
    @pulumi.getter(name="sourceAddress")
    def source_address(self) -> pulumi.Input[_builtins.str]:
        """
        The source IP address for the SRT protocol in caller mode.
        """
        return pulumi.get(self, "source_address")

    @source_address.setter
    def source_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_address", value)

    @_builtins.property
    @pulumi.getter(name="sourcePort")
    def source_port(self) -> pulumi.Input[_builtins.int]:
        """
        The source port number for the SRT protocol in caller mode.
        """
        return pulumi.get(self, "source_port")

    @source_port.setter
    def source_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "source_port", value)

    @_builtins.property
    @pulumi.getter(name="decryptionConfiguration")
    def decryption_configuration(self) -> Optional[pulumi.Input['RouterInputSrtDecryptionConfigurationArgs']]:
        return pulumi.get(self, "decryption_configuration")

    @decryption_configuration.setter
    def decryption_configuration(self, value: Optional[pulumi.Input['RouterInputSrtDecryptionConfigurationArgs']]):
        pulumi.set(self, "decryption_configuration", value)

    @_builtins.property
    @pulumi.getter(name="streamId")
    def stream_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The stream ID for the SRT protocol in caller mode.
        """
        return pulumi.get(self, "stream_id")

    @stream_id.setter
    def stream_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "stream_id", value)


if not MYPY:
    class RouterInputSrtDecryptionConfigurationArgsDict(TypedDict):
        """
        Contains the configuration settings for decrypting SRT streams, including the encryption key details and decryption parameters.
        """
        encryption_key: pulumi.Input['RouterInputSecretsManagerEncryptionKeyConfigurationArgsDict']
elif False:
    RouterInputSrtDecryptionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterInputSrtDecryptionConfigurationArgs:
    def __init__(__self__, *,
                 encryption_key: pulumi.Input['RouterInputSecretsManagerEncryptionKeyConfigurationArgs']):
        """
        Contains the configuration settings for decrypting SRT streams, including the encryption key details and decryption parameters.
        """
        pulumi.set(__self__, "encryption_key", encryption_key)

    @_builtins.property
    @pulumi.getter(name="encryptionKey")
    def encryption_key(self) -> pulumi.Input['RouterInputSecretsManagerEncryptionKeyConfigurationArgs']:
        return pulumi.get(self, "encryption_key")

    @encryption_key.setter
    def encryption_key(self, value: pulumi.Input['RouterInputSecretsManagerEncryptionKeyConfigurationArgs']):
        pulumi.set(self, "encryption_key", value)


if not MYPY:
    class RouterInputSrtListenerRouterInputConfigurationArgsDict(TypedDict):
        """
        The configuration settings for a router input using the SRT (Secure Reliable Transport) protocol in listener mode, including the port, minimum latency, and decryption key configuration.
        """
        minimum_latency_milliseconds: pulumi.Input[_builtins.int]
        """
        The minimum latency in milliseconds for the SRT protocol in listener mode.
        """
        port: pulumi.Input[_builtins.int]
        """
        The port number for the SRT protocol in listener mode.
        """
        decryption_configuration: NotRequired[pulumi.Input['RouterInputSrtDecryptionConfigurationArgsDict']]
elif False:
    RouterInputSrtListenerRouterInputConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterInputSrtListenerRouterInputConfigurationArgs:
    def __init__(__self__, *,
                 minimum_latency_milliseconds: pulumi.Input[_builtins.int],
                 port: pulumi.Input[_builtins.int],
                 decryption_configuration: Optional[pulumi.Input['RouterInputSrtDecryptionConfigurationArgs']] = None):
        """
        The configuration settings for a router input using the SRT (Secure Reliable Transport) protocol in listener mode, including the port, minimum latency, and decryption key configuration.
        :param pulumi.Input[_builtins.int] minimum_latency_milliseconds: The minimum latency in milliseconds for the SRT protocol in listener mode.
        :param pulumi.Input[_builtins.int] port: The port number for the SRT protocol in listener mode.
        """
        pulumi.set(__self__, "minimum_latency_milliseconds", minimum_latency_milliseconds)
        pulumi.set(__self__, "port", port)
        if decryption_configuration is not None:
            pulumi.set(__self__, "decryption_configuration", decryption_configuration)

    @_builtins.property
    @pulumi.getter(name="minimumLatencyMilliseconds")
    def minimum_latency_milliseconds(self) -> pulumi.Input[_builtins.int]:
        """
        The minimum latency in milliseconds for the SRT protocol in listener mode.
        """
        return pulumi.get(self, "minimum_latency_milliseconds")

    @minimum_latency_milliseconds.setter
    def minimum_latency_milliseconds(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "minimum_latency_milliseconds", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        The port number for the SRT protocol in listener mode.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="decryptionConfiguration")
    def decryption_configuration(self) -> Optional[pulumi.Input['RouterInputSrtDecryptionConfigurationArgs']]:
        return pulumi.get(self, "decryption_configuration")

    @decryption_configuration.setter
    def decryption_configuration(self, value: Optional[pulumi.Input['RouterInputSrtDecryptionConfigurationArgs']]):
        pulumi.set(self, "decryption_configuration", value)


if not MYPY:
    class RouterInputStandardRouterInputConfigurationArgsDict(TypedDict):
        """
        The configuration settings for a standard router input, including the protocol, protocol-specific configuration, network interface, and availability zone.
        """
        network_interface_arn: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name (ARN) of the network interface associated with the standard router input.
        """
        protocol_configuration: pulumi.Input[Union['RouterInputProtocolConfiguration0PropertiesArgsDict', 'RouterInputProtocolConfiguration1PropertiesArgsDict', 'RouterInputProtocolConfiguration2PropertiesArgsDict', 'RouterInputProtocolConfiguration3PropertiesArgsDict']]
        protocol: NotRequired[pulumi.Input['RouterInputProtocol']]
elif False:
    RouterInputStandardRouterInputConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterInputStandardRouterInputConfigurationArgs:
    def __init__(__self__, *,
                 network_interface_arn: pulumi.Input[_builtins.str],
                 protocol_configuration: pulumi.Input[Union['RouterInputProtocolConfiguration0PropertiesArgs', 'RouterInputProtocolConfiguration1PropertiesArgs', 'RouterInputProtocolConfiguration2PropertiesArgs', 'RouterInputProtocolConfiguration3PropertiesArgs']],
                 protocol: Optional[pulumi.Input['RouterInputProtocol']] = None):
        """
        The configuration settings for a standard router input, including the protocol, protocol-specific configuration, network interface, and availability zone.
        :param pulumi.Input[_builtins.str] network_interface_arn: The Amazon Resource Name (ARN) of the network interface associated with the standard router input.
        """
        pulumi.set(__self__, "network_interface_arn", network_interface_arn)
        pulumi.set(__self__, "protocol_configuration", protocol_configuration)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter(name="networkInterfaceArn")
    def network_interface_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the network interface associated with the standard router input.
        """
        return pulumi.get(self, "network_interface_arn")

    @network_interface_arn.setter
    def network_interface_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "network_interface_arn", value)

    @_builtins.property
    @pulumi.getter(name="protocolConfiguration")
    def protocol_configuration(self) -> pulumi.Input[Union['RouterInputProtocolConfiguration0PropertiesArgs', 'RouterInputProtocolConfiguration1PropertiesArgs', 'RouterInputProtocolConfiguration2PropertiesArgs', 'RouterInputProtocolConfiguration3PropertiesArgs']]:
        return pulumi.get(self, "protocol_configuration")

    @protocol_configuration.setter
    def protocol_configuration(self, value: pulumi.Input[Union['RouterInputProtocolConfiguration0PropertiesArgs', 'RouterInputProtocolConfiguration1PropertiesArgs', 'RouterInputProtocolConfiguration2PropertiesArgs', 'RouterInputProtocolConfiguration3PropertiesArgs']]):
        pulumi.set(self, "protocol_configuration", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input['RouterInputProtocol']]:
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input['RouterInputProtocol']]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class RouterInputTransitEncryptionKeyConfiguration0PropertiesArgsDict(TypedDict):
        """
        Defines the configuration settings for transit encryption keys.
        """
        secrets_manager: pulumi.Input['RouterInputSecretsManagerEncryptionKeyConfigurationArgsDict']
elif False:
    RouterInputTransitEncryptionKeyConfiguration0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterInputTransitEncryptionKeyConfiguration0PropertiesArgs:
    def __init__(__self__, *,
                 secrets_manager: pulumi.Input['RouterInputSecretsManagerEncryptionKeyConfigurationArgs']):
        """
        Defines the configuration settings for transit encryption keys.
        """
        pulumi.set(__self__, "secrets_manager", secrets_manager)

    @_builtins.property
    @pulumi.getter(name="secretsManager")
    def secrets_manager(self) -> pulumi.Input['RouterInputSecretsManagerEncryptionKeyConfigurationArgs']:
        return pulumi.get(self, "secrets_manager")

    @secrets_manager.setter
    def secrets_manager(self, value: pulumi.Input['RouterInputSecretsManagerEncryptionKeyConfigurationArgs']):
        pulumi.set(self, "secrets_manager", value)


if not MYPY:
    class RouterInputTransitEncryptionKeyConfiguration1PropertiesArgsDict(TypedDict):
        """
        Defines the configuration settings for transit encryption keys.
        """
        automatic: pulumi.Input['RouterInputAutomaticEncryptionKeyConfigurationArgsDict']
elif False:
    RouterInputTransitEncryptionKeyConfiguration1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterInputTransitEncryptionKeyConfiguration1PropertiesArgs:
    def __init__(__self__, *,
                 automatic: pulumi.Input['RouterInputAutomaticEncryptionKeyConfigurationArgs']):
        """
        Defines the configuration settings for transit encryption keys.
        """
        pulumi.set(__self__, "automatic", automatic)

    @_builtins.property
    @pulumi.getter
    def automatic(self) -> pulumi.Input['RouterInputAutomaticEncryptionKeyConfigurationArgs']:
        return pulumi.get(self, "automatic")

    @automatic.setter
    def automatic(self, value: pulumi.Input['RouterInputAutomaticEncryptionKeyConfigurationArgs']):
        pulumi.set(self, "automatic", value)


if not MYPY:
    class RouterInputTransitEncryptionArgsDict(TypedDict):
        """
        The transit encryption settings for a router input.
        """
        encryption_key_configuration: pulumi.Input[Union['RouterInputTransitEncryptionKeyConfiguration0PropertiesArgsDict', 'RouterInputTransitEncryptionKeyConfiguration1PropertiesArgsDict']]
        encryption_key_type: NotRequired[pulumi.Input['RouterInputTransitEncryptionKeyType']]
elif False:
    RouterInputTransitEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterInputTransitEncryptionArgs:
    def __init__(__self__, *,
                 encryption_key_configuration: pulumi.Input[Union['RouterInputTransitEncryptionKeyConfiguration0PropertiesArgs', 'RouterInputTransitEncryptionKeyConfiguration1PropertiesArgs']],
                 encryption_key_type: Optional[pulumi.Input['RouterInputTransitEncryptionKeyType']] = None):
        """
        The transit encryption settings for a router input.
        """
        pulumi.set(__self__, "encryption_key_configuration", encryption_key_configuration)
        if encryption_key_type is not None:
            pulumi.set(__self__, "encryption_key_type", encryption_key_type)

    @_builtins.property
    @pulumi.getter(name="encryptionKeyConfiguration")
    def encryption_key_configuration(self) -> pulumi.Input[Union['RouterInputTransitEncryptionKeyConfiguration0PropertiesArgs', 'RouterInputTransitEncryptionKeyConfiguration1PropertiesArgs']]:
        return pulumi.get(self, "encryption_key_configuration")

    @encryption_key_configuration.setter
    def encryption_key_configuration(self, value: pulumi.Input[Union['RouterInputTransitEncryptionKeyConfiguration0PropertiesArgs', 'RouterInputTransitEncryptionKeyConfiguration1PropertiesArgs']]):
        pulumi.set(self, "encryption_key_configuration", value)

    @_builtins.property
    @pulumi.getter(name="encryptionKeyType")
    def encryption_key_type(self) -> Optional[pulumi.Input['RouterInputTransitEncryptionKeyType']]:
        return pulumi.get(self, "encryption_key_type")

    @encryption_key_type.setter
    def encryption_key_type(self, value: Optional[pulumi.Input['RouterInputTransitEncryptionKeyType']]):
        pulumi.set(self, "encryption_key_type", value)


if not MYPY:
    class RouterNetworkInterfaceConfiguration0PropertiesArgsDict(TypedDict):
        """
        The configuration settings for a router network interface.
        """
        public: pulumi.Input['RouterNetworkInterfacePublicRouterNetworkInterfaceConfigurationArgsDict']
elif False:
    RouterNetworkInterfaceConfiguration0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterNetworkInterfaceConfiguration0PropertiesArgs:
    def __init__(__self__, *,
                 public: pulumi.Input['RouterNetworkInterfacePublicRouterNetworkInterfaceConfigurationArgs']):
        """
        The configuration settings for a router network interface.
        """
        pulumi.set(__self__, "public", public)

    @_builtins.property
    @pulumi.getter
    def public(self) -> pulumi.Input['RouterNetworkInterfacePublicRouterNetworkInterfaceConfigurationArgs']:
        return pulumi.get(self, "public")

    @public.setter
    def public(self, value: pulumi.Input['RouterNetworkInterfacePublicRouterNetworkInterfaceConfigurationArgs']):
        pulumi.set(self, "public", value)


if not MYPY:
    class RouterNetworkInterfaceConfiguration1PropertiesArgsDict(TypedDict):
        """
        The configuration settings for a router network interface.
        """
        vpc: pulumi.Input['RouterNetworkInterfaceVpcRouterNetworkInterfaceConfigurationArgsDict']
elif False:
    RouterNetworkInterfaceConfiguration1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterNetworkInterfaceConfiguration1PropertiesArgs:
    def __init__(__self__, *,
                 vpc: pulumi.Input['RouterNetworkInterfaceVpcRouterNetworkInterfaceConfigurationArgs']):
        """
        The configuration settings for a router network interface.
        """
        pulumi.set(__self__, "vpc", vpc)

    @_builtins.property
    @pulumi.getter
    def vpc(self) -> pulumi.Input['RouterNetworkInterfaceVpcRouterNetworkInterfaceConfigurationArgs']:
        return pulumi.get(self, "vpc")

    @vpc.setter
    def vpc(self, value: pulumi.Input['RouterNetworkInterfaceVpcRouterNetworkInterfaceConfigurationArgs']):
        pulumi.set(self, "vpc", value)


if not MYPY:
    class RouterNetworkInterfacePublicRouterNetworkInterfaceConfigurationArgsDict(TypedDict):
        """
        The configuration settings for a public router network interface, including the list of allowed CIDR blocks.
        """
        allow_rules: pulumi.Input[Sequence[pulumi.Input['RouterNetworkInterfacePublicRouterNetworkInterfaceRuleArgsDict']]]
        """
        The list of allowed CIDR blocks for the public router network interface.
        """
elif False:
    RouterNetworkInterfacePublicRouterNetworkInterfaceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterNetworkInterfacePublicRouterNetworkInterfaceConfigurationArgs:
    def __init__(__self__, *,
                 allow_rules: pulumi.Input[Sequence[pulumi.Input['RouterNetworkInterfacePublicRouterNetworkInterfaceRuleArgs']]]):
        """
        The configuration settings for a public router network interface, including the list of allowed CIDR blocks.
        :param pulumi.Input[Sequence[pulumi.Input['RouterNetworkInterfacePublicRouterNetworkInterfaceRuleArgs']]] allow_rules: The list of allowed CIDR blocks for the public router network interface.
        """
        pulumi.set(__self__, "allow_rules", allow_rules)

    @_builtins.property
    @pulumi.getter(name="allowRules")
    def allow_rules(self) -> pulumi.Input[Sequence[pulumi.Input['RouterNetworkInterfacePublicRouterNetworkInterfaceRuleArgs']]]:
        """
        The list of allowed CIDR blocks for the public router network interface.
        """
        return pulumi.get(self, "allow_rules")

    @allow_rules.setter
    def allow_rules(self, value: pulumi.Input[Sequence[pulumi.Input['RouterNetworkInterfacePublicRouterNetworkInterfaceRuleArgs']]]):
        pulumi.set(self, "allow_rules", value)


if not MYPY:
    class RouterNetworkInterfacePublicRouterNetworkInterfaceRuleArgsDict(TypedDict):
        """
        A rule that allows a specific CIDR block to access the public router network interface.
        """
        cidr: pulumi.Input[_builtins.str]
        """
        The CIDR block that is allowed to access the public router network interface.
        """
elif False:
    RouterNetworkInterfacePublicRouterNetworkInterfaceRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterNetworkInterfacePublicRouterNetworkInterfaceRuleArgs:
    def __init__(__self__, *,
                 cidr: pulumi.Input[_builtins.str]):
        """
        A rule that allows a specific CIDR block to access the public router network interface.
        :param pulumi.Input[_builtins.str] cidr: The CIDR block that is allowed to access the public router network interface.
        """
        pulumi.set(__self__, "cidr", cidr)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> pulumi.Input[_builtins.str]:
        """
        The CIDR block that is allowed to access the public router network interface.
        """
        return pulumi.get(self, "cidr")

    @cidr.setter
    def cidr(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cidr", value)


if not MYPY:
    class RouterNetworkInterfaceVpcRouterNetworkInterfaceConfigurationArgsDict(TypedDict):
        """
        The configuration settings for a router network interface within a VPC, including the security group IDs and subnet ID.
        """
        security_group_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The IDs of the security groups to associate with the router network interface within the VPC.
        """
        subnet_id: pulumi.Input[_builtins.str]
        """
        The ID of the subnet within the VPC to associate the router network interface with.
        """
elif False:
    RouterNetworkInterfaceVpcRouterNetworkInterfaceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterNetworkInterfaceVpcRouterNetworkInterfaceConfigurationArgs:
    def __init__(__self__, *,
                 security_group_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 subnet_id: pulumi.Input[_builtins.str]):
        """
        The configuration settings for a router network interface within a VPC, including the security group IDs and subnet ID.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] security_group_ids: The IDs of the security groups to associate with the router network interface within the VPC.
        :param pulumi.Input[_builtins.str] subnet_id: The ID of the subnet within the VPC to associate the router network interface with.
        """
        pulumi.set(__self__, "security_group_ids", security_group_ids)
        pulumi.set(__self__, "subnet_id", subnet_id)

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The IDs of the security groups to associate with the router network interface within the VPC.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "security_group_ids", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the subnet within the VPC to associate the router network interface with.
        """
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subnet_id", value)


if not MYPY:
    class RouterOutputResourceAutomaticEncryptionKeyConfigurationArgsDict(TypedDict):
        """
        Configuration settings for automatic encryption key management, where MediaConnect handles key creation and rotation.
        """
        pass
elif False:
    RouterOutputResourceAutomaticEncryptionKeyConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterOutputResourceAutomaticEncryptionKeyConfigurationArgs:
    def __init__(__self__):
        """
        Configuration settings for automatic encryption key management, where MediaConnect handles key creation and rotation.
        """
        pass


if not MYPY:
    class RouterOutputResourceDefaultMaintenanceConfigurationArgsDict(TypedDict):
        """
        Configuration settings for default maintenance scheduling.
        """
        pass
elif False:
    RouterOutputResourceDefaultMaintenanceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterOutputResourceDefaultMaintenanceConfigurationArgs:
    def __init__(__self__):
        """
        Configuration settings for default maintenance scheduling.
        """
        pass


if not MYPY:
    class RouterOutputResourceFlowTransitEncryptionKeyConfiguration0PropertiesArgsDict(TypedDict):
        """
        Configuration settings for flow transit encryption keys.
        """
        secrets_manager: pulumi.Input['RouterOutputResourceSecretsManagerEncryptionKeyConfigurationArgsDict']
elif False:
    RouterOutputResourceFlowTransitEncryptionKeyConfiguration0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterOutputResourceFlowTransitEncryptionKeyConfiguration0PropertiesArgs:
    def __init__(__self__, *,
                 secrets_manager: pulumi.Input['RouterOutputResourceSecretsManagerEncryptionKeyConfigurationArgs']):
        """
        Configuration settings for flow transit encryption keys.
        """
        pulumi.set(__self__, "secrets_manager", secrets_manager)

    @_builtins.property
    @pulumi.getter(name="secretsManager")
    def secrets_manager(self) -> pulumi.Input['RouterOutputResourceSecretsManagerEncryptionKeyConfigurationArgs']:
        return pulumi.get(self, "secrets_manager")

    @secrets_manager.setter
    def secrets_manager(self, value: pulumi.Input['RouterOutputResourceSecretsManagerEncryptionKeyConfigurationArgs']):
        pulumi.set(self, "secrets_manager", value)


if not MYPY:
    class RouterOutputResourceFlowTransitEncryptionKeyConfiguration1PropertiesArgsDict(TypedDict):
        """
        Configuration settings for flow transit encryption keys.
        """
        automatic: pulumi.Input['RouterOutputResourceAutomaticEncryptionKeyConfigurationArgsDict']
elif False:
    RouterOutputResourceFlowTransitEncryptionKeyConfiguration1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterOutputResourceFlowTransitEncryptionKeyConfiguration1PropertiesArgs:
    def __init__(__self__, *,
                 automatic: pulumi.Input['RouterOutputResourceAutomaticEncryptionKeyConfigurationArgs']):
        """
        Configuration settings for flow transit encryption keys.
        """
        pulumi.set(__self__, "automatic", automatic)

    @_builtins.property
    @pulumi.getter
    def automatic(self) -> pulumi.Input['RouterOutputResourceAutomaticEncryptionKeyConfigurationArgs']:
        return pulumi.get(self, "automatic")

    @automatic.setter
    def automatic(self, value: pulumi.Input['RouterOutputResourceAutomaticEncryptionKeyConfigurationArgs']):
        pulumi.set(self, "automatic", value)


if not MYPY:
    class RouterOutputResourceFlowTransitEncryptionArgsDict(TypedDict):
        """
        The configuration that defines how content is encrypted during transit between the MediaConnect router and a MediaConnect flow.
        """
        encryption_key_configuration: pulumi.Input[Union['RouterOutputResourceFlowTransitEncryptionKeyConfiguration0PropertiesArgsDict', 'RouterOutputResourceFlowTransitEncryptionKeyConfiguration1PropertiesArgsDict']]
        encryption_key_type: NotRequired[pulumi.Input['RouterOutputResourceFlowTransitEncryptionKeyType']]
elif False:
    RouterOutputResourceFlowTransitEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterOutputResourceFlowTransitEncryptionArgs:
    def __init__(__self__, *,
                 encryption_key_configuration: pulumi.Input[Union['RouterOutputResourceFlowTransitEncryptionKeyConfiguration0PropertiesArgs', 'RouterOutputResourceFlowTransitEncryptionKeyConfiguration1PropertiesArgs']],
                 encryption_key_type: Optional[pulumi.Input['RouterOutputResourceFlowTransitEncryptionKeyType']] = None):
        """
        The configuration that defines how content is encrypted during transit between the MediaConnect router and a MediaConnect flow.
        """
        pulumi.set(__self__, "encryption_key_configuration", encryption_key_configuration)
        if encryption_key_type is not None:
            pulumi.set(__self__, "encryption_key_type", encryption_key_type)

    @_builtins.property
    @pulumi.getter(name="encryptionKeyConfiguration")
    def encryption_key_configuration(self) -> pulumi.Input[Union['RouterOutputResourceFlowTransitEncryptionKeyConfiguration0PropertiesArgs', 'RouterOutputResourceFlowTransitEncryptionKeyConfiguration1PropertiesArgs']]:
        return pulumi.get(self, "encryption_key_configuration")

    @encryption_key_configuration.setter
    def encryption_key_configuration(self, value: pulumi.Input[Union['RouterOutputResourceFlowTransitEncryptionKeyConfiguration0PropertiesArgs', 'RouterOutputResourceFlowTransitEncryptionKeyConfiguration1PropertiesArgs']]):
        pulumi.set(self, "encryption_key_configuration", value)

    @_builtins.property
    @pulumi.getter(name="encryptionKeyType")
    def encryption_key_type(self) -> Optional[pulumi.Input['RouterOutputResourceFlowTransitEncryptionKeyType']]:
        return pulumi.get(self, "encryption_key_type")

    @encryption_key_type.setter
    def encryption_key_type(self, value: Optional[pulumi.Input['RouterOutputResourceFlowTransitEncryptionKeyType']]):
        pulumi.set(self, "encryption_key_type", value)


if not MYPY:
    class RouterOutputResourceMaintenanceConfiguration0PropertiesArgsDict(TypedDict):
        """
        The configuration settings for maintenance operations, including preferred maintenance windows and schedules.
        """
        preferred_day_time: pulumi.Input['RouterOutputResourcePreferredDayTimeMaintenanceConfigurationArgsDict']
elif False:
    RouterOutputResourceMaintenanceConfiguration0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterOutputResourceMaintenanceConfiguration0PropertiesArgs:
    def __init__(__self__, *,
                 preferred_day_time: pulumi.Input['RouterOutputResourcePreferredDayTimeMaintenanceConfigurationArgs']):
        """
        The configuration settings for maintenance operations, including preferred maintenance windows and schedules.
        """
        pulumi.set(__self__, "preferred_day_time", preferred_day_time)

    @_builtins.property
    @pulumi.getter(name="preferredDayTime")
    def preferred_day_time(self) -> pulumi.Input['RouterOutputResourcePreferredDayTimeMaintenanceConfigurationArgs']:
        return pulumi.get(self, "preferred_day_time")

    @preferred_day_time.setter
    def preferred_day_time(self, value: pulumi.Input['RouterOutputResourcePreferredDayTimeMaintenanceConfigurationArgs']):
        pulumi.set(self, "preferred_day_time", value)


if not MYPY:
    class RouterOutputResourceMaintenanceConfiguration1PropertiesArgsDict(TypedDict):
        """
        The configuration settings for maintenance operations, including preferred maintenance windows and schedules.
        """
        default: pulumi.Input['RouterOutputResourceDefaultMaintenanceConfigurationArgsDict']
elif False:
    RouterOutputResourceMaintenanceConfiguration1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterOutputResourceMaintenanceConfiguration1PropertiesArgs:
    def __init__(__self__, *,
                 default: pulumi.Input['RouterOutputResourceDefaultMaintenanceConfigurationArgs']):
        """
        The configuration settings for maintenance operations, including preferred maintenance windows and schedules.
        """
        pulumi.set(__self__, "default", default)

    @_builtins.property
    @pulumi.getter
    def default(self) -> pulumi.Input['RouterOutputResourceDefaultMaintenanceConfigurationArgs']:
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: pulumi.Input['RouterOutputResourceDefaultMaintenanceConfigurationArgs']):
        pulumi.set(self, "default", value)


if not MYPY:
    class RouterOutputResourceMediaConnectFlowRouterOutputConfigurationArgsDict(TypedDict):
        """
        Configuration settings for connecting a router output to a MediaConnect flow source.
        """
        destination_transit_encryption: pulumi.Input['RouterOutputResourceFlowTransitEncryptionArgsDict']
        flow_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ARN of the flow to connect to this router output.
        """
        flow_source_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ARN of the flow source to connect to this router output.
        """
elif False:
    RouterOutputResourceMediaConnectFlowRouterOutputConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterOutputResourceMediaConnectFlowRouterOutputConfigurationArgs:
    def __init__(__self__, *,
                 destination_transit_encryption: pulumi.Input['RouterOutputResourceFlowTransitEncryptionArgs'],
                 flow_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 flow_source_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Configuration settings for connecting a router output to a MediaConnect flow source.
        :param pulumi.Input[_builtins.str] flow_arn: The ARN of the flow to connect to this router output.
        :param pulumi.Input[_builtins.str] flow_source_arn: The ARN of the flow source to connect to this router output.
        """
        pulumi.set(__self__, "destination_transit_encryption", destination_transit_encryption)
        if flow_arn is not None:
            pulumi.set(__self__, "flow_arn", flow_arn)
        if flow_source_arn is not None:
            pulumi.set(__self__, "flow_source_arn", flow_source_arn)

    @_builtins.property
    @pulumi.getter(name="destinationTransitEncryption")
    def destination_transit_encryption(self) -> pulumi.Input['RouterOutputResourceFlowTransitEncryptionArgs']:
        return pulumi.get(self, "destination_transit_encryption")

    @destination_transit_encryption.setter
    def destination_transit_encryption(self, value: pulumi.Input['RouterOutputResourceFlowTransitEncryptionArgs']):
        pulumi.set(self, "destination_transit_encryption", value)

    @_builtins.property
    @pulumi.getter(name="flowArn")
    def flow_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ARN of the flow to connect to this router output.
        """
        return pulumi.get(self, "flow_arn")

    @flow_arn.setter
    def flow_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "flow_arn", value)

    @_builtins.property
    @pulumi.getter(name="flowSourceArn")
    def flow_source_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ARN of the flow source to connect to this router output.
        """
        return pulumi.get(self, "flow_source_arn")

    @flow_source_arn.setter
    def flow_source_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "flow_source_arn", value)


if not MYPY:
    class RouterOutputResourceMediaLiveInputRouterOutputConfigurationArgsDict(TypedDict):
        """
        Configuration settings for connecting a router output to a MediaLive input.
        """
        destination_transit_encryption: pulumi.Input['RouterOutputResourceMediaLiveTransitEncryptionArgsDict']
        media_live_input_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ARN of the MediaLive input to connect to this router output.
        """
        media_live_pipeline_id: NotRequired[pulumi.Input['RouterOutputResourceMediaLiveInputPipelineId']]
elif False:
    RouterOutputResourceMediaLiveInputRouterOutputConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterOutputResourceMediaLiveInputRouterOutputConfigurationArgs:
    def __init__(__self__, *,
                 destination_transit_encryption: pulumi.Input['RouterOutputResourceMediaLiveTransitEncryptionArgs'],
                 media_live_input_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 media_live_pipeline_id: Optional[pulumi.Input['RouterOutputResourceMediaLiveInputPipelineId']] = None):
        """
        Configuration settings for connecting a router output to a MediaLive input.
        :param pulumi.Input[_builtins.str] media_live_input_arn: The ARN of the MediaLive input to connect to this router output.
        """
        pulumi.set(__self__, "destination_transit_encryption", destination_transit_encryption)
        if media_live_input_arn is not None:
            pulumi.set(__self__, "media_live_input_arn", media_live_input_arn)
        if media_live_pipeline_id is not None:
            pulumi.set(__self__, "media_live_pipeline_id", media_live_pipeline_id)

    @_builtins.property
    @pulumi.getter(name="destinationTransitEncryption")
    def destination_transit_encryption(self) -> pulumi.Input['RouterOutputResourceMediaLiveTransitEncryptionArgs']:
        return pulumi.get(self, "destination_transit_encryption")

    @destination_transit_encryption.setter
    def destination_transit_encryption(self, value: pulumi.Input['RouterOutputResourceMediaLiveTransitEncryptionArgs']):
        pulumi.set(self, "destination_transit_encryption", value)

    @_builtins.property
    @pulumi.getter(name="mediaLiveInputArn")
    def media_live_input_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ARN of the MediaLive input to connect to this router output.
        """
        return pulumi.get(self, "media_live_input_arn")

    @media_live_input_arn.setter
    def media_live_input_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "media_live_input_arn", value)

    @_builtins.property
    @pulumi.getter(name="mediaLivePipelineId")
    def media_live_pipeline_id(self) -> Optional[pulumi.Input['RouterOutputResourceMediaLiveInputPipelineId']]:
        return pulumi.get(self, "media_live_pipeline_id")

    @media_live_pipeline_id.setter
    def media_live_pipeline_id(self, value: Optional[pulumi.Input['RouterOutputResourceMediaLiveInputPipelineId']]):
        pulumi.set(self, "media_live_pipeline_id", value)


if not MYPY:
    class RouterOutputResourceMediaLiveTransitEncryptionKeyConfiguration0PropertiesArgsDict(TypedDict):
        """
        Configuration settings for the MediaLive transit encryption key.
        """
        secrets_manager: pulumi.Input['RouterOutputResourceSecretsManagerEncryptionKeyConfigurationArgsDict']
elif False:
    RouterOutputResourceMediaLiveTransitEncryptionKeyConfiguration0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterOutputResourceMediaLiveTransitEncryptionKeyConfiguration0PropertiesArgs:
    def __init__(__self__, *,
                 secrets_manager: pulumi.Input['RouterOutputResourceSecretsManagerEncryptionKeyConfigurationArgs']):
        """
        Configuration settings for the MediaLive transit encryption key.
        """
        pulumi.set(__self__, "secrets_manager", secrets_manager)

    @_builtins.property
    @pulumi.getter(name="secretsManager")
    def secrets_manager(self) -> pulumi.Input['RouterOutputResourceSecretsManagerEncryptionKeyConfigurationArgs']:
        return pulumi.get(self, "secrets_manager")

    @secrets_manager.setter
    def secrets_manager(self, value: pulumi.Input['RouterOutputResourceSecretsManagerEncryptionKeyConfigurationArgs']):
        pulumi.set(self, "secrets_manager", value)


if not MYPY:
    class RouterOutputResourceMediaLiveTransitEncryptionKeyConfiguration1PropertiesArgsDict(TypedDict):
        """
        Configuration settings for the MediaLive transit encryption key.
        """
        automatic: pulumi.Input['RouterOutputResourceAutomaticEncryptionKeyConfigurationArgsDict']
elif False:
    RouterOutputResourceMediaLiveTransitEncryptionKeyConfiguration1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterOutputResourceMediaLiveTransitEncryptionKeyConfiguration1PropertiesArgs:
    def __init__(__self__, *,
                 automatic: pulumi.Input['RouterOutputResourceAutomaticEncryptionKeyConfigurationArgs']):
        """
        Configuration settings for the MediaLive transit encryption key.
        """
        pulumi.set(__self__, "automatic", automatic)

    @_builtins.property
    @pulumi.getter
    def automatic(self) -> pulumi.Input['RouterOutputResourceAutomaticEncryptionKeyConfigurationArgs']:
        return pulumi.get(self, "automatic")

    @automatic.setter
    def automatic(self, value: pulumi.Input['RouterOutputResourceAutomaticEncryptionKeyConfigurationArgs']):
        pulumi.set(self, "automatic", value)


if not MYPY:
    class RouterOutputResourceMediaLiveTransitEncryptionArgsDict(TypedDict):
        """
        The encryption configuration that defines how content is encrypted during transit between MediaConnect Router and MediaLive. This configuration determines whether encryption keys are automatically managed by the service or manually managed through AWS Secrets Manager.
        """
        encryption_key_configuration: pulumi.Input[Union['RouterOutputResourceMediaLiveTransitEncryptionKeyConfiguration0PropertiesArgsDict', 'RouterOutputResourceMediaLiveTransitEncryptionKeyConfiguration1PropertiesArgsDict']]
        encryption_key_type: NotRequired[pulumi.Input['RouterOutputResourceMediaLiveTransitEncryptionKeyType']]
elif False:
    RouterOutputResourceMediaLiveTransitEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterOutputResourceMediaLiveTransitEncryptionArgs:
    def __init__(__self__, *,
                 encryption_key_configuration: pulumi.Input[Union['RouterOutputResourceMediaLiveTransitEncryptionKeyConfiguration0PropertiesArgs', 'RouterOutputResourceMediaLiveTransitEncryptionKeyConfiguration1PropertiesArgs']],
                 encryption_key_type: Optional[pulumi.Input['RouterOutputResourceMediaLiveTransitEncryptionKeyType']] = None):
        """
        The encryption configuration that defines how content is encrypted during transit between MediaConnect Router and MediaLive. This configuration determines whether encryption keys are automatically managed by the service or manually managed through AWS Secrets Manager.
        """
        pulumi.set(__self__, "encryption_key_configuration", encryption_key_configuration)
        if encryption_key_type is not None:
            pulumi.set(__self__, "encryption_key_type", encryption_key_type)

    @_builtins.property
    @pulumi.getter(name="encryptionKeyConfiguration")
    def encryption_key_configuration(self) -> pulumi.Input[Union['RouterOutputResourceMediaLiveTransitEncryptionKeyConfiguration0PropertiesArgs', 'RouterOutputResourceMediaLiveTransitEncryptionKeyConfiguration1PropertiesArgs']]:
        return pulumi.get(self, "encryption_key_configuration")

    @encryption_key_configuration.setter
    def encryption_key_configuration(self, value: pulumi.Input[Union['RouterOutputResourceMediaLiveTransitEncryptionKeyConfiguration0PropertiesArgs', 'RouterOutputResourceMediaLiveTransitEncryptionKeyConfiguration1PropertiesArgs']]):
        pulumi.set(self, "encryption_key_configuration", value)

    @_builtins.property
    @pulumi.getter(name="encryptionKeyType")
    def encryption_key_type(self) -> Optional[pulumi.Input['RouterOutputResourceMediaLiveTransitEncryptionKeyType']]:
        return pulumi.get(self, "encryption_key_type")

    @encryption_key_type.setter
    def encryption_key_type(self, value: Optional[pulumi.Input['RouterOutputResourceMediaLiveTransitEncryptionKeyType']]):
        pulumi.set(self, "encryption_key_type", value)


if not MYPY:
    class RouterOutputResourcePreferredDayTimeMaintenanceConfigurationArgsDict(TypedDict):
        """
        Configuration for preferred day and time maintenance settings.
        """
        day: pulumi.Input['RouterOutputResourceDay']
        time: pulumi.Input[_builtins.str]
        """
        The preferred time for maintenance operations.
        """
elif False:
    RouterOutputResourcePreferredDayTimeMaintenanceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterOutputResourcePreferredDayTimeMaintenanceConfigurationArgs:
    def __init__(__self__, *,
                 day: pulumi.Input['RouterOutputResourceDay'],
                 time: pulumi.Input[_builtins.str]):
        """
        Configuration for preferred day and time maintenance settings.
        :param pulumi.Input[_builtins.str] time: The preferred time for maintenance operations.
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "time", time)

    @_builtins.property
    @pulumi.getter
    def day(self) -> pulumi.Input['RouterOutputResourceDay']:
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: pulumi.Input['RouterOutputResourceDay']):
        pulumi.set(self, "day", value)

    @_builtins.property
    @pulumi.getter
    def time(self) -> pulumi.Input[_builtins.str]:
        """
        The preferred time for maintenance operations.
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "time", value)


if not MYPY:
    class RouterOutputResourceRistRouterOutputConfigurationArgsDict(TypedDict):
        """
        The configuration settings for a router output using the RIST (Reliable Internet Stream Transport) protocol, including the destination address and port.
        """
        destination_address: pulumi.Input[_builtins.str]
        """
        The destination IP address for the RIST protocol in the router output configuration.
        """
        destination_port: pulumi.Input[_builtins.int]
        """
        The destination port number for the RIST protocol in the router output configuration.
        """
elif False:
    RouterOutputResourceRistRouterOutputConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterOutputResourceRistRouterOutputConfigurationArgs:
    def __init__(__self__, *,
                 destination_address: pulumi.Input[_builtins.str],
                 destination_port: pulumi.Input[_builtins.int]):
        """
        The configuration settings for a router output using the RIST (Reliable Internet Stream Transport) protocol, including the destination address and port.
        :param pulumi.Input[_builtins.str] destination_address: The destination IP address for the RIST protocol in the router output configuration.
        :param pulumi.Input[_builtins.int] destination_port: The destination port number for the RIST protocol in the router output configuration.
        """
        pulumi.set(__self__, "destination_address", destination_address)
        pulumi.set(__self__, "destination_port", destination_port)

    @_builtins.property
    @pulumi.getter(name="destinationAddress")
    def destination_address(self) -> pulumi.Input[_builtins.str]:
        """
        The destination IP address for the RIST protocol in the router output configuration.
        """
        return pulumi.get(self, "destination_address")

    @destination_address.setter
    def destination_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "destination_address", value)

    @_builtins.property
    @pulumi.getter(name="destinationPort")
    def destination_port(self) -> pulumi.Input[_builtins.int]:
        """
        The destination port number for the RIST protocol in the router output configuration.
        """
        return pulumi.get(self, "destination_port")

    @destination_port.setter
    def destination_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "destination_port", value)


if not MYPY:
    class RouterOutputResourceRouterOutputConfiguration0PropertiesArgsDict(TypedDict):
        """
        The configuration settings for a router output.
        """
        standard: pulumi.Input['RouterOutputResourceStandardRouterOutputConfigurationArgsDict']
elif False:
    RouterOutputResourceRouterOutputConfiguration0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterOutputResourceRouterOutputConfiguration0PropertiesArgs:
    def __init__(__self__, *,
                 standard: pulumi.Input['RouterOutputResourceStandardRouterOutputConfigurationArgs']):
        """
        The configuration settings for a router output.
        """
        pulumi.set(__self__, "standard", standard)

    @_builtins.property
    @pulumi.getter
    def standard(self) -> pulumi.Input['RouterOutputResourceStandardRouterOutputConfigurationArgs']:
        return pulumi.get(self, "standard")

    @standard.setter
    def standard(self, value: pulumi.Input['RouterOutputResourceStandardRouterOutputConfigurationArgs']):
        pulumi.set(self, "standard", value)


if not MYPY:
    class RouterOutputResourceRouterOutputConfiguration1PropertiesArgsDict(TypedDict):
        """
        The configuration settings for a router output.
        """
        media_connect_flow: pulumi.Input['RouterOutputResourceMediaConnectFlowRouterOutputConfigurationArgsDict']
elif False:
    RouterOutputResourceRouterOutputConfiguration1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterOutputResourceRouterOutputConfiguration1PropertiesArgs:
    def __init__(__self__, *,
                 media_connect_flow: pulumi.Input['RouterOutputResourceMediaConnectFlowRouterOutputConfigurationArgs']):
        """
        The configuration settings for a router output.
        """
        pulumi.set(__self__, "media_connect_flow", media_connect_flow)

    @_builtins.property
    @pulumi.getter(name="mediaConnectFlow")
    def media_connect_flow(self) -> pulumi.Input['RouterOutputResourceMediaConnectFlowRouterOutputConfigurationArgs']:
        return pulumi.get(self, "media_connect_flow")

    @media_connect_flow.setter
    def media_connect_flow(self, value: pulumi.Input['RouterOutputResourceMediaConnectFlowRouterOutputConfigurationArgs']):
        pulumi.set(self, "media_connect_flow", value)


if not MYPY:
    class RouterOutputResourceRouterOutputConfiguration2PropertiesArgsDict(TypedDict):
        """
        The configuration settings for a router output.
        """
        media_live_input: pulumi.Input['RouterOutputResourceMediaLiveInputRouterOutputConfigurationArgsDict']
elif False:
    RouterOutputResourceRouterOutputConfiguration2PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterOutputResourceRouterOutputConfiguration2PropertiesArgs:
    def __init__(__self__, *,
                 media_live_input: pulumi.Input['RouterOutputResourceMediaLiveInputRouterOutputConfigurationArgs']):
        """
        The configuration settings for a router output.
        """
        pulumi.set(__self__, "media_live_input", media_live_input)

    @_builtins.property
    @pulumi.getter(name="mediaLiveInput")
    def media_live_input(self) -> pulumi.Input['RouterOutputResourceMediaLiveInputRouterOutputConfigurationArgs']:
        return pulumi.get(self, "media_live_input")

    @media_live_input.setter
    def media_live_input(self, value: pulumi.Input['RouterOutputResourceMediaLiveInputRouterOutputConfigurationArgs']):
        pulumi.set(self, "media_live_input", value)


if not MYPY:
    class RouterOutputResourceRouterOutputProtocolConfiguration0PropertiesArgsDict(TypedDict):
        """
        The protocol configuration settings for a router output.
        """
        rtp: pulumi.Input['RouterOutputResourceRtpRouterOutputConfigurationArgsDict']
elif False:
    RouterOutputResourceRouterOutputProtocolConfiguration0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterOutputResourceRouterOutputProtocolConfiguration0PropertiesArgs:
    def __init__(__self__, *,
                 rtp: pulumi.Input['RouterOutputResourceRtpRouterOutputConfigurationArgs']):
        """
        The protocol configuration settings for a router output.
        """
        pulumi.set(__self__, "rtp", rtp)

    @_builtins.property
    @pulumi.getter
    def rtp(self) -> pulumi.Input['RouterOutputResourceRtpRouterOutputConfigurationArgs']:
        return pulumi.get(self, "rtp")

    @rtp.setter
    def rtp(self, value: pulumi.Input['RouterOutputResourceRtpRouterOutputConfigurationArgs']):
        pulumi.set(self, "rtp", value)


if not MYPY:
    class RouterOutputResourceRouterOutputProtocolConfiguration1PropertiesArgsDict(TypedDict):
        """
        The protocol configuration settings for a router output.
        """
        rist: pulumi.Input['RouterOutputResourceRistRouterOutputConfigurationArgsDict']
elif False:
    RouterOutputResourceRouterOutputProtocolConfiguration1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterOutputResourceRouterOutputProtocolConfiguration1PropertiesArgs:
    def __init__(__self__, *,
                 rist: pulumi.Input['RouterOutputResourceRistRouterOutputConfigurationArgs']):
        """
        The protocol configuration settings for a router output.
        """
        pulumi.set(__self__, "rist", rist)

    @_builtins.property
    @pulumi.getter
    def rist(self) -> pulumi.Input['RouterOutputResourceRistRouterOutputConfigurationArgs']:
        return pulumi.get(self, "rist")

    @rist.setter
    def rist(self, value: pulumi.Input['RouterOutputResourceRistRouterOutputConfigurationArgs']):
        pulumi.set(self, "rist", value)


if not MYPY:
    class RouterOutputResourceRouterOutputProtocolConfiguration2PropertiesArgsDict(TypedDict):
        """
        The protocol configuration settings for a router output.
        """
        srt_listener: pulumi.Input['RouterOutputResourceSrtListenerRouterOutputConfigurationArgsDict']
elif False:
    RouterOutputResourceRouterOutputProtocolConfiguration2PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterOutputResourceRouterOutputProtocolConfiguration2PropertiesArgs:
    def __init__(__self__, *,
                 srt_listener: pulumi.Input['RouterOutputResourceSrtListenerRouterOutputConfigurationArgs']):
        """
        The protocol configuration settings for a router output.
        """
        pulumi.set(__self__, "srt_listener", srt_listener)

    @_builtins.property
    @pulumi.getter(name="srtListener")
    def srt_listener(self) -> pulumi.Input['RouterOutputResourceSrtListenerRouterOutputConfigurationArgs']:
        return pulumi.get(self, "srt_listener")

    @srt_listener.setter
    def srt_listener(self, value: pulumi.Input['RouterOutputResourceSrtListenerRouterOutputConfigurationArgs']):
        pulumi.set(self, "srt_listener", value)


if not MYPY:
    class RouterOutputResourceRouterOutputProtocolConfiguration3PropertiesArgsDict(TypedDict):
        """
        The protocol configuration settings for a router output.
        """
        srt_caller: pulumi.Input['RouterOutputResourceSrtCallerRouterOutputConfigurationArgsDict']
elif False:
    RouterOutputResourceRouterOutputProtocolConfiguration3PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterOutputResourceRouterOutputProtocolConfiguration3PropertiesArgs:
    def __init__(__self__, *,
                 srt_caller: pulumi.Input['RouterOutputResourceSrtCallerRouterOutputConfigurationArgs']):
        """
        The protocol configuration settings for a router output.
        """
        pulumi.set(__self__, "srt_caller", srt_caller)

    @_builtins.property
    @pulumi.getter(name="srtCaller")
    def srt_caller(self) -> pulumi.Input['RouterOutputResourceSrtCallerRouterOutputConfigurationArgs']:
        return pulumi.get(self, "srt_caller")

    @srt_caller.setter
    def srt_caller(self, value: pulumi.Input['RouterOutputResourceSrtCallerRouterOutputConfigurationArgs']):
        pulumi.set(self, "srt_caller", value)


if not MYPY:
    class RouterOutputResourceRtpRouterOutputConfigurationArgsDict(TypedDict):
        """
        The configuration settings for a router output using the RTP (Real-Time Transport Protocol) protocol, including the destination address and port, and forward error correction state.
        """
        destination_address: pulumi.Input[_builtins.str]
        """
        The destination IP address for the RTP protocol in the router output configuration.
        """
        destination_port: pulumi.Input[_builtins.int]
        """
        The destination port number for the RTP protocol in the router output configuration.
        """
        forward_error_correction: NotRequired[pulumi.Input['RouterOutputResourceForwardErrorCorrectionState']]
elif False:
    RouterOutputResourceRtpRouterOutputConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterOutputResourceRtpRouterOutputConfigurationArgs:
    def __init__(__self__, *,
                 destination_address: pulumi.Input[_builtins.str],
                 destination_port: pulumi.Input[_builtins.int],
                 forward_error_correction: Optional[pulumi.Input['RouterOutputResourceForwardErrorCorrectionState']] = None):
        """
        The configuration settings for a router output using the RTP (Real-Time Transport Protocol) protocol, including the destination address and port, and forward error correction state.
        :param pulumi.Input[_builtins.str] destination_address: The destination IP address for the RTP protocol in the router output configuration.
        :param pulumi.Input[_builtins.int] destination_port: The destination port number for the RTP protocol in the router output configuration.
        """
        pulumi.set(__self__, "destination_address", destination_address)
        pulumi.set(__self__, "destination_port", destination_port)
        if forward_error_correction is not None:
            pulumi.set(__self__, "forward_error_correction", forward_error_correction)

    @_builtins.property
    @pulumi.getter(name="destinationAddress")
    def destination_address(self) -> pulumi.Input[_builtins.str]:
        """
        The destination IP address for the RTP protocol in the router output configuration.
        """
        return pulumi.get(self, "destination_address")

    @destination_address.setter
    def destination_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "destination_address", value)

    @_builtins.property
    @pulumi.getter(name="destinationPort")
    def destination_port(self) -> pulumi.Input[_builtins.int]:
        """
        The destination port number for the RTP protocol in the router output configuration.
        """
        return pulumi.get(self, "destination_port")

    @destination_port.setter
    def destination_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "destination_port", value)

    @_builtins.property
    @pulumi.getter(name="forwardErrorCorrection")
    def forward_error_correction(self) -> Optional[pulumi.Input['RouterOutputResourceForwardErrorCorrectionState']]:
        return pulumi.get(self, "forward_error_correction")

    @forward_error_correction.setter
    def forward_error_correction(self, value: Optional[pulumi.Input['RouterOutputResourceForwardErrorCorrectionState']]):
        pulumi.set(self, "forward_error_correction", value)


if not MYPY:
    class RouterOutputResourceSecretsManagerEncryptionKeyConfigurationArgsDict(TypedDict):
        """
        The configuration settings for transit encryption using AWS Secrets Manager, including the secret ARN and role ARN.
        """
        role_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the IAM role assumed by MediaConnect to access the AWS Secrets Manager secret.
        """
        secret_arn: pulumi.Input[_builtins.str]
        """
        The ARN of the AWS Secrets Manager secret used for transit encryption.
        """
elif False:
    RouterOutputResourceSecretsManagerEncryptionKeyConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterOutputResourceSecretsManagerEncryptionKeyConfigurationArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[_builtins.str],
                 secret_arn: pulumi.Input[_builtins.str]):
        """
        The configuration settings for transit encryption using AWS Secrets Manager, including the secret ARN and role ARN.
        :param pulumi.Input[_builtins.str] role_arn: The ARN of the IAM role assumed by MediaConnect to access the AWS Secrets Manager secret.
        :param pulumi.Input[_builtins.str] secret_arn: The ARN of the AWS Secrets Manager secret used for transit encryption.
        """
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "secret_arn", secret_arn)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the IAM role assumed by MediaConnect to access the AWS Secrets Manager secret.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="secretArn")
    def secret_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The ARN of the AWS Secrets Manager secret used for transit encryption.
        """
        return pulumi.get(self, "secret_arn")

    @secret_arn.setter
    def secret_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_arn", value)


if not MYPY:
    class RouterOutputResourceSrtCallerRouterOutputConfigurationArgsDict(TypedDict):
        """
        The configuration settings for a router output using the SRT (Secure Reliable Transport) protocol in caller mode, including the destination address and port, minimum latency, stream ID, and encryption key configuration.
        """
        destination_address: pulumi.Input[_builtins.str]
        """
        The destination IP address for the SRT protocol in caller mode.
        """
        destination_port: pulumi.Input[_builtins.int]
        """
        The destination port number for the SRT protocol in caller mode.
        """
        minimum_latency_milliseconds: pulumi.Input[_builtins.int]
        """
        The minimum latency in milliseconds for the SRT protocol in caller mode.
        """
        encryption_configuration: NotRequired[pulumi.Input['RouterOutputResourceSrtEncryptionConfigurationArgsDict']]
        stream_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The stream ID for the SRT protocol in caller mode.
        """
elif False:
    RouterOutputResourceSrtCallerRouterOutputConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterOutputResourceSrtCallerRouterOutputConfigurationArgs:
    def __init__(__self__, *,
                 destination_address: pulumi.Input[_builtins.str],
                 destination_port: pulumi.Input[_builtins.int],
                 minimum_latency_milliseconds: pulumi.Input[_builtins.int],
                 encryption_configuration: Optional[pulumi.Input['RouterOutputResourceSrtEncryptionConfigurationArgs']] = None,
                 stream_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        The configuration settings for a router output using the SRT (Secure Reliable Transport) protocol in caller mode, including the destination address and port, minimum latency, stream ID, and encryption key configuration.
        :param pulumi.Input[_builtins.str] destination_address: The destination IP address for the SRT protocol in caller mode.
        :param pulumi.Input[_builtins.int] destination_port: The destination port number for the SRT protocol in caller mode.
        :param pulumi.Input[_builtins.int] minimum_latency_milliseconds: The minimum latency in milliseconds for the SRT protocol in caller mode.
        :param pulumi.Input[_builtins.str] stream_id: The stream ID for the SRT protocol in caller mode.
        """
        pulumi.set(__self__, "destination_address", destination_address)
        pulumi.set(__self__, "destination_port", destination_port)
        pulumi.set(__self__, "minimum_latency_milliseconds", minimum_latency_milliseconds)
        if encryption_configuration is not None:
            pulumi.set(__self__, "encryption_configuration", encryption_configuration)
        if stream_id is not None:
            pulumi.set(__self__, "stream_id", stream_id)

    @_builtins.property
    @pulumi.getter(name="destinationAddress")
    def destination_address(self) -> pulumi.Input[_builtins.str]:
        """
        The destination IP address for the SRT protocol in caller mode.
        """
        return pulumi.get(self, "destination_address")

    @destination_address.setter
    def destination_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "destination_address", value)

    @_builtins.property
    @pulumi.getter(name="destinationPort")
    def destination_port(self) -> pulumi.Input[_builtins.int]:
        """
        The destination port number for the SRT protocol in caller mode.
        """
        return pulumi.get(self, "destination_port")

    @destination_port.setter
    def destination_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "destination_port", value)

    @_builtins.property
    @pulumi.getter(name="minimumLatencyMilliseconds")
    def minimum_latency_milliseconds(self) -> pulumi.Input[_builtins.int]:
        """
        The minimum latency in milliseconds for the SRT protocol in caller mode.
        """
        return pulumi.get(self, "minimum_latency_milliseconds")

    @minimum_latency_milliseconds.setter
    def minimum_latency_milliseconds(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "minimum_latency_milliseconds", value)

    @_builtins.property
    @pulumi.getter(name="encryptionConfiguration")
    def encryption_configuration(self) -> Optional[pulumi.Input['RouterOutputResourceSrtEncryptionConfigurationArgs']]:
        return pulumi.get(self, "encryption_configuration")

    @encryption_configuration.setter
    def encryption_configuration(self, value: Optional[pulumi.Input['RouterOutputResourceSrtEncryptionConfigurationArgs']]):
        pulumi.set(self, "encryption_configuration", value)

    @_builtins.property
    @pulumi.getter(name="streamId")
    def stream_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The stream ID for the SRT protocol in caller mode.
        """
        return pulumi.get(self, "stream_id")

    @stream_id.setter
    def stream_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "stream_id", value)


if not MYPY:
    class RouterOutputResourceSrtEncryptionConfigurationArgsDict(TypedDict):
        """
        Contains the configuration settings for encrypting SRT streams, including the encryption key details and encryption parameters.
        """
        encryption_key: pulumi.Input['RouterOutputResourceSecretsManagerEncryptionKeyConfigurationArgsDict']
elif False:
    RouterOutputResourceSrtEncryptionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterOutputResourceSrtEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 encryption_key: pulumi.Input['RouterOutputResourceSecretsManagerEncryptionKeyConfigurationArgs']):
        """
        Contains the configuration settings for encrypting SRT streams, including the encryption key details and encryption parameters.
        """
        pulumi.set(__self__, "encryption_key", encryption_key)

    @_builtins.property
    @pulumi.getter(name="encryptionKey")
    def encryption_key(self) -> pulumi.Input['RouterOutputResourceSecretsManagerEncryptionKeyConfigurationArgs']:
        return pulumi.get(self, "encryption_key")

    @encryption_key.setter
    def encryption_key(self, value: pulumi.Input['RouterOutputResourceSecretsManagerEncryptionKeyConfigurationArgs']):
        pulumi.set(self, "encryption_key", value)


if not MYPY:
    class RouterOutputResourceSrtListenerRouterOutputConfigurationArgsDict(TypedDict):
        """
        The configuration settings for a router output using the SRT (Secure Reliable Transport) protocol in listener mode, including the port, minimum latency, and encryption key configuration.
        """
        minimum_latency_milliseconds: pulumi.Input[_builtins.int]
        """
        The minimum latency in milliseconds for the SRT protocol in listener mode.
        """
        port: pulumi.Input[_builtins.int]
        """
        The port number for the SRT protocol in listener mode.
        """
        encryption_configuration: NotRequired[pulumi.Input['RouterOutputResourceSrtEncryptionConfigurationArgsDict']]
elif False:
    RouterOutputResourceSrtListenerRouterOutputConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterOutputResourceSrtListenerRouterOutputConfigurationArgs:
    def __init__(__self__, *,
                 minimum_latency_milliseconds: pulumi.Input[_builtins.int],
                 port: pulumi.Input[_builtins.int],
                 encryption_configuration: Optional[pulumi.Input['RouterOutputResourceSrtEncryptionConfigurationArgs']] = None):
        """
        The configuration settings for a router output using the SRT (Secure Reliable Transport) protocol in listener mode, including the port, minimum latency, and encryption key configuration.
        :param pulumi.Input[_builtins.int] minimum_latency_milliseconds: The minimum latency in milliseconds for the SRT protocol in listener mode.
        :param pulumi.Input[_builtins.int] port: The port number for the SRT protocol in listener mode.
        """
        pulumi.set(__self__, "minimum_latency_milliseconds", minimum_latency_milliseconds)
        pulumi.set(__self__, "port", port)
        if encryption_configuration is not None:
            pulumi.set(__self__, "encryption_configuration", encryption_configuration)

    @_builtins.property
    @pulumi.getter(name="minimumLatencyMilliseconds")
    def minimum_latency_milliseconds(self) -> pulumi.Input[_builtins.int]:
        """
        The minimum latency in milliseconds for the SRT protocol in listener mode.
        """
        return pulumi.get(self, "minimum_latency_milliseconds")

    @minimum_latency_milliseconds.setter
    def minimum_latency_milliseconds(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "minimum_latency_milliseconds", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        The port number for the SRT protocol in listener mode.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="encryptionConfiguration")
    def encryption_configuration(self) -> Optional[pulumi.Input['RouterOutputResourceSrtEncryptionConfigurationArgs']]:
        return pulumi.get(self, "encryption_configuration")

    @encryption_configuration.setter
    def encryption_configuration(self, value: Optional[pulumi.Input['RouterOutputResourceSrtEncryptionConfigurationArgs']]):
        pulumi.set(self, "encryption_configuration", value)


if not MYPY:
    class RouterOutputResourceStandardRouterOutputConfigurationArgsDict(TypedDict):
        """
        The configuration settings for a standard router output, including the protocol, protocol-specific configuration, network interface, and availability zone.
        """
        network_interface_arn: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name (ARN) of the network interface associated with the standard router output.
        """
        protocol_configuration: pulumi.Input[Union['RouterOutputResourceRouterOutputProtocolConfiguration0PropertiesArgsDict', 'RouterOutputResourceRouterOutputProtocolConfiguration1PropertiesArgsDict', 'RouterOutputResourceRouterOutputProtocolConfiguration2PropertiesArgsDict', 'RouterOutputResourceRouterOutputProtocolConfiguration3PropertiesArgsDict']]
        protocol: NotRequired[pulumi.Input['RouterOutputResourceRouterOutputProtocol']]
elif False:
    RouterOutputResourceStandardRouterOutputConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RouterOutputResourceStandardRouterOutputConfigurationArgs:
    def __init__(__self__, *,
                 network_interface_arn: pulumi.Input[_builtins.str],
                 protocol_configuration: pulumi.Input[Union['RouterOutputResourceRouterOutputProtocolConfiguration0PropertiesArgs', 'RouterOutputResourceRouterOutputProtocolConfiguration1PropertiesArgs', 'RouterOutputResourceRouterOutputProtocolConfiguration2PropertiesArgs', 'RouterOutputResourceRouterOutputProtocolConfiguration3PropertiesArgs']],
                 protocol: Optional[pulumi.Input['RouterOutputResourceRouterOutputProtocol']] = None):
        """
        The configuration settings for a standard router output, including the protocol, protocol-specific configuration, network interface, and availability zone.
        :param pulumi.Input[_builtins.str] network_interface_arn: The Amazon Resource Name (ARN) of the network interface associated with the standard router output.
        """
        pulumi.set(__self__, "network_interface_arn", network_interface_arn)
        pulumi.set(__self__, "protocol_configuration", protocol_configuration)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter(name="networkInterfaceArn")
    def network_interface_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the network interface associated with the standard router output.
        """
        return pulumi.get(self, "network_interface_arn")

    @network_interface_arn.setter
    def network_interface_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "network_interface_arn", value)

    @_builtins.property
    @pulumi.getter(name="protocolConfiguration")
    def protocol_configuration(self) -> pulumi.Input[Union['RouterOutputResourceRouterOutputProtocolConfiguration0PropertiesArgs', 'RouterOutputResourceRouterOutputProtocolConfiguration1PropertiesArgs', 'RouterOutputResourceRouterOutputProtocolConfiguration2PropertiesArgs', 'RouterOutputResourceRouterOutputProtocolConfiguration3PropertiesArgs']]:
        return pulumi.get(self, "protocol_configuration")

    @protocol_configuration.setter
    def protocol_configuration(self, value: pulumi.Input[Union['RouterOutputResourceRouterOutputProtocolConfiguration0PropertiesArgs', 'RouterOutputResourceRouterOutputProtocolConfiguration1PropertiesArgs', 'RouterOutputResourceRouterOutputProtocolConfiguration2PropertiesArgs', 'RouterOutputResourceRouterOutputProtocolConfiguration3PropertiesArgs']]):
        pulumi.set(self, "protocol_configuration", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input['RouterOutputResourceRouterOutputProtocol']]:
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input['RouterOutputResourceRouterOutputProtocol']]):
        pulumi.set(self, "protocol", value)


