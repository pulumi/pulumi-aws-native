# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'CampaignCollectionScheme0Properties',
    'CampaignCollectionScheme1Properties',
    'CampaignConditionBasedCollectionScheme',
    'CampaignDataDestinationConfig0Properties',
    'CampaignDataDestinationConfig1Properties',
    'CampaignS3Config',
    'CampaignSignalInformation',
    'CampaignTag',
    'CampaignTimeBasedCollectionScheme',
    'CampaignTimestreamConfig',
    'DecoderManifestCanInterface',
    'DecoderManifestCanNetworkInterface',
    'DecoderManifestCanSignal',
    'DecoderManifestCanSignalDecoder',
    'DecoderManifestObdInterface',
    'DecoderManifestObdNetworkInterface',
    'DecoderManifestObdSignal',
    'DecoderManifestObdSignalDecoder',
    'DecoderManifestTag',
    'FleetTag',
    'ModelManifestTag',
    'SignalCatalogActuator',
    'SignalCatalogAttribute',
    'SignalCatalogBranch',
    'SignalCatalogNode0Properties',
    'SignalCatalogNode1Properties',
    'SignalCatalogNode2Properties',
    'SignalCatalogNode3Properties',
    'SignalCatalogNodeCounts',
    'SignalCatalogSensor',
    'SignalCatalogTag',
    'VehicleTag',
    'VehicleattributesMap',
]

@pulumi.output_type
class CampaignCollectionScheme0Properties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeBasedCollectionScheme":
            suggest = "time_based_collection_scheme"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CampaignCollectionScheme0Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CampaignCollectionScheme0Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CampaignCollectionScheme0Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 time_based_collection_scheme: 'outputs.CampaignTimeBasedCollectionScheme'):
        CampaignCollectionScheme0Properties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            time_based_collection_scheme=time_based_collection_scheme,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             time_based_collection_scheme: Optional['outputs.CampaignTimeBasedCollectionScheme'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if time_based_collection_scheme is None and 'timeBasedCollectionScheme' in kwargs:
            time_based_collection_scheme = kwargs['timeBasedCollectionScheme']
        if time_based_collection_scheme is None:
            raise TypeError("Missing 'time_based_collection_scheme' argument")

        _setter("time_based_collection_scheme", time_based_collection_scheme)

    @property
    @pulumi.getter(name="timeBasedCollectionScheme")
    def time_based_collection_scheme(self) -> 'outputs.CampaignTimeBasedCollectionScheme':
        return pulumi.get(self, "time_based_collection_scheme")


@pulumi.output_type
class CampaignCollectionScheme1Properties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionBasedCollectionScheme":
            suggest = "condition_based_collection_scheme"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CampaignCollectionScheme1Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CampaignCollectionScheme1Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CampaignCollectionScheme1Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition_based_collection_scheme: 'outputs.CampaignConditionBasedCollectionScheme'):
        CampaignCollectionScheme1Properties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            condition_based_collection_scheme=condition_based_collection_scheme,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             condition_based_collection_scheme: Optional['outputs.CampaignConditionBasedCollectionScheme'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if condition_based_collection_scheme is None and 'conditionBasedCollectionScheme' in kwargs:
            condition_based_collection_scheme = kwargs['conditionBasedCollectionScheme']
        if condition_based_collection_scheme is None:
            raise TypeError("Missing 'condition_based_collection_scheme' argument")

        _setter("condition_based_collection_scheme", condition_based_collection_scheme)

    @property
    @pulumi.getter(name="conditionBasedCollectionScheme")
    def condition_based_collection_scheme(self) -> 'outputs.CampaignConditionBasedCollectionScheme':
        return pulumi.get(self, "condition_based_collection_scheme")


@pulumi.output_type
class CampaignConditionBasedCollectionScheme(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionLanguageVersion":
            suggest = "condition_language_version"
        elif key == "minimumTriggerIntervalMs":
            suggest = "minimum_trigger_interval_ms"
        elif key == "triggerMode":
            suggest = "trigger_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CampaignConditionBasedCollectionScheme. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CampaignConditionBasedCollectionScheme.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CampaignConditionBasedCollectionScheme.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expression: str,
                 condition_language_version: Optional[int] = None,
                 minimum_trigger_interval_ms: Optional[float] = None,
                 trigger_mode: Optional['CampaignTriggerMode'] = None):
        CampaignConditionBasedCollectionScheme._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expression=expression,
            condition_language_version=condition_language_version,
            minimum_trigger_interval_ms=minimum_trigger_interval_ms,
            trigger_mode=trigger_mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expression: Optional[str] = None,
             condition_language_version: Optional[int] = None,
             minimum_trigger_interval_ms: Optional[float] = None,
             trigger_mode: Optional['CampaignTriggerMode'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if expression is None:
            raise TypeError("Missing 'expression' argument")
        if condition_language_version is None and 'conditionLanguageVersion' in kwargs:
            condition_language_version = kwargs['conditionLanguageVersion']
        if minimum_trigger_interval_ms is None and 'minimumTriggerIntervalMs' in kwargs:
            minimum_trigger_interval_ms = kwargs['minimumTriggerIntervalMs']
        if trigger_mode is None and 'triggerMode' in kwargs:
            trigger_mode = kwargs['triggerMode']

        _setter("expression", expression)
        if condition_language_version is not None:
            _setter("condition_language_version", condition_language_version)
        if minimum_trigger_interval_ms is not None:
            _setter("minimum_trigger_interval_ms", minimum_trigger_interval_ms)
        if trigger_mode is not None:
            _setter("trigger_mode", trigger_mode)

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter(name="conditionLanguageVersion")
    def condition_language_version(self) -> Optional[int]:
        return pulumi.get(self, "condition_language_version")

    @property
    @pulumi.getter(name="minimumTriggerIntervalMs")
    def minimum_trigger_interval_ms(self) -> Optional[float]:
        return pulumi.get(self, "minimum_trigger_interval_ms")

    @property
    @pulumi.getter(name="triggerMode")
    def trigger_mode(self) -> Optional['CampaignTriggerMode']:
        return pulumi.get(self, "trigger_mode")


@pulumi.output_type
class CampaignDataDestinationConfig0Properties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "s3Config":
            suggest = "s3_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CampaignDataDestinationConfig0Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CampaignDataDestinationConfig0Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CampaignDataDestinationConfig0Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 s3_config: 'outputs.CampaignS3Config'):
        CampaignDataDestinationConfig0Properties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            s3_config=s3_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             s3_config: Optional['outputs.CampaignS3Config'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if s3_config is None and 's3Config' in kwargs:
            s3_config = kwargs['s3Config']
        if s3_config is None:
            raise TypeError("Missing 's3_config' argument")

        _setter("s3_config", s3_config)

    @property
    @pulumi.getter(name="s3Config")
    def s3_config(self) -> 'outputs.CampaignS3Config':
        return pulumi.get(self, "s3_config")


@pulumi.output_type
class CampaignDataDestinationConfig1Properties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timestreamConfig":
            suggest = "timestream_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CampaignDataDestinationConfig1Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CampaignDataDestinationConfig1Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CampaignDataDestinationConfig1Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 timestream_config: 'outputs.CampaignTimestreamConfig'):
        CampaignDataDestinationConfig1Properties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            timestream_config=timestream_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             timestream_config: Optional['outputs.CampaignTimestreamConfig'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if timestream_config is None and 'timestreamConfig' in kwargs:
            timestream_config = kwargs['timestreamConfig']
        if timestream_config is None:
            raise TypeError("Missing 'timestream_config' argument")

        _setter("timestream_config", timestream_config)

    @property
    @pulumi.getter(name="timestreamConfig")
    def timestream_config(self) -> 'outputs.CampaignTimestreamConfig':
        return pulumi.get(self, "timestream_config")


@pulumi.output_type
class CampaignS3Config(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketArn":
            suggest = "bucket_arn"
        elif key == "dataFormat":
            suggest = "data_format"
        elif key == "storageCompressionFormat":
            suggest = "storage_compression_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CampaignS3Config. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CampaignS3Config.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CampaignS3Config.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_arn: str,
                 data_format: Optional['CampaignDataFormat'] = None,
                 prefix: Optional[str] = None,
                 storage_compression_format: Optional['CampaignStorageCompressionFormat'] = None):
        CampaignS3Config._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket_arn=bucket_arn,
            data_format=data_format,
            prefix=prefix,
            storage_compression_format=storage_compression_format,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket_arn: Optional[str] = None,
             data_format: Optional['CampaignDataFormat'] = None,
             prefix: Optional[str] = None,
             storage_compression_format: Optional['CampaignStorageCompressionFormat'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bucket_arn is None and 'bucketArn' in kwargs:
            bucket_arn = kwargs['bucketArn']
        if bucket_arn is None:
            raise TypeError("Missing 'bucket_arn' argument")
        if data_format is None and 'dataFormat' in kwargs:
            data_format = kwargs['dataFormat']
        if storage_compression_format is None and 'storageCompressionFormat' in kwargs:
            storage_compression_format = kwargs['storageCompressionFormat']

        _setter("bucket_arn", bucket_arn)
        if data_format is not None:
            _setter("data_format", data_format)
        if prefix is not None:
            _setter("prefix", prefix)
        if storage_compression_format is not None:
            _setter("storage_compression_format", storage_compression_format)

    @property
    @pulumi.getter(name="bucketArn")
    def bucket_arn(self) -> str:
        return pulumi.get(self, "bucket_arn")

    @property
    @pulumi.getter(name="dataFormat")
    def data_format(self) -> Optional['CampaignDataFormat']:
        return pulumi.get(self, "data_format")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter(name="storageCompressionFormat")
    def storage_compression_format(self) -> Optional['CampaignStorageCompressionFormat']:
        return pulumi.get(self, "storage_compression_format")


@pulumi.output_type
class CampaignSignalInformation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSampleCount":
            suggest = "max_sample_count"
        elif key == "minimumSamplingIntervalMs":
            suggest = "minimum_sampling_interval_ms"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CampaignSignalInformation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CampaignSignalInformation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CampaignSignalInformation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 max_sample_count: Optional[float] = None,
                 minimum_sampling_interval_ms: Optional[float] = None):
        CampaignSignalInformation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            max_sample_count=max_sample_count,
            minimum_sampling_interval_ms=minimum_sampling_interval_ms,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             max_sample_count: Optional[float] = None,
             minimum_sampling_interval_ms: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if max_sample_count is None and 'maxSampleCount' in kwargs:
            max_sample_count = kwargs['maxSampleCount']
        if minimum_sampling_interval_ms is None and 'minimumSamplingIntervalMs' in kwargs:
            minimum_sampling_interval_ms = kwargs['minimumSamplingIntervalMs']

        _setter("name", name)
        if max_sample_count is not None:
            _setter("max_sample_count", max_sample_count)
        if minimum_sampling_interval_ms is not None:
            _setter("minimum_sampling_interval_ms", minimum_sampling_interval_ms)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="maxSampleCount")
    def max_sample_count(self) -> Optional[float]:
        return pulumi.get(self, "max_sample_count")

    @property
    @pulumi.getter(name="minimumSamplingIntervalMs")
    def minimum_sampling_interval_ms(self) -> Optional[float]:
        return pulumi.get(self, "minimum_sampling_interval_ms")


@pulumi.output_type
class CampaignTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        CampaignTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class CampaignTimeBasedCollectionScheme(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "periodMs":
            suggest = "period_ms"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CampaignTimeBasedCollectionScheme. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CampaignTimeBasedCollectionScheme.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CampaignTimeBasedCollectionScheme.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 period_ms: float):
        CampaignTimeBasedCollectionScheme._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            period_ms=period_ms,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             period_ms: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if period_ms is None and 'periodMs' in kwargs:
            period_ms = kwargs['periodMs']
        if period_ms is None:
            raise TypeError("Missing 'period_ms' argument")

        _setter("period_ms", period_ms)

    @property
    @pulumi.getter(name="periodMs")
    def period_ms(self) -> float:
        return pulumi.get(self, "period_ms")


@pulumi.output_type
class CampaignTimestreamConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "executionRoleArn":
            suggest = "execution_role_arn"
        elif key == "timestreamTableArn":
            suggest = "timestream_table_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CampaignTimestreamConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CampaignTimestreamConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CampaignTimestreamConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 execution_role_arn: str,
                 timestream_table_arn: str):
        CampaignTimestreamConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            execution_role_arn=execution_role_arn,
            timestream_table_arn=timestream_table_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             execution_role_arn: Optional[str] = None,
             timestream_table_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if execution_role_arn is None and 'executionRoleArn' in kwargs:
            execution_role_arn = kwargs['executionRoleArn']
        if execution_role_arn is None:
            raise TypeError("Missing 'execution_role_arn' argument")
        if timestream_table_arn is None and 'timestreamTableArn' in kwargs:
            timestream_table_arn = kwargs['timestreamTableArn']
        if timestream_table_arn is None:
            raise TypeError("Missing 'timestream_table_arn' argument")

        _setter("execution_role_arn", execution_role_arn)
        _setter("timestream_table_arn", timestream_table_arn)

    @property
    @pulumi.getter(name="executionRoleArn")
    def execution_role_arn(self) -> str:
        return pulumi.get(self, "execution_role_arn")

    @property
    @pulumi.getter(name="timestreamTableArn")
    def timestream_table_arn(self) -> str:
        return pulumi.get(self, "timestream_table_arn")


@pulumi.output_type
class DecoderManifestCanInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "protocolName":
            suggest = "protocol_name"
        elif key == "protocolVersion":
            suggest = "protocol_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DecoderManifestCanInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DecoderManifestCanInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DecoderManifestCanInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 protocol_name: Optional[str] = None,
                 protocol_version: Optional[str] = None):
        DecoderManifestCanInterface._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            protocol_name=protocol_name,
            protocol_version=protocol_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             protocol_name: Optional[str] = None,
             protocol_version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if protocol_name is None and 'protocolName' in kwargs:
            protocol_name = kwargs['protocolName']
        if protocol_version is None and 'protocolVersion' in kwargs:
            protocol_version = kwargs['protocolVersion']

        _setter("name", name)
        if protocol_name is not None:
            _setter("protocol_name", protocol_name)
        if protocol_version is not None:
            _setter("protocol_version", protocol_version)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="protocolName")
    def protocol_name(self) -> Optional[str]:
        return pulumi.get(self, "protocol_name")

    @property
    @pulumi.getter(name="protocolVersion")
    def protocol_version(self) -> Optional[str]:
        return pulumi.get(self, "protocol_version")


@pulumi.output_type
class DecoderManifestCanNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canInterface":
            suggest = "can_interface"
        elif key == "interfaceId":
            suggest = "interface_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DecoderManifestCanNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DecoderManifestCanNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DecoderManifestCanNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 can_interface: 'outputs.DecoderManifestCanInterface',
                 interface_id: str,
                 type: 'DecoderManifestCanNetworkInterfaceType'):
        DecoderManifestCanNetworkInterface._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            can_interface=can_interface,
            interface_id=interface_id,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             can_interface: Optional['outputs.DecoderManifestCanInterface'] = None,
             interface_id: Optional[str] = None,
             type: Optional['DecoderManifestCanNetworkInterfaceType'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if can_interface is None and 'canInterface' in kwargs:
            can_interface = kwargs['canInterface']
        if can_interface is None:
            raise TypeError("Missing 'can_interface' argument")
        if interface_id is None and 'interfaceId' in kwargs:
            interface_id = kwargs['interfaceId']
        if interface_id is None:
            raise TypeError("Missing 'interface_id' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("can_interface", can_interface)
        _setter("interface_id", interface_id)
        _setter("type", type)

    @property
    @pulumi.getter(name="canInterface")
    def can_interface(self) -> 'outputs.DecoderManifestCanInterface':
        return pulumi.get(self, "can_interface")

    @property
    @pulumi.getter(name="interfaceId")
    def interface_id(self) -> str:
        return pulumi.get(self, "interface_id")

    @property
    @pulumi.getter
    def type(self) -> 'DecoderManifestCanNetworkInterfaceType':
        return pulumi.get(self, "type")


@pulumi.output_type
class DecoderManifestCanSignal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isBigEndian":
            suggest = "is_big_endian"
        elif key == "isSigned":
            suggest = "is_signed"
        elif key == "messageId":
            suggest = "message_id"
        elif key == "startBit":
            suggest = "start_bit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DecoderManifestCanSignal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DecoderManifestCanSignal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DecoderManifestCanSignal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 factor: float,
                 is_big_endian: bool,
                 is_signed: bool,
                 length: int,
                 message_id: int,
                 offset: float,
                 start_bit: int,
                 name: Optional[str] = None):
        DecoderManifestCanSignal._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            factor=factor,
            is_big_endian=is_big_endian,
            is_signed=is_signed,
            length=length,
            message_id=message_id,
            offset=offset,
            start_bit=start_bit,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             factor: Optional[float] = None,
             is_big_endian: Optional[bool] = None,
             is_signed: Optional[bool] = None,
             length: Optional[int] = None,
             message_id: Optional[int] = None,
             offset: Optional[float] = None,
             start_bit: Optional[int] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if factor is None:
            raise TypeError("Missing 'factor' argument")
        if is_big_endian is None and 'isBigEndian' in kwargs:
            is_big_endian = kwargs['isBigEndian']
        if is_big_endian is None:
            raise TypeError("Missing 'is_big_endian' argument")
        if is_signed is None and 'isSigned' in kwargs:
            is_signed = kwargs['isSigned']
        if is_signed is None:
            raise TypeError("Missing 'is_signed' argument")
        if length is None:
            raise TypeError("Missing 'length' argument")
        if message_id is None and 'messageId' in kwargs:
            message_id = kwargs['messageId']
        if message_id is None:
            raise TypeError("Missing 'message_id' argument")
        if offset is None:
            raise TypeError("Missing 'offset' argument")
        if start_bit is None and 'startBit' in kwargs:
            start_bit = kwargs['startBit']
        if start_bit is None:
            raise TypeError("Missing 'start_bit' argument")

        _setter("factor", factor)
        _setter("is_big_endian", is_big_endian)
        _setter("is_signed", is_signed)
        _setter("length", length)
        _setter("message_id", message_id)
        _setter("offset", offset)
        _setter("start_bit", start_bit)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def factor(self) -> float:
        return pulumi.get(self, "factor")

    @property
    @pulumi.getter(name="isBigEndian")
    def is_big_endian(self) -> bool:
        return pulumi.get(self, "is_big_endian")

    @property
    @pulumi.getter(name="isSigned")
    def is_signed(self) -> bool:
        return pulumi.get(self, "is_signed")

    @property
    @pulumi.getter
    def length(self) -> int:
        return pulumi.get(self, "length")

    @property
    @pulumi.getter(name="messageId")
    def message_id(self) -> int:
        return pulumi.get(self, "message_id")

    @property
    @pulumi.getter
    def offset(self) -> float:
        return pulumi.get(self, "offset")

    @property
    @pulumi.getter(name="startBit")
    def start_bit(self) -> int:
        return pulumi.get(self, "start_bit")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class DecoderManifestCanSignalDecoder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canSignal":
            suggest = "can_signal"
        elif key == "fullyQualifiedName":
            suggest = "fully_qualified_name"
        elif key == "interfaceId":
            suggest = "interface_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DecoderManifestCanSignalDecoder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DecoderManifestCanSignalDecoder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DecoderManifestCanSignalDecoder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 can_signal: 'outputs.DecoderManifestCanSignal',
                 fully_qualified_name: str,
                 interface_id: str,
                 type: 'DecoderManifestCanSignalDecoderType'):
        DecoderManifestCanSignalDecoder._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            can_signal=can_signal,
            fully_qualified_name=fully_qualified_name,
            interface_id=interface_id,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             can_signal: Optional['outputs.DecoderManifestCanSignal'] = None,
             fully_qualified_name: Optional[str] = None,
             interface_id: Optional[str] = None,
             type: Optional['DecoderManifestCanSignalDecoderType'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if can_signal is None and 'canSignal' in kwargs:
            can_signal = kwargs['canSignal']
        if can_signal is None:
            raise TypeError("Missing 'can_signal' argument")
        if fully_qualified_name is None and 'fullyQualifiedName' in kwargs:
            fully_qualified_name = kwargs['fullyQualifiedName']
        if fully_qualified_name is None:
            raise TypeError("Missing 'fully_qualified_name' argument")
        if interface_id is None and 'interfaceId' in kwargs:
            interface_id = kwargs['interfaceId']
        if interface_id is None:
            raise TypeError("Missing 'interface_id' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("can_signal", can_signal)
        _setter("fully_qualified_name", fully_qualified_name)
        _setter("interface_id", interface_id)
        _setter("type", type)

    @property
    @pulumi.getter(name="canSignal")
    def can_signal(self) -> 'outputs.DecoderManifestCanSignal':
        return pulumi.get(self, "can_signal")

    @property
    @pulumi.getter(name="fullyQualifiedName")
    def fully_qualified_name(self) -> str:
        return pulumi.get(self, "fully_qualified_name")

    @property
    @pulumi.getter(name="interfaceId")
    def interface_id(self) -> str:
        return pulumi.get(self, "interface_id")

    @property
    @pulumi.getter
    def type(self) -> 'DecoderManifestCanSignalDecoderType':
        return pulumi.get(self, "type")


@pulumi.output_type
class DecoderManifestObdInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestMessageId":
            suggest = "request_message_id"
        elif key == "dtcRequestIntervalSeconds":
            suggest = "dtc_request_interval_seconds"
        elif key == "hasTransmissionEcu":
            suggest = "has_transmission_ecu"
        elif key == "obdStandard":
            suggest = "obd_standard"
        elif key == "pidRequestIntervalSeconds":
            suggest = "pid_request_interval_seconds"
        elif key == "useExtendedIds":
            suggest = "use_extended_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DecoderManifestObdInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DecoderManifestObdInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DecoderManifestObdInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 request_message_id: int,
                 dtc_request_interval_seconds: Optional[int] = None,
                 has_transmission_ecu: Optional[bool] = None,
                 obd_standard: Optional[str] = None,
                 pid_request_interval_seconds: Optional[int] = None,
                 use_extended_ids: Optional[bool] = None):
        DecoderManifestObdInterface._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            request_message_id=request_message_id,
            dtc_request_interval_seconds=dtc_request_interval_seconds,
            has_transmission_ecu=has_transmission_ecu,
            obd_standard=obd_standard,
            pid_request_interval_seconds=pid_request_interval_seconds,
            use_extended_ids=use_extended_ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             request_message_id: Optional[int] = None,
             dtc_request_interval_seconds: Optional[int] = None,
             has_transmission_ecu: Optional[bool] = None,
             obd_standard: Optional[str] = None,
             pid_request_interval_seconds: Optional[int] = None,
             use_extended_ids: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if request_message_id is None and 'requestMessageId' in kwargs:
            request_message_id = kwargs['requestMessageId']
        if request_message_id is None:
            raise TypeError("Missing 'request_message_id' argument")
        if dtc_request_interval_seconds is None and 'dtcRequestIntervalSeconds' in kwargs:
            dtc_request_interval_seconds = kwargs['dtcRequestIntervalSeconds']
        if has_transmission_ecu is None and 'hasTransmissionEcu' in kwargs:
            has_transmission_ecu = kwargs['hasTransmissionEcu']
        if obd_standard is None and 'obdStandard' in kwargs:
            obd_standard = kwargs['obdStandard']
        if pid_request_interval_seconds is None and 'pidRequestIntervalSeconds' in kwargs:
            pid_request_interval_seconds = kwargs['pidRequestIntervalSeconds']
        if use_extended_ids is None and 'useExtendedIds' in kwargs:
            use_extended_ids = kwargs['useExtendedIds']

        _setter("name", name)
        _setter("request_message_id", request_message_id)
        if dtc_request_interval_seconds is not None:
            _setter("dtc_request_interval_seconds", dtc_request_interval_seconds)
        if has_transmission_ecu is not None:
            _setter("has_transmission_ecu", has_transmission_ecu)
        if obd_standard is not None:
            _setter("obd_standard", obd_standard)
        if pid_request_interval_seconds is not None:
            _setter("pid_request_interval_seconds", pid_request_interval_seconds)
        if use_extended_ids is not None:
            _setter("use_extended_ids", use_extended_ids)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="requestMessageId")
    def request_message_id(self) -> int:
        return pulumi.get(self, "request_message_id")

    @property
    @pulumi.getter(name="dtcRequestIntervalSeconds")
    def dtc_request_interval_seconds(self) -> Optional[int]:
        return pulumi.get(self, "dtc_request_interval_seconds")

    @property
    @pulumi.getter(name="hasTransmissionEcu")
    def has_transmission_ecu(self) -> Optional[bool]:
        return pulumi.get(self, "has_transmission_ecu")

    @property
    @pulumi.getter(name="obdStandard")
    def obd_standard(self) -> Optional[str]:
        return pulumi.get(self, "obd_standard")

    @property
    @pulumi.getter(name="pidRequestIntervalSeconds")
    def pid_request_interval_seconds(self) -> Optional[int]:
        return pulumi.get(self, "pid_request_interval_seconds")

    @property
    @pulumi.getter(name="useExtendedIds")
    def use_extended_ids(self) -> Optional[bool]:
        return pulumi.get(self, "use_extended_ids")


@pulumi.output_type
class DecoderManifestObdNetworkInterface(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "interfaceId":
            suggest = "interface_id"
        elif key == "obdInterface":
            suggest = "obd_interface"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DecoderManifestObdNetworkInterface. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DecoderManifestObdNetworkInterface.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DecoderManifestObdNetworkInterface.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interface_id: str,
                 obd_interface: 'outputs.DecoderManifestObdInterface',
                 type: 'DecoderManifestObdNetworkInterfaceType'):
        DecoderManifestObdNetworkInterface._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            interface_id=interface_id,
            obd_interface=obd_interface,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             interface_id: Optional[str] = None,
             obd_interface: Optional['outputs.DecoderManifestObdInterface'] = None,
             type: Optional['DecoderManifestObdNetworkInterfaceType'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if interface_id is None and 'interfaceId' in kwargs:
            interface_id = kwargs['interfaceId']
        if interface_id is None:
            raise TypeError("Missing 'interface_id' argument")
        if obd_interface is None and 'obdInterface' in kwargs:
            obd_interface = kwargs['obdInterface']
        if obd_interface is None:
            raise TypeError("Missing 'obd_interface' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("interface_id", interface_id)
        _setter("obd_interface", obd_interface)
        _setter("type", type)

    @property
    @pulumi.getter(name="interfaceId")
    def interface_id(self) -> str:
        return pulumi.get(self, "interface_id")

    @property
    @pulumi.getter(name="obdInterface")
    def obd_interface(self) -> 'outputs.DecoderManifestObdInterface':
        return pulumi.get(self, "obd_interface")

    @property
    @pulumi.getter
    def type(self) -> 'DecoderManifestObdNetworkInterfaceType':
        return pulumi.get(self, "type")


@pulumi.output_type
class DecoderManifestObdSignal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "byteLength":
            suggest = "byte_length"
        elif key == "pidResponseLength":
            suggest = "pid_response_length"
        elif key == "serviceMode":
            suggest = "service_mode"
        elif key == "startByte":
            suggest = "start_byte"
        elif key == "bitMaskLength":
            suggest = "bit_mask_length"
        elif key == "bitRightShift":
            suggest = "bit_right_shift"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DecoderManifestObdSignal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DecoderManifestObdSignal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DecoderManifestObdSignal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 byte_length: int,
                 offset: float,
                 pid: int,
                 pid_response_length: int,
                 scaling: float,
                 service_mode: int,
                 start_byte: int,
                 bit_mask_length: Optional[int] = None,
                 bit_right_shift: Optional[int] = None):
        DecoderManifestObdSignal._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            byte_length=byte_length,
            offset=offset,
            pid=pid,
            pid_response_length=pid_response_length,
            scaling=scaling,
            service_mode=service_mode,
            start_byte=start_byte,
            bit_mask_length=bit_mask_length,
            bit_right_shift=bit_right_shift,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             byte_length: Optional[int] = None,
             offset: Optional[float] = None,
             pid: Optional[int] = None,
             pid_response_length: Optional[int] = None,
             scaling: Optional[float] = None,
             service_mode: Optional[int] = None,
             start_byte: Optional[int] = None,
             bit_mask_length: Optional[int] = None,
             bit_right_shift: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if byte_length is None and 'byteLength' in kwargs:
            byte_length = kwargs['byteLength']
        if byte_length is None:
            raise TypeError("Missing 'byte_length' argument")
        if offset is None:
            raise TypeError("Missing 'offset' argument")
        if pid is None:
            raise TypeError("Missing 'pid' argument")
        if pid_response_length is None and 'pidResponseLength' in kwargs:
            pid_response_length = kwargs['pidResponseLength']
        if pid_response_length is None:
            raise TypeError("Missing 'pid_response_length' argument")
        if scaling is None:
            raise TypeError("Missing 'scaling' argument")
        if service_mode is None and 'serviceMode' in kwargs:
            service_mode = kwargs['serviceMode']
        if service_mode is None:
            raise TypeError("Missing 'service_mode' argument")
        if start_byte is None and 'startByte' in kwargs:
            start_byte = kwargs['startByte']
        if start_byte is None:
            raise TypeError("Missing 'start_byte' argument")
        if bit_mask_length is None and 'bitMaskLength' in kwargs:
            bit_mask_length = kwargs['bitMaskLength']
        if bit_right_shift is None and 'bitRightShift' in kwargs:
            bit_right_shift = kwargs['bitRightShift']

        _setter("byte_length", byte_length)
        _setter("offset", offset)
        _setter("pid", pid)
        _setter("pid_response_length", pid_response_length)
        _setter("scaling", scaling)
        _setter("service_mode", service_mode)
        _setter("start_byte", start_byte)
        if bit_mask_length is not None:
            _setter("bit_mask_length", bit_mask_length)
        if bit_right_shift is not None:
            _setter("bit_right_shift", bit_right_shift)

    @property
    @pulumi.getter(name="byteLength")
    def byte_length(self) -> int:
        return pulumi.get(self, "byte_length")

    @property
    @pulumi.getter
    def offset(self) -> float:
        return pulumi.get(self, "offset")

    @property
    @pulumi.getter
    def pid(self) -> int:
        return pulumi.get(self, "pid")

    @property
    @pulumi.getter(name="pidResponseLength")
    def pid_response_length(self) -> int:
        return pulumi.get(self, "pid_response_length")

    @property
    @pulumi.getter
    def scaling(self) -> float:
        return pulumi.get(self, "scaling")

    @property
    @pulumi.getter(name="serviceMode")
    def service_mode(self) -> int:
        return pulumi.get(self, "service_mode")

    @property
    @pulumi.getter(name="startByte")
    def start_byte(self) -> int:
        return pulumi.get(self, "start_byte")

    @property
    @pulumi.getter(name="bitMaskLength")
    def bit_mask_length(self) -> Optional[int]:
        return pulumi.get(self, "bit_mask_length")

    @property
    @pulumi.getter(name="bitRightShift")
    def bit_right_shift(self) -> Optional[int]:
        return pulumi.get(self, "bit_right_shift")


@pulumi.output_type
class DecoderManifestObdSignalDecoder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fullyQualifiedName":
            suggest = "fully_qualified_name"
        elif key == "interfaceId":
            suggest = "interface_id"
        elif key == "obdSignal":
            suggest = "obd_signal"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DecoderManifestObdSignalDecoder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DecoderManifestObdSignalDecoder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DecoderManifestObdSignalDecoder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fully_qualified_name: str,
                 interface_id: str,
                 obd_signal: 'outputs.DecoderManifestObdSignal',
                 type: 'DecoderManifestObdSignalDecoderType'):
        DecoderManifestObdSignalDecoder._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fully_qualified_name=fully_qualified_name,
            interface_id=interface_id,
            obd_signal=obd_signal,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fully_qualified_name: Optional[str] = None,
             interface_id: Optional[str] = None,
             obd_signal: Optional['outputs.DecoderManifestObdSignal'] = None,
             type: Optional['DecoderManifestObdSignalDecoderType'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if fully_qualified_name is None and 'fullyQualifiedName' in kwargs:
            fully_qualified_name = kwargs['fullyQualifiedName']
        if fully_qualified_name is None:
            raise TypeError("Missing 'fully_qualified_name' argument")
        if interface_id is None and 'interfaceId' in kwargs:
            interface_id = kwargs['interfaceId']
        if interface_id is None:
            raise TypeError("Missing 'interface_id' argument")
        if obd_signal is None and 'obdSignal' in kwargs:
            obd_signal = kwargs['obdSignal']
        if obd_signal is None:
            raise TypeError("Missing 'obd_signal' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("fully_qualified_name", fully_qualified_name)
        _setter("interface_id", interface_id)
        _setter("obd_signal", obd_signal)
        _setter("type", type)

    @property
    @pulumi.getter(name="fullyQualifiedName")
    def fully_qualified_name(self) -> str:
        return pulumi.get(self, "fully_qualified_name")

    @property
    @pulumi.getter(name="interfaceId")
    def interface_id(self) -> str:
        return pulumi.get(self, "interface_id")

    @property
    @pulumi.getter(name="obdSignal")
    def obd_signal(self) -> 'outputs.DecoderManifestObdSignal':
        return pulumi.get(self, "obd_signal")

    @property
    @pulumi.getter
    def type(self) -> 'DecoderManifestObdSignalDecoderType':
        return pulumi.get(self, "type")


@pulumi.output_type
class DecoderManifestTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        DecoderManifestTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class FleetTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        FleetTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class ModelManifestTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        ModelManifestTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class SignalCatalogActuator(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataType":
            suggest = "data_type"
        elif key == "fullyQualifiedName":
            suggest = "fully_qualified_name"
        elif key == "allowedValues":
            suggest = "allowed_values"
        elif key == "assignedValue":
            suggest = "assigned_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SignalCatalogActuator. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SignalCatalogActuator.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SignalCatalogActuator.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_type: 'SignalCatalogNodeDataType',
                 fully_qualified_name: str,
                 allowed_values: Optional[Sequence[str]] = None,
                 assigned_value: Optional[str] = None,
                 description: Optional[str] = None,
                 max: Optional[float] = None,
                 min: Optional[float] = None,
                 unit: Optional[str] = None):
        SignalCatalogActuator._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_type=data_type,
            fully_qualified_name=fully_qualified_name,
            allowed_values=allowed_values,
            assigned_value=assigned_value,
            description=description,
            max=max,
            min=min,
            unit=unit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_type: Optional['SignalCatalogNodeDataType'] = None,
             fully_qualified_name: Optional[str] = None,
             allowed_values: Optional[Sequence[str]] = None,
             assigned_value: Optional[str] = None,
             description: Optional[str] = None,
             max: Optional[float] = None,
             min: Optional[float] = None,
             unit: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if data_type is None and 'dataType' in kwargs:
            data_type = kwargs['dataType']
        if data_type is None:
            raise TypeError("Missing 'data_type' argument")
        if fully_qualified_name is None and 'fullyQualifiedName' in kwargs:
            fully_qualified_name = kwargs['fullyQualifiedName']
        if fully_qualified_name is None:
            raise TypeError("Missing 'fully_qualified_name' argument")
        if allowed_values is None and 'allowedValues' in kwargs:
            allowed_values = kwargs['allowedValues']
        if assigned_value is None and 'assignedValue' in kwargs:
            assigned_value = kwargs['assignedValue']

        _setter("data_type", data_type)
        _setter("fully_qualified_name", fully_qualified_name)
        if allowed_values is not None:
            _setter("allowed_values", allowed_values)
        if assigned_value is not None:
            _setter("assigned_value", assigned_value)
        if description is not None:
            _setter("description", description)
        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)
        if unit is not None:
            _setter("unit", unit)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> 'SignalCatalogNodeDataType':
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter(name="fullyQualifiedName")
    def fully_qualified_name(self) -> str:
        return pulumi.get(self, "fully_qualified_name")

    @property
    @pulumi.getter(name="allowedValues")
    def allowed_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allowed_values")

    @property
    @pulumi.getter(name="assignedValue")
    def assigned_value(self) -> Optional[str]:
        return pulumi.get(self, "assigned_value")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def unit(self) -> Optional[str]:
        return pulumi.get(self, "unit")


@pulumi.output_type
class SignalCatalogAttribute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataType":
            suggest = "data_type"
        elif key == "fullyQualifiedName":
            suggest = "fully_qualified_name"
        elif key == "allowedValues":
            suggest = "allowed_values"
        elif key == "assignedValue":
            suggest = "assigned_value"
        elif key == "defaultValue":
            suggest = "default_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SignalCatalogAttribute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SignalCatalogAttribute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SignalCatalogAttribute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_type: 'SignalCatalogNodeDataType',
                 fully_qualified_name: str,
                 allowed_values: Optional[Sequence[str]] = None,
                 assigned_value: Optional[str] = None,
                 default_value: Optional[str] = None,
                 description: Optional[str] = None,
                 max: Optional[float] = None,
                 min: Optional[float] = None,
                 unit: Optional[str] = None):
        SignalCatalogAttribute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_type=data_type,
            fully_qualified_name=fully_qualified_name,
            allowed_values=allowed_values,
            assigned_value=assigned_value,
            default_value=default_value,
            description=description,
            max=max,
            min=min,
            unit=unit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_type: Optional['SignalCatalogNodeDataType'] = None,
             fully_qualified_name: Optional[str] = None,
             allowed_values: Optional[Sequence[str]] = None,
             assigned_value: Optional[str] = None,
             default_value: Optional[str] = None,
             description: Optional[str] = None,
             max: Optional[float] = None,
             min: Optional[float] = None,
             unit: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if data_type is None and 'dataType' in kwargs:
            data_type = kwargs['dataType']
        if data_type is None:
            raise TypeError("Missing 'data_type' argument")
        if fully_qualified_name is None and 'fullyQualifiedName' in kwargs:
            fully_qualified_name = kwargs['fullyQualifiedName']
        if fully_qualified_name is None:
            raise TypeError("Missing 'fully_qualified_name' argument")
        if allowed_values is None and 'allowedValues' in kwargs:
            allowed_values = kwargs['allowedValues']
        if assigned_value is None and 'assignedValue' in kwargs:
            assigned_value = kwargs['assignedValue']
        if default_value is None and 'defaultValue' in kwargs:
            default_value = kwargs['defaultValue']

        _setter("data_type", data_type)
        _setter("fully_qualified_name", fully_qualified_name)
        if allowed_values is not None:
            _setter("allowed_values", allowed_values)
        if assigned_value is not None:
            _setter("assigned_value", assigned_value)
        if default_value is not None:
            _setter("default_value", default_value)
        if description is not None:
            _setter("description", description)
        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)
        if unit is not None:
            _setter("unit", unit)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> 'SignalCatalogNodeDataType':
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter(name="fullyQualifiedName")
    def fully_qualified_name(self) -> str:
        return pulumi.get(self, "fully_qualified_name")

    @property
    @pulumi.getter(name="allowedValues")
    def allowed_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allowed_values")

    @property
    @pulumi.getter(name="assignedValue")
    def assigned_value(self) -> Optional[str]:
        return pulumi.get(self, "assigned_value")

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[str]:
        return pulumi.get(self, "default_value")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def unit(self) -> Optional[str]:
        return pulumi.get(self, "unit")


@pulumi.output_type
class SignalCatalogBranch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fullyQualifiedName":
            suggest = "fully_qualified_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SignalCatalogBranch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SignalCatalogBranch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SignalCatalogBranch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fully_qualified_name: str,
                 description: Optional[str] = None):
        SignalCatalogBranch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fully_qualified_name=fully_qualified_name,
            description=description,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fully_qualified_name: Optional[str] = None,
             description: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if fully_qualified_name is None and 'fullyQualifiedName' in kwargs:
            fully_qualified_name = kwargs['fullyQualifiedName']
        if fully_qualified_name is None:
            raise TypeError("Missing 'fully_qualified_name' argument")

        _setter("fully_qualified_name", fully_qualified_name)
        if description is not None:
            _setter("description", description)

    @property
    @pulumi.getter(name="fullyQualifiedName")
    def fully_qualified_name(self) -> str:
        return pulumi.get(self, "fully_qualified_name")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class SignalCatalogNode0Properties(dict):
    def __init__(__self__, *,
                 branch: Optional['outputs.SignalCatalogBranch'] = None):
        SignalCatalogNode0Properties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            branch=branch,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             branch: Optional['outputs.SignalCatalogBranch'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if branch is not None:
            _setter("branch", branch)

    @property
    @pulumi.getter
    def branch(self) -> Optional['outputs.SignalCatalogBranch']:
        return pulumi.get(self, "branch")


@pulumi.output_type
class SignalCatalogNode1Properties(dict):
    def __init__(__self__, *,
                 sensor: Optional['outputs.SignalCatalogSensor'] = None):
        SignalCatalogNode1Properties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sensor=sensor,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sensor: Optional['outputs.SignalCatalogSensor'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if sensor is not None:
            _setter("sensor", sensor)

    @property
    @pulumi.getter
    def sensor(self) -> Optional['outputs.SignalCatalogSensor']:
        return pulumi.get(self, "sensor")


@pulumi.output_type
class SignalCatalogNode2Properties(dict):
    def __init__(__self__, *,
                 actuator: Optional['outputs.SignalCatalogActuator'] = None):
        SignalCatalogNode2Properties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actuator=actuator,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actuator: Optional['outputs.SignalCatalogActuator'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if actuator is not None:
            _setter("actuator", actuator)

    @property
    @pulumi.getter
    def actuator(self) -> Optional['outputs.SignalCatalogActuator']:
        return pulumi.get(self, "actuator")


@pulumi.output_type
class SignalCatalogNode3Properties(dict):
    def __init__(__self__, *,
                 attribute: Optional['outputs.SignalCatalogAttribute'] = None):
        SignalCatalogNode3Properties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attribute=attribute,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attribute: Optional['outputs.SignalCatalogAttribute'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):

        if attribute is not None:
            _setter("attribute", attribute)

    @property
    @pulumi.getter
    def attribute(self) -> Optional['outputs.SignalCatalogAttribute']:
        return pulumi.get(self, "attribute")


@pulumi.output_type
class SignalCatalogNodeCounts(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "totalActuators":
            suggest = "total_actuators"
        elif key == "totalAttributes":
            suggest = "total_attributes"
        elif key == "totalBranches":
            suggest = "total_branches"
        elif key == "totalNodes":
            suggest = "total_nodes"
        elif key == "totalSensors":
            suggest = "total_sensors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SignalCatalogNodeCounts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SignalCatalogNodeCounts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SignalCatalogNodeCounts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 total_actuators: Optional[float] = None,
                 total_attributes: Optional[float] = None,
                 total_branches: Optional[float] = None,
                 total_nodes: Optional[float] = None,
                 total_sensors: Optional[float] = None):
        SignalCatalogNodeCounts._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            total_actuators=total_actuators,
            total_attributes=total_attributes,
            total_branches=total_branches,
            total_nodes=total_nodes,
            total_sensors=total_sensors,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             total_actuators: Optional[float] = None,
             total_attributes: Optional[float] = None,
             total_branches: Optional[float] = None,
             total_nodes: Optional[float] = None,
             total_sensors: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if total_actuators is None and 'totalActuators' in kwargs:
            total_actuators = kwargs['totalActuators']
        if total_attributes is None and 'totalAttributes' in kwargs:
            total_attributes = kwargs['totalAttributes']
        if total_branches is None and 'totalBranches' in kwargs:
            total_branches = kwargs['totalBranches']
        if total_nodes is None and 'totalNodes' in kwargs:
            total_nodes = kwargs['totalNodes']
        if total_sensors is None and 'totalSensors' in kwargs:
            total_sensors = kwargs['totalSensors']

        if total_actuators is not None:
            _setter("total_actuators", total_actuators)
        if total_attributes is not None:
            _setter("total_attributes", total_attributes)
        if total_branches is not None:
            _setter("total_branches", total_branches)
        if total_nodes is not None:
            _setter("total_nodes", total_nodes)
        if total_sensors is not None:
            _setter("total_sensors", total_sensors)

    @property
    @pulumi.getter(name="totalActuators")
    def total_actuators(self) -> Optional[float]:
        return pulumi.get(self, "total_actuators")

    @property
    @pulumi.getter(name="totalAttributes")
    def total_attributes(self) -> Optional[float]:
        return pulumi.get(self, "total_attributes")

    @property
    @pulumi.getter(name="totalBranches")
    def total_branches(self) -> Optional[float]:
        return pulumi.get(self, "total_branches")

    @property
    @pulumi.getter(name="totalNodes")
    def total_nodes(self) -> Optional[float]:
        return pulumi.get(self, "total_nodes")

    @property
    @pulumi.getter(name="totalSensors")
    def total_sensors(self) -> Optional[float]:
        return pulumi.get(self, "total_sensors")


@pulumi.output_type
class SignalCatalogSensor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataType":
            suggest = "data_type"
        elif key == "fullyQualifiedName":
            suggest = "fully_qualified_name"
        elif key == "allowedValues":
            suggest = "allowed_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SignalCatalogSensor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SignalCatalogSensor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SignalCatalogSensor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_type: 'SignalCatalogNodeDataType',
                 fully_qualified_name: str,
                 allowed_values: Optional[Sequence[str]] = None,
                 description: Optional[str] = None,
                 max: Optional[float] = None,
                 min: Optional[float] = None,
                 unit: Optional[str] = None):
        SignalCatalogSensor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_type=data_type,
            fully_qualified_name=fully_qualified_name,
            allowed_values=allowed_values,
            description=description,
            max=max,
            min=min,
            unit=unit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_type: Optional['SignalCatalogNodeDataType'] = None,
             fully_qualified_name: Optional[str] = None,
             allowed_values: Optional[Sequence[str]] = None,
             description: Optional[str] = None,
             max: Optional[float] = None,
             min: Optional[float] = None,
             unit: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if data_type is None and 'dataType' in kwargs:
            data_type = kwargs['dataType']
        if data_type is None:
            raise TypeError("Missing 'data_type' argument")
        if fully_qualified_name is None and 'fullyQualifiedName' in kwargs:
            fully_qualified_name = kwargs['fullyQualifiedName']
        if fully_qualified_name is None:
            raise TypeError("Missing 'fully_qualified_name' argument")
        if allowed_values is None and 'allowedValues' in kwargs:
            allowed_values = kwargs['allowedValues']

        _setter("data_type", data_type)
        _setter("fully_qualified_name", fully_qualified_name)
        if allowed_values is not None:
            _setter("allowed_values", allowed_values)
        if description is not None:
            _setter("description", description)
        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)
        if unit is not None:
            _setter("unit", unit)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> 'SignalCatalogNodeDataType':
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter(name="fullyQualifiedName")
    def fully_qualified_name(self) -> str:
        return pulumi.get(self, "fully_qualified_name")

    @property
    @pulumi.getter(name="allowedValues")
    def allowed_values(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allowed_values")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def unit(self) -> Optional[str]:
        return pulumi.get(self, "unit")


@pulumi.output_type
class SignalCatalogTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        SignalCatalogTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class VehicleTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        VehicleTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class VehicleattributesMap(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        pass



