# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'ConnectivityInfoProperties',
    'EnvironmentCheck',
    'EnvironmentHostInfoForCreate',
    'EnvironmentInitialVlanInfo',
    'EnvironmentSecret',
    'InitialVlansProperties',
    'LicenseInfoProperties',
    'ServiceAccessSecurityGroupsProperties',
    'VcfHostnamesProperties',
]

@pulumi.output_type
class ConnectivityInfoProperties(dict):
    """
    The connectivity configuration for the environment. Amazon EVS requires that you specify two route server peer IDs. During environment creation, the route server endpoints peer with the NSX uplink VLAN for connectivity to the NSX overlay network.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateRouteServerPeerings":
            suggest = "private_route_server_peerings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectivityInfoProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectivityInfoProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectivityInfoProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_route_server_peerings: Sequence[_builtins.str]):
        """
        The connectivity configuration for the environment. Amazon EVS requires that you specify two route server peer IDs. During environment creation, the route server endpoints peer with the NSX uplink VLAN for connectivity to the NSX overlay network.
        :param Sequence[_builtins.str] private_route_server_peerings: The unique IDs for private route server peers.
        """
        pulumi.set(__self__, "private_route_server_peerings", private_route_server_peerings)

    @_builtins.property
    @pulumi.getter(name="privateRouteServerPeerings")
    def private_route_server_peerings(self) -> Sequence[_builtins.str]:
        """
        The unique IDs for private route server peers.
        """
        return pulumi.get(self, "private_route_server_peerings")


@pulumi.output_type
class EnvironmentCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "impairedSince":
            suggest = "impaired_since"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnvironmentCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnvironmentCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnvironmentCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 result: 'EnvironmentCheckResult',
                 type: 'EnvironmentCheckType',
                 impaired_since: Optional[_builtins.str] = None):
        """
        :param 'EnvironmentCheckResult' result: The check result.
        :param 'EnvironmentCheckType' type: The check type. Amazon EVS performs the following checks.
               
               - `KEY_REUSE` : checks that the VCF license key is not used by another Amazon EVS environment. This check fails if a used license is added to the environment.
               - `KEY_COVERAGE` : checks that your VCF license key allocates sufficient vCPU cores for all deployed hosts. The check fails when any assigned hosts in the EVS environment are not covered by license keys, or when any unassigned hosts cannot be covered by available vCPU cores in keys.
               - `REACHABILITY` : checks that the Amazon EVS control plane has a persistent connection to SDDC Manager. If Amazon EVS cannot reach the environment, this check fails.
               - `HOST_COUNT` : Checks that your environment has a minimum of 4 hosts, which is a requirement for VCF 5.2.1.
               
               If this check fails, you will need to add hosts so that your environment meets this minimum requirement. Amazon EVS only supports environments with 4-16 hosts.
        :param _builtins.str impaired_since: The time when environment health began to be impaired.
        """
        pulumi.set(__self__, "result", result)
        pulumi.set(__self__, "type", type)
        if impaired_since is not None:
            pulumi.set(__self__, "impaired_since", impaired_since)

    @_builtins.property
    @pulumi.getter
    def result(self) -> 'EnvironmentCheckResult':
        """
        The check result.
        """
        return pulumi.get(self, "result")

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'EnvironmentCheckType':
        """
        The check type. Amazon EVS performs the following checks.

        - `KEY_REUSE` : checks that the VCF license key is not used by another Amazon EVS environment. This check fails if a used license is added to the environment.
        - `KEY_COVERAGE` : checks that your VCF license key allocates sufficient vCPU cores for all deployed hosts. The check fails when any assigned hosts in the EVS environment are not covered by license keys, or when any unassigned hosts cannot be covered by available vCPU cores in keys.
        - `REACHABILITY` : checks that the Amazon EVS control plane has a persistent connection to SDDC Manager. If Amazon EVS cannot reach the environment, this check fails.
        - `HOST_COUNT` : Checks that your environment has a minimum of 4 hosts, which is a requirement for VCF 5.2.1.

        If this check fails, you will need to add hosts so that your environment meets this minimum requirement. Amazon EVS only supports environments with 4-16 hosts.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="impairedSince")
    def impaired_since(self) -> Optional[_builtins.str]:
        """
        The time when environment health began to be impaired.
        """
        return pulumi.get(self, "impaired_since")


@pulumi.output_type
class EnvironmentHostInfoForCreate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostName":
            suggest = "host_name"
        elif key == "instanceType":
            suggest = "instance_type"
        elif key == "keyName":
            suggest = "key_name"
        elif key == "dedicatedHostId":
            suggest = "dedicated_host_id"
        elif key == "placementGroupId":
            suggest = "placement_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnvironmentHostInfoForCreate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnvironmentHostInfoForCreate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnvironmentHostInfoForCreate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_name: _builtins.str,
                 instance_type: 'EnvironmentHostInfoForCreateInstanceType',
                 key_name: _builtins.str,
                 dedicated_host_id: Optional[_builtins.str] = None,
                 placement_group_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str host_name: The DNS hostname of the host. DNS hostnames for hosts must be unique across Amazon EVS environments and within VCF.
        :param 'EnvironmentHostInfoForCreateInstanceType' instance_type: The EC2 instance type that represents the host.
        :param _builtins.str key_name: The name of the SSH key that is used to access the host.
        :param _builtins.str dedicated_host_id: The unique ID of the Amazon EC2 Dedicated Host.
        :param _builtins.str placement_group_id: The unique ID of the placement group where the host is placed.
        """
        pulumi.set(__self__, "host_name", host_name)
        pulumi.set(__self__, "instance_type", instance_type)
        pulumi.set(__self__, "key_name", key_name)
        if dedicated_host_id is not None:
            pulumi.set(__self__, "dedicated_host_id", dedicated_host_id)
        if placement_group_id is not None:
            pulumi.set(__self__, "placement_group_id", placement_group_id)

    @_builtins.property
    @pulumi.getter(name="hostName")
    def host_name(self) -> _builtins.str:
        """
        The DNS hostname of the host. DNS hostnames for hosts must be unique across Amazon EVS environments and within VCF.
        """
        return pulumi.get(self, "host_name")

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> 'EnvironmentHostInfoForCreateInstanceType':
        """
        The EC2 instance type that represents the host.
        """
        return pulumi.get(self, "instance_type")

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> _builtins.str:
        """
        The name of the SSH key that is used to access the host.
        """
        return pulumi.get(self, "key_name")

    @_builtins.property
    @pulumi.getter(name="dedicatedHostId")
    def dedicated_host_id(self) -> Optional[_builtins.str]:
        """
        The unique ID of the Amazon EC2 Dedicated Host.
        """
        return pulumi.get(self, "dedicated_host_id")

    @_builtins.property
    @pulumi.getter(name="placementGroupId")
    def placement_group_id(self) -> Optional[_builtins.str]:
        """
        The unique ID of the placement group where the host is placed.
        """
        return pulumi.get(self, "placement_group_id")


@pulumi.output_type
class EnvironmentInitialVlanInfo(dict):
    def __init__(__self__, *,
                 cidr: _builtins.str):
        """
        :param _builtins.str cidr: The CIDR block that you provide to create an Amazon EVS VLAN subnet. Amazon EVS VLAN subnets have a minimum CIDR block size of /28 and a maximum size of /24. Amazon EVS VLAN subnet CIDR blocks must not overlap with other subnets in the VPC.
        """
        pulumi.set(__self__, "cidr", cidr)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> _builtins.str:
        """
        The CIDR block that you provide to create an Amazon EVS VLAN subnet. Amazon EVS VLAN subnets have a minimum CIDR block size of /28 and a maximum size of /24. Amazon EVS VLAN subnet CIDR blocks must not overlap with other subnets in the VPC.
        """
        return pulumi.get(self, "cidr")


@pulumi.output_type
class EnvironmentSecret(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretArn":
            suggest = "secret_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnvironmentSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnvironmentSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnvironmentSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_arn: Optional[_builtins.str] = None):
        """
        :param _builtins.str secret_arn: The Amazon Resource Name (ARN) of the secret.
        """
        if secret_arn is not None:
            pulumi.set(__self__, "secret_arn", secret_arn)

    @_builtins.property
    @pulumi.getter(name="secretArn")
    def secret_arn(self) -> Optional[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the secret.
        """
        return pulumi.get(self, "secret_arn")


@pulumi.output_type
class InitialVlansProperties(dict):
    """
    The initial Vlan configuration only required upon creation. Modification after creation will have no effect
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "edgeVTep":
            suggest = "edge_v_tep"
        elif key == "expansionVlan1":
            suggest = "expansion_vlan1"
        elif key == "expansionVlan2":
            suggest = "expansion_vlan2"
        elif key == "nsxUpLink":
            suggest = "nsx_up_link"
        elif key == "vMotion":
            suggest = "v_motion"
        elif key == "vSan":
            suggest = "v_san"
        elif key == "vTep":
            suggest = "v_tep"
        elif key == "vmManagement":
            suggest = "vm_management"
        elif key == "vmkManagement":
            suggest = "vmk_management"
        elif key == "hcxNetworkAclId":
            suggest = "hcx_network_acl_id"
        elif key == "isHcxPublic":
            suggest = "is_hcx_public"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InitialVlansProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InitialVlansProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InitialVlansProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 edge_v_tep: 'outputs.EnvironmentInitialVlanInfo',
                 expansion_vlan1: 'outputs.EnvironmentInitialVlanInfo',
                 expansion_vlan2: 'outputs.EnvironmentInitialVlanInfo',
                 hcx: 'outputs.EnvironmentInitialVlanInfo',
                 nsx_up_link: 'outputs.EnvironmentInitialVlanInfo',
                 v_motion: 'outputs.EnvironmentInitialVlanInfo',
                 v_san: 'outputs.EnvironmentInitialVlanInfo',
                 v_tep: 'outputs.EnvironmentInitialVlanInfo',
                 vm_management: 'outputs.EnvironmentInitialVlanInfo',
                 vmk_management: 'outputs.EnvironmentInitialVlanInfo',
                 hcx_network_acl_id: Optional[_builtins.str] = None,
                 is_hcx_public: Optional[_builtins.bool] = None):
        """
        The initial Vlan configuration only required upon creation. Modification after creation will have no effect
        :param 'EnvironmentInitialVlanInfo' edge_v_tep: The edge VTEP VLAN subnet. This VLAN subnet manages traffic flowing between the internal network and external networks, including internet access and other site connections.
        :param 'EnvironmentInitialVlanInfo' expansion_vlan1: An additional VLAN subnet that can be used to extend VCF capabilities once configured. For example, you can configure an expansion VLAN subnet to use NSX Federation for centralized management and synchronization of multiple NSX deployments across different locations.
        :param 'EnvironmentInitialVlanInfo' expansion_vlan2: An additional VLAN subnet that can be used to extend VCF capabilities once configured. For example, you can configure an expansion VLAN subnet to use NSX Federation for centralized management and synchronization of multiple NSX deployments across different locations.
        :param 'EnvironmentInitialVlanInfo' hcx: The HCX VLAN subnet. This VLAN subnet allows the HCX Interconnnect (IX) and HCX Network Extension (NE) to reach their peers and enable HCX Service Mesh creation.
               
               If you plan to use a public HCX VLAN subnet, the following requirements must be met:
               
               - Must have a /28 netmask and be allocated from the IPAM public pool. Required for HCX internet access configuration.
               - The HCX public VLAN CIDR block must be added to the VPC as a secondary CIDR block.
               - Must have at least two Elastic IP addresses to be allocated from the public IPAM pool for HCX components.
        :param 'EnvironmentInitialVlanInfo' nsx_up_link: The NSX uplink VLAN subnet. This VLAN subnet allows connectivity to the NSX overlay network.
        :param 'EnvironmentInitialVlanInfo' v_motion: The vMotion VLAN subnet. This VLAN subnet carries traffic for vSphere vMotion.
        :param 'EnvironmentInitialVlanInfo' v_san: The vSAN VLAN subnet. This VLAN subnet carries the communication between ESXi hosts to implement a vSAN shared storage pool.
        :param 'EnvironmentInitialVlanInfo' v_tep: The VTEP VLAN subnet. This VLAN subnet handles internal network traffic between virtual machines within a VCF instance.
        :param 'EnvironmentInitialVlanInfo' vm_management: The VM management VLAN subnet. This VLAN subnet carries traffic for vSphere virtual machines.
        :param 'EnvironmentInitialVlanInfo' vmk_management: The host VMkernel management VLAN subnet. This VLAN subnet carries traffic for managing ESXi hosts and communicating with VMware vCenter Server.
        :param _builtins.str hcx_network_acl_id: A unique ID for a network access control list that the HCX VLAN uses. Required when `isHcxPublic` is set to `true` .
        :param _builtins.bool is_hcx_public: Determines if the HCX VLAN that Amazon EVS provisions is public or private.
        """
        pulumi.set(__self__, "edge_v_tep", edge_v_tep)
        pulumi.set(__self__, "expansion_vlan1", expansion_vlan1)
        pulumi.set(__self__, "expansion_vlan2", expansion_vlan2)
        pulumi.set(__self__, "hcx", hcx)
        pulumi.set(__self__, "nsx_up_link", nsx_up_link)
        pulumi.set(__self__, "v_motion", v_motion)
        pulumi.set(__self__, "v_san", v_san)
        pulumi.set(__self__, "v_tep", v_tep)
        pulumi.set(__self__, "vm_management", vm_management)
        pulumi.set(__self__, "vmk_management", vmk_management)
        if hcx_network_acl_id is not None:
            pulumi.set(__self__, "hcx_network_acl_id", hcx_network_acl_id)
        if is_hcx_public is not None:
            pulumi.set(__self__, "is_hcx_public", is_hcx_public)

    @_builtins.property
    @pulumi.getter(name="edgeVTep")
    def edge_v_tep(self) -> 'outputs.EnvironmentInitialVlanInfo':
        """
        The edge VTEP VLAN subnet. This VLAN subnet manages traffic flowing between the internal network and external networks, including internet access and other site connections.
        """
        return pulumi.get(self, "edge_v_tep")

    @_builtins.property
    @pulumi.getter(name="expansionVlan1")
    def expansion_vlan1(self) -> 'outputs.EnvironmentInitialVlanInfo':
        """
        An additional VLAN subnet that can be used to extend VCF capabilities once configured. For example, you can configure an expansion VLAN subnet to use NSX Federation for centralized management and synchronization of multiple NSX deployments across different locations.
        """
        return pulumi.get(self, "expansion_vlan1")

    @_builtins.property
    @pulumi.getter(name="expansionVlan2")
    def expansion_vlan2(self) -> 'outputs.EnvironmentInitialVlanInfo':
        """
        An additional VLAN subnet that can be used to extend VCF capabilities once configured. For example, you can configure an expansion VLAN subnet to use NSX Federation for centralized management and synchronization of multiple NSX deployments across different locations.
        """
        return pulumi.get(self, "expansion_vlan2")

    @_builtins.property
    @pulumi.getter
    def hcx(self) -> 'outputs.EnvironmentInitialVlanInfo':
        """
        The HCX VLAN subnet. This VLAN subnet allows the HCX Interconnnect (IX) and HCX Network Extension (NE) to reach their peers and enable HCX Service Mesh creation.

        If you plan to use a public HCX VLAN subnet, the following requirements must be met:

        - Must have a /28 netmask and be allocated from the IPAM public pool. Required for HCX internet access configuration.
        - The HCX public VLAN CIDR block must be added to the VPC as a secondary CIDR block.
        - Must have at least two Elastic IP addresses to be allocated from the public IPAM pool for HCX components.
        """
        return pulumi.get(self, "hcx")

    @_builtins.property
    @pulumi.getter(name="nsxUpLink")
    def nsx_up_link(self) -> 'outputs.EnvironmentInitialVlanInfo':
        """
        The NSX uplink VLAN subnet. This VLAN subnet allows connectivity to the NSX overlay network.
        """
        return pulumi.get(self, "nsx_up_link")

    @_builtins.property
    @pulumi.getter(name="vMotion")
    def v_motion(self) -> 'outputs.EnvironmentInitialVlanInfo':
        """
        The vMotion VLAN subnet. This VLAN subnet carries traffic for vSphere vMotion.
        """
        return pulumi.get(self, "v_motion")

    @_builtins.property
    @pulumi.getter(name="vSan")
    def v_san(self) -> 'outputs.EnvironmentInitialVlanInfo':
        """
        The vSAN VLAN subnet. This VLAN subnet carries the communication between ESXi hosts to implement a vSAN shared storage pool.
        """
        return pulumi.get(self, "v_san")

    @_builtins.property
    @pulumi.getter(name="vTep")
    def v_tep(self) -> 'outputs.EnvironmentInitialVlanInfo':
        """
        The VTEP VLAN subnet. This VLAN subnet handles internal network traffic between virtual machines within a VCF instance.
        """
        return pulumi.get(self, "v_tep")

    @_builtins.property
    @pulumi.getter(name="vmManagement")
    def vm_management(self) -> 'outputs.EnvironmentInitialVlanInfo':
        """
        The VM management VLAN subnet. This VLAN subnet carries traffic for vSphere virtual machines.
        """
        return pulumi.get(self, "vm_management")

    @_builtins.property
    @pulumi.getter(name="vmkManagement")
    def vmk_management(self) -> 'outputs.EnvironmentInitialVlanInfo':
        """
        The host VMkernel management VLAN subnet. This VLAN subnet carries traffic for managing ESXi hosts and communicating with VMware vCenter Server.
        """
        return pulumi.get(self, "vmk_management")

    @_builtins.property
    @pulumi.getter(name="hcxNetworkAclId")
    def hcx_network_acl_id(self) -> Optional[_builtins.str]:
        """
        A unique ID for a network access control list that the HCX VLAN uses. Required when `isHcxPublic` is set to `true` .
        """
        return pulumi.get(self, "hcx_network_acl_id")

    @_builtins.property
    @pulumi.getter(name="isHcxPublic")
    def is_hcx_public(self) -> Optional[_builtins.bool]:
        """
        Determines if the HCX VLAN that Amazon EVS provisions is public or private.
        """
        return pulumi.get(self, "is_hcx_public")


@pulumi.output_type
class LicenseInfoProperties(dict):
    """
    The license information for an EVS environment
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "solutionKey":
            suggest = "solution_key"
        elif key == "vsanKey":
            suggest = "vsan_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LicenseInfoProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LicenseInfoProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LicenseInfoProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 solution_key: _builtins.str,
                 vsan_key: _builtins.str):
        """
        The license information for an EVS environment
        :param _builtins.str solution_key: The VCF solution key. This license unlocks VMware VCF product features, including vSphere, NSX, SDDC Manager, and vCenter Server. The VCF solution key must cover a minimum of 256 cores.
        :param _builtins.str vsan_key: The VSAN license key. This license unlocks vSAN features. The vSAN license key must provide at least 110 TiB of vSAN capacity.
        """
        pulumi.set(__self__, "solution_key", solution_key)
        pulumi.set(__self__, "vsan_key", vsan_key)

    @_builtins.property
    @pulumi.getter(name="solutionKey")
    def solution_key(self) -> _builtins.str:
        """
        The VCF solution key. This license unlocks VMware VCF product features, including vSphere, NSX, SDDC Manager, and vCenter Server. The VCF solution key must cover a minimum of 256 cores.
        """
        return pulumi.get(self, "solution_key")

    @_builtins.property
    @pulumi.getter(name="vsanKey")
    def vsan_key(self) -> _builtins.str:
        """
        The VSAN license key. This license unlocks vSAN features. The vSAN license key must provide at least 110 TiB of vSAN capacity.
        """
        return pulumi.get(self, "vsan_key")


@pulumi.output_type
class ServiceAccessSecurityGroupsProperties(dict):
    """
    The security groups that allow traffic between the Amazon EVS control plane and your VPC for service access. If a security group is not specified, Amazon EVS uses the default security group in your account for service access.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityGroups":
            suggest = "security_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAccessSecurityGroupsProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAccessSecurityGroupsProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAccessSecurityGroupsProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 security_groups: Optional[Sequence[_builtins.str]] = None):
        """
        The security groups that allow traffic between the Amazon EVS control plane and your VPC for service access. If a security group is not specified, Amazon EVS uses the default security group in your account for service access.
        :param Sequence[_builtins.str] security_groups: The security groups that allow service access.
        """
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[_builtins.str]]:
        """
        The security groups that allow service access.
        """
        return pulumi.get(self, "security_groups")


@pulumi.output_type
class VcfHostnamesProperties(dict):
    """
    The DNS hostnames to be used by the VCF management appliances in your environment.

    For environment creation to be successful, each hostname entry must resolve to a domain name that you've registered in your DNS service of choice and configured in the DHCP option set of your VPC. DNS hostnames cannot be changed after environment creation has started.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudBuilder":
            suggest = "cloud_builder"
        elif key == "nsxEdge1":
            suggest = "nsx_edge1"
        elif key == "nsxEdge2":
            suggest = "nsx_edge2"
        elif key == "nsxManager1":
            suggest = "nsx_manager1"
        elif key == "nsxManager2":
            suggest = "nsx_manager2"
        elif key == "nsxManager3":
            suggest = "nsx_manager3"
        elif key == "sddcManager":
            suggest = "sddc_manager"
        elif key == "vCenter":
            suggest = "v_center"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VcfHostnamesProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VcfHostnamesProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VcfHostnamesProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_builder: _builtins.str,
                 nsx: _builtins.str,
                 nsx_edge1: _builtins.str,
                 nsx_edge2: _builtins.str,
                 nsx_manager1: _builtins.str,
                 nsx_manager2: _builtins.str,
                 nsx_manager3: _builtins.str,
                 sddc_manager: _builtins.str,
                 v_center: _builtins.str):
        """
        The DNS hostnames to be used by the VCF management appliances in your environment.

        For environment creation to be successful, each hostname entry must resolve to a domain name that you've registered in your DNS service of choice and configured in the DHCP option set of your VPC. DNS hostnames cannot be changed after environment creation has started.
        :param _builtins.str cloud_builder: The hostname for VMware Cloud Builder.
        :param _builtins.str nsx: The VMware NSX hostname.
        :param _builtins.str nsx_edge1: The hostname for the first NSX Edge node.
        :param _builtins.str nsx_edge2: The hostname for the second NSX Edge node.
        :param _builtins.str nsx_manager1: The hostname for the first VMware NSX Manager virtual machine (VM).
        :param _builtins.str nsx_manager2: The hostname for the second VMware NSX Manager virtual machine (VM).
        :param _builtins.str nsx_manager3: The hostname for the third VMware NSX Manager virtual machine (VM).
        :param _builtins.str sddc_manager: The hostname for SDDC Manager.
        :param _builtins.str v_center: The VMware vCenter hostname.
        """
        pulumi.set(__self__, "cloud_builder", cloud_builder)
        pulumi.set(__self__, "nsx", nsx)
        pulumi.set(__self__, "nsx_edge1", nsx_edge1)
        pulumi.set(__self__, "nsx_edge2", nsx_edge2)
        pulumi.set(__self__, "nsx_manager1", nsx_manager1)
        pulumi.set(__self__, "nsx_manager2", nsx_manager2)
        pulumi.set(__self__, "nsx_manager3", nsx_manager3)
        pulumi.set(__self__, "sddc_manager", sddc_manager)
        pulumi.set(__self__, "v_center", v_center)

    @_builtins.property
    @pulumi.getter(name="cloudBuilder")
    def cloud_builder(self) -> _builtins.str:
        """
        The hostname for VMware Cloud Builder.
        """
        return pulumi.get(self, "cloud_builder")

    @_builtins.property
    @pulumi.getter
    def nsx(self) -> _builtins.str:
        """
        The VMware NSX hostname.
        """
        return pulumi.get(self, "nsx")

    @_builtins.property
    @pulumi.getter(name="nsxEdge1")
    def nsx_edge1(self) -> _builtins.str:
        """
        The hostname for the first NSX Edge node.
        """
        return pulumi.get(self, "nsx_edge1")

    @_builtins.property
    @pulumi.getter(name="nsxEdge2")
    def nsx_edge2(self) -> _builtins.str:
        """
        The hostname for the second NSX Edge node.
        """
        return pulumi.get(self, "nsx_edge2")

    @_builtins.property
    @pulumi.getter(name="nsxManager1")
    def nsx_manager1(self) -> _builtins.str:
        """
        The hostname for the first VMware NSX Manager virtual machine (VM).
        """
        return pulumi.get(self, "nsx_manager1")

    @_builtins.property
    @pulumi.getter(name="nsxManager2")
    def nsx_manager2(self) -> _builtins.str:
        """
        The hostname for the second VMware NSX Manager virtual machine (VM).
        """
        return pulumi.get(self, "nsx_manager2")

    @_builtins.property
    @pulumi.getter(name="nsxManager3")
    def nsx_manager3(self) -> _builtins.str:
        """
        The hostname for the third VMware NSX Manager virtual machine (VM).
        """
        return pulumi.get(self, "nsx_manager3")

    @_builtins.property
    @pulumi.getter(name="sddcManager")
    def sddc_manager(self) -> _builtins.str:
        """
        The hostname for SDDC Manager.
        """
        return pulumi.get(self, "sddc_manager")

    @_builtins.property
    @pulumi.getter(name="vCenter")
    def v_center(self) -> _builtins.str:
        """
        The VMware vCenter hostname.
        """
        return pulumi.get(self, "v_center")


