# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'ConnectivityInfoPropertiesArgs',
    'ConnectivityInfoPropertiesArgsDict',
    'EnvironmentHostInfoForCreateArgs',
    'EnvironmentHostInfoForCreateArgsDict',
    'EnvironmentInitialVlanInfoArgs',
    'EnvironmentInitialVlanInfoArgsDict',
    'InitialVlansPropertiesArgs',
    'InitialVlansPropertiesArgsDict',
    'LicenseInfoPropertiesArgs',
    'LicenseInfoPropertiesArgsDict',
    'ServiceAccessSecurityGroupsPropertiesArgs',
    'ServiceAccessSecurityGroupsPropertiesArgsDict',
    'VcfHostnamesPropertiesArgs',
    'VcfHostnamesPropertiesArgsDict',
]

MYPY = False

if not MYPY:
    class ConnectivityInfoPropertiesArgsDict(TypedDict):
        """
        The connectivity configuration for the environment. Amazon EVS requires that you specify two route server peer IDs. During environment creation, the route server endpoints peer with the NSX uplink VLAN for connectivity to the NSX overlay network.
        """
        private_route_server_peerings: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The unique IDs for private route server peers.
        """
elif False:
    ConnectivityInfoPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectivityInfoPropertiesArgs:
    def __init__(__self__, *,
                 private_route_server_peerings: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        The connectivity configuration for the environment. Amazon EVS requires that you specify two route server peer IDs. During environment creation, the route server endpoints peer with the NSX uplink VLAN for connectivity to the NSX overlay network.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] private_route_server_peerings: The unique IDs for private route server peers.
        """
        pulumi.set(__self__, "private_route_server_peerings", private_route_server_peerings)

    @_builtins.property
    @pulumi.getter(name="privateRouteServerPeerings")
    def private_route_server_peerings(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The unique IDs for private route server peers.
        """
        return pulumi.get(self, "private_route_server_peerings")

    @private_route_server_peerings.setter
    def private_route_server_peerings(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "private_route_server_peerings", value)


if not MYPY:
    class EnvironmentHostInfoForCreateArgsDict(TypedDict):
        host_name: pulumi.Input[_builtins.str]
        """
        The DNS hostname of the host. DNS hostnames for hosts must be unique across Amazon EVS environments and within VCF.
        """
        instance_type: pulumi.Input['EnvironmentHostInfoForCreateInstanceType']
        """
        The EC2 instance type that represents the host.
        """
        key_name: pulumi.Input[_builtins.str]
        """
        The name of the SSH key that is used to access the host.
        """
        dedicated_host_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique ID of the Amazon EC2 Dedicated Host.
        """
        placement_group_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique ID of the placement group where the host is placed.
        """
elif False:
    EnvironmentHostInfoForCreateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EnvironmentHostInfoForCreateArgs:
    def __init__(__self__, *,
                 host_name: pulumi.Input[_builtins.str],
                 instance_type: pulumi.Input['EnvironmentHostInfoForCreateInstanceType'],
                 key_name: pulumi.Input[_builtins.str],
                 dedicated_host_id: Optional[pulumi.Input[_builtins.str]] = None,
                 placement_group_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host_name: The DNS hostname of the host. DNS hostnames for hosts must be unique across Amazon EVS environments and within VCF.
        :param pulumi.Input['EnvironmentHostInfoForCreateInstanceType'] instance_type: The EC2 instance type that represents the host.
        :param pulumi.Input[_builtins.str] key_name: The name of the SSH key that is used to access the host.
        :param pulumi.Input[_builtins.str] dedicated_host_id: The unique ID of the Amazon EC2 Dedicated Host.
        :param pulumi.Input[_builtins.str] placement_group_id: The unique ID of the placement group where the host is placed.
        """
        pulumi.set(__self__, "host_name", host_name)
        pulumi.set(__self__, "instance_type", instance_type)
        pulumi.set(__self__, "key_name", key_name)
        if dedicated_host_id is not None:
            pulumi.set(__self__, "dedicated_host_id", dedicated_host_id)
        if placement_group_id is not None:
            pulumi.set(__self__, "placement_group_id", placement_group_id)

    @_builtins.property
    @pulumi.getter(name="hostName")
    def host_name(self) -> pulumi.Input[_builtins.str]:
        """
        The DNS hostname of the host. DNS hostnames for hosts must be unique across Amazon EVS environments and within VCF.
        """
        return pulumi.get(self, "host_name")

    @host_name.setter
    def host_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host_name", value)

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> pulumi.Input['EnvironmentHostInfoForCreateInstanceType']:
        """
        The EC2 instance type that represents the host.
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: pulumi.Input['EnvironmentHostInfoForCreateInstanceType']):
        pulumi.set(self, "instance_type", value)

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the SSH key that is used to access the host.
        """
        return pulumi.get(self, "key_name")

    @key_name.setter
    def key_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_name", value)

    @_builtins.property
    @pulumi.getter(name="dedicatedHostId")
    def dedicated_host_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique ID of the Amazon EC2 Dedicated Host.
        """
        return pulumi.get(self, "dedicated_host_id")

    @dedicated_host_id.setter
    def dedicated_host_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dedicated_host_id", value)

    @_builtins.property
    @pulumi.getter(name="placementGroupId")
    def placement_group_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique ID of the placement group where the host is placed.
        """
        return pulumi.get(self, "placement_group_id")

    @placement_group_id.setter
    def placement_group_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "placement_group_id", value)


if not MYPY:
    class EnvironmentInitialVlanInfoArgsDict(TypedDict):
        cidr: pulumi.Input[_builtins.str]
        """
        The CIDR block that you provide to create an Amazon EVS VLAN subnet. Amazon EVS VLAN subnets have a minimum CIDR block size of /28 and a maximum size of /24. Amazon EVS VLAN subnet CIDR blocks must not overlap with other subnets in the VPC.
        """
elif False:
    EnvironmentInitialVlanInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EnvironmentInitialVlanInfoArgs:
    def __init__(__self__, *,
                 cidr: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] cidr: The CIDR block that you provide to create an Amazon EVS VLAN subnet. Amazon EVS VLAN subnets have a minimum CIDR block size of /28 and a maximum size of /24. Amazon EVS VLAN subnet CIDR blocks must not overlap with other subnets in the VPC.
        """
        pulumi.set(__self__, "cidr", cidr)

    @_builtins.property
    @pulumi.getter
    def cidr(self) -> pulumi.Input[_builtins.str]:
        """
        The CIDR block that you provide to create an Amazon EVS VLAN subnet. Amazon EVS VLAN subnets have a minimum CIDR block size of /28 and a maximum size of /24. Amazon EVS VLAN subnet CIDR blocks must not overlap with other subnets in the VPC.
        """
        return pulumi.get(self, "cidr")

    @cidr.setter
    def cidr(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cidr", value)


if not MYPY:
    class InitialVlansPropertiesArgsDict(TypedDict):
        """
        The initial Vlan configuration only required upon creation. Modification after creation will have no effect
        """
        edge_v_tep: pulumi.Input['EnvironmentInitialVlanInfoArgsDict']
        """
        The edge VTEP VLAN subnet. This VLAN subnet manages traffic flowing between the internal network and external networks, including internet access and other site connections.
        """
        expansion_vlan1: pulumi.Input['EnvironmentInitialVlanInfoArgsDict']
        """
        An additional VLAN subnet that can be used to extend VCF capabilities once configured. For example, you can configure an expansion VLAN subnet to use NSX Federation for centralized management and synchronization of multiple NSX deployments across different locations.
        """
        expansion_vlan2: pulumi.Input['EnvironmentInitialVlanInfoArgsDict']
        """
        An additional VLAN subnet that can be used to extend VCF capabilities once configured. For example, you can configure an expansion VLAN subnet to use NSX Federation for centralized management and synchronization of multiple NSX deployments across different locations.
        """
        hcx: pulumi.Input['EnvironmentInitialVlanInfoArgsDict']
        """
        The HCX VLAN subnet. This VLAN subnet allows the HCX Interconnnect (IX) and HCX Network Extension (NE) to reach their peers and enable HCX Service Mesh creation.

        If you plan to use a public HCX VLAN subnet, the following requirements must be met:

        - Must have a /28 netmask and be allocated from the IPAM public pool. Required for HCX internet access configuration.
        - The HCX public VLAN CIDR block must be added to the VPC as a secondary CIDR block.
        - Must have at least two Elastic IP addresses to be allocated from the public IPAM pool for HCX components.
        """
        nsx_up_link: pulumi.Input['EnvironmentInitialVlanInfoArgsDict']
        """
        The NSX uplink VLAN subnet. This VLAN subnet allows connectivity to the NSX overlay network.
        """
        v_motion: pulumi.Input['EnvironmentInitialVlanInfoArgsDict']
        """
        The vMotion VLAN subnet. This VLAN subnet carries traffic for vSphere vMotion.
        """
        v_san: pulumi.Input['EnvironmentInitialVlanInfoArgsDict']
        """
        The vSAN VLAN subnet. This VLAN subnet carries the communication between ESXi hosts to implement a vSAN shared storage pool.
        """
        v_tep: pulumi.Input['EnvironmentInitialVlanInfoArgsDict']
        """
        The VTEP VLAN subnet. This VLAN subnet handles internal network traffic between virtual machines within a VCF instance.
        """
        vm_management: pulumi.Input['EnvironmentInitialVlanInfoArgsDict']
        """
        The VM management VLAN subnet. This VLAN subnet carries traffic for vSphere virtual machines.
        """
        vmk_management: pulumi.Input['EnvironmentInitialVlanInfoArgsDict']
        """
        The host VMkernel management VLAN subnet. This VLAN subnet carries traffic for managing ESXi hosts and communicating with VMware vCenter Server.
        """
        hcx_network_acl_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        A unique ID for a network access control list that the HCX VLAN uses. Required when `isHcxPublic` is set to `true` .
        """
        is_hcx_public: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Determines if the HCX VLAN that Amazon EVS provisions is public or private.
        """
elif False:
    InitialVlansPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InitialVlansPropertiesArgs:
    def __init__(__self__, *,
                 edge_v_tep: pulumi.Input['EnvironmentInitialVlanInfoArgs'],
                 expansion_vlan1: pulumi.Input['EnvironmentInitialVlanInfoArgs'],
                 expansion_vlan2: pulumi.Input['EnvironmentInitialVlanInfoArgs'],
                 hcx: pulumi.Input['EnvironmentInitialVlanInfoArgs'],
                 nsx_up_link: pulumi.Input['EnvironmentInitialVlanInfoArgs'],
                 v_motion: pulumi.Input['EnvironmentInitialVlanInfoArgs'],
                 v_san: pulumi.Input['EnvironmentInitialVlanInfoArgs'],
                 v_tep: pulumi.Input['EnvironmentInitialVlanInfoArgs'],
                 vm_management: pulumi.Input['EnvironmentInitialVlanInfoArgs'],
                 vmk_management: pulumi.Input['EnvironmentInitialVlanInfoArgs'],
                 hcx_network_acl_id: Optional[pulumi.Input[_builtins.str]] = None,
                 is_hcx_public: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        The initial Vlan configuration only required upon creation. Modification after creation will have no effect
        :param pulumi.Input['EnvironmentInitialVlanInfoArgs'] edge_v_tep: The edge VTEP VLAN subnet. This VLAN subnet manages traffic flowing between the internal network and external networks, including internet access and other site connections.
        :param pulumi.Input['EnvironmentInitialVlanInfoArgs'] expansion_vlan1: An additional VLAN subnet that can be used to extend VCF capabilities once configured. For example, you can configure an expansion VLAN subnet to use NSX Federation for centralized management and synchronization of multiple NSX deployments across different locations.
        :param pulumi.Input['EnvironmentInitialVlanInfoArgs'] expansion_vlan2: An additional VLAN subnet that can be used to extend VCF capabilities once configured. For example, you can configure an expansion VLAN subnet to use NSX Federation for centralized management and synchronization of multiple NSX deployments across different locations.
        :param pulumi.Input['EnvironmentInitialVlanInfoArgs'] hcx: The HCX VLAN subnet. This VLAN subnet allows the HCX Interconnnect (IX) and HCX Network Extension (NE) to reach their peers and enable HCX Service Mesh creation.
               
               If you plan to use a public HCX VLAN subnet, the following requirements must be met:
               
               - Must have a /28 netmask and be allocated from the IPAM public pool. Required for HCX internet access configuration.
               - The HCX public VLAN CIDR block must be added to the VPC as a secondary CIDR block.
               - Must have at least two Elastic IP addresses to be allocated from the public IPAM pool for HCX components.
        :param pulumi.Input['EnvironmentInitialVlanInfoArgs'] nsx_up_link: The NSX uplink VLAN subnet. This VLAN subnet allows connectivity to the NSX overlay network.
        :param pulumi.Input['EnvironmentInitialVlanInfoArgs'] v_motion: The vMotion VLAN subnet. This VLAN subnet carries traffic for vSphere vMotion.
        :param pulumi.Input['EnvironmentInitialVlanInfoArgs'] v_san: The vSAN VLAN subnet. This VLAN subnet carries the communication between ESXi hosts to implement a vSAN shared storage pool.
        :param pulumi.Input['EnvironmentInitialVlanInfoArgs'] v_tep: The VTEP VLAN subnet. This VLAN subnet handles internal network traffic between virtual machines within a VCF instance.
        :param pulumi.Input['EnvironmentInitialVlanInfoArgs'] vm_management: The VM management VLAN subnet. This VLAN subnet carries traffic for vSphere virtual machines.
        :param pulumi.Input['EnvironmentInitialVlanInfoArgs'] vmk_management: The host VMkernel management VLAN subnet. This VLAN subnet carries traffic for managing ESXi hosts and communicating with VMware vCenter Server.
        :param pulumi.Input[_builtins.str] hcx_network_acl_id: A unique ID for a network access control list that the HCX VLAN uses. Required when `isHcxPublic` is set to `true` .
        :param pulumi.Input[_builtins.bool] is_hcx_public: Determines if the HCX VLAN that Amazon EVS provisions is public or private.
        """
        pulumi.set(__self__, "edge_v_tep", edge_v_tep)
        pulumi.set(__self__, "expansion_vlan1", expansion_vlan1)
        pulumi.set(__self__, "expansion_vlan2", expansion_vlan2)
        pulumi.set(__self__, "hcx", hcx)
        pulumi.set(__self__, "nsx_up_link", nsx_up_link)
        pulumi.set(__self__, "v_motion", v_motion)
        pulumi.set(__self__, "v_san", v_san)
        pulumi.set(__self__, "v_tep", v_tep)
        pulumi.set(__self__, "vm_management", vm_management)
        pulumi.set(__self__, "vmk_management", vmk_management)
        if hcx_network_acl_id is not None:
            pulumi.set(__self__, "hcx_network_acl_id", hcx_network_acl_id)
        if is_hcx_public is not None:
            pulumi.set(__self__, "is_hcx_public", is_hcx_public)

    @_builtins.property
    @pulumi.getter(name="edgeVTep")
    def edge_v_tep(self) -> pulumi.Input['EnvironmentInitialVlanInfoArgs']:
        """
        The edge VTEP VLAN subnet. This VLAN subnet manages traffic flowing between the internal network and external networks, including internet access and other site connections.
        """
        return pulumi.get(self, "edge_v_tep")

    @edge_v_tep.setter
    def edge_v_tep(self, value: pulumi.Input['EnvironmentInitialVlanInfoArgs']):
        pulumi.set(self, "edge_v_tep", value)

    @_builtins.property
    @pulumi.getter(name="expansionVlan1")
    def expansion_vlan1(self) -> pulumi.Input['EnvironmentInitialVlanInfoArgs']:
        """
        An additional VLAN subnet that can be used to extend VCF capabilities once configured. For example, you can configure an expansion VLAN subnet to use NSX Federation for centralized management and synchronization of multiple NSX deployments across different locations.
        """
        return pulumi.get(self, "expansion_vlan1")

    @expansion_vlan1.setter
    def expansion_vlan1(self, value: pulumi.Input['EnvironmentInitialVlanInfoArgs']):
        pulumi.set(self, "expansion_vlan1", value)

    @_builtins.property
    @pulumi.getter(name="expansionVlan2")
    def expansion_vlan2(self) -> pulumi.Input['EnvironmentInitialVlanInfoArgs']:
        """
        An additional VLAN subnet that can be used to extend VCF capabilities once configured. For example, you can configure an expansion VLAN subnet to use NSX Federation for centralized management and synchronization of multiple NSX deployments across different locations.
        """
        return pulumi.get(self, "expansion_vlan2")

    @expansion_vlan2.setter
    def expansion_vlan2(self, value: pulumi.Input['EnvironmentInitialVlanInfoArgs']):
        pulumi.set(self, "expansion_vlan2", value)

    @_builtins.property
    @pulumi.getter
    def hcx(self) -> pulumi.Input['EnvironmentInitialVlanInfoArgs']:
        """
        The HCX VLAN subnet. This VLAN subnet allows the HCX Interconnnect (IX) and HCX Network Extension (NE) to reach their peers and enable HCX Service Mesh creation.

        If you plan to use a public HCX VLAN subnet, the following requirements must be met:

        - Must have a /28 netmask and be allocated from the IPAM public pool. Required for HCX internet access configuration.
        - The HCX public VLAN CIDR block must be added to the VPC as a secondary CIDR block.
        - Must have at least two Elastic IP addresses to be allocated from the public IPAM pool for HCX components.
        """
        return pulumi.get(self, "hcx")

    @hcx.setter
    def hcx(self, value: pulumi.Input['EnvironmentInitialVlanInfoArgs']):
        pulumi.set(self, "hcx", value)

    @_builtins.property
    @pulumi.getter(name="nsxUpLink")
    def nsx_up_link(self) -> pulumi.Input['EnvironmentInitialVlanInfoArgs']:
        """
        The NSX uplink VLAN subnet. This VLAN subnet allows connectivity to the NSX overlay network.
        """
        return pulumi.get(self, "nsx_up_link")

    @nsx_up_link.setter
    def nsx_up_link(self, value: pulumi.Input['EnvironmentInitialVlanInfoArgs']):
        pulumi.set(self, "nsx_up_link", value)

    @_builtins.property
    @pulumi.getter(name="vMotion")
    def v_motion(self) -> pulumi.Input['EnvironmentInitialVlanInfoArgs']:
        """
        The vMotion VLAN subnet. This VLAN subnet carries traffic for vSphere vMotion.
        """
        return pulumi.get(self, "v_motion")

    @v_motion.setter
    def v_motion(self, value: pulumi.Input['EnvironmentInitialVlanInfoArgs']):
        pulumi.set(self, "v_motion", value)

    @_builtins.property
    @pulumi.getter(name="vSan")
    def v_san(self) -> pulumi.Input['EnvironmentInitialVlanInfoArgs']:
        """
        The vSAN VLAN subnet. This VLAN subnet carries the communication between ESXi hosts to implement a vSAN shared storage pool.
        """
        return pulumi.get(self, "v_san")

    @v_san.setter
    def v_san(self, value: pulumi.Input['EnvironmentInitialVlanInfoArgs']):
        pulumi.set(self, "v_san", value)

    @_builtins.property
    @pulumi.getter(name="vTep")
    def v_tep(self) -> pulumi.Input['EnvironmentInitialVlanInfoArgs']:
        """
        The VTEP VLAN subnet. This VLAN subnet handles internal network traffic between virtual machines within a VCF instance.
        """
        return pulumi.get(self, "v_tep")

    @v_tep.setter
    def v_tep(self, value: pulumi.Input['EnvironmentInitialVlanInfoArgs']):
        pulumi.set(self, "v_tep", value)

    @_builtins.property
    @pulumi.getter(name="vmManagement")
    def vm_management(self) -> pulumi.Input['EnvironmentInitialVlanInfoArgs']:
        """
        The VM management VLAN subnet. This VLAN subnet carries traffic for vSphere virtual machines.
        """
        return pulumi.get(self, "vm_management")

    @vm_management.setter
    def vm_management(self, value: pulumi.Input['EnvironmentInitialVlanInfoArgs']):
        pulumi.set(self, "vm_management", value)

    @_builtins.property
    @pulumi.getter(name="vmkManagement")
    def vmk_management(self) -> pulumi.Input['EnvironmentInitialVlanInfoArgs']:
        """
        The host VMkernel management VLAN subnet. This VLAN subnet carries traffic for managing ESXi hosts and communicating with VMware vCenter Server.
        """
        return pulumi.get(self, "vmk_management")

    @vmk_management.setter
    def vmk_management(self, value: pulumi.Input['EnvironmentInitialVlanInfoArgs']):
        pulumi.set(self, "vmk_management", value)

    @_builtins.property
    @pulumi.getter(name="hcxNetworkAclId")
    def hcx_network_acl_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A unique ID for a network access control list that the HCX VLAN uses. Required when `isHcxPublic` is set to `true` .
        """
        return pulumi.get(self, "hcx_network_acl_id")

    @hcx_network_acl_id.setter
    def hcx_network_acl_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hcx_network_acl_id", value)

    @_builtins.property
    @pulumi.getter(name="isHcxPublic")
    def is_hcx_public(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines if the HCX VLAN that Amazon EVS provisions is public or private.
        """
        return pulumi.get(self, "is_hcx_public")

    @is_hcx_public.setter
    def is_hcx_public(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_hcx_public", value)


if not MYPY:
    class LicenseInfoPropertiesArgsDict(TypedDict):
        """
        The license information for an EVS environment
        """
        solution_key: pulumi.Input[_builtins.str]
        """
        The VCF solution key. This license unlocks VMware VCF product features, including vSphere, NSX, SDDC Manager, and vCenter Server. The VCF solution key must cover a minimum of 256 cores.
        """
        vsan_key: pulumi.Input[_builtins.str]
        """
        The VSAN license key. This license unlocks vSAN features. The vSAN license key must provide at least 110 TiB of vSAN capacity.
        """
elif False:
    LicenseInfoPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LicenseInfoPropertiesArgs:
    def __init__(__self__, *,
                 solution_key: pulumi.Input[_builtins.str],
                 vsan_key: pulumi.Input[_builtins.str]):
        """
        The license information for an EVS environment
        :param pulumi.Input[_builtins.str] solution_key: The VCF solution key. This license unlocks VMware VCF product features, including vSphere, NSX, SDDC Manager, and vCenter Server. The VCF solution key must cover a minimum of 256 cores.
        :param pulumi.Input[_builtins.str] vsan_key: The VSAN license key. This license unlocks vSAN features. The vSAN license key must provide at least 110 TiB of vSAN capacity.
        """
        pulumi.set(__self__, "solution_key", solution_key)
        pulumi.set(__self__, "vsan_key", vsan_key)

    @_builtins.property
    @pulumi.getter(name="solutionKey")
    def solution_key(self) -> pulumi.Input[_builtins.str]:
        """
        The VCF solution key. This license unlocks VMware VCF product features, including vSphere, NSX, SDDC Manager, and vCenter Server. The VCF solution key must cover a minimum of 256 cores.
        """
        return pulumi.get(self, "solution_key")

    @solution_key.setter
    def solution_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "solution_key", value)

    @_builtins.property
    @pulumi.getter(name="vsanKey")
    def vsan_key(self) -> pulumi.Input[_builtins.str]:
        """
        The VSAN license key. This license unlocks vSAN features. The vSAN license key must provide at least 110 TiB of vSAN capacity.
        """
        return pulumi.get(self, "vsan_key")

    @vsan_key.setter
    def vsan_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vsan_key", value)


if not MYPY:
    class ServiceAccessSecurityGroupsPropertiesArgsDict(TypedDict):
        """
        The security groups that allow traffic between the Amazon EVS control plane and your VPC for service access. If a security group is not specified, Amazon EVS uses the default security group in your account for service access.
        """
        security_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The security groups that allow service access.
        """
elif False:
    ServiceAccessSecurityGroupsPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceAccessSecurityGroupsPropertiesArgs:
    def __init__(__self__, *,
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        The security groups that allow traffic between the Amazon EVS control plane and your VPC for service access. If a security group is not specified, Amazon EVS uses the default security group in your account for service access.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] security_groups: The security groups that allow service access.
        """
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)

    @_builtins.property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The security groups that allow service access.
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "security_groups", value)


if not MYPY:
    class VcfHostnamesPropertiesArgsDict(TypedDict):
        """
        The DNS hostnames to be used by the VCF management appliances in your environment.

        For environment creation to be successful, each hostname entry must resolve to a domain name that you've registered in your DNS service of choice and configured in the DHCP option set of your VPC. DNS hostnames cannot be changed after environment creation has started.
        """
        cloud_builder: pulumi.Input[_builtins.str]
        """
        The hostname for VMware Cloud Builder.
        """
        nsx: pulumi.Input[_builtins.str]
        """
        The VMware NSX hostname.
        """
        nsx_edge1: pulumi.Input[_builtins.str]
        """
        The hostname for the first NSX Edge node.
        """
        nsx_edge2: pulumi.Input[_builtins.str]
        """
        The hostname for the second NSX Edge node.
        """
        nsx_manager1: pulumi.Input[_builtins.str]
        """
        The hostname for the first VMware NSX Manager virtual machine (VM).
        """
        nsx_manager2: pulumi.Input[_builtins.str]
        """
        The hostname for the second VMware NSX Manager virtual machine (VM).
        """
        nsx_manager3: pulumi.Input[_builtins.str]
        """
        The hostname for the third VMware NSX Manager virtual machine (VM).
        """
        sddc_manager: pulumi.Input[_builtins.str]
        """
        The hostname for SDDC Manager.
        """
        v_center: pulumi.Input[_builtins.str]
        """
        The VMware vCenter hostname.
        """
elif False:
    VcfHostnamesPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VcfHostnamesPropertiesArgs:
    def __init__(__self__, *,
                 cloud_builder: pulumi.Input[_builtins.str],
                 nsx: pulumi.Input[_builtins.str],
                 nsx_edge1: pulumi.Input[_builtins.str],
                 nsx_edge2: pulumi.Input[_builtins.str],
                 nsx_manager1: pulumi.Input[_builtins.str],
                 nsx_manager2: pulumi.Input[_builtins.str],
                 nsx_manager3: pulumi.Input[_builtins.str],
                 sddc_manager: pulumi.Input[_builtins.str],
                 v_center: pulumi.Input[_builtins.str]):
        """
        The DNS hostnames to be used by the VCF management appliances in your environment.

        For environment creation to be successful, each hostname entry must resolve to a domain name that you've registered in your DNS service of choice and configured in the DHCP option set of your VPC. DNS hostnames cannot be changed after environment creation has started.
        :param pulumi.Input[_builtins.str] cloud_builder: The hostname for VMware Cloud Builder.
        :param pulumi.Input[_builtins.str] nsx: The VMware NSX hostname.
        :param pulumi.Input[_builtins.str] nsx_edge1: The hostname for the first NSX Edge node.
        :param pulumi.Input[_builtins.str] nsx_edge2: The hostname for the second NSX Edge node.
        :param pulumi.Input[_builtins.str] nsx_manager1: The hostname for the first VMware NSX Manager virtual machine (VM).
        :param pulumi.Input[_builtins.str] nsx_manager2: The hostname for the second VMware NSX Manager virtual machine (VM).
        :param pulumi.Input[_builtins.str] nsx_manager3: The hostname for the third VMware NSX Manager virtual machine (VM).
        :param pulumi.Input[_builtins.str] sddc_manager: The hostname for SDDC Manager.
        :param pulumi.Input[_builtins.str] v_center: The VMware vCenter hostname.
        """
        pulumi.set(__self__, "cloud_builder", cloud_builder)
        pulumi.set(__self__, "nsx", nsx)
        pulumi.set(__self__, "nsx_edge1", nsx_edge1)
        pulumi.set(__self__, "nsx_edge2", nsx_edge2)
        pulumi.set(__self__, "nsx_manager1", nsx_manager1)
        pulumi.set(__self__, "nsx_manager2", nsx_manager2)
        pulumi.set(__self__, "nsx_manager3", nsx_manager3)
        pulumi.set(__self__, "sddc_manager", sddc_manager)
        pulumi.set(__self__, "v_center", v_center)

    @_builtins.property
    @pulumi.getter(name="cloudBuilder")
    def cloud_builder(self) -> pulumi.Input[_builtins.str]:
        """
        The hostname for VMware Cloud Builder.
        """
        return pulumi.get(self, "cloud_builder")

    @cloud_builder.setter
    def cloud_builder(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cloud_builder", value)

    @_builtins.property
    @pulumi.getter
    def nsx(self) -> pulumi.Input[_builtins.str]:
        """
        The VMware NSX hostname.
        """
        return pulumi.get(self, "nsx")

    @nsx.setter
    def nsx(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "nsx", value)

    @_builtins.property
    @pulumi.getter(name="nsxEdge1")
    def nsx_edge1(self) -> pulumi.Input[_builtins.str]:
        """
        The hostname for the first NSX Edge node.
        """
        return pulumi.get(self, "nsx_edge1")

    @nsx_edge1.setter
    def nsx_edge1(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "nsx_edge1", value)

    @_builtins.property
    @pulumi.getter(name="nsxEdge2")
    def nsx_edge2(self) -> pulumi.Input[_builtins.str]:
        """
        The hostname for the second NSX Edge node.
        """
        return pulumi.get(self, "nsx_edge2")

    @nsx_edge2.setter
    def nsx_edge2(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "nsx_edge2", value)

    @_builtins.property
    @pulumi.getter(name="nsxManager1")
    def nsx_manager1(self) -> pulumi.Input[_builtins.str]:
        """
        The hostname for the first VMware NSX Manager virtual machine (VM).
        """
        return pulumi.get(self, "nsx_manager1")

    @nsx_manager1.setter
    def nsx_manager1(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "nsx_manager1", value)

    @_builtins.property
    @pulumi.getter(name="nsxManager2")
    def nsx_manager2(self) -> pulumi.Input[_builtins.str]:
        """
        The hostname for the second VMware NSX Manager virtual machine (VM).
        """
        return pulumi.get(self, "nsx_manager2")

    @nsx_manager2.setter
    def nsx_manager2(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "nsx_manager2", value)

    @_builtins.property
    @pulumi.getter(name="nsxManager3")
    def nsx_manager3(self) -> pulumi.Input[_builtins.str]:
        """
        The hostname for the third VMware NSX Manager virtual machine (VM).
        """
        return pulumi.get(self, "nsx_manager3")

    @nsx_manager3.setter
    def nsx_manager3(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "nsx_manager3", value)

    @_builtins.property
    @pulumi.getter(name="sddcManager")
    def sddc_manager(self) -> pulumi.Input[_builtins.str]:
        """
        The hostname for SDDC Manager.
        """
        return pulumi.get(self, "sddc_manager")

    @sddc_manager.setter
    def sddc_manager(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "sddc_manager", value)

    @_builtins.property
    @pulumi.getter(name="vCenter")
    def v_center(self) -> pulumi.Input[_builtins.str]:
        """
        The VMware vCenter hostname.
        """
        return pulumi.get(self, "v_center")

    @v_center.setter
    def v_center(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "v_center", value)


