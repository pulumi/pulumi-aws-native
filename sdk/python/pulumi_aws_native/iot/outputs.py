# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AbortConfigProperties',
    'AccountAuditConfigurationAuditCheckConfiguration',
    'AccountAuditConfigurationAuditCheckConfigurations',
    'AccountAuditConfigurationAuditNotificationTarget',
    'AccountAuditConfigurationAuditNotificationTargetConfigurations',
    'BillingGroupPropertiesProperties',
    'CaCertificateRegistrationConfig',
    'DomainConfigurationAuthorizerConfig',
    'DomainConfigurationServerCertificateConfig',
    'DomainConfigurationServerCertificateSummary',
    'DomainConfigurationTlsConfig',
    'FleetMetricAggregationType',
    'JobExecutionsRetryConfigProperties',
    'JobExecutionsRolloutConfigProperties',
    'JobTemplateAbortCriteria',
    'JobTemplateExponentialRolloutRate',
    'JobTemplateMaintenanceWindow',
    'JobTemplateRateIncreaseCriteria',
    'JobTemplateRetryCriteria',
    'MetricsExportConfigProperties',
    'MitigationActionActionParams',
    'MitigationActionAddThingsToThingGroupParams',
    'MitigationActionEnableIoTLoggingParams',
    'MitigationActionPublishFindingToSnsParams',
    'MitigationActionReplaceDefaultPolicyVersionParams',
    'MitigationActionUpdateCaCertificateParams',
    'MitigationActionUpdateDeviceCertificateParams',
    'PresignedUrlConfigProperties',
    'ProvisioningTemplateProvisioningHook',
    'SecurityProfileAlertTarget',
    'SecurityProfileBehavior',
    'SecurityProfileBehaviorCriteria',
    'SecurityProfileMachineLearningDetectionConfig',
    'SecurityProfileMetricDimension',
    'SecurityProfileMetricToRetain',
    'SecurityProfileMetricValue',
    'SecurityProfileStatisticalThreshold',
    'ThingAttributePayload',
    'ThingGroupAttributePayload',
    'ThingGroupPropertiesProperties',
    'ThingTypePropertiesProperties',
    'TimeoutConfigProperties',
    'TopicRuleAction',
    'TopicRuleAssetPropertyTimestamp',
    'TopicRuleAssetPropertyValue',
    'TopicRuleAssetPropertyVariant',
    'TopicRuleCloudwatchAlarmAction',
    'TopicRuleCloudwatchLogsAction',
    'TopicRuleCloudwatchMetricAction',
    'TopicRuleDestinationHttpUrlDestinationSummary',
    'TopicRuleDestinationVpcDestinationProperties',
    'TopicRuleDynamoDBv2Action',
    'TopicRuleDynamoDbAction',
    'TopicRuleElasticsearchAction',
    'TopicRuleFirehoseAction',
    'TopicRuleHttpAction',
    'TopicRuleHttpActionHeader',
    'TopicRuleHttpAuthorization',
    'TopicRuleIotAnalyticsAction',
    'TopicRuleIotEventsAction',
    'TopicRuleIotSiteWiseAction',
    'TopicRuleKafkaAction',
    'TopicRuleKafkaActionHeader',
    'TopicRuleKinesisAction',
    'TopicRuleLambdaAction',
    'TopicRuleLocationAction',
    'TopicRuleOpenSearchAction',
    'TopicRulePayload',
    'TopicRulePutAssetPropertyValueEntry',
    'TopicRulePutItemInput',
    'TopicRuleRepublishAction',
    'TopicRuleRepublishActionHeaders',
    'TopicRuleS3Action',
    'TopicRuleSigV4Authorization',
    'TopicRuleSnsAction',
    'TopicRuleSqsAction',
    'TopicRuleStepFunctionsAction',
    'TopicRuleTimestamp',
    'TopicRuleTimestreamAction',
    'TopicRuleTimestreamDimension',
    'TopicRuleTimestreamTimestamp',
    'TopicRuleUserProperty',
]

@pulumi.output_type
class AbortConfigProperties(dict):
    """
    The criteria that determine when and how a job abort takes place.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "criteriaList":
            suggest = "criteria_list"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AbortConfigProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AbortConfigProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AbortConfigProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 criteria_list: Sequence['outputs.JobTemplateAbortCriteria']):
        """
        The criteria that determine when and how a job abort takes place.
        :param Sequence['JobTemplateAbortCriteria'] criteria_list: The list of criteria that determine when and how to abort the job.
        """
        pulumi.set(__self__, "criteria_list", criteria_list)

    @property
    @pulumi.getter(name="criteriaList")
    def criteria_list(self) -> Sequence['outputs.JobTemplateAbortCriteria']:
        """
        The list of criteria that determine when and how to abort the job.
        """
        return pulumi.get(self, "criteria_list")


@pulumi.output_type
class AccountAuditConfigurationAuditCheckConfiguration(dict):
    """
    The configuration for a specific audit check.
    """
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        The configuration for a specific audit check.
        :param bool enabled: True if the check is enabled.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        True if the check is enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class AccountAuditConfigurationAuditCheckConfigurations(dict):
    """
    Specifies which audit checks are enabled and disabled for this account.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticatedCognitoRoleOverlyPermissiveCheck":
            suggest = "authenticated_cognito_role_overly_permissive_check"
        elif key == "caCertificateExpiringCheck":
            suggest = "ca_certificate_expiring_check"
        elif key == "caCertificateKeyQualityCheck":
            suggest = "ca_certificate_key_quality_check"
        elif key == "conflictingClientIdsCheck":
            suggest = "conflicting_client_ids_check"
        elif key == "deviceCertificateExpiringCheck":
            suggest = "device_certificate_expiring_check"
        elif key == "deviceCertificateKeyQualityCheck":
            suggest = "device_certificate_key_quality_check"
        elif key == "deviceCertificateSharedCheck":
            suggest = "device_certificate_shared_check"
        elif key == "intermediateCaRevokedForActiveDeviceCertificatesCheck":
            suggest = "intermediate_ca_revoked_for_active_device_certificates_check"
        elif key == "ioTPolicyPotentialMisConfigurationCheck":
            suggest = "io_t_policy_potential_mis_configuration_check"
        elif key == "iotPolicyOverlyPermissiveCheck":
            suggest = "iot_policy_overly_permissive_check"
        elif key == "iotRoleAliasAllowsAccessToUnusedServicesCheck":
            suggest = "iot_role_alias_allows_access_to_unused_services_check"
        elif key == "iotRoleAliasOverlyPermissiveCheck":
            suggest = "iot_role_alias_overly_permissive_check"
        elif key == "loggingDisabledCheck":
            suggest = "logging_disabled_check"
        elif key == "revokedCaCertificateStillActiveCheck":
            suggest = "revoked_ca_certificate_still_active_check"
        elif key == "revokedDeviceCertificateStillActiveCheck":
            suggest = "revoked_device_certificate_still_active_check"
        elif key == "unauthenticatedCognitoRoleOverlyPermissiveCheck":
            suggest = "unauthenticated_cognito_role_overly_permissive_check"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountAuditConfigurationAuditCheckConfigurations. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountAuditConfigurationAuditCheckConfigurations.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountAuditConfigurationAuditCheckConfigurations.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authenticated_cognito_role_overly_permissive_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
                 ca_certificate_expiring_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
                 ca_certificate_key_quality_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
                 conflicting_client_ids_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
                 device_certificate_expiring_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
                 device_certificate_key_quality_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
                 device_certificate_shared_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
                 intermediate_ca_revoked_for_active_device_certificates_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
                 io_t_policy_potential_mis_configuration_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
                 iot_policy_overly_permissive_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
                 iot_role_alias_allows_access_to_unused_services_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
                 iot_role_alias_overly_permissive_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
                 logging_disabled_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
                 revoked_ca_certificate_still_active_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
                 revoked_device_certificate_still_active_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
                 unauthenticated_cognito_role_overly_permissive_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None):
        """
        Specifies which audit checks are enabled and disabled for this account.
        :param 'AccountAuditConfigurationAuditCheckConfiguration' authenticated_cognito_role_overly_permissive_check: Checks the permissiveness of an authenticated Amazon Cognito identity pool role. For this check, AWS IoT Device Defender audits all Amazon Cognito identity pools that have been used to connect to the AWS IoT message broker during the 31 days before the audit is performed.
        :param 'AccountAuditConfigurationAuditCheckConfiguration' ca_certificate_expiring_check: Checks if a CA certificate is expiring. This check applies to CA certificates expiring within 30 days or that have expired.
        :param 'AccountAuditConfigurationAuditCheckConfiguration' ca_certificate_key_quality_check: Checks the quality of the CA certificate key. The quality checks if the key is in a valid format, not expired, and if the key meets a minimum required size. This check applies to CA certificates that are `ACTIVE` or `PENDING_TRANSFER` .
        :param 'AccountAuditConfigurationAuditCheckConfiguration' conflicting_client_ids_check: Checks if multiple devices connect using the same client ID.
        :param 'AccountAuditConfigurationAuditCheckConfiguration' device_certificate_expiring_check: Checks if a device certificate is expiring. This check applies to device certificates expiring within 30 days or that have expired.
        :param 'AccountAuditConfigurationAuditCheckConfiguration' device_certificate_key_quality_check: Checks the quality of the device certificate key. The quality checks if the key is in a valid format, not expired, signed by a registered certificate authority, and if the key meets a minimum required size.
        :param 'AccountAuditConfigurationAuditCheckConfiguration' device_certificate_shared_check: Checks if multiple concurrent connections use the same X.509 certificate to authenticate with AWS IoT .
        :param 'AccountAuditConfigurationAuditCheckConfiguration' intermediate_ca_revoked_for_active_device_certificates_check: Checks if device certificates are still active despite being revoked by an intermediate CA.
        :param 'AccountAuditConfigurationAuditCheckConfiguration' io_t_policy_potential_mis_configuration_check: Checks if an AWS IoT policy is potentially misconfigured. Misconfigured policies, including overly permissive policies, can cause security incidents like allowing devices access to unintended resources. This check is a warning for you to make sure that only intended actions are allowed before updating the policy.
        :param 'AccountAuditConfigurationAuditCheckConfiguration' iot_policy_overly_permissive_check: Checks the permissiveness of a policy attached to an authenticated Amazon Cognito identity pool role.
        :param 'AccountAuditConfigurationAuditCheckConfiguration' iot_role_alias_allows_access_to_unused_services_check: Checks if a role alias has access to services that haven't been used for the AWS IoT device in the last year.
        :param 'AccountAuditConfigurationAuditCheckConfiguration' iot_role_alias_overly_permissive_check: Checks if the temporary credentials provided by AWS IoT role aliases are overly permissive.
        :param 'AccountAuditConfigurationAuditCheckConfiguration' logging_disabled_check: Checks if AWS IoT logs are disabled.
        :param 'AccountAuditConfigurationAuditCheckConfiguration' revoked_ca_certificate_still_active_check: Checks if a revoked CA certificate is still active.
        :param 'AccountAuditConfigurationAuditCheckConfiguration' revoked_device_certificate_still_active_check: Checks if a revoked device certificate is still active.
        :param 'AccountAuditConfigurationAuditCheckConfiguration' unauthenticated_cognito_role_overly_permissive_check: Checks if policy attached to an unauthenticated Amazon Cognito identity pool role is too permissive.
        """
        if authenticated_cognito_role_overly_permissive_check is not None:
            pulumi.set(__self__, "authenticated_cognito_role_overly_permissive_check", authenticated_cognito_role_overly_permissive_check)
        if ca_certificate_expiring_check is not None:
            pulumi.set(__self__, "ca_certificate_expiring_check", ca_certificate_expiring_check)
        if ca_certificate_key_quality_check is not None:
            pulumi.set(__self__, "ca_certificate_key_quality_check", ca_certificate_key_quality_check)
        if conflicting_client_ids_check is not None:
            pulumi.set(__self__, "conflicting_client_ids_check", conflicting_client_ids_check)
        if device_certificate_expiring_check is not None:
            pulumi.set(__self__, "device_certificate_expiring_check", device_certificate_expiring_check)
        if device_certificate_key_quality_check is not None:
            pulumi.set(__self__, "device_certificate_key_quality_check", device_certificate_key_quality_check)
        if device_certificate_shared_check is not None:
            pulumi.set(__self__, "device_certificate_shared_check", device_certificate_shared_check)
        if intermediate_ca_revoked_for_active_device_certificates_check is not None:
            pulumi.set(__self__, "intermediate_ca_revoked_for_active_device_certificates_check", intermediate_ca_revoked_for_active_device_certificates_check)
        if io_t_policy_potential_mis_configuration_check is not None:
            pulumi.set(__self__, "io_t_policy_potential_mis_configuration_check", io_t_policy_potential_mis_configuration_check)
        if iot_policy_overly_permissive_check is not None:
            pulumi.set(__self__, "iot_policy_overly_permissive_check", iot_policy_overly_permissive_check)
        if iot_role_alias_allows_access_to_unused_services_check is not None:
            pulumi.set(__self__, "iot_role_alias_allows_access_to_unused_services_check", iot_role_alias_allows_access_to_unused_services_check)
        if iot_role_alias_overly_permissive_check is not None:
            pulumi.set(__self__, "iot_role_alias_overly_permissive_check", iot_role_alias_overly_permissive_check)
        if logging_disabled_check is not None:
            pulumi.set(__self__, "logging_disabled_check", logging_disabled_check)
        if revoked_ca_certificate_still_active_check is not None:
            pulumi.set(__self__, "revoked_ca_certificate_still_active_check", revoked_ca_certificate_still_active_check)
        if revoked_device_certificate_still_active_check is not None:
            pulumi.set(__self__, "revoked_device_certificate_still_active_check", revoked_device_certificate_still_active_check)
        if unauthenticated_cognito_role_overly_permissive_check is not None:
            pulumi.set(__self__, "unauthenticated_cognito_role_overly_permissive_check", unauthenticated_cognito_role_overly_permissive_check)

    @property
    @pulumi.getter(name="authenticatedCognitoRoleOverlyPermissiveCheck")
    def authenticated_cognito_role_overly_permissive_check(self) -> Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration']:
        """
        Checks the permissiveness of an authenticated Amazon Cognito identity pool role. For this check, AWS IoT Device Defender audits all Amazon Cognito identity pools that have been used to connect to the AWS IoT message broker during the 31 days before the audit is performed.
        """
        return pulumi.get(self, "authenticated_cognito_role_overly_permissive_check")

    @property
    @pulumi.getter(name="caCertificateExpiringCheck")
    def ca_certificate_expiring_check(self) -> Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration']:
        """
        Checks if a CA certificate is expiring. This check applies to CA certificates expiring within 30 days or that have expired.
        """
        return pulumi.get(self, "ca_certificate_expiring_check")

    @property
    @pulumi.getter(name="caCertificateKeyQualityCheck")
    def ca_certificate_key_quality_check(self) -> Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration']:
        """
        Checks the quality of the CA certificate key. The quality checks if the key is in a valid format, not expired, and if the key meets a minimum required size. This check applies to CA certificates that are `ACTIVE` or `PENDING_TRANSFER` .
        """
        return pulumi.get(self, "ca_certificate_key_quality_check")

    @property
    @pulumi.getter(name="conflictingClientIdsCheck")
    def conflicting_client_ids_check(self) -> Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration']:
        """
        Checks if multiple devices connect using the same client ID.
        """
        return pulumi.get(self, "conflicting_client_ids_check")

    @property
    @pulumi.getter(name="deviceCertificateExpiringCheck")
    def device_certificate_expiring_check(self) -> Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration']:
        """
        Checks if a device certificate is expiring. This check applies to device certificates expiring within 30 days or that have expired.
        """
        return pulumi.get(self, "device_certificate_expiring_check")

    @property
    @pulumi.getter(name="deviceCertificateKeyQualityCheck")
    def device_certificate_key_quality_check(self) -> Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration']:
        """
        Checks the quality of the device certificate key. The quality checks if the key is in a valid format, not expired, signed by a registered certificate authority, and if the key meets a minimum required size.
        """
        return pulumi.get(self, "device_certificate_key_quality_check")

    @property
    @pulumi.getter(name="deviceCertificateSharedCheck")
    def device_certificate_shared_check(self) -> Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration']:
        """
        Checks if multiple concurrent connections use the same X.509 certificate to authenticate with AWS IoT .
        """
        return pulumi.get(self, "device_certificate_shared_check")

    @property
    @pulumi.getter(name="intermediateCaRevokedForActiveDeviceCertificatesCheck")
    def intermediate_ca_revoked_for_active_device_certificates_check(self) -> Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration']:
        """
        Checks if device certificates are still active despite being revoked by an intermediate CA.
        """
        return pulumi.get(self, "intermediate_ca_revoked_for_active_device_certificates_check")

    @property
    @pulumi.getter(name="ioTPolicyPotentialMisConfigurationCheck")
    def io_t_policy_potential_mis_configuration_check(self) -> Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration']:
        """
        Checks if an AWS IoT policy is potentially misconfigured. Misconfigured policies, including overly permissive policies, can cause security incidents like allowing devices access to unintended resources. This check is a warning for you to make sure that only intended actions are allowed before updating the policy.
        """
        return pulumi.get(self, "io_t_policy_potential_mis_configuration_check")

    @property
    @pulumi.getter(name="iotPolicyOverlyPermissiveCheck")
    def iot_policy_overly_permissive_check(self) -> Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration']:
        """
        Checks the permissiveness of a policy attached to an authenticated Amazon Cognito identity pool role.
        """
        return pulumi.get(self, "iot_policy_overly_permissive_check")

    @property
    @pulumi.getter(name="iotRoleAliasAllowsAccessToUnusedServicesCheck")
    def iot_role_alias_allows_access_to_unused_services_check(self) -> Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration']:
        """
        Checks if a role alias has access to services that haven't been used for the AWS IoT device in the last year.
        """
        return pulumi.get(self, "iot_role_alias_allows_access_to_unused_services_check")

    @property
    @pulumi.getter(name="iotRoleAliasOverlyPermissiveCheck")
    def iot_role_alias_overly_permissive_check(self) -> Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration']:
        """
        Checks if the temporary credentials provided by AWS IoT role aliases are overly permissive.
        """
        return pulumi.get(self, "iot_role_alias_overly_permissive_check")

    @property
    @pulumi.getter(name="loggingDisabledCheck")
    def logging_disabled_check(self) -> Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration']:
        """
        Checks if AWS IoT logs are disabled.
        """
        return pulumi.get(self, "logging_disabled_check")

    @property
    @pulumi.getter(name="revokedCaCertificateStillActiveCheck")
    def revoked_ca_certificate_still_active_check(self) -> Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration']:
        """
        Checks if a revoked CA certificate is still active.
        """
        return pulumi.get(self, "revoked_ca_certificate_still_active_check")

    @property
    @pulumi.getter(name="revokedDeviceCertificateStillActiveCheck")
    def revoked_device_certificate_still_active_check(self) -> Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration']:
        """
        Checks if a revoked device certificate is still active.
        """
        return pulumi.get(self, "revoked_device_certificate_still_active_check")

    @property
    @pulumi.getter(name="unauthenticatedCognitoRoleOverlyPermissiveCheck")
    def unauthenticated_cognito_role_overly_permissive_check(self) -> Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration']:
        """
        Checks if policy attached to an unauthenticated Amazon Cognito identity pool role is too permissive.
        """
        return pulumi.get(self, "unauthenticated_cognito_role_overly_permissive_check")


@pulumi.output_type
class AccountAuditConfigurationAuditNotificationTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"
        elif key == "targetArn":
            suggest = "target_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountAuditConfigurationAuditNotificationTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountAuditConfigurationAuditNotificationTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountAuditConfigurationAuditNotificationTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 role_arn: Optional[str] = None,
                 target_arn: Optional[str] = None):
        """
        :param bool enabled: True if notifications to the target are enabled.
        :param str role_arn: The ARN of the role that grants permission to send notifications to the target.
        :param str target_arn: The ARN of the target (SNS topic) to which audit notifications are sent.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if target_arn is not None:
            pulumi.set(__self__, "target_arn", target_arn)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        True if notifications to the target are enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        The ARN of the role that grants permission to send notifications to the target.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="targetArn")
    def target_arn(self) -> Optional[str]:
        """
        The ARN of the target (SNS topic) to which audit notifications are sent.
        """
        return pulumi.get(self, "target_arn")


@pulumi.output_type
class AccountAuditConfigurationAuditNotificationTargetConfigurations(dict):
    """
    Information about the targets to which audit notifications are sent.
    """
    def __init__(__self__, *,
                 sns: Optional['outputs.AccountAuditConfigurationAuditNotificationTarget'] = None):
        """
        Information about the targets to which audit notifications are sent.
        :param 'AccountAuditConfigurationAuditNotificationTarget' sns: The `Sns` notification target.
        """
        if sns is not None:
            pulumi.set(__self__, "sns", sns)

    @property
    @pulumi.getter
    def sns(self) -> Optional['outputs.AccountAuditConfigurationAuditNotificationTarget']:
        """
        The `Sns` notification target.
        """
        return pulumi.get(self, "sns")


@pulumi.output_type
class BillingGroupPropertiesProperties(dict):
    """
    The properties of the billing group.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "billingGroupDescription":
            suggest = "billing_group_description"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BillingGroupPropertiesProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BillingGroupPropertiesProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BillingGroupPropertiesProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 billing_group_description: Optional[str] = None):
        """
        The properties of the billing group.
        :param str billing_group_description: The description of the billing group.
        """
        if billing_group_description is not None:
            pulumi.set(__self__, "billing_group_description", billing_group_description)

    @property
    @pulumi.getter(name="billingGroupDescription")
    def billing_group_description(self) -> Optional[str]:
        """
        The description of the billing group.
        """
        return pulumi.get(self, "billing_group_description")


@pulumi.output_type
class CaCertificateRegistrationConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"
        elif key == "templateBody":
            suggest = "template_body"
        elif key == "templateName":
            suggest = "template_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CaCertificateRegistrationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CaCertificateRegistrationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CaCertificateRegistrationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: Optional[str] = None,
                 template_body: Optional[str] = None,
                 template_name: Optional[str] = None):
        """
        :param str role_arn: The ARN of the role.
        :param str template_body: The template body.
        :param str template_name: The name of the provisioning template.
        """
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if template_body is not None:
            pulumi.set(__self__, "template_body", template_body)
        if template_name is not None:
            pulumi.set(__self__, "template_name", template_name)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        The ARN of the role.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="templateBody")
    def template_body(self) -> Optional[str]:
        """
        The template body.
        """
        return pulumi.get(self, "template_body")

    @property
    @pulumi.getter(name="templateName")
    def template_name(self) -> Optional[str]:
        """
        The name of the provisioning template.
        """
        return pulumi.get(self, "template_name")


@pulumi.output_type
class DomainConfigurationAuthorizerConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowAuthorizerOverride":
            suggest = "allow_authorizer_override"
        elif key == "defaultAuthorizerName":
            suggest = "default_authorizer_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainConfigurationAuthorizerConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainConfigurationAuthorizerConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainConfigurationAuthorizerConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_authorizer_override: Optional[bool] = None,
                 default_authorizer_name: Optional[str] = None):
        """
        :param bool allow_authorizer_override: A Boolean that specifies whether the domain configuration's authorization service can be overridden.
        :param str default_authorizer_name: The name of the authorization service for a domain configuration.
        """
        if allow_authorizer_override is not None:
            pulumi.set(__self__, "allow_authorizer_override", allow_authorizer_override)
        if default_authorizer_name is not None:
            pulumi.set(__self__, "default_authorizer_name", default_authorizer_name)

    @property
    @pulumi.getter(name="allowAuthorizerOverride")
    def allow_authorizer_override(self) -> Optional[bool]:
        """
        A Boolean that specifies whether the domain configuration's authorization service can be overridden.
        """
        return pulumi.get(self, "allow_authorizer_override")

    @property
    @pulumi.getter(name="defaultAuthorizerName")
    def default_authorizer_name(self) -> Optional[str]:
        """
        The name of the authorization service for a domain configuration.
        """
        return pulumi.get(self, "default_authorizer_name")


@pulumi.output_type
class DomainConfigurationServerCertificateConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableOcspCheck":
            suggest = "enable_ocsp_check"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainConfigurationServerCertificateConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainConfigurationServerCertificateConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainConfigurationServerCertificateConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_ocsp_check: Optional[bool] = None):
        """
        :param bool enable_ocsp_check: A Boolean value that indicates whether Online Certificate Status Protocol (OCSP) server certificate check is enabled or not. For more information, see [Configurable endpoints](https://docs.aws.amazon.com//iot/latest/developerguide/iot-custom-endpoints-configurable.html) from the AWS IoT Core Developer Guide.
        """
        if enable_ocsp_check is not None:
            pulumi.set(__self__, "enable_ocsp_check", enable_ocsp_check)

    @property
    @pulumi.getter(name="enableOcspCheck")
    def enable_ocsp_check(self) -> Optional[bool]:
        """
        A Boolean value that indicates whether Online Certificate Status Protocol (OCSP) server certificate check is enabled or not. For more information, see [Configurable endpoints](https://docs.aws.amazon.com//iot/latest/developerguide/iot-custom-endpoints-configurable.html) from the AWS IoT Core Developer Guide.
        """
        return pulumi.get(self, "enable_ocsp_check")


@pulumi.output_type
class DomainConfigurationServerCertificateSummary(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverCertificateArn":
            suggest = "server_certificate_arn"
        elif key == "serverCertificateStatus":
            suggest = "server_certificate_status"
        elif key == "serverCertificateStatusDetail":
            suggest = "server_certificate_status_detail"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainConfigurationServerCertificateSummary. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainConfigurationServerCertificateSummary.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainConfigurationServerCertificateSummary.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 server_certificate_arn: Optional[str] = None,
                 server_certificate_status: Optional['DomainConfigurationServerCertificateSummaryServerCertificateStatus'] = None,
                 server_certificate_status_detail: Optional[str] = None):
        """
        :param str server_certificate_arn: The ARN of the server certificate.
        :param 'DomainConfigurationServerCertificateSummaryServerCertificateStatus' server_certificate_status: The status of the server certificate.
        :param str server_certificate_status_detail: Details that explain the status of the server certificate.
        """
        if server_certificate_arn is not None:
            pulumi.set(__self__, "server_certificate_arn", server_certificate_arn)
        if server_certificate_status is not None:
            pulumi.set(__self__, "server_certificate_status", server_certificate_status)
        if server_certificate_status_detail is not None:
            pulumi.set(__self__, "server_certificate_status_detail", server_certificate_status_detail)

    @property
    @pulumi.getter(name="serverCertificateArn")
    def server_certificate_arn(self) -> Optional[str]:
        """
        The ARN of the server certificate.
        """
        return pulumi.get(self, "server_certificate_arn")

    @property
    @pulumi.getter(name="serverCertificateStatus")
    def server_certificate_status(self) -> Optional['DomainConfigurationServerCertificateSummaryServerCertificateStatus']:
        """
        The status of the server certificate.
        """
        return pulumi.get(self, "server_certificate_status")

    @property
    @pulumi.getter(name="serverCertificateStatusDetail")
    def server_certificate_status_detail(self) -> Optional[str]:
        """
        Details that explain the status of the server certificate.
        """
        return pulumi.get(self, "server_certificate_status_detail")


@pulumi.output_type
class DomainConfigurationTlsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityPolicy":
            suggest = "security_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainConfigurationTlsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainConfigurationTlsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainConfigurationTlsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 security_policy: Optional[str] = None):
        """
        :param str security_policy: The security policy for a domain configuration. For more information, see [Security policies](https://docs.aws.amazon.com/iot/latest/developerguide/transport-security.html#tls-policy-table) in the *AWS IoT Core developer guide* .
        """
        if security_policy is not None:
            pulumi.set(__self__, "security_policy", security_policy)

    @property
    @pulumi.getter(name="securityPolicy")
    def security_policy(self) -> Optional[str]:
        """
        The security policy for a domain configuration. For more information, see [Security policies](https://docs.aws.amazon.com/iot/latest/developerguide/transport-security.html#tls-policy-table) in the *AWS IoT Core developer guide* .
        """
        return pulumi.get(self, "security_policy")


@pulumi.output_type
class FleetMetricAggregationType(dict):
    """
    Aggregation types supported by Fleet Indexing
    """
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        Aggregation types supported by Fleet Indexing
        :param str name: Fleet Indexing aggregation type names such as Statistics, Percentiles and Cardinality
        :param Sequence[str] values: Fleet Indexing aggregation type values
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Fleet Indexing aggregation type names such as Statistics, Percentiles and Cardinality
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Fleet Indexing aggregation type values
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class JobExecutionsRetryConfigProperties(dict):
    """
    Allows you to create the criteria to retry a job.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retryCriteriaList":
            suggest = "retry_criteria_list"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobExecutionsRetryConfigProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobExecutionsRetryConfigProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobExecutionsRetryConfigProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 retry_criteria_list: Optional[Sequence['outputs.JobTemplateRetryCriteria']] = None):
        """
        Allows you to create the criteria to retry a job.
        :param Sequence['JobTemplateRetryCriteria'] retry_criteria_list: The list of criteria that determines how many retries are allowed for each failure type for a job.
        """
        if retry_criteria_list is not None:
            pulumi.set(__self__, "retry_criteria_list", retry_criteria_list)

    @property
    @pulumi.getter(name="retryCriteriaList")
    def retry_criteria_list(self) -> Optional[Sequence['outputs.JobTemplateRetryCriteria']]:
        """
        The list of criteria that determines how many retries are allowed for each failure type for a job.
        """
        return pulumi.get(self, "retry_criteria_list")


@pulumi.output_type
class JobExecutionsRolloutConfigProperties(dict):
    """
    Allows you to create a staged rollout of a job.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exponentialRolloutRate":
            suggest = "exponential_rollout_rate"
        elif key == "maximumPerMinute":
            suggest = "maximum_per_minute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobExecutionsRolloutConfigProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobExecutionsRolloutConfigProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobExecutionsRolloutConfigProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exponential_rollout_rate: Optional['outputs.JobTemplateExponentialRolloutRate'] = None,
                 maximum_per_minute: Optional[int] = None):
        """
        Allows you to create a staged rollout of a job.
        :param 'JobTemplateExponentialRolloutRate' exponential_rollout_rate: The rate of increase for a job rollout. This parameter allows you to define an exponential rate for a job rollout.
        :param int maximum_per_minute: The maximum number of things that will be notified of a pending job, per minute. This parameter allows you to create a staged rollout.
        """
        if exponential_rollout_rate is not None:
            pulumi.set(__self__, "exponential_rollout_rate", exponential_rollout_rate)
        if maximum_per_minute is not None:
            pulumi.set(__self__, "maximum_per_minute", maximum_per_minute)

    @property
    @pulumi.getter(name="exponentialRolloutRate")
    def exponential_rollout_rate(self) -> Optional['outputs.JobTemplateExponentialRolloutRate']:
        """
        The rate of increase for a job rollout. This parameter allows you to define an exponential rate for a job rollout.
        """
        return pulumi.get(self, "exponential_rollout_rate")

    @property
    @pulumi.getter(name="maximumPerMinute")
    def maximum_per_minute(self) -> Optional[int]:
        """
        The maximum number of things that will be notified of a pending job, per minute. This parameter allows you to create a staged rollout.
        """
        return pulumi.get(self, "maximum_per_minute")


@pulumi.output_type
class JobTemplateAbortCriteria(dict):
    """
    The criteria that determine when and how a job abort takes place.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureType":
            suggest = "failure_type"
        elif key == "minNumberOfExecutedThings":
            suggest = "min_number_of_executed_things"
        elif key == "thresholdPercentage":
            suggest = "threshold_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTemplateAbortCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTemplateAbortCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTemplateAbortCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: 'JobTemplateAction',
                 failure_type: 'JobTemplateFailureType',
                 min_number_of_executed_things: int,
                 threshold_percentage: float):
        """
        The criteria that determine when and how a job abort takes place.
        :param 'JobTemplateAction' action: The type of job action to take to initiate the job abort.
        :param 'JobTemplateFailureType' failure_type: The type of job execution failures that can initiate a job abort.
        :param int min_number_of_executed_things: The minimum number of things which must receive job execution notifications before the job can be aborted.
        :param float threshold_percentage: The minimum percentage of job execution failures that must occur to initiate the job abort.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "failure_type", failure_type)
        pulumi.set(__self__, "min_number_of_executed_things", min_number_of_executed_things)
        pulumi.set(__self__, "threshold_percentage", threshold_percentage)

    @property
    @pulumi.getter
    def action(self) -> 'JobTemplateAction':
        """
        The type of job action to take to initiate the job abort.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="failureType")
    def failure_type(self) -> 'JobTemplateFailureType':
        """
        The type of job execution failures that can initiate a job abort.
        """
        return pulumi.get(self, "failure_type")

    @property
    @pulumi.getter(name="minNumberOfExecutedThings")
    def min_number_of_executed_things(self) -> int:
        """
        The minimum number of things which must receive job execution notifications before the job can be aborted.
        """
        return pulumi.get(self, "min_number_of_executed_things")

    @property
    @pulumi.getter(name="thresholdPercentage")
    def threshold_percentage(self) -> float:
        """
        The minimum percentage of job execution failures that must occur to initiate the job abort.
        """
        return pulumi.get(self, "threshold_percentage")


@pulumi.output_type
class JobTemplateExponentialRolloutRate(dict):
    """
    Allows you to create an exponential rate of rollout for a job.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseRatePerMinute":
            suggest = "base_rate_per_minute"
        elif key == "incrementFactor":
            suggest = "increment_factor"
        elif key == "rateIncreaseCriteria":
            suggest = "rate_increase_criteria"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTemplateExponentialRolloutRate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTemplateExponentialRolloutRate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTemplateExponentialRolloutRate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_rate_per_minute: int,
                 increment_factor: float,
                 rate_increase_criteria: 'outputs.JobTemplateRateIncreaseCriteria'):
        """
        Allows you to create an exponential rate of rollout for a job.
        :param int base_rate_per_minute: The minimum number of things that will be notified of a pending job, per minute at the start of job rollout. This parameter allows you to define the initial rate of rollout.
        :param float increment_factor: The exponential factor to increase the rate of rollout for a job.
        :param 'JobTemplateRateIncreaseCriteria' rate_increase_criteria: The criteria to initiate the increase in rate of rollout for a job.
        """
        pulumi.set(__self__, "base_rate_per_minute", base_rate_per_minute)
        pulumi.set(__self__, "increment_factor", increment_factor)
        pulumi.set(__self__, "rate_increase_criteria", rate_increase_criteria)

    @property
    @pulumi.getter(name="baseRatePerMinute")
    def base_rate_per_minute(self) -> int:
        """
        The minimum number of things that will be notified of a pending job, per minute at the start of job rollout. This parameter allows you to define the initial rate of rollout.
        """
        return pulumi.get(self, "base_rate_per_minute")

    @property
    @pulumi.getter(name="incrementFactor")
    def increment_factor(self) -> float:
        """
        The exponential factor to increase the rate of rollout for a job.
        """
        return pulumi.get(self, "increment_factor")

    @property
    @pulumi.getter(name="rateIncreaseCriteria")
    def rate_increase_criteria(self) -> 'outputs.JobTemplateRateIncreaseCriteria':
        """
        The criteria to initiate the increase in rate of rollout for a job.
        """
        return pulumi.get(self, "rate_increase_criteria")


@pulumi.output_type
class JobTemplateMaintenanceWindow(dict):
    """
    Specifies a start time and duration for a scheduled Job.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationInMinutes":
            suggest = "duration_in_minutes"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTemplateMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTemplateMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTemplateMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_in_minutes: Optional[int] = None,
                 start_time: Optional[str] = None):
        """
        Specifies a start time and duration for a scheduled Job.
        :param int duration_in_minutes: Displays the duration of the next maintenance window.
        :param str start_time: Displays the start time of the next maintenance window.
        """
        if duration_in_minutes is not None:
            pulumi.set(__self__, "duration_in_minutes", duration_in_minutes)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="durationInMinutes")
    def duration_in_minutes(self) -> Optional[int]:
        """
        Displays the duration of the next maintenance window.
        """
        return pulumi.get(self, "duration_in_minutes")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        Displays the start time of the next maintenance window.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class JobTemplateRateIncreaseCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numberOfNotifiedThings":
            suggest = "number_of_notified_things"
        elif key == "numberOfSucceededThings":
            suggest = "number_of_succeeded_things"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTemplateRateIncreaseCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTemplateRateIncreaseCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTemplateRateIncreaseCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 number_of_notified_things: Optional[int] = None,
                 number_of_succeeded_things: Optional[int] = None):
        """
        :param int number_of_notified_things: The threshold for number of notified things that will initiate the increase in rate of rollout.
        :param int number_of_succeeded_things: The threshold for number of succeeded things that will initiate the increase in rate of rollout.
        """
        if number_of_notified_things is not None:
            pulumi.set(__self__, "number_of_notified_things", number_of_notified_things)
        if number_of_succeeded_things is not None:
            pulumi.set(__self__, "number_of_succeeded_things", number_of_succeeded_things)

    @property
    @pulumi.getter(name="numberOfNotifiedThings")
    def number_of_notified_things(self) -> Optional[int]:
        """
        The threshold for number of notified things that will initiate the increase in rate of rollout.
        """
        return pulumi.get(self, "number_of_notified_things")

    @property
    @pulumi.getter(name="numberOfSucceededThings")
    def number_of_succeeded_things(self) -> Optional[int]:
        """
        The threshold for number of succeeded things that will initiate the increase in rate of rollout.
        """
        return pulumi.get(self, "number_of_succeeded_things")


@pulumi.output_type
class JobTemplateRetryCriteria(dict):
    """
    Specifies how many times a failure type should be retried.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureType":
            suggest = "failure_type"
        elif key == "numberOfRetries":
            suggest = "number_of_retries"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTemplateRetryCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTemplateRetryCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTemplateRetryCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_type: Optional['JobTemplateJobRetryFailureType'] = None,
                 number_of_retries: Optional[int] = None):
        """
        Specifies how many times a failure type should be retried.
        :param 'JobTemplateJobRetryFailureType' failure_type: The type of job execution failures that can initiate a job retry.
        :param int number_of_retries: The number of retries allowed for a failure type for the job.
        """
        if failure_type is not None:
            pulumi.set(__self__, "failure_type", failure_type)
        if number_of_retries is not None:
            pulumi.set(__self__, "number_of_retries", number_of_retries)

    @property
    @pulumi.getter(name="failureType")
    def failure_type(self) -> Optional['JobTemplateJobRetryFailureType']:
        """
        The type of job execution failures that can initiate a job retry.
        """
        return pulumi.get(self, "failure_type")

    @property
    @pulumi.getter(name="numberOfRetries")
    def number_of_retries(self) -> Optional[int]:
        """
        The number of retries allowed for a failure type for the job.
        """
        return pulumi.get(self, "number_of_retries")


@pulumi.output_type
class MetricsExportConfigProperties(dict):
    """
    A structure containing the mqtt topic for metrics export.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mqttTopic":
            suggest = "mqtt_topic"
        elif key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricsExportConfigProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricsExportConfigProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricsExportConfigProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mqtt_topic: str,
                 role_arn: str):
        """
        A structure containing the mqtt topic for metrics export.
        :param str mqtt_topic: The topic for metrics export.
        :param str role_arn: The ARN of the role that grants permission to publish to mqtt topic.
        """
        pulumi.set(__self__, "mqtt_topic", mqtt_topic)
        pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter(name="mqttTopic")
    def mqtt_topic(self) -> str:
        """
        The topic for metrics export.
        """
        return pulumi.get(self, "mqtt_topic")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        The ARN of the role that grants permission to publish to mqtt topic.
        """
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class MitigationActionActionParams(dict):
    """
    The set of parameters for this mitigation action. You can specify only one type of parameter (in other words, you can apply only one action for each defined mitigation action).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addThingsToThingGroupParams":
            suggest = "add_things_to_thing_group_params"
        elif key == "enableIoTLoggingParams":
            suggest = "enable_io_t_logging_params"
        elif key == "publishFindingToSnsParams":
            suggest = "publish_finding_to_sns_params"
        elif key == "replaceDefaultPolicyVersionParams":
            suggest = "replace_default_policy_version_params"
        elif key == "updateCaCertificateParams":
            suggest = "update_ca_certificate_params"
        elif key == "updateDeviceCertificateParams":
            suggest = "update_device_certificate_params"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MitigationActionActionParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MitigationActionActionParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MitigationActionActionParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 add_things_to_thing_group_params: Optional['outputs.MitigationActionAddThingsToThingGroupParams'] = None,
                 enable_io_t_logging_params: Optional['outputs.MitigationActionEnableIoTLoggingParams'] = None,
                 publish_finding_to_sns_params: Optional['outputs.MitigationActionPublishFindingToSnsParams'] = None,
                 replace_default_policy_version_params: Optional['outputs.MitigationActionReplaceDefaultPolicyVersionParams'] = None,
                 update_ca_certificate_params: Optional['outputs.MitigationActionUpdateCaCertificateParams'] = None,
                 update_device_certificate_params: Optional['outputs.MitigationActionUpdateDeviceCertificateParams'] = None):
        """
        The set of parameters for this mitigation action. You can specify only one type of parameter (in other words, you can apply only one action for each defined mitigation action).
        :param 'MitigationActionAddThingsToThingGroupParams' add_things_to_thing_group_params: Specifies the group to which you want to add the devices.
        :param 'MitigationActionEnableIoTLoggingParams' enable_io_t_logging_params: Specifies the logging level and the role with permissions for logging. You cannot specify a logging level of `DISABLED` .
        :param 'MitigationActionPublishFindingToSnsParams' publish_finding_to_sns_params: Specifies the topic to which the finding should be published.
        :param 'MitigationActionReplaceDefaultPolicyVersionParams' replace_default_policy_version_params: Replaces the policy version with a default or blank policy. You specify the template name. Only a value of `BLANK_POLICY` is currently supported.
        :param 'MitigationActionUpdateCaCertificateParams' update_ca_certificate_params: Specifies the new state for the CA certificate. Only a value of `DEACTIVATE` is currently supported.
        :param 'MitigationActionUpdateDeviceCertificateParams' update_device_certificate_params: Specifies the new state for a device certificate. Only a value of `DEACTIVATE` is currently supported.
        """
        if add_things_to_thing_group_params is not None:
            pulumi.set(__self__, "add_things_to_thing_group_params", add_things_to_thing_group_params)
        if enable_io_t_logging_params is not None:
            pulumi.set(__self__, "enable_io_t_logging_params", enable_io_t_logging_params)
        if publish_finding_to_sns_params is not None:
            pulumi.set(__self__, "publish_finding_to_sns_params", publish_finding_to_sns_params)
        if replace_default_policy_version_params is not None:
            pulumi.set(__self__, "replace_default_policy_version_params", replace_default_policy_version_params)
        if update_ca_certificate_params is not None:
            pulumi.set(__self__, "update_ca_certificate_params", update_ca_certificate_params)
        if update_device_certificate_params is not None:
            pulumi.set(__self__, "update_device_certificate_params", update_device_certificate_params)

    @property
    @pulumi.getter(name="addThingsToThingGroupParams")
    def add_things_to_thing_group_params(self) -> Optional['outputs.MitigationActionAddThingsToThingGroupParams']:
        """
        Specifies the group to which you want to add the devices.
        """
        return pulumi.get(self, "add_things_to_thing_group_params")

    @property
    @pulumi.getter(name="enableIoTLoggingParams")
    def enable_io_t_logging_params(self) -> Optional['outputs.MitigationActionEnableIoTLoggingParams']:
        """
        Specifies the logging level and the role with permissions for logging. You cannot specify a logging level of `DISABLED` .
        """
        return pulumi.get(self, "enable_io_t_logging_params")

    @property
    @pulumi.getter(name="publishFindingToSnsParams")
    def publish_finding_to_sns_params(self) -> Optional['outputs.MitigationActionPublishFindingToSnsParams']:
        """
        Specifies the topic to which the finding should be published.
        """
        return pulumi.get(self, "publish_finding_to_sns_params")

    @property
    @pulumi.getter(name="replaceDefaultPolicyVersionParams")
    def replace_default_policy_version_params(self) -> Optional['outputs.MitigationActionReplaceDefaultPolicyVersionParams']:
        """
        Replaces the policy version with a default or blank policy. You specify the template name. Only a value of `BLANK_POLICY` is currently supported.
        """
        return pulumi.get(self, "replace_default_policy_version_params")

    @property
    @pulumi.getter(name="updateCaCertificateParams")
    def update_ca_certificate_params(self) -> Optional['outputs.MitigationActionUpdateCaCertificateParams']:
        """
        Specifies the new state for the CA certificate. Only a value of `DEACTIVATE` is currently supported.
        """
        return pulumi.get(self, "update_ca_certificate_params")

    @property
    @pulumi.getter(name="updateDeviceCertificateParams")
    def update_device_certificate_params(self) -> Optional['outputs.MitigationActionUpdateDeviceCertificateParams']:
        """
        Specifies the new state for a device certificate. Only a value of `DEACTIVATE` is currently supported.
        """
        return pulumi.get(self, "update_device_certificate_params")


@pulumi.output_type
class MitigationActionAddThingsToThingGroupParams(dict):
    """
    Parameters to define a mitigation action that moves devices associated with a certificate to one or more specified thing groups, typically for quarantine.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "thingGroupNames":
            suggest = "thing_group_names"
        elif key == "overrideDynamicGroups":
            suggest = "override_dynamic_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MitigationActionAddThingsToThingGroupParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MitigationActionAddThingsToThingGroupParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MitigationActionAddThingsToThingGroupParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 thing_group_names: Sequence[str],
                 override_dynamic_groups: Optional[bool] = None):
        """
        Parameters to define a mitigation action that moves devices associated with a certificate to one or more specified thing groups, typically for quarantine.
        :param Sequence[str] thing_group_names: The list of groups to which you want to add the things that triggered the mitigation action.
        :param bool override_dynamic_groups: Specifies if this mitigation action can move the things that triggered the mitigation action out of one or more dynamic thing groups.
        """
        pulumi.set(__self__, "thing_group_names", thing_group_names)
        if override_dynamic_groups is not None:
            pulumi.set(__self__, "override_dynamic_groups", override_dynamic_groups)

    @property
    @pulumi.getter(name="thingGroupNames")
    def thing_group_names(self) -> Sequence[str]:
        """
        The list of groups to which you want to add the things that triggered the mitigation action.
        """
        return pulumi.get(self, "thing_group_names")

    @property
    @pulumi.getter(name="overrideDynamicGroups")
    def override_dynamic_groups(self) -> Optional[bool]:
        """
        Specifies if this mitigation action can move the things that triggered the mitigation action out of one or more dynamic thing groups.
        """
        return pulumi.get(self, "override_dynamic_groups")


@pulumi.output_type
class MitigationActionEnableIoTLoggingParams(dict):
    """
    Parameters to define a mitigation action that enables AWS IoT logging at a specified level of detail.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logLevel":
            suggest = "log_level"
        elif key == "roleArnForLogging":
            suggest = "role_arn_for_logging"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MitigationActionEnableIoTLoggingParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MitigationActionEnableIoTLoggingParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MitigationActionEnableIoTLoggingParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_level: 'MitigationActionEnableIoTLoggingParamsLogLevel',
                 role_arn_for_logging: str):
        """
        Parameters to define a mitigation action that enables AWS IoT logging at a specified level of detail.
        :param 'MitigationActionEnableIoTLoggingParamsLogLevel' log_level:  Specifies which types of information are logged.
        :param str role_arn_for_logging:  The ARN of the IAM role used for logging.
        """
        pulumi.set(__self__, "log_level", log_level)
        pulumi.set(__self__, "role_arn_for_logging", role_arn_for_logging)

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> 'MitigationActionEnableIoTLoggingParamsLogLevel':
        """
         Specifies which types of information are logged.
        """
        return pulumi.get(self, "log_level")

    @property
    @pulumi.getter(name="roleArnForLogging")
    def role_arn_for_logging(self) -> str:
        """
         The ARN of the IAM role used for logging.
        """
        return pulumi.get(self, "role_arn_for_logging")


@pulumi.output_type
class MitigationActionPublishFindingToSnsParams(dict):
    """
    Parameters, to define a mitigation action that publishes findings to Amazon SNS. You can implement your own custom actions in response to the Amazon SNS messages.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "topicArn":
            suggest = "topic_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MitigationActionPublishFindingToSnsParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MitigationActionPublishFindingToSnsParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MitigationActionPublishFindingToSnsParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 topic_arn: str):
        """
        Parameters, to define a mitigation action that publishes findings to Amazon SNS. You can implement your own custom actions in response to the Amazon SNS messages.
        :param str topic_arn: The ARN of the topic to which you want to publish the findings.
        """
        pulumi.set(__self__, "topic_arn", topic_arn)

    @property
    @pulumi.getter(name="topicArn")
    def topic_arn(self) -> str:
        """
        The ARN of the topic to which you want to publish the findings.
        """
        return pulumi.get(self, "topic_arn")


@pulumi.output_type
class MitigationActionReplaceDefaultPolicyVersionParams(dict):
    """
    Parameters to define a mitigation action that adds a blank policy to restrict permissions.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "templateName":
            suggest = "template_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MitigationActionReplaceDefaultPolicyVersionParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MitigationActionReplaceDefaultPolicyVersionParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MitigationActionReplaceDefaultPolicyVersionParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 template_name: 'MitigationActionReplaceDefaultPolicyVersionParamsTemplateName'):
        """
        Parameters to define a mitigation action that adds a blank policy to restrict permissions.
        :param 'MitigationActionReplaceDefaultPolicyVersionParamsTemplateName' template_name: The name of the template to be applied. The only supported value is `BLANK_POLICY` .
        """
        pulumi.set(__self__, "template_name", template_name)

    @property
    @pulumi.getter(name="templateName")
    def template_name(self) -> 'MitigationActionReplaceDefaultPolicyVersionParamsTemplateName':
        """
        The name of the template to be applied. The only supported value is `BLANK_POLICY` .
        """
        return pulumi.get(self, "template_name")


@pulumi.output_type
class MitigationActionUpdateCaCertificateParams(dict):
    """
    Parameters to define a mitigation action that changes the state of the CA certificate to inactive.
    """
    def __init__(__self__, *,
                 action: 'MitigationActionUpdateCaCertificateParamsAction'):
        """
        Parameters to define a mitigation action that changes the state of the CA certificate to inactive.
        :param 'MitigationActionUpdateCaCertificateParamsAction' action: The action that you want to apply to the CA certificate. The only supported value is `DEACTIVATE` .
        """
        pulumi.set(__self__, "action", action)

    @property
    @pulumi.getter
    def action(self) -> 'MitigationActionUpdateCaCertificateParamsAction':
        """
        The action that you want to apply to the CA certificate. The only supported value is `DEACTIVATE` .
        """
        return pulumi.get(self, "action")


@pulumi.output_type
class MitigationActionUpdateDeviceCertificateParams(dict):
    """
    Parameters to define a mitigation action that changes the state of the device certificate to inactive.
    """
    def __init__(__self__, *,
                 action: 'MitigationActionUpdateDeviceCertificateParamsAction'):
        """
        Parameters to define a mitigation action that changes the state of the device certificate to inactive.
        :param 'MitigationActionUpdateDeviceCertificateParamsAction' action: The action that you want to apply to the device certificate. The only supported value is `DEACTIVATE` .
        """
        pulumi.set(__self__, "action", action)

    @property
    @pulumi.getter
    def action(self) -> 'MitigationActionUpdateDeviceCertificateParamsAction':
        """
        The action that you want to apply to the device certificate. The only supported value is `DEACTIVATE` .
        """
        return pulumi.get(self, "action")


@pulumi.output_type
class PresignedUrlConfigProperties(dict):
    """
    Configuration for pre-signed S3 URLs.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"
        elif key == "expiresInSec":
            suggest = "expires_in_sec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PresignedUrlConfigProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PresignedUrlConfigProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PresignedUrlConfigProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: str,
                 expires_in_sec: Optional[int] = None):
        """
        Configuration for pre-signed S3 URLs.
        :param str role_arn: The ARN of an IAM role that grants grants permission to download files from the S3 bucket where the job data/updates are stored. The role must also grant permission for IoT to download the files.
               
               > For information about addressing the confused deputy problem, see [cross-service confused deputy prevention](https://docs.aws.amazon.com/iot/latest/developerguide/cross-service-confused-deputy-prevention.html) in the *AWS IoT Core developer guide* .
        :param int expires_in_sec: How long (in seconds) pre-signed URLs are valid. Valid values are 60 - 3600, the default value is 3600 seconds. Pre-signed URLs are generated when Jobs receives an MQTT request for the job document.
        """
        pulumi.set(__self__, "role_arn", role_arn)
        if expires_in_sec is not None:
            pulumi.set(__self__, "expires_in_sec", expires_in_sec)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        The ARN of an IAM role that grants grants permission to download files from the S3 bucket where the job data/updates are stored. The role must also grant permission for IoT to download the files.

        > For information about addressing the confused deputy problem, see [cross-service confused deputy prevention](https://docs.aws.amazon.com/iot/latest/developerguide/cross-service-confused-deputy-prevention.html) in the *AWS IoT Core developer guide* .
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="expiresInSec")
    def expires_in_sec(self) -> Optional[int]:
        """
        How long (in seconds) pre-signed URLs are valid. Valid values are 60 - 3600, the default value is 3600 seconds. Pre-signed URLs are generated when Jobs receives an MQTT request for the job document.
        """
        return pulumi.get(self, "expires_in_sec")


@pulumi.output_type
class ProvisioningTemplateProvisioningHook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "payloadVersion":
            suggest = "payload_version"
        elif key == "targetArn":
            suggest = "target_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProvisioningTemplateProvisioningHook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProvisioningTemplateProvisioningHook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProvisioningTemplateProvisioningHook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 payload_version: Optional[str] = None,
                 target_arn: Optional[str] = None):
        """
        :param str payload_version: The payload that was sent to the target function. The valid payload is `"2020-04-01"` .
        :param str target_arn: The ARN of the target function.
        """
        if payload_version is not None:
            pulumi.set(__self__, "payload_version", payload_version)
        if target_arn is not None:
            pulumi.set(__self__, "target_arn", target_arn)

    @property
    @pulumi.getter(name="payloadVersion")
    def payload_version(self) -> Optional[str]:
        """
        The payload that was sent to the target function. The valid payload is `"2020-04-01"` .
        """
        return pulumi.get(self, "payload_version")

    @property
    @pulumi.getter(name="targetArn")
    def target_arn(self) -> Optional[str]:
        """
        The ARN of the target function.
        """
        return pulumi.get(self, "target_arn")


@pulumi.output_type
class SecurityProfileAlertTarget(dict):
    """
    A structure containing the alert target ARN and the role ARN.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertTargetArn":
            suggest = "alert_target_arn"
        elif key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityProfileAlertTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityProfileAlertTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityProfileAlertTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_target_arn: str,
                 role_arn: str):
        """
        A structure containing the alert target ARN and the role ARN.
        :param str alert_target_arn: The ARN of the notification target to which alerts are sent.
        :param str role_arn: The ARN of the role that grants permission to send alerts to the notification target.
        """
        pulumi.set(__self__, "alert_target_arn", alert_target_arn)
        pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter(name="alertTargetArn")
    def alert_target_arn(self) -> str:
        """
        The ARN of the notification target to which alerts are sent.
        """
        return pulumi.get(self, "alert_target_arn")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        The ARN of the role that grants permission to send alerts to the notification target.
        """
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class SecurityProfileBehavior(dict):
    """
    A security profile behavior.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exportMetric":
            suggest = "export_metric"
        elif key == "metricDimension":
            suggest = "metric_dimension"
        elif key == "suppressAlerts":
            suggest = "suppress_alerts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityProfileBehavior. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityProfileBehavior.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityProfileBehavior.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 criteria: Optional['outputs.SecurityProfileBehaviorCriteria'] = None,
                 export_metric: Optional[bool] = None,
                 metric: Optional[str] = None,
                 metric_dimension: Optional['outputs.SecurityProfileMetricDimension'] = None,
                 suppress_alerts: Optional[bool] = None):
        """
        A security profile behavior.
        :param str name: The name for the behavior.
        :param 'SecurityProfileBehaviorCriteria' criteria: The criteria that determine if a device is behaving normally in regard to the `metric` .
               
               > In the AWS IoT console, you can choose to be sent an alert through Amazon SNS when AWS IoT Device Defender detects that a device is behaving anomalously.
        :param bool export_metric: Value indicates exporting metrics related to the behavior when it is true.
        :param str metric: What is measured by the behavior.
        :param 'SecurityProfileMetricDimension' metric_dimension: The dimension of the metric.
        :param bool suppress_alerts: Manage Detect alarm SNS notifications by setting behavior notification to on or suppressed. Detect will continue to performing device behavior evaluations. However, suppressed alarms wouldn't be forwarded for SNS notification.
        """
        pulumi.set(__self__, "name", name)
        if criteria is not None:
            pulumi.set(__self__, "criteria", criteria)
        if export_metric is not None:
            pulumi.set(__self__, "export_metric", export_metric)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if metric_dimension is not None:
            pulumi.set(__self__, "metric_dimension", metric_dimension)
        if suppress_alerts is not None:
            pulumi.set(__self__, "suppress_alerts", suppress_alerts)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name for the behavior.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def criteria(self) -> Optional['outputs.SecurityProfileBehaviorCriteria']:
        """
        The criteria that determine if a device is behaving normally in regard to the `metric` .

        > In the AWS IoT console, you can choose to be sent an alert through Amazon SNS when AWS IoT Device Defender detects that a device is behaving anomalously.
        """
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter(name="exportMetric")
    def export_metric(self) -> Optional[bool]:
        """
        Value indicates exporting metrics related to the behavior when it is true.
        """
        return pulumi.get(self, "export_metric")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        What is measured by the behavior.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="metricDimension")
    def metric_dimension(self) -> Optional['outputs.SecurityProfileMetricDimension']:
        """
        The dimension of the metric.
        """
        return pulumi.get(self, "metric_dimension")

    @property
    @pulumi.getter(name="suppressAlerts")
    def suppress_alerts(self) -> Optional[bool]:
        """
        Manage Detect alarm SNS notifications by setting behavior notification to on or suppressed. Detect will continue to performing device behavior evaluations. However, suppressed alarms wouldn't be forwarded for SNS notification.
        """
        return pulumi.get(self, "suppress_alerts")


@pulumi.output_type
class SecurityProfileBehaviorCriteria(dict):
    """
    The criteria by which the behavior is determined to be normal.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"
        elif key == "consecutiveDatapointsToAlarm":
            suggest = "consecutive_datapoints_to_alarm"
        elif key == "consecutiveDatapointsToClear":
            suggest = "consecutive_datapoints_to_clear"
        elif key == "durationSeconds":
            suggest = "duration_seconds"
        elif key == "mlDetectionConfig":
            suggest = "ml_detection_config"
        elif key == "statisticalThreshold":
            suggest = "statistical_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityProfileBehaviorCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityProfileBehaviorCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityProfileBehaviorCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: Optional['SecurityProfileBehaviorCriteriaComparisonOperator'] = None,
                 consecutive_datapoints_to_alarm: Optional[int] = None,
                 consecutive_datapoints_to_clear: Optional[int] = None,
                 duration_seconds: Optional[int] = None,
                 ml_detection_config: Optional['outputs.SecurityProfileMachineLearningDetectionConfig'] = None,
                 statistical_threshold: Optional['outputs.SecurityProfileStatisticalThreshold'] = None,
                 value: Optional['outputs.SecurityProfileMetricValue'] = None):
        """
        The criteria by which the behavior is determined to be normal.
        :param 'SecurityProfileBehaviorCriteriaComparisonOperator' comparison_operator: The operator that relates the thing measured (metric) to the criteria (containing a value or statisticalThreshold).
        :param int consecutive_datapoints_to_alarm: If a device is in violation of the behavior for the specified number of consecutive datapoints, an alarm occurs. If not specified, the default is 1.
        :param int consecutive_datapoints_to_clear: If an alarm has occurred and the offending device is no longer in violation of the behavior for the specified number of consecutive datapoints, the alarm is cleared. If not specified, the default is 1.
        :param int duration_seconds: Use this to specify the time duration over which the behavior is evaluated.
        :param 'SecurityProfileMachineLearningDetectionConfig' ml_detection_config: The confidence level of the detection model.
        :param 'SecurityProfileStatisticalThreshold' statistical_threshold: A statistical ranking (percentile)that indicates a threshold value by which a behavior is determined to be in compliance or in violation of the behavior.
        :param 'SecurityProfileMetricValue' value: The value to be compared with the `metric` .
        """
        if comparison_operator is not None:
            pulumi.set(__self__, "comparison_operator", comparison_operator)
        if consecutive_datapoints_to_alarm is not None:
            pulumi.set(__self__, "consecutive_datapoints_to_alarm", consecutive_datapoints_to_alarm)
        if consecutive_datapoints_to_clear is not None:
            pulumi.set(__self__, "consecutive_datapoints_to_clear", consecutive_datapoints_to_clear)
        if duration_seconds is not None:
            pulumi.set(__self__, "duration_seconds", duration_seconds)
        if ml_detection_config is not None:
            pulumi.set(__self__, "ml_detection_config", ml_detection_config)
        if statistical_threshold is not None:
            pulumi.set(__self__, "statistical_threshold", statistical_threshold)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> Optional['SecurityProfileBehaviorCriteriaComparisonOperator']:
        """
        The operator that relates the thing measured (metric) to the criteria (containing a value or statisticalThreshold).
        """
        return pulumi.get(self, "comparison_operator")

    @property
    @pulumi.getter(name="consecutiveDatapointsToAlarm")
    def consecutive_datapoints_to_alarm(self) -> Optional[int]:
        """
        If a device is in violation of the behavior for the specified number of consecutive datapoints, an alarm occurs. If not specified, the default is 1.
        """
        return pulumi.get(self, "consecutive_datapoints_to_alarm")

    @property
    @pulumi.getter(name="consecutiveDatapointsToClear")
    def consecutive_datapoints_to_clear(self) -> Optional[int]:
        """
        If an alarm has occurred and the offending device is no longer in violation of the behavior for the specified number of consecutive datapoints, the alarm is cleared. If not specified, the default is 1.
        """
        return pulumi.get(self, "consecutive_datapoints_to_clear")

    @property
    @pulumi.getter(name="durationSeconds")
    def duration_seconds(self) -> Optional[int]:
        """
        Use this to specify the time duration over which the behavior is evaluated.
        """
        return pulumi.get(self, "duration_seconds")

    @property
    @pulumi.getter(name="mlDetectionConfig")
    def ml_detection_config(self) -> Optional['outputs.SecurityProfileMachineLearningDetectionConfig']:
        """
        The confidence level of the detection model.
        """
        return pulumi.get(self, "ml_detection_config")

    @property
    @pulumi.getter(name="statisticalThreshold")
    def statistical_threshold(self) -> Optional['outputs.SecurityProfileStatisticalThreshold']:
        """
        A statistical ranking (percentile)that indicates a threshold value by which a behavior is determined to be in compliance or in violation of the behavior.
        """
        return pulumi.get(self, "statistical_threshold")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.SecurityProfileMetricValue']:
        """
        The value to be compared with the `metric` .
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SecurityProfileMachineLearningDetectionConfig(dict):
    """
    The configuration of an ML Detect Security Profile.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "confidenceLevel":
            suggest = "confidence_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityProfileMachineLearningDetectionConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityProfileMachineLearningDetectionConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityProfileMachineLearningDetectionConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 confidence_level: Optional['SecurityProfileMachineLearningDetectionConfigConfidenceLevel'] = None):
        """
        The configuration of an ML Detect Security Profile.
        :param 'SecurityProfileMachineLearningDetectionConfigConfidenceLevel' confidence_level: The sensitivity of anomalous behavior evaluation. Can be Low, Medium, or High.
        """
        if confidence_level is not None:
            pulumi.set(__self__, "confidence_level", confidence_level)

    @property
    @pulumi.getter(name="confidenceLevel")
    def confidence_level(self) -> Optional['SecurityProfileMachineLearningDetectionConfigConfidenceLevel']:
        """
        The sensitivity of anomalous behavior evaluation. Can be Low, Medium, or High.
        """
        return pulumi.get(self, "confidence_level")


@pulumi.output_type
class SecurityProfileMetricDimension(dict):
    """
    The dimension of a metric.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dimensionName":
            suggest = "dimension_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityProfileMetricDimension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityProfileMetricDimension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityProfileMetricDimension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dimension_name: str,
                 operator: Optional['SecurityProfileMetricDimensionOperator'] = None):
        """
        The dimension of a metric.
        :param str dimension_name: A unique identifier for the dimension.
        :param 'SecurityProfileMetricDimensionOperator' operator: Defines how the dimensionValues of a dimension are interpreted.
        """
        pulumi.set(__self__, "dimension_name", dimension_name)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter(name="dimensionName")
    def dimension_name(self) -> str:
        """
        A unique identifier for the dimension.
        """
        return pulumi.get(self, "dimension_name")

    @property
    @pulumi.getter
    def operator(self) -> Optional['SecurityProfileMetricDimensionOperator']:
        """
        Defines how the dimensionValues of a dimension are interpreted.
        """
        return pulumi.get(self, "operator")


@pulumi.output_type
class SecurityProfileMetricToRetain(dict):
    """
    The metric you want to retain. Dimensions are optional.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exportMetric":
            suggest = "export_metric"
        elif key == "metricDimension":
            suggest = "metric_dimension"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityProfileMetricToRetain. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityProfileMetricToRetain.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityProfileMetricToRetain.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 export_metric: Optional[bool] = None,
                 metric_dimension: Optional['outputs.SecurityProfileMetricDimension'] = None):
        """
        The metric you want to retain. Dimensions are optional.
        :param str metric: What is measured by the behavior.
        :param bool export_metric: The value indicates exporting metrics related to the `MetricToRetain` when it's true.
        :param 'SecurityProfileMetricDimension' metric_dimension: The dimension of the metric.
        """
        pulumi.set(__self__, "metric", metric)
        if export_metric is not None:
            pulumi.set(__self__, "export_metric", export_metric)
        if metric_dimension is not None:
            pulumi.set(__self__, "metric_dimension", metric_dimension)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        What is measured by the behavior.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="exportMetric")
    def export_metric(self) -> Optional[bool]:
        """
        The value indicates exporting metrics related to the `MetricToRetain` when it's true.
        """
        return pulumi.get(self, "export_metric")

    @property
    @pulumi.getter(name="metricDimension")
    def metric_dimension(self) -> Optional['outputs.SecurityProfileMetricDimension']:
        """
        The dimension of the metric.
        """
        return pulumi.get(self, "metric_dimension")


@pulumi.output_type
class SecurityProfileMetricValue(dict):
    """
    The value to be compared with the metric.
    """
    def __init__(__self__, *,
                 cidrs: Optional[Sequence[str]] = None,
                 count: Optional[str] = None,
                 number: Optional[float] = None,
                 numbers: Optional[Sequence[float]] = None,
                 ports: Optional[Sequence[int]] = None,
                 strings: Optional[Sequence[str]] = None):
        """
        The value to be compared with the metric.
        :param Sequence[str] cidrs: If the ComparisonOperator calls for a set of CIDRs, use this to specify that set to be compared with the metric.
        :param str count: If the ComparisonOperator calls for a numeric value, use this to specify that (integer) numeric value to be compared with the metric.
        :param float number: The numeral value of a metric.
        :param Sequence[float] numbers: The numeral values of a metric.
        :param Sequence[int] ports: If the ComparisonOperator calls for a set of ports, use this to specify that set to be compared with the metric.
        :param Sequence[str] strings: The string values of a metric.
        """
        if cidrs is not None:
            pulumi.set(__self__, "cidrs", cidrs)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if number is not None:
            pulumi.set(__self__, "number", number)
        if numbers is not None:
            pulumi.set(__self__, "numbers", numbers)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if strings is not None:
            pulumi.set(__self__, "strings", strings)

    @property
    @pulumi.getter
    def cidrs(self) -> Optional[Sequence[str]]:
        """
        If the ComparisonOperator calls for a set of CIDRs, use this to specify that set to be compared with the metric.
        """
        return pulumi.get(self, "cidrs")

    @property
    @pulumi.getter
    def count(self) -> Optional[str]:
        """
        If the ComparisonOperator calls for a numeric value, use this to specify that (integer) numeric value to be compared with the metric.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def number(self) -> Optional[float]:
        """
        The numeral value of a metric.
        """
        return pulumi.get(self, "number")

    @property
    @pulumi.getter
    def numbers(self) -> Optional[Sequence[float]]:
        """
        The numeral values of a metric.
        """
        return pulumi.get(self, "numbers")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[int]]:
        """
        If the ComparisonOperator calls for a set of ports, use this to specify that set to be compared with the metric.
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter
    def strings(self) -> Optional[Sequence[str]]:
        """
        The string values of a metric.
        """
        return pulumi.get(self, "strings")


@pulumi.output_type
class SecurityProfileStatisticalThreshold(dict):
    """
    A statistical ranking (percentile) which indicates a threshold value by which a behavior is determined to be in compliance or in violation of the behavior.
    """
    def __init__(__self__, *,
                 statistic: Optional['SecurityProfileStatisticalThresholdStatistic'] = None):
        """
        A statistical ranking (percentile) which indicates a threshold value by which a behavior is determined to be in compliance or in violation of the behavior.
        :param 'SecurityProfileStatisticalThresholdStatistic' statistic: The percentile which resolves to a threshold value by which compliance with a behavior is determined
        """
        if statistic is not None:
            pulumi.set(__self__, "statistic", statistic)

    @property
    @pulumi.getter
    def statistic(self) -> Optional['SecurityProfileStatisticalThresholdStatistic']:
        """
        The percentile which resolves to a threshold value by which compliance with a behavior is determined
        """
        return pulumi.get(self, "statistic")


@pulumi.output_type
class ThingAttributePayload(dict):
    def __init__(__self__, *,
                 attributes: Optional[Mapping[str, str]] = None):
        """
        :param Mapping[str, str] attributes: A JSON string containing up to three key-value pair in JSON format. For example:
               
               `{\\"attributes\\":{\\"string1\\":\\"string2\\"}}`
        """
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)

    @property
    @pulumi.getter
    def attributes(self) -> Optional[Mapping[str, str]]:
        """
        A JSON string containing up to three key-value pair in JSON format. For example:

        `{\\"attributes\\":{\\"string1\\":\\"string2\\"}}`
        """
        return pulumi.get(self, "attributes")


@pulumi.output_type
class ThingGroupAttributePayload(dict):
    def __init__(__self__, *,
                 attributes: Optional[Mapping[str, str]] = None):
        """
        :param Mapping[str, str] attributes: A JSON string containing up to three key-value pair in JSON format. For example:
               
               `{\\"attributes\\":{\\"string1\\":\\"string2\\"}}`
        """
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)

    @property
    @pulumi.getter
    def attributes(self) -> Optional[Mapping[str, str]]:
        """
        A JSON string containing up to three key-value pair in JSON format. For example:

        `{\\"attributes\\":{\\"string1\\":\\"string2\\"}}`
        """
        return pulumi.get(self, "attributes")


@pulumi.output_type
class ThingGroupPropertiesProperties(dict):
    """
    Thing group properties.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributePayload":
            suggest = "attribute_payload"
        elif key == "thingGroupDescription":
            suggest = "thing_group_description"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ThingGroupPropertiesProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ThingGroupPropertiesProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ThingGroupPropertiesProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_payload: Optional['outputs.ThingGroupAttributePayload'] = None,
                 thing_group_description: Optional[str] = None):
        """
        Thing group properties.
        :param 'ThingGroupAttributePayload' attribute_payload: The thing group attributes in JSON format.
        :param str thing_group_description: The thing group description.
        """
        if attribute_payload is not None:
            pulumi.set(__self__, "attribute_payload", attribute_payload)
        if thing_group_description is not None:
            pulumi.set(__self__, "thing_group_description", thing_group_description)

    @property
    @pulumi.getter(name="attributePayload")
    def attribute_payload(self) -> Optional['outputs.ThingGroupAttributePayload']:
        """
        The thing group attributes in JSON format.
        """
        return pulumi.get(self, "attribute_payload")

    @property
    @pulumi.getter(name="thingGroupDescription")
    def thing_group_description(self) -> Optional[str]:
        """
        The thing group description.
        """
        return pulumi.get(self, "thing_group_description")


@pulumi.output_type
class ThingTypePropertiesProperties(dict):
    """
    The thing type properties for the thing type to create. It contains information about the new thing type including a description, and a list of searchable thing attribute names. `ThingTypeProperties` can't be updated after the initial creation of the `ThingType` .
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "searchableAttributes":
            suggest = "searchable_attributes"
        elif key == "thingTypeDescription":
            suggest = "thing_type_description"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ThingTypePropertiesProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ThingTypePropertiesProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ThingTypePropertiesProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 searchable_attributes: Optional[Sequence[str]] = None,
                 thing_type_description: Optional[str] = None):
        """
        The thing type properties for the thing type to create. It contains information about the new thing type including a description, and a list of searchable thing attribute names. `ThingTypeProperties` can't be updated after the initial creation of the `ThingType` .
        :param Sequence[str] searchable_attributes: A list of searchable thing attribute names.
        :param str thing_type_description: The description of the thing type.
        """
        if searchable_attributes is not None:
            pulumi.set(__self__, "searchable_attributes", searchable_attributes)
        if thing_type_description is not None:
            pulumi.set(__self__, "thing_type_description", thing_type_description)

    @property
    @pulumi.getter(name="searchableAttributes")
    def searchable_attributes(self) -> Optional[Sequence[str]]:
        """
        A list of searchable thing attribute names.
        """
        return pulumi.get(self, "searchable_attributes")

    @property
    @pulumi.getter(name="thingTypeDescription")
    def thing_type_description(self) -> Optional[str]:
        """
        The description of the thing type.
        """
        return pulumi.get(self, "thing_type_description")


@pulumi.output_type
class TimeoutConfigProperties(dict):
    """
    Specifies the amount of time each device has to finish its execution of the job.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inProgressTimeoutInMinutes":
            suggest = "in_progress_timeout_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TimeoutConfigProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TimeoutConfigProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TimeoutConfigProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 in_progress_timeout_in_minutes: int):
        """
        Specifies the amount of time each device has to finish its execution of the job.
        :param int in_progress_timeout_in_minutes: Specifies the amount of time, in minutes, this device has to finish execution of this job. The timeout interval can be anywhere between 1 minute and 7 days (1 to 10080 minutes). The in progress timer can't be updated and will apply to all job executions for the job. Whenever a job execution remains in the IN_PROGRESS status for longer than this interval, the job execution will fail and switch to the terminal `TIMED_OUT` status.
        """
        pulumi.set(__self__, "in_progress_timeout_in_minutes", in_progress_timeout_in_minutes)

    @property
    @pulumi.getter(name="inProgressTimeoutInMinutes")
    def in_progress_timeout_in_minutes(self) -> int:
        """
        Specifies the amount of time, in minutes, this device has to finish execution of this job. The timeout interval can be anywhere between 1 minute and 7 days (1 to 10080 minutes). The in progress timer can't be updated and will apply to all job executions for the job. Whenever a job execution remains in the IN_PROGRESS status for longer than this interval, the job execution will fail and switch to the terminal `TIMED_OUT` status.
        """
        return pulumi.get(self, "in_progress_timeout_in_minutes")


@pulumi.output_type
class TopicRuleAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudwatchAlarm":
            suggest = "cloudwatch_alarm"
        elif key == "cloudwatchLogs":
            suggest = "cloudwatch_logs"
        elif key == "cloudwatchMetric":
            suggest = "cloudwatch_metric"
        elif key == "dynamoDBv2":
            suggest = "dynamo_d_bv2"
        elif key == "dynamoDb":
            suggest = "dynamo_db"
        elif key == "iotAnalytics":
            suggest = "iot_analytics"
        elif key == "iotEvents":
            suggest = "iot_events"
        elif key == "iotSiteWise":
            suggest = "iot_site_wise"
        elif key == "lambda":
            suggest = "lambda_"
        elif key == "openSearch":
            suggest = "open_search"
        elif key == "stepFunctions":
            suggest = "step_functions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloudwatch_alarm: Optional['outputs.TopicRuleCloudwatchAlarmAction'] = None,
                 cloudwatch_logs: Optional['outputs.TopicRuleCloudwatchLogsAction'] = None,
                 cloudwatch_metric: Optional['outputs.TopicRuleCloudwatchMetricAction'] = None,
                 dynamo_d_bv2: Optional['outputs.TopicRuleDynamoDBv2Action'] = None,
                 dynamo_db: Optional['outputs.TopicRuleDynamoDbAction'] = None,
                 elasticsearch: Optional['outputs.TopicRuleElasticsearchAction'] = None,
                 firehose: Optional['outputs.TopicRuleFirehoseAction'] = None,
                 http: Optional['outputs.TopicRuleHttpAction'] = None,
                 iot_analytics: Optional['outputs.TopicRuleIotAnalyticsAction'] = None,
                 iot_events: Optional['outputs.TopicRuleIotEventsAction'] = None,
                 iot_site_wise: Optional['outputs.TopicRuleIotSiteWiseAction'] = None,
                 kafka: Optional['outputs.TopicRuleKafkaAction'] = None,
                 kinesis: Optional['outputs.TopicRuleKinesisAction'] = None,
                 lambda_: Optional['outputs.TopicRuleLambdaAction'] = None,
                 location: Optional['outputs.TopicRuleLocationAction'] = None,
                 open_search: Optional['outputs.TopicRuleOpenSearchAction'] = None,
                 republish: Optional['outputs.TopicRuleRepublishAction'] = None,
                 s3: Optional['outputs.TopicRuleS3Action'] = None,
                 sns: Optional['outputs.TopicRuleSnsAction'] = None,
                 sqs: Optional['outputs.TopicRuleSqsAction'] = None,
                 step_functions: Optional['outputs.TopicRuleStepFunctionsAction'] = None,
                 timestream: Optional['outputs.TopicRuleTimestreamAction'] = None):
        """
        :param 'TopicRuleCloudwatchAlarmAction' cloudwatch_alarm: Change the state of a CloudWatch alarm.
        :param 'TopicRuleCloudwatchLogsAction' cloudwatch_logs: Sends data to CloudWatch.
        :param 'TopicRuleCloudwatchMetricAction' cloudwatch_metric: Capture a CloudWatch metric.
        :param 'TopicRuleDynamoDBv2Action' dynamo_d_bv2: Write to a DynamoDB table. This is a new version of the DynamoDB action. It allows you to write each attribute in an MQTT message payload into a separate DynamoDB column.
        :param 'TopicRuleDynamoDbAction' dynamo_db: Write to a DynamoDB table.
        :param 'TopicRuleElasticsearchAction' elasticsearch: Write data to an Amazon OpenSearch Service domain.
               
               > The `Elasticsearch` action can only be used by existing rule actions. To create a new rule action or to update an existing rule action, use the `OpenSearch` rule action instead. For more information, see [OpenSearchAction](https://docs.aws.amazon.com//iot/latest/apireference/API_OpenSearchAction.html) .
        :param 'TopicRuleFirehoseAction' firehose: Write to an Amazon Kinesis Firehose stream.
        :param 'TopicRuleHttpAction' http: Send data to an HTTPS endpoint.
        :param 'TopicRuleIotAnalyticsAction' iot_analytics: Sends message data to an AWS IoT Analytics channel.
        :param 'TopicRuleIotEventsAction' iot_events: Sends an input to an AWS IoT Events detector.
        :param 'TopicRuleIotSiteWiseAction' iot_site_wise: Sends data from the MQTT message that triggered the rule to AWS IoT SiteWise asset properties.
        :param 'TopicRuleKafkaAction' kafka: Send messages to an Amazon Managed Streaming for Apache Kafka (Amazon MSK) or self-managed Apache Kafka cluster.
        :param 'TopicRuleKinesisAction' kinesis: Write data to an Amazon Kinesis stream.
        :param 'TopicRuleLambdaAction' lambda_: Invoke a Lambda function.
        :param 'TopicRuleLocationAction' location: Sends device location data to [Amazon Location Service](https://docs.aws.amazon.com//location/latest/developerguide/welcome.html) .
        :param 'TopicRuleOpenSearchAction' open_search: Write data to an Amazon OpenSearch Service domain.
        :param 'TopicRuleRepublishAction' republish: Publish to another MQTT topic.
        :param 'TopicRuleS3Action' s3: Write to an Amazon S3 bucket.
        :param 'TopicRuleSnsAction' sns: Publish to an Amazon SNS topic.
        :param 'TopicRuleSqsAction' sqs: Publish to an Amazon SQS queue.
        :param 'TopicRuleStepFunctionsAction' step_functions: Starts execution of a Step Functions state machine.
        :param 'TopicRuleTimestreamAction' timestream: Writes attributes from an MQTT message.
        """
        if cloudwatch_alarm is not None:
            pulumi.set(__self__, "cloudwatch_alarm", cloudwatch_alarm)
        if cloudwatch_logs is not None:
            pulumi.set(__self__, "cloudwatch_logs", cloudwatch_logs)
        if cloudwatch_metric is not None:
            pulumi.set(__self__, "cloudwatch_metric", cloudwatch_metric)
        if dynamo_d_bv2 is not None:
            pulumi.set(__self__, "dynamo_d_bv2", dynamo_d_bv2)
        if dynamo_db is not None:
            pulumi.set(__self__, "dynamo_db", dynamo_db)
        if elasticsearch is not None:
            pulumi.set(__self__, "elasticsearch", elasticsearch)
        if firehose is not None:
            pulumi.set(__self__, "firehose", firehose)
        if http is not None:
            pulumi.set(__self__, "http", http)
        if iot_analytics is not None:
            pulumi.set(__self__, "iot_analytics", iot_analytics)
        if iot_events is not None:
            pulumi.set(__self__, "iot_events", iot_events)
        if iot_site_wise is not None:
            pulumi.set(__self__, "iot_site_wise", iot_site_wise)
        if kafka is not None:
            pulumi.set(__self__, "kafka", kafka)
        if kinesis is not None:
            pulumi.set(__self__, "kinesis", kinesis)
        if lambda_ is not None:
            pulumi.set(__self__, "lambda_", lambda_)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if open_search is not None:
            pulumi.set(__self__, "open_search", open_search)
        if republish is not None:
            pulumi.set(__self__, "republish", republish)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if sns is not None:
            pulumi.set(__self__, "sns", sns)
        if sqs is not None:
            pulumi.set(__self__, "sqs", sqs)
        if step_functions is not None:
            pulumi.set(__self__, "step_functions", step_functions)
        if timestream is not None:
            pulumi.set(__self__, "timestream", timestream)

    @property
    @pulumi.getter(name="cloudwatchAlarm")
    def cloudwatch_alarm(self) -> Optional['outputs.TopicRuleCloudwatchAlarmAction']:
        """
        Change the state of a CloudWatch alarm.
        """
        return pulumi.get(self, "cloudwatch_alarm")

    @property
    @pulumi.getter(name="cloudwatchLogs")
    def cloudwatch_logs(self) -> Optional['outputs.TopicRuleCloudwatchLogsAction']:
        """
        Sends data to CloudWatch.
        """
        return pulumi.get(self, "cloudwatch_logs")

    @property
    @pulumi.getter(name="cloudwatchMetric")
    def cloudwatch_metric(self) -> Optional['outputs.TopicRuleCloudwatchMetricAction']:
        """
        Capture a CloudWatch metric.
        """
        return pulumi.get(self, "cloudwatch_metric")

    @property
    @pulumi.getter(name="dynamoDBv2")
    def dynamo_d_bv2(self) -> Optional['outputs.TopicRuleDynamoDBv2Action']:
        """
        Write to a DynamoDB table. This is a new version of the DynamoDB action. It allows you to write each attribute in an MQTT message payload into a separate DynamoDB column.
        """
        return pulumi.get(self, "dynamo_d_bv2")

    @property
    @pulumi.getter(name="dynamoDb")
    def dynamo_db(self) -> Optional['outputs.TopicRuleDynamoDbAction']:
        """
        Write to a DynamoDB table.
        """
        return pulumi.get(self, "dynamo_db")

    @property
    @pulumi.getter
    def elasticsearch(self) -> Optional['outputs.TopicRuleElasticsearchAction']:
        """
        Write data to an Amazon OpenSearch Service domain.

        > The `Elasticsearch` action can only be used by existing rule actions. To create a new rule action or to update an existing rule action, use the `OpenSearch` rule action instead. For more information, see [OpenSearchAction](https://docs.aws.amazon.com//iot/latest/apireference/API_OpenSearchAction.html) .
        """
        return pulumi.get(self, "elasticsearch")

    @property
    @pulumi.getter
    def firehose(self) -> Optional['outputs.TopicRuleFirehoseAction']:
        """
        Write to an Amazon Kinesis Firehose stream.
        """
        return pulumi.get(self, "firehose")

    @property
    @pulumi.getter
    def http(self) -> Optional['outputs.TopicRuleHttpAction']:
        """
        Send data to an HTTPS endpoint.
        """
        return pulumi.get(self, "http")

    @property
    @pulumi.getter(name="iotAnalytics")
    def iot_analytics(self) -> Optional['outputs.TopicRuleIotAnalyticsAction']:
        """
        Sends message data to an AWS IoT Analytics channel.
        """
        return pulumi.get(self, "iot_analytics")

    @property
    @pulumi.getter(name="iotEvents")
    def iot_events(self) -> Optional['outputs.TopicRuleIotEventsAction']:
        """
        Sends an input to an AWS IoT Events detector.
        """
        return pulumi.get(self, "iot_events")

    @property
    @pulumi.getter(name="iotSiteWise")
    def iot_site_wise(self) -> Optional['outputs.TopicRuleIotSiteWiseAction']:
        """
        Sends data from the MQTT message that triggered the rule to AWS IoT SiteWise asset properties.
        """
        return pulumi.get(self, "iot_site_wise")

    @property
    @pulumi.getter
    def kafka(self) -> Optional['outputs.TopicRuleKafkaAction']:
        """
        Send messages to an Amazon Managed Streaming for Apache Kafka (Amazon MSK) or self-managed Apache Kafka cluster.
        """
        return pulumi.get(self, "kafka")

    @property
    @pulumi.getter
    def kinesis(self) -> Optional['outputs.TopicRuleKinesisAction']:
        """
        Write data to an Amazon Kinesis stream.
        """
        return pulumi.get(self, "kinesis")

    @property
    @pulumi.getter(name="lambda")
    def lambda_(self) -> Optional['outputs.TopicRuleLambdaAction']:
        """
        Invoke a Lambda function.
        """
        return pulumi.get(self, "lambda_")

    @property
    @pulumi.getter
    def location(self) -> Optional['outputs.TopicRuleLocationAction']:
        """
        Sends device location data to [Amazon Location Service](https://docs.aws.amazon.com//location/latest/developerguide/welcome.html) .
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="openSearch")
    def open_search(self) -> Optional['outputs.TopicRuleOpenSearchAction']:
        """
        Write data to an Amazon OpenSearch Service domain.
        """
        return pulumi.get(self, "open_search")

    @property
    @pulumi.getter
    def republish(self) -> Optional['outputs.TopicRuleRepublishAction']:
        """
        Publish to another MQTT topic.
        """
        return pulumi.get(self, "republish")

    @property
    @pulumi.getter
    def s3(self) -> Optional['outputs.TopicRuleS3Action']:
        """
        Write to an Amazon S3 bucket.
        """
        return pulumi.get(self, "s3")

    @property
    @pulumi.getter
    def sns(self) -> Optional['outputs.TopicRuleSnsAction']:
        """
        Publish to an Amazon SNS topic.
        """
        return pulumi.get(self, "sns")

    @property
    @pulumi.getter
    def sqs(self) -> Optional['outputs.TopicRuleSqsAction']:
        """
        Publish to an Amazon SQS queue.
        """
        return pulumi.get(self, "sqs")

    @property
    @pulumi.getter(name="stepFunctions")
    def step_functions(self) -> Optional['outputs.TopicRuleStepFunctionsAction']:
        """
        Starts execution of a Step Functions state machine.
        """
        return pulumi.get(self, "step_functions")

    @property
    @pulumi.getter
    def timestream(self) -> Optional['outputs.TopicRuleTimestreamAction']:
        """
        Writes attributes from an MQTT message.
        """
        return pulumi.get(self, "timestream")


@pulumi.output_type
class TopicRuleAssetPropertyTimestamp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeInSeconds":
            suggest = "time_in_seconds"
        elif key == "offsetInNanos":
            suggest = "offset_in_nanos"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleAssetPropertyTimestamp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleAssetPropertyTimestamp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleAssetPropertyTimestamp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 time_in_seconds: str,
                 offset_in_nanos: Optional[str] = None):
        """
        :param str time_in_seconds: A string that contains the time in seconds since epoch. Accepts substitution templates.
        :param str offset_in_nanos: Optional. A string that contains the nanosecond time offset. Accepts substitution templates.
        """
        pulumi.set(__self__, "time_in_seconds", time_in_seconds)
        if offset_in_nanos is not None:
            pulumi.set(__self__, "offset_in_nanos", offset_in_nanos)

    @property
    @pulumi.getter(name="timeInSeconds")
    def time_in_seconds(self) -> str:
        """
        A string that contains the time in seconds since epoch. Accepts substitution templates.
        """
        return pulumi.get(self, "time_in_seconds")

    @property
    @pulumi.getter(name="offsetInNanos")
    def offset_in_nanos(self) -> Optional[str]:
        """
        Optional. A string that contains the nanosecond time offset. Accepts substitution templates.
        """
        return pulumi.get(self, "offset_in_nanos")


@pulumi.output_type
class TopicRuleAssetPropertyValue(dict):
    def __init__(__self__, *,
                 timestamp: 'outputs.TopicRuleAssetPropertyTimestamp',
                 value: 'outputs.TopicRuleAssetPropertyVariant',
                 quality: Optional[str] = None):
        """
        :param 'TopicRuleAssetPropertyTimestamp' timestamp: The asset property value timestamp.
        :param 'TopicRuleAssetPropertyVariant' value: The value of the asset property.
        :param str quality: Optional. A string that describes the quality of the value. Accepts substitution templates. Must be `GOOD` , `BAD` , or `UNCERTAIN` .
        """
        pulumi.set(__self__, "timestamp", timestamp)
        pulumi.set(__self__, "value", value)
        if quality is not None:
            pulumi.set(__self__, "quality", quality)

    @property
    @pulumi.getter
    def timestamp(self) -> 'outputs.TopicRuleAssetPropertyTimestamp':
        """
        The asset property value timestamp.
        """
        return pulumi.get(self, "timestamp")

    @property
    @pulumi.getter
    def value(self) -> 'outputs.TopicRuleAssetPropertyVariant':
        """
        The value of the asset property.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def quality(self) -> Optional[str]:
        """
        Optional. A string that describes the quality of the value. Accepts substitution templates. Must be `GOOD` , `BAD` , or `UNCERTAIN` .
        """
        return pulumi.get(self, "quality")


@pulumi.output_type
class TopicRuleAssetPropertyVariant(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "booleanValue":
            suggest = "boolean_value"
        elif key == "doubleValue":
            suggest = "double_value"
        elif key == "integerValue":
            suggest = "integer_value"
        elif key == "stringValue":
            suggest = "string_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleAssetPropertyVariant. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleAssetPropertyVariant.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleAssetPropertyVariant.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 boolean_value: Optional[str] = None,
                 double_value: Optional[str] = None,
                 integer_value: Optional[str] = None,
                 string_value: Optional[str] = None):
        """
        :param str boolean_value: Optional. A string that contains the boolean value ( `true` or `false` ) of the value entry. Accepts substitution templates.
        :param str double_value: Optional. A string that contains the double value of the value entry. Accepts substitution templates.
        :param str integer_value: Optional. A string that contains the integer value of the value entry. Accepts substitution templates.
        :param str string_value: Optional. The string value of the value entry. Accepts substitution templates.
        """
        if boolean_value is not None:
            pulumi.set(__self__, "boolean_value", boolean_value)
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if integer_value is not None:
            pulumi.set(__self__, "integer_value", integer_value)
        if string_value is not None:
            pulumi.set(__self__, "string_value", string_value)

    @property
    @pulumi.getter(name="booleanValue")
    def boolean_value(self) -> Optional[str]:
        """
        Optional. A string that contains the boolean value ( `true` or `false` ) of the value entry. Accepts substitution templates.
        """
        return pulumi.get(self, "boolean_value")

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional[str]:
        """
        Optional. A string that contains the double value of the value entry. Accepts substitution templates.
        """
        return pulumi.get(self, "double_value")

    @property
    @pulumi.getter(name="integerValue")
    def integer_value(self) -> Optional[str]:
        """
        Optional. A string that contains the integer value of the value entry. Accepts substitution templates.
        """
        return pulumi.get(self, "integer_value")

    @property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> Optional[str]:
        """
        Optional. The string value of the value entry. Accepts substitution templates.
        """
        return pulumi.get(self, "string_value")


@pulumi.output_type
class TopicRuleCloudwatchAlarmAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alarmName":
            suggest = "alarm_name"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "stateReason":
            suggest = "state_reason"
        elif key == "stateValue":
            suggest = "state_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleCloudwatchAlarmAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleCloudwatchAlarmAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleCloudwatchAlarmAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alarm_name: str,
                 role_arn: str,
                 state_reason: str,
                 state_value: str):
        """
        :param str alarm_name: The CloudWatch alarm name.
        :param str role_arn: The IAM role that allows access to the CloudWatch alarm.
        :param str state_reason: The reason for the alarm change.
        :param str state_value: The value of the alarm state. Acceptable values are: OK, ALARM, INSUFFICIENT_DATA.
        """
        pulumi.set(__self__, "alarm_name", alarm_name)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "state_reason", state_reason)
        pulumi.set(__self__, "state_value", state_value)

    @property
    @pulumi.getter(name="alarmName")
    def alarm_name(self) -> str:
        """
        The CloudWatch alarm name.
        """
        return pulumi.get(self, "alarm_name")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        The IAM role that allows access to the CloudWatch alarm.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="stateReason")
    def state_reason(self) -> str:
        """
        The reason for the alarm change.
        """
        return pulumi.get(self, "state_reason")

    @property
    @pulumi.getter(name="stateValue")
    def state_value(self) -> str:
        """
        The value of the alarm state. Acceptable values are: OK, ALARM, INSUFFICIENT_DATA.
        """
        return pulumi.get(self, "state_value")


@pulumi.output_type
class TopicRuleCloudwatchLogsAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logGroupName":
            suggest = "log_group_name"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "batchMode":
            suggest = "batch_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleCloudwatchLogsAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleCloudwatchLogsAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleCloudwatchLogsAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_group_name: str,
                 role_arn: str,
                 batch_mode: Optional[bool] = None):
        """
        :param str log_group_name: The CloudWatch log name.
        :param str role_arn: The IAM role that allows access to the CloudWatch log.
        :param bool batch_mode: Indicates whether batches of log records will be extracted and uploaded into CloudWatch.
        """
        pulumi.set(__self__, "log_group_name", log_group_name)
        pulumi.set(__self__, "role_arn", role_arn)
        if batch_mode is not None:
            pulumi.set(__self__, "batch_mode", batch_mode)

    @property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> str:
        """
        The CloudWatch log name.
        """
        return pulumi.get(self, "log_group_name")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        The IAM role that allows access to the CloudWatch log.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="batchMode")
    def batch_mode(self) -> Optional[bool]:
        """
        Indicates whether batches of log records will be extracted and uploaded into CloudWatch.
        """
        return pulumi.get(self, "batch_mode")


@pulumi.output_type
class TopicRuleCloudwatchMetricAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"
        elif key == "metricNamespace":
            suggest = "metric_namespace"
        elif key == "metricUnit":
            suggest = "metric_unit"
        elif key == "metricValue":
            suggest = "metric_value"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "metricTimestamp":
            suggest = "metric_timestamp"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleCloudwatchMetricAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleCloudwatchMetricAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleCloudwatchMetricAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_name: str,
                 metric_namespace: str,
                 metric_unit: str,
                 metric_value: str,
                 role_arn: str,
                 metric_timestamp: Optional[str] = None):
        """
        :param str metric_name: The CloudWatch metric name.
        :param str metric_namespace: The CloudWatch metric namespace name.
        :param str metric_unit: The [metric unit](https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#Unit) supported by CloudWatch.
        :param str metric_value: The CloudWatch metric value.
        :param str role_arn: The IAM role that allows access to the CloudWatch metric.
        :param str metric_timestamp: An optional [Unix timestamp](https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#about_timestamp) .
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "metric_namespace", metric_namespace)
        pulumi.set(__self__, "metric_unit", metric_unit)
        pulumi.set(__self__, "metric_value", metric_value)
        pulumi.set(__self__, "role_arn", role_arn)
        if metric_timestamp is not None:
            pulumi.set(__self__, "metric_timestamp", metric_timestamp)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        """
        The CloudWatch metric name.
        """
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter(name="metricNamespace")
    def metric_namespace(self) -> str:
        """
        The CloudWatch metric namespace name.
        """
        return pulumi.get(self, "metric_namespace")

    @property
    @pulumi.getter(name="metricUnit")
    def metric_unit(self) -> str:
        """
        The [metric unit](https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#Unit) supported by CloudWatch.
        """
        return pulumi.get(self, "metric_unit")

    @property
    @pulumi.getter(name="metricValue")
    def metric_value(self) -> str:
        """
        The CloudWatch metric value.
        """
        return pulumi.get(self, "metric_value")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        The IAM role that allows access to the CloudWatch metric.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="metricTimestamp")
    def metric_timestamp(self) -> Optional[str]:
        """
        An optional [Unix timestamp](https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#about_timestamp) .
        """
        return pulumi.get(self, "metric_timestamp")


@pulumi.output_type
class TopicRuleDestinationHttpUrlDestinationSummary(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "confirmationUrl":
            suggest = "confirmation_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleDestinationHttpUrlDestinationSummary. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleDestinationHttpUrlDestinationSummary.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleDestinationHttpUrlDestinationSummary.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 confirmation_url: Optional[str] = None):
        """
        :param str confirmation_url: The URL used to confirm the HTTP topic rule destination URL.
        """
        if confirmation_url is not None:
            pulumi.set(__self__, "confirmation_url", confirmation_url)

    @property
    @pulumi.getter(name="confirmationUrl")
    def confirmation_url(self) -> Optional[str]:
        """
        The URL used to confirm the HTTP topic rule destination URL.
        """
        return pulumi.get(self, "confirmation_url")


@pulumi.output_type
class TopicRuleDestinationVpcDestinationProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"
        elif key == "securityGroups":
            suggest = "security_groups"
        elif key == "subnetIds":
            suggest = "subnet_ids"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleDestinationVpcDestinationProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleDestinationVpcDestinationProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleDestinationVpcDestinationProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: Optional[str] = None,
                 security_groups: Optional[Sequence[str]] = None,
                 subnet_ids: Optional[Sequence[str]] = None,
                 vpc_id: Optional[str] = None):
        """
        :param str role_arn: The ARN of a role that has permission to create and attach to elastic network interfaces (ENIs).
        :param Sequence[str] security_groups: The security groups of the VPC destination.
        :param Sequence[str] subnet_ids: The subnet IDs of the VPC destination.
        :param str vpc_id: The ID of the VPC.
        """
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if subnet_ids is not None:
            pulumi.set(__self__, "subnet_ids", subnet_ids)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        The ARN of a role that has permission to create and attach to elastic network interfaces (ENIs).
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[str]]:
        """
        The security groups of the VPC destination.
        """
        return pulumi.get(self, "security_groups")

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Optional[Sequence[str]]:
        """
        The subnet IDs of the VPC destination.
        """
        return pulumi.get(self, "subnet_ids")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[str]:
        """
        The ID of the VPC.
        """
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class TopicRuleDynamoDBv2Action(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "putItem":
            suggest = "put_item"
        elif key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleDynamoDBv2Action. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleDynamoDBv2Action.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleDynamoDBv2Action.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 put_item: Optional['outputs.TopicRulePutItemInput'] = None,
                 role_arn: Optional[str] = None):
        """
        :param 'TopicRulePutItemInput' put_item: Specifies the DynamoDB table to which the message data will be written. For example:
               
               `{ "dynamoDBv2": { "roleArn": "aws:iam:12341251:my-role" "putItem": { "tableName": "my-table" } } }`
               
               Each attribute in the message payload will be written to a separate column in the DynamoDB database.
        :param str role_arn: The ARN of the IAM role that grants access to the DynamoDB table.
        """
        if put_item is not None:
            pulumi.set(__self__, "put_item", put_item)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter(name="putItem")
    def put_item(self) -> Optional['outputs.TopicRulePutItemInput']:
        """
        Specifies the DynamoDB table to which the message data will be written. For example:

        `{ "dynamoDBv2": { "roleArn": "aws:iam:12341251:my-role" "putItem": { "tableName": "my-table" } } }`

        Each attribute in the message payload will be written to a separate column in the DynamoDB database.
        """
        return pulumi.get(self, "put_item")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        The ARN of the IAM role that grants access to the DynamoDB table.
        """
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class TopicRuleDynamoDbAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hashKeyField":
            suggest = "hash_key_field"
        elif key == "hashKeyValue":
            suggest = "hash_key_value"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "tableName":
            suggest = "table_name"
        elif key == "hashKeyType":
            suggest = "hash_key_type"
        elif key == "payloadField":
            suggest = "payload_field"
        elif key == "rangeKeyField":
            suggest = "range_key_field"
        elif key == "rangeKeyType":
            suggest = "range_key_type"
        elif key == "rangeKeyValue":
            suggest = "range_key_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleDynamoDbAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleDynamoDbAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleDynamoDbAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hash_key_field: str,
                 hash_key_value: str,
                 role_arn: str,
                 table_name: str,
                 hash_key_type: Optional[str] = None,
                 payload_field: Optional[str] = None,
                 range_key_field: Optional[str] = None,
                 range_key_type: Optional[str] = None,
                 range_key_value: Optional[str] = None):
        """
        :param str hash_key_field: The hash key name.
        :param str hash_key_value: The hash key value.
        :param str role_arn: The ARN of the IAM role that grants access to the DynamoDB table.
        :param str table_name: The name of the DynamoDB table.
        :param str hash_key_type: The hash key type. Valid values are "STRING" or "NUMBER"
        :param str payload_field: The action payload. This name can be customized.
        :param str range_key_field: The range key name.
        :param str range_key_type: The range key type. Valid values are "STRING" or "NUMBER"
        :param str range_key_value: The range key value.
        """
        pulumi.set(__self__, "hash_key_field", hash_key_field)
        pulumi.set(__self__, "hash_key_value", hash_key_value)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "table_name", table_name)
        if hash_key_type is not None:
            pulumi.set(__self__, "hash_key_type", hash_key_type)
        if payload_field is not None:
            pulumi.set(__self__, "payload_field", payload_field)
        if range_key_field is not None:
            pulumi.set(__self__, "range_key_field", range_key_field)
        if range_key_type is not None:
            pulumi.set(__self__, "range_key_type", range_key_type)
        if range_key_value is not None:
            pulumi.set(__self__, "range_key_value", range_key_value)

    @property
    @pulumi.getter(name="hashKeyField")
    def hash_key_field(self) -> str:
        """
        The hash key name.
        """
        return pulumi.get(self, "hash_key_field")

    @property
    @pulumi.getter(name="hashKeyValue")
    def hash_key_value(self) -> str:
        """
        The hash key value.
        """
        return pulumi.get(self, "hash_key_value")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        The ARN of the IAM role that grants access to the DynamoDB table.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> str:
        """
        The name of the DynamoDB table.
        """
        return pulumi.get(self, "table_name")

    @property
    @pulumi.getter(name="hashKeyType")
    def hash_key_type(self) -> Optional[str]:
        """
        The hash key type. Valid values are "STRING" or "NUMBER"
        """
        return pulumi.get(self, "hash_key_type")

    @property
    @pulumi.getter(name="payloadField")
    def payload_field(self) -> Optional[str]:
        """
        The action payload. This name can be customized.
        """
        return pulumi.get(self, "payload_field")

    @property
    @pulumi.getter(name="rangeKeyField")
    def range_key_field(self) -> Optional[str]:
        """
        The range key name.
        """
        return pulumi.get(self, "range_key_field")

    @property
    @pulumi.getter(name="rangeKeyType")
    def range_key_type(self) -> Optional[str]:
        """
        The range key type. Valid values are "STRING" or "NUMBER"
        """
        return pulumi.get(self, "range_key_type")

    @property
    @pulumi.getter(name="rangeKeyValue")
    def range_key_value(self) -> Optional[str]:
        """
        The range key value.
        """
        return pulumi.get(self, "range_key_value")


@pulumi.output_type
class TopicRuleElasticsearchAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleElasticsearchAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleElasticsearchAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleElasticsearchAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: str,
                 id: str,
                 index: str,
                 role_arn: str,
                 type: str):
        """
        :param str endpoint: The endpoint of your OpenSearch domain.
        :param str id: The unique identifier for the document you are storing.
        :param str index: The index where you want to store your data.
        :param str role_arn: The IAM role ARN that has access to OpenSearch.
        :param str type: The type of document you are storing.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        The endpoint of your OpenSearch domain.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The unique identifier for the document you are storing.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The index where you want to store your data.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        The IAM role ARN that has access to OpenSearch.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of document you are storing.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class TopicRuleFirehoseAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deliveryStreamName":
            suggest = "delivery_stream_name"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "batchMode":
            suggest = "batch_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleFirehoseAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleFirehoseAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleFirehoseAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delivery_stream_name: str,
                 role_arn: str,
                 batch_mode: Optional[bool] = None,
                 separator: Optional[str] = None):
        """
        :param str delivery_stream_name: The delivery stream name.
        :param str role_arn: The IAM role that grants access to the Amazon Kinesis Firehose stream.
        :param bool batch_mode: Whether to deliver the Kinesis Data Firehose stream as a batch by using [`PutRecordBatch`](https://docs.aws.amazon.com/firehose/latest/APIReference/API_PutRecordBatch.html) . The default value is `false` .
               
               When `batchMode` is `true` and the rule's SQL statement evaluates to an Array, each Array element forms one record in the [`PutRecordBatch`](https://docs.aws.amazon.com/firehose/latest/APIReference/API_PutRecordBatch.html) request. The resulting array can't have more than 500 records.
        :param str separator: A character separator that will be used to separate records written to the Firehose stream. Valid values are: '\\n' (newline), '\\t' (tab), '\\r\\n' (Windows newline), ',' (comma).
        """
        pulumi.set(__self__, "delivery_stream_name", delivery_stream_name)
        pulumi.set(__self__, "role_arn", role_arn)
        if batch_mode is not None:
            pulumi.set(__self__, "batch_mode", batch_mode)
        if separator is not None:
            pulumi.set(__self__, "separator", separator)

    @property
    @pulumi.getter(name="deliveryStreamName")
    def delivery_stream_name(self) -> str:
        """
        The delivery stream name.
        """
        return pulumi.get(self, "delivery_stream_name")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        The IAM role that grants access to the Amazon Kinesis Firehose stream.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="batchMode")
    def batch_mode(self) -> Optional[bool]:
        """
        Whether to deliver the Kinesis Data Firehose stream as a batch by using [`PutRecordBatch`](https://docs.aws.amazon.com/firehose/latest/APIReference/API_PutRecordBatch.html) . The default value is `false` .

        When `batchMode` is `true` and the rule's SQL statement evaluates to an Array, each Array element forms one record in the [`PutRecordBatch`](https://docs.aws.amazon.com/firehose/latest/APIReference/API_PutRecordBatch.html) request. The resulting array can't have more than 500 records.
        """
        return pulumi.get(self, "batch_mode")

    @property
    @pulumi.getter
    def separator(self) -> Optional[str]:
        """
        A character separator that will be used to separate records written to the Firehose stream. Valid values are: '\\n' (newline), '\\t' (tab), '\\r\\n' (Windows newline), ',' (comma).
        """
        return pulumi.get(self, "separator")


@pulumi.output_type
class TopicRuleHttpAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "confirmationUrl":
            suggest = "confirmation_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleHttpAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleHttpAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleHttpAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 auth: Optional['outputs.TopicRuleHttpAuthorization'] = None,
                 confirmation_url: Optional[str] = None,
                 headers: Optional[Sequence['outputs.TopicRuleHttpActionHeader']] = None):
        """
        :param str url: The endpoint URL. If substitution templates are used in the URL, you must also specify a `confirmationUrl` . If this is a new destination, a new `TopicRuleDestination` is created if possible.
        :param 'TopicRuleHttpAuthorization' auth: The authentication method to use when sending data to an HTTPS endpoint.
        :param str confirmation_url: The URL to which AWS IoT sends a confirmation message. The value of the confirmation URL must be a prefix of the endpoint URL. If you do not specify a confirmation URL AWS IoT uses the endpoint URL as the confirmation URL. If you use substitution templates in the confirmationUrl, you must create and enable topic rule destinations that match each possible value of the substitution template before traffic is allowed to your endpoint URL.
        :param Sequence['TopicRuleHttpActionHeader'] headers: The HTTP headers to send with the message data.
        """
        pulumi.set(__self__, "url", url)
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if confirmation_url is not None:
            pulumi.set(__self__, "confirmation_url", confirmation_url)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The endpoint URL. If substitution templates are used in the URL, you must also specify a `confirmationUrl` . If this is a new destination, a new `TopicRuleDestination` is created if possible.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def auth(self) -> Optional['outputs.TopicRuleHttpAuthorization']:
        """
        The authentication method to use when sending data to an HTTPS endpoint.
        """
        return pulumi.get(self, "auth")

    @property
    @pulumi.getter(name="confirmationUrl")
    def confirmation_url(self) -> Optional[str]:
        """
        The URL to which AWS IoT sends a confirmation message. The value of the confirmation URL must be a prefix of the endpoint URL. If you do not specify a confirmation URL AWS IoT uses the endpoint URL as the confirmation URL. If you use substitution templates in the confirmationUrl, you must create and enable topic rule destinations that match each possible value of the substitution template before traffic is allowed to your endpoint URL.
        """
        return pulumi.get(self, "confirmation_url")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.TopicRuleHttpActionHeader']]:
        """
        The HTTP headers to send with the message data.
        """
        return pulumi.get(self, "headers")


@pulumi.output_type
class TopicRuleHttpActionHeader(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The HTTP header key.
        :param str value: The HTTP header value. Substitution templates are supported.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The HTTP header key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The HTTP header value. Substitution templates are supported.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class TopicRuleHttpAuthorization(dict):
    def __init__(__self__, *,
                 sigv4: Optional['outputs.TopicRuleSigV4Authorization'] = None):
        """
        :param 'TopicRuleSigV4Authorization' sigv4: Use Sig V4 authorization. For more information, see [Signature Version 4 Signing Process](https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html) .
        """
        if sigv4 is not None:
            pulumi.set(__self__, "sigv4", sigv4)

    @property
    @pulumi.getter
    def sigv4(self) -> Optional['outputs.TopicRuleSigV4Authorization']:
        """
        Use Sig V4 authorization. For more information, see [Signature Version 4 Signing Process](https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html) .
        """
        return pulumi.get(self, "sigv4")


@pulumi.output_type
class TopicRuleIotAnalyticsAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "channelName":
            suggest = "channel_name"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "batchMode":
            suggest = "batch_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleIotAnalyticsAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleIotAnalyticsAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleIotAnalyticsAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 channel_name: str,
                 role_arn: str,
                 batch_mode: Optional[bool] = None):
        """
        :param str channel_name: The name of the IoT Analytics channel to which message data will be sent.
        :param str role_arn: The ARN of the role which has a policy that grants IoT Analytics permission to send message data via IoT Analytics (iotanalytics:BatchPutMessage).
        :param bool batch_mode: Whether to process the action as a batch. The default value is `false` .
               
               When `batchMode` is `true` and the rule SQL statement evaluates to an Array, each Array element is delivered as a separate message when passed by [`BatchPutMessage`](https://docs.aws.amazon.com/iotanalytics/latest/APIReference/API_BatchPutMessage.html) The resulting array can't have more than 100 messages.
        """
        pulumi.set(__self__, "channel_name", channel_name)
        pulumi.set(__self__, "role_arn", role_arn)
        if batch_mode is not None:
            pulumi.set(__self__, "batch_mode", batch_mode)

    @property
    @pulumi.getter(name="channelName")
    def channel_name(self) -> str:
        """
        The name of the IoT Analytics channel to which message data will be sent.
        """
        return pulumi.get(self, "channel_name")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        The ARN of the role which has a policy that grants IoT Analytics permission to send message data via IoT Analytics (iotanalytics:BatchPutMessage).
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="batchMode")
    def batch_mode(self) -> Optional[bool]:
        """
        Whether to process the action as a batch. The default value is `false` .

        When `batchMode` is `true` and the rule SQL statement evaluates to an Array, each Array element is delivered as a separate message when passed by [`BatchPutMessage`](https://docs.aws.amazon.com/iotanalytics/latest/APIReference/API_BatchPutMessage.html) The resulting array can't have more than 100 messages.
        """
        return pulumi.get(self, "batch_mode")


@pulumi.output_type
class TopicRuleIotEventsAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputName":
            suggest = "input_name"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "batchMode":
            suggest = "batch_mode"
        elif key == "messageId":
            suggest = "message_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleIotEventsAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleIotEventsAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleIotEventsAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input_name: str,
                 role_arn: str,
                 batch_mode: Optional[bool] = None,
                 message_id: Optional[str] = None):
        """
        :param str input_name: The name of the AWS IoT Events input.
        :param str role_arn: The ARN of the role that grants AWS IoT permission to send an input to an AWS IoT Events detector. ("Action":"iotevents:BatchPutMessage").
        :param bool batch_mode: Whether to process the event actions as a batch. The default value is `false` .
               
               When `batchMode` is `true` , you can't specify a `messageId` .
               
               When `batchMode` is `true` and the rule SQL statement evaluates to an Array, each Array element is treated as a separate message when Events by calling [`BatchPutMessage`](https://docs.aws.amazon.com/iotevents/latest/apireference/API_iotevents-data_BatchPutMessage.html) . The resulting array can't have more than 10 messages.
        :param str message_id: The ID of the message. The default `messageId` is a new UUID value.
               
               When `batchMode` is `true` , you can't specify a `messageId` --a new UUID value will be assigned.
               
               Assign a value to this property to ensure that only one input (message) with a given `messageId` will be processed by an AWS IoT Events detector.
        """
        pulumi.set(__self__, "input_name", input_name)
        pulumi.set(__self__, "role_arn", role_arn)
        if batch_mode is not None:
            pulumi.set(__self__, "batch_mode", batch_mode)
        if message_id is not None:
            pulumi.set(__self__, "message_id", message_id)

    @property
    @pulumi.getter(name="inputName")
    def input_name(self) -> str:
        """
        The name of the AWS IoT Events input.
        """
        return pulumi.get(self, "input_name")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        The ARN of the role that grants AWS IoT permission to send an input to an AWS IoT Events detector. ("Action":"iotevents:BatchPutMessage").
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="batchMode")
    def batch_mode(self) -> Optional[bool]:
        """
        Whether to process the event actions as a batch. The default value is `false` .

        When `batchMode` is `true` , you can't specify a `messageId` .

        When `batchMode` is `true` and the rule SQL statement evaluates to an Array, each Array element is treated as a separate message when Events by calling [`BatchPutMessage`](https://docs.aws.amazon.com/iotevents/latest/apireference/API_iotevents-data_BatchPutMessage.html) . The resulting array can't have more than 10 messages.
        """
        return pulumi.get(self, "batch_mode")

    @property
    @pulumi.getter(name="messageId")
    def message_id(self) -> Optional[str]:
        """
        The ID of the message. The default `messageId` is a new UUID value.

        When `batchMode` is `true` , you can't specify a `messageId` --a new UUID value will be assigned.

        Assign a value to this property to ensure that only one input (message) with a given `messageId` will be processed by an AWS IoT Events detector.
        """
        return pulumi.get(self, "message_id")


@pulumi.output_type
class TopicRuleIotSiteWiseAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "putAssetPropertyValueEntries":
            suggest = "put_asset_property_value_entries"
        elif key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleIotSiteWiseAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleIotSiteWiseAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleIotSiteWiseAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 put_asset_property_value_entries: Sequence['outputs.TopicRulePutAssetPropertyValueEntry'],
                 role_arn: str):
        """
        :param Sequence['TopicRulePutAssetPropertyValueEntry'] put_asset_property_value_entries: A list of asset property value entries.
        :param str role_arn: The ARN of the role that grants AWS IoT permission to send an asset property value to AWS IoT SiteWise. ( `"Action": "iotsitewise:BatchPutAssetPropertyValue"` ). The trust policy can restrict access to specific asset hierarchy paths.
        """
        pulumi.set(__self__, "put_asset_property_value_entries", put_asset_property_value_entries)
        pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter(name="putAssetPropertyValueEntries")
    def put_asset_property_value_entries(self) -> Sequence['outputs.TopicRulePutAssetPropertyValueEntry']:
        """
        A list of asset property value entries.
        """
        return pulumi.get(self, "put_asset_property_value_entries")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        The ARN of the role that grants AWS IoT permission to send an asset property value to AWS IoT SiteWise. ( `"Action": "iotsitewise:BatchPutAssetPropertyValue"` ). The trust policy can restrict access to specific asset hierarchy paths.
        """
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class TopicRuleKafkaAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientProperties":
            suggest = "client_properties"
        elif key == "destinationArn":
            suggest = "destination_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleKafkaAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleKafkaAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleKafkaAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_properties: Mapping[str, str],
                 destination_arn: str,
                 topic: str,
                 headers: Optional[Sequence['outputs.TopicRuleKafkaActionHeader']] = None,
                 key: Optional[str] = None,
                 partition: Optional[str] = None):
        """
        :param Mapping[str, str] client_properties: Properties of the Apache Kafka producer client.
        :param str destination_arn: The ARN of Kafka action's VPC `TopicRuleDestination` .
        :param str topic: The Kafka topic for messages to be sent to the Kafka broker.
        :param Sequence['TopicRuleKafkaActionHeader'] headers: The list of Kafka headers that you specify.
        :param str key: The Kafka message key.
        :param str partition: The Kafka message partition.
        """
        pulumi.set(__self__, "client_properties", client_properties)
        pulumi.set(__self__, "destination_arn", destination_arn)
        pulumi.set(__self__, "topic", topic)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if partition is not None:
            pulumi.set(__self__, "partition", partition)

    @property
    @pulumi.getter(name="clientProperties")
    def client_properties(self) -> Mapping[str, str]:
        """
        Properties of the Apache Kafka producer client.
        """
        return pulumi.get(self, "client_properties")

    @property
    @pulumi.getter(name="destinationArn")
    def destination_arn(self) -> str:
        """
        The ARN of Kafka action's VPC `TopicRuleDestination` .
        """
        return pulumi.get(self, "destination_arn")

    @property
    @pulumi.getter
    def topic(self) -> str:
        """
        The Kafka topic for messages to be sent to the Kafka broker.
        """
        return pulumi.get(self, "topic")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.TopicRuleKafkaActionHeader']]:
        """
        The list of Kafka headers that you specify.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The Kafka message key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def partition(self) -> Optional[str]:
        """
        The Kafka message partition.
        """
        return pulumi.get(self, "partition")


@pulumi.output_type
class TopicRuleKafkaActionHeader(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: The key of the Kafka header.
        :param str value: The value of the Kafka header.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key of the Kafka header.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the Kafka header.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class TopicRuleKinesisAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"
        elif key == "streamName":
            suggest = "stream_name"
        elif key == "partitionKey":
            suggest = "partition_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleKinesisAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleKinesisAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleKinesisAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: str,
                 stream_name: str,
                 partition_key: Optional[str] = None):
        """
        :param str role_arn: The ARN of the IAM role that grants access to the Amazon Kinesis stream.
        :param str stream_name: The name of the Amazon Kinesis stream.
        :param str partition_key: The partition key.
        """
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "stream_name", stream_name)
        if partition_key is not None:
            pulumi.set(__self__, "partition_key", partition_key)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        The ARN of the IAM role that grants access to the Amazon Kinesis stream.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> str:
        """
        The name of the Amazon Kinesis stream.
        """
        return pulumi.get(self, "stream_name")

    @property
    @pulumi.getter(name="partitionKey")
    def partition_key(self) -> Optional[str]:
        """
        The partition key.
        """
        return pulumi.get(self, "partition_key")


@pulumi.output_type
class TopicRuleLambdaAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "functionArn":
            suggest = "function_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleLambdaAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleLambdaAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleLambdaAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 function_arn: Optional[str] = None):
        """
        :param str function_arn: The ARN of the Lambda function.
        """
        if function_arn is not None:
            pulumi.set(__self__, "function_arn", function_arn)

    @property
    @pulumi.getter(name="functionArn")
    def function_arn(self) -> Optional[str]:
        """
        The ARN of the Lambda function.
        """
        return pulumi.get(self, "function_arn")


@pulumi.output_type
class TopicRuleLocationAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceId":
            suggest = "device_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "trackerName":
            suggest = "tracker_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleLocationAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleLocationAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleLocationAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_id: str,
                 latitude: str,
                 longitude: str,
                 role_arn: str,
                 tracker_name: str,
                 timestamp: Optional['outputs.TopicRuleTimestamp'] = None):
        """
        :param str device_id: The unique ID of the device providing the location data.
        :param str latitude: A string that evaluates to a double value that represents the latitude of the device's location.
        :param str longitude: A string that evaluates to a double value that represents the longitude of the device's location.
        :param str role_arn: The IAM role that grants permission to write to the Amazon Location resource.
        :param str tracker_name: The name of the tracker resource in Amazon Location in which the location is updated.
        :param 'TopicRuleTimestamp' timestamp: The time that the location data was sampled. The default value is the time the MQTT message was processed.
        """
        pulumi.set(__self__, "device_id", device_id)
        pulumi.set(__self__, "latitude", latitude)
        pulumi.set(__self__, "longitude", longitude)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "tracker_name", tracker_name)
        if timestamp is not None:
            pulumi.set(__self__, "timestamp", timestamp)

    @property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> str:
        """
        The unique ID of the device providing the location data.
        """
        return pulumi.get(self, "device_id")

    @property
    @pulumi.getter
    def latitude(self) -> str:
        """
        A string that evaluates to a double value that represents the latitude of the device's location.
        """
        return pulumi.get(self, "latitude")

    @property
    @pulumi.getter
    def longitude(self) -> str:
        """
        A string that evaluates to a double value that represents the longitude of the device's location.
        """
        return pulumi.get(self, "longitude")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        The IAM role that grants permission to write to the Amazon Location resource.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="trackerName")
    def tracker_name(self) -> str:
        """
        The name of the tracker resource in Amazon Location in which the location is updated.
        """
        return pulumi.get(self, "tracker_name")

    @property
    @pulumi.getter
    def timestamp(self) -> Optional['outputs.TopicRuleTimestamp']:
        """
        The time that the location data was sampled. The default value is the time the MQTT message was processed.
        """
        return pulumi.get(self, "timestamp")


@pulumi.output_type
class TopicRuleOpenSearchAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleOpenSearchAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleOpenSearchAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleOpenSearchAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: str,
                 id: str,
                 index: str,
                 role_arn: str,
                 type: str):
        """
        :param str endpoint: The endpoint of your OpenSearch domain.
        :param str id: The unique identifier for the document you are storing.
        :param str index: The OpenSearch index where you want to store your data.
        :param str role_arn: The IAM role ARN that has access to OpenSearch.
        :param str type: The type of document you are storing.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        The endpoint of your OpenSearch domain.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The unique identifier for the document you are storing.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The OpenSearch index where you want to store your data.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        The IAM role ARN that has access to OpenSearch.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of document you are storing.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class TopicRulePayload(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsIotSqlVersion":
            suggest = "aws_iot_sql_version"
        elif key == "errorAction":
            suggest = "error_action"
        elif key == "ruleDisabled":
            suggest = "rule_disabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRulePayload. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRulePayload.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRulePayload.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions: Sequence['outputs.TopicRuleAction'],
                 sql: str,
                 aws_iot_sql_version: Optional[str] = None,
                 description: Optional[str] = None,
                 error_action: Optional['outputs.TopicRuleAction'] = None,
                 rule_disabled: Optional[bool] = None):
        """
        :param Sequence['TopicRuleAction'] actions: The actions associated with the rule.
        :param str sql: The SQL statement used to query the topic. For more information, see [AWS IoT SQL Reference](https://docs.aws.amazon.com/iot/latest/developerguide/iot-sql-reference.html) in the *AWS IoT Developer Guide* .
        :param str aws_iot_sql_version: The version of the SQL rules engine to use when evaluating the rule.
               
               The default value is 2015-10-08.
        :param str description: The description of the rule.
        :param 'TopicRuleAction' error_action: The action to take when an error occurs.
        :param bool rule_disabled: Specifies whether the rule is disabled.
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "sql", sql)
        if aws_iot_sql_version is not None:
            pulumi.set(__self__, "aws_iot_sql_version", aws_iot_sql_version)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if error_action is not None:
            pulumi.set(__self__, "error_action", error_action)
        if rule_disabled is not None:
            pulumi.set(__self__, "rule_disabled", rule_disabled)

    @property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.TopicRuleAction']:
        """
        The actions associated with the rule.
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def sql(self) -> str:
        """
        The SQL statement used to query the topic. For more information, see [AWS IoT SQL Reference](https://docs.aws.amazon.com/iot/latest/developerguide/iot-sql-reference.html) in the *AWS IoT Developer Guide* .
        """
        return pulumi.get(self, "sql")

    @property
    @pulumi.getter(name="awsIotSqlVersion")
    def aws_iot_sql_version(self) -> Optional[str]:
        """
        The version of the SQL rules engine to use when evaluating the rule.

        The default value is 2015-10-08.
        """
        return pulumi.get(self, "aws_iot_sql_version")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        The description of the rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="errorAction")
    def error_action(self) -> Optional['outputs.TopicRuleAction']:
        """
        The action to take when an error occurs.
        """
        return pulumi.get(self, "error_action")

    @property
    @pulumi.getter(name="ruleDisabled")
    def rule_disabled(self) -> Optional[bool]:
        """
        Specifies whether the rule is disabled.
        """
        return pulumi.get(self, "rule_disabled")


@pulumi.output_type
class TopicRulePutAssetPropertyValueEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertyValues":
            suggest = "property_values"
        elif key == "assetId":
            suggest = "asset_id"
        elif key == "entryId":
            suggest = "entry_id"
        elif key == "propertyAlias":
            suggest = "property_alias"
        elif key == "propertyId":
            suggest = "property_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRulePutAssetPropertyValueEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRulePutAssetPropertyValueEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRulePutAssetPropertyValueEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 property_values: Sequence['outputs.TopicRuleAssetPropertyValue'],
                 asset_id: Optional[str] = None,
                 entry_id: Optional[str] = None,
                 property_alias: Optional[str] = None,
                 property_id: Optional[str] = None):
        """
        :param Sequence['TopicRuleAssetPropertyValue'] property_values: A list of property values to insert that each contain timestamp, quality, and value (TQV) information.
        :param str asset_id: The ID of the AWS IoT SiteWise asset. You must specify either a `propertyAlias` or both an `aliasId` and a `propertyId` . Accepts substitution templates.
        :param str entry_id: Optional. A unique identifier for this entry that you can define to better track which message caused an error in case of failure. Accepts substitution templates. Defaults to a new UUID.
        :param str property_alias: The name of the property alias associated with your asset property. You must specify either a `propertyAlias` or both an `aliasId` and a `propertyId` . Accepts substitution templates.
        :param str property_id: The ID of the asset's property. You must specify either a `propertyAlias` or both an `aliasId` and a `propertyId` . Accepts substitution templates.
        """
        pulumi.set(__self__, "property_values", property_values)
        if asset_id is not None:
            pulumi.set(__self__, "asset_id", asset_id)
        if entry_id is not None:
            pulumi.set(__self__, "entry_id", entry_id)
        if property_alias is not None:
            pulumi.set(__self__, "property_alias", property_alias)
        if property_id is not None:
            pulumi.set(__self__, "property_id", property_id)

    @property
    @pulumi.getter(name="propertyValues")
    def property_values(self) -> Sequence['outputs.TopicRuleAssetPropertyValue']:
        """
        A list of property values to insert that each contain timestamp, quality, and value (TQV) information.
        """
        return pulumi.get(self, "property_values")

    @property
    @pulumi.getter(name="assetId")
    def asset_id(self) -> Optional[str]:
        """
        The ID of the AWS IoT SiteWise asset. You must specify either a `propertyAlias` or both an `aliasId` and a `propertyId` . Accepts substitution templates.
        """
        return pulumi.get(self, "asset_id")

    @property
    @pulumi.getter(name="entryId")
    def entry_id(self) -> Optional[str]:
        """
        Optional. A unique identifier for this entry that you can define to better track which message caused an error in case of failure. Accepts substitution templates. Defaults to a new UUID.
        """
        return pulumi.get(self, "entry_id")

    @property
    @pulumi.getter(name="propertyAlias")
    def property_alias(self) -> Optional[str]:
        """
        The name of the property alias associated with your asset property. You must specify either a `propertyAlias` or both an `aliasId` and a `propertyId` . Accepts substitution templates.
        """
        return pulumi.get(self, "property_alias")

    @property
    @pulumi.getter(name="propertyId")
    def property_id(self) -> Optional[str]:
        """
        The ID of the asset's property. You must specify either a `propertyAlias` or both an `aliasId` and a `propertyId` . Accepts substitution templates.
        """
        return pulumi.get(self, "property_id")


@pulumi.output_type
class TopicRulePutItemInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tableName":
            suggest = "table_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRulePutItemInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRulePutItemInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRulePutItemInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 table_name: str):
        """
        :param str table_name: The table where the message data will be written.
        """
        pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> str:
        """
        The table where the message data will be written.
        """
        return pulumi.get(self, "table_name")


@pulumi.output_type
class TopicRuleRepublishAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleRepublishAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleRepublishAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleRepublishAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: str,
                 topic: str,
                 headers: Optional['outputs.TopicRuleRepublishActionHeaders'] = None,
                 qos: Optional[int] = None):
        """
        :param str role_arn: The ARN of the IAM role that grants access.
        :param str topic: The name of the MQTT topic.
        :param 'TopicRuleRepublishActionHeaders' headers: MQTT Version 5.0 headers information. For more information, see [MQTT](https://docs.aws.amazon.com//iot/latest/developerguide/mqtt.html) in the IoT Core Developer Guide.
        :param int qos: The Quality of Service (QoS) level to use when republishing messages. The default value is 0.
        """
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "topic", topic)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if qos is not None:
            pulumi.set(__self__, "qos", qos)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        The ARN of the IAM role that grants access.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter
    def topic(self) -> str:
        """
        The name of the MQTT topic.
        """
        return pulumi.get(self, "topic")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.TopicRuleRepublishActionHeaders']:
        """
        MQTT Version 5.0 headers information. For more information, see [MQTT](https://docs.aws.amazon.com//iot/latest/developerguide/mqtt.html) in the IoT Core Developer Guide.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def qos(self) -> Optional[int]:
        """
        The Quality of Service (QoS) level to use when republishing messages. The default value is 0.
        """
        return pulumi.get(self, "qos")


@pulumi.output_type
class TopicRuleRepublishActionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentType":
            suggest = "content_type"
        elif key == "correlationData":
            suggest = "correlation_data"
        elif key == "messageExpiry":
            suggest = "message_expiry"
        elif key == "payloadFormatIndicator":
            suggest = "payload_format_indicator"
        elif key == "responseTopic":
            suggest = "response_topic"
        elif key == "userProperties":
            suggest = "user_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleRepublishActionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleRepublishActionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleRepublishActionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content_type: Optional[str] = None,
                 correlation_data: Optional[str] = None,
                 message_expiry: Optional[str] = None,
                 payload_format_indicator: Optional[str] = None,
                 response_topic: Optional[str] = None,
                 user_properties: Optional[Sequence['outputs.TopicRuleUserProperty']] = None):
        """
        :param str content_type: A UTF-8 encoded string that describes the content of the publishing message.
               
               For more information, see [Content Type](https://docs.aws.amazon.com/https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901118) in the MQTT Version 5.0 specification.
               
               Supports [substitution templates](https://docs.aws.amazon.com//iot/latest/developerguide/iot-substitution-templates.html) .
        :param str correlation_data: The base64-encoded binary data used by the sender of the request message to identify which request the response message is for.
               
               For more information, see [Correlation Data](https://docs.aws.amazon.com/https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901115) in the MQTT Version 5.0 specification.
               
               Supports [substitution templates](https://docs.aws.amazon.com//iot/latest/developerguide/iot-substitution-templates.html) .
               
               > This binary data must be base64-encoded.
        :param str message_expiry: A user-defined integer value that represents the message expiry interval at the broker. If the messages haven't been sent to the subscribers within that interval, the message expires and is removed. The value of `messageExpiry` represents the number of seconds before it expires. For more information about the limits of `messageExpiry` , see [Message broker and protocol limits and quotas](https://docs.aws.amazon.com//general/latest/gr/iot-core.html#limits_iot) in the IoT Core Reference Guide.
               
               Supports [substitution templates](https://docs.aws.amazon.com//iot/latest/developerguide/iot-substitution-templates.html) .
        :param str payload_format_indicator: An `Enum` string value that indicates whether the payload is formatted as UTF-8.
               
               Valid values are `UNSPECIFIED_BYTES` and `UTF8_DATA` .
               
               For more information, see [Payload Format Indicator](https://docs.aws.amazon.com/https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901111) from the MQTT Version 5.0 specification.
               
               Supports [substitution templates](https://docs.aws.amazon.com//iot/latest/developerguide/iot-substitution-templates.html) .
        :param str response_topic: A UTF-8 encoded string that's used as the topic name for a response message. The response topic is used to describe the topic to which the receiver should publish as part of the request-response flow. The topic must not contain wildcard characters.
               
               For more information, see [Response Topic](https://docs.aws.amazon.com/https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901114) in the MQTT Version 5.0 specification.
               
               Supports [substitution templates](https://docs.aws.amazon.com//iot/latest/developerguide/iot-substitution-templates.html) .
        :param Sequence['TopicRuleUserProperty'] user_properties: An array of key-value pairs that you define in the MQTT5 header.
        """
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if correlation_data is not None:
            pulumi.set(__self__, "correlation_data", correlation_data)
        if message_expiry is not None:
            pulumi.set(__self__, "message_expiry", message_expiry)
        if payload_format_indicator is not None:
            pulumi.set(__self__, "payload_format_indicator", payload_format_indicator)
        if response_topic is not None:
            pulumi.set(__self__, "response_topic", response_topic)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[str]:
        """
        A UTF-8 encoded string that describes the content of the publishing message.

        For more information, see [Content Type](https://docs.aws.amazon.com/https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901118) in the MQTT Version 5.0 specification.

        Supports [substitution templates](https://docs.aws.amazon.com//iot/latest/developerguide/iot-substitution-templates.html) .
        """
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter(name="correlationData")
    def correlation_data(self) -> Optional[str]:
        """
        The base64-encoded binary data used by the sender of the request message to identify which request the response message is for.

        For more information, see [Correlation Data](https://docs.aws.amazon.com/https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901115) in the MQTT Version 5.0 specification.

        Supports [substitution templates](https://docs.aws.amazon.com//iot/latest/developerguide/iot-substitution-templates.html) .

        > This binary data must be base64-encoded.
        """
        return pulumi.get(self, "correlation_data")

    @property
    @pulumi.getter(name="messageExpiry")
    def message_expiry(self) -> Optional[str]:
        """
        A user-defined integer value that represents the message expiry interval at the broker. If the messages haven't been sent to the subscribers within that interval, the message expires and is removed. The value of `messageExpiry` represents the number of seconds before it expires. For more information about the limits of `messageExpiry` , see [Message broker and protocol limits and quotas](https://docs.aws.amazon.com//general/latest/gr/iot-core.html#limits_iot) in the IoT Core Reference Guide.

        Supports [substitution templates](https://docs.aws.amazon.com//iot/latest/developerguide/iot-substitution-templates.html) .
        """
        return pulumi.get(self, "message_expiry")

    @property
    @pulumi.getter(name="payloadFormatIndicator")
    def payload_format_indicator(self) -> Optional[str]:
        """
        An `Enum` string value that indicates whether the payload is formatted as UTF-8.

        Valid values are `UNSPECIFIED_BYTES` and `UTF8_DATA` .

        For more information, see [Payload Format Indicator](https://docs.aws.amazon.com/https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901111) from the MQTT Version 5.0 specification.

        Supports [substitution templates](https://docs.aws.amazon.com//iot/latest/developerguide/iot-substitution-templates.html) .
        """
        return pulumi.get(self, "payload_format_indicator")

    @property
    @pulumi.getter(name="responseTopic")
    def response_topic(self) -> Optional[str]:
        """
        A UTF-8 encoded string that's used as the topic name for a response message. The response topic is used to describe the topic to which the receiver should publish as part of the request-response flow. The topic must not contain wildcard characters.

        For more information, see [Response Topic](https://docs.aws.amazon.com/https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901114) in the MQTT Version 5.0 specification.

        Supports [substitution templates](https://docs.aws.amazon.com//iot/latest/developerguide/iot-substitution-templates.html) .
        """
        return pulumi.get(self, "response_topic")

    @property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[Sequence['outputs.TopicRuleUserProperty']]:
        """
        An array of key-value pairs that you define in the MQTT5 header.
        """
        return pulumi.get(self, "user_properties")


@pulumi.output_type
class TopicRuleS3Action(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "cannedAcl":
            suggest = "canned_acl"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleS3Action. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleS3Action.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleS3Action.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: str,
                 key: str,
                 role_arn: str,
                 canned_acl: Optional['TopicRuleCannedAccessControlList'] = None):
        """
        :param str bucket_name: The Amazon S3 bucket.
        :param str key: The object key. For more information, see [Actions, resources, and condition keys for Amazon S3](https://docs.aws.amazon.com/AmazonS3/latest/dev/list_amazons3.html) .
        :param str role_arn: The ARN of the IAM role that grants access.
        :param 'TopicRuleCannedAccessControlList' canned_acl: The Amazon S3 canned ACL that controls access to the object identified by the object key. For more information, see [S3 canned ACLs](https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl) .
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "role_arn", role_arn)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> str:
        """
        The Amazon S3 bucket.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The object key. For more information, see [Actions, resources, and condition keys for Amazon S3](https://docs.aws.amazon.com/AmazonS3/latest/dev/list_amazons3.html) .
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        The ARN of the IAM role that grants access.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional['TopicRuleCannedAccessControlList']:
        """
        The Amazon S3 canned ACL that controls access to the object identified by the object key. For more information, see [S3 canned ACLs](https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl) .
        """
        return pulumi.get(self, "canned_acl")


@pulumi.output_type
class TopicRuleSigV4Authorization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"
        elif key == "serviceName":
            suggest = "service_name"
        elif key == "signingRegion":
            suggest = "signing_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleSigV4Authorization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleSigV4Authorization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleSigV4Authorization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: str,
                 service_name: str,
                 signing_region: str):
        """
        :param str role_arn: The ARN of the signing role.
        :param str service_name: The service name to use while signing with Sig V4.
        :param str signing_region: The signing region.
        """
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "service_name", service_name)
        pulumi.set(__self__, "signing_region", signing_region)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        The ARN of the signing role.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> str:
        """
        The service name to use while signing with Sig V4.
        """
        return pulumi.get(self, "service_name")

    @property
    @pulumi.getter(name="signingRegion")
    def signing_region(self) -> str:
        """
        The signing region.
        """
        return pulumi.get(self, "signing_region")


@pulumi.output_type
class TopicRuleSnsAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"
        elif key == "targetArn":
            suggest = "target_arn"
        elif key == "messageFormat":
            suggest = "message_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleSnsAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleSnsAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleSnsAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: str,
                 target_arn: str,
                 message_format: Optional[str] = None):
        """
        :param str role_arn: The ARN of the IAM role that grants access.
        :param str target_arn: The ARN of the SNS topic.
        :param str message_format: (Optional) The message format of the message to publish. Accepted values are "JSON" and "RAW". The default value of the attribute is "RAW". SNS uses this setting to determine if the payload should be parsed and relevant platform-specific bits of the payload should be extracted. For more information, see [Amazon SNS Message and JSON Formats](https://docs.aws.amazon.com/sns/latest/dg/json-formats.html) in the *Amazon Simple Notification Service Developer Guide* .
        """
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "target_arn", target_arn)
        if message_format is not None:
            pulumi.set(__self__, "message_format", message_format)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        The ARN of the IAM role that grants access.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="targetArn")
    def target_arn(self) -> str:
        """
        The ARN of the SNS topic.
        """
        return pulumi.get(self, "target_arn")

    @property
    @pulumi.getter(name="messageFormat")
    def message_format(self) -> Optional[str]:
        """
        (Optional) The message format of the message to publish. Accepted values are "JSON" and "RAW". The default value of the attribute is "RAW". SNS uses this setting to determine if the payload should be parsed and relevant platform-specific bits of the payload should be extracted. For more information, see [Amazon SNS Message and JSON Formats](https://docs.aws.amazon.com/sns/latest/dg/json-formats.html) in the *Amazon Simple Notification Service Developer Guide* .
        """
        return pulumi.get(self, "message_format")


@pulumi.output_type
class TopicRuleSqsAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queueUrl":
            suggest = "queue_url"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "useBase64":
            suggest = "use_base64"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleSqsAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleSqsAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleSqsAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 queue_url: str,
                 role_arn: str,
                 use_base64: Optional[bool] = None):
        """
        :param str queue_url: The URL of the Amazon SQS queue.
        :param str role_arn: The ARN of the IAM role that grants access.
        :param bool use_base64: Specifies whether to use Base64 encoding.
        """
        pulumi.set(__self__, "queue_url", queue_url)
        pulumi.set(__self__, "role_arn", role_arn)
        if use_base64 is not None:
            pulumi.set(__self__, "use_base64", use_base64)

    @property
    @pulumi.getter(name="queueUrl")
    def queue_url(self) -> str:
        """
        The URL of the Amazon SQS queue.
        """
        return pulumi.get(self, "queue_url")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        The ARN of the IAM role that grants access.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="useBase64")
    def use_base64(self) -> Optional[bool]:
        """
        Specifies whether to use Base64 encoding.
        """
        return pulumi.get(self, "use_base64")


@pulumi.output_type
class TopicRuleStepFunctionsAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"
        elif key == "stateMachineName":
            suggest = "state_machine_name"
        elif key == "executionNamePrefix":
            suggest = "execution_name_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleStepFunctionsAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleStepFunctionsAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleStepFunctionsAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: str,
                 state_machine_name: str,
                 execution_name_prefix: Optional[str] = None):
        """
        :param str role_arn: The ARN of the role that grants IoT permission to start execution of a state machine ("Action":"states:StartExecution").
        :param str state_machine_name: The name of the Step Functions state machine whose execution will be started.
        :param str execution_name_prefix: (Optional) A name will be given to the state machine execution consisting of this prefix followed by a UUID. Step Functions automatically creates a unique name for each state machine execution if one is not provided.
        """
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "state_machine_name", state_machine_name)
        if execution_name_prefix is not None:
            pulumi.set(__self__, "execution_name_prefix", execution_name_prefix)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        The ARN of the role that grants IoT permission to start execution of a state machine ("Action":"states:StartExecution").
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="stateMachineName")
    def state_machine_name(self) -> str:
        """
        The name of the Step Functions state machine whose execution will be started.
        """
        return pulumi.get(self, "state_machine_name")

    @property
    @pulumi.getter(name="executionNamePrefix")
    def execution_name_prefix(self) -> Optional[str]:
        """
        (Optional) A name will be given to the state machine execution consisting of this prefix followed by a UUID. Step Functions automatically creates a unique name for each state machine execution if one is not provided.
        """
        return pulumi.get(self, "execution_name_prefix")


@pulumi.output_type
class TopicRuleTimestamp(dict):
    def __init__(__self__, *,
                 value: str,
                 unit: Optional[str] = None):
        """
        :param str value: An expression that returns a long epoch time value.
        :param str unit: The precision of the timestamp value that results from the expression described in `value` .
        """
        pulumi.set(__self__, "value", value)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        An expression that returns a long epoch time value.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def unit(self) -> Optional[str]:
        """
        The precision of the timestamp value that results from the expression described in `value` .
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class TopicRuleTimestreamAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "tableName":
            suggest = "table_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleTimestreamAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleTimestreamAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleTimestreamAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: str,
                 dimensions: Sequence['outputs.TopicRuleTimestreamDimension'],
                 role_arn: str,
                 table_name: str,
                 timestamp: Optional['outputs.TopicRuleTimestreamTimestamp'] = None):
        """
        :param str database_name: The name of an Amazon Timestream database that has the table to write records into.
        :param Sequence['TopicRuleTimestreamDimension'] dimensions: Metadata attributes of the time series that are written in each measure record.
        :param str role_arn: The Amazon Resource Name (ARN) of the role that grants AWS IoT permission to write to the Timestream database table.
        :param str table_name: The table where the message data will be written.
        :param 'TopicRuleTimestreamTimestamp' timestamp: The value to use for the entry's timestamp. If blank, the time that the entry was processed is used.
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "table_name", table_name)
        if timestamp is not None:
            pulumi.set(__self__, "timestamp", timestamp)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        The name of an Amazon Timestream database that has the table to write records into.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def dimensions(self) -> Sequence['outputs.TopicRuleTimestreamDimension']:
        """
        Metadata attributes of the time series that are written in each measure record.
        """
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        The Amazon Resource Name (ARN) of the role that grants AWS IoT permission to write to the Timestream database table.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> str:
        """
        The table where the message data will be written.
        """
        return pulumi.get(self, "table_name")

    @property
    @pulumi.getter
    def timestamp(self) -> Optional['outputs.TopicRuleTimestreamTimestamp']:
        """
        The value to use for the entry's timestamp. If blank, the time that the entry was processed is used.
        """
        return pulumi.get(self, "timestamp")


@pulumi.output_type
class TopicRuleTimestreamDimension(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class TopicRuleTimestreamTimestamp(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: str):
        """
        :param str unit: The precision of the timestamp value that results from the expression described in `value` .
        :param str value: An expression that returns a long epoch time value.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        """
        The precision of the timestamp value that results from the expression described in `value` .
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        An expression that returns a long epoch time value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class TopicRuleUserProperty(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


