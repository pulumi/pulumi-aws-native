# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AbortConfigProperties',
    'AccountAuditConfigurationAuditCheckConfiguration',
    'AccountAuditConfigurationAuditCheckConfigurations',
    'AccountAuditConfigurationAuditNotificationTarget',
    'AccountAuditConfigurationAuditNotificationTargetConfigurations',
    'AuthorizerTag',
    'BillingGroupPropertiesProperties',
    'BillingGroupTag',
    'CaCertificateRegistrationConfig',
    'CaCertificateTag',
    'CustomMetricTag',
    'DimensionTag',
    'DomainConfigurationAuthorizerConfig',
    'DomainConfigurationServerCertificateSummary',
    'DomainConfigurationTag',
    'DomainConfigurationTlsConfig',
    'FleetMetricAggregationType',
    'FleetMetricTag',
    'JobExecutionsRetryConfigProperties',
    'JobExecutionsRolloutConfigProperties',
    'JobTemplateAbortCriteria',
    'JobTemplateExponentialRolloutRate',
    'JobTemplateMaintenanceWindow',
    'JobTemplateRateIncreaseCriteria',
    'JobTemplateRetryCriteria',
    'JobTemplateTag',
    'MitigationActionActionParams',
    'MitigationActionAddThingsToThingGroupParams',
    'MitigationActionEnableIoTLoggingParams',
    'MitigationActionPublishFindingToSnsParams',
    'MitigationActionReplaceDefaultPolicyVersionParams',
    'MitigationActionTag',
    'MitigationActionUpdateCaCertificateParams',
    'MitigationActionUpdateDeviceCertificateParams',
    'PresignedUrlConfigProperties',
    'ProvisioningTemplateProvisioningHook',
    'ProvisioningTemplateTag',
    'RoleAliasTag',
    'ScheduledAuditTag',
    'SecurityProfileBehavior',
    'SecurityProfileBehaviorCriteria',
    'SecurityProfileMachineLearningDetectionConfig',
    'SecurityProfileMetricDimension',
    'SecurityProfileMetricToRetain',
    'SecurityProfileMetricValue',
    'SecurityProfileStatisticalThreshold',
    'SecurityProfileTag',
    'SoftwarePackageTag',
    'SoftwarePackageVersionResourceAttributes',
    'SoftwarePackageVersionTag',
    'ThingAttributePayload',
    'ThingGroupAttributePayload',
    'ThingGroupPropertiesProperties',
    'ThingGroupTag',
    'ThingTypePropertiesProperties',
    'ThingTypeTag',
    'TimeoutConfigProperties',
    'TopicRuleAction',
    'TopicRuleAssetPropertyTimestamp',
    'TopicRuleAssetPropertyValue',
    'TopicRuleAssetPropertyVariant',
    'TopicRuleCloudwatchAlarmAction',
    'TopicRuleCloudwatchLogsAction',
    'TopicRuleCloudwatchMetricAction',
    'TopicRuleDestinationHttpUrlDestinationSummary',
    'TopicRuleDestinationVpcDestinationProperties',
    'TopicRuleDynamoDBv2Action',
    'TopicRuleDynamoDbAction',
    'TopicRuleElasticsearchAction',
    'TopicRuleFirehoseAction',
    'TopicRuleHttpAction',
    'TopicRuleHttpActionHeader',
    'TopicRuleHttpAuthorization',
    'TopicRuleIotAnalyticsAction',
    'TopicRuleIotEventsAction',
    'TopicRuleIotSiteWiseAction',
    'TopicRuleKafkaAction',
    'TopicRuleKinesisAction',
    'TopicRuleLambdaAction',
    'TopicRuleLocationAction',
    'TopicRuleOpenSearchAction',
    'TopicRulePayload',
    'TopicRulePutAssetPropertyValueEntry',
    'TopicRulePutItemInput',
    'TopicRuleRepublishAction',
    'TopicRuleRepublishActionHeaders',
    'TopicRuleS3Action',
    'TopicRuleSigV4Authorization',
    'TopicRuleSnsAction',
    'TopicRuleSqsAction',
    'TopicRuleStepFunctionsAction',
    'TopicRuleTag',
    'TopicRuleTimestamp',
    'TopicRuleTimestreamAction',
    'TopicRuleTimestreamDimension',
    'TopicRuleTimestreamTimestamp',
    'TopicRuleUserProperty',
]

@pulumi.output_type
class AbortConfigProperties(dict):
    """
    The criteria that determine when and how a job abort takes place.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "criteriaList":
            suggest = "criteria_list"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AbortConfigProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AbortConfigProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AbortConfigProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 criteria_list: Sequence['outputs.JobTemplateAbortCriteria']):
        """
        The criteria that determine when and how a job abort takes place.
        """
        AbortConfigProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            criteria_list=criteria_list,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             criteria_list: Sequence['outputs.JobTemplateAbortCriteria'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("criteria_list", criteria_list)

    @property
    @pulumi.getter(name="criteriaList")
    def criteria_list(self) -> Sequence['outputs.JobTemplateAbortCriteria']:
        return pulumi.get(self, "criteria_list")


@pulumi.output_type
class AccountAuditConfigurationAuditCheckConfiguration(dict):
    """
    The configuration for a specific audit check.
    """
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        The configuration for a specific audit check.
        :param bool enabled: True if the check is enabled.
        """
        AccountAuditConfigurationAuditCheckConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        True if the check is enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class AccountAuditConfigurationAuditCheckConfigurations(dict):
    """
    Specifies which audit checks are enabled and disabled for this account.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authenticatedCognitoRoleOverlyPermissiveCheck":
            suggest = "authenticated_cognito_role_overly_permissive_check"
        elif key == "caCertificateExpiringCheck":
            suggest = "ca_certificate_expiring_check"
        elif key == "caCertificateKeyQualityCheck":
            suggest = "ca_certificate_key_quality_check"
        elif key == "conflictingClientIdsCheck":
            suggest = "conflicting_client_ids_check"
        elif key == "deviceCertificateExpiringCheck":
            suggest = "device_certificate_expiring_check"
        elif key == "deviceCertificateKeyQualityCheck":
            suggest = "device_certificate_key_quality_check"
        elif key == "deviceCertificateSharedCheck":
            suggest = "device_certificate_shared_check"
        elif key == "intermediateCaRevokedForActiveDeviceCertificatesCheck":
            suggest = "intermediate_ca_revoked_for_active_device_certificates_check"
        elif key == "ioTPolicyPotentialMisConfigurationCheck":
            suggest = "io_t_policy_potential_mis_configuration_check"
        elif key == "iotPolicyOverlyPermissiveCheck":
            suggest = "iot_policy_overly_permissive_check"
        elif key == "iotRoleAliasAllowsAccessToUnusedServicesCheck":
            suggest = "iot_role_alias_allows_access_to_unused_services_check"
        elif key == "iotRoleAliasOverlyPermissiveCheck":
            suggest = "iot_role_alias_overly_permissive_check"
        elif key == "loggingDisabledCheck":
            suggest = "logging_disabled_check"
        elif key == "revokedCaCertificateStillActiveCheck":
            suggest = "revoked_ca_certificate_still_active_check"
        elif key == "revokedDeviceCertificateStillActiveCheck":
            suggest = "revoked_device_certificate_still_active_check"
        elif key == "unauthenticatedCognitoRoleOverlyPermissiveCheck":
            suggest = "unauthenticated_cognito_role_overly_permissive_check"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountAuditConfigurationAuditCheckConfigurations. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountAuditConfigurationAuditCheckConfigurations.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountAuditConfigurationAuditCheckConfigurations.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authenticated_cognito_role_overly_permissive_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
                 ca_certificate_expiring_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
                 ca_certificate_key_quality_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
                 conflicting_client_ids_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
                 device_certificate_expiring_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
                 device_certificate_key_quality_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
                 device_certificate_shared_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
                 intermediate_ca_revoked_for_active_device_certificates_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
                 io_t_policy_potential_mis_configuration_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
                 iot_policy_overly_permissive_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
                 iot_role_alias_allows_access_to_unused_services_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
                 iot_role_alias_overly_permissive_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
                 logging_disabled_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
                 revoked_ca_certificate_still_active_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
                 revoked_device_certificate_still_active_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
                 unauthenticated_cognito_role_overly_permissive_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None):
        """
        Specifies which audit checks are enabled and disabled for this account.
        """
        AccountAuditConfigurationAuditCheckConfigurations._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            authenticated_cognito_role_overly_permissive_check=authenticated_cognito_role_overly_permissive_check,
            ca_certificate_expiring_check=ca_certificate_expiring_check,
            ca_certificate_key_quality_check=ca_certificate_key_quality_check,
            conflicting_client_ids_check=conflicting_client_ids_check,
            device_certificate_expiring_check=device_certificate_expiring_check,
            device_certificate_key_quality_check=device_certificate_key_quality_check,
            device_certificate_shared_check=device_certificate_shared_check,
            intermediate_ca_revoked_for_active_device_certificates_check=intermediate_ca_revoked_for_active_device_certificates_check,
            io_t_policy_potential_mis_configuration_check=io_t_policy_potential_mis_configuration_check,
            iot_policy_overly_permissive_check=iot_policy_overly_permissive_check,
            iot_role_alias_allows_access_to_unused_services_check=iot_role_alias_allows_access_to_unused_services_check,
            iot_role_alias_overly_permissive_check=iot_role_alias_overly_permissive_check,
            logging_disabled_check=logging_disabled_check,
            revoked_ca_certificate_still_active_check=revoked_ca_certificate_still_active_check,
            revoked_device_certificate_still_active_check=revoked_device_certificate_still_active_check,
            unauthenticated_cognito_role_overly_permissive_check=unauthenticated_cognito_role_overly_permissive_check,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             authenticated_cognito_role_overly_permissive_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
             ca_certificate_expiring_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
             ca_certificate_key_quality_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
             conflicting_client_ids_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
             device_certificate_expiring_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
             device_certificate_key_quality_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
             device_certificate_shared_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
             intermediate_ca_revoked_for_active_device_certificates_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
             io_t_policy_potential_mis_configuration_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
             iot_policy_overly_permissive_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
             iot_role_alias_allows_access_to_unused_services_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
             iot_role_alias_overly_permissive_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
             logging_disabled_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
             revoked_ca_certificate_still_active_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
             revoked_device_certificate_still_active_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
             unauthenticated_cognito_role_overly_permissive_check: Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if authenticated_cognito_role_overly_permissive_check is not None:
            _setter("authenticated_cognito_role_overly_permissive_check", authenticated_cognito_role_overly_permissive_check)
        if ca_certificate_expiring_check is not None:
            _setter("ca_certificate_expiring_check", ca_certificate_expiring_check)
        if ca_certificate_key_quality_check is not None:
            _setter("ca_certificate_key_quality_check", ca_certificate_key_quality_check)
        if conflicting_client_ids_check is not None:
            _setter("conflicting_client_ids_check", conflicting_client_ids_check)
        if device_certificate_expiring_check is not None:
            _setter("device_certificate_expiring_check", device_certificate_expiring_check)
        if device_certificate_key_quality_check is not None:
            _setter("device_certificate_key_quality_check", device_certificate_key_quality_check)
        if device_certificate_shared_check is not None:
            _setter("device_certificate_shared_check", device_certificate_shared_check)
        if intermediate_ca_revoked_for_active_device_certificates_check is not None:
            _setter("intermediate_ca_revoked_for_active_device_certificates_check", intermediate_ca_revoked_for_active_device_certificates_check)
        if io_t_policy_potential_mis_configuration_check is not None:
            _setter("io_t_policy_potential_mis_configuration_check", io_t_policy_potential_mis_configuration_check)
        if iot_policy_overly_permissive_check is not None:
            _setter("iot_policy_overly_permissive_check", iot_policy_overly_permissive_check)
        if iot_role_alias_allows_access_to_unused_services_check is not None:
            _setter("iot_role_alias_allows_access_to_unused_services_check", iot_role_alias_allows_access_to_unused_services_check)
        if iot_role_alias_overly_permissive_check is not None:
            _setter("iot_role_alias_overly_permissive_check", iot_role_alias_overly_permissive_check)
        if logging_disabled_check is not None:
            _setter("logging_disabled_check", logging_disabled_check)
        if revoked_ca_certificate_still_active_check is not None:
            _setter("revoked_ca_certificate_still_active_check", revoked_ca_certificate_still_active_check)
        if revoked_device_certificate_still_active_check is not None:
            _setter("revoked_device_certificate_still_active_check", revoked_device_certificate_still_active_check)
        if unauthenticated_cognito_role_overly_permissive_check is not None:
            _setter("unauthenticated_cognito_role_overly_permissive_check", unauthenticated_cognito_role_overly_permissive_check)

    @property
    @pulumi.getter(name="authenticatedCognitoRoleOverlyPermissiveCheck")
    def authenticated_cognito_role_overly_permissive_check(self) -> Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration']:
        return pulumi.get(self, "authenticated_cognito_role_overly_permissive_check")

    @property
    @pulumi.getter(name="caCertificateExpiringCheck")
    def ca_certificate_expiring_check(self) -> Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration']:
        return pulumi.get(self, "ca_certificate_expiring_check")

    @property
    @pulumi.getter(name="caCertificateKeyQualityCheck")
    def ca_certificate_key_quality_check(self) -> Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration']:
        return pulumi.get(self, "ca_certificate_key_quality_check")

    @property
    @pulumi.getter(name="conflictingClientIdsCheck")
    def conflicting_client_ids_check(self) -> Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration']:
        return pulumi.get(self, "conflicting_client_ids_check")

    @property
    @pulumi.getter(name="deviceCertificateExpiringCheck")
    def device_certificate_expiring_check(self) -> Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration']:
        return pulumi.get(self, "device_certificate_expiring_check")

    @property
    @pulumi.getter(name="deviceCertificateKeyQualityCheck")
    def device_certificate_key_quality_check(self) -> Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration']:
        return pulumi.get(self, "device_certificate_key_quality_check")

    @property
    @pulumi.getter(name="deviceCertificateSharedCheck")
    def device_certificate_shared_check(self) -> Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration']:
        return pulumi.get(self, "device_certificate_shared_check")

    @property
    @pulumi.getter(name="intermediateCaRevokedForActiveDeviceCertificatesCheck")
    def intermediate_ca_revoked_for_active_device_certificates_check(self) -> Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration']:
        return pulumi.get(self, "intermediate_ca_revoked_for_active_device_certificates_check")

    @property
    @pulumi.getter(name="ioTPolicyPotentialMisConfigurationCheck")
    def io_t_policy_potential_mis_configuration_check(self) -> Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration']:
        return pulumi.get(self, "io_t_policy_potential_mis_configuration_check")

    @property
    @pulumi.getter(name="iotPolicyOverlyPermissiveCheck")
    def iot_policy_overly_permissive_check(self) -> Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration']:
        return pulumi.get(self, "iot_policy_overly_permissive_check")

    @property
    @pulumi.getter(name="iotRoleAliasAllowsAccessToUnusedServicesCheck")
    def iot_role_alias_allows_access_to_unused_services_check(self) -> Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration']:
        return pulumi.get(self, "iot_role_alias_allows_access_to_unused_services_check")

    @property
    @pulumi.getter(name="iotRoleAliasOverlyPermissiveCheck")
    def iot_role_alias_overly_permissive_check(self) -> Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration']:
        return pulumi.get(self, "iot_role_alias_overly_permissive_check")

    @property
    @pulumi.getter(name="loggingDisabledCheck")
    def logging_disabled_check(self) -> Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration']:
        return pulumi.get(self, "logging_disabled_check")

    @property
    @pulumi.getter(name="revokedCaCertificateStillActiveCheck")
    def revoked_ca_certificate_still_active_check(self) -> Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration']:
        return pulumi.get(self, "revoked_ca_certificate_still_active_check")

    @property
    @pulumi.getter(name="revokedDeviceCertificateStillActiveCheck")
    def revoked_device_certificate_still_active_check(self) -> Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration']:
        return pulumi.get(self, "revoked_device_certificate_still_active_check")

    @property
    @pulumi.getter(name="unauthenticatedCognitoRoleOverlyPermissiveCheck")
    def unauthenticated_cognito_role_overly_permissive_check(self) -> Optional['outputs.AccountAuditConfigurationAuditCheckConfiguration']:
        return pulumi.get(self, "unauthenticated_cognito_role_overly_permissive_check")


@pulumi.output_type
class AccountAuditConfigurationAuditNotificationTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"
        elif key == "targetArn":
            suggest = "target_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccountAuditConfigurationAuditNotificationTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccountAuditConfigurationAuditNotificationTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccountAuditConfigurationAuditNotificationTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 role_arn: Optional[str] = None,
                 target_arn: Optional[str] = None):
        """
        :param bool enabled: True if notifications to the target are enabled.
        :param str role_arn: The ARN of the role that grants permission to send notifications to the target.
        :param str target_arn: The ARN of the target (SNS topic) to which audit notifications are sent.
        """
        AccountAuditConfigurationAuditNotificationTarget._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            role_arn=role_arn,
            target_arn=target_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             role_arn: Optional[str] = None,
             target_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if enabled is not None:
            _setter("enabled", enabled)
        if role_arn is not None:
            _setter("role_arn", role_arn)
        if target_arn is not None:
            _setter("target_arn", target_arn)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        True if notifications to the target are enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        The ARN of the role that grants permission to send notifications to the target.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="targetArn")
    def target_arn(self) -> Optional[str]:
        """
        The ARN of the target (SNS topic) to which audit notifications are sent.
        """
        return pulumi.get(self, "target_arn")


@pulumi.output_type
class AccountAuditConfigurationAuditNotificationTargetConfigurations(dict):
    """
    Information about the targets to which audit notifications are sent.
    """
    def __init__(__self__, *,
                 sns: Optional['outputs.AccountAuditConfigurationAuditNotificationTarget'] = None):
        """
        Information about the targets to which audit notifications are sent.
        """
        AccountAuditConfigurationAuditNotificationTargetConfigurations._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sns=sns,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sns: Optional['outputs.AccountAuditConfigurationAuditNotificationTarget'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if sns is not None:
            _setter("sns", sns)

    @property
    @pulumi.getter
    def sns(self) -> Optional['outputs.AccountAuditConfigurationAuditNotificationTarget']:
        return pulumi.get(self, "sns")


@pulumi.output_type
class AuthorizerTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        AuthorizerTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class BillingGroupPropertiesProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "billingGroupDescription":
            suggest = "billing_group_description"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BillingGroupPropertiesProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BillingGroupPropertiesProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BillingGroupPropertiesProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 billing_group_description: Optional[str] = None):
        BillingGroupPropertiesProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            billing_group_description=billing_group_description,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             billing_group_description: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if billing_group_description is not None:
            _setter("billing_group_description", billing_group_description)

    @property
    @pulumi.getter(name="billingGroupDescription")
    def billing_group_description(self) -> Optional[str]:
        return pulumi.get(self, "billing_group_description")


@pulumi.output_type
class BillingGroupTag(dict):
    """
    A key-value pair to associate with a resource.
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        A key-value pair to associate with a resource.
        :param str key: The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
        :param str value: The value for the tag. You can specify a value that is 1 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
        """
        BillingGroupTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the tag. You can specify a value that is 1 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CaCertificateRegistrationConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"
        elif key == "templateBody":
            suggest = "template_body"
        elif key == "templateName":
            suggest = "template_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CaCertificateRegistrationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CaCertificateRegistrationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CaCertificateRegistrationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: Optional[str] = None,
                 template_body: Optional[str] = None,
                 template_name: Optional[str] = None):
        CaCertificateRegistrationConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            role_arn=role_arn,
            template_body=template_body,
            template_name=template_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             role_arn: Optional[str] = None,
             template_body: Optional[str] = None,
             template_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if role_arn is not None:
            _setter("role_arn", role_arn)
        if template_body is not None:
            _setter("template_body", template_body)
        if template_name is not None:
            _setter("template_name", template_name)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="templateBody")
    def template_body(self) -> Optional[str]:
        return pulumi.get(self, "template_body")

    @property
    @pulumi.getter(name="templateName")
    def template_name(self) -> Optional[str]:
        return pulumi.get(self, "template_name")


@pulumi.output_type
class CaCertificateTag(dict):
    """
    A key-value pair to associate with a resource.
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        A key-value pair to associate with a resource.
        :param str key: The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        :param str value: The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        CaCertificateTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CustomMetricTag(dict):
    """
    A key-value pair to associate with a resource.
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        A key-value pair to associate with a resource.
        :param str key: The tag's key.
        :param str value: The tag's value.
        """
        CustomMetricTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The tag's key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The tag's value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DimensionTag(dict):
    """
    A key-value pair to associate with a resource.
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        A key-value pair to associate with a resource.
        :param str key: The tag's key.
        :param str value: The tag's value.
        """
        DimensionTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The tag's key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The tag's value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DomainConfigurationAuthorizerConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowAuthorizerOverride":
            suggest = "allow_authorizer_override"
        elif key == "defaultAuthorizerName":
            suggest = "default_authorizer_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainConfigurationAuthorizerConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainConfigurationAuthorizerConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainConfigurationAuthorizerConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_authorizer_override: Optional[bool] = None,
                 default_authorizer_name: Optional[str] = None):
        DomainConfigurationAuthorizerConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow_authorizer_override=allow_authorizer_override,
            default_authorizer_name=default_authorizer_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow_authorizer_override: Optional[bool] = None,
             default_authorizer_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if allow_authorizer_override is not None:
            _setter("allow_authorizer_override", allow_authorizer_override)
        if default_authorizer_name is not None:
            _setter("default_authorizer_name", default_authorizer_name)

    @property
    @pulumi.getter(name="allowAuthorizerOverride")
    def allow_authorizer_override(self) -> Optional[bool]:
        return pulumi.get(self, "allow_authorizer_override")

    @property
    @pulumi.getter(name="defaultAuthorizerName")
    def default_authorizer_name(self) -> Optional[str]:
        return pulumi.get(self, "default_authorizer_name")


@pulumi.output_type
class DomainConfigurationServerCertificateSummary(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverCertificateArn":
            suggest = "server_certificate_arn"
        elif key == "serverCertificateStatus":
            suggest = "server_certificate_status"
        elif key == "serverCertificateStatusDetail":
            suggest = "server_certificate_status_detail"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainConfigurationServerCertificateSummary. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainConfigurationServerCertificateSummary.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainConfigurationServerCertificateSummary.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 server_certificate_arn: Optional[str] = None,
                 server_certificate_status: Optional['DomainConfigurationServerCertificateSummaryServerCertificateStatus'] = None,
                 server_certificate_status_detail: Optional[str] = None):
        DomainConfigurationServerCertificateSummary._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            server_certificate_arn=server_certificate_arn,
            server_certificate_status=server_certificate_status,
            server_certificate_status_detail=server_certificate_status_detail,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             server_certificate_arn: Optional[str] = None,
             server_certificate_status: Optional['DomainConfigurationServerCertificateSummaryServerCertificateStatus'] = None,
             server_certificate_status_detail: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if server_certificate_arn is not None:
            _setter("server_certificate_arn", server_certificate_arn)
        if server_certificate_status is not None:
            _setter("server_certificate_status", server_certificate_status)
        if server_certificate_status_detail is not None:
            _setter("server_certificate_status_detail", server_certificate_status_detail)

    @property
    @pulumi.getter(name="serverCertificateArn")
    def server_certificate_arn(self) -> Optional[str]:
        return pulumi.get(self, "server_certificate_arn")

    @property
    @pulumi.getter(name="serverCertificateStatus")
    def server_certificate_status(self) -> Optional['DomainConfigurationServerCertificateSummaryServerCertificateStatus']:
        return pulumi.get(self, "server_certificate_status")

    @property
    @pulumi.getter(name="serverCertificateStatusDetail")
    def server_certificate_status_detail(self) -> Optional[str]:
        return pulumi.get(self, "server_certificate_status_detail")


@pulumi.output_type
class DomainConfigurationTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        DomainConfigurationTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class DomainConfigurationTlsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "securityPolicy":
            suggest = "security_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainConfigurationTlsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainConfigurationTlsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainConfigurationTlsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 security_policy: Optional[str] = None):
        DomainConfigurationTlsConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            security_policy=security_policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             security_policy: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if security_policy is not None:
            _setter("security_policy", security_policy)

    @property
    @pulumi.getter(name="securityPolicy")
    def security_policy(self) -> Optional[str]:
        return pulumi.get(self, "security_policy")


@pulumi.output_type
class FleetMetricAggregationType(dict):
    """
    Aggregation types supported by Fleet Indexing
    """
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str]):
        """
        Aggregation types supported by Fleet Indexing
        :param str name: Fleet Indexing aggregation type names such as Statistics, Percentiles and Cardinality
        :param Sequence[str] values: Fleet Indexing aggregation type values
        """
        FleetMetricAggregationType._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             values: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Fleet Indexing aggregation type names such as Statistics, Percentiles and Cardinality
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Fleet Indexing aggregation type values
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class FleetMetricTag(dict):
    """
    A key-value pair to associate with a resource
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        A key-value pair to associate with a resource
        :param str key: The tag's key
        :param str value: The tag's value
        """
        FleetMetricTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The tag's key
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The tag's value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class JobExecutionsRetryConfigProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retryCriteriaList":
            suggest = "retry_criteria_list"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobExecutionsRetryConfigProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobExecutionsRetryConfigProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobExecutionsRetryConfigProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 retry_criteria_list: Optional[Sequence['outputs.JobTemplateRetryCriteria']] = None):
        JobExecutionsRetryConfigProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            retry_criteria_list=retry_criteria_list,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             retry_criteria_list: Optional[Sequence['outputs.JobTemplateRetryCriteria']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if retry_criteria_list is not None:
            _setter("retry_criteria_list", retry_criteria_list)

    @property
    @pulumi.getter(name="retryCriteriaList")
    def retry_criteria_list(self) -> Optional[Sequence['outputs.JobTemplateRetryCriteria']]:
        return pulumi.get(self, "retry_criteria_list")


@pulumi.output_type
class JobExecutionsRolloutConfigProperties(dict):
    """
    Allows you to create a staged rollout of a job.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exponentialRolloutRate":
            suggest = "exponential_rollout_rate"
        elif key == "maximumPerMinute":
            suggest = "maximum_per_minute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobExecutionsRolloutConfigProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobExecutionsRolloutConfigProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobExecutionsRolloutConfigProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exponential_rollout_rate: Optional['outputs.JobTemplateExponentialRolloutRate'] = None,
                 maximum_per_minute: Optional[int] = None):
        """
        Allows you to create a staged rollout of a job.
        :param 'JobTemplateExponentialRolloutRate' exponential_rollout_rate: The rate of increase for a job rollout. This parameter allows you to define an exponential rate for a job rollout.
        :param int maximum_per_minute: The maximum number of things that will be notified of a pending job, per minute. This parameter allows you to create a staged rollout.
        """
        JobExecutionsRolloutConfigProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exponential_rollout_rate=exponential_rollout_rate,
            maximum_per_minute=maximum_per_minute,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exponential_rollout_rate: Optional['outputs.JobTemplateExponentialRolloutRate'] = None,
             maximum_per_minute: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if exponential_rollout_rate is not None:
            _setter("exponential_rollout_rate", exponential_rollout_rate)
        if maximum_per_minute is not None:
            _setter("maximum_per_minute", maximum_per_minute)

    @property
    @pulumi.getter(name="exponentialRolloutRate")
    def exponential_rollout_rate(self) -> Optional['outputs.JobTemplateExponentialRolloutRate']:
        """
        The rate of increase for a job rollout. This parameter allows you to define an exponential rate for a job rollout.
        """
        return pulumi.get(self, "exponential_rollout_rate")

    @property
    @pulumi.getter(name="maximumPerMinute")
    def maximum_per_minute(self) -> Optional[int]:
        """
        The maximum number of things that will be notified of a pending job, per minute. This parameter allows you to create a staged rollout.
        """
        return pulumi.get(self, "maximum_per_minute")


@pulumi.output_type
class JobTemplateAbortCriteria(dict):
    """
    The criteria that determine when and how a job abort takes place.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureType":
            suggest = "failure_type"
        elif key == "minNumberOfExecutedThings":
            suggest = "min_number_of_executed_things"
        elif key == "thresholdPercentage":
            suggest = "threshold_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTemplateAbortCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTemplateAbortCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTemplateAbortCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: 'JobTemplateAction',
                 failure_type: 'JobTemplateFailureType',
                 min_number_of_executed_things: int,
                 threshold_percentage: float):
        """
        The criteria that determine when and how a job abort takes place.
        :param 'JobTemplateAction' action: The type of job action to take to initiate the job abort.
        :param 'JobTemplateFailureType' failure_type: The type of job execution failures that can initiate a job abort.
        :param int min_number_of_executed_things: The minimum number of things which must receive job execution notifications before the job can be aborted.
        :param float threshold_percentage: The minimum percentage of job execution failures that must occur to initiate the job abort.
        """
        JobTemplateAbortCriteria._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            failure_type=failure_type,
            min_number_of_executed_things=min_number_of_executed_things,
            threshold_percentage=threshold_percentage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: 'JobTemplateAction',
             failure_type: 'JobTemplateFailureType',
             min_number_of_executed_things: int,
             threshold_percentage: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("action", action)
        _setter("failure_type", failure_type)
        _setter("min_number_of_executed_things", min_number_of_executed_things)
        _setter("threshold_percentage", threshold_percentage)

    @property
    @pulumi.getter
    def action(self) -> 'JobTemplateAction':
        """
        The type of job action to take to initiate the job abort.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="failureType")
    def failure_type(self) -> 'JobTemplateFailureType':
        """
        The type of job execution failures that can initiate a job abort.
        """
        return pulumi.get(self, "failure_type")

    @property
    @pulumi.getter(name="minNumberOfExecutedThings")
    def min_number_of_executed_things(self) -> int:
        """
        The minimum number of things which must receive job execution notifications before the job can be aborted.
        """
        return pulumi.get(self, "min_number_of_executed_things")

    @property
    @pulumi.getter(name="thresholdPercentage")
    def threshold_percentage(self) -> float:
        """
        The minimum percentage of job execution failures that must occur to initiate the job abort.
        """
        return pulumi.get(self, "threshold_percentage")


@pulumi.output_type
class JobTemplateExponentialRolloutRate(dict):
    """
    Allows you to create an exponential rate of rollout for a job.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseRatePerMinute":
            suggest = "base_rate_per_minute"
        elif key == "incrementFactor":
            suggest = "increment_factor"
        elif key == "rateIncreaseCriteria":
            suggest = "rate_increase_criteria"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTemplateExponentialRolloutRate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTemplateExponentialRolloutRate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTemplateExponentialRolloutRate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_rate_per_minute: int,
                 increment_factor: float,
                 rate_increase_criteria: 'outputs.JobTemplateRateIncreaseCriteria'):
        """
        Allows you to create an exponential rate of rollout for a job.
        :param int base_rate_per_minute: The minimum number of things that will be notified of a pending job, per minute at the start of job rollout. This parameter allows you to define the initial rate of rollout.
        :param float increment_factor: The exponential factor to increase the rate of rollout for a job.
        :param 'JobTemplateRateIncreaseCriteria' rate_increase_criteria: The criteria to initiate the increase in rate of rollout for a job.
        """
        JobTemplateExponentialRolloutRate._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            base_rate_per_minute=base_rate_per_minute,
            increment_factor=increment_factor,
            rate_increase_criteria=rate_increase_criteria,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             base_rate_per_minute: int,
             increment_factor: float,
             rate_increase_criteria: 'outputs.JobTemplateRateIncreaseCriteria',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("base_rate_per_minute", base_rate_per_minute)
        _setter("increment_factor", increment_factor)
        _setter("rate_increase_criteria", rate_increase_criteria)

    @property
    @pulumi.getter(name="baseRatePerMinute")
    def base_rate_per_minute(self) -> int:
        """
        The minimum number of things that will be notified of a pending job, per minute at the start of job rollout. This parameter allows you to define the initial rate of rollout.
        """
        return pulumi.get(self, "base_rate_per_minute")

    @property
    @pulumi.getter(name="incrementFactor")
    def increment_factor(self) -> float:
        """
        The exponential factor to increase the rate of rollout for a job.
        """
        return pulumi.get(self, "increment_factor")

    @property
    @pulumi.getter(name="rateIncreaseCriteria")
    def rate_increase_criteria(self) -> 'outputs.JobTemplateRateIncreaseCriteria':
        """
        The criteria to initiate the increase in rate of rollout for a job.
        """
        return pulumi.get(self, "rate_increase_criteria")


@pulumi.output_type
class JobTemplateMaintenanceWindow(dict):
    """
    Specifies a start time and duration for a scheduled Job.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationInMinutes":
            suggest = "duration_in_minutes"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTemplateMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTemplateMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTemplateMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_in_minutes: Optional[int] = None,
                 start_time: Optional[str] = None):
        """
        Specifies a start time and duration for a scheduled Job.
        """
        JobTemplateMaintenanceWindow._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            duration_in_minutes=duration_in_minutes,
            start_time=start_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             duration_in_minutes: Optional[int] = None,
             start_time: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if duration_in_minutes is not None:
            _setter("duration_in_minutes", duration_in_minutes)
        if start_time is not None:
            _setter("start_time", start_time)

    @property
    @pulumi.getter(name="durationInMinutes")
    def duration_in_minutes(self) -> Optional[int]:
        return pulumi.get(self, "duration_in_minutes")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        return pulumi.get(self, "start_time")


@pulumi.output_type
class JobTemplateRateIncreaseCriteria(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numberOfNotifiedThings":
            suggest = "number_of_notified_things"
        elif key == "numberOfSucceededThings":
            suggest = "number_of_succeeded_things"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTemplateRateIncreaseCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTemplateRateIncreaseCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTemplateRateIncreaseCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 number_of_notified_things: Optional[int] = None,
                 number_of_succeeded_things: Optional[int] = None):
        JobTemplateRateIncreaseCriteria._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            number_of_notified_things=number_of_notified_things,
            number_of_succeeded_things=number_of_succeeded_things,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             number_of_notified_things: Optional[int] = None,
             number_of_succeeded_things: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if number_of_notified_things is not None:
            _setter("number_of_notified_things", number_of_notified_things)
        if number_of_succeeded_things is not None:
            _setter("number_of_succeeded_things", number_of_succeeded_things)

    @property
    @pulumi.getter(name="numberOfNotifiedThings")
    def number_of_notified_things(self) -> Optional[int]:
        return pulumi.get(self, "number_of_notified_things")

    @property
    @pulumi.getter(name="numberOfSucceededThings")
    def number_of_succeeded_things(self) -> Optional[int]:
        return pulumi.get(self, "number_of_succeeded_things")


@pulumi.output_type
class JobTemplateRetryCriteria(dict):
    """
    Specifies how many times a failure type should be retried.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureType":
            suggest = "failure_type"
        elif key == "numberOfRetries":
            suggest = "number_of_retries"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JobTemplateRetryCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JobTemplateRetryCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JobTemplateRetryCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_type: Optional['JobTemplateJobRetryFailureType'] = None,
                 number_of_retries: Optional[int] = None):
        """
        Specifies how many times a failure type should be retried.
        """
        JobTemplateRetryCriteria._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            failure_type=failure_type,
            number_of_retries=number_of_retries,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             failure_type: Optional['JobTemplateJobRetryFailureType'] = None,
             number_of_retries: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if failure_type is not None:
            _setter("failure_type", failure_type)
        if number_of_retries is not None:
            _setter("number_of_retries", number_of_retries)

    @property
    @pulumi.getter(name="failureType")
    def failure_type(self) -> Optional['JobTemplateJobRetryFailureType']:
        return pulumi.get(self, "failure_type")

    @property
    @pulumi.getter(name="numberOfRetries")
    def number_of_retries(self) -> Optional[int]:
        return pulumi.get(self, "number_of_retries")


@pulumi.output_type
class JobTemplateTag(dict):
    """
    A key-value pair to associate with a resource.
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        A key-value pair to associate with a resource.
        :param str key: The tag's key.
        :param str value: The tag's value.
        """
        JobTemplateTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The tag's key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The tag's value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class MitigationActionActionParams(dict):
    """
    The set of parameters for this mitigation action. You can specify only one type of parameter (in other words, you can apply only one action for each defined mitigation action).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addThingsToThingGroupParams":
            suggest = "add_things_to_thing_group_params"
        elif key == "enableIoTLoggingParams":
            suggest = "enable_io_t_logging_params"
        elif key == "publishFindingToSnsParams":
            suggest = "publish_finding_to_sns_params"
        elif key == "replaceDefaultPolicyVersionParams":
            suggest = "replace_default_policy_version_params"
        elif key == "updateCaCertificateParams":
            suggest = "update_ca_certificate_params"
        elif key == "updateDeviceCertificateParams":
            suggest = "update_device_certificate_params"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MitigationActionActionParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MitigationActionActionParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MitigationActionActionParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 add_things_to_thing_group_params: Optional['outputs.MitigationActionAddThingsToThingGroupParams'] = None,
                 enable_io_t_logging_params: Optional['outputs.MitigationActionEnableIoTLoggingParams'] = None,
                 publish_finding_to_sns_params: Optional['outputs.MitigationActionPublishFindingToSnsParams'] = None,
                 replace_default_policy_version_params: Optional['outputs.MitigationActionReplaceDefaultPolicyVersionParams'] = None,
                 update_ca_certificate_params: Optional['outputs.MitigationActionUpdateCaCertificateParams'] = None,
                 update_device_certificate_params: Optional['outputs.MitigationActionUpdateDeviceCertificateParams'] = None):
        """
        The set of parameters for this mitigation action. You can specify only one type of parameter (in other words, you can apply only one action for each defined mitigation action).
        """
        MitigationActionActionParams._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            add_things_to_thing_group_params=add_things_to_thing_group_params,
            enable_io_t_logging_params=enable_io_t_logging_params,
            publish_finding_to_sns_params=publish_finding_to_sns_params,
            replace_default_policy_version_params=replace_default_policy_version_params,
            update_ca_certificate_params=update_ca_certificate_params,
            update_device_certificate_params=update_device_certificate_params,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             add_things_to_thing_group_params: Optional['outputs.MitigationActionAddThingsToThingGroupParams'] = None,
             enable_io_t_logging_params: Optional['outputs.MitigationActionEnableIoTLoggingParams'] = None,
             publish_finding_to_sns_params: Optional['outputs.MitigationActionPublishFindingToSnsParams'] = None,
             replace_default_policy_version_params: Optional['outputs.MitigationActionReplaceDefaultPolicyVersionParams'] = None,
             update_ca_certificate_params: Optional['outputs.MitigationActionUpdateCaCertificateParams'] = None,
             update_device_certificate_params: Optional['outputs.MitigationActionUpdateDeviceCertificateParams'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if add_things_to_thing_group_params is not None:
            _setter("add_things_to_thing_group_params", add_things_to_thing_group_params)
        if enable_io_t_logging_params is not None:
            _setter("enable_io_t_logging_params", enable_io_t_logging_params)
        if publish_finding_to_sns_params is not None:
            _setter("publish_finding_to_sns_params", publish_finding_to_sns_params)
        if replace_default_policy_version_params is not None:
            _setter("replace_default_policy_version_params", replace_default_policy_version_params)
        if update_ca_certificate_params is not None:
            _setter("update_ca_certificate_params", update_ca_certificate_params)
        if update_device_certificate_params is not None:
            _setter("update_device_certificate_params", update_device_certificate_params)

    @property
    @pulumi.getter(name="addThingsToThingGroupParams")
    def add_things_to_thing_group_params(self) -> Optional['outputs.MitigationActionAddThingsToThingGroupParams']:
        return pulumi.get(self, "add_things_to_thing_group_params")

    @property
    @pulumi.getter(name="enableIoTLoggingParams")
    def enable_io_t_logging_params(self) -> Optional['outputs.MitigationActionEnableIoTLoggingParams']:
        return pulumi.get(self, "enable_io_t_logging_params")

    @property
    @pulumi.getter(name="publishFindingToSnsParams")
    def publish_finding_to_sns_params(self) -> Optional['outputs.MitigationActionPublishFindingToSnsParams']:
        return pulumi.get(self, "publish_finding_to_sns_params")

    @property
    @pulumi.getter(name="replaceDefaultPolicyVersionParams")
    def replace_default_policy_version_params(self) -> Optional['outputs.MitigationActionReplaceDefaultPolicyVersionParams']:
        return pulumi.get(self, "replace_default_policy_version_params")

    @property
    @pulumi.getter(name="updateCaCertificateParams")
    def update_ca_certificate_params(self) -> Optional['outputs.MitigationActionUpdateCaCertificateParams']:
        return pulumi.get(self, "update_ca_certificate_params")

    @property
    @pulumi.getter(name="updateDeviceCertificateParams")
    def update_device_certificate_params(self) -> Optional['outputs.MitigationActionUpdateDeviceCertificateParams']:
        return pulumi.get(self, "update_device_certificate_params")


@pulumi.output_type
class MitigationActionAddThingsToThingGroupParams(dict):
    """
    Parameters to define a mitigation action that moves devices associated with a certificate to one or more specified thing groups, typically for quarantine.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "thingGroupNames":
            suggest = "thing_group_names"
        elif key == "overrideDynamicGroups":
            suggest = "override_dynamic_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MitigationActionAddThingsToThingGroupParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MitigationActionAddThingsToThingGroupParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MitigationActionAddThingsToThingGroupParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 thing_group_names: Sequence[str],
                 override_dynamic_groups: Optional[bool] = None):
        """
        Parameters to define a mitigation action that moves devices associated with a certificate to one or more specified thing groups, typically for quarantine.
        :param Sequence[str] thing_group_names: The list of groups to which you want to add the things that triggered the mitigation action.
        :param bool override_dynamic_groups: Specifies if this mitigation action can move the things that triggered the mitigation action out of one or more dynamic thing groups.
        """
        MitigationActionAddThingsToThingGroupParams._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            thing_group_names=thing_group_names,
            override_dynamic_groups=override_dynamic_groups,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             thing_group_names: Sequence[str],
             override_dynamic_groups: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("thing_group_names", thing_group_names)
        if override_dynamic_groups is not None:
            _setter("override_dynamic_groups", override_dynamic_groups)

    @property
    @pulumi.getter(name="thingGroupNames")
    def thing_group_names(self) -> Sequence[str]:
        """
        The list of groups to which you want to add the things that triggered the mitigation action.
        """
        return pulumi.get(self, "thing_group_names")

    @property
    @pulumi.getter(name="overrideDynamicGroups")
    def override_dynamic_groups(self) -> Optional[bool]:
        """
        Specifies if this mitigation action can move the things that triggered the mitigation action out of one or more dynamic thing groups.
        """
        return pulumi.get(self, "override_dynamic_groups")


@pulumi.output_type
class MitigationActionEnableIoTLoggingParams(dict):
    """
    Parameters to define a mitigation action that enables AWS IoT logging at a specified level of detail.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logLevel":
            suggest = "log_level"
        elif key == "roleArnForLogging":
            suggest = "role_arn_for_logging"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MitigationActionEnableIoTLoggingParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MitigationActionEnableIoTLoggingParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MitigationActionEnableIoTLoggingParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_level: 'MitigationActionEnableIoTLoggingParamsLogLevel',
                 role_arn_for_logging: str):
        """
        Parameters to define a mitigation action that enables AWS IoT logging at a specified level of detail.
        :param 'MitigationActionEnableIoTLoggingParamsLogLevel' log_level:  Specifies which types of information are logged.
        :param str role_arn_for_logging:  The ARN of the IAM role used for logging.
        """
        MitigationActionEnableIoTLoggingParams._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            log_level=log_level,
            role_arn_for_logging=role_arn_for_logging,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             log_level: 'MitigationActionEnableIoTLoggingParamsLogLevel',
             role_arn_for_logging: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("log_level", log_level)
        _setter("role_arn_for_logging", role_arn_for_logging)

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> 'MitigationActionEnableIoTLoggingParamsLogLevel':
        """
         Specifies which types of information are logged.
        """
        return pulumi.get(self, "log_level")

    @property
    @pulumi.getter(name="roleArnForLogging")
    def role_arn_for_logging(self) -> str:
        """
         The ARN of the IAM role used for logging.
        """
        return pulumi.get(self, "role_arn_for_logging")


@pulumi.output_type
class MitigationActionPublishFindingToSnsParams(dict):
    """
    Parameters, to define a mitigation action that publishes findings to Amazon SNS. You can implement your own custom actions in response to the Amazon SNS messages.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "topicArn":
            suggest = "topic_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MitigationActionPublishFindingToSnsParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MitigationActionPublishFindingToSnsParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MitigationActionPublishFindingToSnsParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 topic_arn: str):
        """
        Parameters, to define a mitigation action that publishes findings to Amazon SNS. You can implement your own custom actions in response to the Amazon SNS messages.
        :param str topic_arn: The ARN of the topic to which you want to publish the findings.
        """
        MitigationActionPublishFindingToSnsParams._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            topic_arn=topic_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             topic_arn: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("topic_arn", topic_arn)

    @property
    @pulumi.getter(name="topicArn")
    def topic_arn(self) -> str:
        """
        The ARN of the topic to which you want to publish the findings.
        """
        return pulumi.get(self, "topic_arn")


@pulumi.output_type
class MitigationActionReplaceDefaultPolicyVersionParams(dict):
    """
    Parameters to define a mitigation action that adds a blank policy to restrict permissions.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "templateName":
            suggest = "template_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MitigationActionReplaceDefaultPolicyVersionParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MitigationActionReplaceDefaultPolicyVersionParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MitigationActionReplaceDefaultPolicyVersionParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 template_name: 'MitigationActionReplaceDefaultPolicyVersionParamsTemplateName'):
        """
        Parameters to define a mitigation action that adds a blank policy to restrict permissions.
        """
        MitigationActionReplaceDefaultPolicyVersionParams._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            template_name=template_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             template_name: 'MitigationActionReplaceDefaultPolicyVersionParamsTemplateName',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("template_name", template_name)

    @property
    @pulumi.getter(name="templateName")
    def template_name(self) -> 'MitigationActionReplaceDefaultPolicyVersionParamsTemplateName':
        return pulumi.get(self, "template_name")


@pulumi.output_type
class MitigationActionTag(dict):
    """
    A key-value pair to associate with a resource.
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        A key-value pair to associate with a resource.
        :param str key: The tag's key.
        :param str value: The tag's value.
        """
        MitigationActionTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The tag's key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The tag's value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class MitigationActionUpdateCaCertificateParams(dict):
    """
    Parameters to define a mitigation action that changes the state of the CA certificate to inactive.
    """
    def __init__(__self__, *,
                 action: 'MitigationActionUpdateCaCertificateParamsAction'):
        """
        Parameters to define a mitigation action that changes the state of the CA certificate to inactive.
        """
        MitigationActionUpdateCaCertificateParams._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: 'MitigationActionUpdateCaCertificateParamsAction',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("action", action)

    @property
    @pulumi.getter
    def action(self) -> 'MitigationActionUpdateCaCertificateParamsAction':
        return pulumi.get(self, "action")


@pulumi.output_type
class MitigationActionUpdateDeviceCertificateParams(dict):
    """
    Parameters to define a mitigation action that changes the state of the device certificate to inactive.
    """
    def __init__(__self__, *,
                 action: 'MitigationActionUpdateDeviceCertificateParamsAction'):
        """
        Parameters to define a mitigation action that changes the state of the device certificate to inactive.
        """
        MitigationActionUpdateDeviceCertificateParams._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: 'MitigationActionUpdateDeviceCertificateParamsAction',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("action", action)

    @property
    @pulumi.getter
    def action(self) -> 'MitigationActionUpdateDeviceCertificateParamsAction':
        return pulumi.get(self, "action")


@pulumi.output_type
class PresignedUrlConfigProperties(dict):
    """
    Configuration for pre-signed S3 URLs.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"
        elif key == "expiresInSec":
            suggest = "expires_in_sec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PresignedUrlConfigProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PresignedUrlConfigProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PresignedUrlConfigProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: str,
                 expires_in_sec: Optional[int] = None):
        """
        Configuration for pre-signed S3 URLs.
        """
        PresignedUrlConfigProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            role_arn=role_arn,
            expires_in_sec=expires_in_sec,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             role_arn: str,
             expires_in_sec: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("role_arn", role_arn)
        if expires_in_sec is not None:
            _setter("expires_in_sec", expires_in_sec)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="expiresInSec")
    def expires_in_sec(self) -> Optional[int]:
        return pulumi.get(self, "expires_in_sec")


@pulumi.output_type
class ProvisioningTemplateProvisioningHook(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "payloadVersion":
            suggest = "payload_version"
        elif key == "targetArn":
            suggest = "target_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProvisioningTemplateProvisioningHook. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProvisioningTemplateProvisioningHook.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProvisioningTemplateProvisioningHook.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 payload_version: Optional[str] = None,
                 target_arn: Optional[str] = None):
        ProvisioningTemplateProvisioningHook._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            payload_version=payload_version,
            target_arn=target_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             payload_version: Optional[str] = None,
             target_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if payload_version is not None:
            _setter("payload_version", payload_version)
        if target_arn is not None:
            _setter("target_arn", target_arn)

    @property
    @pulumi.getter(name="payloadVersion")
    def payload_version(self) -> Optional[str]:
        return pulumi.get(self, "payload_version")

    @property
    @pulumi.getter(name="targetArn")
    def target_arn(self) -> Optional[str]:
        return pulumi.get(self, "target_arn")


@pulumi.output_type
class ProvisioningTemplateTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        ProvisioningTemplateTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class RoleAliasTag(dict):
    """
    A key-value pair to associate with a resource.
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        A key-value pair to associate with a resource.
        :param str key: The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        :param str value: The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        RoleAliasTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key name of the tag. You can specify a value that is 1 to 127 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the tag. You can specify a value that is 1 to 255 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ScheduledAuditTag(dict):
    """
    A key-value pair to associate with a resource.
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        A key-value pair to associate with a resource.
        :param str key: The tag's key.
        :param str value: The tag's value.
        """
        ScheduledAuditTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The tag's key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The tag's value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SecurityProfileBehavior(dict):
    """
    A security profile behavior.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricDimension":
            suggest = "metric_dimension"
        elif key == "suppressAlerts":
            suggest = "suppress_alerts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityProfileBehavior. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityProfileBehavior.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityProfileBehavior.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 criteria: Optional['outputs.SecurityProfileBehaviorCriteria'] = None,
                 metric: Optional[str] = None,
                 metric_dimension: Optional['outputs.SecurityProfileMetricDimension'] = None,
                 suppress_alerts: Optional[bool] = None):
        """
        A security profile behavior.
        :param str name: The name for the behavior.
        :param str metric: What is measured by the behavior.
        :param bool suppress_alerts: Manage Detect alarm SNS notifications by setting behavior notification to on or suppressed. Detect will continue to performing device behavior evaluations. However, suppressed alarms wouldn't be forwarded for SNS notification.
        """
        SecurityProfileBehavior._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            criteria=criteria,
            metric=metric,
            metric_dimension=metric_dimension,
            suppress_alerts=suppress_alerts,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             criteria: Optional['outputs.SecurityProfileBehaviorCriteria'] = None,
             metric: Optional[str] = None,
             metric_dimension: Optional['outputs.SecurityProfileMetricDimension'] = None,
             suppress_alerts: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        if criteria is not None:
            _setter("criteria", criteria)
        if metric is not None:
            _setter("metric", metric)
        if metric_dimension is not None:
            _setter("metric_dimension", metric_dimension)
        if suppress_alerts is not None:
            _setter("suppress_alerts", suppress_alerts)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name for the behavior.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def criteria(self) -> Optional['outputs.SecurityProfileBehaviorCriteria']:
        return pulumi.get(self, "criteria")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        What is measured by the behavior.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="metricDimension")
    def metric_dimension(self) -> Optional['outputs.SecurityProfileMetricDimension']:
        return pulumi.get(self, "metric_dimension")

    @property
    @pulumi.getter(name="suppressAlerts")
    def suppress_alerts(self) -> Optional[bool]:
        """
        Manage Detect alarm SNS notifications by setting behavior notification to on or suppressed. Detect will continue to performing device behavior evaluations. However, suppressed alarms wouldn't be forwarded for SNS notification.
        """
        return pulumi.get(self, "suppress_alerts")


@pulumi.output_type
class SecurityProfileBehaviorCriteria(dict):
    """
    The criteria by which the behavior is determined to be normal.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comparisonOperator":
            suggest = "comparison_operator"
        elif key == "consecutiveDatapointsToAlarm":
            suggest = "consecutive_datapoints_to_alarm"
        elif key == "consecutiveDatapointsToClear":
            suggest = "consecutive_datapoints_to_clear"
        elif key == "durationSeconds":
            suggest = "duration_seconds"
        elif key == "mlDetectionConfig":
            suggest = "ml_detection_config"
        elif key == "statisticalThreshold":
            suggest = "statistical_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityProfileBehaviorCriteria. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityProfileBehaviorCriteria.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityProfileBehaviorCriteria.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparison_operator: Optional['SecurityProfileBehaviorCriteriaComparisonOperator'] = None,
                 consecutive_datapoints_to_alarm: Optional[int] = None,
                 consecutive_datapoints_to_clear: Optional[int] = None,
                 duration_seconds: Optional[int] = None,
                 ml_detection_config: Optional['outputs.SecurityProfileMachineLearningDetectionConfig'] = None,
                 statistical_threshold: Optional['outputs.SecurityProfileStatisticalThreshold'] = None,
                 value: Optional['outputs.SecurityProfileMetricValue'] = None):
        """
        The criteria by which the behavior is determined to be normal.
        :param 'SecurityProfileBehaviorCriteriaComparisonOperator' comparison_operator: The operator that relates the thing measured (metric) to the criteria (containing a value or statisticalThreshold).
        :param int consecutive_datapoints_to_alarm: If a device is in violation of the behavior for the specified number of consecutive datapoints, an alarm occurs. If not specified, the default is 1.
        :param int consecutive_datapoints_to_clear: If an alarm has occurred and the offending device is no longer in violation of the behavior for the specified number of consecutive datapoints, the alarm is cleared. If not specified, the default is 1.
        :param int duration_seconds: Use this to specify the time duration over which the behavior is evaluated.
        """
        SecurityProfileBehaviorCriteria._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparison_operator=comparison_operator,
            consecutive_datapoints_to_alarm=consecutive_datapoints_to_alarm,
            consecutive_datapoints_to_clear=consecutive_datapoints_to_clear,
            duration_seconds=duration_seconds,
            ml_detection_config=ml_detection_config,
            statistical_threshold=statistical_threshold,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparison_operator: Optional['SecurityProfileBehaviorCriteriaComparisonOperator'] = None,
             consecutive_datapoints_to_alarm: Optional[int] = None,
             consecutive_datapoints_to_clear: Optional[int] = None,
             duration_seconds: Optional[int] = None,
             ml_detection_config: Optional['outputs.SecurityProfileMachineLearningDetectionConfig'] = None,
             statistical_threshold: Optional['outputs.SecurityProfileStatisticalThreshold'] = None,
             value: Optional['outputs.SecurityProfileMetricValue'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if comparison_operator is not None:
            _setter("comparison_operator", comparison_operator)
        if consecutive_datapoints_to_alarm is not None:
            _setter("consecutive_datapoints_to_alarm", consecutive_datapoints_to_alarm)
        if consecutive_datapoints_to_clear is not None:
            _setter("consecutive_datapoints_to_clear", consecutive_datapoints_to_clear)
        if duration_seconds is not None:
            _setter("duration_seconds", duration_seconds)
        if ml_detection_config is not None:
            _setter("ml_detection_config", ml_detection_config)
        if statistical_threshold is not None:
            _setter("statistical_threshold", statistical_threshold)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> Optional['SecurityProfileBehaviorCriteriaComparisonOperator']:
        """
        The operator that relates the thing measured (metric) to the criteria (containing a value or statisticalThreshold).
        """
        return pulumi.get(self, "comparison_operator")

    @property
    @pulumi.getter(name="consecutiveDatapointsToAlarm")
    def consecutive_datapoints_to_alarm(self) -> Optional[int]:
        """
        If a device is in violation of the behavior for the specified number of consecutive datapoints, an alarm occurs. If not specified, the default is 1.
        """
        return pulumi.get(self, "consecutive_datapoints_to_alarm")

    @property
    @pulumi.getter(name="consecutiveDatapointsToClear")
    def consecutive_datapoints_to_clear(self) -> Optional[int]:
        """
        If an alarm has occurred and the offending device is no longer in violation of the behavior for the specified number of consecutive datapoints, the alarm is cleared. If not specified, the default is 1.
        """
        return pulumi.get(self, "consecutive_datapoints_to_clear")

    @property
    @pulumi.getter(name="durationSeconds")
    def duration_seconds(self) -> Optional[int]:
        """
        Use this to specify the time duration over which the behavior is evaluated.
        """
        return pulumi.get(self, "duration_seconds")

    @property
    @pulumi.getter(name="mlDetectionConfig")
    def ml_detection_config(self) -> Optional['outputs.SecurityProfileMachineLearningDetectionConfig']:
        return pulumi.get(self, "ml_detection_config")

    @property
    @pulumi.getter(name="statisticalThreshold")
    def statistical_threshold(self) -> Optional['outputs.SecurityProfileStatisticalThreshold']:
        return pulumi.get(self, "statistical_threshold")

    @property
    @pulumi.getter
    def value(self) -> Optional['outputs.SecurityProfileMetricValue']:
        return pulumi.get(self, "value")


@pulumi.output_type
class SecurityProfileMachineLearningDetectionConfig(dict):
    """
    The configuration of an ML Detect Security Profile.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "confidenceLevel":
            suggest = "confidence_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityProfileMachineLearningDetectionConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityProfileMachineLearningDetectionConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityProfileMachineLearningDetectionConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 confidence_level: Optional['SecurityProfileMachineLearningDetectionConfigConfidenceLevel'] = None):
        """
        The configuration of an ML Detect Security Profile.
        :param 'SecurityProfileMachineLearningDetectionConfigConfidenceLevel' confidence_level: The sensitivity of anomalous behavior evaluation. Can be Low, Medium, or High.
        """
        SecurityProfileMachineLearningDetectionConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            confidence_level=confidence_level,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             confidence_level: Optional['SecurityProfileMachineLearningDetectionConfigConfidenceLevel'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if confidence_level is not None:
            _setter("confidence_level", confidence_level)

    @property
    @pulumi.getter(name="confidenceLevel")
    def confidence_level(self) -> Optional['SecurityProfileMachineLearningDetectionConfigConfidenceLevel']:
        """
        The sensitivity of anomalous behavior evaluation. Can be Low, Medium, or High.
        """
        return pulumi.get(self, "confidence_level")


@pulumi.output_type
class SecurityProfileMetricDimension(dict):
    """
    The dimension of a metric.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dimensionName":
            suggest = "dimension_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityProfileMetricDimension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityProfileMetricDimension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityProfileMetricDimension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dimension_name: str,
                 operator: Optional['SecurityProfileMetricDimensionOperator'] = None):
        """
        The dimension of a metric.
        :param str dimension_name: A unique identifier for the dimension.
        :param 'SecurityProfileMetricDimensionOperator' operator: Defines how the dimensionValues of a dimension are interpreted.
        """
        SecurityProfileMetricDimension._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dimension_name=dimension_name,
            operator=operator,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dimension_name: str,
             operator: Optional['SecurityProfileMetricDimensionOperator'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("dimension_name", dimension_name)
        if operator is not None:
            _setter("operator", operator)

    @property
    @pulumi.getter(name="dimensionName")
    def dimension_name(self) -> str:
        """
        A unique identifier for the dimension.
        """
        return pulumi.get(self, "dimension_name")

    @property
    @pulumi.getter
    def operator(self) -> Optional['SecurityProfileMetricDimensionOperator']:
        """
        Defines how the dimensionValues of a dimension are interpreted.
        """
        return pulumi.get(self, "operator")


@pulumi.output_type
class SecurityProfileMetricToRetain(dict):
    """
    The metric you want to retain. Dimensions are optional.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricDimension":
            suggest = "metric_dimension"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityProfileMetricToRetain. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityProfileMetricToRetain.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityProfileMetricToRetain.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 metric_dimension: Optional['outputs.SecurityProfileMetricDimension'] = None):
        """
        The metric you want to retain. Dimensions are optional.
        :param str metric: What is measured by the behavior.
        """
        SecurityProfileMetricToRetain._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric=metric,
            metric_dimension=metric_dimension,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric: str,
             metric_dimension: Optional['outputs.SecurityProfileMetricDimension'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("metric", metric)
        if metric_dimension is not None:
            _setter("metric_dimension", metric_dimension)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        What is measured by the behavior.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="metricDimension")
    def metric_dimension(self) -> Optional['outputs.SecurityProfileMetricDimension']:
        return pulumi.get(self, "metric_dimension")


@pulumi.output_type
class SecurityProfileMetricValue(dict):
    """
    The value to be compared with the metric.
    """
    def __init__(__self__, *,
                 cidrs: Optional[Sequence[str]] = None,
                 count: Optional[str] = None,
                 number: Optional[float] = None,
                 numbers: Optional[Sequence[float]] = None,
                 ports: Optional[Sequence[int]] = None,
                 strings: Optional[Sequence[str]] = None):
        """
        The value to be compared with the metric.
        :param Sequence[str] cidrs: If the ComparisonOperator calls for a set of CIDRs, use this to specify that set to be compared with the metric.
        :param str count: If the ComparisonOperator calls for a numeric value, use this to specify that (integer) numeric value to be compared with the metric.
        :param float number: The numeral value of a metric.
        :param Sequence[float] numbers: The numeral values of a metric.
        :param Sequence[int] ports: If the ComparisonOperator calls for a set of ports, use this to specify that set to be compared with the metric.
        :param Sequence[str] strings: The string values of a metric.
        """
        SecurityProfileMetricValue._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cidrs=cidrs,
            count=count,
            number=number,
            numbers=numbers,
            ports=ports,
            strings=strings,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cidrs: Optional[Sequence[str]] = None,
             count: Optional[str] = None,
             number: Optional[float] = None,
             numbers: Optional[Sequence[float]] = None,
             ports: Optional[Sequence[int]] = None,
             strings: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cidrs is not None:
            _setter("cidrs", cidrs)
        if count is not None:
            _setter("count", count)
        if number is not None:
            _setter("number", number)
        if numbers is not None:
            _setter("numbers", numbers)
        if ports is not None:
            _setter("ports", ports)
        if strings is not None:
            _setter("strings", strings)

    @property
    @pulumi.getter
    def cidrs(self) -> Optional[Sequence[str]]:
        """
        If the ComparisonOperator calls for a set of CIDRs, use this to specify that set to be compared with the metric.
        """
        return pulumi.get(self, "cidrs")

    @property
    @pulumi.getter
    def count(self) -> Optional[str]:
        """
        If the ComparisonOperator calls for a numeric value, use this to specify that (integer) numeric value to be compared with the metric.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def number(self) -> Optional[float]:
        """
        The numeral value of a metric.
        """
        return pulumi.get(self, "number")

    @property
    @pulumi.getter
    def numbers(self) -> Optional[Sequence[float]]:
        """
        The numeral values of a metric.
        """
        return pulumi.get(self, "numbers")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence[int]]:
        """
        If the ComparisonOperator calls for a set of ports, use this to specify that set to be compared with the metric.
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter
    def strings(self) -> Optional[Sequence[str]]:
        """
        The string values of a metric.
        """
        return pulumi.get(self, "strings")


@pulumi.output_type
class SecurityProfileStatisticalThreshold(dict):
    """
    A statistical ranking (percentile) which indicates a threshold value by which a behavior is determined to be in compliance or in violation of the behavior.
    """
    def __init__(__self__, *,
                 statistic: Optional['SecurityProfileStatisticalThresholdStatistic'] = None):
        """
        A statistical ranking (percentile) which indicates a threshold value by which a behavior is determined to be in compliance or in violation of the behavior.
        :param 'SecurityProfileStatisticalThresholdStatistic' statistic: The percentile which resolves to a threshold value by which compliance with a behavior is determined
        """
        SecurityProfileStatisticalThreshold._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            statistic=statistic,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             statistic: Optional['SecurityProfileStatisticalThresholdStatistic'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if statistic is not None:
            _setter("statistic", statistic)

    @property
    @pulumi.getter
    def statistic(self) -> Optional['SecurityProfileStatisticalThresholdStatistic']:
        """
        The percentile which resolves to a threshold value by which compliance with a behavior is determined
        """
        return pulumi.get(self, "statistic")


@pulumi.output_type
class SecurityProfileTag(dict):
    """
    A key-value pair to associate with a resource.
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        A key-value pair to associate with a resource.
        :param str key: The tag's key.
        :param str value: The tag's value.
        """
        SecurityProfileTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The tag's key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The tag's value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SoftwarePackageTag(dict):
    """
    A key-value pair to associate with a resource.
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        A key-value pair to associate with a resource.
        :param str key: The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
        :param str value: The value for the tag. You can specify a value that is 1 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
        """
        SoftwarePackageTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the tag. You can specify a value that is 1 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SoftwarePackageVersionResourceAttributes(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions]=None):
        pass


@pulumi.output_type
class SoftwarePackageVersionTag(dict):
    """
    A key-value pair to associate with a resource.
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        A key-value pair to associate with a resource.
        :param str key: The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
        :param str value: The value for the tag. You can specify a value that is 1 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
        """
        SoftwarePackageVersionTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the tag. You can specify a value that is 1 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ThingAttributePayload(dict):
    def __init__(__self__, *,
                 attributes: Optional[Any] = None):
        ThingAttributePayload._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attributes=attributes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attributes: Optional[Any] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if attributes is not None:
            _setter("attributes", attributes)

    @property
    @pulumi.getter
    def attributes(self) -> Optional[Any]:
        return pulumi.get(self, "attributes")


@pulumi.output_type
class ThingGroupAttributePayload(dict):
    def __init__(__self__, *,
                 attributes: Optional[Any] = None):
        ThingGroupAttributePayload._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attributes=attributes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attributes: Optional[Any] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if attributes is not None:
            _setter("attributes", attributes)

    @property
    @pulumi.getter
    def attributes(self) -> Optional[Any]:
        return pulumi.get(self, "attributes")


@pulumi.output_type
class ThingGroupPropertiesProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributePayload":
            suggest = "attribute_payload"
        elif key == "thingGroupDescription":
            suggest = "thing_group_description"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ThingGroupPropertiesProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ThingGroupPropertiesProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ThingGroupPropertiesProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_payload: Optional['outputs.ThingGroupAttributePayload'] = None,
                 thing_group_description: Optional[str] = None):
        ThingGroupPropertiesProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attribute_payload=attribute_payload,
            thing_group_description=thing_group_description,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attribute_payload: Optional['outputs.ThingGroupAttributePayload'] = None,
             thing_group_description: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if attribute_payload is not None:
            _setter("attribute_payload", attribute_payload)
        if thing_group_description is not None:
            _setter("thing_group_description", thing_group_description)

    @property
    @pulumi.getter(name="attributePayload")
    def attribute_payload(self) -> Optional['outputs.ThingGroupAttributePayload']:
        return pulumi.get(self, "attribute_payload")

    @property
    @pulumi.getter(name="thingGroupDescription")
    def thing_group_description(self) -> Optional[str]:
        return pulumi.get(self, "thing_group_description")


@pulumi.output_type
class ThingGroupTag(dict):
    """
    A key-value pair to associate with a resource.
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        A key-value pair to associate with a resource.
        :param str key: The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
        :param str value: The value for the tag. You can specify a value that is 1 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
        """
        ThingGroupTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the tag. You can specify a value that is 1 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ThingTypePropertiesProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "searchableAttributes":
            suggest = "searchable_attributes"
        elif key == "thingTypeDescription":
            suggest = "thing_type_description"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ThingTypePropertiesProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ThingTypePropertiesProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ThingTypePropertiesProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 searchable_attributes: Optional[Sequence[str]] = None,
                 thing_type_description: Optional[str] = None):
        ThingTypePropertiesProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            searchable_attributes=searchable_attributes,
            thing_type_description=thing_type_description,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             searchable_attributes: Optional[Sequence[str]] = None,
             thing_type_description: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if searchable_attributes is not None:
            _setter("searchable_attributes", searchable_attributes)
        if thing_type_description is not None:
            _setter("thing_type_description", thing_type_description)

    @property
    @pulumi.getter(name="searchableAttributes")
    def searchable_attributes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "searchable_attributes")

    @property
    @pulumi.getter(name="thingTypeDescription")
    def thing_type_description(self) -> Optional[str]:
        return pulumi.get(self, "thing_type_description")


@pulumi.output_type
class ThingTypeTag(dict):
    """
    A key-value pair to associate with a resource.
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        A key-value pair to associate with a resource.
        :param str key: The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
        :param str value: The value for the tag. You can specify a value that is 1 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
        """
        ThingTypeTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key name of the tag. You can specify a value that is 1 to 128 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the tag. You can specify a value that is 1 to 256 Unicode characters in length and cannot be prefixed with aws:. You can use any of the following characters: the set of Unicode letters, digits, whitespace, _, ., /, =, +, and -. 
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class TimeoutConfigProperties(dict):
    """
    Specifies the amount of time each device has to finish its execution of the job.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inProgressTimeoutInMinutes":
            suggest = "in_progress_timeout_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TimeoutConfigProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TimeoutConfigProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TimeoutConfigProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 in_progress_timeout_in_minutes: int):
        """
        Specifies the amount of time each device has to finish its execution of the job.
        """
        TimeoutConfigProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            in_progress_timeout_in_minutes=in_progress_timeout_in_minutes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             in_progress_timeout_in_minutes: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("in_progress_timeout_in_minutes", in_progress_timeout_in_minutes)

    @property
    @pulumi.getter(name="inProgressTimeoutInMinutes")
    def in_progress_timeout_in_minutes(self) -> int:
        return pulumi.get(self, "in_progress_timeout_in_minutes")


@pulumi.output_type
class TopicRuleAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudwatchAlarm":
            suggest = "cloudwatch_alarm"
        elif key == "cloudwatchLogs":
            suggest = "cloudwatch_logs"
        elif key == "cloudwatchMetric":
            suggest = "cloudwatch_metric"
        elif key == "dynamoDBv2":
            suggest = "dynamo_d_bv2"
        elif key == "dynamoDb":
            suggest = "dynamo_db"
        elif key == "iotAnalytics":
            suggest = "iot_analytics"
        elif key == "iotEvents":
            suggest = "iot_events"
        elif key == "iotSiteWise":
            suggest = "iot_site_wise"
        elif key == "lambda":
            suggest = "lambda_"
        elif key == "openSearch":
            suggest = "open_search"
        elif key == "stepFunctions":
            suggest = "step_functions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloudwatch_alarm: Optional['outputs.TopicRuleCloudwatchAlarmAction'] = None,
                 cloudwatch_logs: Optional['outputs.TopicRuleCloudwatchLogsAction'] = None,
                 cloudwatch_metric: Optional['outputs.TopicRuleCloudwatchMetricAction'] = None,
                 dynamo_d_bv2: Optional['outputs.TopicRuleDynamoDBv2Action'] = None,
                 dynamo_db: Optional['outputs.TopicRuleDynamoDbAction'] = None,
                 elasticsearch: Optional['outputs.TopicRuleElasticsearchAction'] = None,
                 firehose: Optional['outputs.TopicRuleFirehoseAction'] = None,
                 http: Optional['outputs.TopicRuleHttpAction'] = None,
                 iot_analytics: Optional['outputs.TopicRuleIotAnalyticsAction'] = None,
                 iot_events: Optional['outputs.TopicRuleIotEventsAction'] = None,
                 iot_site_wise: Optional['outputs.TopicRuleIotSiteWiseAction'] = None,
                 kafka: Optional['outputs.TopicRuleKafkaAction'] = None,
                 kinesis: Optional['outputs.TopicRuleKinesisAction'] = None,
                 lambda_: Optional['outputs.TopicRuleLambdaAction'] = None,
                 location: Optional['outputs.TopicRuleLocationAction'] = None,
                 open_search: Optional['outputs.TopicRuleOpenSearchAction'] = None,
                 republish: Optional['outputs.TopicRuleRepublishAction'] = None,
                 s3: Optional['outputs.TopicRuleS3Action'] = None,
                 sns: Optional['outputs.TopicRuleSnsAction'] = None,
                 sqs: Optional['outputs.TopicRuleSqsAction'] = None,
                 step_functions: Optional['outputs.TopicRuleStepFunctionsAction'] = None,
                 timestream: Optional['outputs.TopicRuleTimestreamAction'] = None):
        TopicRuleAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloudwatch_alarm=cloudwatch_alarm,
            cloudwatch_logs=cloudwatch_logs,
            cloudwatch_metric=cloudwatch_metric,
            dynamo_d_bv2=dynamo_d_bv2,
            dynamo_db=dynamo_db,
            elasticsearch=elasticsearch,
            firehose=firehose,
            http=http,
            iot_analytics=iot_analytics,
            iot_events=iot_events,
            iot_site_wise=iot_site_wise,
            kafka=kafka,
            kinesis=kinesis,
            lambda_=lambda_,
            location=location,
            open_search=open_search,
            republish=republish,
            s3=s3,
            sns=sns,
            sqs=sqs,
            step_functions=step_functions,
            timestream=timestream,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloudwatch_alarm: Optional['outputs.TopicRuleCloudwatchAlarmAction'] = None,
             cloudwatch_logs: Optional['outputs.TopicRuleCloudwatchLogsAction'] = None,
             cloudwatch_metric: Optional['outputs.TopicRuleCloudwatchMetricAction'] = None,
             dynamo_d_bv2: Optional['outputs.TopicRuleDynamoDBv2Action'] = None,
             dynamo_db: Optional['outputs.TopicRuleDynamoDbAction'] = None,
             elasticsearch: Optional['outputs.TopicRuleElasticsearchAction'] = None,
             firehose: Optional['outputs.TopicRuleFirehoseAction'] = None,
             http: Optional['outputs.TopicRuleHttpAction'] = None,
             iot_analytics: Optional['outputs.TopicRuleIotAnalyticsAction'] = None,
             iot_events: Optional['outputs.TopicRuleIotEventsAction'] = None,
             iot_site_wise: Optional['outputs.TopicRuleIotSiteWiseAction'] = None,
             kafka: Optional['outputs.TopicRuleKafkaAction'] = None,
             kinesis: Optional['outputs.TopicRuleKinesisAction'] = None,
             lambda_: Optional['outputs.TopicRuleLambdaAction'] = None,
             location: Optional['outputs.TopicRuleLocationAction'] = None,
             open_search: Optional['outputs.TopicRuleOpenSearchAction'] = None,
             republish: Optional['outputs.TopicRuleRepublishAction'] = None,
             s3: Optional['outputs.TopicRuleS3Action'] = None,
             sns: Optional['outputs.TopicRuleSnsAction'] = None,
             sqs: Optional['outputs.TopicRuleSqsAction'] = None,
             step_functions: Optional['outputs.TopicRuleStepFunctionsAction'] = None,
             timestream: Optional['outputs.TopicRuleTimestreamAction'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cloudwatch_alarm is not None:
            _setter("cloudwatch_alarm", cloudwatch_alarm)
        if cloudwatch_logs is not None:
            _setter("cloudwatch_logs", cloudwatch_logs)
        if cloudwatch_metric is not None:
            _setter("cloudwatch_metric", cloudwatch_metric)
        if dynamo_d_bv2 is not None:
            _setter("dynamo_d_bv2", dynamo_d_bv2)
        if dynamo_db is not None:
            _setter("dynamo_db", dynamo_db)
        if elasticsearch is not None:
            _setter("elasticsearch", elasticsearch)
        if firehose is not None:
            _setter("firehose", firehose)
        if http is not None:
            _setter("http", http)
        if iot_analytics is not None:
            _setter("iot_analytics", iot_analytics)
        if iot_events is not None:
            _setter("iot_events", iot_events)
        if iot_site_wise is not None:
            _setter("iot_site_wise", iot_site_wise)
        if kafka is not None:
            _setter("kafka", kafka)
        if kinesis is not None:
            _setter("kinesis", kinesis)
        if lambda_ is not None:
            _setter("lambda_", lambda_)
        if location is not None:
            _setter("location", location)
        if open_search is not None:
            _setter("open_search", open_search)
        if republish is not None:
            _setter("republish", republish)
        if s3 is not None:
            _setter("s3", s3)
        if sns is not None:
            _setter("sns", sns)
        if sqs is not None:
            _setter("sqs", sqs)
        if step_functions is not None:
            _setter("step_functions", step_functions)
        if timestream is not None:
            _setter("timestream", timestream)

    @property
    @pulumi.getter(name="cloudwatchAlarm")
    def cloudwatch_alarm(self) -> Optional['outputs.TopicRuleCloudwatchAlarmAction']:
        return pulumi.get(self, "cloudwatch_alarm")

    @property
    @pulumi.getter(name="cloudwatchLogs")
    def cloudwatch_logs(self) -> Optional['outputs.TopicRuleCloudwatchLogsAction']:
        return pulumi.get(self, "cloudwatch_logs")

    @property
    @pulumi.getter(name="cloudwatchMetric")
    def cloudwatch_metric(self) -> Optional['outputs.TopicRuleCloudwatchMetricAction']:
        return pulumi.get(self, "cloudwatch_metric")

    @property
    @pulumi.getter(name="dynamoDBv2")
    def dynamo_d_bv2(self) -> Optional['outputs.TopicRuleDynamoDBv2Action']:
        return pulumi.get(self, "dynamo_d_bv2")

    @property
    @pulumi.getter(name="dynamoDb")
    def dynamo_db(self) -> Optional['outputs.TopicRuleDynamoDbAction']:
        return pulumi.get(self, "dynamo_db")

    @property
    @pulumi.getter
    def elasticsearch(self) -> Optional['outputs.TopicRuleElasticsearchAction']:
        return pulumi.get(self, "elasticsearch")

    @property
    @pulumi.getter
    def firehose(self) -> Optional['outputs.TopicRuleFirehoseAction']:
        return pulumi.get(self, "firehose")

    @property
    @pulumi.getter
    def http(self) -> Optional['outputs.TopicRuleHttpAction']:
        return pulumi.get(self, "http")

    @property
    @pulumi.getter(name="iotAnalytics")
    def iot_analytics(self) -> Optional['outputs.TopicRuleIotAnalyticsAction']:
        return pulumi.get(self, "iot_analytics")

    @property
    @pulumi.getter(name="iotEvents")
    def iot_events(self) -> Optional['outputs.TopicRuleIotEventsAction']:
        return pulumi.get(self, "iot_events")

    @property
    @pulumi.getter(name="iotSiteWise")
    def iot_site_wise(self) -> Optional['outputs.TopicRuleIotSiteWiseAction']:
        return pulumi.get(self, "iot_site_wise")

    @property
    @pulumi.getter
    def kafka(self) -> Optional['outputs.TopicRuleKafkaAction']:
        return pulumi.get(self, "kafka")

    @property
    @pulumi.getter
    def kinesis(self) -> Optional['outputs.TopicRuleKinesisAction']:
        return pulumi.get(self, "kinesis")

    @property
    @pulumi.getter(name="lambda")
    def lambda_(self) -> Optional['outputs.TopicRuleLambdaAction']:
        return pulumi.get(self, "lambda_")

    @property
    @pulumi.getter
    def location(self) -> Optional['outputs.TopicRuleLocationAction']:
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="openSearch")
    def open_search(self) -> Optional['outputs.TopicRuleOpenSearchAction']:
        return pulumi.get(self, "open_search")

    @property
    @pulumi.getter
    def republish(self) -> Optional['outputs.TopicRuleRepublishAction']:
        return pulumi.get(self, "republish")

    @property
    @pulumi.getter
    def s3(self) -> Optional['outputs.TopicRuleS3Action']:
        return pulumi.get(self, "s3")

    @property
    @pulumi.getter
    def sns(self) -> Optional['outputs.TopicRuleSnsAction']:
        return pulumi.get(self, "sns")

    @property
    @pulumi.getter
    def sqs(self) -> Optional['outputs.TopicRuleSqsAction']:
        return pulumi.get(self, "sqs")

    @property
    @pulumi.getter(name="stepFunctions")
    def step_functions(self) -> Optional['outputs.TopicRuleStepFunctionsAction']:
        return pulumi.get(self, "step_functions")

    @property
    @pulumi.getter
    def timestream(self) -> Optional['outputs.TopicRuleTimestreamAction']:
        return pulumi.get(self, "timestream")


@pulumi.output_type
class TopicRuleAssetPropertyTimestamp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeInSeconds":
            suggest = "time_in_seconds"
        elif key == "offsetInNanos":
            suggest = "offset_in_nanos"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleAssetPropertyTimestamp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleAssetPropertyTimestamp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleAssetPropertyTimestamp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 time_in_seconds: str,
                 offset_in_nanos: Optional[str] = None):
        TopicRuleAssetPropertyTimestamp._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            time_in_seconds=time_in_seconds,
            offset_in_nanos=offset_in_nanos,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             time_in_seconds: str,
             offset_in_nanos: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("time_in_seconds", time_in_seconds)
        if offset_in_nanos is not None:
            _setter("offset_in_nanos", offset_in_nanos)

    @property
    @pulumi.getter(name="timeInSeconds")
    def time_in_seconds(self) -> str:
        return pulumi.get(self, "time_in_seconds")

    @property
    @pulumi.getter(name="offsetInNanos")
    def offset_in_nanos(self) -> Optional[str]:
        return pulumi.get(self, "offset_in_nanos")


@pulumi.output_type
class TopicRuleAssetPropertyValue(dict):
    def __init__(__self__, *,
                 timestamp: 'outputs.TopicRuleAssetPropertyTimestamp',
                 value: 'outputs.TopicRuleAssetPropertyVariant',
                 quality: Optional[str] = None):
        TopicRuleAssetPropertyValue._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            timestamp=timestamp,
            value=value,
            quality=quality,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             timestamp: 'outputs.TopicRuleAssetPropertyTimestamp',
             value: 'outputs.TopicRuleAssetPropertyVariant',
             quality: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("timestamp", timestamp)
        _setter("value", value)
        if quality is not None:
            _setter("quality", quality)

    @property
    @pulumi.getter
    def timestamp(self) -> 'outputs.TopicRuleAssetPropertyTimestamp':
        return pulumi.get(self, "timestamp")

    @property
    @pulumi.getter
    def value(self) -> 'outputs.TopicRuleAssetPropertyVariant':
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def quality(self) -> Optional[str]:
        return pulumi.get(self, "quality")


@pulumi.output_type
class TopicRuleAssetPropertyVariant(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "booleanValue":
            suggest = "boolean_value"
        elif key == "doubleValue":
            suggest = "double_value"
        elif key == "integerValue":
            suggest = "integer_value"
        elif key == "stringValue":
            suggest = "string_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleAssetPropertyVariant. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleAssetPropertyVariant.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleAssetPropertyVariant.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 boolean_value: Optional[str] = None,
                 double_value: Optional[str] = None,
                 integer_value: Optional[str] = None,
                 string_value: Optional[str] = None):
        TopicRuleAssetPropertyVariant._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            boolean_value=boolean_value,
            double_value=double_value,
            integer_value=integer_value,
            string_value=string_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             boolean_value: Optional[str] = None,
             double_value: Optional[str] = None,
             integer_value: Optional[str] = None,
             string_value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if boolean_value is not None:
            _setter("boolean_value", boolean_value)
        if double_value is not None:
            _setter("double_value", double_value)
        if integer_value is not None:
            _setter("integer_value", integer_value)
        if string_value is not None:
            _setter("string_value", string_value)

    @property
    @pulumi.getter(name="booleanValue")
    def boolean_value(self) -> Optional[str]:
        return pulumi.get(self, "boolean_value")

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional[str]:
        return pulumi.get(self, "double_value")

    @property
    @pulumi.getter(name="integerValue")
    def integer_value(self) -> Optional[str]:
        return pulumi.get(self, "integer_value")

    @property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> Optional[str]:
        return pulumi.get(self, "string_value")


@pulumi.output_type
class TopicRuleCloudwatchAlarmAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alarmName":
            suggest = "alarm_name"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "stateReason":
            suggest = "state_reason"
        elif key == "stateValue":
            suggest = "state_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleCloudwatchAlarmAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleCloudwatchAlarmAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleCloudwatchAlarmAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alarm_name: str,
                 role_arn: str,
                 state_reason: str,
                 state_value: str):
        TopicRuleCloudwatchAlarmAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alarm_name=alarm_name,
            role_arn=role_arn,
            state_reason=state_reason,
            state_value=state_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alarm_name: str,
             role_arn: str,
             state_reason: str,
             state_value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("alarm_name", alarm_name)
        _setter("role_arn", role_arn)
        _setter("state_reason", state_reason)
        _setter("state_value", state_value)

    @property
    @pulumi.getter(name="alarmName")
    def alarm_name(self) -> str:
        return pulumi.get(self, "alarm_name")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="stateReason")
    def state_reason(self) -> str:
        return pulumi.get(self, "state_reason")

    @property
    @pulumi.getter(name="stateValue")
    def state_value(self) -> str:
        return pulumi.get(self, "state_value")


@pulumi.output_type
class TopicRuleCloudwatchLogsAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logGroupName":
            suggest = "log_group_name"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "batchMode":
            suggest = "batch_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleCloudwatchLogsAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleCloudwatchLogsAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleCloudwatchLogsAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 log_group_name: str,
                 role_arn: str,
                 batch_mode: Optional[bool] = None):
        TopicRuleCloudwatchLogsAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            log_group_name=log_group_name,
            role_arn=role_arn,
            batch_mode=batch_mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             log_group_name: str,
             role_arn: str,
             batch_mode: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("log_group_name", log_group_name)
        _setter("role_arn", role_arn)
        if batch_mode is not None:
            _setter("batch_mode", batch_mode)

    @property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> str:
        return pulumi.get(self, "log_group_name")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="batchMode")
    def batch_mode(self) -> Optional[bool]:
        return pulumi.get(self, "batch_mode")


@pulumi.output_type
class TopicRuleCloudwatchMetricAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricName":
            suggest = "metric_name"
        elif key == "metricNamespace":
            suggest = "metric_namespace"
        elif key == "metricUnit":
            suggest = "metric_unit"
        elif key == "metricValue":
            suggest = "metric_value"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "metricTimestamp":
            suggest = "metric_timestamp"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleCloudwatchMetricAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleCloudwatchMetricAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleCloudwatchMetricAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_name: str,
                 metric_namespace: str,
                 metric_unit: str,
                 metric_value: str,
                 role_arn: str,
                 metric_timestamp: Optional[str] = None):
        TopicRuleCloudwatchMetricAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric_name=metric_name,
            metric_namespace=metric_namespace,
            metric_unit=metric_unit,
            metric_value=metric_value,
            role_arn=role_arn,
            metric_timestamp=metric_timestamp,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric_name: str,
             metric_namespace: str,
             metric_unit: str,
             metric_value: str,
             role_arn: str,
             metric_timestamp: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("metric_name", metric_name)
        _setter("metric_namespace", metric_namespace)
        _setter("metric_unit", metric_unit)
        _setter("metric_value", metric_value)
        _setter("role_arn", role_arn)
        if metric_timestamp is not None:
            _setter("metric_timestamp", metric_timestamp)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> str:
        return pulumi.get(self, "metric_name")

    @property
    @pulumi.getter(name="metricNamespace")
    def metric_namespace(self) -> str:
        return pulumi.get(self, "metric_namespace")

    @property
    @pulumi.getter(name="metricUnit")
    def metric_unit(self) -> str:
        return pulumi.get(self, "metric_unit")

    @property
    @pulumi.getter(name="metricValue")
    def metric_value(self) -> str:
        return pulumi.get(self, "metric_value")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="metricTimestamp")
    def metric_timestamp(self) -> Optional[str]:
        return pulumi.get(self, "metric_timestamp")


@pulumi.output_type
class TopicRuleDestinationHttpUrlDestinationSummary(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "confirmationUrl":
            suggest = "confirmation_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleDestinationHttpUrlDestinationSummary. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleDestinationHttpUrlDestinationSummary.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleDestinationHttpUrlDestinationSummary.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 confirmation_url: Optional[str] = None):
        TopicRuleDestinationHttpUrlDestinationSummary._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            confirmation_url=confirmation_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             confirmation_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if confirmation_url is not None:
            _setter("confirmation_url", confirmation_url)

    @property
    @pulumi.getter(name="confirmationUrl")
    def confirmation_url(self) -> Optional[str]:
        return pulumi.get(self, "confirmation_url")


@pulumi.output_type
class TopicRuleDestinationVpcDestinationProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"
        elif key == "securityGroups":
            suggest = "security_groups"
        elif key == "subnetIds":
            suggest = "subnet_ids"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleDestinationVpcDestinationProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleDestinationVpcDestinationProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleDestinationVpcDestinationProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: Optional[str] = None,
                 security_groups: Optional[Sequence[str]] = None,
                 subnet_ids: Optional[Sequence[str]] = None,
                 vpc_id: Optional[str] = None):
        TopicRuleDestinationVpcDestinationProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            role_arn=role_arn,
            security_groups=security_groups,
            subnet_ids=subnet_ids,
            vpc_id=vpc_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             role_arn: Optional[str] = None,
             security_groups: Optional[Sequence[str]] = None,
             subnet_ids: Optional[Sequence[str]] = None,
             vpc_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if role_arn is not None:
            _setter("role_arn", role_arn)
        if security_groups is not None:
            _setter("security_groups", security_groups)
        if subnet_ids is not None:
            _setter("subnet_ids", subnet_ids)
        if vpc_id is not None:
            _setter("vpc_id", vpc_id)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "security_groups")

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "subnet_ids")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[str]:
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class TopicRuleDynamoDBv2Action(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "putItem":
            suggest = "put_item"
        elif key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleDynamoDBv2Action. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleDynamoDBv2Action.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleDynamoDBv2Action.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 put_item: Optional['outputs.TopicRulePutItemInput'] = None,
                 role_arn: Optional[str] = None):
        TopicRuleDynamoDBv2Action._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            put_item=put_item,
            role_arn=role_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             put_item: Optional['outputs.TopicRulePutItemInput'] = None,
             role_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if put_item is not None:
            _setter("put_item", put_item)
        if role_arn is not None:
            _setter("role_arn", role_arn)

    @property
    @pulumi.getter(name="putItem")
    def put_item(self) -> Optional['outputs.TopicRulePutItemInput']:
        return pulumi.get(self, "put_item")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class TopicRuleDynamoDbAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hashKeyField":
            suggest = "hash_key_field"
        elif key == "hashKeyValue":
            suggest = "hash_key_value"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "tableName":
            suggest = "table_name"
        elif key == "hashKeyType":
            suggest = "hash_key_type"
        elif key == "payloadField":
            suggest = "payload_field"
        elif key == "rangeKeyField":
            suggest = "range_key_field"
        elif key == "rangeKeyType":
            suggest = "range_key_type"
        elif key == "rangeKeyValue":
            suggest = "range_key_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleDynamoDbAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleDynamoDbAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleDynamoDbAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hash_key_field: str,
                 hash_key_value: str,
                 role_arn: str,
                 table_name: str,
                 hash_key_type: Optional[str] = None,
                 payload_field: Optional[str] = None,
                 range_key_field: Optional[str] = None,
                 range_key_type: Optional[str] = None,
                 range_key_value: Optional[str] = None):
        TopicRuleDynamoDbAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hash_key_field=hash_key_field,
            hash_key_value=hash_key_value,
            role_arn=role_arn,
            table_name=table_name,
            hash_key_type=hash_key_type,
            payload_field=payload_field,
            range_key_field=range_key_field,
            range_key_type=range_key_type,
            range_key_value=range_key_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hash_key_field: str,
             hash_key_value: str,
             role_arn: str,
             table_name: str,
             hash_key_type: Optional[str] = None,
             payload_field: Optional[str] = None,
             range_key_field: Optional[str] = None,
             range_key_type: Optional[str] = None,
             range_key_value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("hash_key_field", hash_key_field)
        _setter("hash_key_value", hash_key_value)
        _setter("role_arn", role_arn)
        _setter("table_name", table_name)
        if hash_key_type is not None:
            _setter("hash_key_type", hash_key_type)
        if payload_field is not None:
            _setter("payload_field", payload_field)
        if range_key_field is not None:
            _setter("range_key_field", range_key_field)
        if range_key_type is not None:
            _setter("range_key_type", range_key_type)
        if range_key_value is not None:
            _setter("range_key_value", range_key_value)

    @property
    @pulumi.getter(name="hashKeyField")
    def hash_key_field(self) -> str:
        return pulumi.get(self, "hash_key_field")

    @property
    @pulumi.getter(name="hashKeyValue")
    def hash_key_value(self) -> str:
        return pulumi.get(self, "hash_key_value")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> str:
        return pulumi.get(self, "table_name")

    @property
    @pulumi.getter(name="hashKeyType")
    def hash_key_type(self) -> Optional[str]:
        return pulumi.get(self, "hash_key_type")

    @property
    @pulumi.getter(name="payloadField")
    def payload_field(self) -> Optional[str]:
        return pulumi.get(self, "payload_field")

    @property
    @pulumi.getter(name="rangeKeyField")
    def range_key_field(self) -> Optional[str]:
        return pulumi.get(self, "range_key_field")

    @property
    @pulumi.getter(name="rangeKeyType")
    def range_key_type(self) -> Optional[str]:
        return pulumi.get(self, "range_key_type")

    @property
    @pulumi.getter(name="rangeKeyValue")
    def range_key_value(self) -> Optional[str]:
        return pulumi.get(self, "range_key_value")


@pulumi.output_type
class TopicRuleElasticsearchAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleElasticsearchAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleElasticsearchAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleElasticsearchAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: str,
                 id: str,
                 index: str,
                 role_arn: str,
                 type: str):
        TopicRuleElasticsearchAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint=endpoint,
            id=id,
            index=index,
            role_arn=role_arn,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint: str,
             id: str,
             index: str,
             role_arn: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("endpoint", endpoint)
        _setter("id", id)
        _setter("index", index)
        _setter("role_arn", role_arn)
        _setter("type", type)

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class TopicRuleFirehoseAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deliveryStreamName":
            suggest = "delivery_stream_name"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "batchMode":
            suggest = "batch_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleFirehoseAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleFirehoseAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleFirehoseAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delivery_stream_name: str,
                 role_arn: str,
                 batch_mode: Optional[bool] = None,
                 separator: Optional[str] = None):
        TopicRuleFirehoseAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            delivery_stream_name=delivery_stream_name,
            role_arn=role_arn,
            batch_mode=batch_mode,
            separator=separator,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             delivery_stream_name: str,
             role_arn: str,
             batch_mode: Optional[bool] = None,
             separator: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("delivery_stream_name", delivery_stream_name)
        _setter("role_arn", role_arn)
        if batch_mode is not None:
            _setter("batch_mode", batch_mode)
        if separator is not None:
            _setter("separator", separator)

    @property
    @pulumi.getter(name="deliveryStreamName")
    def delivery_stream_name(self) -> str:
        return pulumi.get(self, "delivery_stream_name")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="batchMode")
    def batch_mode(self) -> Optional[bool]:
        return pulumi.get(self, "batch_mode")

    @property
    @pulumi.getter
    def separator(self) -> Optional[str]:
        return pulumi.get(self, "separator")


@pulumi.output_type
class TopicRuleHttpAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "confirmationUrl":
            suggest = "confirmation_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleHttpAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleHttpAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleHttpAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 auth: Optional['outputs.TopicRuleHttpAuthorization'] = None,
                 confirmation_url: Optional[str] = None,
                 headers: Optional[Sequence['outputs.TopicRuleHttpActionHeader']] = None):
        TopicRuleHttpAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            url=url,
            auth=auth,
            confirmation_url=confirmation_url,
            headers=headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             url: str,
             auth: Optional['outputs.TopicRuleHttpAuthorization'] = None,
             confirmation_url: Optional[str] = None,
             headers: Optional[Sequence['outputs.TopicRuleHttpActionHeader']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("url", url)
        if auth is not None:
            _setter("auth", auth)
        if confirmation_url is not None:
            _setter("confirmation_url", confirmation_url)
        if headers is not None:
            _setter("headers", headers)

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def auth(self) -> Optional['outputs.TopicRuleHttpAuthorization']:
        return pulumi.get(self, "auth")

    @property
    @pulumi.getter(name="confirmationUrl")
    def confirmation_url(self) -> Optional[str]:
        return pulumi.get(self, "confirmation_url")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.TopicRuleHttpActionHeader']]:
        return pulumi.get(self, "headers")


@pulumi.output_type
class TopicRuleHttpActionHeader(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        TopicRuleHttpActionHeader._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class TopicRuleHttpAuthorization(dict):
    def __init__(__self__, *,
                 sigv4: Optional['outputs.TopicRuleSigV4Authorization'] = None):
        TopicRuleHttpAuthorization._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sigv4=sigv4,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sigv4: Optional['outputs.TopicRuleSigV4Authorization'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if sigv4 is not None:
            _setter("sigv4", sigv4)

    @property
    @pulumi.getter
    def sigv4(self) -> Optional['outputs.TopicRuleSigV4Authorization']:
        return pulumi.get(self, "sigv4")


@pulumi.output_type
class TopicRuleIotAnalyticsAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "channelName":
            suggest = "channel_name"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "batchMode":
            suggest = "batch_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleIotAnalyticsAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleIotAnalyticsAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleIotAnalyticsAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 channel_name: str,
                 role_arn: str,
                 batch_mode: Optional[bool] = None):
        TopicRuleIotAnalyticsAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            channel_name=channel_name,
            role_arn=role_arn,
            batch_mode=batch_mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             channel_name: str,
             role_arn: str,
             batch_mode: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("channel_name", channel_name)
        _setter("role_arn", role_arn)
        if batch_mode is not None:
            _setter("batch_mode", batch_mode)

    @property
    @pulumi.getter(name="channelName")
    def channel_name(self) -> str:
        return pulumi.get(self, "channel_name")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="batchMode")
    def batch_mode(self) -> Optional[bool]:
        return pulumi.get(self, "batch_mode")


@pulumi.output_type
class TopicRuleIotEventsAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputName":
            suggest = "input_name"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "batchMode":
            suggest = "batch_mode"
        elif key == "messageId":
            suggest = "message_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleIotEventsAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleIotEventsAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleIotEventsAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input_name: str,
                 role_arn: str,
                 batch_mode: Optional[bool] = None,
                 message_id: Optional[str] = None):
        TopicRuleIotEventsAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            input_name=input_name,
            role_arn=role_arn,
            batch_mode=batch_mode,
            message_id=message_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             input_name: str,
             role_arn: str,
             batch_mode: Optional[bool] = None,
             message_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("input_name", input_name)
        _setter("role_arn", role_arn)
        if batch_mode is not None:
            _setter("batch_mode", batch_mode)
        if message_id is not None:
            _setter("message_id", message_id)

    @property
    @pulumi.getter(name="inputName")
    def input_name(self) -> str:
        return pulumi.get(self, "input_name")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="batchMode")
    def batch_mode(self) -> Optional[bool]:
        return pulumi.get(self, "batch_mode")

    @property
    @pulumi.getter(name="messageId")
    def message_id(self) -> Optional[str]:
        return pulumi.get(self, "message_id")


@pulumi.output_type
class TopicRuleIotSiteWiseAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "putAssetPropertyValueEntries":
            suggest = "put_asset_property_value_entries"
        elif key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleIotSiteWiseAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleIotSiteWiseAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleIotSiteWiseAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 put_asset_property_value_entries: Sequence['outputs.TopicRulePutAssetPropertyValueEntry'],
                 role_arn: str):
        TopicRuleIotSiteWiseAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            put_asset_property_value_entries=put_asset_property_value_entries,
            role_arn=role_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             put_asset_property_value_entries: Sequence['outputs.TopicRulePutAssetPropertyValueEntry'],
             role_arn: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("put_asset_property_value_entries", put_asset_property_value_entries)
        _setter("role_arn", role_arn)

    @property
    @pulumi.getter(name="putAssetPropertyValueEntries")
    def put_asset_property_value_entries(self) -> Sequence['outputs.TopicRulePutAssetPropertyValueEntry']:
        return pulumi.get(self, "put_asset_property_value_entries")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class TopicRuleKafkaAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientProperties":
            suggest = "client_properties"
        elif key == "destinationArn":
            suggest = "destination_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleKafkaAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleKafkaAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleKafkaAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_properties: Any,
                 destination_arn: str,
                 topic: str,
                 key: Optional[str] = None,
                 partition: Optional[str] = None):
        TopicRuleKafkaAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_properties=client_properties,
            destination_arn=destination_arn,
            topic=topic,
            key=key,
            partition=partition,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_properties: Any,
             destination_arn: str,
             topic: str,
             key: Optional[str] = None,
             partition: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("client_properties", client_properties)
        _setter("destination_arn", destination_arn)
        _setter("topic", topic)
        if key is not None:
            _setter("key", key)
        if partition is not None:
            _setter("partition", partition)

    @property
    @pulumi.getter(name="clientProperties")
    def client_properties(self) -> Any:
        return pulumi.get(self, "client_properties")

    @property
    @pulumi.getter(name="destinationArn")
    def destination_arn(self) -> str:
        return pulumi.get(self, "destination_arn")

    @property
    @pulumi.getter
    def topic(self) -> str:
        return pulumi.get(self, "topic")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def partition(self) -> Optional[str]:
        return pulumi.get(self, "partition")


@pulumi.output_type
class TopicRuleKinesisAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"
        elif key == "streamName":
            suggest = "stream_name"
        elif key == "partitionKey":
            suggest = "partition_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleKinesisAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleKinesisAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleKinesisAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: str,
                 stream_name: str,
                 partition_key: Optional[str] = None):
        TopicRuleKinesisAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            role_arn=role_arn,
            stream_name=stream_name,
            partition_key=partition_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             role_arn: str,
             stream_name: str,
             partition_key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("role_arn", role_arn)
        _setter("stream_name", stream_name)
        if partition_key is not None:
            _setter("partition_key", partition_key)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> str:
        return pulumi.get(self, "stream_name")

    @property
    @pulumi.getter(name="partitionKey")
    def partition_key(self) -> Optional[str]:
        return pulumi.get(self, "partition_key")


@pulumi.output_type
class TopicRuleLambdaAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "functionArn":
            suggest = "function_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleLambdaAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleLambdaAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleLambdaAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 function_arn: Optional[str] = None):
        TopicRuleLambdaAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            function_arn=function_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             function_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if function_arn is not None:
            _setter("function_arn", function_arn)

    @property
    @pulumi.getter(name="functionArn")
    def function_arn(self) -> Optional[str]:
        return pulumi.get(self, "function_arn")


@pulumi.output_type
class TopicRuleLocationAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceId":
            suggest = "device_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "trackerName":
            suggest = "tracker_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleLocationAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleLocationAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleLocationAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_id: str,
                 latitude: str,
                 longitude: str,
                 role_arn: str,
                 tracker_name: str,
                 timestamp: Optional['outputs.TopicRuleTimestamp'] = None):
        TopicRuleLocationAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            device_id=device_id,
            latitude=latitude,
            longitude=longitude,
            role_arn=role_arn,
            tracker_name=tracker_name,
            timestamp=timestamp,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             device_id: str,
             latitude: str,
             longitude: str,
             role_arn: str,
             tracker_name: str,
             timestamp: Optional['outputs.TopicRuleTimestamp'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("device_id", device_id)
        _setter("latitude", latitude)
        _setter("longitude", longitude)
        _setter("role_arn", role_arn)
        _setter("tracker_name", tracker_name)
        if timestamp is not None:
            _setter("timestamp", timestamp)

    @property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> str:
        return pulumi.get(self, "device_id")

    @property
    @pulumi.getter
    def latitude(self) -> str:
        return pulumi.get(self, "latitude")

    @property
    @pulumi.getter
    def longitude(self) -> str:
        return pulumi.get(self, "longitude")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="trackerName")
    def tracker_name(self) -> str:
        return pulumi.get(self, "tracker_name")

    @property
    @pulumi.getter
    def timestamp(self) -> Optional['outputs.TopicRuleTimestamp']:
        return pulumi.get(self, "timestamp")


@pulumi.output_type
class TopicRuleOpenSearchAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleOpenSearchAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleOpenSearchAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleOpenSearchAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: str,
                 id: str,
                 index: str,
                 role_arn: str,
                 type: str):
        TopicRuleOpenSearchAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint=endpoint,
            id=id,
            index=index,
            role_arn=role_arn,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint: str,
             id: str,
             index: str,
             role_arn: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("endpoint", endpoint)
        _setter("id", id)
        _setter("index", index)
        _setter("role_arn", role_arn)
        _setter("type", type)

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class TopicRulePayload(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsIotSqlVersion":
            suggest = "aws_iot_sql_version"
        elif key == "errorAction":
            suggest = "error_action"
        elif key == "ruleDisabled":
            suggest = "rule_disabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRulePayload. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRulePayload.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRulePayload.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions: Sequence['outputs.TopicRuleAction'],
                 sql: str,
                 aws_iot_sql_version: Optional[str] = None,
                 description: Optional[str] = None,
                 error_action: Optional['outputs.TopicRuleAction'] = None,
                 rule_disabled: Optional[bool] = None):
        TopicRulePayload._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
            sql=sql,
            aws_iot_sql_version=aws_iot_sql_version,
            description=description,
            error_action=error_action,
            rule_disabled=rule_disabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: Sequence['outputs.TopicRuleAction'],
             sql: str,
             aws_iot_sql_version: Optional[str] = None,
             description: Optional[str] = None,
             error_action: Optional['outputs.TopicRuleAction'] = None,
             rule_disabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("actions", actions)
        _setter("sql", sql)
        if aws_iot_sql_version is not None:
            _setter("aws_iot_sql_version", aws_iot_sql_version)
        if description is not None:
            _setter("description", description)
        if error_action is not None:
            _setter("error_action", error_action)
        if rule_disabled is not None:
            _setter("rule_disabled", rule_disabled)

    @property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.TopicRuleAction']:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def sql(self) -> str:
        return pulumi.get(self, "sql")

    @property
    @pulumi.getter(name="awsIotSqlVersion")
    def aws_iot_sql_version(self) -> Optional[str]:
        return pulumi.get(self, "aws_iot_sql_version")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="errorAction")
    def error_action(self) -> Optional['outputs.TopicRuleAction']:
        return pulumi.get(self, "error_action")

    @property
    @pulumi.getter(name="ruleDisabled")
    def rule_disabled(self) -> Optional[bool]:
        return pulumi.get(self, "rule_disabled")


@pulumi.output_type
class TopicRulePutAssetPropertyValueEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "propertyValues":
            suggest = "property_values"
        elif key == "assetId":
            suggest = "asset_id"
        elif key == "entryId":
            suggest = "entry_id"
        elif key == "propertyAlias":
            suggest = "property_alias"
        elif key == "propertyId":
            suggest = "property_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRulePutAssetPropertyValueEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRulePutAssetPropertyValueEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRulePutAssetPropertyValueEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 property_values: Sequence['outputs.TopicRuleAssetPropertyValue'],
                 asset_id: Optional[str] = None,
                 entry_id: Optional[str] = None,
                 property_alias: Optional[str] = None,
                 property_id: Optional[str] = None):
        TopicRulePutAssetPropertyValueEntry._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            property_values=property_values,
            asset_id=asset_id,
            entry_id=entry_id,
            property_alias=property_alias,
            property_id=property_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             property_values: Sequence['outputs.TopicRuleAssetPropertyValue'],
             asset_id: Optional[str] = None,
             entry_id: Optional[str] = None,
             property_alias: Optional[str] = None,
             property_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("property_values", property_values)
        if asset_id is not None:
            _setter("asset_id", asset_id)
        if entry_id is not None:
            _setter("entry_id", entry_id)
        if property_alias is not None:
            _setter("property_alias", property_alias)
        if property_id is not None:
            _setter("property_id", property_id)

    @property
    @pulumi.getter(name="propertyValues")
    def property_values(self) -> Sequence['outputs.TopicRuleAssetPropertyValue']:
        return pulumi.get(self, "property_values")

    @property
    @pulumi.getter(name="assetId")
    def asset_id(self) -> Optional[str]:
        return pulumi.get(self, "asset_id")

    @property
    @pulumi.getter(name="entryId")
    def entry_id(self) -> Optional[str]:
        return pulumi.get(self, "entry_id")

    @property
    @pulumi.getter(name="propertyAlias")
    def property_alias(self) -> Optional[str]:
        return pulumi.get(self, "property_alias")

    @property
    @pulumi.getter(name="propertyId")
    def property_id(self) -> Optional[str]:
        return pulumi.get(self, "property_id")


@pulumi.output_type
class TopicRulePutItemInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tableName":
            suggest = "table_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRulePutItemInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRulePutItemInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRulePutItemInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 table_name: str):
        TopicRulePutItemInput._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            table_name=table_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             table_name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("table_name", table_name)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> str:
        return pulumi.get(self, "table_name")


@pulumi.output_type
class TopicRuleRepublishAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleRepublishAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleRepublishAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleRepublishAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: str,
                 topic: str,
                 headers: Optional['outputs.TopicRuleRepublishActionHeaders'] = None,
                 qos: Optional[int] = None):
        TopicRuleRepublishAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            role_arn=role_arn,
            topic=topic,
            headers=headers,
            qos=qos,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             role_arn: str,
             topic: str,
             headers: Optional['outputs.TopicRuleRepublishActionHeaders'] = None,
             qos: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("role_arn", role_arn)
        _setter("topic", topic)
        if headers is not None:
            _setter("headers", headers)
        if qos is not None:
            _setter("qos", qos)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter
    def topic(self) -> str:
        return pulumi.get(self, "topic")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.TopicRuleRepublishActionHeaders']:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def qos(self) -> Optional[int]:
        return pulumi.get(self, "qos")


@pulumi.output_type
class TopicRuleRepublishActionHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentType":
            suggest = "content_type"
        elif key == "correlationData":
            suggest = "correlation_data"
        elif key == "messageExpiry":
            suggest = "message_expiry"
        elif key == "payloadFormatIndicator":
            suggest = "payload_format_indicator"
        elif key == "responseTopic":
            suggest = "response_topic"
        elif key == "userProperties":
            suggest = "user_properties"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleRepublishActionHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleRepublishActionHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleRepublishActionHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content_type: Optional[str] = None,
                 correlation_data: Optional[str] = None,
                 message_expiry: Optional[str] = None,
                 payload_format_indicator: Optional[str] = None,
                 response_topic: Optional[str] = None,
                 user_properties: Optional[Sequence['outputs.TopicRuleUserProperty']] = None):
        TopicRuleRepublishActionHeaders._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            content_type=content_type,
            correlation_data=correlation_data,
            message_expiry=message_expiry,
            payload_format_indicator=payload_format_indicator,
            response_topic=response_topic,
            user_properties=user_properties,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             content_type: Optional[str] = None,
             correlation_data: Optional[str] = None,
             message_expiry: Optional[str] = None,
             payload_format_indicator: Optional[str] = None,
             response_topic: Optional[str] = None,
             user_properties: Optional[Sequence['outputs.TopicRuleUserProperty']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if content_type is not None:
            _setter("content_type", content_type)
        if correlation_data is not None:
            _setter("correlation_data", correlation_data)
        if message_expiry is not None:
            _setter("message_expiry", message_expiry)
        if payload_format_indicator is not None:
            _setter("payload_format_indicator", payload_format_indicator)
        if response_topic is not None:
            _setter("response_topic", response_topic)
        if user_properties is not None:
            _setter("user_properties", user_properties)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[str]:
        return pulumi.get(self, "content_type")

    @property
    @pulumi.getter(name="correlationData")
    def correlation_data(self) -> Optional[str]:
        return pulumi.get(self, "correlation_data")

    @property
    @pulumi.getter(name="messageExpiry")
    def message_expiry(self) -> Optional[str]:
        return pulumi.get(self, "message_expiry")

    @property
    @pulumi.getter(name="payloadFormatIndicator")
    def payload_format_indicator(self) -> Optional[str]:
        return pulumi.get(self, "payload_format_indicator")

    @property
    @pulumi.getter(name="responseTopic")
    def response_topic(self) -> Optional[str]:
        return pulumi.get(self, "response_topic")

    @property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[Sequence['outputs.TopicRuleUserProperty']]:
        return pulumi.get(self, "user_properties")


@pulumi.output_type
class TopicRuleS3Action(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "cannedAcl":
            suggest = "canned_acl"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleS3Action. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleS3Action.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleS3Action.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: str,
                 key: str,
                 role_arn: str,
                 canned_acl: Optional['TopicRuleCannedAccessControlList'] = None):
        TopicRuleS3Action._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket_name=bucket_name,
            key=key,
            role_arn=role_arn,
            canned_acl=canned_acl,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket_name: str,
             key: str,
             role_arn: str,
             canned_acl: Optional['TopicRuleCannedAccessControlList'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("bucket_name", bucket_name)
        _setter("key", key)
        _setter("role_arn", role_arn)
        if canned_acl is not None:
            _setter("canned_acl", canned_acl)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> str:
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional['TopicRuleCannedAccessControlList']:
        return pulumi.get(self, "canned_acl")


@pulumi.output_type
class TopicRuleSigV4Authorization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"
        elif key == "serviceName":
            suggest = "service_name"
        elif key == "signingRegion":
            suggest = "signing_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleSigV4Authorization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleSigV4Authorization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleSigV4Authorization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: str,
                 service_name: str,
                 signing_region: str):
        TopicRuleSigV4Authorization._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            role_arn=role_arn,
            service_name=service_name,
            signing_region=signing_region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             role_arn: str,
             service_name: str,
             signing_region: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("role_arn", role_arn)
        _setter("service_name", service_name)
        _setter("signing_region", signing_region)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> str:
        return pulumi.get(self, "service_name")

    @property
    @pulumi.getter(name="signingRegion")
    def signing_region(self) -> str:
        return pulumi.get(self, "signing_region")


@pulumi.output_type
class TopicRuleSnsAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"
        elif key == "targetArn":
            suggest = "target_arn"
        elif key == "messageFormat":
            suggest = "message_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleSnsAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleSnsAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleSnsAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: str,
                 target_arn: str,
                 message_format: Optional[str] = None):
        TopicRuleSnsAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            role_arn=role_arn,
            target_arn=target_arn,
            message_format=message_format,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             role_arn: str,
             target_arn: str,
             message_format: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("role_arn", role_arn)
        _setter("target_arn", target_arn)
        if message_format is not None:
            _setter("message_format", message_format)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="targetArn")
    def target_arn(self) -> str:
        return pulumi.get(self, "target_arn")

    @property
    @pulumi.getter(name="messageFormat")
    def message_format(self) -> Optional[str]:
        return pulumi.get(self, "message_format")


@pulumi.output_type
class TopicRuleSqsAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queueUrl":
            suggest = "queue_url"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "useBase64":
            suggest = "use_base64"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleSqsAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleSqsAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleSqsAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 queue_url: str,
                 role_arn: str,
                 use_base64: Optional[bool] = None):
        TopicRuleSqsAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            queue_url=queue_url,
            role_arn=role_arn,
            use_base64=use_base64,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             queue_url: str,
             role_arn: str,
             use_base64: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("queue_url", queue_url)
        _setter("role_arn", role_arn)
        if use_base64 is not None:
            _setter("use_base64", use_base64)

    @property
    @pulumi.getter(name="queueUrl")
    def queue_url(self) -> str:
        return pulumi.get(self, "queue_url")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="useBase64")
    def use_base64(self) -> Optional[bool]:
        return pulumi.get(self, "use_base64")


@pulumi.output_type
class TopicRuleStepFunctionsAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"
        elif key == "stateMachineName":
            suggest = "state_machine_name"
        elif key == "executionNamePrefix":
            suggest = "execution_name_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleStepFunctionsAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleStepFunctionsAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleStepFunctionsAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: str,
                 state_machine_name: str,
                 execution_name_prefix: Optional[str] = None):
        TopicRuleStepFunctionsAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            role_arn=role_arn,
            state_machine_name=state_machine_name,
            execution_name_prefix=execution_name_prefix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             role_arn: str,
             state_machine_name: str,
             execution_name_prefix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("role_arn", role_arn)
        _setter("state_machine_name", state_machine_name)
        if execution_name_prefix is not None:
            _setter("execution_name_prefix", execution_name_prefix)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="stateMachineName")
    def state_machine_name(self) -> str:
        return pulumi.get(self, "state_machine_name")

    @property
    @pulumi.getter(name="executionNamePrefix")
    def execution_name_prefix(self) -> Optional[str]:
        return pulumi.get(self, "execution_name_prefix")


@pulumi.output_type
class TopicRuleTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        TopicRuleTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class TopicRuleTimestamp(dict):
    def __init__(__self__, *,
                 value: str,
                 unit: Optional[str] = None):
        TopicRuleTimestamp._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            value=value,
            unit=unit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             value: str,
             unit: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("value", value)
        if unit is not None:
            _setter("unit", unit)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def unit(self) -> Optional[str]:
        return pulumi.get(self, "unit")


@pulumi.output_type
class TopicRuleTimestreamAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "tableName":
            suggest = "table_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TopicRuleTimestreamAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TopicRuleTimestreamAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TopicRuleTimestreamAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: str,
                 dimensions: Sequence['outputs.TopicRuleTimestreamDimension'],
                 role_arn: str,
                 table_name: str,
                 timestamp: Optional['outputs.TopicRuleTimestreamTimestamp'] = None):
        TopicRuleTimestreamAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_name=database_name,
            dimensions=dimensions,
            role_arn=role_arn,
            table_name=table_name,
            timestamp=timestamp,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_name: str,
             dimensions: Sequence['outputs.TopicRuleTimestreamDimension'],
             role_arn: str,
             table_name: str,
             timestamp: Optional['outputs.TopicRuleTimestreamTimestamp'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("database_name", database_name)
        _setter("dimensions", dimensions)
        _setter("role_arn", role_arn)
        _setter("table_name", table_name)
        if timestamp is not None:
            _setter("timestamp", timestamp)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def dimensions(self) -> Sequence['outputs.TopicRuleTimestreamDimension']:
        return pulumi.get(self, "dimensions")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> str:
        return pulumi.get(self, "table_name")

    @property
    @pulumi.getter
    def timestamp(self) -> Optional['outputs.TopicRuleTimestreamTimestamp']:
        return pulumi.get(self, "timestamp")


@pulumi.output_type
class TopicRuleTimestreamDimension(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        TopicRuleTimestreamDimension._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class TopicRuleTimestreamTimestamp(dict):
    def __init__(__self__, *,
                 unit: str,
                 value: str):
        TopicRuleTimestreamTimestamp._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            unit=unit,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             unit: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("unit", unit)
        _setter("value", value)

    @property
    @pulumi.getter
    def unit(self) -> str:
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class TopicRuleUserProperty(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        TopicRuleUserProperty._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


