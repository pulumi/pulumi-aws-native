# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'AbortConfigPropertiesArgs',
    'AbortConfigPropertiesArgsDict',
    'AccountAuditConfigurationAuditCheckConfigurationsArgs',
    'AccountAuditConfigurationAuditCheckConfigurationsArgsDict',
    'AccountAuditConfigurationAuditCheckConfigurationArgs',
    'AccountAuditConfigurationAuditCheckConfigurationArgsDict',
    'AccountAuditConfigurationAuditNotificationTargetConfigurationsArgs',
    'AccountAuditConfigurationAuditNotificationTargetConfigurationsArgsDict',
    'AccountAuditConfigurationAuditNotificationTargetArgs',
    'AccountAuditConfigurationAuditNotificationTargetArgsDict',
    'BillingGroupPropertiesPropertiesArgs',
    'BillingGroupPropertiesPropertiesArgsDict',
    'CaCertificateRegistrationConfigArgs',
    'CaCertificateRegistrationConfigArgsDict',
    'CommandParameterValueArgs',
    'CommandParameterValueArgsDict',
    'CommandParameterArgs',
    'CommandParameterArgsDict',
    'CommandPayloadArgs',
    'CommandPayloadArgsDict',
    'DomainConfigurationAuthorizerConfigArgs',
    'DomainConfigurationAuthorizerConfigArgsDict',
    'DomainConfigurationClientCertificateConfigArgs',
    'DomainConfigurationClientCertificateConfigArgsDict',
    'DomainConfigurationServerCertificateConfigArgs',
    'DomainConfigurationServerCertificateConfigArgsDict',
    'DomainConfigurationTlsConfigArgs',
    'DomainConfigurationTlsConfigArgsDict',
    'FleetMetricAggregationTypeArgs',
    'FleetMetricAggregationTypeArgsDict',
    'JobExecutionsRetryConfigPropertiesArgs',
    'JobExecutionsRetryConfigPropertiesArgsDict',
    'JobExecutionsRolloutConfigPropertiesArgs',
    'JobExecutionsRolloutConfigPropertiesArgsDict',
    'JobTemplateAbortCriteriaArgs',
    'JobTemplateAbortCriteriaArgsDict',
    'JobTemplateExponentialRolloutRateArgs',
    'JobTemplateExponentialRolloutRateArgsDict',
    'JobTemplateMaintenanceWindowArgs',
    'JobTemplateMaintenanceWindowArgsDict',
    'JobTemplateRateIncreaseCriteriaArgs',
    'JobTemplateRateIncreaseCriteriaArgsDict',
    'JobTemplateRetryCriteriaArgs',
    'JobTemplateRetryCriteriaArgsDict',
    'MetricsExportConfigPropertiesArgs',
    'MetricsExportConfigPropertiesArgsDict',
    'MitigationActionActionParamsArgs',
    'MitigationActionActionParamsArgsDict',
    'MitigationActionAddThingsToThingGroupParamsArgs',
    'MitigationActionAddThingsToThingGroupParamsArgsDict',
    'MitigationActionEnableIoTLoggingParamsArgs',
    'MitigationActionEnableIoTLoggingParamsArgsDict',
    'MitigationActionPublishFindingToSnsParamsArgs',
    'MitigationActionPublishFindingToSnsParamsArgsDict',
    'MitigationActionReplaceDefaultPolicyVersionParamsArgs',
    'MitigationActionReplaceDefaultPolicyVersionParamsArgsDict',
    'MitigationActionUpdateCaCertificateParamsArgs',
    'MitigationActionUpdateCaCertificateParamsArgsDict',
    'MitigationActionUpdateDeviceCertificateParamsArgs',
    'MitigationActionUpdateDeviceCertificateParamsArgsDict',
    'PresignedUrlConfigPropertiesArgs',
    'PresignedUrlConfigPropertiesArgsDict',
    'ProvisioningTemplateProvisioningHookArgs',
    'ProvisioningTemplateProvisioningHookArgsDict',
    'SecurityProfileAlertTargetArgs',
    'SecurityProfileAlertTargetArgsDict',
    'SecurityProfileBehaviorCriteriaArgs',
    'SecurityProfileBehaviorCriteriaArgsDict',
    'SecurityProfileBehaviorArgs',
    'SecurityProfileBehaviorArgsDict',
    'SecurityProfileMachineLearningDetectionConfigArgs',
    'SecurityProfileMachineLearningDetectionConfigArgsDict',
    'SecurityProfileMetricDimensionArgs',
    'SecurityProfileMetricDimensionArgsDict',
    'SecurityProfileMetricToRetainArgs',
    'SecurityProfileMetricToRetainArgsDict',
    'SecurityProfileMetricValueArgs',
    'SecurityProfileMetricValueArgsDict',
    'SecurityProfileStatisticalThresholdArgs',
    'SecurityProfileStatisticalThresholdArgsDict',
    'ThingAttributePayloadArgs',
    'ThingAttributePayloadArgsDict',
    'ThingGroupAttributePayloadArgs',
    'ThingGroupAttributePayloadArgsDict',
    'ThingGroupPropertiesPropertiesArgs',
    'ThingGroupPropertiesPropertiesArgsDict',
    'ThingTypePropagatingAttributeArgs',
    'ThingTypePropagatingAttributeArgsDict',
    'ThingTypePropertiesPropertiesMqtt5ConfigurationPropertiesArgs',
    'ThingTypePropertiesPropertiesMqtt5ConfigurationPropertiesArgsDict',
    'ThingTypePropertiesPropertiesArgs',
    'ThingTypePropertiesPropertiesArgsDict',
    'TimeoutConfigPropertiesArgs',
    'TimeoutConfigPropertiesArgsDict',
    'TopicRuleActionArgs',
    'TopicRuleActionArgsDict',
    'TopicRuleAssetPropertyTimestampArgs',
    'TopicRuleAssetPropertyTimestampArgsDict',
    'TopicRuleAssetPropertyValueArgs',
    'TopicRuleAssetPropertyValueArgsDict',
    'TopicRuleAssetPropertyVariantArgs',
    'TopicRuleAssetPropertyVariantArgsDict',
    'TopicRuleCloudwatchAlarmActionArgs',
    'TopicRuleCloudwatchAlarmActionArgsDict',
    'TopicRuleCloudwatchLogsActionArgs',
    'TopicRuleCloudwatchLogsActionArgsDict',
    'TopicRuleCloudwatchMetricActionArgs',
    'TopicRuleCloudwatchMetricActionArgsDict',
    'TopicRuleDestinationHttpUrlDestinationSummaryArgs',
    'TopicRuleDestinationHttpUrlDestinationSummaryArgsDict',
    'TopicRuleDestinationVpcDestinationPropertiesArgs',
    'TopicRuleDestinationVpcDestinationPropertiesArgsDict',
    'TopicRuleDynamoDBv2ActionArgs',
    'TopicRuleDynamoDBv2ActionArgsDict',
    'TopicRuleDynamoDbActionArgs',
    'TopicRuleDynamoDbActionArgsDict',
    'TopicRuleElasticsearchActionArgs',
    'TopicRuleElasticsearchActionArgsDict',
    'TopicRuleFirehoseActionArgs',
    'TopicRuleFirehoseActionArgsDict',
    'TopicRuleHttpActionHeaderArgs',
    'TopicRuleHttpActionHeaderArgsDict',
    'TopicRuleHttpActionArgs',
    'TopicRuleHttpActionArgsDict',
    'TopicRuleHttpAuthorizationArgs',
    'TopicRuleHttpAuthorizationArgsDict',
    'TopicRuleIotAnalyticsActionArgs',
    'TopicRuleIotAnalyticsActionArgsDict',
    'TopicRuleIotEventsActionArgs',
    'TopicRuleIotEventsActionArgsDict',
    'TopicRuleIotSiteWiseActionArgs',
    'TopicRuleIotSiteWiseActionArgsDict',
    'TopicRuleKafkaActionHeaderArgs',
    'TopicRuleKafkaActionHeaderArgsDict',
    'TopicRuleKafkaActionArgs',
    'TopicRuleKafkaActionArgsDict',
    'TopicRuleKinesisActionArgs',
    'TopicRuleKinesisActionArgsDict',
    'TopicRuleLambdaActionArgs',
    'TopicRuleLambdaActionArgsDict',
    'TopicRuleLocationActionArgs',
    'TopicRuleLocationActionArgsDict',
    'TopicRuleOpenSearchActionArgs',
    'TopicRuleOpenSearchActionArgsDict',
    'TopicRulePayloadArgs',
    'TopicRulePayloadArgsDict',
    'TopicRulePutAssetPropertyValueEntryArgs',
    'TopicRulePutAssetPropertyValueEntryArgsDict',
    'TopicRulePutItemInputArgs',
    'TopicRulePutItemInputArgsDict',
    'TopicRuleRepublishActionHeadersArgs',
    'TopicRuleRepublishActionHeadersArgsDict',
    'TopicRuleRepublishActionArgs',
    'TopicRuleRepublishActionArgsDict',
    'TopicRuleS3ActionArgs',
    'TopicRuleS3ActionArgsDict',
    'TopicRuleSigV4AuthorizationArgs',
    'TopicRuleSigV4AuthorizationArgsDict',
    'TopicRuleSnsActionArgs',
    'TopicRuleSnsActionArgsDict',
    'TopicRuleSqsActionArgs',
    'TopicRuleSqsActionArgsDict',
    'TopicRuleStepFunctionsActionArgs',
    'TopicRuleStepFunctionsActionArgsDict',
    'TopicRuleTimestampArgs',
    'TopicRuleTimestampArgsDict',
    'TopicRuleTimestreamActionArgs',
    'TopicRuleTimestreamActionArgsDict',
    'TopicRuleTimestreamDimensionArgs',
    'TopicRuleTimestreamDimensionArgsDict',
    'TopicRuleTimestreamTimestampArgs',
    'TopicRuleTimestreamTimestampArgsDict',
    'TopicRuleUserPropertyArgs',
    'TopicRuleUserPropertyArgsDict',
]

MYPY = False

if not MYPY:
    class AbortConfigPropertiesArgsDict(TypedDict):
        """
        The criteria that determine when and how a job abort takes place.
        """
        criteria_list: pulumi.Input[Sequence[pulumi.Input['JobTemplateAbortCriteriaArgsDict']]]
        """
        The list of criteria that determine when and how to abort the job.
        """
elif False:
    AbortConfigPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AbortConfigPropertiesArgs:
    def __init__(__self__, *,
                 criteria_list: pulumi.Input[Sequence[pulumi.Input['JobTemplateAbortCriteriaArgs']]]):
        """
        The criteria that determine when and how a job abort takes place.
        :param pulumi.Input[Sequence[pulumi.Input['JobTemplateAbortCriteriaArgs']]] criteria_list: The list of criteria that determine when and how to abort the job.
        """
        pulumi.set(__self__, "criteria_list", criteria_list)

    @property
    @pulumi.getter(name="criteriaList")
    def criteria_list(self) -> pulumi.Input[Sequence[pulumi.Input['JobTemplateAbortCriteriaArgs']]]:
        """
        The list of criteria that determine when and how to abort the job.
        """
        return pulumi.get(self, "criteria_list")

    @criteria_list.setter
    def criteria_list(self, value: pulumi.Input[Sequence[pulumi.Input['JobTemplateAbortCriteriaArgs']]]):
        pulumi.set(self, "criteria_list", value)


if not MYPY:
    class AccountAuditConfigurationAuditCheckConfigurationsArgsDict(TypedDict):
        """
        Specifies which audit checks are enabled and disabled for this account.
        """
        authenticated_cognito_role_overly_permissive_check: NotRequired[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgsDict']]
        """
        Checks the permissiveness of an authenticated Amazon Cognito identity pool role. For this check, AWS IoT Device Defender audits all Amazon Cognito identity pools that have been used to connect to the AWS IoT message broker during the 31 days before the audit is performed.
        """
        ca_certificate_expiring_check: NotRequired[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgsDict']]
        """
        Checks if a CA certificate is expiring. This check applies to CA certificates expiring within 30 days or that have expired.
        """
        ca_certificate_key_quality_check: NotRequired[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgsDict']]
        """
        Checks the quality of the CA certificate key. The quality checks if the key is in a valid format, not expired, and if the key meets a minimum required size. This check applies to CA certificates that are `ACTIVE` or `PENDING_TRANSFER` .
        """
        conflicting_client_ids_check: NotRequired[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgsDict']]
        """
        Checks if multiple devices connect using the same client ID.
        """
        device_certificate_expiring_check: NotRequired[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgsDict']]
        """
        Checks if a device certificate is expiring. This check applies to device certificates expiring within 30 days or that have expired.
        """
        device_certificate_key_quality_check: NotRequired[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgsDict']]
        """
        Checks the quality of the device certificate key. The quality checks if the key is in a valid format, not expired, signed by a registered certificate authority, and if the key meets a minimum required size.
        """
        device_certificate_shared_check: NotRequired[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgsDict']]
        """
        Checks if multiple concurrent connections use the same X.509 certificate to authenticate with AWS IoT .
        """
        intermediate_ca_revoked_for_active_device_certificates_check: NotRequired[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgsDict']]
        """
        Checks if device certificates are still active despite being revoked by an intermediate CA.
        """
        io_t_policy_potential_mis_configuration_check: NotRequired[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgsDict']]
        """
        Checks if an AWS IoT policy is potentially misconfigured. Misconfigured policies, including overly permissive policies, can cause security incidents like allowing devices access to unintended resources. This check is a warning for you to make sure that only intended actions are allowed before updating the policy.
        """
        iot_policy_overly_permissive_check: NotRequired[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgsDict']]
        """
        Checks the permissiveness of a policy attached to an authenticated Amazon Cognito identity pool role.
        """
        iot_role_alias_allows_access_to_unused_services_check: NotRequired[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgsDict']]
        """
        Checks if a role alias has access to services that haven't been used for the AWS IoT device in the last year.
        """
        iot_role_alias_overly_permissive_check: NotRequired[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgsDict']]
        """
        Checks if the temporary credentials provided by AWS IoT role aliases are overly permissive.
        """
        logging_disabled_check: NotRequired[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgsDict']]
        """
        Checks if AWS IoT logs are disabled.
        """
        revoked_ca_certificate_still_active_check: NotRequired[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgsDict']]
        """
        Checks if a revoked CA certificate is still active.
        """
        revoked_device_certificate_still_active_check: NotRequired[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgsDict']]
        """
        Checks if a revoked device certificate is still active.
        """
        unauthenticated_cognito_role_overly_permissive_check: NotRequired[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgsDict']]
        """
        Checks if policy attached to an unauthenticated Amazon Cognito identity pool role is too permissive.
        """
elif False:
    AccountAuditConfigurationAuditCheckConfigurationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountAuditConfigurationAuditCheckConfigurationsArgs:
    def __init__(__self__, *,
                 authenticated_cognito_role_overly_permissive_check: Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']] = None,
                 ca_certificate_expiring_check: Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']] = None,
                 ca_certificate_key_quality_check: Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']] = None,
                 conflicting_client_ids_check: Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']] = None,
                 device_certificate_expiring_check: Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']] = None,
                 device_certificate_key_quality_check: Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']] = None,
                 device_certificate_shared_check: Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']] = None,
                 intermediate_ca_revoked_for_active_device_certificates_check: Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']] = None,
                 io_t_policy_potential_mis_configuration_check: Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']] = None,
                 iot_policy_overly_permissive_check: Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']] = None,
                 iot_role_alias_allows_access_to_unused_services_check: Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']] = None,
                 iot_role_alias_overly_permissive_check: Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']] = None,
                 logging_disabled_check: Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']] = None,
                 revoked_ca_certificate_still_active_check: Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']] = None,
                 revoked_device_certificate_still_active_check: Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']] = None,
                 unauthenticated_cognito_role_overly_permissive_check: Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']] = None):
        """
        Specifies which audit checks are enabled and disabled for this account.
        :param pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs'] authenticated_cognito_role_overly_permissive_check: Checks the permissiveness of an authenticated Amazon Cognito identity pool role. For this check, AWS IoT Device Defender audits all Amazon Cognito identity pools that have been used to connect to the AWS IoT message broker during the 31 days before the audit is performed.
        :param pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs'] ca_certificate_expiring_check: Checks if a CA certificate is expiring. This check applies to CA certificates expiring within 30 days or that have expired.
        :param pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs'] ca_certificate_key_quality_check: Checks the quality of the CA certificate key. The quality checks if the key is in a valid format, not expired, and if the key meets a minimum required size. This check applies to CA certificates that are `ACTIVE` or `PENDING_TRANSFER` .
        :param pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs'] conflicting_client_ids_check: Checks if multiple devices connect using the same client ID.
        :param pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs'] device_certificate_expiring_check: Checks if a device certificate is expiring. This check applies to device certificates expiring within 30 days or that have expired.
        :param pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs'] device_certificate_key_quality_check: Checks the quality of the device certificate key. The quality checks if the key is in a valid format, not expired, signed by a registered certificate authority, and if the key meets a minimum required size.
        :param pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs'] device_certificate_shared_check: Checks if multiple concurrent connections use the same X.509 certificate to authenticate with AWS IoT .
        :param pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs'] intermediate_ca_revoked_for_active_device_certificates_check: Checks if device certificates are still active despite being revoked by an intermediate CA.
        :param pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs'] io_t_policy_potential_mis_configuration_check: Checks if an AWS IoT policy is potentially misconfigured. Misconfigured policies, including overly permissive policies, can cause security incidents like allowing devices access to unintended resources. This check is a warning for you to make sure that only intended actions are allowed before updating the policy.
        :param pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs'] iot_policy_overly_permissive_check: Checks the permissiveness of a policy attached to an authenticated Amazon Cognito identity pool role.
        :param pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs'] iot_role_alias_allows_access_to_unused_services_check: Checks if a role alias has access to services that haven't been used for the AWS IoT device in the last year.
        :param pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs'] iot_role_alias_overly_permissive_check: Checks if the temporary credentials provided by AWS IoT role aliases are overly permissive.
        :param pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs'] logging_disabled_check: Checks if AWS IoT logs are disabled.
        :param pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs'] revoked_ca_certificate_still_active_check: Checks if a revoked CA certificate is still active.
        :param pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs'] revoked_device_certificate_still_active_check: Checks if a revoked device certificate is still active.
        :param pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs'] unauthenticated_cognito_role_overly_permissive_check: Checks if policy attached to an unauthenticated Amazon Cognito identity pool role is too permissive.
        """
        if authenticated_cognito_role_overly_permissive_check is not None:
            pulumi.set(__self__, "authenticated_cognito_role_overly_permissive_check", authenticated_cognito_role_overly_permissive_check)
        if ca_certificate_expiring_check is not None:
            pulumi.set(__self__, "ca_certificate_expiring_check", ca_certificate_expiring_check)
        if ca_certificate_key_quality_check is not None:
            pulumi.set(__self__, "ca_certificate_key_quality_check", ca_certificate_key_quality_check)
        if conflicting_client_ids_check is not None:
            pulumi.set(__self__, "conflicting_client_ids_check", conflicting_client_ids_check)
        if device_certificate_expiring_check is not None:
            pulumi.set(__self__, "device_certificate_expiring_check", device_certificate_expiring_check)
        if device_certificate_key_quality_check is not None:
            pulumi.set(__self__, "device_certificate_key_quality_check", device_certificate_key_quality_check)
        if device_certificate_shared_check is not None:
            pulumi.set(__self__, "device_certificate_shared_check", device_certificate_shared_check)
        if intermediate_ca_revoked_for_active_device_certificates_check is not None:
            pulumi.set(__self__, "intermediate_ca_revoked_for_active_device_certificates_check", intermediate_ca_revoked_for_active_device_certificates_check)
        if io_t_policy_potential_mis_configuration_check is not None:
            pulumi.set(__self__, "io_t_policy_potential_mis_configuration_check", io_t_policy_potential_mis_configuration_check)
        if iot_policy_overly_permissive_check is not None:
            pulumi.set(__self__, "iot_policy_overly_permissive_check", iot_policy_overly_permissive_check)
        if iot_role_alias_allows_access_to_unused_services_check is not None:
            pulumi.set(__self__, "iot_role_alias_allows_access_to_unused_services_check", iot_role_alias_allows_access_to_unused_services_check)
        if iot_role_alias_overly_permissive_check is not None:
            pulumi.set(__self__, "iot_role_alias_overly_permissive_check", iot_role_alias_overly_permissive_check)
        if logging_disabled_check is not None:
            pulumi.set(__self__, "logging_disabled_check", logging_disabled_check)
        if revoked_ca_certificate_still_active_check is not None:
            pulumi.set(__self__, "revoked_ca_certificate_still_active_check", revoked_ca_certificate_still_active_check)
        if revoked_device_certificate_still_active_check is not None:
            pulumi.set(__self__, "revoked_device_certificate_still_active_check", revoked_device_certificate_still_active_check)
        if unauthenticated_cognito_role_overly_permissive_check is not None:
            pulumi.set(__self__, "unauthenticated_cognito_role_overly_permissive_check", unauthenticated_cognito_role_overly_permissive_check)

    @property
    @pulumi.getter(name="authenticatedCognitoRoleOverlyPermissiveCheck")
    def authenticated_cognito_role_overly_permissive_check(self) -> Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']]:
        """
        Checks the permissiveness of an authenticated Amazon Cognito identity pool role. For this check, AWS IoT Device Defender audits all Amazon Cognito identity pools that have been used to connect to the AWS IoT message broker during the 31 days before the audit is performed.
        """
        return pulumi.get(self, "authenticated_cognito_role_overly_permissive_check")

    @authenticated_cognito_role_overly_permissive_check.setter
    def authenticated_cognito_role_overly_permissive_check(self, value: Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']]):
        pulumi.set(self, "authenticated_cognito_role_overly_permissive_check", value)

    @property
    @pulumi.getter(name="caCertificateExpiringCheck")
    def ca_certificate_expiring_check(self) -> Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']]:
        """
        Checks if a CA certificate is expiring. This check applies to CA certificates expiring within 30 days or that have expired.
        """
        return pulumi.get(self, "ca_certificate_expiring_check")

    @ca_certificate_expiring_check.setter
    def ca_certificate_expiring_check(self, value: Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']]):
        pulumi.set(self, "ca_certificate_expiring_check", value)

    @property
    @pulumi.getter(name="caCertificateKeyQualityCheck")
    def ca_certificate_key_quality_check(self) -> Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']]:
        """
        Checks the quality of the CA certificate key. The quality checks if the key is in a valid format, not expired, and if the key meets a minimum required size. This check applies to CA certificates that are `ACTIVE` or `PENDING_TRANSFER` .
        """
        return pulumi.get(self, "ca_certificate_key_quality_check")

    @ca_certificate_key_quality_check.setter
    def ca_certificate_key_quality_check(self, value: Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']]):
        pulumi.set(self, "ca_certificate_key_quality_check", value)

    @property
    @pulumi.getter(name="conflictingClientIdsCheck")
    def conflicting_client_ids_check(self) -> Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']]:
        """
        Checks if multiple devices connect using the same client ID.
        """
        return pulumi.get(self, "conflicting_client_ids_check")

    @conflicting_client_ids_check.setter
    def conflicting_client_ids_check(self, value: Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']]):
        pulumi.set(self, "conflicting_client_ids_check", value)

    @property
    @pulumi.getter(name="deviceCertificateExpiringCheck")
    def device_certificate_expiring_check(self) -> Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']]:
        """
        Checks if a device certificate is expiring. This check applies to device certificates expiring within 30 days or that have expired.
        """
        return pulumi.get(self, "device_certificate_expiring_check")

    @device_certificate_expiring_check.setter
    def device_certificate_expiring_check(self, value: Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']]):
        pulumi.set(self, "device_certificate_expiring_check", value)

    @property
    @pulumi.getter(name="deviceCertificateKeyQualityCheck")
    def device_certificate_key_quality_check(self) -> Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']]:
        """
        Checks the quality of the device certificate key. The quality checks if the key is in a valid format, not expired, signed by a registered certificate authority, and if the key meets a minimum required size.
        """
        return pulumi.get(self, "device_certificate_key_quality_check")

    @device_certificate_key_quality_check.setter
    def device_certificate_key_quality_check(self, value: Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']]):
        pulumi.set(self, "device_certificate_key_quality_check", value)

    @property
    @pulumi.getter(name="deviceCertificateSharedCheck")
    def device_certificate_shared_check(self) -> Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']]:
        """
        Checks if multiple concurrent connections use the same X.509 certificate to authenticate with AWS IoT .
        """
        return pulumi.get(self, "device_certificate_shared_check")

    @device_certificate_shared_check.setter
    def device_certificate_shared_check(self, value: Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']]):
        pulumi.set(self, "device_certificate_shared_check", value)

    @property
    @pulumi.getter(name="intermediateCaRevokedForActiveDeviceCertificatesCheck")
    def intermediate_ca_revoked_for_active_device_certificates_check(self) -> Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']]:
        """
        Checks if device certificates are still active despite being revoked by an intermediate CA.
        """
        return pulumi.get(self, "intermediate_ca_revoked_for_active_device_certificates_check")

    @intermediate_ca_revoked_for_active_device_certificates_check.setter
    def intermediate_ca_revoked_for_active_device_certificates_check(self, value: Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']]):
        pulumi.set(self, "intermediate_ca_revoked_for_active_device_certificates_check", value)

    @property
    @pulumi.getter(name="ioTPolicyPotentialMisConfigurationCheck")
    def io_t_policy_potential_mis_configuration_check(self) -> Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']]:
        """
        Checks if an AWS IoT policy is potentially misconfigured. Misconfigured policies, including overly permissive policies, can cause security incidents like allowing devices access to unintended resources. This check is a warning for you to make sure that only intended actions are allowed before updating the policy.
        """
        return pulumi.get(self, "io_t_policy_potential_mis_configuration_check")

    @io_t_policy_potential_mis_configuration_check.setter
    def io_t_policy_potential_mis_configuration_check(self, value: Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']]):
        pulumi.set(self, "io_t_policy_potential_mis_configuration_check", value)

    @property
    @pulumi.getter(name="iotPolicyOverlyPermissiveCheck")
    def iot_policy_overly_permissive_check(self) -> Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']]:
        """
        Checks the permissiveness of a policy attached to an authenticated Amazon Cognito identity pool role.
        """
        return pulumi.get(self, "iot_policy_overly_permissive_check")

    @iot_policy_overly_permissive_check.setter
    def iot_policy_overly_permissive_check(self, value: Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']]):
        pulumi.set(self, "iot_policy_overly_permissive_check", value)

    @property
    @pulumi.getter(name="iotRoleAliasAllowsAccessToUnusedServicesCheck")
    def iot_role_alias_allows_access_to_unused_services_check(self) -> Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']]:
        """
        Checks if a role alias has access to services that haven't been used for the AWS IoT device in the last year.
        """
        return pulumi.get(self, "iot_role_alias_allows_access_to_unused_services_check")

    @iot_role_alias_allows_access_to_unused_services_check.setter
    def iot_role_alias_allows_access_to_unused_services_check(self, value: Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']]):
        pulumi.set(self, "iot_role_alias_allows_access_to_unused_services_check", value)

    @property
    @pulumi.getter(name="iotRoleAliasOverlyPermissiveCheck")
    def iot_role_alias_overly_permissive_check(self) -> Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']]:
        """
        Checks if the temporary credentials provided by AWS IoT role aliases are overly permissive.
        """
        return pulumi.get(self, "iot_role_alias_overly_permissive_check")

    @iot_role_alias_overly_permissive_check.setter
    def iot_role_alias_overly_permissive_check(self, value: Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']]):
        pulumi.set(self, "iot_role_alias_overly_permissive_check", value)

    @property
    @pulumi.getter(name="loggingDisabledCheck")
    def logging_disabled_check(self) -> Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']]:
        """
        Checks if AWS IoT logs are disabled.
        """
        return pulumi.get(self, "logging_disabled_check")

    @logging_disabled_check.setter
    def logging_disabled_check(self, value: Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']]):
        pulumi.set(self, "logging_disabled_check", value)

    @property
    @pulumi.getter(name="revokedCaCertificateStillActiveCheck")
    def revoked_ca_certificate_still_active_check(self) -> Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']]:
        """
        Checks if a revoked CA certificate is still active.
        """
        return pulumi.get(self, "revoked_ca_certificate_still_active_check")

    @revoked_ca_certificate_still_active_check.setter
    def revoked_ca_certificate_still_active_check(self, value: Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']]):
        pulumi.set(self, "revoked_ca_certificate_still_active_check", value)

    @property
    @pulumi.getter(name="revokedDeviceCertificateStillActiveCheck")
    def revoked_device_certificate_still_active_check(self) -> Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']]:
        """
        Checks if a revoked device certificate is still active.
        """
        return pulumi.get(self, "revoked_device_certificate_still_active_check")

    @revoked_device_certificate_still_active_check.setter
    def revoked_device_certificate_still_active_check(self, value: Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']]):
        pulumi.set(self, "revoked_device_certificate_still_active_check", value)

    @property
    @pulumi.getter(name="unauthenticatedCognitoRoleOverlyPermissiveCheck")
    def unauthenticated_cognito_role_overly_permissive_check(self) -> Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']]:
        """
        Checks if policy attached to an unauthenticated Amazon Cognito identity pool role is too permissive.
        """
        return pulumi.get(self, "unauthenticated_cognito_role_overly_permissive_check")

    @unauthenticated_cognito_role_overly_permissive_check.setter
    def unauthenticated_cognito_role_overly_permissive_check(self, value: Optional[pulumi.Input['AccountAuditConfigurationAuditCheckConfigurationArgs']]):
        pulumi.set(self, "unauthenticated_cognito_role_overly_permissive_check", value)


if not MYPY:
    class AccountAuditConfigurationAuditCheckConfigurationArgsDict(TypedDict):
        """
        The configuration for a specific audit check.
        """
        enabled: NotRequired[pulumi.Input[bool]]
        """
        True if the check is enabled.
        """
elif False:
    AccountAuditConfigurationAuditCheckConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountAuditConfigurationAuditCheckConfigurationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        The configuration for a specific audit check.
        :param pulumi.Input[bool] enabled: True if the check is enabled.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        True if the check is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class AccountAuditConfigurationAuditNotificationTargetConfigurationsArgsDict(TypedDict):
        """
        Information about the targets to which audit notifications are sent.
        """
        sns: NotRequired[pulumi.Input['AccountAuditConfigurationAuditNotificationTargetArgsDict']]
        """
        The `Sns` notification target.
        """
elif False:
    AccountAuditConfigurationAuditNotificationTargetConfigurationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountAuditConfigurationAuditNotificationTargetConfigurationsArgs:
    def __init__(__self__, *,
                 sns: Optional[pulumi.Input['AccountAuditConfigurationAuditNotificationTargetArgs']] = None):
        """
        Information about the targets to which audit notifications are sent.
        :param pulumi.Input['AccountAuditConfigurationAuditNotificationTargetArgs'] sns: The `Sns` notification target.
        """
        if sns is not None:
            pulumi.set(__self__, "sns", sns)

    @property
    @pulumi.getter
    def sns(self) -> Optional[pulumi.Input['AccountAuditConfigurationAuditNotificationTargetArgs']]:
        """
        The `Sns` notification target.
        """
        return pulumi.get(self, "sns")

    @sns.setter
    def sns(self, value: Optional[pulumi.Input['AccountAuditConfigurationAuditNotificationTargetArgs']]):
        pulumi.set(self, "sns", value)


if not MYPY:
    class AccountAuditConfigurationAuditNotificationTargetArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        True if notifications to the target are enabled.
        """
        role_arn: NotRequired[pulumi.Input[str]]
        """
        The ARN of the role that grants permission to send notifications to the target.
        """
        target_arn: NotRequired[pulumi.Input[str]]
        """
        The ARN of the target (SNS topic) to which audit notifications are sent.
        """
elif False:
    AccountAuditConfigurationAuditNotificationTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountAuditConfigurationAuditNotificationTargetArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 role_arn: Optional[pulumi.Input[str]] = None,
                 target_arn: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: True if notifications to the target are enabled.
        :param pulumi.Input[str] role_arn: The ARN of the role that grants permission to send notifications to the target.
        :param pulumi.Input[str] target_arn: The ARN of the target (SNS topic) to which audit notifications are sent.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if target_arn is not None:
            pulumi.set(__self__, "target_arn", target_arn)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        True if notifications to the target are enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The ARN of the role that grants permission to send notifications to the target.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="targetArn")
    def target_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The ARN of the target (SNS topic) to which audit notifications are sent.
        """
        return pulumi.get(self, "target_arn")

    @target_arn.setter
    def target_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_arn", value)


if not MYPY:
    class BillingGroupPropertiesPropertiesArgsDict(TypedDict):
        """
        The properties of the billing group.
        """
        billing_group_description: NotRequired[pulumi.Input[str]]
        """
        The description of the billing group.
        """
elif False:
    BillingGroupPropertiesPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BillingGroupPropertiesPropertiesArgs:
    def __init__(__self__, *,
                 billing_group_description: Optional[pulumi.Input[str]] = None):
        """
        The properties of the billing group.
        :param pulumi.Input[str] billing_group_description: The description of the billing group.
        """
        if billing_group_description is not None:
            pulumi.set(__self__, "billing_group_description", billing_group_description)

    @property
    @pulumi.getter(name="billingGroupDescription")
    def billing_group_description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the billing group.
        """
        return pulumi.get(self, "billing_group_description")

    @billing_group_description.setter
    def billing_group_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "billing_group_description", value)


if not MYPY:
    class CaCertificateRegistrationConfigArgsDict(TypedDict):
        role_arn: NotRequired[pulumi.Input[str]]
        """
        The ARN of the role.
        """
        template_body: NotRequired[pulumi.Input[str]]
        """
        The template body.
        """
        template_name: NotRequired[pulumi.Input[str]]
        """
        The name of the provisioning template.
        """
elif False:
    CaCertificateRegistrationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CaCertificateRegistrationConfigArgs:
    def __init__(__self__, *,
                 role_arn: Optional[pulumi.Input[str]] = None,
                 template_body: Optional[pulumi.Input[str]] = None,
                 template_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] role_arn: The ARN of the role.
        :param pulumi.Input[str] template_body: The template body.
        :param pulumi.Input[str] template_name: The name of the provisioning template.
        """
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if template_body is not None:
            pulumi.set(__self__, "template_body", template_body)
        if template_name is not None:
            pulumi.set(__self__, "template_name", template_name)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The ARN of the role.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="templateBody")
    def template_body(self) -> Optional[pulumi.Input[str]]:
        """
        The template body.
        """
        return pulumi.get(self, "template_body")

    @template_body.setter
    def template_body(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "template_body", value)

    @property
    @pulumi.getter(name="templateName")
    def template_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the provisioning template.
        """
        return pulumi.get(self, "template_name")

    @template_name.setter
    def template_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "template_name", value)


if not MYPY:
    class CommandParameterValueArgsDict(TypedDict):
        b: NotRequired[pulumi.Input[bool]]
        bin: NotRequired[pulumi.Input[str]]
        d: NotRequired[pulumi.Input[float]]
        i: NotRequired[pulumi.Input[int]]
        l: NotRequired[pulumi.Input[str]]
        s: NotRequired[pulumi.Input[str]]
        ul: NotRequired[pulumi.Input[str]]
elif False:
    CommandParameterValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CommandParameterValueArgs:
    def __init__(__self__, *,
                 b: Optional[pulumi.Input[bool]] = None,
                 bin: Optional[pulumi.Input[str]] = None,
                 d: Optional[pulumi.Input[float]] = None,
                 i: Optional[pulumi.Input[int]] = None,
                 l: Optional[pulumi.Input[str]] = None,
                 s: Optional[pulumi.Input[str]] = None,
                 ul: Optional[pulumi.Input[str]] = None):
        if b is not None:
            pulumi.set(__self__, "b", b)
        if bin is not None:
            pulumi.set(__self__, "bin", bin)
        if d is not None:
            pulumi.set(__self__, "d", d)
        if i is not None:
            pulumi.set(__self__, "i", i)
        if l is not None:
            pulumi.set(__self__, "l", l)
        if s is not None:
            pulumi.set(__self__, "s", s)
        if ul is not None:
            pulumi.set(__self__, "ul", ul)

    @property
    @pulumi.getter
    def b(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "b")

    @b.setter
    def b(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "b", value)

    @property
    @pulumi.getter
    def bin(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "bin")

    @bin.setter
    def bin(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bin", value)

    @property
    @pulumi.getter
    def d(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "d")

    @d.setter
    def d(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "d", value)

    @property
    @pulumi.getter
    def i(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "i")

    @i.setter
    def i(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "i", value)

    @property
    @pulumi.getter
    def l(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "l")

    @l.setter
    def l(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "l", value)

    @property
    @pulumi.getter
    def s(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "s")

    @s.setter
    def s(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "s", value)

    @property
    @pulumi.getter
    def ul(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ul")

    @ul.setter
    def ul(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ul", value)


if not MYPY:
    class CommandParameterArgsDict(TypedDict):
        name: pulumi.Input[str]
        default_value: NotRequired[pulumi.Input['CommandParameterValueArgsDict']]
        description: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input['CommandParameterValueArgsDict']]
elif False:
    CommandParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CommandParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 default_value: Optional[pulumi.Input['CommandParameterValueArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input['CommandParameterValueArgs']] = None):
        pulumi.set(__self__, "name", name)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[pulumi.Input['CommandParameterValueArgs']]:
        return pulumi.get(self, "default_value")

    @default_value.setter
    def default_value(self, value: Optional[pulumi.Input['CommandParameterValueArgs']]):
        pulumi.set(self, "default_value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input['CommandParameterValueArgs']]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input['CommandParameterValueArgs']]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CommandPayloadArgsDict(TypedDict):
        content: NotRequired[pulumi.Input[str]]
        content_type: NotRequired[pulumi.Input[str]]
elif False:
    CommandPayloadArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CommandPayloadArgs:
    def __init__(__self__, *,
                 content: Optional[pulumi.Input[str]] = None,
                 content_type: Optional[pulumi.Input[str]] = None):
        if content is not None:
            pulumi.set(__self__, "content", content)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)

    @property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_type", value)


if not MYPY:
    class DomainConfigurationAuthorizerConfigArgsDict(TypedDict):
        allow_authorizer_override: NotRequired[pulumi.Input[bool]]
        """
        A Boolean that specifies whether the domain configuration's authorization service can be overridden.
        """
        default_authorizer_name: NotRequired[pulumi.Input[str]]
        """
        The name of the authorization service for a domain configuration.
        """
elif False:
    DomainConfigurationAuthorizerConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainConfigurationAuthorizerConfigArgs:
    def __init__(__self__, *,
                 allow_authorizer_override: Optional[pulumi.Input[bool]] = None,
                 default_authorizer_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] allow_authorizer_override: A Boolean that specifies whether the domain configuration's authorization service can be overridden.
        :param pulumi.Input[str] default_authorizer_name: The name of the authorization service for a domain configuration.
        """
        if allow_authorizer_override is not None:
            pulumi.set(__self__, "allow_authorizer_override", allow_authorizer_override)
        if default_authorizer_name is not None:
            pulumi.set(__self__, "default_authorizer_name", default_authorizer_name)

    @property
    @pulumi.getter(name="allowAuthorizerOverride")
    def allow_authorizer_override(self) -> Optional[pulumi.Input[bool]]:
        """
        A Boolean that specifies whether the domain configuration's authorization service can be overridden.
        """
        return pulumi.get(self, "allow_authorizer_override")

    @allow_authorizer_override.setter
    def allow_authorizer_override(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_authorizer_override", value)

    @property
    @pulumi.getter(name="defaultAuthorizerName")
    def default_authorizer_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the authorization service for a domain configuration.
        """
        return pulumi.get(self, "default_authorizer_name")

    @default_authorizer_name.setter
    def default_authorizer_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_authorizer_name", value)


if not MYPY:
    class DomainConfigurationClientCertificateConfigArgsDict(TypedDict):
        client_certificate_callback_arn: NotRequired[pulumi.Input[str]]
        """
        The ARN of the Lambda function that IoT invokes after mutual TLS authentication during the connection.
        """
elif False:
    DomainConfigurationClientCertificateConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainConfigurationClientCertificateConfigArgs:
    def __init__(__self__, *,
                 client_certificate_callback_arn: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_certificate_callback_arn: The ARN of the Lambda function that IoT invokes after mutual TLS authentication during the connection.
        """
        if client_certificate_callback_arn is not None:
            pulumi.set(__self__, "client_certificate_callback_arn", client_certificate_callback_arn)

    @property
    @pulumi.getter(name="clientCertificateCallbackArn")
    def client_certificate_callback_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The ARN of the Lambda function that IoT invokes after mutual TLS authentication during the connection.
        """
        return pulumi.get(self, "client_certificate_callback_arn")

    @client_certificate_callback_arn.setter
    def client_certificate_callback_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_certificate_callback_arn", value)


if not MYPY:
    class DomainConfigurationServerCertificateConfigArgsDict(TypedDict):
        enable_ocsp_check: NotRequired[pulumi.Input[bool]]
        """
        A Boolean value that indicates whether Online Certificate Status Protocol (OCSP) server certificate check is enabled or not. For more information, see [Configurable endpoints](https://docs.aws.amazon.com//iot/latest/developerguide/iot-custom-endpoints-configurable.html) from the AWS IoT Core Developer Guide.
        """
        ocsp_authorized_responder_arn: NotRequired[pulumi.Input[str]]
        ocsp_lambda_arn: NotRequired[pulumi.Input[str]]
elif False:
    DomainConfigurationServerCertificateConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainConfigurationServerCertificateConfigArgs:
    def __init__(__self__, *,
                 enable_ocsp_check: Optional[pulumi.Input[bool]] = None,
                 ocsp_authorized_responder_arn: Optional[pulumi.Input[str]] = None,
                 ocsp_lambda_arn: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enable_ocsp_check: A Boolean value that indicates whether Online Certificate Status Protocol (OCSP) server certificate check is enabled or not. For more information, see [Configurable endpoints](https://docs.aws.amazon.com//iot/latest/developerguide/iot-custom-endpoints-configurable.html) from the AWS IoT Core Developer Guide.
        """
        if enable_ocsp_check is not None:
            pulumi.set(__self__, "enable_ocsp_check", enable_ocsp_check)
        if ocsp_authorized_responder_arn is not None:
            pulumi.set(__self__, "ocsp_authorized_responder_arn", ocsp_authorized_responder_arn)
        if ocsp_lambda_arn is not None:
            pulumi.set(__self__, "ocsp_lambda_arn", ocsp_lambda_arn)

    @property
    @pulumi.getter(name="enableOcspCheck")
    def enable_ocsp_check(self) -> Optional[pulumi.Input[bool]]:
        """
        A Boolean value that indicates whether Online Certificate Status Protocol (OCSP) server certificate check is enabled or not. For more information, see [Configurable endpoints](https://docs.aws.amazon.com//iot/latest/developerguide/iot-custom-endpoints-configurable.html) from the AWS IoT Core Developer Guide.
        """
        return pulumi.get(self, "enable_ocsp_check")

    @enable_ocsp_check.setter
    def enable_ocsp_check(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_ocsp_check", value)

    @property
    @pulumi.getter(name="ocspAuthorizedResponderArn")
    def ocsp_authorized_responder_arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ocsp_authorized_responder_arn")

    @ocsp_authorized_responder_arn.setter
    def ocsp_authorized_responder_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ocsp_authorized_responder_arn", value)

    @property
    @pulumi.getter(name="ocspLambdaArn")
    def ocsp_lambda_arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ocsp_lambda_arn")

    @ocsp_lambda_arn.setter
    def ocsp_lambda_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ocsp_lambda_arn", value)


if not MYPY:
    class DomainConfigurationTlsConfigArgsDict(TypedDict):
        security_policy: NotRequired[pulumi.Input[str]]
        """
        The security policy for a domain configuration. For more information, see [Security policies](https://docs.aws.amazon.com/iot/latest/developerguide/transport-security.html#tls-policy-table) in the *AWS IoT Core developer guide* .
        """
elif False:
    DomainConfigurationTlsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainConfigurationTlsConfigArgs:
    def __init__(__self__, *,
                 security_policy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] security_policy: The security policy for a domain configuration. For more information, see [Security policies](https://docs.aws.amazon.com/iot/latest/developerguide/transport-security.html#tls-policy-table) in the *AWS IoT Core developer guide* .
        """
        if security_policy is not None:
            pulumi.set(__self__, "security_policy", security_policy)

    @property
    @pulumi.getter(name="securityPolicy")
    def security_policy(self) -> Optional[pulumi.Input[str]]:
        """
        The security policy for a domain configuration. For more information, see [Security policies](https://docs.aws.amazon.com/iot/latest/developerguide/transport-security.html#tls-policy-table) in the *AWS IoT Core developer guide* .
        """
        return pulumi.get(self, "security_policy")

    @security_policy.setter
    def security_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "security_policy", value)


if not MYPY:
    class FleetMetricAggregationTypeArgsDict(TypedDict):
        """
        Aggregation types supported by Fleet Indexing
        """
        name: pulumi.Input[str]
        """
        Fleet Indexing aggregation type names such as Statistics, Percentiles and Cardinality
        """
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Fleet Indexing aggregation type values
        """
elif False:
    FleetMetricAggregationTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FleetMetricAggregationTypeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        Aggregation types supported by Fleet Indexing
        :param pulumi.Input[str] name: Fleet Indexing aggregation type names such as Statistics, Percentiles and Cardinality
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: Fleet Indexing aggregation type values
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Fleet Indexing aggregation type names such as Statistics, Percentiles and Cardinality
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Fleet Indexing aggregation type values
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class JobExecutionsRetryConfigPropertiesArgsDict(TypedDict):
        """
        Allows you to create the criteria to retry a job.
        """
        retry_criteria_list: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobTemplateRetryCriteriaArgsDict']]]]
        """
        The list of criteria that determines how many retries are allowed for each failure type for a job.
        """
elif False:
    JobExecutionsRetryConfigPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobExecutionsRetryConfigPropertiesArgs:
    def __init__(__self__, *,
                 retry_criteria_list: Optional[pulumi.Input[Sequence[pulumi.Input['JobTemplateRetryCriteriaArgs']]]] = None):
        """
        Allows you to create the criteria to retry a job.
        :param pulumi.Input[Sequence[pulumi.Input['JobTemplateRetryCriteriaArgs']]] retry_criteria_list: The list of criteria that determines how many retries are allowed for each failure type for a job.
        """
        if retry_criteria_list is not None:
            pulumi.set(__self__, "retry_criteria_list", retry_criteria_list)

    @property
    @pulumi.getter(name="retryCriteriaList")
    def retry_criteria_list(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobTemplateRetryCriteriaArgs']]]]:
        """
        The list of criteria that determines how many retries are allowed for each failure type for a job.
        """
        return pulumi.get(self, "retry_criteria_list")

    @retry_criteria_list.setter
    def retry_criteria_list(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobTemplateRetryCriteriaArgs']]]]):
        pulumi.set(self, "retry_criteria_list", value)


if not MYPY:
    class JobExecutionsRolloutConfigPropertiesArgsDict(TypedDict):
        """
        Allows you to create a staged rollout of a job.
        """
        exponential_rollout_rate: NotRequired[pulumi.Input['JobTemplateExponentialRolloutRateArgsDict']]
        """
        The rate of increase for a job rollout. This parameter allows you to define an exponential rate for a job rollout.
        """
        maximum_per_minute: NotRequired[pulumi.Input[int]]
        """
        The maximum number of things that will be notified of a pending job, per minute. This parameter allows you to create a staged rollout.
        """
elif False:
    JobExecutionsRolloutConfigPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobExecutionsRolloutConfigPropertiesArgs:
    def __init__(__self__, *,
                 exponential_rollout_rate: Optional[pulumi.Input['JobTemplateExponentialRolloutRateArgs']] = None,
                 maximum_per_minute: Optional[pulumi.Input[int]] = None):
        """
        Allows you to create a staged rollout of a job.
        :param pulumi.Input['JobTemplateExponentialRolloutRateArgs'] exponential_rollout_rate: The rate of increase for a job rollout. This parameter allows you to define an exponential rate for a job rollout.
        :param pulumi.Input[int] maximum_per_minute: The maximum number of things that will be notified of a pending job, per minute. This parameter allows you to create a staged rollout.
        """
        if exponential_rollout_rate is not None:
            pulumi.set(__self__, "exponential_rollout_rate", exponential_rollout_rate)
        if maximum_per_minute is not None:
            pulumi.set(__self__, "maximum_per_minute", maximum_per_minute)

    @property
    @pulumi.getter(name="exponentialRolloutRate")
    def exponential_rollout_rate(self) -> Optional[pulumi.Input['JobTemplateExponentialRolloutRateArgs']]:
        """
        The rate of increase for a job rollout. This parameter allows you to define an exponential rate for a job rollout.
        """
        return pulumi.get(self, "exponential_rollout_rate")

    @exponential_rollout_rate.setter
    def exponential_rollout_rate(self, value: Optional[pulumi.Input['JobTemplateExponentialRolloutRateArgs']]):
        pulumi.set(self, "exponential_rollout_rate", value)

    @property
    @pulumi.getter(name="maximumPerMinute")
    def maximum_per_minute(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of things that will be notified of a pending job, per minute. This parameter allows you to create a staged rollout.
        """
        return pulumi.get(self, "maximum_per_minute")

    @maximum_per_minute.setter
    def maximum_per_minute(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "maximum_per_minute", value)


if not MYPY:
    class JobTemplateAbortCriteriaArgsDict(TypedDict):
        """
        The criteria that determine when and how a job abort takes place.
        """
        action: pulumi.Input['JobTemplateAction']
        """
        The type of job action to take to initiate the job abort.
        """
        failure_type: pulumi.Input['JobTemplateFailureType']
        """
        The type of job execution failures that can initiate a job abort.
        """
        min_number_of_executed_things: pulumi.Input[int]
        """
        The minimum number of things which must receive job execution notifications before the job can be aborted.
        """
        threshold_percentage: pulumi.Input[float]
        """
        The minimum percentage of job execution failures that must occur to initiate the job abort.
        """
elif False:
    JobTemplateAbortCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTemplateAbortCriteriaArgs:
    def __init__(__self__, *,
                 action: pulumi.Input['JobTemplateAction'],
                 failure_type: pulumi.Input['JobTemplateFailureType'],
                 min_number_of_executed_things: pulumi.Input[int],
                 threshold_percentage: pulumi.Input[float]):
        """
        The criteria that determine when and how a job abort takes place.
        :param pulumi.Input['JobTemplateAction'] action: The type of job action to take to initiate the job abort.
        :param pulumi.Input['JobTemplateFailureType'] failure_type: The type of job execution failures that can initiate a job abort.
        :param pulumi.Input[int] min_number_of_executed_things: The minimum number of things which must receive job execution notifications before the job can be aborted.
        :param pulumi.Input[float] threshold_percentage: The minimum percentage of job execution failures that must occur to initiate the job abort.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "failure_type", failure_type)
        pulumi.set(__self__, "min_number_of_executed_things", min_number_of_executed_things)
        pulumi.set(__self__, "threshold_percentage", threshold_percentage)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input['JobTemplateAction']:
        """
        The type of job action to take to initiate the job abort.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input['JobTemplateAction']):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="failureType")
    def failure_type(self) -> pulumi.Input['JobTemplateFailureType']:
        """
        The type of job execution failures that can initiate a job abort.
        """
        return pulumi.get(self, "failure_type")

    @failure_type.setter
    def failure_type(self, value: pulumi.Input['JobTemplateFailureType']):
        pulumi.set(self, "failure_type", value)

    @property
    @pulumi.getter(name="minNumberOfExecutedThings")
    def min_number_of_executed_things(self) -> pulumi.Input[int]:
        """
        The minimum number of things which must receive job execution notifications before the job can be aborted.
        """
        return pulumi.get(self, "min_number_of_executed_things")

    @min_number_of_executed_things.setter
    def min_number_of_executed_things(self, value: pulumi.Input[int]):
        pulumi.set(self, "min_number_of_executed_things", value)

    @property
    @pulumi.getter(name="thresholdPercentage")
    def threshold_percentage(self) -> pulumi.Input[float]:
        """
        The minimum percentage of job execution failures that must occur to initiate the job abort.
        """
        return pulumi.get(self, "threshold_percentage")

    @threshold_percentage.setter
    def threshold_percentage(self, value: pulumi.Input[float]):
        pulumi.set(self, "threshold_percentage", value)


if not MYPY:
    class JobTemplateExponentialRolloutRateArgsDict(TypedDict):
        """
        Allows you to create an exponential rate of rollout for a job.
        """
        base_rate_per_minute: pulumi.Input[int]
        """
        The minimum number of things that will be notified of a pending job, per minute at the start of job rollout. This parameter allows you to define the initial rate of rollout.
        """
        increment_factor: pulumi.Input[float]
        """
        The exponential factor to increase the rate of rollout for a job.
        """
        rate_increase_criteria: pulumi.Input['JobTemplateRateIncreaseCriteriaArgsDict']
        """
        The criteria to initiate the increase in rate of rollout for a job.
        """
elif False:
    JobTemplateExponentialRolloutRateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTemplateExponentialRolloutRateArgs:
    def __init__(__self__, *,
                 base_rate_per_minute: pulumi.Input[int],
                 increment_factor: pulumi.Input[float],
                 rate_increase_criteria: pulumi.Input['JobTemplateRateIncreaseCriteriaArgs']):
        """
        Allows you to create an exponential rate of rollout for a job.
        :param pulumi.Input[int] base_rate_per_minute: The minimum number of things that will be notified of a pending job, per minute at the start of job rollout. This parameter allows you to define the initial rate of rollout.
        :param pulumi.Input[float] increment_factor: The exponential factor to increase the rate of rollout for a job.
        :param pulumi.Input['JobTemplateRateIncreaseCriteriaArgs'] rate_increase_criteria: The criteria to initiate the increase in rate of rollout for a job.
        """
        pulumi.set(__self__, "base_rate_per_minute", base_rate_per_minute)
        pulumi.set(__self__, "increment_factor", increment_factor)
        pulumi.set(__self__, "rate_increase_criteria", rate_increase_criteria)

    @property
    @pulumi.getter(name="baseRatePerMinute")
    def base_rate_per_minute(self) -> pulumi.Input[int]:
        """
        The minimum number of things that will be notified of a pending job, per minute at the start of job rollout. This parameter allows you to define the initial rate of rollout.
        """
        return pulumi.get(self, "base_rate_per_minute")

    @base_rate_per_minute.setter
    def base_rate_per_minute(self, value: pulumi.Input[int]):
        pulumi.set(self, "base_rate_per_minute", value)

    @property
    @pulumi.getter(name="incrementFactor")
    def increment_factor(self) -> pulumi.Input[float]:
        """
        The exponential factor to increase the rate of rollout for a job.
        """
        return pulumi.get(self, "increment_factor")

    @increment_factor.setter
    def increment_factor(self, value: pulumi.Input[float]):
        pulumi.set(self, "increment_factor", value)

    @property
    @pulumi.getter(name="rateIncreaseCriteria")
    def rate_increase_criteria(self) -> pulumi.Input['JobTemplateRateIncreaseCriteriaArgs']:
        """
        The criteria to initiate the increase in rate of rollout for a job.
        """
        return pulumi.get(self, "rate_increase_criteria")

    @rate_increase_criteria.setter
    def rate_increase_criteria(self, value: pulumi.Input['JobTemplateRateIncreaseCriteriaArgs']):
        pulumi.set(self, "rate_increase_criteria", value)


if not MYPY:
    class JobTemplateMaintenanceWindowArgsDict(TypedDict):
        """
        Specifies a start time and duration for a scheduled Job.
        """
        duration_in_minutes: NotRequired[pulumi.Input[int]]
        """
        Displays the duration of the next maintenance window.
        """
        start_time: NotRequired[pulumi.Input[str]]
        """
        Displays the start time of the next maintenance window.
        """
elif False:
    JobTemplateMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTemplateMaintenanceWindowArgs:
    def __init__(__self__, *,
                 duration_in_minutes: Optional[pulumi.Input[int]] = None,
                 start_time: Optional[pulumi.Input[str]] = None):
        """
        Specifies a start time and duration for a scheduled Job.
        :param pulumi.Input[int] duration_in_minutes: Displays the duration of the next maintenance window.
        :param pulumi.Input[str] start_time: Displays the start time of the next maintenance window.
        """
        if duration_in_minutes is not None:
            pulumi.set(__self__, "duration_in_minutes", duration_in_minutes)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="durationInMinutes")
    def duration_in_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        Displays the duration of the next maintenance window.
        """
        return pulumi.get(self, "duration_in_minutes")

    @duration_in_minutes.setter
    def duration_in_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "duration_in_minutes", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        Displays the start time of the next maintenance window.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class JobTemplateRateIncreaseCriteriaArgsDict(TypedDict):
        number_of_notified_things: NotRequired[pulumi.Input[int]]
        """
        The threshold for number of notified things that will initiate the increase in rate of rollout.
        """
        number_of_succeeded_things: NotRequired[pulumi.Input[int]]
        """
        The threshold for number of succeeded things that will initiate the increase in rate of rollout.
        """
elif False:
    JobTemplateRateIncreaseCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTemplateRateIncreaseCriteriaArgs:
    def __init__(__self__, *,
                 number_of_notified_things: Optional[pulumi.Input[int]] = None,
                 number_of_succeeded_things: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] number_of_notified_things: The threshold for number of notified things that will initiate the increase in rate of rollout.
        :param pulumi.Input[int] number_of_succeeded_things: The threshold for number of succeeded things that will initiate the increase in rate of rollout.
        """
        if number_of_notified_things is not None:
            pulumi.set(__self__, "number_of_notified_things", number_of_notified_things)
        if number_of_succeeded_things is not None:
            pulumi.set(__self__, "number_of_succeeded_things", number_of_succeeded_things)

    @property
    @pulumi.getter(name="numberOfNotifiedThings")
    def number_of_notified_things(self) -> Optional[pulumi.Input[int]]:
        """
        The threshold for number of notified things that will initiate the increase in rate of rollout.
        """
        return pulumi.get(self, "number_of_notified_things")

    @number_of_notified_things.setter
    def number_of_notified_things(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number_of_notified_things", value)

    @property
    @pulumi.getter(name="numberOfSucceededThings")
    def number_of_succeeded_things(self) -> Optional[pulumi.Input[int]]:
        """
        The threshold for number of succeeded things that will initiate the increase in rate of rollout.
        """
        return pulumi.get(self, "number_of_succeeded_things")

    @number_of_succeeded_things.setter
    def number_of_succeeded_things(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number_of_succeeded_things", value)


if not MYPY:
    class JobTemplateRetryCriteriaArgsDict(TypedDict):
        """
        Specifies how many times a failure type should be retried.
        """
        failure_type: NotRequired[pulumi.Input['JobTemplateJobRetryFailureType']]
        """
        The type of job execution failures that can initiate a job retry.
        """
        number_of_retries: NotRequired[pulumi.Input[int]]
        """
        The number of retries allowed for a failure type for the job.
        """
elif False:
    JobTemplateRetryCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobTemplateRetryCriteriaArgs:
    def __init__(__self__, *,
                 failure_type: Optional[pulumi.Input['JobTemplateJobRetryFailureType']] = None,
                 number_of_retries: Optional[pulumi.Input[int]] = None):
        """
        Specifies how many times a failure type should be retried.
        :param pulumi.Input['JobTemplateJobRetryFailureType'] failure_type: The type of job execution failures that can initiate a job retry.
        :param pulumi.Input[int] number_of_retries: The number of retries allowed for a failure type for the job.
        """
        if failure_type is not None:
            pulumi.set(__self__, "failure_type", failure_type)
        if number_of_retries is not None:
            pulumi.set(__self__, "number_of_retries", number_of_retries)

    @property
    @pulumi.getter(name="failureType")
    def failure_type(self) -> Optional[pulumi.Input['JobTemplateJobRetryFailureType']]:
        """
        The type of job execution failures that can initiate a job retry.
        """
        return pulumi.get(self, "failure_type")

    @failure_type.setter
    def failure_type(self, value: Optional[pulumi.Input['JobTemplateJobRetryFailureType']]):
        pulumi.set(self, "failure_type", value)

    @property
    @pulumi.getter(name="numberOfRetries")
    def number_of_retries(self) -> Optional[pulumi.Input[int]]:
        """
        The number of retries allowed for a failure type for the job.
        """
        return pulumi.get(self, "number_of_retries")

    @number_of_retries.setter
    def number_of_retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number_of_retries", value)


if not MYPY:
    class MetricsExportConfigPropertiesArgsDict(TypedDict):
        """
        A structure containing the mqtt topic for metrics export.
        """
        mqtt_topic: pulumi.Input[str]
        """
        The topic for metrics export.
        """
        role_arn: pulumi.Input[str]
        """
        The ARN of the role that grants permission to publish to mqtt topic.
        """
elif False:
    MetricsExportConfigPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricsExportConfigPropertiesArgs:
    def __init__(__self__, *,
                 mqtt_topic: pulumi.Input[str],
                 role_arn: pulumi.Input[str]):
        """
        A structure containing the mqtt topic for metrics export.
        :param pulumi.Input[str] mqtt_topic: The topic for metrics export.
        :param pulumi.Input[str] role_arn: The ARN of the role that grants permission to publish to mqtt topic.
        """
        pulumi.set(__self__, "mqtt_topic", mqtt_topic)
        pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter(name="mqttTopic")
    def mqtt_topic(self) -> pulumi.Input[str]:
        """
        The topic for metrics export.
        """
        return pulumi.get(self, "mqtt_topic")

    @mqtt_topic.setter
    def mqtt_topic(self, value: pulumi.Input[str]):
        pulumi.set(self, "mqtt_topic", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the role that grants permission to publish to mqtt topic.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)


if not MYPY:
    class MitigationActionActionParamsArgsDict(TypedDict):
        """
        The set of parameters for this mitigation action. You can specify only one type of parameter (in other words, you can apply only one action for each defined mitigation action).
        """
        add_things_to_thing_group_params: NotRequired[pulumi.Input['MitigationActionAddThingsToThingGroupParamsArgsDict']]
        """
        Specifies the group to which you want to add the devices.
        """
        enable_io_t_logging_params: NotRequired[pulumi.Input['MitigationActionEnableIoTLoggingParamsArgsDict']]
        """
        Specifies the logging level and the role with permissions for logging. You cannot specify a logging level of `DISABLED` .
        """
        publish_finding_to_sns_params: NotRequired[pulumi.Input['MitigationActionPublishFindingToSnsParamsArgsDict']]
        """
        Specifies the topic to which the finding should be published.
        """
        replace_default_policy_version_params: NotRequired[pulumi.Input['MitigationActionReplaceDefaultPolicyVersionParamsArgsDict']]
        """
        Replaces the policy version with a default or blank policy. You specify the template name. Only a value of `BLANK_POLICY` is currently supported.
        """
        update_ca_certificate_params: NotRequired[pulumi.Input['MitigationActionUpdateCaCertificateParamsArgsDict']]
        """
        Specifies the new state for the CA certificate. Only a value of `DEACTIVATE` is currently supported.
        """
        update_device_certificate_params: NotRequired[pulumi.Input['MitigationActionUpdateDeviceCertificateParamsArgsDict']]
        """
        Specifies the new state for a device certificate. Only a value of `DEACTIVATE` is currently supported.
        """
elif False:
    MitigationActionActionParamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MitigationActionActionParamsArgs:
    def __init__(__self__, *,
                 add_things_to_thing_group_params: Optional[pulumi.Input['MitigationActionAddThingsToThingGroupParamsArgs']] = None,
                 enable_io_t_logging_params: Optional[pulumi.Input['MitigationActionEnableIoTLoggingParamsArgs']] = None,
                 publish_finding_to_sns_params: Optional[pulumi.Input['MitigationActionPublishFindingToSnsParamsArgs']] = None,
                 replace_default_policy_version_params: Optional[pulumi.Input['MitigationActionReplaceDefaultPolicyVersionParamsArgs']] = None,
                 update_ca_certificate_params: Optional[pulumi.Input['MitigationActionUpdateCaCertificateParamsArgs']] = None,
                 update_device_certificate_params: Optional[pulumi.Input['MitigationActionUpdateDeviceCertificateParamsArgs']] = None):
        """
        The set of parameters for this mitigation action. You can specify only one type of parameter (in other words, you can apply only one action for each defined mitigation action).
        :param pulumi.Input['MitigationActionAddThingsToThingGroupParamsArgs'] add_things_to_thing_group_params: Specifies the group to which you want to add the devices.
        :param pulumi.Input['MitigationActionEnableIoTLoggingParamsArgs'] enable_io_t_logging_params: Specifies the logging level and the role with permissions for logging. You cannot specify a logging level of `DISABLED` .
        :param pulumi.Input['MitigationActionPublishFindingToSnsParamsArgs'] publish_finding_to_sns_params: Specifies the topic to which the finding should be published.
        :param pulumi.Input['MitigationActionReplaceDefaultPolicyVersionParamsArgs'] replace_default_policy_version_params: Replaces the policy version with a default or blank policy. You specify the template name. Only a value of `BLANK_POLICY` is currently supported.
        :param pulumi.Input['MitigationActionUpdateCaCertificateParamsArgs'] update_ca_certificate_params: Specifies the new state for the CA certificate. Only a value of `DEACTIVATE` is currently supported.
        :param pulumi.Input['MitigationActionUpdateDeviceCertificateParamsArgs'] update_device_certificate_params: Specifies the new state for a device certificate. Only a value of `DEACTIVATE` is currently supported.
        """
        if add_things_to_thing_group_params is not None:
            pulumi.set(__self__, "add_things_to_thing_group_params", add_things_to_thing_group_params)
        if enable_io_t_logging_params is not None:
            pulumi.set(__self__, "enable_io_t_logging_params", enable_io_t_logging_params)
        if publish_finding_to_sns_params is not None:
            pulumi.set(__self__, "publish_finding_to_sns_params", publish_finding_to_sns_params)
        if replace_default_policy_version_params is not None:
            pulumi.set(__self__, "replace_default_policy_version_params", replace_default_policy_version_params)
        if update_ca_certificate_params is not None:
            pulumi.set(__self__, "update_ca_certificate_params", update_ca_certificate_params)
        if update_device_certificate_params is not None:
            pulumi.set(__self__, "update_device_certificate_params", update_device_certificate_params)

    @property
    @pulumi.getter(name="addThingsToThingGroupParams")
    def add_things_to_thing_group_params(self) -> Optional[pulumi.Input['MitigationActionAddThingsToThingGroupParamsArgs']]:
        """
        Specifies the group to which you want to add the devices.
        """
        return pulumi.get(self, "add_things_to_thing_group_params")

    @add_things_to_thing_group_params.setter
    def add_things_to_thing_group_params(self, value: Optional[pulumi.Input['MitigationActionAddThingsToThingGroupParamsArgs']]):
        pulumi.set(self, "add_things_to_thing_group_params", value)

    @property
    @pulumi.getter(name="enableIoTLoggingParams")
    def enable_io_t_logging_params(self) -> Optional[pulumi.Input['MitigationActionEnableIoTLoggingParamsArgs']]:
        """
        Specifies the logging level and the role with permissions for logging. You cannot specify a logging level of `DISABLED` .
        """
        return pulumi.get(self, "enable_io_t_logging_params")

    @enable_io_t_logging_params.setter
    def enable_io_t_logging_params(self, value: Optional[pulumi.Input['MitigationActionEnableIoTLoggingParamsArgs']]):
        pulumi.set(self, "enable_io_t_logging_params", value)

    @property
    @pulumi.getter(name="publishFindingToSnsParams")
    def publish_finding_to_sns_params(self) -> Optional[pulumi.Input['MitigationActionPublishFindingToSnsParamsArgs']]:
        """
        Specifies the topic to which the finding should be published.
        """
        return pulumi.get(self, "publish_finding_to_sns_params")

    @publish_finding_to_sns_params.setter
    def publish_finding_to_sns_params(self, value: Optional[pulumi.Input['MitigationActionPublishFindingToSnsParamsArgs']]):
        pulumi.set(self, "publish_finding_to_sns_params", value)

    @property
    @pulumi.getter(name="replaceDefaultPolicyVersionParams")
    def replace_default_policy_version_params(self) -> Optional[pulumi.Input['MitigationActionReplaceDefaultPolicyVersionParamsArgs']]:
        """
        Replaces the policy version with a default or blank policy. You specify the template name. Only a value of `BLANK_POLICY` is currently supported.
        """
        return pulumi.get(self, "replace_default_policy_version_params")

    @replace_default_policy_version_params.setter
    def replace_default_policy_version_params(self, value: Optional[pulumi.Input['MitigationActionReplaceDefaultPolicyVersionParamsArgs']]):
        pulumi.set(self, "replace_default_policy_version_params", value)

    @property
    @pulumi.getter(name="updateCaCertificateParams")
    def update_ca_certificate_params(self) -> Optional[pulumi.Input['MitigationActionUpdateCaCertificateParamsArgs']]:
        """
        Specifies the new state for the CA certificate. Only a value of `DEACTIVATE` is currently supported.
        """
        return pulumi.get(self, "update_ca_certificate_params")

    @update_ca_certificate_params.setter
    def update_ca_certificate_params(self, value: Optional[pulumi.Input['MitigationActionUpdateCaCertificateParamsArgs']]):
        pulumi.set(self, "update_ca_certificate_params", value)

    @property
    @pulumi.getter(name="updateDeviceCertificateParams")
    def update_device_certificate_params(self) -> Optional[pulumi.Input['MitigationActionUpdateDeviceCertificateParamsArgs']]:
        """
        Specifies the new state for a device certificate. Only a value of `DEACTIVATE` is currently supported.
        """
        return pulumi.get(self, "update_device_certificate_params")

    @update_device_certificate_params.setter
    def update_device_certificate_params(self, value: Optional[pulumi.Input['MitigationActionUpdateDeviceCertificateParamsArgs']]):
        pulumi.set(self, "update_device_certificate_params", value)


if not MYPY:
    class MitigationActionAddThingsToThingGroupParamsArgsDict(TypedDict):
        """
        Parameters to define a mitigation action that moves devices associated with a certificate to one or more specified thing groups, typically for quarantine.
        """
        thing_group_names: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The list of groups to which you want to add the things that triggered the mitigation action.
        """
        override_dynamic_groups: NotRequired[pulumi.Input[bool]]
        """
        Specifies if this mitigation action can move the things that triggered the mitigation action out of one or more dynamic thing groups.
        """
elif False:
    MitigationActionAddThingsToThingGroupParamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MitigationActionAddThingsToThingGroupParamsArgs:
    def __init__(__self__, *,
                 thing_group_names: pulumi.Input[Sequence[pulumi.Input[str]]],
                 override_dynamic_groups: Optional[pulumi.Input[bool]] = None):
        """
        Parameters to define a mitigation action that moves devices associated with a certificate to one or more specified thing groups, typically for quarantine.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] thing_group_names: The list of groups to which you want to add the things that triggered the mitigation action.
        :param pulumi.Input[bool] override_dynamic_groups: Specifies if this mitigation action can move the things that triggered the mitigation action out of one or more dynamic thing groups.
        """
        pulumi.set(__self__, "thing_group_names", thing_group_names)
        if override_dynamic_groups is not None:
            pulumi.set(__self__, "override_dynamic_groups", override_dynamic_groups)

    @property
    @pulumi.getter(name="thingGroupNames")
    def thing_group_names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The list of groups to which you want to add the things that triggered the mitigation action.
        """
        return pulumi.get(self, "thing_group_names")

    @thing_group_names.setter
    def thing_group_names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "thing_group_names", value)

    @property
    @pulumi.getter(name="overrideDynamicGroups")
    def override_dynamic_groups(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies if this mitigation action can move the things that triggered the mitigation action out of one or more dynamic thing groups.
        """
        return pulumi.get(self, "override_dynamic_groups")

    @override_dynamic_groups.setter
    def override_dynamic_groups(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "override_dynamic_groups", value)


if not MYPY:
    class MitigationActionEnableIoTLoggingParamsArgsDict(TypedDict):
        """
        Parameters to define a mitigation action that enables AWS IoT logging at a specified level of detail.
        """
        log_level: pulumi.Input['MitigationActionEnableIoTLoggingParamsLogLevel']
        """
         Specifies which types of information are logged.
        """
        role_arn_for_logging: pulumi.Input[str]
        """
         The ARN of the IAM role used for logging.
        """
elif False:
    MitigationActionEnableIoTLoggingParamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MitigationActionEnableIoTLoggingParamsArgs:
    def __init__(__self__, *,
                 log_level: pulumi.Input['MitigationActionEnableIoTLoggingParamsLogLevel'],
                 role_arn_for_logging: pulumi.Input[str]):
        """
        Parameters to define a mitigation action that enables AWS IoT logging at a specified level of detail.
        :param pulumi.Input['MitigationActionEnableIoTLoggingParamsLogLevel'] log_level:  Specifies which types of information are logged.
        :param pulumi.Input[str] role_arn_for_logging:  The ARN of the IAM role used for logging.
        """
        pulumi.set(__self__, "log_level", log_level)
        pulumi.set(__self__, "role_arn_for_logging", role_arn_for_logging)

    @property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> pulumi.Input['MitigationActionEnableIoTLoggingParamsLogLevel']:
        """
         Specifies which types of information are logged.
        """
        return pulumi.get(self, "log_level")

    @log_level.setter
    def log_level(self, value: pulumi.Input['MitigationActionEnableIoTLoggingParamsLogLevel']):
        pulumi.set(self, "log_level", value)

    @property
    @pulumi.getter(name="roleArnForLogging")
    def role_arn_for_logging(self) -> pulumi.Input[str]:
        """
         The ARN of the IAM role used for logging.
        """
        return pulumi.get(self, "role_arn_for_logging")

    @role_arn_for_logging.setter
    def role_arn_for_logging(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn_for_logging", value)


if not MYPY:
    class MitigationActionPublishFindingToSnsParamsArgsDict(TypedDict):
        """
        Parameters, to define a mitigation action that publishes findings to Amazon SNS. You can implement your own custom actions in response to the Amazon SNS messages.
        """
        topic_arn: pulumi.Input[str]
        """
        The ARN of the topic to which you want to publish the findings.
        """
elif False:
    MitigationActionPublishFindingToSnsParamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MitigationActionPublishFindingToSnsParamsArgs:
    def __init__(__self__, *,
                 topic_arn: pulumi.Input[str]):
        """
        Parameters, to define a mitigation action that publishes findings to Amazon SNS. You can implement your own custom actions in response to the Amazon SNS messages.
        :param pulumi.Input[str] topic_arn: The ARN of the topic to which you want to publish the findings.
        """
        pulumi.set(__self__, "topic_arn", topic_arn)

    @property
    @pulumi.getter(name="topicArn")
    def topic_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the topic to which you want to publish the findings.
        """
        return pulumi.get(self, "topic_arn")

    @topic_arn.setter
    def topic_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "topic_arn", value)


if not MYPY:
    class MitigationActionReplaceDefaultPolicyVersionParamsArgsDict(TypedDict):
        """
        Parameters to define a mitigation action that adds a blank policy to restrict permissions.
        """
        template_name: pulumi.Input['MitigationActionReplaceDefaultPolicyVersionParamsTemplateName']
        """
        The name of the template to be applied. The only supported value is `BLANK_POLICY` .
        """
elif False:
    MitigationActionReplaceDefaultPolicyVersionParamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MitigationActionReplaceDefaultPolicyVersionParamsArgs:
    def __init__(__self__, *,
                 template_name: pulumi.Input['MitigationActionReplaceDefaultPolicyVersionParamsTemplateName']):
        """
        Parameters to define a mitigation action that adds a blank policy to restrict permissions.
        :param pulumi.Input['MitigationActionReplaceDefaultPolicyVersionParamsTemplateName'] template_name: The name of the template to be applied. The only supported value is `BLANK_POLICY` .
        """
        pulumi.set(__self__, "template_name", template_name)

    @property
    @pulumi.getter(name="templateName")
    def template_name(self) -> pulumi.Input['MitigationActionReplaceDefaultPolicyVersionParamsTemplateName']:
        """
        The name of the template to be applied. The only supported value is `BLANK_POLICY` .
        """
        return pulumi.get(self, "template_name")

    @template_name.setter
    def template_name(self, value: pulumi.Input['MitigationActionReplaceDefaultPolicyVersionParamsTemplateName']):
        pulumi.set(self, "template_name", value)


if not MYPY:
    class MitigationActionUpdateCaCertificateParamsArgsDict(TypedDict):
        """
        Parameters to define a mitigation action that changes the state of the CA certificate to inactive.
        """
        action: pulumi.Input['MitigationActionUpdateCaCertificateParamsAction']
        """
        The action that you want to apply to the CA certificate. The only supported value is `DEACTIVATE` .
        """
elif False:
    MitigationActionUpdateCaCertificateParamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MitigationActionUpdateCaCertificateParamsArgs:
    def __init__(__self__, *,
                 action: pulumi.Input['MitigationActionUpdateCaCertificateParamsAction']):
        """
        Parameters to define a mitigation action that changes the state of the CA certificate to inactive.
        :param pulumi.Input['MitigationActionUpdateCaCertificateParamsAction'] action: The action that you want to apply to the CA certificate. The only supported value is `DEACTIVATE` .
        """
        pulumi.set(__self__, "action", action)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input['MitigationActionUpdateCaCertificateParamsAction']:
        """
        The action that you want to apply to the CA certificate. The only supported value is `DEACTIVATE` .
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input['MitigationActionUpdateCaCertificateParamsAction']):
        pulumi.set(self, "action", value)


if not MYPY:
    class MitigationActionUpdateDeviceCertificateParamsArgsDict(TypedDict):
        """
        Parameters to define a mitigation action that changes the state of the device certificate to inactive.
        """
        action: pulumi.Input['MitigationActionUpdateDeviceCertificateParamsAction']
        """
        The action that you want to apply to the device certificate. The only supported value is `DEACTIVATE` .
        """
elif False:
    MitigationActionUpdateDeviceCertificateParamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MitigationActionUpdateDeviceCertificateParamsArgs:
    def __init__(__self__, *,
                 action: pulumi.Input['MitigationActionUpdateDeviceCertificateParamsAction']):
        """
        Parameters to define a mitigation action that changes the state of the device certificate to inactive.
        :param pulumi.Input['MitigationActionUpdateDeviceCertificateParamsAction'] action: The action that you want to apply to the device certificate. The only supported value is `DEACTIVATE` .
        """
        pulumi.set(__self__, "action", action)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input['MitigationActionUpdateDeviceCertificateParamsAction']:
        """
        The action that you want to apply to the device certificate. The only supported value is `DEACTIVATE` .
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input['MitigationActionUpdateDeviceCertificateParamsAction']):
        pulumi.set(self, "action", value)


if not MYPY:
    class PresignedUrlConfigPropertiesArgsDict(TypedDict):
        """
        Configuration for pre-signed S3 URLs.
        """
        role_arn: pulumi.Input[str]
        """
        The ARN of an IAM role that grants grants permission to download files from the S3 bucket where the job data/updates are stored. The role must also grant permission for IoT to download the files.

        > For information about addressing the confused deputy problem, see [cross-service confused deputy prevention](https://docs.aws.amazon.com/iot/latest/developerguide/cross-service-confused-deputy-prevention.html) in the *AWS IoT Core developer guide* .
        """
        expires_in_sec: NotRequired[pulumi.Input[int]]
        """
        How long (in seconds) pre-signed URLs are valid. Valid values are 60 - 3600, the default value is 3600 seconds. Pre-signed URLs are generated when Jobs receives an MQTT request for the job document.
        """
elif False:
    PresignedUrlConfigPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PresignedUrlConfigPropertiesArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[str],
                 expires_in_sec: Optional[pulumi.Input[int]] = None):
        """
        Configuration for pre-signed S3 URLs.
        :param pulumi.Input[str] role_arn: The ARN of an IAM role that grants grants permission to download files from the S3 bucket where the job data/updates are stored. The role must also grant permission for IoT to download the files.
               
               > For information about addressing the confused deputy problem, see [cross-service confused deputy prevention](https://docs.aws.amazon.com/iot/latest/developerguide/cross-service-confused-deputy-prevention.html) in the *AWS IoT Core developer guide* .
        :param pulumi.Input[int] expires_in_sec: How long (in seconds) pre-signed URLs are valid. Valid values are 60 - 3600, the default value is 3600 seconds. Pre-signed URLs are generated when Jobs receives an MQTT request for the job document.
        """
        pulumi.set(__self__, "role_arn", role_arn)
        if expires_in_sec is not None:
            pulumi.set(__self__, "expires_in_sec", expires_in_sec)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The ARN of an IAM role that grants grants permission to download files from the S3 bucket where the job data/updates are stored. The role must also grant permission for IoT to download the files.

        > For information about addressing the confused deputy problem, see [cross-service confused deputy prevention](https://docs.aws.amazon.com/iot/latest/developerguide/cross-service-confused-deputy-prevention.html) in the *AWS IoT Core developer guide* .
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="expiresInSec")
    def expires_in_sec(self) -> Optional[pulumi.Input[int]]:
        """
        How long (in seconds) pre-signed URLs are valid. Valid values are 60 - 3600, the default value is 3600 seconds. Pre-signed URLs are generated when Jobs receives an MQTT request for the job document.
        """
        return pulumi.get(self, "expires_in_sec")

    @expires_in_sec.setter
    def expires_in_sec(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "expires_in_sec", value)


if not MYPY:
    class ProvisioningTemplateProvisioningHookArgsDict(TypedDict):
        payload_version: NotRequired[pulumi.Input[str]]
        """
        The payload that was sent to the target function. The valid payload is `"2020-04-01"` .
        """
        target_arn: NotRequired[pulumi.Input[str]]
        """
        The ARN of the target function.
        """
elif False:
    ProvisioningTemplateProvisioningHookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProvisioningTemplateProvisioningHookArgs:
    def __init__(__self__, *,
                 payload_version: Optional[pulumi.Input[str]] = None,
                 target_arn: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] payload_version: The payload that was sent to the target function. The valid payload is `"2020-04-01"` .
        :param pulumi.Input[str] target_arn: The ARN of the target function.
        """
        if payload_version is not None:
            pulumi.set(__self__, "payload_version", payload_version)
        if target_arn is not None:
            pulumi.set(__self__, "target_arn", target_arn)

    @property
    @pulumi.getter(name="payloadVersion")
    def payload_version(self) -> Optional[pulumi.Input[str]]:
        """
        The payload that was sent to the target function. The valid payload is `"2020-04-01"` .
        """
        return pulumi.get(self, "payload_version")

    @payload_version.setter
    def payload_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "payload_version", value)

    @property
    @pulumi.getter(name="targetArn")
    def target_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The ARN of the target function.
        """
        return pulumi.get(self, "target_arn")

    @target_arn.setter
    def target_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target_arn", value)


if not MYPY:
    class SecurityProfileAlertTargetArgsDict(TypedDict):
        """
        A structure containing the alert target ARN and the role ARN.
        """
        alert_target_arn: pulumi.Input[str]
        """
        The ARN of the notification target to which alerts are sent.
        """
        role_arn: pulumi.Input[str]
        """
        The ARN of the role that grants permission to send alerts to the notification target.
        """
elif False:
    SecurityProfileAlertTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityProfileAlertTargetArgs:
    def __init__(__self__, *,
                 alert_target_arn: pulumi.Input[str],
                 role_arn: pulumi.Input[str]):
        """
        A structure containing the alert target ARN and the role ARN.
        :param pulumi.Input[str] alert_target_arn: The ARN of the notification target to which alerts are sent.
        :param pulumi.Input[str] role_arn: The ARN of the role that grants permission to send alerts to the notification target.
        """
        pulumi.set(__self__, "alert_target_arn", alert_target_arn)
        pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter(name="alertTargetArn")
    def alert_target_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the notification target to which alerts are sent.
        """
        return pulumi.get(self, "alert_target_arn")

    @alert_target_arn.setter
    def alert_target_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "alert_target_arn", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the role that grants permission to send alerts to the notification target.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)


if not MYPY:
    class SecurityProfileBehaviorCriteriaArgsDict(TypedDict):
        """
        The criteria by which the behavior is determined to be normal.
        """
        comparison_operator: NotRequired[pulumi.Input['SecurityProfileBehaviorCriteriaComparisonOperator']]
        """
        The operator that relates the thing measured (metric) to the criteria (containing a value or statisticalThreshold).
        """
        consecutive_datapoints_to_alarm: NotRequired[pulumi.Input[int]]
        """
        If a device is in violation of the behavior for the specified number of consecutive datapoints, an alarm occurs. If not specified, the default is 1.
        """
        consecutive_datapoints_to_clear: NotRequired[pulumi.Input[int]]
        """
        If an alarm has occurred and the offending device is no longer in violation of the behavior for the specified number of consecutive datapoints, the alarm is cleared. If not specified, the default is 1.
        """
        duration_seconds: NotRequired[pulumi.Input[int]]
        """
        Use this to specify the time duration over which the behavior is evaluated.
        """
        ml_detection_config: NotRequired[pulumi.Input['SecurityProfileMachineLearningDetectionConfigArgsDict']]
        """
        The confidence level of the detection model.
        """
        statistical_threshold: NotRequired[pulumi.Input['SecurityProfileStatisticalThresholdArgsDict']]
        """
        A statistical ranking (percentile)that indicates a threshold value by which a behavior is determined to be in compliance or in violation of the behavior.
        """
        value: NotRequired[pulumi.Input['SecurityProfileMetricValueArgsDict']]
        """
        The value to be compared with the `metric` .
        """
elif False:
    SecurityProfileBehaviorCriteriaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityProfileBehaviorCriteriaArgs:
    def __init__(__self__, *,
                 comparison_operator: Optional[pulumi.Input['SecurityProfileBehaviorCriteriaComparisonOperator']] = None,
                 consecutive_datapoints_to_alarm: Optional[pulumi.Input[int]] = None,
                 consecutive_datapoints_to_clear: Optional[pulumi.Input[int]] = None,
                 duration_seconds: Optional[pulumi.Input[int]] = None,
                 ml_detection_config: Optional[pulumi.Input['SecurityProfileMachineLearningDetectionConfigArgs']] = None,
                 statistical_threshold: Optional[pulumi.Input['SecurityProfileStatisticalThresholdArgs']] = None,
                 value: Optional[pulumi.Input['SecurityProfileMetricValueArgs']] = None):
        """
        The criteria by which the behavior is determined to be normal.
        :param pulumi.Input['SecurityProfileBehaviorCriteriaComparisonOperator'] comparison_operator: The operator that relates the thing measured (metric) to the criteria (containing a value or statisticalThreshold).
        :param pulumi.Input[int] consecutive_datapoints_to_alarm: If a device is in violation of the behavior for the specified number of consecutive datapoints, an alarm occurs. If not specified, the default is 1.
        :param pulumi.Input[int] consecutive_datapoints_to_clear: If an alarm has occurred and the offending device is no longer in violation of the behavior for the specified number of consecutive datapoints, the alarm is cleared. If not specified, the default is 1.
        :param pulumi.Input[int] duration_seconds: Use this to specify the time duration over which the behavior is evaluated.
        :param pulumi.Input['SecurityProfileMachineLearningDetectionConfigArgs'] ml_detection_config: The confidence level of the detection model.
        :param pulumi.Input['SecurityProfileStatisticalThresholdArgs'] statistical_threshold: A statistical ranking (percentile)that indicates a threshold value by which a behavior is determined to be in compliance or in violation of the behavior.
        :param pulumi.Input['SecurityProfileMetricValueArgs'] value: The value to be compared with the `metric` .
        """
        if comparison_operator is not None:
            pulumi.set(__self__, "comparison_operator", comparison_operator)
        if consecutive_datapoints_to_alarm is not None:
            pulumi.set(__self__, "consecutive_datapoints_to_alarm", consecutive_datapoints_to_alarm)
        if consecutive_datapoints_to_clear is not None:
            pulumi.set(__self__, "consecutive_datapoints_to_clear", consecutive_datapoints_to_clear)
        if duration_seconds is not None:
            pulumi.set(__self__, "duration_seconds", duration_seconds)
        if ml_detection_config is not None:
            pulumi.set(__self__, "ml_detection_config", ml_detection_config)
        if statistical_threshold is not None:
            pulumi.set(__self__, "statistical_threshold", statistical_threshold)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="comparisonOperator")
    def comparison_operator(self) -> Optional[pulumi.Input['SecurityProfileBehaviorCriteriaComparisonOperator']]:
        """
        The operator that relates the thing measured (metric) to the criteria (containing a value or statisticalThreshold).
        """
        return pulumi.get(self, "comparison_operator")

    @comparison_operator.setter
    def comparison_operator(self, value: Optional[pulumi.Input['SecurityProfileBehaviorCriteriaComparisonOperator']]):
        pulumi.set(self, "comparison_operator", value)

    @property
    @pulumi.getter(name="consecutiveDatapointsToAlarm")
    def consecutive_datapoints_to_alarm(self) -> Optional[pulumi.Input[int]]:
        """
        If a device is in violation of the behavior for the specified number of consecutive datapoints, an alarm occurs. If not specified, the default is 1.
        """
        return pulumi.get(self, "consecutive_datapoints_to_alarm")

    @consecutive_datapoints_to_alarm.setter
    def consecutive_datapoints_to_alarm(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "consecutive_datapoints_to_alarm", value)

    @property
    @pulumi.getter(name="consecutiveDatapointsToClear")
    def consecutive_datapoints_to_clear(self) -> Optional[pulumi.Input[int]]:
        """
        If an alarm has occurred and the offending device is no longer in violation of the behavior for the specified number of consecutive datapoints, the alarm is cleared. If not specified, the default is 1.
        """
        return pulumi.get(self, "consecutive_datapoints_to_clear")

    @consecutive_datapoints_to_clear.setter
    def consecutive_datapoints_to_clear(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "consecutive_datapoints_to_clear", value)

    @property
    @pulumi.getter(name="durationSeconds")
    def duration_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Use this to specify the time duration over which the behavior is evaluated.
        """
        return pulumi.get(self, "duration_seconds")

    @duration_seconds.setter
    def duration_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "duration_seconds", value)

    @property
    @pulumi.getter(name="mlDetectionConfig")
    def ml_detection_config(self) -> Optional[pulumi.Input['SecurityProfileMachineLearningDetectionConfigArgs']]:
        """
        The confidence level of the detection model.
        """
        return pulumi.get(self, "ml_detection_config")

    @ml_detection_config.setter
    def ml_detection_config(self, value: Optional[pulumi.Input['SecurityProfileMachineLearningDetectionConfigArgs']]):
        pulumi.set(self, "ml_detection_config", value)

    @property
    @pulumi.getter(name="statisticalThreshold")
    def statistical_threshold(self) -> Optional[pulumi.Input['SecurityProfileStatisticalThresholdArgs']]:
        """
        A statistical ranking (percentile)that indicates a threshold value by which a behavior is determined to be in compliance or in violation of the behavior.
        """
        return pulumi.get(self, "statistical_threshold")

    @statistical_threshold.setter
    def statistical_threshold(self, value: Optional[pulumi.Input['SecurityProfileStatisticalThresholdArgs']]):
        pulumi.set(self, "statistical_threshold", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input['SecurityProfileMetricValueArgs']]:
        """
        The value to be compared with the `metric` .
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input['SecurityProfileMetricValueArgs']]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SecurityProfileBehaviorArgsDict(TypedDict):
        """
        A security profile behavior.
        """
        name: pulumi.Input[str]
        """
        The name for the behavior.
        """
        criteria: NotRequired[pulumi.Input['SecurityProfileBehaviorCriteriaArgsDict']]
        """
        The criteria that determine if a device is behaving normally in regard to the `metric` .

        > In the AWS IoT console, you can choose to be sent an alert through Amazon SNS when AWS IoT Device Defender detects that a device is behaving anomalously.
        """
        export_metric: NotRequired[pulumi.Input[bool]]
        """
        Value indicates exporting metrics related to the behavior when it is true.
        """
        metric: NotRequired[pulumi.Input[str]]
        """
        What is measured by the behavior.
        """
        metric_dimension: NotRequired[pulumi.Input['SecurityProfileMetricDimensionArgsDict']]
        """
        The dimension of the metric.
        """
        suppress_alerts: NotRequired[pulumi.Input[bool]]
        """
        Manage Detect alarm SNS notifications by setting behavior notification to on or suppressed. Detect will continue to performing device behavior evaluations. However, suppressed alarms wouldn't be forwarded for SNS notification.
        """
elif False:
    SecurityProfileBehaviorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityProfileBehaviorArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 criteria: Optional[pulumi.Input['SecurityProfileBehaviorCriteriaArgs']] = None,
                 export_metric: Optional[pulumi.Input[bool]] = None,
                 metric: Optional[pulumi.Input[str]] = None,
                 metric_dimension: Optional[pulumi.Input['SecurityProfileMetricDimensionArgs']] = None,
                 suppress_alerts: Optional[pulumi.Input[bool]] = None):
        """
        A security profile behavior.
        :param pulumi.Input[str] name: The name for the behavior.
        :param pulumi.Input['SecurityProfileBehaviorCriteriaArgs'] criteria: The criteria that determine if a device is behaving normally in regard to the `metric` .
               
               > In the AWS IoT console, you can choose to be sent an alert through Amazon SNS when AWS IoT Device Defender detects that a device is behaving anomalously.
        :param pulumi.Input[bool] export_metric: Value indicates exporting metrics related to the behavior when it is true.
        :param pulumi.Input[str] metric: What is measured by the behavior.
        :param pulumi.Input['SecurityProfileMetricDimensionArgs'] metric_dimension: The dimension of the metric.
        :param pulumi.Input[bool] suppress_alerts: Manage Detect alarm SNS notifications by setting behavior notification to on or suppressed. Detect will continue to performing device behavior evaluations. However, suppressed alarms wouldn't be forwarded for SNS notification.
        """
        pulumi.set(__self__, "name", name)
        if criteria is not None:
            pulumi.set(__self__, "criteria", criteria)
        if export_metric is not None:
            pulumi.set(__self__, "export_metric", export_metric)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if metric_dimension is not None:
            pulumi.set(__self__, "metric_dimension", metric_dimension)
        if suppress_alerts is not None:
            pulumi.set(__self__, "suppress_alerts", suppress_alerts)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name for the behavior.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def criteria(self) -> Optional[pulumi.Input['SecurityProfileBehaviorCriteriaArgs']]:
        """
        The criteria that determine if a device is behaving normally in regard to the `metric` .

        > In the AWS IoT console, you can choose to be sent an alert through Amazon SNS when AWS IoT Device Defender detects that a device is behaving anomalously.
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: Optional[pulumi.Input['SecurityProfileBehaviorCriteriaArgs']]):
        pulumi.set(self, "criteria", value)

    @property
    @pulumi.getter(name="exportMetric")
    def export_metric(self) -> Optional[pulumi.Input[bool]]:
        """
        Value indicates exporting metrics related to the behavior when it is true.
        """
        return pulumi.get(self, "export_metric")

    @export_metric.setter
    def export_metric(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "export_metric", value)

    @property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[str]]:
        """
        What is measured by the behavior.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="metricDimension")
    def metric_dimension(self) -> Optional[pulumi.Input['SecurityProfileMetricDimensionArgs']]:
        """
        The dimension of the metric.
        """
        return pulumi.get(self, "metric_dimension")

    @metric_dimension.setter
    def metric_dimension(self, value: Optional[pulumi.Input['SecurityProfileMetricDimensionArgs']]):
        pulumi.set(self, "metric_dimension", value)

    @property
    @pulumi.getter(name="suppressAlerts")
    def suppress_alerts(self) -> Optional[pulumi.Input[bool]]:
        """
        Manage Detect alarm SNS notifications by setting behavior notification to on or suppressed. Detect will continue to performing device behavior evaluations. However, suppressed alarms wouldn't be forwarded for SNS notification.
        """
        return pulumi.get(self, "suppress_alerts")

    @suppress_alerts.setter
    def suppress_alerts(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "suppress_alerts", value)


if not MYPY:
    class SecurityProfileMachineLearningDetectionConfigArgsDict(TypedDict):
        """
        The configuration of an ML Detect Security Profile.
        """
        confidence_level: NotRequired[pulumi.Input['SecurityProfileMachineLearningDetectionConfigConfidenceLevel']]
        """
        The sensitivity of anomalous behavior evaluation. Can be Low, Medium, or High.
        """
elif False:
    SecurityProfileMachineLearningDetectionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityProfileMachineLearningDetectionConfigArgs:
    def __init__(__self__, *,
                 confidence_level: Optional[pulumi.Input['SecurityProfileMachineLearningDetectionConfigConfidenceLevel']] = None):
        """
        The configuration of an ML Detect Security Profile.
        :param pulumi.Input['SecurityProfileMachineLearningDetectionConfigConfidenceLevel'] confidence_level: The sensitivity of anomalous behavior evaluation. Can be Low, Medium, or High.
        """
        if confidence_level is not None:
            pulumi.set(__self__, "confidence_level", confidence_level)

    @property
    @pulumi.getter(name="confidenceLevel")
    def confidence_level(self) -> Optional[pulumi.Input['SecurityProfileMachineLearningDetectionConfigConfidenceLevel']]:
        """
        The sensitivity of anomalous behavior evaluation. Can be Low, Medium, or High.
        """
        return pulumi.get(self, "confidence_level")

    @confidence_level.setter
    def confidence_level(self, value: Optional[pulumi.Input['SecurityProfileMachineLearningDetectionConfigConfidenceLevel']]):
        pulumi.set(self, "confidence_level", value)


if not MYPY:
    class SecurityProfileMetricDimensionArgsDict(TypedDict):
        """
        The dimension of a metric.
        """
        dimension_name: pulumi.Input[str]
        """
        A unique identifier for the dimension.
        """
        operator: NotRequired[pulumi.Input['SecurityProfileMetricDimensionOperator']]
        """
        Defines how the dimensionValues of a dimension are interpreted.
        """
elif False:
    SecurityProfileMetricDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityProfileMetricDimensionArgs:
    def __init__(__self__, *,
                 dimension_name: pulumi.Input[str],
                 operator: Optional[pulumi.Input['SecurityProfileMetricDimensionOperator']] = None):
        """
        The dimension of a metric.
        :param pulumi.Input[str] dimension_name: A unique identifier for the dimension.
        :param pulumi.Input['SecurityProfileMetricDimensionOperator'] operator: Defines how the dimensionValues of a dimension are interpreted.
        """
        pulumi.set(__self__, "dimension_name", dimension_name)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)

    @property
    @pulumi.getter(name="dimensionName")
    def dimension_name(self) -> pulumi.Input[str]:
        """
        A unique identifier for the dimension.
        """
        return pulumi.get(self, "dimension_name")

    @dimension_name.setter
    def dimension_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "dimension_name", value)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input['SecurityProfileMetricDimensionOperator']]:
        """
        Defines how the dimensionValues of a dimension are interpreted.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input['SecurityProfileMetricDimensionOperator']]):
        pulumi.set(self, "operator", value)


if not MYPY:
    class SecurityProfileMetricToRetainArgsDict(TypedDict):
        """
        The metric you want to retain. Dimensions are optional.
        """
        metric: pulumi.Input[str]
        """
        What is measured by the behavior.
        """
        export_metric: NotRequired[pulumi.Input[bool]]
        """
        The value indicates exporting metrics related to the `MetricToRetain` when it's true.
        """
        metric_dimension: NotRequired[pulumi.Input['SecurityProfileMetricDimensionArgsDict']]
        """
        The dimension of the metric.
        """
elif False:
    SecurityProfileMetricToRetainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityProfileMetricToRetainArgs:
    def __init__(__self__, *,
                 metric: pulumi.Input[str],
                 export_metric: Optional[pulumi.Input[bool]] = None,
                 metric_dimension: Optional[pulumi.Input['SecurityProfileMetricDimensionArgs']] = None):
        """
        The metric you want to retain. Dimensions are optional.
        :param pulumi.Input[str] metric: What is measured by the behavior.
        :param pulumi.Input[bool] export_metric: The value indicates exporting metrics related to the `MetricToRetain` when it's true.
        :param pulumi.Input['SecurityProfileMetricDimensionArgs'] metric_dimension: The dimension of the metric.
        """
        pulumi.set(__self__, "metric", metric)
        if export_metric is not None:
            pulumi.set(__self__, "export_metric", export_metric)
        if metric_dimension is not None:
            pulumi.set(__self__, "metric_dimension", metric_dimension)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        """
        What is measured by the behavior.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="exportMetric")
    def export_metric(self) -> Optional[pulumi.Input[bool]]:
        """
        The value indicates exporting metrics related to the `MetricToRetain` when it's true.
        """
        return pulumi.get(self, "export_metric")

    @export_metric.setter
    def export_metric(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "export_metric", value)

    @property
    @pulumi.getter(name="metricDimension")
    def metric_dimension(self) -> Optional[pulumi.Input['SecurityProfileMetricDimensionArgs']]:
        """
        The dimension of the metric.
        """
        return pulumi.get(self, "metric_dimension")

    @metric_dimension.setter
    def metric_dimension(self, value: Optional[pulumi.Input['SecurityProfileMetricDimensionArgs']]):
        pulumi.set(self, "metric_dimension", value)


if not MYPY:
    class SecurityProfileMetricValueArgsDict(TypedDict):
        """
        The value to be compared with the metric.
        """
        cidrs: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        If the ComparisonOperator calls for a set of CIDRs, use this to specify that set to be compared with the metric.
        """
        count: NotRequired[pulumi.Input[str]]
        """
        If the ComparisonOperator calls for a numeric value, use this to specify that (integer) numeric value to be compared with the metric.
        """
        number: NotRequired[pulumi.Input[float]]
        """
        The numeral value of a metric.
        """
        numbers: NotRequired[pulumi.Input[Sequence[pulumi.Input[float]]]]
        """
        The numeral values of a metric.
        """
        ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        If the ComparisonOperator calls for a set of ports, use this to specify that set to be compared with the metric.
        """
        strings: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The string values of a metric.
        """
elif False:
    SecurityProfileMetricValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityProfileMetricValueArgs:
    def __init__(__self__, *,
                 cidrs: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 count: Optional[pulumi.Input[str]] = None,
                 number: Optional[pulumi.Input[float]] = None,
                 numbers: Optional[pulumi.Input[Sequence[pulumi.Input[float]]]] = None,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 strings: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The value to be compared with the metric.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] cidrs: If the ComparisonOperator calls for a set of CIDRs, use this to specify that set to be compared with the metric.
        :param pulumi.Input[str] count: If the ComparisonOperator calls for a numeric value, use this to specify that (integer) numeric value to be compared with the metric.
        :param pulumi.Input[float] number: The numeral value of a metric.
        :param pulumi.Input[Sequence[pulumi.Input[float]]] numbers: The numeral values of a metric.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] ports: If the ComparisonOperator calls for a set of ports, use this to specify that set to be compared with the metric.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] strings: The string values of a metric.
        """
        if cidrs is not None:
            pulumi.set(__self__, "cidrs", cidrs)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if number is not None:
            pulumi.set(__self__, "number", number)
        if numbers is not None:
            pulumi.set(__self__, "numbers", numbers)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if strings is not None:
            pulumi.set(__self__, "strings", strings)

    @property
    @pulumi.getter
    def cidrs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        If the ComparisonOperator calls for a set of CIDRs, use this to specify that set to be compared with the metric.
        """
        return pulumi.get(self, "cidrs")

    @cidrs.setter
    def cidrs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "cidrs", value)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[str]]:
        """
        If the ComparisonOperator calls for a numeric value, use this to specify that (integer) numeric value to be compared with the metric.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def number(self) -> Optional[pulumi.Input[float]]:
        """
        The numeral value of a metric.
        """
        return pulumi.get(self, "number")

    @number.setter
    def number(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "number", value)

    @property
    @pulumi.getter
    def numbers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[float]]]]:
        """
        The numeral values of a metric.
        """
        return pulumi.get(self, "numbers")

    @numbers.setter
    def numbers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[float]]]]):
        pulumi.set(self, "numbers", value)

    @property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        If the ComparisonOperator calls for a set of ports, use this to specify that set to be compared with the metric.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "ports", value)

    @property
    @pulumi.getter
    def strings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The string values of a metric.
        """
        return pulumi.get(self, "strings")

    @strings.setter
    def strings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "strings", value)


if not MYPY:
    class SecurityProfileStatisticalThresholdArgsDict(TypedDict):
        """
        A statistical ranking (percentile) which indicates a threshold value by which a behavior is determined to be in compliance or in violation of the behavior.
        """
        statistic: NotRequired[pulumi.Input['SecurityProfileStatisticalThresholdStatistic']]
        """
        The percentile which resolves to a threshold value by which compliance with a behavior is determined
        """
elif False:
    SecurityProfileStatisticalThresholdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityProfileStatisticalThresholdArgs:
    def __init__(__self__, *,
                 statistic: Optional[pulumi.Input['SecurityProfileStatisticalThresholdStatistic']] = None):
        """
        A statistical ranking (percentile) which indicates a threshold value by which a behavior is determined to be in compliance or in violation of the behavior.
        :param pulumi.Input['SecurityProfileStatisticalThresholdStatistic'] statistic: The percentile which resolves to a threshold value by which compliance with a behavior is determined
        """
        if statistic is not None:
            pulumi.set(__self__, "statistic", statistic)

    @property
    @pulumi.getter
    def statistic(self) -> Optional[pulumi.Input['SecurityProfileStatisticalThresholdStatistic']]:
        """
        The percentile which resolves to a threshold value by which compliance with a behavior is determined
        """
        return pulumi.get(self, "statistic")

    @statistic.setter
    def statistic(self, value: Optional[pulumi.Input['SecurityProfileStatisticalThresholdStatistic']]):
        pulumi.set(self, "statistic", value)


if not MYPY:
    class ThingAttributePayloadArgsDict(TypedDict):
        attributes: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A JSON string containing up to three key-value pair in JSON format. For example:

        `{\\"attributes\\":{\\"string1\\":\\"string2\\"}}`
        """
elif False:
    ThingAttributePayloadArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThingAttributePayloadArgs:
    def __init__(__self__, *,
                 attributes: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] attributes: A JSON string containing up to three key-value pair in JSON format. For example:
               
               `{\\"attributes\\":{\\"string1\\":\\"string2\\"}}`
        """
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)

    @property
    @pulumi.getter
    def attributes(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A JSON string containing up to three key-value pair in JSON format. For example:

        `{\\"attributes\\":{\\"string1\\":\\"string2\\"}}`
        """
        return pulumi.get(self, "attributes")

    @attributes.setter
    def attributes(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "attributes", value)


if not MYPY:
    class ThingGroupAttributePayloadArgsDict(TypedDict):
        attributes: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A JSON string containing up to three key-value pair in JSON format. For example:

        `{\\"attributes\\":{\\"string1\\":\\"string2\\"}}`
        """
elif False:
    ThingGroupAttributePayloadArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThingGroupAttributePayloadArgs:
    def __init__(__self__, *,
                 attributes: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] attributes: A JSON string containing up to three key-value pair in JSON format. For example:
               
               `{\\"attributes\\":{\\"string1\\":\\"string2\\"}}`
        """
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)

    @property
    @pulumi.getter
    def attributes(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A JSON string containing up to three key-value pair in JSON format. For example:

        `{\\"attributes\\":{\\"string1\\":\\"string2\\"}}`
        """
        return pulumi.get(self, "attributes")

    @attributes.setter
    def attributes(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "attributes", value)


if not MYPY:
    class ThingGroupPropertiesPropertiesArgsDict(TypedDict):
        """
        Thing group properties.
        """
        attribute_payload: NotRequired[pulumi.Input['ThingGroupAttributePayloadArgsDict']]
        """
        The thing group attributes in JSON format.
        """
        thing_group_description: NotRequired[pulumi.Input[str]]
        """
        The thing group description.
        """
elif False:
    ThingGroupPropertiesPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThingGroupPropertiesPropertiesArgs:
    def __init__(__self__, *,
                 attribute_payload: Optional[pulumi.Input['ThingGroupAttributePayloadArgs']] = None,
                 thing_group_description: Optional[pulumi.Input[str]] = None):
        """
        Thing group properties.
        :param pulumi.Input['ThingGroupAttributePayloadArgs'] attribute_payload: The thing group attributes in JSON format.
        :param pulumi.Input[str] thing_group_description: The thing group description.
        """
        if attribute_payload is not None:
            pulumi.set(__self__, "attribute_payload", attribute_payload)
        if thing_group_description is not None:
            pulumi.set(__self__, "thing_group_description", thing_group_description)

    @property
    @pulumi.getter(name="attributePayload")
    def attribute_payload(self) -> Optional[pulumi.Input['ThingGroupAttributePayloadArgs']]:
        """
        The thing group attributes in JSON format.
        """
        return pulumi.get(self, "attribute_payload")

    @attribute_payload.setter
    def attribute_payload(self, value: Optional[pulumi.Input['ThingGroupAttributePayloadArgs']]):
        pulumi.set(self, "attribute_payload", value)

    @property
    @pulumi.getter(name="thingGroupDescription")
    def thing_group_description(self) -> Optional[pulumi.Input[str]]:
        """
        The thing group description.
        """
        return pulumi.get(self, "thing_group_description")

    @thing_group_description.setter
    def thing_group_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "thing_group_description", value)


if not MYPY:
    class ThingTypePropagatingAttributeArgsDict(TypedDict):
        user_property_key: pulumi.Input[str]
        """
        The key of the MQTT 5 user property, which is a key-value pair.
        """
        connection_attribute: NotRequired[pulumi.Input['ThingTypePropagatingAttributeConnectionAttribute']]
        """
        The attribute associated with the connection details.
        """
        thing_attribute: NotRequired[pulumi.Input[str]]
        """
        The thing attribute that is propagating for MQTT 5 message enrichment.
        """
elif False:
    ThingTypePropagatingAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThingTypePropagatingAttributeArgs:
    def __init__(__self__, *,
                 user_property_key: pulumi.Input[str],
                 connection_attribute: Optional[pulumi.Input['ThingTypePropagatingAttributeConnectionAttribute']] = None,
                 thing_attribute: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] user_property_key: The key of the MQTT 5 user property, which is a key-value pair.
        :param pulumi.Input['ThingTypePropagatingAttributeConnectionAttribute'] connection_attribute: The attribute associated with the connection details.
        :param pulumi.Input[str] thing_attribute: The thing attribute that is propagating for MQTT 5 message enrichment.
        """
        pulumi.set(__self__, "user_property_key", user_property_key)
        if connection_attribute is not None:
            pulumi.set(__self__, "connection_attribute", connection_attribute)
        if thing_attribute is not None:
            pulumi.set(__self__, "thing_attribute", thing_attribute)

    @property
    @pulumi.getter(name="userPropertyKey")
    def user_property_key(self) -> pulumi.Input[str]:
        """
        The key of the MQTT 5 user property, which is a key-value pair.
        """
        return pulumi.get(self, "user_property_key")

    @user_property_key.setter
    def user_property_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "user_property_key", value)

    @property
    @pulumi.getter(name="connectionAttribute")
    def connection_attribute(self) -> Optional[pulumi.Input['ThingTypePropagatingAttributeConnectionAttribute']]:
        """
        The attribute associated with the connection details.
        """
        return pulumi.get(self, "connection_attribute")

    @connection_attribute.setter
    def connection_attribute(self, value: Optional[pulumi.Input['ThingTypePropagatingAttributeConnectionAttribute']]):
        pulumi.set(self, "connection_attribute", value)

    @property
    @pulumi.getter(name="thingAttribute")
    def thing_attribute(self) -> Optional[pulumi.Input[str]]:
        """
        The thing attribute that is propagating for MQTT 5 message enrichment.
        """
        return pulumi.get(self, "thing_attribute")

    @thing_attribute.setter
    def thing_attribute(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "thing_attribute", value)


if not MYPY:
    class ThingTypePropertiesPropertiesMqtt5ConfigurationPropertiesArgsDict(TypedDict):
        """
        The configuration to add user-defined properties to enrich MQTT 5 messages.
        """
        propagating_attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ThingTypePropagatingAttributeArgsDict']]]]
elif False:
    ThingTypePropertiesPropertiesMqtt5ConfigurationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThingTypePropertiesPropertiesMqtt5ConfigurationPropertiesArgs:
    def __init__(__self__, *,
                 propagating_attributes: Optional[pulumi.Input[Sequence[pulumi.Input['ThingTypePropagatingAttributeArgs']]]] = None):
        """
        The configuration to add user-defined properties to enrich MQTT 5 messages.
        """
        if propagating_attributes is not None:
            pulumi.set(__self__, "propagating_attributes", propagating_attributes)

    @property
    @pulumi.getter(name="propagatingAttributes")
    def propagating_attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ThingTypePropagatingAttributeArgs']]]]:
        return pulumi.get(self, "propagating_attributes")

    @propagating_attributes.setter
    def propagating_attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ThingTypePropagatingAttributeArgs']]]]):
        pulumi.set(self, "propagating_attributes", value)


if not MYPY:
    class ThingTypePropertiesPropertiesArgsDict(TypedDict):
        """
        The thing type properties for the thing type to create. It contains information about the new thing type including a description, a list of searchable thing attribute names, and a list of propagating attributes. After a thing type is created, you can only update `Mqtt5Configuration` .
        """
        mqtt5_configuration: NotRequired[pulumi.Input['ThingTypePropertiesPropertiesMqtt5ConfigurationPropertiesArgsDict']]
        """
        The configuration to add user-defined properties to enrich MQTT 5 messages.
        """
        searchable_attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of searchable thing attribute names.
        """
        thing_type_description: NotRequired[pulumi.Input[str]]
        """
        The description of the thing type.
        """
elif False:
    ThingTypePropertiesPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ThingTypePropertiesPropertiesArgs:
    def __init__(__self__, *,
                 mqtt5_configuration: Optional[pulumi.Input['ThingTypePropertiesPropertiesMqtt5ConfigurationPropertiesArgs']] = None,
                 searchable_attributes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 thing_type_description: Optional[pulumi.Input[str]] = None):
        """
        The thing type properties for the thing type to create. It contains information about the new thing type including a description, a list of searchable thing attribute names, and a list of propagating attributes. After a thing type is created, you can only update `Mqtt5Configuration` .
        :param pulumi.Input['ThingTypePropertiesPropertiesMqtt5ConfigurationPropertiesArgs'] mqtt5_configuration: The configuration to add user-defined properties to enrich MQTT 5 messages.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] searchable_attributes: A list of searchable thing attribute names.
        :param pulumi.Input[str] thing_type_description: The description of the thing type.
        """
        if mqtt5_configuration is not None:
            pulumi.set(__self__, "mqtt5_configuration", mqtt5_configuration)
        if searchable_attributes is not None:
            pulumi.set(__self__, "searchable_attributes", searchable_attributes)
        if thing_type_description is not None:
            pulumi.set(__self__, "thing_type_description", thing_type_description)

    @property
    @pulumi.getter(name="mqtt5Configuration")
    def mqtt5_configuration(self) -> Optional[pulumi.Input['ThingTypePropertiesPropertiesMqtt5ConfigurationPropertiesArgs']]:
        """
        The configuration to add user-defined properties to enrich MQTT 5 messages.
        """
        return pulumi.get(self, "mqtt5_configuration")

    @mqtt5_configuration.setter
    def mqtt5_configuration(self, value: Optional[pulumi.Input['ThingTypePropertiesPropertiesMqtt5ConfigurationPropertiesArgs']]):
        pulumi.set(self, "mqtt5_configuration", value)

    @property
    @pulumi.getter(name="searchableAttributes")
    def searchable_attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of searchable thing attribute names.
        """
        return pulumi.get(self, "searchable_attributes")

    @searchable_attributes.setter
    def searchable_attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "searchable_attributes", value)

    @property
    @pulumi.getter(name="thingTypeDescription")
    def thing_type_description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the thing type.
        """
        return pulumi.get(self, "thing_type_description")

    @thing_type_description.setter
    def thing_type_description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "thing_type_description", value)


if not MYPY:
    class TimeoutConfigPropertiesArgsDict(TypedDict):
        """
        Specifies the amount of time each device has to finish its execution of the job.
        """
        in_progress_timeout_in_minutes: pulumi.Input[int]
        """
        Specifies the amount of time, in minutes, this device has to finish execution of this job. The timeout interval can be anywhere between 1 minute and 7 days (1 to 10080 minutes). The in progress timer can't be updated and will apply to all job executions for the job. Whenever a job execution remains in the IN_PROGRESS status for longer than this interval, the job execution will fail and switch to the terminal `TIMED_OUT` status.
        """
elif False:
    TimeoutConfigPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TimeoutConfigPropertiesArgs:
    def __init__(__self__, *,
                 in_progress_timeout_in_minutes: pulumi.Input[int]):
        """
        Specifies the amount of time each device has to finish its execution of the job.
        :param pulumi.Input[int] in_progress_timeout_in_minutes: Specifies the amount of time, in minutes, this device has to finish execution of this job. The timeout interval can be anywhere between 1 minute and 7 days (1 to 10080 minutes). The in progress timer can't be updated and will apply to all job executions for the job. Whenever a job execution remains in the IN_PROGRESS status for longer than this interval, the job execution will fail and switch to the terminal `TIMED_OUT` status.
        """
        pulumi.set(__self__, "in_progress_timeout_in_minutes", in_progress_timeout_in_minutes)

    @property
    @pulumi.getter(name="inProgressTimeoutInMinutes")
    def in_progress_timeout_in_minutes(self) -> pulumi.Input[int]:
        """
        Specifies the amount of time, in minutes, this device has to finish execution of this job. The timeout interval can be anywhere between 1 minute and 7 days (1 to 10080 minutes). The in progress timer can't be updated and will apply to all job executions for the job. Whenever a job execution remains in the IN_PROGRESS status for longer than this interval, the job execution will fail and switch to the terminal `TIMED_OUT` status.
        """
        return pulumi.get(self, "in_progress_timeout_in_minutes")

    @in_progress_timeout_in_minutes.setter
    def in_progress_timeout_in_minutes(self, value: pulumi.Input[int]):
        pulumi.set(self, "in_progress_timeout_in_minutes", value)


if not MYPY:
    class TopicRuleActionArgsDict(TypedDict):
        cloudwatch_alarm: NotRequired[pulumi.Input['TopicRuleCloudwatchAlarmActionArgsDict']]
        """
        Change the state of a CloudWatch alarm.
        """
        cloudwatch_logs: NotRequired[pulumi.Input['TopicRuleCloudwatchLogsActionArgsDict']]
        """
        Sends data to CloudWatch.
        """
        cloudwatch_metric: NotRequired[pulumi.Input['TopicRuleCloudwatchMetricActionArgsDict']]
        """
        Capture a CloudWatch metric.
        """
        dynamo_d_bv2: NotRequired[pulumi.Input['TopicRuleDynamoDBv2ActionArgsDict']]
        """
        Write to a DynamoDB table. This is a new version of the DynamoDB action. It allows you to write each attribute in an MQTT message payload into a separate DynamoDB column.
        """
        dynamo_db: NotRequired[pulumi.Input['TopicRuleDynamoDbActionArgsDict']]
        """
        Write to a DynamoDB table.
        """
        elasticsearch: NotRequired[pulumi.Input['TopicRuleElasticsearchActionArgsDict']]
        """
        Write data to an Amazon OpenSearch Service domain.

        > The `Elasticsearch` action can only be used by existing rule actions. To create a new rule action or to update an existing rule action, use the `OpenSearch` rule action instead. For more information, see [OpenSearchAction](https://docs.aws.amazon.com//iot/latest/apireference/API_OpenSearchAction.html) .
        """
        firehose: NotRequired[pulumi.Input['TopicRuleFirehoseActionArgsDict']]
        """
        Write to an Amazon Kinesis Firehose stream.
        """
        http: NotRequired[pulumi.Input['TopicRuleHttpActionArgsDict']]
        """
        Send data to an HTTPS endpoint.
        """
        iot_analytics: NotRequired[pulumi.Input['TopicRuleIotAnalyticsActionArgsDict']]
        """
        Sends message data to an AWS IoT Analytics channel.
        """
        iot_events: NotRequired[pulumi.Input['TopicRuleIotEventsActionArgsDict']]
        """
        Sends an input to an AWS IoT Events detector.
        """
        iot_site_wise: NotRequired[pulumi.Input['TopicRuleIotSiteWiseActionArgsDict']]
        """
        Sends data from the MQTT message that triggered the rule to AWS IoT SiteWise asset properties.
        """
        kafka: NotRequired[pulumi.Input['TopicRuleKafkaActionArgsDict']]
        """
        Send messages to an Amazon Managed Streaming for Apache Kafka (Amazon MSK) or self-managed Apache Kafka cluster.
        """
        kinesis: NotRequired[pulumi.Input['TopicRuleKinesisActionArgsDict']]
        """
        Write data to an Amazon Kinesis stream.
        """
        lambda_: NotRequired[pulumi.Input['TopicRuleLambdaActionArgsDict']]
        """
        Invoke a Lambda function.
        """
        location: NotRequired[pulumi.Input['TopicRuleLocationActionArgsDict']]
        """
        Sends device location data to [Amazon Location Service](https://docs.aws.amazon.com//location/latest/developerguide/welcome.html) .
        """
        open_search: NotRequired[pulumi.Input['TopicRuleOpenSearchActionArgsDict']]
        """
        Write data to an Amazon OpenSearch Service domain.
        """
        republish: NotRequired[pulumi.Input['TopicRuleRepublishActionArgsDict']]
        """
        Publish to another MQTT topic.
        """
        s3: NotRequired[pulumi.Input['TopicRuleS3ActionArgsDict']]
        """
        Write to an Amazon S3 bucket.
        """
        sns: NotRequired[pulumi.Input['TopicRuleSnsActionArgsDict']]
        """
        Publish to an Amazon SNS topic.
        """
        sqs: NotRequired[pulumi.Input['TopicRuleSqsActionArgsDict']]
        """
        Publish to an Amazon SQS queue.
        """
        step_functions: NotRequired[pulumi.Input['TopicRuleStepFunctionsActionArgsDict']]
        """
        Starts execution of a Step Functions state machine.
        """
        timestream: NotRequired[pulumi.Input['TopicRuleTimestreamActionArgsDict']]
        """
        Writes attributes from an MQTT message.
        """
elif False:
    TopicRuleActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleActionArgs:
    def __init__(__self__, *,
                 cloudwatch_alarm: Optional[pulumi.Input['TopicRuleCloudwatchAlarmActionArgs']] = None,
                 cloudwatch_logs: Optional[pulumi.Input['TopicRuleCloudwatchLogsActionArgs']] = None,
                 cloudwatch_metric: Optional[pulumi.Input['TopicRuleCloudwatchMetricActionArgs']] = None,
                 dynamo_d_bv2: Optional[pulumi.Input['TopicRuleDynamoDBv2ActionArgs']] = None,
                 dynamo_db: Optional[pulumi.Input['TopicRuleDynamoDbActionArgs']] = None,
                 elasticsearch: Optional[pulumi.Input['TopicRuleElasticsearchActionArgs']] = None,
                 firehose: Optional[pulumi.Input['TopicRuleFirehoseActionArgs']] = None,
                 http: Optional[pulumi.Input['TopicRuleHttpActionArgs']] = None,
                 iot_analytics: Optional[pulumi.Input['TopicRuleIotAnalyticsActionArgs']] = None,
                 iot_events: Optional[pulumi.Input['TopicRuleIotEventsActionArgs']] = None,
                 iot_site_wise: Optional[pulumi.Input['TopicRuleIotSiteWiseActionArgs']] = None,
                 kafka: Optional[pulumi.Input['TopicRuleKafkaActionArgs']] = None,
                 kinesis: Optional[pulumi.Input['TopicRuleKinesisActionArgs']] = None,
                 lambda_: Optional[pulumi.Input['TopicRuleLambdaActionArgs']] = None,
                 location: Optional[pulumi.Input['TopicRuleLocationActionArgs']] = None,
                 open_search: Optional[pulumi.Input['TopicRuleOpenSearchActionArgs']] = None,
                 republish: Optional[pulumi.Input['TopicRuleRepublishActionArgs']] = None,
                 s3: Optional[pulumi.Input['TopicRuleS3ActionArgs']] = None,
                 sns: Optional[pulumi.Input['TopicRuleSnsActionArgs']] = None,
                 sqs: Optional[pulumi.Input['TopicRuleSqsActionArgs']] = None,
                 step_functions: Optional[pulumi.Input['TopicRuleStepFunctionsActionArgs']] = None,
                 timestream: Optional[pulumi.Input['TopicRuleTimestreamActionArgs']] = None):
        """
        :param pulumi.Input['TopicRuleCloudwatchAlarmActionArgs'] cloudwatch_alarm: Change the state of a CloudWatch alarm.
        :param pulumi.Input['TopicRuleCloudwatchLogsActionArgs'] cloudwatch_logs: Sends data to CloudWatch.
        :param pulumi.Input['TopicRuleCloudwatchMetricActionArgs'] cloudwatch_metric: Capture a CloudWatch metric.
        :param pulumi.Input['TopicRuleDynamoDBv2ActionArgs'] dynamo_d_bv2: Write to a DynamoDB table. This is a new version of the DynamoDB action. It allows you to write each attribute in an MQTT message payload into a separate DynamoDB column.
        :param pulumi.Input['TopicRuleDynamoDbActionArgs'] dynamo_db: Write to a DynamoDB table.
        :param pulumi.Input['TopicRuleElasticsearchActionArgs'] elasticsearch: Write data to an Amazon OpenSearch Service domain.
               
               > The `Elasticsearch` action can only be used by existing rule actions. To create a new rule action or to update an existing rule action, use the `OpenSearch` rule action instead. For more information, see [OpenSearchAction](https://docs.aws.amazon.com//iot/latest/apireference/API_OpenSearchAction.html) .
        :param pulumi.Input['TopicRuleFirehoseActionArgs'] firehose: Write to an Amazon Kinesis Firehose stream.
        :param pulumi.Input['TopicRuleHttpActionArgs'] http: Send data to an HTTPS endpoint.
        :param pulumi.Input['TopicRuleIotAnalyticsActionArgs'] iot_analytics: Sends message data to an AWS IoT Analytics channel.
        :param pulumi.Input['TopicRuleIotEventsActionArgs'] iot_events: Sends an input to an AWS IoT Events detector.
        :param pulumi.Input['TopicRuleIotSiteWiseActionArgs'] iot_site_wise: Sends data from the MQTT message that triggered the rule to AWS IoT SiteWise asset properties.
        :param pulumi.Input['TopicRuleKafkaActionArgs'] kafka: Send messages to an Amazon Managed Streaming for Apache Kafka (Amazon MSK) or self-managed Apache Kafka cluster.
        :param pulumi.Input['TopicRuleKinesisActionArgs'] kinesis: Write data to an Amazon Kinesis stream.
        :param pulumi.Input['TopicRuleLambdaActionArgs'] lambda_: Invoke a Lambda function.
        :param pulumi.Input['TopicRuleLocationActionArgs'] location: Sends device location data to [Amazon Location Service](https://docs.aws.amazon.com//location/latest/developerguide/welcome.html) .
        :param pulumi.Input['TopicRuleOpenSearchActionArgs'] open_search: Write data to an Amazon OpenSearch Service domain.
        :param pulumi.Input['TopicRuleRepublishActionArgs'] republish: Publish to another MQTT topic.
        :param pulumi.Input['TopicRuleS3ActionArgs'] s3: Write to an Amazon S3 bucket.
        :param pulumi.Input['TopicRuleSnsActionArgs'] sns: Publish to an Amazon SNS topic.
        :param pulumi.Input['TopicRuleSqsActionArgs'] sqs: Publish to an Amazon SQS queue.
        :param pulumi.Input['TopicRuleStepFunctionsActionArgs'] step_functions: Starts execution of a Step Functions state machine.
        :param pulumi.Input['TopicRuleTimestreamActionArgs'] timestream: Writes attributes from an MQTT message.
        """
        if cloudwatch_alarm is not None:
            pulumi.set(__self__, "cloudwatch_alarm", cloudwatch_alarm)
        if cloudwatch_logs is not None:
            pulumi.set(__self__, "cloudwatch_logs", cloudwatch_logs)
        if cloudwatch_metric is not None:
            pulumi.set(__self__, "cloudwatch_metric", cloudwatch_metric)
        if dynamo_d_bv2 is not None:
            pulumi.set(__self__, "dynamo_d_bv2", dynamo_d_bv2)
        if dynamo_db is not None:
            pulumi.set(__self__, "dynamo_db", dynamo_db)
        if elasticsearch is not None:
            pulumi.set(__self__, "elasticsearch", elasticsearch)
        if firehose is not None:
            pulumi.set(__self__, "firehose", firehose)
        if http is not None:
            pulumi.set(__self__, "http", http)
        if iot_analytics is not None:
            pulumi.set(__self__, "iot_analytics", iot_analytics)
        if iot_events is not None:
            pulumi.set(__self__, "iot_events", iot_events)
        if iot_site_wise is not None:
            pulumi.set(__self__, "iot_site_wise", iot_site_wise)
        if kafka is not None:
            pulumi.set(__self__, "kafka", kafka)
        if kinesis is not None:
            pulumi.set(__self__, "kinesis", kinesis)
        if lambda_ is not None:
            pulumi.set(__self__, "lambda_", lambda_)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if open_search is not None:
            pulumi.set(__self__, "open_search", open_search)
        if republish is not None:
            pulumi.set(__self__, "republish", republish)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)
        if sns is not None:
            pulumi.set(__self__, "sns", sns)
        if sqs is not None:
            pulumi.set(__self__, "sqs", sqs)
        if step_functions is not None:
            pulumi.set(__self__, "step_functions", step_functions)
        if timestream is not None:
            pulumi.set(__self__, "timestream", timestream)

    @property
    @pulumi.getter(name="cloudwatchAlarm")
    def cloudwatch_alarm(self) -> Optional[pulumi.Input['TopicRuleCloudwatchAlarmActionArgs']]:
        """
        Change the state of a CloudWatch alarm.
        """
        return pulumi.get(self, "cloudwatch_alarm")

    @cloudwatch_alarm.setter
    def cloudwatch_alarm(self, value: Optional[pulumi.Input['TopicRuleCloudwatchAlarmActionArgs']]):
        pulumi.set(self, "cloudwatch_alarm", value)

    @property
    @pulumi.getter(name="cloudwatchLogs")
    def cloudwatch_logs(self) -> Optional[pulumi.Input['TopicRuleCloudwatchLogsActionArgs']]:
        """
        Sends data to CloudWatch.
        """
        return pulumi.get(self, "cloudwatch_logs")

    @cloudwatch_logs.setter
    def cloudwatch_logs(self, value: Optional[pulumi.Input['TopicRuleCloudwatchLogsActionArgs']]):
        pulumi.set(self, "cloudwatch_logs", value)

    @property
    @pulumi.getter(name="cloudwatchMetric")
    def cloudwatch_metric(self) -> Optional[pulumi.Input['TopicRuleCloudwatchMetricActionArgs']]:
        """
        Capture a CloudWatch metric.
        """
        return pulumi.get(self, "cloudwatch_metric")

    @cloudwatch_metric.setter
    def cloudwatch_metric(self, value: Optional[pulumi.Input['TopicRuleCloudwatchMetricActionArgs']]):
        pulumi.set(self, "cloudwatch_metric", value)

    @property
    @pulumi.getter(name="dynamoDBv2")
    def dynamo_d_bv2(self) -> Optional[pulumi.Input['TopicRuleDynamoDBv2ActionArgs']]:
        """
        Write to a DynamoDB table. This is a new version of the DynamoDB action. It allows you to write each attribute in an MQTT message payload into a separate DynamoDB column.
        """
        return pulumi.get(self, "dynamo_d_bv2")

    @dynamo_d_bv2.setter
    def dynamo_d_bv2(self, value: Optional[pulumi.Input['TopicRuleDynamoDBv2ActionArgs']]):
        pulumi.set(self, "dynamo_d_bv2", value)

    @property
    @pulumi.getter(name="dynamoDb")
    def dynamo_db(self) -> Optional[pulumi.Input['TopicRuleDynamoDbActionArgs']]:
        """
        Write to a DynamoDB table.
        """
        return pulumi.get(self, "dynamo_db")

    @dynamo_db.setter
    def dynamo_db(self, value: Optional[pulumi.Input['TopicRuleDynamoDbActionArgs']]):
        pulumi.set(self, "dynamo_db", value)

    @property
    @pulumi.getter
    def elasticsearch(self) -> Optional[pulumi.Input['TopicRuleElasticsearchActionArgs']]:
        """
        Write data to an Amazon OpenSearch Service domain.

        > The `Elasticsearch` action can only be used by existing rule actions. To create a new rule action or to update an existing rule action, use the `OpenSearch` rule action instead. For more information, see [OpenSearchAction](https://docs.aws.amazon.com//iot/latest/apireference/API_OpenSearchAction.html) .
        """
        return pulumi.get(self, "elasticsearch")

    @elasticsearch.setter
    def elasticsearch(self, value: Optional[pulumi.Input['TopicRuleElasticsearchActionArgs']]):
        pulumi.set(self, "elasticsearch", value)

    @property
    @pulumi.getter
    def firehose(self) -> Optional[pulumi.Input['TopicRuleFirehoseActionArgs']]:
        """
        Write to an Amazon Kinesis Firehose stream.
        """
        return pulumi.get(self, "firehose")

    @firehose.setter
    def firehose(self, value: Optional[pulumi.Input['TopicRuleFirehoseActionArgs']]):
        pulumi.set(self, "firehose", value)

    @property
    @pulumi.getter
    def http(self) -> Optional[pulumi.Input['TopicRuleHttpActionArgs']]:
        """
        Send data to an HTTPS endpoint.
        """
        return pulumi.get(self, "http")

    @http.setter
    def http(self, value: Optional[pulumi.Input['TopicRuleHttpActionArgs']]):
        pulumi.set(self, "http", value)

    @property
    @pulumi.getter(name="iotAnalytics")
    def iot_analytics(self) -> Optional[pulumi.Input['TopicRuleIotAnalyticsActionArgs']]:
        """
        Sends message data to an AWS IoT Analytics channel.
        """
        return pulumi.get(self, "iot_analytics")

    @iot_analytics.setter
    def iot_analytics(self, value: Optional[pulumi.Input['TopicRuleIotAnalyticsActionArgs']]):
        pulumi.set(self, "iot_analytics", value)

    @property
    @pulumi.getter(name="iotEvents")
    def iot_events(self) -> Optional[pulumi.Input['TopicRuleIotEventsActionArgs']]:
        """
        Sends an input to an AWS IoT Events detector.
        """
        return pulumi.get(self, "iot_events")

    @iot_events.setter
    def iot_events(self, value: Optional[pulumi.Input['TopicRuleIotEventsActionArgs']]):
        pulumi.set(self, "iot_events", value)

    @property
    @pulumi.getter(name="iotSiteWise")
    def iot_site_wise(self) -> Optional[pulumi.Input['TopicRuleIotSiteWiseActionArgs']]:
        """
        Sends data from the MQTT message that triggered the rule to AWS IoT SiteWise asset properties.
        """
        return pulumi.get(self, "iot_site_wise")

    @iot_site_wise.setter
    def iot_site_wise(self, value: Optional[pulumi.Input['TopicRuleIotSiteWiseActionArgs']]):
        pulumi.set(self, "iot_site_wise", value)

    @property
    @pulumi.getter
    def kafka(self) -> Optional[pulumi.Input['TopicRuleKafkaActionArgs']]:
        """
        Send messages to an Amazon Managed Streaming for Apache Kafka (Amazon MSK) or self-managed Apache Kafka cluster.
        """
        return pulumi.get(self, "kafka")

    @kafka.setter
    def kafka(self, value: Optional[pulumi.Input['TopicRuleKafkaActionArgs']]):
        pulumi.set(self, "kafka", value)

    @property
    @pulumi.getter
    def kinesis(self) -> Optional[pulumi.Input['TopicRuleKinesisActionArgs']]:
        """
        Write data to an Amazon Kinesis stream.
        """
        return pulumi.get(self, "kinesis")

    @kinesis.setter
    def kinesis(self, value: Optional[pulumi.Input['TopicRuleKinesisActionArgs']]):
        pulumi.set(self, "kinesis", value)

    @property
    @pulumi.getter(name="lambda")
    def lambda_(self) -> Optional[pulumi.Input['TopicRuleLambdaActionArgs']]:
        """
        Invoke a Lambda function.
        """
        return pulumi.get(self, "lambda_")

    @lambda_.setter
    def lambda_(self, value: Optional[pulumi.Input['TopicRuleLambdaActionArgs']]):
        pulumi.set(self, "lambda_", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input['TopicRuleLocationActionArgs']]:
        """
        Sends device location data to [Amazon Location Service](https://docs.aws.amazon.com//location/latest/developerguide/welcome.html) .
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input['TopicRuleLocationActionArgs']]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter(name="openSearch")
    def open_search(self) -> Optional[pulumi.Input['TopicRuleOpenSearchActionArgs']]:
        """
        Write data to an Amazon OpenSearch Service domain.
        """
        return pulumi.get(self, "open_search")

    @open_search.setter
    def open_search(self, value: Optional[pulumi.Input['TopicRuleOpenSearchActionArgs']]):
        pulumi.set(self, "open_search", value)

    @property
    @pulumi.getter
    def republish(self) -> Optional[pulumi.Input['TopicRuleRepublishActionArgs']]:
        """
        Publish to another MQTT topic.
        """
        return pulumi.get(self, "republish")

    @republish.setter
    def republish(self, value: Optional[pulumi.Input['TopicRuleRepublishActionArgs']]):
        pulumi.set(self, "republish", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['TopicRuleS3ActionArgs']]:
        """
        Write to an Amazon S3 bucket.
        """
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['TopicRuleS3ActionArgs']]):
        pulumi.set(self, "s3", value)

    @property
    @pulumi.getter
    def sns(self) -> Optional[pulumi.Input['TopicRuleSnsActionArgs']]:
        """
        Publish to an Amazon SNS topic.
        """
        return pulumi.get(self, "sns")

    @sns.setter
    def sns(self, value: Optional[pulumi.Input['TopicRuleSnsActionArgs']]):
        pulumi.set(self, "sns", value)

    @property
    @pulumi.getter
    def sqs(self) -> Optional[pulumi.Input['TopicRuleSqsActionArgs']]:
        """
        Publish to an Amazon SQS queue.
        """
        return pulumi.get(self, "sqs")

    @sqs.setter
    def sqs(self, value: Optional[pulumi.Input['TopicRuleSqsActionArgs']]):
        pulumi.set(self, "sqs", value)

    @property
    @pulumi.getter(name="stepFunctions")
    def step_functions(self) -> Optional[pulumi.Input['TopicRuleStepFunctionsActionArgs']]:
        """
        Starts execution of a Step Functions state machine.
        """
        return pulumi.get(self, "step_functions")

    @step_functions.setter
    def step_functions(self, value: Optional[pulumi.Input['TopicRuleStepFunctionsActionArgs']]):
        pulumi.set(self, "step_functions", value)

    @property
    @pulumi.getter
    def timestream(self) -> Optional[pulumi.Input['TopicRuleTimestreamActionArgs']]:
        """
        Writes attributes from an MQTT message.
        """
        return pulumi.get(self, "timestream")

    @timestream.setter
    def timestream(self, value: Optional[pulumi.Input['TopicRuleTimestreamActionArgs']]):
        pulumi.set(self, "timestream", value)


if not MYPY:
    class TopicRuleAssetPropertyTimestampArgsDict(TypedDict):
        time_in_seconds: pulumi.Input[str]
        """
        A string that contains the time in seconds since epoch. Accepts substitution templates.
        """
        offset_in_nanos: NotRequired[pulumi.Input[str]]
        """
        Optional. A string that contains the nanosecond time offset. Accepts substitution templates.
        """
elif False:
    TopicRuleAssetPropertyTimestampArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleAssetPropertyTimestampArgs:
    def __init__(__self__, *,
                 time_in_seconds: pulumi.Input[str],
                 offset_in_nanos: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] time_in_seconds: A string that contains the time in seconds since epoch. Accepts substitution templates.
        :param pulumi.Input[str] offset_in_nanos: Optional. A string that contains the nanosecond time offset. Accepts substitution templates.
        """
        pulumi.set(__self__, "time_in_seconds", time_in_seconds)
        if offset_in_nanos is not None:
            pulumi.set(__self__, "offset_in_nanos", offset_in_nanos)

    @property
    @pulumi.getter(name="timeInSeconds")
    def time_in_seconds(self) -> pulumi.Input[str]:
        """
        A string that contains the time in seconds since epoch. Accepts substitution templates.
        """
        return pulumi.get(self, "time_in_seconds")

    @time_in_seconds.setter
    def time_in_seconds(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_in_seconds", value)

    @property
    @pulumi.getter(name="offsetInNanos")
    def offset_in_nanos(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. A string that contains the nanosecond time offset. Accepts substitution templates.
        """
        return pulumi.get(self, "offset_in_nanos")

    @offset_in_nanos.setter
    def offset_in_nanos(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "offset_in_nanos", value)


if not MYPY:
    class TopicRuleAssetPropertyValueArgsDict(TypedDict):
        timestamp: pulumi.Input['TopicRuleAssetPropertyTimestampArgsDict']
        """
        The asset property value timestamp.
        """
        value: pulumi.Input['TopicRuleAssetPropertyVariantArgsDict']
        """
        The value of the asset property.
        """
        quality: NotRequired[pulumi.Input[str]]
        """
        Optional. A string that describes the quality of the value. Accepts substitution templates. Must be `GOOD` , `BAD` , or `UNCERTAIN` .
        """
elif False:
    TopicRuleAssetPropertyValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleAssetPropertyValueArgs:
    def __init__(__self__, *,
                 timestamp: pulumi.Input['TopicRuleAssetPropertyTimestampArgs'],
                 value: pulumi.Input['TopicRuleAssetPropertyVariantArgs'],
                 quality: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['TopicRuleAssetPropertyTimestampArgs'] timestamp: The asset property value timestamp.
        :param pulumi.Input['TopicRuleAssetPropertyVariantArgs'] value: The value of the asset property.
        :param pulumi.Input[str] quality: Optional. A string that describes the quality of the value. Accepts substitution templates. Must be `GOOD` , `BAD` , or `UNCERTAIN` .
        """
        pulumi.set(__self__, "timestamp", timestamp)
        pulumi.set(__self__, "value", value)
        if quality is not None:
            pulumi.set(__self__, "quality", quality)

    @property
    @pulumi.getter
    def timestamp(self) -> pulumi.Input['TopicRuleAssetPropertyTimestampArgs']:
        """
        The asset property value timestamp.
        """
        return pulumi.get(self, "timestamp")

    @timestamp.setter
    def timestamp(self, value: pulumi.Input['TopicRuleAssetPropertyTimestampArgs']):
        pulumi.set(self, "timestamp", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input['TopicRuleAssetPropertyVariantArgs']:
        """
        The value of the asset property.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input['TopicRuleAssetPropertyVariantArgs']):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def quality(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. A string that describes the quality of the value. Accepts substitution templates. Must be `GOOD` , `BAD` , or `UNCERTAIN` .
        """
        return pulumi.get(self, "quality")

    @quality.setter
    def quality(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "quality", value)


if not MYPY:
    class TopicRuleAssetPropertyVariantArgsDict(TypedDict):
        boolean_value: NotRequired[pulumi.Input[str]]
        """
        Optional. A string that contains the boolean value ( `true` or `false` ) of the value entry. Accepts substitution templates.
        """
        double_value: NotRequired[pulumi.Input[str]]
        """
        Optional. A string that contains the double value of the value entry. Accepts substitution templates.
        """
        integer_value: NotRequired[pulumi.Input[str]]
        """
        Optional. A string that contains the integer value of the value entry. Accepts substitution templates.
        """
        string_value: NotRequired[pulumi.Input[str]]
        """
        Optional. The string value of the value entry. Accepts substitution templates.
        """
elif False:
    TopicRuleAssetPropertyVariantArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleAssetPropertyVariantArgs:
    def __init__(__self__, *,
                 boolean_value: Optional[pulumi.Input[str]] = None,
                 double_value: Optional[pulumi.Input[str]] = None,
                 integer_value: Optional[pulumi.Input[str]] = None,
                 string_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] boolean_value: Optional. A string that contains the boolean value ( `true` or `false` ) of the value entry. Accepts substitution templates.
        :param pulumi.Input[str] double_value: Optional. A string that contains the double value of the value entry. Accepts substitution templates.
        :param pulumi.Input[str] integer_value: Optional. A string that contains the integer value of the value entry. Accepts substitution templates.
        :param pulumi.Input[str] string_value: Optional. The string value of the value entry. Accepts substitution templates.
        """
        if boolean_value is not None:
            pulumi.set(__self__, "boolean_value", boolean_value)
        if double_value is not None:
            pulumi.set(__self__, "double_value", double_value)
        if integer_value is not None:
            pulumi.set(__self__, "integer_value", integer_value)
        if string_value is not None:
            pulumi.set(__self__, "string_value", string_value)

    @property
    @pulumi.getter(name="booleanValue")
    def boolean_value(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. A string that contains the boolean value ( `true` or `false` ) of the value entry. Accepts substitution templates.
        """
        return pulumi.get(self, "boolean_value")

    @boolean_value.setter
    def boolean_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "boolean_value", value)

    @property
    @pulumi.getter(name="doubleValue")
    def double_value(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. A string that contains the double value of the value entry. Accepts substitution templates.
        """
        return pulumi.get(self, "double_value")

    @double_value.setter
    def double_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "double_value", value)

    @property
    @pulumi.getter(name="integerValue")
    def integer_value(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. A string that contains the integer value of the value entry. Accepts substitution templates.
        """
        return pulumi.get(self, "integer_value")

    @integer_value.setter
    def integer_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "integer_value", value)

    @property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. The string value of the value entry. Accepts substitution templates.
        """
        return pulumi.get(self, "string_value")

    @string_value.setter
    def string_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "string_value", value)


if not MYPY:
    class TopicRuleCloudwatchAlarmActionArgsDict(TypedDict):
        alarm_name: pulumi.Input[str]
        """
        The CloudWatch alarm name.
        """
        role_arn: pulumi.Input[str]
        """
        The IAM role that allows access to the CloudWatch alarm.
        """
        state_reason: pulumi.Input[str]
        """
        The reason for the alarm change.
        """
        state_value: pulumi.Input[str]
        """
        The value of the alarm state. Acceptable values are: OK, ALARM, INSUFFICIENT_DATA.
        """
elif False:
    TopicRuleCloudwatchAlarmActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleCloudwatchAlarmActionArgs:
    def __init__(__self__, *,
                 alarm_name: pulumi.Input[str],
                 role_arn: pulumi.Input[str],
                 state_reason: pulumi.Input[str],
                 state_value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] alarm_name: The CloudWatch alarm name.
        :param pulumi.Input[str] role_arn: The IAM role that allows access to the CloudWatch alarm.
        :param pulumi.Input[str] state_reason: The reason for the alarm change.
        :param pulumi.Input[str] state_value: The value of the alarm state. Acceptable values are: OK, ALARM, INSUFFICIENT_DATA.
        """
        pulumi.set(__self__, "alarm_name", alarm_name)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "state_reason", state_reason)
        pulumi.set(__self__, "state_value", state_value)

    @property
    @pulumi.getter(name="alarmName")
    def alarm_name(self) -> pulumi.Input[str]:
        """
        The CloudWatch alarm name.
        """
        return pulumi.get(self, "alarm_name")

    @alarm_name.setter
    def alarm_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "alarm_name", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The IAM role that allows access to the CloudWatch alarm.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="stateReason")
    def state_reason(self) -> pulumi.Input[str]:
        """
        The reason for the alarm change.
        """
        return pulumi.get(self, "state_reason")

    @state_reason.setter
    def state_reason(self, value: pulumi.Input[str]):
        pulumi.set(self, "state_reason", value)

    @property
    @pulumi.getter(name="stateValue")
    def state_value(self) -> pulumi.Input[str]:
        """
        The value of the alarm state. Acceptable values are: OK, ALARM, INSUFFICIENT_DATA.
        """
        return pulumi.get(self, "state_value")

    @state_value.setter
    def state_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "state_value", value)


if not MYPY:
    class TopicRuleCloudwatchLogsActionArgsDict(TypedDict):
        log_group_name: pulumi.Input[str]
        """
        The CloudWatch log name.
        """
        role_arn: pulumi.Input[str]
        """
        The IAM role that allows access to the CloudWatch log.
        """
        batch_mode: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether batches of log records will be extracted and uploaded into CloudWatch.
        """
elif False:
    TopicRuleCloudwatchLogsActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleCloudwatchLogsActionArgs:
    def __init__(__self__, *,
                 log_group_name: pulumi.Input[str],
                 role_arn: pulumi.Input[str],
                 batch_mode: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] log_group_name: The CloudWatch log name.
        :param pulumi.Input[str] role_arn: The IAM role that allows access to the CloudWatch log.
        :param pulumi.Input[bool] batch_mode: Indicates whether batches of log records will be extracted and uploaded into CloudWatch.
        """
        pulumi.set(__self__, "log_group_name", log_group_name)
        pulumi.set(__self__, "role_arn", role_arn)
        if batch_mode is not None:
            pulumi.set(__self__, "batch_mode", batch_mode)

    @property
    @pulumi.getter(name="logGroupName")
    def log_group_name(self) -> pulumi.Input[str]:
        """
        The CloudWatch log name.
        """
        return pulumi.get(self, "log_group_name")

    @log_group_name.setter
    def log_group_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "log_group_name", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The IAM role that allows access to the CloudWatch log.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="batchMode")
    def batch_mode(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether batches of log records will be extracted and uploaded into CloudWatch.
        """
        return pulumi.get(self, "batch_mode")

    @batch_mode.setter
    def batch_mode(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "batch_mode", value)


if not MYPY:
    class TopicRuleCloudwatchMetricActionArgsDict(TypedDict):
        metric_name: pulumi.Input[str]
        """
        The CloudWatch metric name.
        """
        metric_namespace: pulumi.Input[str]
        """
        The CloudWatch metric namespace name.
        """
        metric_unit: pulumi.Input[str]
        """
        The [metric unit](https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#Unit) supported by CloudWatch.
        """
        metric_value: pulumi.Input[str]
        """
        The CloudWatch metric value.
        """
        role_arn: pulumi.Input[str]
        """
        The IAM role that allows access to the CloudWatch metric.
        """
        metric_timestamp: NotRequired[pulumi.Input[str]]
        """
        An optional [Unix timestamp](https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#about_timestamp) .
        """
elif False:
    TopicRuleCloudwatchMetricActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleCloudwatchMetricActionArgs:
    def __init__(__self__, *,
                 metric_name: pulumi.Input[str],
                 metric_namespace: pulumi.Input[str],
                 metric_unit: pulumi.Input[str],
                 metric_value: pulumi.Input[str],
                 role_arn: pulumi.Input[str],
                 metric_timestamp: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metric_name: The CloudWatch metric name.
        :param pulumi.Input[str] metric_namespace: The CloudWatch metric namespace name.
        :param pulumi.Input[str] metric_unit: The [metric unit](https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#Unit) supported by CloudWatch.
        :param pulumi.Input[str] metric_value: The CloudWatch metric value.
        :param pulumi.Input[str] role_arn: The IAM role that allows access to the CloudWatch metric.
        :param pulumi.Input[str] metric_timestamp: An optional [Unix timestamp](https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#about_timestamp) .
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "metric_namespace", metric_namespace)
        pulumi.set(__self__, "metric_unit", metric_unit)
        pulumi.set(__self__, "metric_value", metric_value)
        pulumi.set(__self__, "role_arn", role_arn)
        if metric_timestamp is not None:
            pulumi.set(__self__, "metric_timestamp", metric_timestamp)

    @property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[str]:
        """
        The CloudWatch metric name.
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_name", value)

    @property
    @pulumi.getter(name="metricNamespace")
    def metric_namespace(self) -> pulumi.Input[str]:
        """
        The CloudWatch metric namespace name.
        """
        return pulumi.get(self, "metric_namespace")

    @metric_namespace.setter
    def metric_namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_namespace", value)

    @property
    @pulumi.getter(name="metricUnit")
    def metric_unit(self) -> pulumi.Input[str]:
        """
        The [metric unit](https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#Unit) supported by CloudWatch.
        """
        return pulumi.get(self, "metric_unit")

    @metric_unit.setter
    def metric_unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_unit", value)

    @property
    @pulumi.getter(name="metricValue")
    def metric_value(self) -> pulumi.Input[str]:
        """
        The CloudWatch metric value.
        """
        return pulumi.get(self, "metric_value")

    @metric_value.setter
    def metric_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric_value", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The IAM role that allows access to the CloudWatch metric.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="metricTimestamp")
    def metric_timestamp(self) -> Optional[pulumi.Input[str]]:
        """
        An optional [Unix timestamp](https://docs.aws.amazon.com/AmazonCloudWatch/latest/DeveloperGuide/cloudwatch_concepts.html#about_timestamp) .
        """
        return pulumi.get(self, "metric_timestamp")

    @metric_timestamp.setter
    def metric_timestamp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metric_timestamp", value)


if not MYPY:
    class TopicRuleDestinationHttpUrlDestinationSummaryArgsDict(TypedDict):
        confirmation_url: NotRequired[pulumi.Input[str]]
        """
        The URL used to confirm the HTTP topic rule destination URL.
        """
elif False:
    TopicRuleDestinationHttpUrlDestinationSummaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleDestinationHttpUrlDestinationSummaryArgs:
    def __init__(__self__, *,
                 confirmation_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] confirmation_url: The URL used to confirm the HTTP topic rule destination URL.
        """
        if confirmation_url is not None:
            pulumi.set(__self__, "confirmation_url", confirmation_url)

    @property
    @pulumi.getter(name="confirmationUrl")
    def confirmation_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL used to confirm the HTTP topic rule destination URL.
        """
        return pulumi.get(self, "confirmation_url")

    @confirmation_url.setter
    def confirmation_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "confirmation_url", value)


if not MYPY:
    class TopicRuleDestinationVpcDestinationPropertiesArgsDict(TypedDict):
        role_arn: NotRequired[pulumi.Input[str]]
        """
        The ARN of a role that has permission to create and attach to elastic network interfaces (ENIs).
        """
        security_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The security groups of the VPC destination.
        """
        subnet_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The subnet IDs of the VPC destination.
        """
        vpc_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the VPC.
        """
elif False:
    TopicRuleDestinationVpcDestinationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleDestinationVpcDestinationPropertiesArgs:
    def __init__(__self__, *,
                 role_arn: Optional[pulumi.Input[str]] = None,
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 subnet_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 vpc_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] role_arn: The ARN of a role that has permission to create and attach to elastic network interfaces (ENIs).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_groups: The security groups of the VPC destination.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subnet_ids: The subnet IDs of the VPC destination.
        :param pulumi.Input[str] vpc_id: The ID of the VPC.
        """
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if subnet_ids is not None:
            pulumi.set(__self__, "subnet_ids", subnet_ids)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The ARN of a role that has permission to create and attach to elastic network interfaces (ENIs).
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The security groups of the VPC destination.
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_groups", value)

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The subnet IDs of the VPC destination.
        """
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "subnet_ids", value)

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the VPC.
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_id", value)


if not MYPY:
    class TopicRuleDynamoDBv2ActionArgsDict(TypedDict):
        put_item: NotRequired[pulumi.Input['TopicRulePutItemInputArgsDict']]
        """
        Specifies the DynamoDB table to which the message data will be written. For example:

        `{ "dynamoDBv2": { "roleArn": "aws:iam:12341251:my-role" "putItem": { "tableName": "my-table" } } }`

        Each attribute in the message payload will be written to a separate column in the DynamoDB database.
        """
        role_arn: NotRequired[pulumi.Input[str]]
        """
        The ARN of the IAM role that grants access to the DynamoDB table.
        """
elif False:
    TopicRuleDynamoDBv2ActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleDynamoDBv2ActionArgs:
    def __init__(__self__, *,
                 put_item: Optional[pulumi.Input['TopicRulePutItemInputArgs']] = None,
                 role_arn: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['TopicRulePutItemInputArgs'] put_item: Specifies the DynamoDB table to which the message data will be written. For example:
               
               `{ "dynamoDBv2": { "roleArn": "aws:iam:12341251:my-role" "putItem": { "tableName": "my-table" } } }`
               
               Each attribute in the message payload will be written to a separate column in the DynamoDB database.
        :param pulumi.Input[str] role_arn: The ARN of the IAM role that grants access to the DynamoDB table.
        """
        if put_item is not None:
            pulumi.set(__self__, "put_item", put_item)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter(name="putItem")
    def put_item(self) -> Optional[pulumi.Input['TopicRulePutItemInputArgs']]:
        """
        Specifies the DynamoDB table to which the message data will be written. For example:

        `{ "dynamoDBv2": { "roleArn": "aws:iam:12341251:my-role" "putItem": { "tableName": "my-table" } } }`

        Each attribute in the message payload will be written to a separate column in the DynamoDB database.
        """
        return pulumi.get(self, "put_item")

    @put_item.setter
    def put_item(self, value: Optional[pulumi.Input['TopicRulePutItemInputArgs']]):
        pulumi.set(self, "put_item", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The ARN of the IAM role that grants access to the DynamoDB table.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role_arn", value)


if not MYPY:
    class TopicRuleDynamoDbActionArgsDict(TypedDict):
        hash_key_field: pulumi.Input[str]
        """
        The hash key name.
        """
        hash_key_value: pulumi.Input[str]
        """
        The hash key value.
        """
        role_arn: pulumi.Input[str]
        """
        The ARN of the IAM role that grants access to the DynamoDB table.
        """
        table_name: pulumi.Input[str]
        """
        The name of the DynamoDB table.
        """
        hash_key_type: NotRequired[pulumi.Input[str]]
        """
        The hash key type. Valid values are "STRING" or "NUMBER"
        """
        payload_field: NotRequired[pulumi.Input[str]]
        """
        The action payload. This name can be customized.
        """
        range_key_field: NotRequired[pulumi.Input[str]]
        """
        The range key name.
        """
        range_key_type: NotRequired[pulumi.Input[str]]
        """
        The range key type. Valid values are "STRING" or "NUMBER"
        """
        range_key_value: NotRequired[pulumi.Input[str]]
        """
        The range key value.
        """
elif False:
    TopicRuleDynamoDbActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleDynamoDbActionArgs:
    def __init__(__self__, *,
                 hash_key_field: pulumi.Input[str],
                 hash_key_value: pulumi.Input[str],
                 role_arn: pulumi.Input[str],
                 table_name: pulumi.Input[str],
                 hash_key_type: Optional[pulumi.Input[str]] = None,
                 payload_field: Optional[pulumi.Input[str]] = None,
                 range_key_field: Optional[pulumi.Input[str]] = None,
                 range_key_type: Optional[pulumi.Input[str]] = None,
                 range_key_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] hash_key_field: The hash key name.
        :param pulumi.Input[str] hash_key_value: The hash key value.
        :param pulumi.Input[str] role_arn: The ARN of the IAM role that grants access to the DynamoDB table.
        :param pulumi.Input[str] table_name: The name of the DynamoDB table.
        :param pulumi.Input[str] hash_key_type: The hash key type. Valid values are "STRING" or "NUMBER"
        :param pulumi.Input[str] payload_field: The action payload. This name can be customized.
        :param pulumi.Input[str] range_key_field: The range key name.
        :param pulumi.Input[str] range_key_type: The range key type. Valid values are "STRING" or "NUMBER"
        :param pulumi.Input[str] range_key_value: The range key value.
        """
        pulumi.set(__self__, "hash_key_field", hash_key_field)
        pulumi.set(__self__, "hash_key_value", hash_key_value)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "table_name", table_name)
        if hash_key_type is not None:
            pulumi.set(__self__, "hash_key_type", hash_key_type)
        if payload_field is not None:
            pulumi.set(__self__, "payload_field", payload_field)
        if range_key_field is not None:
            pulumi.set(__self__, "range_key_field", range_key_field)
        if range_key_type is not None:
            pulumi.set(__self__, "range_key_type", range_key_type)
        if range_key_value is not None:
            pulumi.set(__self__, "range_key_value", range_key_value)

    @property
    @pulumi.getter(name="hashKeyField")
    def hash_key_field(self) -> pulumi.Input[str]:
        """
        The hash key name.
        """
        return pulumi.get(self, "hash_key_field")

    @hash_key_field.setter
    def hash_key_field(self, value: pulumi.Input[str]):
        pulumi.set(self, "hash_key_field", value)

    @property
    @pulumi.getter(name="hashKeyValue")
    def hash_key_value(self) -> pulumi.Input[str]:
        """
        The hash key value.
        """
        return pulumi.get(self, "hash_key_value")

    @hash_key_value.setter
    def hash_key_value(self, value: pulumi.Input[str]):
        pulumi.set(self, "hash_key_value", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the IAM role that grants access to the DynamoDB table.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[str]:
        """
        The name of the DynamoDB table.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "table_name", value)

    @property
    @pulumi.getter(name="hashKeyType")
    def hash_key_type(self) -> Optional[pulumi.Input[str]]:
        """
        The hash key type. Valid values are "STRING" or "NUMBER"
        """
        return pulumi.get(self, "hash_key_type")

    @hash_key_type.setter
    def hash_key_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hash_key_type", value)

    @property
    @pulumi.getter(name="payloadField")
    def payload_field(self) -> Optional[pulumi.Input[str]]:
        """
        The action payload. This name can be customized.
        """
        return pulumi.get(self, "payload_field")

    @payload_field.setter
    def payload_field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "payload_field", value)

    @property
    @pulumi.getter(name="rangeKeyField")
    def range_key_field(self) -> Optional[pulumi.Input[str]]:
        """
        The range key name.
        """
        return pulumi.get(self, "range_key_field")

    @range_key_field.setter
    def range_key_field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "range_key_field", value)

    @property
    @pulumi.getter(name="rangeKeyType")
    def range_key_type(self) -> Optional[pulumi.Input[str]]:
        """
        The range key type. Valid values are "STRING" or "NUMBER"
        """
        return pulumi.get(self, "range_key_type")

    @range_key_type.setter
    def range_key_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "range_key_type", value)

    @property
    @pulumi.getter(name="rangeKeyValue")
    def range_key_value(self) -> Optional[pulumi.Input[str]]:
        """
        The range key value.
        """
        return pulumi.get(self, "range_key_value")

    @range_key_value.setter
    def range_key_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "range_key_value", value)


if not MYPY:
    class TopicRuleElasticsearchActionArgsDict(TypedDict):
        endpoint: pulumi.Input[str]
        """
        The endpoint of your OpenSearch domain.
        """
        id: pulumi.Input[str]
        """
        The unique identifier for the document you are storing.
        """
        index: pulumi.Input[str]
        """
        The index where you want to store your data.
        """
        role_arn: pulumi.Input[str]
        """
        The IAM role ARN that has access to OpenSearch.
        """
        type: pulumi.Input[str]
        """
        The type of document you are storing.
        """
elif False:
    TopicRuleElasticsearchActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleElasticsearchActionArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[str],
                 id: pulumi.Input[str],
                 index: pulumi.Input[str],
                 role_arn: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] endpoint: The endpoint of your OpenSearch domain.
        :param pulumi.Input[str] id: The unique identifier for the document you are storing.
        :param pulumi.Input[str] index: The index where you want to store your data.
        :param pulumi.Input[str] role_arn: The IAM role ARN that has access to OpenSearch.
        :param pulumi.Input[str] type: The type of document you are storing.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[str]:
        """
        The endpoint of your OpenSearch domain.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The unique identifier for the document you are storing.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The index where you want to store your data.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The IAM role ARN that has access to OpenSearch.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of document you are storing.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class TopicRuleFirehoseActionArgsDict(TypedDict):
        delivery_stream_name: pulumi.Input[str]
        """
        The delivery stream name.
        """
        role_arn: pulumi.Input[str]
        """
        The IAM role that grants access to the Amazon Kinesis Firehose stream.
        """
        batch_mode: NotRequired[pulumi.Input[bool]]
        """
        Whether to deliver the Kinesis Data Firehose stream as a batch by using [`PutRecordBatch`](https://docs.aws.amazon.com/firehose/latest/APIReference/API_PutRecordBatch.html) . The default value is `false` .

        When `batchMode` is `true` and the rule's SQL statement evaluates to an Array, each Array element forms one record in the [`PutRecordBatch`](https://docs.aws.amazon.com/firehose/latest/APIReference/API_PutRecordBatch.html) request. The resulting array can't have more than 500 records.
        """
        separator: NotRequired[pulumi.Input[str]]
        """
        A character separator that will be used to separate records written to the Firehose stream. Valid values are: '\\n' (newline), '\\t' (tab), '\\r\\n' (Windows newline), ',' (comma).
        """
elif False:
    TopicRuleFirehoseActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleFirehoseActionArgs:
    def __init__(__self__, *,
                 delivery_stream_name: pulumi.Input[str],
                 role_arn: pulumi.Input[str],
                 batch_mode: Optional[pulumi.Input[bool]] = None,
                 separator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] delivery_stream_name: The delivery stream name.
        :param pulumi.Input[str] role_arn: The IAM role that grants access to the Amazon Kinesis Firehose stream.
        :param pulumi.Input[bool] batch_mode: Whether to deliver the Kinesis Data Firehose stream as a batch by using [`PutRecordBatch`](https://docs.aws.amazon.com/firehose/latest/APIReference/API_PutRecordBatch.html) . The default value is `false` .
               
               When `batchMode` is `true` and the rule's SQL statement evaluates to an Array, each Array element forms one record in the [`PutRecordBatch`](https://docs.aws.amazon.com/firehose/latest/APIReference/API_PutRecordBatch.html) request. The resulting array can't have more than 500 records.
        :param pulumi.Input[str] separator: A character separator that will be used to separate records written to the Firehose stream. Valid values are: '\\n' (newline), '\\t' (tab), '\\r\\n' (Windows newline), ',' (comma).
        """
        pulumi.set(__self__, "delivery_stream_name", delivery_stream_name)
        pulumi.set(__self__, "role_arn", role_arn)
        if batch_mode is not None:
            pulumi.set(__self__, "batch_mode", batch_mode)
        if separator is not None:
            pulumi.set(__self__, "separator", separator)

    @property
    @pulumi.getter(name="deliveryStreamName")
    def delivery_stream_name(self) -> pulumi.Input[str]:
        """
        The delivery stream name.
        """
        return pulumi.get(self, "delivery_stream_name")

    @delivery_stream_name.setter
    def delivery_stream_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "delivery_stream_name", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The IAM role that grants access to the Amazon Kinesis Firehose stream.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="batchMode")
    def batch_mode(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to deliver the Kinesis Data Firehose stream as a batch by using [`PutRecordBatch`](https://docs.aws.amazon.com/firehose/latest/APIReference/API_PutRecordBatch.html) . The default value is `false` .

        When `batchMode` is `true` and the rule's SQL statement evaluates to an Array, each Array element forms one record in the [`PutRecordBatch`](https://docs.aws.amazon.com/firehose/latest/APIReference/API_PutRecordBatch.html) request. The resulting array can't have more than 500 records.
        """
        return pulumi.get(self, "batch_mode")

    @batch_mode.setter
    def batch_mode(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "batch_mode", value)

    @property
    @pulumi.getter
    def separator(self) -> Optional[pulumi.Input[str]]:
        """
        A character separator that will be used to separate records written to the Firehose stream. Valid values are: '\\n' (newline), '\\t' (tab), '\\r\\n' (Windows newline), ',' (comma).
        """
        return pulumi.get(self, "separator")

    @separator.setter
    def separator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "separator", value)


if not MYPY:
    class TopicRuleHttpActionHeaderArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        The HTTP header key.
        """
        value: pulumi.Input[str]
        """
        The HTTP header value. Substitution templates are supported.
        """
elif False:
    TopicRuleHttpActionHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleHttpActionHeaderArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: The HTTP header key.
        :param pulumi.Input[str] value: The HTTP header value. Substitution templates are supported.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The HTTP header key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The HTTP header value. Substitution templates are supported.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class TopicRuleHttpActionArgsDict(TypedDict):
        url: pulumi.Input[str]
        """
        The endpoint URL. If substitution templates are used in the URL, you must also specify a `confirmationUrl` . If this is a new destination, a new `TopicRuleDestination` is created if possible.
        """
        auth: NotRequired[pulumi.Input['TopicRuleHttpAuthorizationArgsDict']]
        """
        The authentication method to use when sending data to an HTTPS endpoint.
        """
        confirmation_url: NotRequired[pulumi.Input[str]]
        """
        The URL to which AWS IoT sends a confirmation message. The value of the confirmation URL must be a prefix of the endpoint URL. If you do not specify a confirmation URL AWS IoT uses the endpoint URL as the confirmation URL. If you use substitution templates in the confirmationUrl, you must create and enable topic rule destinations that match each possible value of the substitution template before traffic is allowed to your endpoint URL.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['TopicRuleHttpActionHeaderArgsDict']]]]
        """
        The HTTP headers to send with the message data.
        """
elif False:
    TopicRuleHttpActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleHttpActionArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 auth: Optional[pulumi.Input['TopicRuleHttpAuthorizationArgs']] = None,
                 confirmation_url: Optional[pulumi.Input[str]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['TopicRuleHttpActionHeaderArgs']]]] = None):
        """
        :param pulumi.Input[str] url: The endpoint URL. If substitution templates are used in the URL, you must also specify a `confirmationUrl` . If this is a new destination, a new `TopicRuleDestination` is created if possible.
        :param pulumi.Input['TopicRuleHttpAuthorizationArgs'] auth: The authentication method to use when sending data to an HTTPS endpoint.
        :param pulumi.Input[str] confirmation_url: The URL to which AWS IoT sends a confirmation message. The value of the confirmation URL must be a prefix of the endpoint URL. If you do not specify a confirmation URL AWS IoT uses the endpoint URL as the confirmation URL. If you use substitution templates in the confirmationUrl, you must create and enable topic rule destinations that match each possible value of the substitution template before traffic is allowed to your endpoint URL.
        :param pulumi.Input[Sequence[pulumi.Input['TopicRuleHttpActionHeaderArgs']]] headers: The HTTP headers to send with the message data.
        """
        pulumi.set(__self__, "url", url)
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if confirmation_url is not None:
            pulumi.set(__self__, "confirmation_url", confirmation_url)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The endpoint URL. If substitution templates are used in the URL, you must also specify a `confirmationUrl` . If this is a new destination, a new `TopicRuleDestination` is created if possible.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def auth(self) -> Optional[pulumi.Input['TopicRuleHttpAuthorizationArgs']]:
        """
        The authentication method to use when sending data to an HTTPS endpoint.
        """
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: Optional[pulumi.Input['TopicRuleHttpAuthorizationArgs']]):
        pulumi.set(self, "auth", value)

    @property
    @pulumi.getter(name="confirmationUrl")
    def confirmation_url(self) -> Optional[pulumi.Input[str]]:
        """
        The URL to which AWS IoT sends a confirmation message. The value of the confirmation URL must be a prefix of the endpoint URL. If you do not specify a confirmation URL AWS IoT uses the endpoint URL as the confirmation URL. If you use substitution templates in the confirmationUrl, you must create and enable topic rule destinations that match each possible value of the substitution template before traffic is allowed to your endpoint URL.
        """
        return pulumi.get(self, "confirmation_url")

    @confirmation_url.setter
    def confirmation_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "confirmation_url", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TopicRuleHttpActionHeaderArgs']]]]:
        """
        The HTTP headers to send with the message data.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TopicRuleHttpActionHeaderArgs']]]]):
        pulumi.set(self, "headers", value)


if not MYPY:
    class TopicRuleHttpAuthorizationArgsDict(TypedDict):
        sigv4: NotRequired[pulumi.Input['TopicRuleSigV4AuthorizationArgsDict']]
        """
        Use Sig V4 authorization. For more information, see [Signature Version 4 Signing Process](https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html) .
        """
elif False:
    TopicRuleHttpAuthorizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleHttpAuthorizationArgs:
    def __init__(__self__, *,
                 sigv4: Optional[pulumi.Input['TopicRuleSigV4AuthorizationArgs']] = None):
        """
        :param pulumi.Input['TopicRuleSigV4AuthorizationArgs'] sigv4: Use Sig V4 authorization. For more information, see [Signature Version 4 Signing Process](https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html) .
        """
        if sigv4 is not None:
            pulumi.set(__self__, "sigv4", sigv4)

    @property
    @pulumi.getter
    def sigv4(self) -> Optional[pulumi.Input['TopicRuleSigV4AuthorizationArgs']]:
        """
        Use Sig V4 authorization. For more information, see [Signature Version 4 Signing Process](https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html) .
        """
        return pulumi.get(self, "sigv4")

    @sigv4.setter
    def sigv4(self, value: Optional[pulumi.Input['TopicRuleSigV4AuthorizationArgs']]):
        pulumi.set(self, "sigv4", value)


if not MYPY:
    class TopicRuleIotAnalyticsActionArgsDict(TypedDict):
        channel_name: pulumi.Input[str]
        """
        The name of the IoT Analytics channel to which message data will be sent.
        """
        role_arn: pulumi.Input[str]
        """
        The ARN of the role which has a policy that grants IoT Analytics permission to send message data via IoT Analytics (iotanalytics:BatchPutMessage).
        """
        batch_mode: NotRequired[pulumi.Input[bool]]
        """
        Whether to process the action as a batch. The default value is `false` .

        When `batchMode` is `true` and the rule SQL statement evaluates to an Array, each Array element is delivered as a separate message when passed by [`BatchPutMessage`](https://docs.aws.amazon.com/iotanalytics/latest/APIReference/API_BatchPutMessage.html) The resulting array can't have more than 100 messages.
        """
elif False:
    TopicRuleIotAnalyticsActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleIotAnalyticsActionArgs:
    def __init__(__self__, *,
                 channel_name: pulumi.Input[str],
                 role_arn: pulumi.Input[str],
                 batch_mode: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] channel_name: The name of the IoT Analytics channel to which message data will be sent.
        :param pulumi.Input[str] role_arn: The ARN of the role which has a policy that grants IoT Analytics permission to send message data via IoT Analytics (iotanalytics:BatchPutMessage).
        :param pulumi.Input[bool] batch_mode: Whether to process the action as a batch. The default value is `false` .
               
               When `batchMode` is `true` and the rule SQL statement evaluates to an Array, each Array element is delivered as a separate message when passed by [`BatchPutMessage`](https://docs.aws.amazon.com/iotanalytics/latest/APIReference/API_BatchPutMessage.html) The resulting array can't have more than 100 messages.
        """
        pulumi.set(__self__, "channel_name", channel_name)
        pulumi.set(__self__, "role_arn", role_arn)
        if batch_mode is not None:
            pulumi.set(__self__, "batch_mode", batch_mode)

    @property
    @pulumi.getter(name="channelName")
    def channel_name(self) -> pulumi.Input[str]:
        """
        The name of the IoT Analytics channel to which message data will be sent.
        """
        return pulumi.get(self, "channel_name")

    @channel_name.setter
    def channel_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "channel_name", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the role which has a policy that grants IoT Analytics permission to send message data via IoT Analytics (iotanalytics:BatchPutMessage).
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="batchMode")
    def batch_mode(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to process the action as a batch. The default value is `false` .

        When `batchMode` is `true` and the rule SQL statement evaluates to an Array, each Array element is delivered as a separate message when passed by [`BatchPutMessage`](https://docs.aws.amazon.com/iotanalytics/latest/APIReference/API_BatchPutMessage.html) The resulting array can't have more than 100 messages.
        """
        return pulumi.get(self, "batch_mode")

    @batch_mode.setter
    def batch_mode(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "batch_mode", value)


if not MYPY:
    class TopicRuleIotEventsActionArgsDict(TypedDict):
        input_name: pulumi.Input[str]
        """
        The name of the AWS IoT Events input.
        """
        role_arn: pulumi.Input[str]
        """
        The ARN of the role that grants AWS IoT permission to send an input to an AWS IoT Events detector. ("Action":"iotevents:BatchPutMessage").
        """
        batch_mode: NotRequired[pulumi.Input[bool]]
        """
        Whether to process the event actions as a batch. The default value is `false` .

        When `batchMode` is `true` , you can't specify a `messageId` .

        When `batchMode` is `true` and the rule SQL statement evaluates to an Array, each Array element is treated as a separate message when Events by calling [`BatchPutMessage`](https://docs.aws.amazon.com/iotevents/latest/apireference/API_iotevents-data_BatchPutMessage.html) . The resulting array can't have more than 10 messages.
        """
        message_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the message. The default `messageId` is a new UUID value.

        When `batchMode` is `true` , you can't specify a `messageId` --a new UUID value will be assigned.

        Assign a value to this property to ensure that only one input (message) with a given `messageId` will be processed by an AWS IoT Events detector.
        """
elif False:
    TopicRuleIotEventsActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleIotEventsActionArgs:
    def __init__(__self__, *,
                 input_name: pulumi.Input[str],
                 role_arn: pulumi.Input[str],
                 batch_mode: Optional[pulumi.Input[bool]] = None,
                 message_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] input_name: The name of the AWS IoT Events input.
        :param pulumi.Input[str] role_arn: The ARN of the role that grants AWS IoT permission to send an input to an AWS IoT Events detector. ("Action":"iotevents:BatchPutMessage").
        :param pulumi.Input[bool] batch_mode: Whether to process the event actions as a batch. The default value is `false` .
               
               When `batchMode` is `true` , you can't specify a `messageId` .
               
               When `batchMode` is `true` and the rule SQL statement evaluates to an Array, each Array element is treated as a separate message when Events by calling [`BatchPutMessage`](https://docs.aws.amazon.com/iotevents/latest/apireference/API_iotevents-data_BatchPutMessage.html) . The resulting array can't have more than 10 messages.
        :param pulumi.Input[str] message_id: The ID of the message. The default `messageId` is a new UUID value.
               
               When `batchMode` is `true` , you can't specify a `messageId` --a new UUID value will be assigned.
               
               Assign a value to this property to ensure that only one input (message) with a given `messageId` will be processed by an AWS IoT Events detector.
        """
        pulumi.set(__self__, "input_name", input_name)
        pulumi.set(__self__, "role_arn", role_arn)
        if batch_mode is not None:
            pulumi.set(__self__, "batch_mode", batch_mode)
        if message_id is not None:
            pulumi.set(__self__, "message_id", message_id)

    @property
    @pulumi.getter(name="inputName")
    def input_name(self) -> pulumi.Input[str]:
        """
        The name of the AWS IoT Events input.
        """
        return pulumi.get(self, "input_name")

    @input_name.setter
    def input_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "input_name", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the role that grants AWS IoT permission to send an input to an AWS IoT Events detector. ("Action":"iotevents:BatchPutMessage").
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="batchMode")
    def batch_mode(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to process the event actions as a batch. The default value is `false` .

        When `batchMode` is `true` , you can't specify a `messageId` .

        When `batchMode` is `true` and the rule SQL statement evaluates to an Array, each Array element is treated as a separate message when Events by calling [`BatchPutMessage`](https://docs.aws.amazon.com/iotevents/latest/apireference/API_iotevents-data_BatchPutMessage.html) . The resulting array can't have more than 10 messages.
        """
        return pulumi.get(self, "batch_mode")

    @batch_mode.setter
    def batch_mode(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "batch_mode", value)

    @property
    @pulumi.getter(name="messageId")
    def message_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the message. The default `messageId` is a new UUID value.

        When `batchMode` is `true` , you can't specify a `messageId` --a new UUID value will be assigned.

        Assign a value to this property to ensure that only one input (message) with a given `messageId` will be processed by an AWS IoT Events detector.
        """
        return pulumi.get(self, "message_id")

    @message_id.setter
    def message_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message_id", value)


if not MYPY:
    class TopicRuleIotSiteWiseActionArgsDict(TypedDict):
        put_asset_property_value_entries: pulumi.Input[Sequence[pulumi.Input['TopicRulePutAssetPropertyValueEntryArgsDict']]]
        """
        A list of asset property value entries.
        """
        role_arn: pulumi.Input[str]
        """
        The ARN of the role that grants AWS IoT permission to send an asset property value to AWS IoT SiteWise. ( `"Action": "iotsitewise:BatchPutAssetPropertyValue"` ). The trust policy can restrict access to specific asset hierarchy paths.
        """
elif False:
    TopicRuleIotSiteWiseActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleIotSiteWiseActionArgs:
    def __init__(__self__, *,
                 put_asset_property_value_entries: pulumi.Input[Sequence[pulumi.Input['TopicRulePutAssetPropertyValueEntryArgs']]],
                 role_arn: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['TopicRulePutAssetPropertyValueEntryArgs']]] put_asset_property_value_entries: A list of asset property value entries.
        :param pulumi.Input[str] role_arn: The ARN of the role that grants AWS IoT permission to send an asset property value to AWS IoT SiteWise. ( `"Action": "iotsitewise:BatchPutAssetPropertyValue"` ). The trust policy can restrict access to specific asset hierarchy paths.
        """
        pulumi.set(__self__, "put_asset_property_value_entries", put_asset_property_value_entries)
        pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter(name="putAssetPropertyValueEntries")
    def put_asset_property_value_entries(self) -> pulumi.Input[Sequence[pulumi.Input['TopicRulePutAssetPropertyValueEntryArgs']]]:
        """
        A list of asset property value entries.
        """
        return pulumi.get(self, "put_asset_property_value_entries")

    @put_asset_property_value_entries.setter
    def put_asset_property_value_entries(self, value: pulumi.Input[Sequence[pulumi.Input['TopicRulePutAssetPropertyValueEntryArgs']]]):
        pulumi.set(self, "put_asset_property_value_entries", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the role that grants AWS IoT permission to send an asset property value to AWS IoT SiteWise. ( `"Action": "iotsitewise:BatchPutAssetPropertyValue"` ). The trust policy can restrict access to specific asset hierarchy paths.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)


if not MYPY:
    class TopicRuleKafkaActionHeaderArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        The key of the Kafka header.
        """
        value: pulumi.Input[str]
        """
        The value of the Kafka header.
        """
elif False:
    TopicRuleKafkaActionHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleKafkaActionHeaderArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: The key of the Kafka header.
        :param pulumi.Input[str] value: The value of the Kafka header.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The key of the Kafka header.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value of the Kafka header.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class TopicRuleKafkaActionArgsDict(TypedDict):
        client_properties: pulumi.Input[Mapping[str, pulumi.Input[str]]]
        """
        Properties of the Apache Kafka producer client.
        """
        destination_arn: pulumi.Input[str]
        """
        The ARN of Kafka action's VPC `TopicRuleDestination` .
        """
        topic: pulumi.Input[str]
        """
        The Kafka topic for messages to be sent to the Kafka broker.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['TopicRuleKafkaActionHeaderArgsDict']]]]
        """
        The list of Kafka headers that you specify.
        """
        key: NotRequired[pulumi.Input[str]]
        """
        The Kafka message key.
        """
        partition: NotRequired[pulumi.Input[str]]
        """
        The Kafka message partition.
        """
elif False:
    TopicRuleKafkaActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleKafkaActionArgs:
    def __init__(__self__, *,
                 client_properties: pulumi.Input[Mapping[str, pulumi.Input[str]]],
                 destination_arn: pulumi.Input[str],
                 topic: pulumi.Input[str],
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['TopicRuleKafkaActionHeaderArgs']]]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 partition: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] client_properties: Properties of the Apache Kafka producer client.
        :param pulumi.Input[str] destination_arn: The ARN of Kafka action's VPC `TopicRuleDestination` .
        :param pulumi.Input[str] topic: The Kafka topic for messages to be sent to the Kafka broker.
        :param pulumi.Input[Sequence[pulumi.Input['TopicRuleKafkaActionHeaderArgs']]] headers: The list of Kafka headers that you specify.
        :param pulumi.Input[str] key: The Kafka message key.
        :param pulumi.Input[str] partition: The Kafka message partition.
        """
        pulumi.set(__self__, "client_properties", client_properties)
        pulumi.set(__self__, "destination_arn", destination_arn)
        pulumi.set(__self__, "topic", topic)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if partition is not None:
            pulumi.set(__self__, "partition", partition)

    @property
    @pulumi.getter(name="clientProperties")
    def client_properties(self) -> pulumi.Input[Mapping[str, pulumi.Input[str]]]:
        """
        Properties of the Apache Kafka producer client.
        """
        return pulumi.get(self, "client_properties")

    @client_properties.setter
    def client_properties(self, value: pulumi.Input[Mapping[str, pulumi.Input[str]]]):
        pulumi.set(self, "client_properties", value)

    @property
    @pulumi.getter(name="destinationArn")
    def destination_arn(self) -> pulumi.Input[str]:
        """
        The ARN of Kafka action's VPC `TopicRuleDestination` .
        """
        return pulumi.get(self, "destination_arn")

    @destination_arn.setter
    def destination_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination_arn", value)

    @property
    @pulumi.getter
    def topic(self) -> pulumi.Input[str]:
        """
        The Kafka topic for messages to be sent to the Kafka broker.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: pulumi.Input[str]):
        pulumi.set(self, "topic", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TopicRuleKafkaActionHeaderArgs']]]]:
        """
        The list of Kafka headers that you specify.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TopicRuleKafkaActionHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The Kafka message key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def partition(self) -> Optional[pulumi.Input[str]]:
        """
        The Kafka message partition.
        """
        return pulumi.get(self, "partition")

    @partition.setter
    def partition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "partition", value)


if not MYPY:
    class TopicRuleKinesisActionArgsDict(TypedDict):
        role_arn: pulumi.Input[str]
        """
        The ARN of the IAM role that grants access to the Amazon Kinesis stream.
        """
        stream_name: pulumi.Input[str]
        """
        The name of the Amazon Kinesis stream.
        """
        partition_key: NotRequired[pulumi.Input[str]]
        """
        The partition key.
        """
elif False:
    TopicRuleKinesisActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleKinesisActionArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[str],
                 stream_name: pulumi.Input[str],
                 partition_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] role_arn: The ARN of the IAM role that grants access to the Amazon Kinesis stream.
        :param pulumi.Input[str] stream_name: The name of the Amazon Kinesis stream.
        :param pulumi.Input[str] partition_key: The partition key.
        """
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "stream_name", stream_name)
        if partition_key is not None:
            pulumi.set(__self__, "partition_key", partition_key)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the IAM role that grants access to the Amazon Kinesis stream.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> pulumi.Input[str]:
        """
        The name of the Amazon Kinesis stream.
        """
        return pulumi.get(self, "stream_name")

    @stream_name.setter
    def stream_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "stream_name", value)

    @property
    @pulumi.getter(name="partitionKey")
    def partition_key(self) -> Optional[pulumi.Input[str]]:
        """
        The partition key.
        """
        return pulumi.get(self, "partition_key")

    @partition_key.setter
    def partition_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "partition_key", value)


if not MYPY:
    class TopicRuleLambdaActionArgsDict(TypedDict):
        function_arn: NotRequired[pulumi.Input[str]]
        """
        The ARN of the Lambda function.
        """
elif False:
    TopicRuleLambdaActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleLambdaActionArgs:
    def __init__(__self__, *,
                 function_arn: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] function_arn: The ARN of the Lambda function.
        """
        if function_arn is not None:
            pulumi.set(__self__, "function_arn", function_arn)

    @property
    @pulumi.getter(name="functionArn")
    def function_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The ARN of the Lambda function.
        """
        return pulumi.get(self, "function_arn")

    @function_arn.setter
    def function_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "function_arn", value)


if not MYPY:
    class TopicRuleLocationActionArgsDict(TypedDict):
        device_id: pulumi.Input[str]
        """
        The unique ID of the device providing the location data.
        """
        latitude: pulumi.Input[str]
        """
        A string that evaluates to a double value that represents the latitude of the device's location.
        """
        longitude: pulumi.Input[str]
        """
        A string that evaluates to a double value that represents the longitude of the device's location.
        """
        role_arn: pulumi.Input[str]
        """
        The IAM role that grants permission to write to the Amazon Location resource.
        """
        tracker_name: pulumi.Input[str]
        """
        The name of the tracker resource in Amazon Location in which the location is updated.
        """
        timestamp: NotRequired[pulumi.Input['TopicRuleTimestampArgsDict']]
        """
        The time that the location data was sampled. The default value is the time the MQTT message was processed.
        """
elif False:
    TopicRuleLocationActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleLocationActionArgs:
    def __init__(__self__, *,
                 device_id: pulumi.Input[str],
                 latitude: pulumi.Input[str],
                 longitude: pulumi.Input[str],
                 role_arn: pulumi.Input[str],
                 tracker_name: pulumi.Input[str],
                 timestamp: Optional[pulumi.Input['TopicRuleTimestampArgs']] = None):
        """
        :param pulumi.Input[str] device_id: The unique ID of the device providing the location data.
        :param pulumi.Input[str] latitude: A string that evaluates to a double value that represents the latitude of the device's location.
        :param pulumi.Input[str] longitude: A string that evaluates to a double value that represents the longitude of the device's location.
        :param pulumi.Input[str] role_arn: The IAM role that grants permission to write to the Amazon Location resource.
        :param pulumi.Input[str] tracker_name: The name of the tracker resource in Amazon Location in which the location is updated.
        :param pulumi.Input['TopicRuleTimestampArgs'] timestamp: The time that the location data was sampled. The default value is the time the MQTT message was processed.
        """
        pulumi.set(__self__, "device_id", device_id)
        pulumi.set(__self__, "latitude", latitude)
        pulumi.set(__self__, "longitude", longitude)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "tracker_name", tracker_name)
        if timestamp is not None:
            pulumi.set(__self__, "timestamp", timestamp)

    @property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> pulumi.Input[str]:
        """
        The unique ID of the device providing the location data.
        """
        return pulumi.get(self, "device_id")

    @device_id.setter
    def device_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "device_id", value)

    @property
    @pulumi.getter
    def latitude(self) -> pulumi.Input[str]:
        """
        A string that evaluates to a double value that represents the latitude of the device's location.
        """
        return pulumi.get(self, "latitude")

    @latitude.setter
    def latitude(self, value: pulumi.Input[str]):
        pulumi.set(self, "latitude", value)

    @property
    @pulumi.getter
    def longitude(self) -> pulumi.Input[str]:
        """
        A string that evaluates to a double value that represents the longitude of the device's location.
        """
        return pulumi.get(self, "longitude")

    @longitude.setter
    def longitude(self, value: pulumi.Input[str]):
        pulumi.set(self, "longitude", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The IAM role that grants permission to write to the Amazon Location resource.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="trackerName")
    def tracker_name(self) -> pulumi.Input[str]:
        """
        The name of the tracker resource in Amazon Location in which the location is updated.
        """
        return pulumi.get(self, "tracker_name")

    @tracker_name.setter
    def tracker_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "tracker_name", value)

    @property
    @pulumi.getter
    def timestamp(self) -> Optional[pulumi.Input['TopicRuleTimestampArgs']]:
        """
        The time that the location data was sampled. The default value is the time the MQTT message was processed.
        """
        return pulumi.get(self, "timestamp")

    @timestamp.setter
    def timestamp(self, value: Optional[pulumi.Input['TopicRuleTimestampArgs']]):
        pulumi.set(self, "timestamp", value)


if not MYPY:
    class TopicRuleOpenSearchActionArgsDict(TypedDict):
        endpoint: pulumi.Input[str]
        """
        The endpoint of your OpenSearch domain.
        """
        id: pulumi.Input[str]
        """
        The unique identifier for the document you are storing.
        """
        index: pulumi.Input[str]
        """
        The OpenSearch index where you want to store your data.
        """
        role_arn: pulumi.Input[str]
        """
        The IAM role ARN that has access to OpenSearch.
        """
        type: pulumi.Input[str]
        """
        The type of document you are storing.
        """
elif False:
    TopicRuleOpenSearchActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleOpenSearchActionArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[str],
                 id: pulumi.Input[str],
                 index: pulumi.Input[str],
                 role_arn: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] endpoint: The endpoint of your OpenSearch domain.
        :param pulumi.Input[str] id: The unique identifier for the document you are storing.
        :param pulumi.Input[str] index: The OpenSearch index where you want to store your data.
        :param pulumi.Input[str] role_arn: The IAM role ARN that has access to OpenSearch.
        :param pulumi.Input[str] type: The type of document you are storing.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[str]:
        """
        The endpoint of your OpenSearch domain.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The unique identifier for the document you are storing.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        """
        The OpenSearch index where you want to store your data.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The IAM role ARN that has access to OpenSearch.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of document you are storing.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class TopicRulePayloadArgsDict(TypedDict):
        actions: pulumi.Input[Sequence[pulumi.Input['TopicRuleActionArgsDict']]]
        """
        The actions associated with the rule.
        """
        sql: pulumi.Input[str]
        """
        The SQL statement used to query the topic. For more information, see [AWS IoT SQL Reference](https://docs.aws.amazon.com/iot/latest/developerguide/iot-sql-reference.html) in the *AWS IoT Developer Guide* .
        """
        aws_iot_sql_version: NotRequired[pulumi.Input[str]]
        """
        The version of the SQL rules engine to use when evaluating the rule.

        The default value is 2015-10-08.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        The description of the rule.
        """
        error_action: NotRequired[pulumi.Input['TopicRuleActionArgsDict']]
        """
        The action to take when an error occurs.
        """
        rule_disabled: NotRequired[pulumi.Input[bool]]
        """
        Specifies whether the rule is disabled.
        """
elif False:
    TopicRulePayloadArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRulePayloadArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input[Sequence[pulumi.Input['TopicRuleActionArgs']]],
                 sql: pulumi.Input[str],
                 aws_iot_sql_version: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 error_action: Optional[pulumi.Input['TopicRuleActionArgs']] = None,
                 rule_disabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['TopicRuleActionArgs']]] actions: The actions associated with the rule.
        :param pulumi.Input[str] sql: The SQL statement used to query the topic. For more information, see [AWS IoT SQL Reference](https://docs.aws.amazon.com/iot/latest/developerguide/iot-sql-reference.html) in the *AWS IoT Developer Guide* .
        :param pulumi.Input[str] aws_iot_sql_version: The version of the SQL rules engine to use when evaluating the rule.
               
               The default value is 2015-10-08.
        :param pulumi.Input[str] description: The description of the rule.
        :param pulumi.Input['TopicRuleActionArgs'] error_action: The action to take when an error occurs.
        :param pulumi.Input[bool] rule_disabled: Specifies whether the rule is disabled.
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "sql", sql)
        if aws_iot_sql_version is not None:
            pulumi.set(__self__, "aws_iot_sql_version", aws_iot_sql_version)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if error_action is not None:
            pulumi.set(__self__, "error_action", error_action)
        if rule_disabled is not None:
            pulumi.set(__self__, "rule_disabled", rule_disabled)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input[Sequence[pulumi.Input['TopicRuleActionArgs']]]:
        """
        The actions associated with the rule.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input[Sequence[pulumi.Input['TopicRuleActionArgs']]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter
    def sql(self) -> pulumi.Input[str]:
        """
        The SQL statement used to query the topic. For more information, see [AWS IoT SQL Reference](https://docs.aws.amazon.com/iot/latest/developerguide/iot-sql-reference.html) in the *AWS IoT Developer Guide* .
        """
        return pulumi.get(self, "sql")

    @sql.setter
    def sql(self, value: pulumi.Input[str]):
        pulumi.set(self, "sql", value)

    @property
    @pulumi.getter(name="awsIotSqlVersion")
    def aws_iot_sql_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of the SQL rules engine to use when evaluating the rule.

        The default value is 2015-10-08.
        """
        return pulumi.get(self, "aws_iot_sql_version")

    @aws_iot_sql_version.setter
    def aws_iot_sql_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aws_iot_sql_version", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        The description of the rule.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="errorAction")
    def error_action(self) -> Optional[pulumi.Input['TopicRuleActionArgs']]:
        """
        The action to take when an error occurs.
        """
        return pulumi.get(self, "error_action")

    @error_action.setter
    def error_action(self, value: Optional[pulumi.Input['TopicRuleActionArgs']]):
        pulumi.set(self, "error_action", value)

    @property
    @pulumi.getter(name="ruleDisabled")
    def rule_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether the rule is disabled.
        """
        return pulumi.get(self, "rule_disabled")

    @rule_disabled.setter
    def rule_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "rule_disabled", value)


if not MYPY:
    class TopicRulePutAssetPropertyValueEntryArgsDict(TypedDict):
        property_values: pulumi.Input[Sequence[pulumi.Input['TopicRuleAssetPropertyValueArgsDict']]]
        """
        A list of property values to insert that each contain timestamp, quality, and value (TQV) information.
        """
        asset_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the AWS IoT SiteWise asset. You must specify either a `propertyAlias` or both an `aliasId` and a `propertyId` . Accepts substitution templates.
        """
        entry_id: NotRequired[pulumi.Input[str]]
        """
        Optional. A unique identifier for this entry that you can define to better track which message caused an error in case of failure. Accepts substitution templates. Defaults to a new UUID.
        """
        property_alias: NotRequired[pulumi.Input[str]]
        """
        The name of the property alias associated with your asset property. You must specify either a `propertyAlias` or both an `aliasId` and a `propertyId` . Accepts substitution templates.
        """
        property_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the asset's property. You must specify either a `propertyAlias` or both an `aliasId` and a `propertyId` . Accepts substitution templates.
        """
elif False:
    TopicRulePutAssetPropertyValueEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRulePutAssetPropertyValueEntryArgs:
    def __init__(__self__, *,
                 property_values: pulumi.Input[Sequence[pulumi.Input['TopicRuleAssetPropertyValueArgs']]],
                 asset_id: Optional[pulumi.Input[str]] = None,
                 entry_id: Optional[pulumi.Input[str]] = None,
                 property_alias: Optional[pulumi.Input[str]] = None,
                 property_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['TopicRuleAssetPropertyValueArgs']]] property_values: A list of property values to insert that each contain timestamp, quality, and value (TQV) information.
        :param pulumi.Input[str] asset_id: The ID of the AWS IoT SiteWise asset. You must specify either a `propertyAlias` or both an `aliasId` and a `propertyId` . Accepts substitution templates.
        :param pulumi.Input[str] entry_id: Optional. A unique identifier for this entry that you can define to better track which message caused an error in case of failure. Accepts substitution templates. Defaults to a new UUID.
        :param pulumi.Input[str] property_alias: The name of the property alias associated with your asset property. You must specify either a `propertyAlias` or both an `aliasId` and a `propertyId` . Accepts substitution templates.
        :param pulumi.Input[str] property_id: The ID of the asset's property. You must specify either a `propertyAlias` or both an `aliasId` and a `propertyId` . Accepts substitution templates.
        """
        pulumi.set(__self__, "property_values", property_values)
        if asset_id is not None:
            pulumi.set(__self__, "asset_id", asset_id)
        if entry_id is not None:
            pulumi.set(__self__, "entry_id", entry_id)
        if property_alias is not None:
            pulumi.set(__self__, "property_alias", property_alias)
        if property_id is not None:
            pulumi.set(__self__, "property_id", property_id)

    @property
    @pulumi.getter(name="propertyValues")
    def property_values(self) -> pulumi.Input[Sequence[pulumi.Input['TopicRuleAssetPropertyValueArgs']]]:
        """
        A list of property values to insert that each contain timestamp, quality, and value (TQV) information.
        """
        return pulumi.get(self, "property_values")

    @property_values.setter
    def property_values(self, value: pulumi.Input[Sequence[pulumi.Input['TopicRuleAssetPropertyValueArgs']]]):
        pulumi.set(self, "property_values", value)

    @property
    @pulumi.getter(name="assetId")
    def asset_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the AWS IoT SiteWise asset. You must specify either a `propertyAlias` or both an `aliasId` and a `propertyId` . Accepts substitution templates.
        """
        return pulumi.get(self, "asset_id")

    @asset_id.setter
    def asset_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "asset_id", value)

    @property
    @pulumi.getter(name="entryId")
    def entry_id(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. A unique identifier for this entry that you can define to better track which message caused an error in case of failure. Accepts substitution templates. Defaults to a new UUID.
        """
        return pulumi.get(self, "entry_id")

    @entry_id.setter
    def entry_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "entry_id", value)

    @property
    @pulumi.getter(name="propertyAlias")
    def property_alias(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the property alias associated with your asset property. You must specify either a `propertyAlias` or both an `aliasId` and a `propertyId` . Accepts substitution templates.
        """
        return pulumi.get(self, "property_alias")

    @property_alias.setter
    def property_alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "property_alias", value)

    @property
    @pulumi.getter(name="propertyId")
    def property_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the asset's property. You must specify either a `propertyAlias` or both an `aliasId` and a `propertyId` . Accepts substitution templates.
        """
        return pulumi.get(self, "property_id")

    @property_id.setter
    def property_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "property_id", value)


if not MYPY:
    class TopicRulePutItemInputArgsDict(TypedDict):
        table_name: pulumi.Input[str]
        """
        The table where the message data will be written.
        """
elif False:
    TopicRulePutItemInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRulePutItemInputArgs:
    def __init__(__self__, *,
                 table_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] table_name: The table where the message data will be written.
        """
        pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[str]:
        """
        The table where the message data will be written.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "table_name", value)


if not MYPY:
    class TopicRuleRepublishActionHeadersArgsDict(TypedDict):
        content_type: NotRequired[pulumi.Input[str]]
        """
        A UTF-8 encoded string that describes the content of the publishing message.

        For more information, see [Content Type](https://docs.aws.amazon.com/https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901118) in the MQTT Version 5.0 specification.

        Supports [substitution templates](https://docs.aws.amazon.com//iot/latest/developerguide/iot-substitution-templates.html) .
        """
        correlation_data: NotRequired[pulumi.Input[str]]
        """
        The base64-encoded binary data used by the sender of the request message to identify which request the response message is for.

        For more information, see [Correlation Data](https://docs.aws.amazon.com/https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901115) in the MQTT Version 5.0 specification.

        Supports [substitution templates](https://docs.aws.amazon.com//iot/latest/developerguide/iot-substitution-templates.html) .

        > This binary data must be base64-encoded.
        """
        message_expiry: NotRequired[pulumi.Input[str]]
        """
        A user-defined integer value that represents the message expiry interval at the broker. If the messages haven't been sent to the subscribers within that interval, the message expires and is removed. The value of `messageExpiry` represents the number of seconds before it expires. For more information about the limits of `messageExpiry` , see [Message broker and protocol limits and quotas](https://docs.aws.amazon.com//general/latest/gr/iot-core.html#limits_iot) in the IoT Core Reference Guide.

        Supports [substitution templates](https://docs.aws.amazon.com//iot/latest/developerguide/iot-substitution-templates.html) .
        """
        payload_format_indicator: NotRequired[pulumi.Input[str]]
        """
        An `Enum` string value that indicates whether the payload is formatted as UTF-8.

        Valid values are `UNSPECIFIED_BYTES` and `UTF8_DATA` .

        For more information, see [Payload Format Indicator](https://docs.aws.amazon.com/https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901111) from the MQTT Version 5.0 specification.

        Supports [substitution templates](https://docs.aws.amazon.com//iot/latest/developerguide/iot-substitution-templates.html) .
        """
        response_topic: NotRequired[pulumi.Input[str]]
        """
        A UTF-8 encoded string that's used as the topic name for a response message. The response topic is used to describe the topic to which the receiver should publish as part of the request-response flow. The topic must not contain wildcard characters.

        For more information, see [Response Topic](https://docs.aws.amazon.com/https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901114) in the MQTT Version 5.0 specification.

        Supports [substitution templates](https://docs.aws.amazon.com//iot/latest/developerguide/iot-substitution-templates.html) .
        """
        user_properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['TopicRuleUserPropertyArgsDict']]]]
        """
        An array of key-value pairs that you define in the MQTT5 header.
        """
elif False:
    TopicRuleRepublishActionHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleRepublishActionHeadersArgs:
    def __init__(__self__, *,
                 content_type: Optional[pulumi.Input[str]] = None,
                 correlation_data: Optional[pulumi.Input[str]] = None,
                 message_expiry: Optional[pulumi.Input[str]] = None,
                 payload_format_indicator: Optional[pulumi.Input[str]] = None,
                 response_topic: Optional[pulumi.Input[str]] = None,
                 user_properties: Optional[pulumi.Input[Sequence[pulumi.Input['TopicRuleUserPropertyArgs']]]] = None):
        """
        :param pulumi.Input[str] content_type: A UTF-8 encoded string that describes the content of the publishing message.
               
               For more information, see [Content Type](https://docs.aws.amazon.com/https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901118) in the MQTT Version 5.0 specification.
               
               Supports [substitution templates](https://docs.aws.amazon.com//iot/latest/developerguide/iot-substitution-templates.html) .
        :param pulumi.Input[str] correlation_data: The base64-encoded binary data used by the sender of the request message to identify which request the response message is for.
               
               For more information, see [Correlation Data](https://docs.aws.amazon.com/https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901115) in the MQTT Version 5.0 specification.
               
               Supports [substitution templates](https://docs.aws.amazon.com//iot/latest/developerguide/iot-substitution-templates.html) .
               
               > This binary data must be base64-encoded.
        :param pulumi.Input[str] message_expiry: A user-defined integer value that represents the message expiry interval at the broker. If the messages haven't been sent to the subscribers within that interval, the message expires and is removed. The value of `messageExpiry` represents the number of seconds before it expires. For more information about the limits of `messageExpiry` , see [Message broker and protocol limits and quotas](https://docs.aws.amazon.com//general/latest/gr/iot-core.html#limits_iot) in the IoT Core Reference Guide.
               
               Supports [substitution templates](https://docs.aws.amazon.com//iot/latest/developerguide/iot-substitution-templates.html) .
        :param pulumi.Input[str] payload_format_indicator: An `Enum` string value that indicates whether the payload is formatted as UTF-8.
               
               Valid values are `UNSPECIFIED_BYTES` and `UTF8_DATA` .
               
               For more information, see [Payload Format Indicator](https://docs.aws.amazon.com/https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901111) from the MQTT Version 5.0 specification.
               
               Supports [substitution templates](https://docs.aws.amazon.com//iot/latest/developerguide/iot-substitution-templates.html) .
        :param pulumi.Input[str] response_topic: A UTF-8 encoded string that's used as the topic name for a response message. The response topic is used to describe the topic to which the receiver should publish as part of the request-response flow. The topic must not contain wildcard characters.
               
               For more information, see [Response Topic](https://docs.aws.amazon.com/https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901114) in the MQTT Version 5.0 specification.
               
               Supports [substitution templates](https://docs.aws.amazon.com//iot/latest/developerguide/iot-substitution-templates.html) .
        :param pulumi.Input[Sequence[pulumi.Input['TopicRuleUserPropertyArgs']]] user_properties: An array of key-value pairs that you define in the MQTT5 header.
        """
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if correlation_data is not None:
            pulumi.set(__self__, "correlation_data", correlation_data)
        if message_expiry is not None:
            pulumi.set(__self__, "message_expiry", message_expiry)
        if payload_format_indicator is not None:
            pulumi.set(__self__, "payload_format_indicator", payload_format_indicator)
        if response_topic is not None:
            pulumi.set(__self__, "response_topic", response_topic)
        if user_properties is not None:
            pulumi.set(__self__, "user_properties", user_properties)

    @property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[str]]:
        """
        A UTF-8 encoded string that describes the content of the publishing message.

        For more information, see [Content Type](https://docs.aws.amazon.com/https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901118) in the MQTT Version 5.0 specification.

        Supports [substitution templates](https://docs.aws.amazon.com//iot/latest/developerguide/iot-substitution-templates.html) .
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content_type", value)

    @property
    @pulumi.getter(name="correlationData")
    def correlation_data(self) -> Optional[pulumi.Input[str]]:
        """
        The base64-encoded binary data used by the sender of the request message to identify which request the response message is for.

        For more information, see [Correlation Data](https://docs.aws.amazon.com/https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901115) in the MQTT Version 5.0 specification.

        Supports [substitution templates](https://docs.aws.amazon.com//iot/latest/developerguide/iot-substitution-templates.html) .

        > This binary data must be base64-encoded.
        """
        return pulumi.get(self, "correlation_data")

    @correlation_data.setter
    def correlation_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "correlation_data", value)

    @property
    @pulumi.getter(name="messageExpiry")
    def message_expiry(self) -> Optional[pulumi.Input[str]]:
        """
        A user-defined integer value that represents the message expiry interval at the broker. If the messages haven't been sent to the subscribers within that interval, the message expires and is removed. The value of `messageExpiry` represents the number of seconds before it expires. For more information about the limits of `messageExpiry` , see [Message broker and protocol limits and quotas](https://docs.aws.amazon.com//general/latest/gr/iot-core.html#limits_iot) in the IoT Core Reference Guide.

        Supports [substitution templates](https://docs.aws.amazon.com//iot/latest/developerguide/iot-substitution-templates.html) .
        """
        return pulumi.get(self, "message_expiry")

    @message_expiry.setter
    def message_expiry(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message_expiry", value)

    @property
    @pulumi.getter(name="payloadFormatIndicator")
    def payload_format_indicator(self) -> Optional[pulumi.Input[str]]:
        """
        An `Enum` string value that indicates whether the payload is formatted as UTF-8.

        Valid values are `UNSPECIFIED_BYTES` and `UTF8_DATA` .

        For more information, see [Payload Format Indicator](https://docs.aws.amazon.com/https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901111) from the MQTT Version 5.0 specification.

        Supports [substitution templates](https://docs.aws.amazon.com//iot/latest/developerguide/iot-substitution-templates.html) .
        """
        return pulumi.get(self, "payload_format_indicator")

    @payload_format_indicator.setter
    def payload_format_indicator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "payload_format_indicator", value)

    @property
    @pulumi.getter(name="responseTopic")
    def response_topic(self) -> Optional[pulumi.Input[str]]:
        """
        A UTF-8 encoded string that's used as the topic name for a response message. The response topic is used to describe the topic to which the receiver should publish as part of the request-response flow. The topic must not contain wildcard characters.

        For more information, see [Response Topic](https://docs.aws.amazon.com/https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901114) in the MQTT Version 5.0 specification.

        Supports [substitution templates](https://docs.aws.amazon.com//iot/latest/developerguide/iot-substitution-templates.html) .
        """
        return pulumi.get(self, "response_topic")

    @response_topic.setter
    def response_topic(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "response_topic", value)

    @property
    @pulumi.getter(name="userProperties")
    def user_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TopicRuleUserPropertyArgs']]]]:
        """
        An array of key-value pairs that you define in the MQTT5 header.
        """
        return pulumi.get(self, "user_properties")

    @user_properties.setter
    def user_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TopicRuleUserPropertyArgs']]]]):
        pulumi.set(self, "user_properties", value)


if not MYPY:
    class TopicRuleRepublishActionArgsDict(TypedDict):
        role_arn: pulumi.Input[str]
        """
        The ARN of the IAM role that grants access.
        """
        topic: pulumi.Input[str]
        """
        The name of the MQTT topic.
        """
        headers: NotRequired[pulumi.Input['TopicRuleRepublishActionHeadersArgsDict']]
        """
        MQTT Version 5.0 headers information. For more information, see [MQTT](https://docs.aws.amazon.com//iot/latest/developerguide/mqtt.html) in the IoT Core Developer Guide.
        """
        qos: NotRequired[pulumi.Input[int]]
        """
        The Quality of Service (QoS) level to use when republishing messages. The default value is 0.
        """
elif False:
    TopicRuleRepublishActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleRepublishActionArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[str],
                 topic: pulumi.Input[str],
                 headers: Optional[pulumi.Input['TopicRuleRepublishActionHeadersArgs']] = None,
                 qos: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] role_arn: The ARN of the IAM role that grants access.
        :param pulumi.Input[str] topic: The name of the MQTT topic.
        :param pulumi.Input['TopicRuleRepublishActionHeadersArgs'] headers: MQTT Version 5.0 headers information. For more information, see [MQTT](https://docs.aws.amazon.com//iot/latest/developerguide/mqtt.html) in the IoT Core Developer Guide.
        :param pulumi.Input[int] qos: The Quality of Service (QoS) level to use when republishing messages. The default value is 0.
        """
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "topic", topic)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if qos is not None:
            pulumi.set(__self__, "qos", qos)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the IAM role that grants access.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter
    def topic(self) -> pulumi.Input[str]:
        """
        The name of the MQTT topic.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: pulumi.Input[str]):
        pulumi.set(self, "topic", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input['TopicRuleRepublishActionHeadersArgs']]:
        """
        MQTT Version 5.0 headers information. For more information, see [MQTT](https://docs.aws.amazon.com//iot/latest/developerguide/mqtt.html) in the IoT Core Developer Guide.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input['TopicRuleRepublishActionHeadersArgs']]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter
    def qos(self) -> Optional[pulumi.Input[int]]:
        """
        The Quality of Service (QoS) level to use when republishing messages. The default value is 0.
        """
        return pulumi.get(self, "qos")

    @qos.setter
    def qos(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "qos", value)


if not MYPY:
    class TopicRuleS3ActionArgsDict(TypedDict):
        bucket_name: pulumi.Input[str]
        """
        The Amazon S3 bucket.
        """
        key: pulumi.Input[str]
        """
        The object key. For more information, see [Actions, resources, and condition keys for Amazon S3](https://docs.aws.amazon.com/AmazonS3/latest/dev/list_amazons3.html) .
        """
        role_arn: pulumi.Input[str]
        """
        The ARN of the IAM role that grants access.
        """
        canned_acl: NotRequired[pulumi.Input['TopicRuleCannedAccessControlList']]
        """
        The Amazon S3 canned ACL that controls access to the object identified by the object key. For more information, see [S3 canned ACLs](https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl) .
        """
elif False:
    TopicRuleS3ActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleS3ActionArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[str],
                 key: pulumi.Input[str],
                 role_arn: pulumi.Input[str],
                 canned_acl: Optional[pulumi.Input['TopicRuleCannedAccessControlList']] = None):
        """
        :param pulumi.Input[str] bucket_name: The Amazon S3 bucket.
        :param pulumi.Input[str] key: The object key. For more information, see [Actions, resources, and condition keys for Amazon S3](https://docs.aws.amazon.com/AmazonS3/latest/dev/list_amazons3.html) .
        :param pulumi.Input[str] role_arn: The ARN of the IAM role that grants access.
        :param pulumi.Input['TopicRuleCannedAccessControlList'] canned_acl: The Amazon S3 canned ACL that controls access to the object identified by the object key. For more information, see [S3 canned ACLs](https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl) .
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "role_arn", role_arn)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[str]:
        """
        The Amazon S3 bucket.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The object key. For more information, see [Actions, resources, and condition keys for Amazon S3](https://docs.aws.amazon.com/AmazonS3/latest/dev/list_amazons3.html) .
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the IAM role that grants access.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[pulumi.Input['TopicRuleCannedAccessControlList']]:
        """
        The Amazon S3 canned ACL that controls access to the object identified by the object key. For more information, see [S3 canned ACLs](https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl) .
        """
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[pulumi.Input['TopicRuleCannedAccessControlList']]):
        pulumi.set(self, "canned_acl", value)


if not MYPY:
    class TopicRuleSigV4AuthorizationArgsDict(TypedDict):
        role_arn: pulumi.Input[str]
        """
        The ARN of the signing role.
        """
        service_name: pulumi.Input[str]
        """
        The service name to use while signing with Sig V4.
        """
        signing_region: pulumi.Input[str]
        """
        The signing region.
        """
elif False:
    TopicRuleSigV4AuthorizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleSigV4AuthorizationArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[str],
                 service_name: pulumi.Input[str],
                 signing_region: pulumi.Input[str]):
        """
        :param pulumi.Input[str] role_arn: The ARN of the signing role.
        :param pulumi.Input[str] service_name: The service name to use while signing with Sig V4.
        :param pulumi.Input[str] signing_region: The signing region.
        """
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "service_name", service_name)
        pulumi.set(__self__, "signing_region", signing_region)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the signing role.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> pulumi.Input[str]:
        """
        The service name to use while signing with Sig V4.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_name", value)

    @property
    @pulumi.getter(name="signingRegion")
    def signing_region(self) -> pulumi.Input[str]:
        """
        The signing region.
        """
        return pulumi.get(self, "signing_region")

    @signing_region.setter
    def signing_region(self, value: pulumi.Input[str]):
        pulumi.set(self, "signing_region", value)


if not MYPY:
    class TopicRuleSnsActionArgsDict(TypedDict):
        role_arn: pulumi.Input[str]
        """
        The ARN of the IAM role that grants access.
        """
        target_arn: pulumi.Input[str]
        """
        The ARN of the SNS topic.
        """
        message_format: NotRequired[pulumi.Input[str]]
        """
        (Optional) The message format of the message to publish. Accepted values are "JSON" and "RAW". The default value of the attribute is "RAW". SNS uses this setting to determine if the payload should be parsed and relevant platform-specific bits of the payload should be extracted. For more information, see [Amazon SNS Message and JSON Formats](https://docs.aws.amazon.com/sns/latest/dg/json-formats.html) in the *Amazon Simple Notification Service Developer Guide* .
        """
elif False:
    TopicRuleSnsActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleSnsActionArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[str],
                 target_arn: pulumi.Input[str],
                 message_format: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] role_arn: The ARN of the IAM role that grants access.
        :param pulumi.Input[str] target_arn: The ARN of the SNS topic.
        :param pulumi.Input[str] message_format: (Optional) The message format of the message to publish. Accepted values are "JSON" and "RAW". The default value of the attribute is "RAW". SNS uses this setting to determine if the payload should be parsed and relevant platform-specific bits of the payload should be extracted. For more information, see [Amazon SNS Message and JSON Formats](https://docs.aws.amazon.com/sns/latest/dg/json-formats.html) in the *Amazon Simple Notification Service Developer Guide* .
        """
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "target_arn", target_arn)
        if message_format is not None:
            pulumi.set(__self__, "message_format", message_format)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the IAM role that grants access.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="targetArn")
    def target_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the SNS topic.
        """
        return pulumi.get(self, "target_arn")

    @target_arn.setter
    def target_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_arn", value)

    @property
    @pulumi.getter(name="messageFormat")
    def message_format(self) -> Optional[pulumi.Input[str]]:
        """
        (Optional) The message format of the message to publish. Accepted values are "JSON" and "RAW". The default value of the attribute is "RAW". SNS uses this setting to determine if the payload should be parsed and relevant platform-specific bits of the payload should be extracted. For more information, see [Amazon SNS Message and JSON Formats](https://docs.aws.amazon.com/sns/latest/dg/json-formats.html) in the *Amazon Simple Notification Service Developer Guide* .
        """
        return pulumi.get(self, "message_format")

    @message_format.setter
    def message_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message_format", value)


if not MYPY:
    class TopicRuleSqsActionArgsDict(TypedDict):
        queue_url: pulumi.Input[str]
        """
        The URL of the Amazon SQS queue.
        """
        role_arn: pulumi.Input[str]
        """
        The ARN of the IAM role that grants access.
        """
        use_base64: NotRequired[pulumi.Input[bool]]
        """
        Specifies whether to use Base64 encoding.
        """
elif False:
    TopicRuleSqsActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleSqsActionArgs:
    def __init__(__self__, *,
                 queue_url: pulumi.Input[str],
                 role_arn: pulumi.Input[str],
                 use_base64: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] queue_url: The URL of the Amazon SQS queue.
        :param pulumi.Input[str] role_arn: The ARN of the IAM role that grants access.
        :param pulumi.Input[bool] use_base64: Specifies whether to use Base64 encoding.
        """
        pulumi.set(__self__, "queue_url", queue_url)
        pulumi.set(__self__, "role_arn", role_arn)
        if use_base64 is not None:
            pulumi.set(__self__, "use_base64", use_base64)

    @property
    @pulumi.getter(name="queueUrl")
    def queue_url(self) -> pulumi.Input[str]:
        """
        The URL of the Amazon SQS queue.
        """
        return pulumi.get(self, "queue_url")

    @queue_url.setter
    def queue_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "queue_url", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the IAM role that grants access.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="useBase64")
    def use_base64(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether to use Base64 encoding.
        """
        return pulumi.get(self, "use_base64")

    @use_base64.setter
    def use_base64(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_base64", value)


if not MYPY:
    class TopicRuleStepFunctionsActionArgsDict(TypedDict):
        role_arn: pulumi.Input[str]
        """
        The ARN of the role that grants IoT permission to start execution of a state machine ("Action":"states:StartExecution").
        """
        state_machine_name: pulumi.Input[str]
        """
        The name of the Step Functions state machine whose execution will be started.
        """
        execution_name_prefix: NotRequired[pulumi.Input[str]]
        """
        (Optional) A name will be given to the state machine execution consisting of this prefix followed by a UUID. Step Functions automatically creates a unique name for each state machine execution if one is not provided.
        """
elif False:
    TopicRuleStepFunctionsActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleStepFunctionsActionArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[str],
                 state_machine_name: pulumi.Input[str],
                 execution_name_prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] role_arn: The ARN of the role that grants IoT permission to start execution of a state machine ("Action":"states:StartExecution").
        :param pulumi.Input[str] state_machine_name: The name of the Step Functions state machine whose execution will be started.
        :param pulumi.Input[str] execution_name_prefix: (Optional) A name will be given to the state machine execution consisting of this prefix followed by a UUID. Step Functions automatically creates a unique name for each state machine execution if one is not provided.
        """
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "state_machine_name", state_machine_name)
        if execution_name_prefix is not None:
            pulumi.set(__self__, "execution_name_prefix", execution_name_prefix)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The ARN of the role that grants IoT permission to start execution of a state machine ("Action":"states:StartExecution").
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="stateMachineName")
    def state_machine_name(self) -> pulumi.Input[str]:
        """
        The name of the Step Functions state machine whose execution will be started.
        """
        return pulumi.get(self, "state_machine_name")

    @state_machine_name.setter
    def state_machine_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "state_machine_name", value)

    @property
    @pulumi.getter(name="executionNamePrefix")
    def execution_name_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        (Optional) A name will be given to the state machine execution consisting of this prefix followed by a UUID. Step Functions automatically creates a unique name for each state machine execution if one is not provided.
        """
        return pulumi.get(self, "execution_name_prefix")

    @execution_name_prefix.setter
    def execution_name_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "execution_name_prefix", value)


if not MYPY:
    class TopicRuleTimestampArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        An expression that returns a long epoch time value.
        """
        unit: NotRequired[pulumi.Input[str]]
        """
        The precision of the timestamp value that results from the expression described in `value` .
        """
elif False:
    TopicRuleTimestampArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleTimestampArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 unit: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: An expression that returns a long epoch time value.
        :param pulumi.Input[str] unit: The precision of the timestamp value that results from the expression described in `value` .
        """
        pulumi.set(__self__, "value", value)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        An expression that returns a long epoch time value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input[str]]:
        """
        The precision of the timestamp value that results from the expression described in `value` .
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unit", value)


if not MYPY:
    class TopicRuleTimestreamActionArgsDict(TypedDict):
        database_name: pulumi.Input[str]
        """
        The name of an Amazon Timestream database that has the table to write records into.
        """
        dimensions: pulumi.Input[Sequence[pulumi.Input['TopicRuleTimestreamDimensionArgsDict']]]
        """
        Metadata attributes of the time series that are written in each measure record.
        """
        role_arn: pulumi.Input[str]
        """
        The Amazon Resource Name (ARN) of the role that grants AWS IoT permission to write to the Timestream database table.
        """
        table_name: pulumi.Input[str]
        """
        The table where the message data will be written.
        """
        timestamp: NotRequired[pulumi.Input['TopicRuleTimestreamTimestampArgsDict']]
        """
        The value to use for the entry's timestamp. If blank, the time that the entry was processed is used.
        """
elif False:
    TopicRuleTimestreamActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleTimestreamActionArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[str],
                 dimensions: pulumi.Input[Sequence[pulumi.Input['TopicRuleTimestreamDimensionArgs']]],
                 role_arn: pulumi.Input[str],
                 table_name: pulumi.Input[str],
                 timestamp: Optional[pulumi.Input['TopicRuleTimestreamTimestampArgs']] = None):
        """
        :param pulumi.Input[str] database_name: The name of an Amazon Timestream database that has the table to write records into.
        :param pulumi.Input[Sequence[pulumi.Input['TopicRuleTimestreamDimensionArgs']]] dimensions: Metadata attributes of the time series that are written in each measure record.
        :param pulumi.Input[str] role_arn: The Amazon Resource Name (ARN) of the role that grants AWS IoT permission to write to the Timestream database table.
        :param pulumi.Input[str] table_name: The table where the message data will be written.
        :param pulumi.Input['TopicRuleTimestreamTimestampArgs'] timestamp: The value to use for the entry's timestamp. If blank, the time that the entry was processed is used.
        """
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "dimensions", dimensions)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "table_name", table_name)
        if timestamp is not None:
            pulumi.set(__self__, "timestamp", timestamp)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[str]:
        """
        The name of an Amazon Timestream database that has the table to write records into.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter
    def dimensions(self) -> pulumi.Input[Sequence[pulumi.Input['TopicRuleTimestreamDimensionArgs']]]:
        """
        Metadata attributes of the time series that are written in each measure record.
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: pulumi.Input[Sequence[pulumi.Input['TopicRuleTimestreamDimensionArgs']]]):
        pulumi.set(self, "dimensions", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the role that grants AWS IoT permission to write to the Timestream database table.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[str]:
        """
        The table where the message data will be written.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "table_name", value)

    @property
    @pulumi.getter
    def timestamp(self) -> Optional[pulumi.Input['TopicRuleTimestreamTimestampArgs']]:
        """
        The value to use for the entry's timestamp. If blank, the time that the entry was processed is used.
        """
        return pulumi.get(self, "timestamp")

    @timestamp.setter
    def timestamp(self, value: Optional[pulumi.Input['TopicRuleTimestreamTimestampArgs']]):
        pulumi.set(self, "timestamp", value)


if not MYPY:
    class TopicRuleTimestreamDimensionArgsDict(TypedDict):
        name: pulumi.Input[str]
        value: pulumi.Input[str]
elif False:
    TopicRuleTimestreamDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleTimestreamDimensionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class TopicRuleTimestreamTimestampArgsDict(TypedDict):
        unit: pulumi.Input[str]
        """
        The precision of the timestamp value that results from the expression described in `value` .
        """
        value: pulumi.Input[str]
        """
        An expression that returns a long epoch time value.
        """
elif False:
    TopicRuleTimestreamTimestampArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleTimestreamTimestampArgs:
    def __init__(__self__, *,
                 unit: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] unit: The precision of the timestamp value that results from the expression described in `value` .
        :param pulumi.Input[str] value: An expression that returns a long epoch time value.
        """
        pulumi.set(__self__, "unit", unit)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def unit(self) -> pulumi.Input[str]:
        """
        The precision of the timestamp value that results from the expression described in `value` .
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: pulumi.Input[str]):
        pulumi.set(self, "unit", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        An expression that returns a long epoch time value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class TopicRuleUserPropertyArgsDict(TypedDict):
        key: pulumi.Input[str]
        value: pulumi.Input[str]
elif False:
    TopicRuleUserPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicRuleUserPropertyArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


