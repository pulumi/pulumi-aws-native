# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'AppDataSource',
    'AppEnvironmentVariable',
    'AppSource',
    'AppSslConfiguration',
    'InstanceBlockDeviceMapping',
    'InstanceEbsBlockDevice',
    'InstanceTimeBasedAutoScaling',
    'LayerAutoScalingThresholds',
    'LayerLifecycleEventConfiguration',
    'LayerLoadBasedAutoScaling',
    'LayerRecipes',
    'LayerShutdownEventConfiguration',
    'LayerTag',
    'LayerVolumeConfiguration',
    'StackChefConfiguration',
    'StackConfigurationManager',
    'StackElasticIp',
    'StackRdsDbInstance',
    'StackSource',
    'StackTag',
]

@pulumi.output_type
class AppDataSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppDataSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppDataSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppDataSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 database_name: Optional[str] = None,
                 type: Optional[str] = None):
        AppDataSource._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arn=arn,
            database_name=database_name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arn: Optional[str] = None,
             database_name: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if arn is not None:
            _setter("arn", arn)
        if database_name is not None:
            _setter("database_name", database_name)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> Optional[str]:
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class AppEnvironmentVariable(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str,
                 secure: Optional[bool] = None):
        AppEnvironmentVariable._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
            secure=secure,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             secure: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)
        if secure is not None:
            _setter("secure", secure)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def secure(self) -> Optional[bool]:
        return pulumi.get(self, "secure")


@pulumi.output_type
class AppSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sshKey":
            suggest = "ssh_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password: Optional[str] = None,
                 revision: Optional[str] = None,
                 ssh_key: Optional[str] = None,
                 type: Optional[str] = None,
                 url: Optional[str] = None,
                 username: Optional[str] = None):
        AppSource._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password=password,
            revision=revision,
            ssh_key=ssh_key,
            type=type,
            url=url,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password: Optional[str] = None,
             revision: Optional[str] = None,
             ssh_key: Optional[str] = None,
             type: Optional[str] = None,
             url: Optional[str] = None,
             username: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if password is not None:
            _setter("password", password)
        if revision is not None:
            _setter("revision", revision)
        if ssh_key is not None:
            _setter("ssh_key", ssh_key)
        if type is not None:
            _setter("type", type)
        if url is not None:
            _setter("url", url)
        if username is not None:
            _setter("username", username)

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def revision(self) -> Optional[str]:
        return pulumi.get(self, "revision")

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> Optional[str]:
        return pulumi.get(self, "ssh_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        return pulumi.get(self, "username")


@pulumi.output_type
class AppSslConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateKey":
            suggest = "private_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSslConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSslConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSslConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate: Optional[str] = None,
                 chain: Optional[str] = None,
                 private_key: Optional[str] = None):
        AppSslConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate=certificate,
            chain=chain,
            private_key=private_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate: Optional[str] = None,
             chain: Optional[str] = None,
             private_key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if certificate is not None:
            _setter("certificate", certificate)
        if chain is not None:
            _setter("chain", chain)
        if private_key is not None:
            _setter("private_key", private_key)

    @property
    @pulumi.getter
    def certificate(self) -> Optional[str]:
        return pulumi.get(self, "certificate")

    @property
    @pulumi.getter
    def chain(self) -> Optional[str]:
        return pulumi.get(self, "chain")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[str]:
        return pulumi.get(self, "private_key")


@pulumi.output_type
class InstanceBlockDeviceMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceName":
            suggest = "device_name"
        elif key == "noDevice":
            suggest = "no_device"
        elif key == "virtualName":
            suggest = "virtual_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceBlockDeviceMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceBlockDeviceMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceBlockDeviceMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_name: Optional[str] = None,
                 ebs: Optional['outputs.InstanceEbsBlockDevice'] = None,
                 no_device: Optional[str] = None,
                 virtual_name: Optional[str] = None):
        InstanceBlockDeviceMapping._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            device_name=device_name,
            ebs=ebs,
            no_device=no_device,
            virtual_name=virtual_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             device_name: Optional[str] = None,
             ebs: Optional['outputs.InstanceEbsBlockDevice'] = None,
             no_device: Optional[str] = None,
             virtual_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if device_name is not None:
            _setter("device_name", device_name)
        if ebs is not None:
            _setter("ebs", ebs)
        if no_device is not None:
            _setter("no_device", no_device)
        if virtual_name is not None:
            _setter("virtual_name", virtual_name)

    @property
    @pulumi.getter(name="deviceName")
    def device_name(self) -> Optional[str]:
        return pulumi.get(self, "device_name")

    @property
    @pulumi.getter
    def ebs(self) -> Optional['outputs.InstanceEbsBlockDevice']:
        return pulumi.get(self, "ebs")

    @property
    @pulumi.getter(name="noDevice")
    def no_device(self) -> Optional[str]:
        return pulumi.get(self, "no_device")

    @property
    @pulumi.getter(name="virtualName")
    def virtual_name(self) -> Optional[str]:
        return pulumi.get(self, "virtual_name")


@pulumi.output_type
class InstanceEbsBlockDevice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "snapshotId":
            suggest = "snapshot_id"
        elif key == "volumeSize":
            suggest = "volume_size"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceEbsBlockDevice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceEbsBlockDevice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceEbsBlockDevice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_on_termination: Optional[bool] = None,
                 iops: Optional[int] = None,
                 snapshot_id: Optional[str] = None,
                 volume_size: Optional[int] = None,
                 volume_type: Optional[str] = None):
        InstanceEbsBlockDevice._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            delete_on_termination=delete_on_termination,
            iops=iops,
            snapshot_id=snapshot_id,
            volume_size=volume_size,
            volume_type=volume_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             delete_on_termination: Optional[bool] = None,
             iops: Optional[int] = None,
             snapshot_id: Optional[str] = None,
             volume_size: Optional[int] = None,
             volume_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if delete_on_termination is not None:
            _setter("delete_on_termination", delete_on_termination)
        if iops is not None:
            _setter("iops", iops)
        if snapshot_id is not None:
            _setter("snapshot_id", snapshot_id)
        if volume_size is not None:
            _setter("volume_size", volume_size)
        if volume_type is not None:
            _setter("volume_type", volume_type)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[bool]:
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="snapshotId")
    def snapshot_id(self) -> Optional[str]:
        return pulumi.get(self, "snapshot_id")

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[int]:
        return pulumi.get(self, "volume_size")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[str]:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class InstanceTimeBasedAutoScaling(dict):
    def __init__(__self__, *,
                 friday: Optional[Any] = None,
                 monday: Optional[Any] = None,
                 saturday: Optional[Any] = None,
                 sunday: Optional[Any] = None,
                 thursday: Optional[Any] = None,
                 tuesday: Optional[Any] = None,
                 wednesday: Optional[Any] = None):
        InstanceTimeBasedAutoScaling._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            friday=friday,
            monday=monday,
            saturday=saturday,
            sunday=sunday,
            thursday=thursday,
            tuesday=tuesday,
            wednesday=wednesday,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             friday: Optional[Any] = None,
             monday: Optional[Any] = None,
             saturday: Optional[Any] = None,
             sunday: Optional[Any] = None,
             thursday: Optional[Any] = None,
             tuesday: Optional[Any] = None,
             wednesday: Optional[Any] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if friday is not None:
            _setter("friday", friday)
        if monday is not None:
            _setter("monday", monday)
        if saturday is not None:
            _setter("saturday", saturday)
        if sunday is not None:
            _setter("sunday", sunday)
        if thursday is not None:
            _setter("thursday", thursday)
        if tuesday is not None:
            _setter("tuesday", tuesday)
        if wednesday is not None:
            _setter("wednesday", wednesday)

    @property
    @pulumi.getter
    def friday(self) -> Optional[Any]:
        return pulumi.get(self, "friday")

    @property
    @pulumi.getter
    def monday(self) -> Optional[Any]:
        return pulumi.get(self, "monday")

    @property
    @pulumi.getter
    def saturday(self) -> Optional[Any]:
        return pulumi.get(self, "saturday")

    @property
    @pulumi.getter
    def sunday(self) -> Optional[Any]:
        return pulumi.get(self, "sunday")

    @property
    @pulumi.getter
    def thursday(self) -> Optional[Any]:
        return pulumi.get(self, "thursday")

    @property
    @pulumi.getter
    def tuesday(self) -> Optional[Any]:
        return pulumi.get(self, "tuesday")

    @property
    @pulumi.getter
    def wednesday(self) -> Optional[Any]:
        return pulumi.get(self, "wednesday")


@pulumi.output_type
class LayerAutoScalingThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cpuThreshold":
            suggest = "cpu_threshold"
        elif key == "ignoreMetricsTime":
            suggest = "ignore_metrics_time"
        elif key == "instanceCount":
            suggest = "instance_count"
        elif key == "loadThreshold":
            suggest = "load_threshold"
        elif key == "memoryThreshold":
            suggest = "memory_threshold"
        elif key == "thresholdsWaitTime":
            suggest = "thresholds_wait_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LayerAutoScalingThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LayerAutoScalingThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LayerAutoScalingThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cpu_threshold: Optional[float] = None,
                 ignore_metrics_time: Optional[int] = None,
                 instance_count: Optional[int] = None,
                 load_threshold: Optional[float] = None,
                 memory_threshold: Optional[float] = None,
                 thresholds_wait_time: Optional[int] = None):
        LayerAutoScalingThresholds._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cpu_threshold=cpu_threshold,
            ignore_metrics_time=ignore_metrics_time,
            instance_count=instance_count,
            load_threshold=load_threshold,
            memory_threshold=memory_threshold,
            thresholds_wait_time=thresholds_wait_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cpu_threshold: Optional[float] = None,
             ignore_metrics_time: Optional[int] = None,
             instance_count: Optional[int] = None,
             load_threshold: Optional[float] = None,
             memory_threshold: Optional[float] = None,
             thresholds_wait_time: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if cpu_threshold is not None:
            _setter("cpu_threshold", cpu_threshold)
        if ignore_metrics_time is not None:
            _setter("ignore_metrics_time", ignore_metrics_time)
        if instance_count is not None:
            _setter("instance_count", instance_count)
        if load_threshold is not None:
            _setter("load_threshold", load_threshold)
        if memory_threshold is not None:
            _setter("memory_threshold", memory_threshold)
        if thresholds_wait_time is not None:
            _setter("thresholds_wait_time", thresholds_wait_time)

    @property
    @pulumi.getter(name="cpuThreshold")
    def cpu_threshold(self) -> Optional[float]:
        return pulumi.get(self, "cpu_threshold")

    @property
    @pulumi.getter(name="ignoreMetricsTime")
    def ignore_metrics_time(self) -> Optional[int]:
        return pulumi.get(self, "ignore_metrics_time")

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[int]:
        return pulumi.get(self, "instance_count")

    @property
    @pulumi.getter(name="loadThreshold")
    def load_threshold(self) -> Optional[float]:
        return pulumi.get(self, "load_threshold")

    @property
    @pulumi.getter(name="memoryThreshold")
    def memory_threshold(self) -> Optional[float]:
        return pulumi.get(self, "memory_threshold")

    @property
    @pulumi.getter(name="thresholdsWaitTime")
    def thresholds_wait_time(self) -> Optional[int]:
        return pulumi.get(self, "thresholds_wait_time")


@pulumi.output_type
class LayerLifecycleEventConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "shutdownEventConfiguration":
            suggest = "shutdown_event_configuration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LayerLifecycleEventConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LayerLifecycleEventConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LayerLifecycleEventConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 shutdown_event_configuration: Optional['outputs.LayerShutdownEventConfiguration'] = None):
        LayerLifecycleEventConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            shutdown_event_configuration=shutdown_event_configuration,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             shutdown_event_configuration: Optional['outputs.LayerShutdownEventConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if shutdown_event_configuration is not None:
            _setter("shutdown_event_configuration", shutdown_event_configuration)

    @property
    @pulumi.getter(name="shutdownEventConfiguration")
    def shutdown_event_configuration(self) -> Optional['outputs.LayerShutdownEventConfiguration']:
        return pulumi.get(self, "shutdown_event_configuration")


@pulumi.output_type
class LayerLoadBasedAutoScaling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "downScaling":
            suggest = "down_scaling"
        elif key == "upScaling":
            suggest = "up_scaling"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LayerLoadBasedAutoScaling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LayerLoadBasedAutoScaling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LayerLoadBasedAutoScaling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 down_scaling: Optional['outputs.LayerAutoScalingThresholds'] = None,
                 enable: Optional[bool] = None,
                 up_scaling: Optional['outputs.LayerAutoScalingThresholds'] = None):
        LayerLoadBasedAutoScaling._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            down_scaling=down_scaling,
            enable=enable,
            up_scaling=up_scaling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             down_scaling: Optional['outputs.LayerAutoScalingThresholds'] = None,
             enable: Optional[bool] = None,
             up_scaling: Optional['outputs.LayerAutoScalingThresholds'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if down_scaling is not None:
            _setter("down_scaling", down_scaling)
        if enable is not None:
            _setter("enable", enable)
        if up_scaling is not None:
            _setter("up_scaling", up_scaling)

    @property
    @pulumi.getter(name="downScaling")
    def down_scaling(self) -> Optional['outputs.LayerAutoScalingThresholds']:
        return pulumi.get(self, "down_scaling")

    @property
    @pulumi.getter
    def enable(self) -> Optional[bool]:
        return pulumi.get(self, "enable")

    @property
    @pulumi.getter(name="upScaling")
    def up_scaling(self) -> Optional['outputs.LayerAutoScalingThresholds']:
        return pulumi.get(self, "up_scaling")


@pulumi.output_type
class LayerRecipes(dict):
    def __init__(__self__, *,
                 configure: Optional[Sequence[str]] = None,
                 deploy: Optional[Sequence[str]] = None,
                 setup: Optional[Sequence[str]] = None,
                 shutdown: Optional[Sequence[str]] = None,
                 undeploy: Optional[Sequence[str]] = None):
        LayerRecipes._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            configure=configure,
            deploy=deploy,
            setup=setup,
            shutdown=shutdown,
            undeploy=undeploy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             configure: Optional[Sequence[str]] = None,
             deploy: Optional[Sequence[str]] = None,
             setup: Optional[Sequence[str]] = None,
             shutdown: Optional[Sequence[str]] = None,
             undeploy: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if configure is not None:
            _setter("configure", configure)
        if deploy is not None:
            _setter("deploy", deploy)
        if setup is not None:
            _setter("setup", setup)
        if shutdown is not None:
            _setter("shutdown", shutdown)
        if undeploy is not None:
            _setter("undeploy", undeploy)

    @property
    @pulumi.getter
    def configure(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "configure")

    @property
    @pulumi.getter
    def deploy(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "deploy")

    @property
    @pulumi.getter
    def setup(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "setup")

    @property
    @pulumi.getter
    def shutdown(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "shutdown")

    @property
    @pulumi.getter
    def undeploy(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "undeploy")


@pulumi.output_type
class LayerShutdownEventConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delayUntilElbConnectionsDrained":
            suggest = "delay_until_elb_connections_drained"
        elif key == "executionTimeout":
            suggest = "execution_timeout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LayerShutdownEventConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LayerShutdownEventConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LayerShutdownEventConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delay_until_elb_connections_drained: Optional[bool] = None,
                 execution_timeout: Optional[int] = None):
        LayerShutdownEventConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            delay_until_elb_connections_drained=delay_until_elb_connections_drained,
            execution_timeout=execution_timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             delay_until_elb_connections_drained: Optional[bool] = None,
             execution_timeout: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if delay_until_elb_connections_drained is not None:
            _setter("delay_until_elb_connections_drained", delay_until_elb_connections_drained)
        if execution_timeout is not None:
            _setter("execution_timeout", execution_timeout)

    @property
    @pulumi.getter(name="delayUntilElbConnectionsDrained")
    def delay_until_elb_connections_drained(self) -> Optional[bool]:
        return pulumi.get(self, "delay_until_elb_connections_drained")

    @property
    @pulumi.getter(name="executionTimeout")
    def execution_timeout(self) -> Optional[int]:
        return pulumi.get(self, "execution_timeout")


@pulumi.output_type
class LayerTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        LayerTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class LayerVolumeConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mountPoint":
            suggest = "mount_point"
        elif key == "numberOfDisks":
            suggest = "number_of_disks"
        elif key == "raidLevel":
            suggest = "raid_level"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LayerVolumeConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LayerVolumeConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LayerVolumeConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 encrypted: Optional[bool] = None,
                 iops: Optional[int] = None,
                 mount_point: Optional[str] = None,
                 number_of_disks: Optional[int] = None,
                 raid_level: Optional[int] = None,
                 size: Optional[int] = None,
                 volume_type: Optional[str] = None):
        LayerVolumeConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            encrypted=encrypted,
            iops=iops,
            mount_point=mount_point,
            number_of_disks=number_of_disks,
            raid_level=raid_level,
            size=size,
            volume_type=volume_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             encrypted: Optional[bool] = None,
             iops: Optional[int] = None,
             mount_point: Optional[str] = None,
             number_of_disks: Optional[int] = None,
             raid_level: Optional[int] = None,
             size: Optional[int] = None,
             volume_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if encrypted is not None:
            _setter("encrypted", encrypted)
        if iops is not None:
            _setter("iops", iops)
        if mount_point is not None:
            _setter("mount_point", mount_point)
        if number_of_disks is not None:
            _setter("number_of_disks", number_of_disks)
        if raid_level is not None:
            _setter("raid_level", raid_level)
        if size is not None:
            _setter("size", size)
        if volume_type is not None:
            _setter("volume_type", volume_type)

    @property
    @pulumi.getter
    def encrypted(self) -> Optional[bool]:
        return pulumi.get(self, "encrypted")

    @property
    @pulumi.getter
    def iops(self) -> Optional[int]:
        return pulumi.get(self, "iops")

    @property
    @pulumi.getter(name="mountPoint")
    def mount_point(self) -> Optional[str]:
        return pulumi.get(self, "mount_point")

    @property
    @pulumi.getter(name="numberOfDisks")
    def number_of_disks(self) -> Optional[int]:
        return pulumi.get(self, "number_of_disks")

    @property
    @pulumi.getter(name="raidLevel")
    def raid_level(self) -> Optional[int]:
        return pulumi.get(self, "raid_level")

    @property
    @pulumi.getter
    def size(self) -> Optional[int]:
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[str]:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class StackChefConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "berkshelfVersion":
            suggest = "berkshelf_version"
        elif key == "manageBerkshelf":
            suggest = "manage_berkshelf"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StackChefConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StackChefConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StackChefConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 berkshelf_version: Optional[str] = None,
                 manage_berkshelf: Optional[bool] = None):
        StackChefConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            berkshelf_version=berkshelf_version,
            manage_berkshelf=manage_berkshelf,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             berkshelf_version: Optional[str] = None,
             manage_berkshelf: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if berkshelf_version is not None:
            _setter("berkshelf_version", berkshelf_version)
        if manage_berkshelf is not None:
            _setter("manage_berkshelf", manage_berkshelf)

    @property
    @pulumi.getter(name="berkshelfVersion")
    def berkshelf_version(self) -> Optional[str]:
        return pulumi.get(self, "berkshelf_version")

    @property
    @pulumi.getter(name="manageBerkshelf")
    def manage_berkshelf(self) -> Optional[bool]:
        return pulumi.get(self, "manage_berkshelf")


@pulumi.output_type
class StackConfigurationManager(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 version: Optional[str] = None):
        StackConfigurationManager._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class StackElasticIp(dict):
    def __init__(__self__, *,
                 ip: str,
                 name: Optional[str] = None):
        StackElasticIp._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip=ip,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip: str,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("ip", ip)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def ip(self) -> str:
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class StackRdsDbInstance(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbPassword":
            suggest = "db_password"
        elif key == "dbUser":
            suggest = "db_user"
        elif key == "rdsDbInstanceArn":
            suggest = "rds_db_instance_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StackRdsDbInstance. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StackRdsDbInstance.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StackRdsDbInstance.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 db_password: str,
                 db_user: str,
                 rds_db_instance_arn: str):
        StackRdsDbInstance._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            db_password=db_password,
            db_user=db_user,
            rds_db_instance_arn=rds_db_instance_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             db_password: str,
             db_user: str,
             rds_db_instance_arn: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("db_password", db_password)
        _setter("db_user", db_user)
        _setter("rds_db_instance_arn", rds_db_instance_arn)

    @property
    @pulumi.getter(name="dbPassword")
    def db_password(self) -> str:
        return pulumi.get(self, "db_password")

    @property
    @pulumi.getter(name="dbUser")
    def db_user(self) -> str:
        return pulumi.get(self, "db_user")

    @property
    @pulumi.getter(name="rdsDbInstanceArn")
    def rds_db_instance_arn(self) -> str:
        return pulumi.get(self, "rds_db_instance_arn")


@pulumi.output_type
class StackSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sshKey":
            suggest = "ssh_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StackSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StackSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StackSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password: Optional[str] = None,
                 revision: Optional[str] = None,
                 ssh_key: Optional[str] = None,
                 type: Optional[str] = None,
                 url: Optional[str] = None,
                 username: Optional[str] = None):
        StackSource._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password=password,
            revision=revision,
            ssh_key=ssh_key,
            type=type,
            url=url,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password: Optional[str] = None,
             revision: Optional[str] = None,
             ssh_key: Optional[str] = None,
             type: Optional[str] = None,
             url: Optional[str] = None,
             username: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if password is not None:
            _setter("password", password)
        if revision is not None:
            _setter("revision", revision)
        if ssh_key is not None:
            _setter("ssh_key", ssh_key)
        if type is not None:
            _setter("type", type)
        if url is not None:
            _setter("url", url)
        if username is not None:
            _setter("username", username)

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def revision(self) -> Optional[str]:
        return pulumi.get(self, "revision")

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> Optional[str]:
        return pulumi.get(self, "ssh_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        return pulumi.get(self, "username")


@pulumi.output_type
class StackTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        StackTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


