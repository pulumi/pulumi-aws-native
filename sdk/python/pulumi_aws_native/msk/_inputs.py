# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from ._enums import *

__all__ = [
    'ClusterBrokerLogsArgs',
    'ClusterBrokerNodeGroupInfoArgs',
    'ClusterClientAuthenticationArgs',
    'ClusterCloudWatchLogsArgs',
    'ClusterConfigurationInfoArgs',
    'ClusterConnectivityInfoArgs',
    'ClusterEbsStorageInfoArgs',
    'ClusterEncryptionAtRestArgs',
    'ClusterEncryptionInTransitArgs',
    'ClusterEncryptionInfoArgs',
    'ClusterFirehoseArgs',
    'ClusterIamArgs',
    'ClusterJmxExporterArgs',
    'ClusterLoggingInfoArgs',
    'ClusterNodeExporterArgs',
    'ClusterOpenMonitoringArgs',
    'ClusterPrometheusArgs',
    'ClusterProvisionedThroughputArgs',
    'ClusterPublicAccessArgs',
    'ClusterS3Args',
    'ClusterSaslArgs',
    'ClusterScramArgs',
    'ClusterStorageInfoArgs',
    'ClusterTlsArgs',
    'ClusterUnauthenticatedArgs',
    'ClusterVpcConnectivityClientAuthenticationArgs',
    'ClusterVpcConnectivityIamArgs',
    'ClusterVpcConnectivitySaslArgs',
    'ClusterVpcConnectivityScramArgs',
    'ClusterVpcConnectivityTlsArgs',
    'ClusterVpcConnectivityArgs',
    'ConfigurationLatestRevisionArgs',
    'ReplicatorAmazonMskClusterArgs',
    'ReplicatorConsumerGroupReplicationArgs',
    'ReplicatorKafkaClusterClientVpcConfigArgs',
    'ReplicatorKafkaClusterArgs',
    'ReplicatorReplicationInfoArgs',
    'ReplicatorReplicationStartingPositionArgs',
    'ReplicatorTopicReplicationArgs',
    'ServerlessClusterClientAuthenticationArgs',
    'ServerlessClusterIamArgs',
    'ServerlessClusterSaslArgs',
    'ServerlessClusterVpcConfigArgs',
]

@pulumi.input_type
class ClusterBrokerLogsArgs:
    def __init__(__self__, *,
                 cloud_watch_logs: Optional[pulumi.Input['ClusterCloudWatchLogsArgs']] = None,
                 firehose: Optional[pulumi.Input['ClusterFirehoseArgs']] = None,
                 s3: Optional[pulumi.Input['ClusterS3Args']] = None):
        """
        :param pulumi.Input['ClusterCloudWatchLogsArgs'] cloud_watch_logs: Details of the CloudWatch Logs destination for broker logs.
        :param pulumi.Input['ClusterFirehoseArgs'] firehose: Details of the Kinesis Data Firehose delivery stream that is the destination for broker logs.
        :param pulumi.Input['ClusterS3Args'] s3: Details of the Amazon S3 destination for broker logs.
        """
        if cloud_watch_logs is not None:
            pulumi.set(__self__, "cloud_watch_logs", cloud_watch_logs)
        if firehose is not None:
            pulumi.set(__self__, "firehose", firehose)
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @property
    @pulumi.getter(name="cloudWatchLogs")
    def cloud_watch_logs(self) -> Optional[pulumi.Input['ClusterCloudWatchLogsArgs']]:
        """
        Details of the CloudWatch Logs destination for broker logs.
        """
        return pulumi.get(self, "cloud_watch_logs")

    @cloud_watch_logs.setter
    def cloud_watch_logs(self, value: Optional[pulumi.Input['ClusterCloudWatchLogsArgs']]):
        pulumi.set(self, "cloud_watch_logs", value)

    @property
    @pulumi.getter
    def firehose(self) -> Optional[pulumi.Input['ClusterFirehoseArgs']]:
        """
        Details of the Kinesis Data Firehose delivery stream that is the destination for broker logs.
        """
        return pulumi.get(self, "firehose")

    @firehose.setter
    def firehose(self, value: Optional[pulumi.Input['ClusterFirehoseArgs']]):
        pulumi.set(self, "firehose", value)

    @property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['ClusterS3Args']]:
        """
        Details of the Amazon S3 destination for broker logs.
        """
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['ClusterS3Args']]):
        pulumi.set(self, "s3", value)


@pulumi.input_type
class ClusterBrokerNodeGroupInfoArgs:
    def __init__(__self__, *,
                 client_subnets: pulumi.Input[Sequence[pulumi.Input[str]]],
                 instance_type: pulumi.Input[str],
                 broker_az_distribution: Optional[pulumi.Input[str]] = None,
                 connectivity_info: Optional[pulumi.Input['ClusterConnectivityInfoArgs']] = None,
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 storage_info: Optional[pulumi.Input['ClusterStorageInfoArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] client_subnets: The list of subnets to connect to in the client virtual private cloud (VPC). Amazon creates elastic network interfaces inside these subnets. Client applications use elastic network interfaces to produce and consume data.
               
               If you use the US West (N. California) Region, specify exactly two subnets. For other Regions where Amazon MSK is available, you can specify either two or three subnets. The subnets that you specify must be in distinct Availability Zones. When you create a cluster, Amazon MSK distributes the broker nodes evenly across the subnets that you specify.
               
               Client subnets can't occupy the Availability Zone with ID `use1-az3` .
        :param pulumi.Input[str] instance_type: The type of Amazon EC2 instances to use for brokers. The following instance types are allowed: kafka.m5.large, kafka.m5.xlarge, kafka.m5.2xlarge, kafka.m5.4xlarge, kafka.m5.8xlarge, kafka.m5.12xlarge, kafka.m5.16xlarge, kafka.m5.24xlarge, and kafka.t3.small.
        :param pulumi.Input[str] broker_az_distribution: This parameter is currently not in use.
        :param pulumi.Input['ClusterConnectivityInfoArgs'] connectivity_info: Information about the cluster's connectivity setting.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_groups: The security groups to associate with the elastic network interfaces in order to specify who can connect to and communicate with the Amazon MSK cluster. If you don't specify a security group, Amazon MSK uses the default security group associated with the VPC. If you specify security groups that were shared with you, you must ensure that you have permissions to them. Specifically, you need the `ec2:DescribeSecurityGroups` permission.
        :param pulumi.Input['ClusterStorageInfoArgs'] storage_info: Contains information about storage volumes attached to Amazon MSK broker nodes.
        """
        pulumi.set(__self__, "client_subnets", client_subnets)
        pulumi.set(__self__, "instance_type", instance_type)
        if broker_az_distribution is not None:
            pulumi.set(__self__, "broker_az_distribution", broker_az_distribution)
        if connectivity_info is not None:
            pulumi.set(__self__, "connectivity_info", connectivity_info)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)
        if storage_info is not None:
            pulumi.set(__self__, "storage_info", storage_info)

    @property
    @pulumi.getter(name="clientSubnets")
    def client_subnets(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The list of subnets to connect to in the client virtual private cloud (VPC). Amazon creates elastic network interfaces inside these subnets. Client applications use elastic network interfaces to produce and consume data.

        If you use the US West (N. California) Region, specify exactly two subnets. For other Regions where Amazon MSK is available, you can specify either two or three subnets. The subnets that you specify must be in distinct Availability Zones. When you create a cluster, Amazon MSK distributes the broker nodes evenly across the subnets that you specify.

        Client subnets can't occupy the Availability Zone with ID `use1-az3` .
        """
        return pulumi.get(self, "client_subnets")

    @client_subnets.setter
    def client_subnets(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "client_subnets", value)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> pulumi.Input[str]:
        """
        The type of Amazon EC2 instances to use for brokers. The following instance types are allowed: kafka.m5.large, kafka.m5.xlarge, kafka.m5.2xlarge, kafka.m5.4xlarge, kafka.m5.8xlarge, kafka.m5.12xlarge, kafka.m5.16xlarge, kafka.m5.24xlarge, and kafka.t3.small.
        """
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance_type", value)

    @property
    @pulumi.getter(name="brokerAzDistribution")
    def broker_az_distribution(self) -> Optional[pulumi.Input[str]]:
        """
        This parameter is currently not in use.
        """
        return pulumi.get(self, "broker_az_distribution")

    @broker_az_distribution.setter
    def broker_az_distribution(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "broker_az_distribution", value)

    @property
    @pulumi.getter(name="connectivityInfo")
    def connectivity_info(self) -> Optional[pulumi.Input['ClusterConnectivityInfoArgs']]:
        """
        Information about the cluster's connectivity setting.
        """
        return pulumi.get(self, "connectivity_info")

    @connectivity_info.setter
    def connectivity_info(self, value: Optional[pulumi.Input['ClusterConnectivityInfoArgs']]):
        pulumi.set(self, "connectivity_info", value)

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The security groups to associate with the elastic network interfaces in order to specify who can connect to and communicate with the Amazon MSK cluster. If you don't specify a security group, Amazon MSK uses the default security group associated with the VPC. If you specify security groups that were shared with you, you must ensure that you have permissions to them. Specifically, you need the `ec2:DescribeSecurityGroups` permission.
        """
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_groups", value)

    @property
    @pulumi.getter(name="storageInfo")
    def storage_info(self) -> Optional[pulumi.Input['ClusterStorageInfoArgs']]:
        """
        Contains information about storage volumes attached to Amazon MSK broker nodes.
        """
        return pulumi.get(self, "storage_info")

    @storage_info.setter
    def storage_info(self, value: Optional[pulumi.Input['ClusterStorageInfoArgs']]):
        pulumi.set(self, "storage_info", value)


@pulumi.input_type
class ClusterClientAuthenticationArgs:
    def __init__(__self__, *,
                 sasl: Optional[pulumi.Input['ClusterSaslArgs']] = None,
                 tls: Optional[pulumi.Input['ClusterTlsArgs']] = None,
                 unauthenticated: Optional[pulumi.Input['ClusterUnauthenticatedArgs']] = None):
        """
        :param pulumi.Input['ClusterSaslArgs'] sasl: Details for client authentication using SASL. To turn on SASL, you must also turn on `EncryptionInTransit` by setting `inCluster` to true. You must set `clientBroker` to either `TLS` or `TLS_PLAINTEXT` . If you choose `TLS_PLAINTEXT` , then you must also set `unauthenticated` to true.
        :param pulumi.Input['ClusterTlsArgs'] tls: Details for ClientAuthentication using TLS. To turn on TLS access control, you must also turn on `EncryptionInTransit` by setting `inCluster` to true and `clientBroker` to `TLS` .
        :param pulumi.Input['ClusterUnauthenticatedArgs'] unauthenticated: Details for ClientAuthentication using no authentication.
        """
        if sasl is not None:
            pulumi.set(__self__, "sasl", sasl)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)
        if unauthenticated is not None:
            pulumi.set(__self__, "unauthenticated", unauthenticated)

    @property
    @pulumi.getter
    def sasl(self) -> Optional[pulumi.Input['ClusterSaslArgs']]:
        """
        Details for client authentication using SASL. To turn on SASL, you must also turn on `EncryptionInTransit` by setting `inCluster` to true. You must set `clientBroker` to either `TLS` or `TLS_PLAINTEXT` . If you choose `TLS_PLAINTEXT` , then you must also set `unauthenticated` to true.
        """
        return pulumi.get(self, "sasl")

    @sasl.setter
    def sasl(self, value: Optional[pulumi.Input['ClusterSaslArgs']]):
        pulumi.set(self, "sasl", value)

    @property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input['ClusterTlsArgs']]:
        """
        Details for ClientAuthentication using TLS. To turn on TLS access control, you must also turn on `EncryptionInTransit` by setting `inCluster` to true and `clientBroker` to `TLS` .
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input['ClusterTlsArgs']]):
        pulumi.set(self, "tls", value)

    @property
    @pulumi.getter
    def unauthenticated(self) -> Optional[pulumi.Input['ClusterUnauthenticatedArgs']]:
        """
        Details for ClientAuthentication using no authentication.
        """
        return pulumi.get(self, "unauthenticated")

    @unauthenticated.setter
    def unauthenticated(self, value: Optional[pulumi.Input['ClusterUnauthenticatedArgs']]):
        pulumi.set(self, "unauthenticated", value)


@pulumi.input_type
class ClusterCloudWatchLogsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 log_group: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Specifies whether broker logs get sent to the specified CloudWatch Logs destination.
        :param pulumi.Input[str] log_group: The CloudWatch log group that is the destination for broker logs.
        """
        pulumi.set(__self__, "enabled", enabled)
        if log_group is not None:
            pulumi.set(__self__, "log_group", log_group)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Specifies whether broker logs get sent to the specified CloudWatch Logs destination.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="logGroup")
    def log_group(self) -> Optional[pulumi.Input[str]]:
        """
        The CloudWatch log group that is the destination for broker logs.
        """
        return pulumi.get(self, "log_group")

    @log_group.setter
    def log_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_group", value)


@pulumi.input_type
class ClusterConfigurationInfoArgs:
    def __init__(__self__, *,
                 arn: pulumi.Input[str],
                 revision: pulumi.Input[int]):
        """
        :param pulumi.Input[str] arn: ARN of the configuration to use.
        :param pulumi.Input[int] revision: The revision of the configuration to use.
        """
        pulumi.set(__self__, "arn", arn)
        pulumi.set(__self__, "revision", revision)

    @property
    @pulumi.getter
    def arn(self) -> pulumi.Input[str]:
        """
        ARN of the configuration to use.
        """
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter
    def revision(self) -> pulumi.Input[int]:
        """
        The revision of the configuration to use.
        """
        return pulumi.get(self, "revision")

    @revision.setter
    def revision(self, value: pulumi.Input[int]):
        pulumi.set(self, "revision", value)


@pulumi.input_type
class ClusterConnectivityInfoArgs:
    def __init__(__self__, *,
                 public_access: Optional[pulumi.Input['ClusterPublicAccessArgs']] = None,
                 vpc_connectivity: Optional[pulumi.Input['ClusterVpcConnectivityArgs']] = None):
        """
        :param pulumi.Input['ClusterPublicAccessArgs'] public_access: Access control settings for the cluster's brokers.
        :param pulumi.Input['ClusterVpcConnectivityArgs'] vpc_connectivity: VPC connection control settings for brokers
        """
        if public_access is not None:
            pulumi.set(__self__, "public_access", public_access)
        if vpc_connectivity is not None:
            pulumi.set(__self__, "vpc_connectivity", vpc_connectivity)

    @property
    @pulumi.getter(name="publicAccess")
    def public_access(self) -> Optional[pulumi.Input['ClusterPublicAccessArgs']]:
        """
        Access control settings for the cluster's brokers.
        """
        return pulumi.get(self, "public_access")

    @public_access.setter
    def public_access(self, value: Optional[pulumi.Input['ClusterPublicAccessArgs']]):
        pulumi.set(self, "public_access", value)

    @property
    @pulumi.getter(name="vpcConnectivity")
    def vpc_connectivity(self) -> Optional[pulumi.Input['ClusterVpcConnectivityArgs']]:
        """
        VPC connection control settings for brokers
        """
        return pulumi.get(self, "vpc_connectivity")

    @vpc_connectivity.setter
    def vpc_connectivity(self, value: Optional[pulumi.Input['ClusterVpcConnectivityArgs']]):
        pulumi.set(self, "vpc_connectivity", value)


@pulumi.input_type
class ClusterEbsStorageInfoArgs:
    def __init__(__self__, *,
                 provisioned_throughput: Optional[pulumi.Input['ClusterProvisionedThroughputArgs']] = None,
                 volume_size: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input['ClusterProvisionedThroughputArgs'] provisioned_throughput: EBS volume provisioned throughput information.
        :param pulumi.Input[int] volume_size: The size in GiB of the EBS volume for the data drive on each broker node.
        """
        if provisioned_throughput is not None:
            pulumi.set(__self__, "provisioned_throughput", provisioned_throughput)
        if volume_size is not None:
            pulumi.set(__self__, "volume_size", volume_size)

    @property
    @pulumi.getter(name="provisionedThroughput")
    def provisioned_throughput(self) -> Optional[pulumi.Input['ClusterProvisionedThroughputArgs']]:
        """
        EBS volume provisioned throughput information.
        """
        return pulumi.get(self, "provisioned_throughput")

    @provisioned_throughput.setter
    def provisioned_throughput(self, value: Optional[pulumi.Input['ClusterProvisionedThroughputArgs']]):
        pulumi.set(self, "provisioned_throughput", value)

    @property
    @pulumi.getter(name="volumeSize")
    def volume_size(self) -> Optional[pulumi.Input[int]]:
        """
        The size in GiB of the EBS volume for the data drive on each broker node.
        """
        return pulumi.get(self, "volume_size")

    @volume_size.setter
    def volume_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "volume_size", value)


@pulumi.input_type
class ClusterEncryptionAtRestArgs:
    def __init__(__self__, *,
                 data_volume_kms_key_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] data_volume_kms_key_id: The Amazon Resource Name (ARN) of the Amazon KMS key for encrypting data at rest. If you don't specify a KMS key, MSK creates one for you and uses it.
        """
        pulumi.set(__self__, "data_volume_kms_key_id", data_volume_kms_key_id)

    @property
    @pulumi.getter(name="dataVolumeKmsKeyId")
    def data_volume_kms_key_id(self) -> pulumi.Input[str]:
        """
        The Amazon Resource Name (ARN) of the Amazon KMS key for encrypting data at rest. If you don't specify a KMS key, MSK creates one for you and uses it.
        """
        return pulumi.get(self, "data_volume_kms_key_id")

    @data_volume_kms_key_id.setter
    def data_volume_kms_key_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_volume_kms_key_id", value)


@pulumi.input_type
class ClusterEncryptionInTransitArgs:
    def __init__(__self__, *,
                 client_broker: Optional[pulumi.Input['ClusterEncryptionInTransitClientBroker']] = None,
                 in_cluster: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['ClusterEncryptionInTransitClientBroker'] client_broker: Indicates the encryption setting for data in transit between clients and brokers. You must set it to one of the following values.
               
               `TLS` means that client-broker communication is enabled with TLS only.
               
               `TLS_PLAINTEXT` means that client-broker communication is enabled for both TLS-encrypted, as well as plaintext data.
               
               `PLAINTEXT` means that client-broker communication is enabled in plaintext only.
               
               The default value is `TLS` .
        :param pulumi.Input[bool] in_cluster: When set to true, it indicates that data communication among the broker nodes of the cluster is encrypted. When set to false, the communication happens in plaintext.
               
               The default value is true.
        """
        if client_broker is not None:
            pulumi.set(__self__, "client_broker", client_broker)
        if in_cluster is not None:
            pulumi.set(__self__, "in_cluster", in_cluster)

    @property
    @pulumi.getter(name="clientBroker")
    def client_broker(self) -> Optional[pulumi.Input['ClusterEncryptionInTransitClientBroker']]:
        """
        Indicates the encryption setting for data in transit between clients and brokers. You must set it to one of the following values.

        `TLS` means that client-broker communication is enabled with TLS only.

        `TLS_PLAINTEXT` means that client-broker communication is enabled for both TLS-encrypted, as well as plaintext data.

        `PLAINTEXT` means that client-broker communication is enabled in plaintext only.

        The default value is `TLS` .
        """
        return pulumi.get(self, "client_broker")

    @client_broker.setter
    def client_broker(self, value: Optional[pulumi.Input['ClusterEncryptionInTransitClientBroker']]):
        pulumi.set(self, "client_broker", value)

    @property
    @pulumi.getter(name="inCluster")
    def in_cluster(self) -> Optional[pulumi.Input[bool]]:
        """
        When set to true, it indicates that data communication among the broker nodes of the cluster is encrypted. When set to false, the communication happens in plaintext.

        The default value is true.
        """
        return pulumi.get(self, "in_cluster")

    @in_cluster.setter
    def in_cluster(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "in_cluster", value)


@pulumi.input_type
class ClusterEncryptionInfoArgs:
    def __init__(__self__, *,
                 encryption_at_rest: Optional[pulumi.Input['ClusterEncryptionAtRestArgs']] = None,
                 encryption_in_transit: Optional[pulumi.Input['ClusterEncryptionInTransitArgs']] = None):
        """
        :param pulumi.Input['ClusterEncryptionAtRestArgs'] encryption_at_rest: The data-volume encryption details.
        :param pulumi.Input['ClusterEncryptionInTransitArgs'] encryption_in_transit: The details for encryption in transit.
        """
        if encryption_at_rest is not None:
            pulumi.set(__self__, "encryption_at_rest", encryption_at_rest)
        if encryption_in_transit is not None:
            pulumi.set(__self__, "encryption_in_transit", encryption_in_transit)

    @property
    @pulumi.getter(name="encryptionAtRest")
    def encryption_at_rest(self) -> Optional[pulumi.Input['ClusterEncryptionAtRestArgs']]:
        """
        The data-volume encryption details.
        """
        return pulumi.get(self, "encryption_at_rest")

    @encryption_at_rest.setter
    def encryption_at_rest(self, value: Optional[pulumi.Input['ClusterEncryptionAtRestArgs']]):
        pulumi.set(self, "encryption_at_rest", value)

    @property
    @pulumi.getter(name="encryptionInTransit")
    def encryption_in_transit(self) -> Optional[pulumi.Input['ClusterEncryptionInTransitArgs']]:
        """
        The details for encryption in transit.
        """
        return pulumi.get(self, "encryption_in_transit")

    @encryption_in_transit.setter
    def encryption_in_transit(self, value: Optional[pulumi.Input['ClusterEncryptionInTransitArgs']]):
        pulumi.set(self, "encryption_in_transit", value)


@pulumi.input_type
class ClusterFirehoseArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 delivery_stream: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Specifies whether broker logs get sent to the specified Kinesis Data Firehose delivery stream.
        :param pulumi.Input[str] delivery_stream: The Kinesis Data Firehose delivery stream that is the destination for broker logs.
        """
        pulumi.set(__self__, "enabled", enabled)
        if delivery_stream is not None:
            pulumi.set(__self__, "delivery_stream", delivery_stream)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Specifies whether broker logs get sent to the specified Kinesis Data Firehose delivery stream.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="deliveryStream")
    def delivery_stream(self) -> Optional[pulumi.Input[str]]:
        """
        The Kinesis Data Firehose delivery stream that is the destination for broker logs.
        """
        return pulumi.get(self, "delivery_stream")

    @delivery_stream.setter
    def delivery_stream(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delivery_stream", value)


@pulumi.input_type
class ClusterIamArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] enabled: SASL/IAM authentication is enabled or not.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        SASL/IAM authentication is enabled or not.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class ClusterJmxExporterArgs:
    def __init__(__self__, *,
                 enabled_in_broker: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] enabled_in_broker: Indicates whether you want to enable or disable the JMX Exporter.
        """
        pulumi.set(__self__, "enabled_in_broker", enabled_in_broker)

    @property
    @pulumi.getter(name="enabledInBroker")
    def enabled_in_broker(self) -> pulumi.Input[bool]:
        """
        Indicates whether you want to enable or disable the JMX Exporter.
        """
        return pulumi.get(self, "enabled_in_broker")

    @enabled_in_broker.setter
    def enabled_in_broker(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled_in_broker", value)


@pulumi.input_type
class ClusterLoggingInfoArgs:
    def __init__(__self__, *,
                 broker_logs: pulumi.Input['ClusterBrokerLogsArgs']):
        """
        :param pulumi.Input['ClusterBrokerLogsArgs'] broker_logs: You can configure your MSK cluster to send broker logs to different destination types. This configuration specifies the details of these destinations.
        """
        pulumi.set(__self__, "broker_logs", broker_logs)

    @property
    @pulumi.getter(name="brokerLogs")
    def broker_logs(self) -> pulumi.Input['ClusterBrokerLogsArgs']:
        """
        You can configure your MSK cluster to send broker logs to different destination types. This configuration specifies the details of these destinations.
        """
        return pulumi.get(self, "broker_logs")

    @broker_logs.setter
    def broker_logs(self, value: pulumi.Input['ClusterBrokerLogsArgs']):
        pulumi.set(self, "broker_logs", value)


@pulumi.input_type
class ClusterNodeExporterArgs:
    def __init__(__self__, *,
                 enabled_in_broker: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] enabled_in_broker: Indicates whether you want to enable or disable the Node Exporter.
        """
        pulumi.set(__self__, "enabled_in_broker", enabled_in_broker)

    @property
    @pulumi.getter(name="enabledInBroker")
    def enabled_in_broker(self) -> pulumi.Input[bool]:
        """
        Indicates whether you want to enable or disable the Node Exporter.
        """
        return pulumi.get(self, "enabled_in_broker")

    @enabled_in_broker.setter
    def enabled_in_broker(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled_in_broker", value)


@pulumi.input_type
class ClusterOpenMonitoringArgs:
    def __init__(__self__, *,
                 prometheus: pulumi.Input['ClusterPrometheusArgs']):
        """
        :param pulumi.Input['ClusterPrometheusArgs'] prometheus: Prometheus exporter settings.
        """
        pulumi.set(__self__, "prometheus", prometheus)

    @property
    @pulumi.getter
    def prometheus(self) -> pulumi.Input['ClusterPrometheusArgs']:
        """
        Prometheus exporter settings.
        """
        return pulumi.get(self, "prometheus")

    @prometheus.setter
    def prometheus(self, value: pulumi.Input['ClusterPrometheusArgs']):
        pulumi.set(self, "prometheus", value)


@pulumi.input_type
class ClusterPrometheusArgs:
    def __init__(__self__, *,
                 jmx_exporter: Optional[pulumi.Input['ClusterJmxExporterArgs']] = None,
                 node_exporter: Optional[pulumi.Input['ClusterNodeExporterArgs']] = None):
        """
        :param pulumi.Input['ClusterJmxExporterArgs'] jmx_exporter: Indicates whether you want to enable or disable the JMX Exporter.
        :param pulumi.Input['ClusterNodeExporterArgs'] node_exporter: Indicates whether you want to enable or disable the Node Exporter.
        """
        if jmx_exporter is not None:
            pulumi.set(__self__, "jmx_exporter", jmx_exporter)
        if node_exporter is not None:
            pulumi.set(__self__, "node_exporter", node_exporter)

    @property
    @pulumi.getter(name="jmxExporter")
    def jmx_exporter(self) -> Optional[pulumi.Input['ClusterJmxExporterArgs']]:
        """
        Indicates whether you want to enable or disable the JMX Exporter.
        """
        return pulumi.get(self, "jmx_exporter")

    @jmx_exporter.setter
    def jmx_exporter(self, value: Optional[pulumi.Input['ClusterJmxExporterArgs']]):
        pulumi.set(self, "jmx_exporter", value)

    @property
    @pulumi.getter(name="nodeExporter")
    def node_exporter(self) -> Optional[pulumi.Input['ClusterNodeExporterArgs']]:
        """
        Indicates whether you want to enable or disable the Node Exporter.
        """
        return pulumi.get(self, "node_exporter")

    @node_exporter.setter
    def node_exporter(self, value: Optional[pulumi.Input['ClusterNodeExporterArgs']]):
        pulumi.set(self, "node_exporter", value)


@pulumi.input_type
class ClusterProvisionedThroughputArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 volume_throughput: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] enabled: Provisioned throughput is enabled or not.
        :param pulumi.Input[int] volume_throughput: Throughput value of the EBS volumes for the data drive on each kafka broker node in MiB per second.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if volume_throughput is not None:
            pulumi.set(__self__, "volume_throughput", volume_throughput)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Provisioned throughput is enabled or not.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="volumeThroughput")
    def volume_throughput(self) -> Optional[pulumi.Input[int]]:
        """
        Throughput value of the EBS volumes for the data drive on each kafka broker node in MiB per second.
        """
        return pulumi.get(self, "volume_throughput")

    @volume_throughput.setter
    def volume_throughput(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "volume_throughput", value)


@pulumi.input_type
class ClusterPublicAccessArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: DISABLED means that public access is turned off. SERVICE_PROVIDED_EIPS means that public access is turned on.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        DISABLED means that public access is turned off. SERVICE_PROVIDED_EIPS means that public access is turned on.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ClusterS3Args:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 bucket: Optional[pulumi.Input[str]] = None,
                 prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Specifies whether broker logs get sent to the specified Amazon S3 destination.
        :param pulumi.Input[str] bucket: The name of the S3 bucket that is the destination for broker logs.
        :param pulumi.Input[str] prefix: The S3 prefix that is the destination for broker logs.
        """
        pulumi.set(__self__, "enabled", enabled)
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Specifies whether broker logs get sent to the specified Amazon S3 destination.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the S3 bucket that is the destination for broker logs.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The S3 prefix that is the destination for broker logs.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)


@pulumi.input_type
class ClusterSaslArgs:
    def __init__(__self__, *,
                 iam: Optional[pulumi.Input['ClusterIamArgs']] = None,
                 scram: Optional[pulumi.Input['ClusterScramArgs']] = None):
        """
        :param pulumi.Input['ClusterIamArgs'] iam: Details for ClientAuthentication using IAM.
        :param pulumi.Input['ClusterScramArgs'] scram: Details for SASL/SCRAM client authentication.
        """
        if iam is not None:
            pulumi.set(__self__, "iam", iam)
        if scram is not None:
            pulumi.set(__self__, "scram", scram)

    @property
    @pulumi.getter
    def iam(self) -> Optional[pulumi.Input['ClusterIamArgs']]:
        """
        Details for ClientAuthentication using IAM.
        """
        return pulumi.get(self, "iam")

    @iam.setter
    def iam(self, value: Optional[pulumi.Input['ClusterIamArgs']]):
        pulumi.set(self, "iam", value)

    @property
    @pulumi.getter
    def scram(self) -> Optional[pulumi.Input['ClusterScramArgs']]:
        """
        Details for SASL/SCRAM client authentication.
        """
        return pulumi.get(self, "scram")

    @scram.setter
    def scram(self, value: Optional[pulumi.Input['ClusterScramArgs']]):
        pulumi.set(self, "scram", value)


@pulumi.input_type
class ClusterScramArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] enabled: SASL/SCRAM authentication is enabled or not.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        SASL/SCRAM authentication is enabled or not.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class ClusterStorageInfoArgs:
    def __init__(__self__, *,
                 ebs_storage_info: Optional[pulumi.Input['ClusterEbsStorageInfoArgs']] = None):
        """
        :param pulumi.Input['ClusterEbsStorageInfoArgs'] ebs_storage_info: EBS volume information.
        """
        if ebs_storage_info is not None:
            pulumi.set(__self__, "ebs_storage_info", ebs_storage_info)

    @property
    @pulumi.getter(name="ebsStorageInfo")
    def ebs_storage_info(self) -> Optional[pulumi.Input['ClusterEbsStorageInfoArgs']]:
        """
        EBS volume information.
        """
        return pulumi.get(self, "ebs_storage_info")

    @ebs_storage_info.setter
    def ebs_storage_info(self, value: Optional[pulumi.Input['ClusterEbsStorageInfoArgs']]):
        pulumi.set(self, "ebs_storage_info", value)


@pulumi.input_type
class ClusterTlsArgs:
    def __init__(__self__, *,
                 certificate_authority_arn_list: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] certificate_authority_arn_list: List of AWS Private CA Amazon Resource Name (ARN)s.
        :param pulumi.Input[bool] enabled: TLS authentication is enabled or not.
        """
        if certificate_authority_arn_list is not None:
            pulumi.set(__self__, "certificate_authority_arn_list", certificate_authority_arn_list)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="certificateAuthorityArnList")
    def certificate_authority_arn_list(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of AWS Private CA Amazon Resource Name (ARN)s.
        """
        return pulumi.get(self, "certificate_authority_arn_list")

    @certificate_authority_arn_list.setter
    def certificate_authority_arn_list(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "certificate_authority_arn_list", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        TLS authentication is enabled or not.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class ClusterUnauthenticatedArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] enabled: Unauthenticated is enabled or not.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Unauthenticated is enabled or not.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class ClusterVpcConnectivityClientAuthenticationArgs:
    def __init__(__self__, *,
                 sasl: Optional[pulumi.Input['ClusterVpcConnectivitySaslArgs']] = None,
                 tls: Optional[pulumi.Input['ClusterVpcConnectivityTlsArgs']] = None):
        """
        :param pulumi.Input['ClusterVpcConnectivitySaslArgs'] sasl: Details for VpcConnectivity ClientAuthentication using SASL.
        :param pulumi.Input['ClusterVpcConnectivityTlsArgs'] tls: Details for VpcConnectivity ClientAuthentication using TLS.
        """
        if sasl is not None:
            pulumi.set(__self__, "sasl", sasl)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter
    def sasl(self) -> Optional[pulumi.Input['ClusterVpcConnectivitySaslArgs']]:
        """
        Details for VpcConnectivity ClientAuthentication using SASL.
        """
        return pulumi.get(self, "sasl")

    @sasl.setter
    def sasl(self, value: Optional[pulumi.Input['ClusterVpcConnectivitySaslArgs']]):
        pulumi.set(self, "sasl", value)

    @property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input['ClusterVpcConnectivityTlsArgs']]:
        """
        Details for VpcConnectivity ClientAuthentication using TLS.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input['ClusterVpcConnectivityTlsArgs']]):
        pulumi.set(self, "tls", value)


@pulumi.input_type
class ClusterVpcConnectivityIamArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] enabled: SASL/IAM authentication is enabled or not.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        SASL/IAM authentication is enabled or not.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class ClusterVpcConnectivitySaslArgs:
    def __init__(__self__, *,
                 iam: Optional[pulumi.Input['ClusterVpcConnectivityIamArgs']] = None,
                 scram: Optional[pulumi.Input['ClusterVpcConnectivityScramArgs']] = None):
        """
        :param pulumi.Input['ClusterVpcConnectivityIamArgs'] iam: Details for ClientAuthentication using IAM for VpcConnectivity.
        :param pulumi.Input['ClusterVpcConnectivityScramArgs'] scram: Details for SASL/SCRAM client authentication for VpcConnectivity.
        """
        if iam is not None:
            pulumi.set(__self__, "iam", iam)
        if scram is not None:
            pulumi.set(__self__, "scram", scram)

    @property
    @pulumi.getter
    def iam(self) -> Optional[pulumi.Input['ClusterVpcConnectivityIamArgs']]:
        """
        Details for ClientAuthentication using IAM for VpcConnectivity.
        """
        return pulumi.get(self, "iam")

    @iam.setter
    def iam(self, value: Optional[pulumi.Input['ClusterVpcConnectivityIamArgs']]):
        pulumi.set(self, "iam", value)

    @property
    @pulumi.getter
    def scram(self) -> Optional[pulumi.Input['ClusterVpcConnectivityScramArgs']]:
        """
        Details for SASL/SCRAM client authentication for VpcConnectivity.
        """
        return pulumi.get(self, "scram")

    @scram.setter
    def scram(self, value: Optional[pulumi.Input['ClusterVpcConnectivityScramArgs']]):
        pulumi.set(self, "scram", value)


@pulumi.input_type
class ClusterVpcConnectivityScramArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] enabled: SASL/SCRAM authentication is enabled or not.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        SASL/SCRAM authentication is enabled or not.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class ClusterVpcConnectivityTlsArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] enabled: TLS authentication is enabled or not.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        TLS authentication is enabled or not.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class ClusterVpcConnectivityArgs:
    def __init__(__self__, *,
                 client_authentication: Optional[pulumi.Input['ClusterVpcConnectivityClientAuthenticationArgs']] = None):
        """
        :param pulumi.Input['ClusterVpcConnectivityClientAuthenticationArgs'] client_authentication: VPC connection control settings for brokers.
        """
        if client_authentication is not None:
            pulumi.set(__self__, "client_authentication", client_authentication)

    @property
    @pulumi.getter(name="clientAuthentication")
    def client_authentication(self) -> Optional[pulumi.Input['ClusterVpcConnectivityClientAuthenticationArgs']]:
        """
        VPC connection control settings for brokers.
        """
        return pulumi.get(self, "client_authentication")

    @client_authentication.setter
    def client_authentication(self, value: Optional[pulumi.Input['ClusterVpcConnectivityClientAuthenticationArgs']]):
        pulumi.set(self, "client_authentication", value)


@pulumi.input_type
class ConfigurationLatestRevisionArgs:
    def __init__(__self__, *,
                 creation_time: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 revision: Optional[pulumi.Input[int]] = None):
        if creation_time is not None:
            pulumi.set(__self__, "creation_time", creation_time)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if revision is not None:
            pulumi.set(__self__, "revision", revision)

    @property
    @pulumi.getter(name="creationTime")
    def creation_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "creation_time")

    @creation_time.setter
    def creation_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "creation_time", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def revision(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "revision")

    @revision.setter
    def revision(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "revision", value)


@pulumi.input_type
class ReplicatorAmazonMskClusterArgs:
    def __init__(__self__, *,
                 msk_cluster_arn: pulumi.Input[str]):
        """
        Details of an Amazon MSK cluster.
        :param pulumi.Input[str] msk_cluster_arn: The ARN of an Amazon MSK cluster.
        """
        pulumi.set(__self__, "msk_cluster_arn", msk_cluster_arn)

    @property
    @pulumi.getter(name="mskClusterArn")
    def msk_cluster_arn(self) -> pulumi.Input[str]:
        """
        The ARN of an Amazon MSK cluster.
        """
        return pulumi.get(self, "msk_cluster_arn")

    @msk_cluster_arn.setter
    def msk_cluster_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "msk_cluster_arn", value)


@pulumi.input_type
class ReplicatorConsumerGroupReplicationArgs:
    def __init__(__self__, *,
                 consumer_groups_to_replicate: pulumi.Input[Sequence[pulumi.Input[str]]],
                 consumer_groups_to_exclude: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 detect_and_copy_new_consumer_groups: Optional[pulumi.Input[bool]] = None,
                 synchronise_consumer_group_offsets: Optional[pulumi.Input[bool]] = None):
        """
        Configuration relating to consumer group replication.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] consumer_groups_to_replicate: List of regular expression patterns indicating the consumer groups to copy.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] consumer_groups_to_exclude: List of regular expression patterns indicating the consumer groups that should not be replicated.
        :param pulumi.Input[bool] detect_and_copy_new_consumer_groups: Whether to periodically check for new consumer groups.
        :param pulumi.Input[bool] synchronise_consumer_group_offsets: Whether to periodically write the translated offsets to __consumer_offsets topic in target cluster.
        """
        pulumi.set(__self__, "consumer_groups_to_replicate", consumer_groups_to_replicate)
        if consumer_groups_to_exclude is not None:
            pulumi.set(__self__, "consumer_groups_to_exclude", consumer_groups_to_exclude)
        if detect_and_copy_new_consumer_groups is not None:
            pulumi.set(__self__, "detect_and_copy_new_consumer_groups", detect_and_copy_new_consumer_groups)
        if synchronise_consumer_group_offsets is not None:
            pulumi.set(__self__, "synchronise_consumer_group_offsets", synchronise_consumer_group_offsets)

    @property
    @pulumi.getter(name="consumerGroupsToReplicate")
    def consumer_groups_to_replicate(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of regular expression patterns indicating the consumer groups to copy.
        """
        return pulumi.get(self, "consumer_groups_to_replicate")

    @consumer_groups_to_replicate.setter
    def consumer_groups_to_replicate(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "consumer_groups_to_replicate", value)

    @property
    @pulumi.getter(name="consumerGroupsToExclude")
    def consumer_groups_to_exclude(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of regular expression patterns indicating the consumer groups that should not be replicated.
        """
        return pulumi.get(self, "consumer_groups_to_exclude")

    @consumer_groups_to_exclude.setter
    def consumer_groups_to_exclude(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "consumer_groups_to_exclude", value)

    @property
    @pulumi.getter(name="detectAndCopyNewConsumerGroups")
    def detect_and_copy_new_consumer_groups(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to periodically check for new consumer groups.
        """
        return pulumi.get(self, "detect_and_copy_new_consumer_groups")

    @detect_and_copy_new_consumer_groups.setter
    def detect_and_copy_new_consumer_groups(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "detect_and_copy_new_consumer_groups", value)

    @property
    @pulumi.getter(name="synchroniseConsumerGroupOffsets")
    def synchronise_consumer_group_offsets(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to periodically write the translated offsets to __consumer_offsets topic in target cluster.
        """
        return pulumi.get(self, "synchronise_consumer_group_offsets")

    @synchronise_consumer_group_offsets.setter
    def synchronise_consumer_group_offsets(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "synchronise_consumer_group_offsets", value)


@pulumi.input_type
class ReplicatorKafkaClusterClientVpcConfigArgs:
    def __init__(__self__, *,
                 subnet_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Details of an Amazon VPC which has network connectivity to the Kafka cluster.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subnet_ids: The list of subnets to connect to in the virtual private cloud (VPC). AWS creates elastic network interfaces inside these subnets.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] security_group_ids: The AWS security groups to associate with the elastic network interfaces in order to specify what the replicator has access to. If a security group is not specified, the default security group associated with the VPC is used.
        """
        pulumi.set(__self__, "subnet_ids", subnet_ids)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The list of subnets to connect to in the virtual private cloud (VPC). AWS creates elastic network interfaces inside these subnets.
        """
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "subnet_ids", value)

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The AWS security groups to associate with the elastic network interfaces in order to specify what the replicator has access to. If a security group is not specified, the default security group associated with the VPC is used.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_group_ids", value)


@pulumi.input_type
class ReplicatorKafkaClusterArgs:
    def __init__(__self__, *,
                 amazon_msk_cluster: pulumi.Input['ReplicatorAmazonMskClusterArgs'],
                 vpc_config: pulumi.Input['ReplicatorKafkaClusterClientVpcConfigArgs']):
        """
        Details of a Kafka cluster for replication.
        :param pulumi.Input['ReplicatorAmazonMskClusterArgs'] amazon_msk_cluster: Details of an Amazon MSK cluster. Exactly one of AmazonMskCluster is required.
        :param pulumi.Input['ReplicatorKafkaClusterClientVpcConfigArgs'] vpc_config: Details of an Amazon VPC which has network connectivity to the Apache Kafka cluster.
        """
        pulumi.set(__self__, "amazon_msk_cluster", amazon_msk_cluster)
        pulumi.set(__self__, "vpc_config", vpc_config)

    @property
    @pulumi.getter(name="amazonMskCluster")
    def amazon_msk_cluster(self) -> pulumi.Input['ReplicatorAmazonMskClusterArgs']:
        """
        Details of an Amazon MSK cluster. Exactly one of AmazonMskCluster is required.
        """
        return pulumi.get(self, "amazon_msk_cluster")

    @amazon_msk_cluster.setter
    def amazon_msk_cluster(self, value: pulumi.Input['ReplicatorAmazonMskClusterArgs']):
        pulumi.set(self, "amazon_msk_cluster", value)

    @property
    @pulumi.getter(name="vpcConfig")
    def vpc_config(self) -> pulumi.Input['ReplicatorKafkaClusterClientVpcConfigArgs']:
        """
        Details of an Amazon VPC which has network connectivity to the Apache Kafka cluster.
        """
        return pulumi.get(self, "vpc_config")

    @vpc_config.setter
    def vpc_config(self, value: pulumi.Input['ReplicatorKafkaClusterClientVpcConfigArgs']):
        pulumi.set(self, "vpc_config", value)


@pulumi.input_type
class ReplicatorReplicationInfoArgs:
    def __init__(__self__, *,
                 consumer_group_replication: pulumi.Input['ReplicatorConsumerGroupReplicationArgs'],
                 source_kafka_cluster_arn: pulumi.Input[str],
                 target_compression_type: pulumi.Input['ReplicatorReplicationInfoTargetCompressionType'],
                 target_kafka_cluster_arn: pulumi.Input[str],
                 topic_replication: pulumi.Input['ReplicatorTopicReplicationArgs']):
        """
        Specifies configuration for replication between a source and target Kafka cluster.
        :param pulumi.Input['ReplicatorConsumerGroupReplicationArgs'] consumer_group_replication: Configuration relating to consumer group replication.
        :param pulumi.Input[str] source_kafka_cluster_arn: Amazon Resource Name of the source Kafka cluster.
        :param pulumi.Input['ReplicatorReplicationInfoTargetCompressionType'] target_compression_type: The type of compression to use writing records to target Kafka cluster.
        :param pulumi.Input[str] target_kafka_cluster_arn: Amazon Resource Name of the target Kafka cluster.
        :param pulumi.Input['ReplicatorTopicReplicationArgs'] topic_replication: Configuration relating to topic replication.
        """
        pulumi.set(__self__, "consumer_group_replication", consumer_group_replication)
        pulumi.set(__self__, "source_kafka_cluster_arn", source_kafka_cluster_arn)
        pulumi.set(__self__, "target_compression_type", target_compression_type)
        pulumi.set(__self__, "target_kafka_cluster_arn", target_kafka_cluster_arn)
        pulumi.set(__self__, "topic_replication", topic_replication)

    @property
    @pulumi.getter(name="consumerGroupReplication")
    def consumer_group_replication(self) -> pulumi.Input['ReplicatorConsumerGroupReplicationArgs']:
        """
        Configuration relating to consumer group replication.
        """
        return pulumi.get(self, "consumer_group_replication")

    @consumer_group_replication.setter
    def consumer_group_replication(self, value: pulumi.Input['ReplicatorConsumerGroupReplicationArgs']):
        pulumi.set(self, "consumer_group_replication", value)

    @property
    @pulumi.getter(name="sourceKafkaClusterArn")
    def source_kafka_cluster_arn(self) -> pulumi.Input[str]:
        """
        Amazon Resource Name of the source Kafka cluster.
        """
        return pulumi.get(self, "source_kafka_cluster_arn")

    @source_kafka_cluster_arn.setter
    def source_kafka_cluster_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_kafka_cluster_arn", value)

    @property
    @pulumi.getter(name="targetCompressionType")
    def target_compression_type(self) -> pulumi.Input['ReplicatorReplicationInfoTargetCompressionType']:
        """
        The type of compression to use writing records to target Kafka cluster.
        """
        return pulumi.get(self, "target_compression_type")

    @target_compression_type.setter
    def target_compression_type(self, value: pulumi.Input['ReplicatorReplicationInfoTargetCompressionType']):
        pulumi.set(self, "target_compression_type", value)

    @property
    @pulumi.getter(name="targetKafkaClusterArn")
    def target_kafka_cluster_arn(self) -> pulumi.Input[str]:
        """
        Amazon Resource Name of the target Kafka cluster.
        """
        return pulumi.get(self, "target_kafka_cluster_arn")

    @target_kafka_cluster_arn.setter
    def target_kafka_cluster_arn(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_kafka_cluster_arn", value)

    @property
    @pulumi.getter(name="topicReplication")
    def topic_replication(self) -> pulumi.Input['ReplicatorTopicReplicationArgs']:
        """
        Configuration relating to topic replication.
        """
        return pulumi.get(self, "topic_replication")

    @topic_replication.setter
    def topic_replication(self, value: pulumi.Input['ReplicatorTopicReplicationArgs']):
        pulumi.set(self, "topic_replication", value)


@pulumi.input_type
class ReplicatorReplicationStartingPositionArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input['ReplicatorReplicationStartingPositionType']] = None):
        """
        Configuration for specifying the position in the topics to start replicating from.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['ReplicatorReplicationStartingPositionType']]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['ReplicatorReplicationStartingPositionType']]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ReplicatorTopicReplicationArgs:
    def __init__(__self__, *,
                 topics_to_replicate: pulumi.Input[Sequence[pulumi.Input[str]]],
                 copy_access_control_lists_for_topics: Optional[pulumi.Input[bool]] = None,
                 copy_topic_configurations: Optional[pulumi.Input[bool]] = None,
                 detect_and_copy_new_topics: Optional[pulumi.Input[bool]] = None,
                 starting_position: Optional[pulumi.Input['ReplicatorReplicationStartingPositionArgs']] = None,
                 topics_to_exclude: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] topics_to_replicate: List of regular expression patterns indicating the topics to copy.
        :param pulumi.Input[bool] copy_access_control_lists_for_topics: Whether to periodically configure remote topic ACLs to match their corresponding upstream topics.
        :param pulumi.Input[bool] copy_topic_configurations: Whether to periodically configure remote topics to match their corresponding upstream topics.
        :param pulumi.Input[bool] detect_and_copy_new_topics: Whether to periodically check for new topics and partitions.
        :param pulumi.Input['ReplicatorReplicationStartingPositionArgs'] starting_position: Configuration for specifying the position in the topics to start replicating from.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] topics_to_exclude: List of regular expression patterns indicating the topics that should not be replicated.
        """
        pulumi.set(__self__, "topics_to_replicate", topics_to_replicate)
        if copy_access_control_lists_for_topics is not None:
            pulumi.set(__self__, "copy_access_control_lists_for_topics", copy_access_control_lists_for_topics)
        if copy_topic_configurations is not None:
            pulumi.set(__self__, "copy_topic_configurations", copy_topic_configurations)
        if detect_and_copy_new_topics is not None:
            pulumi.set(__self__, "detect_and_copy_new_topics", detect_and_copy_new_topics)
        if starting_position is not None:
            pulumi.set(__self__, "starting_position", starting_position)
        if topics_to_exclude is not None:
            pulumi.set(__self__, "topics_to_exclude", topics_to_exclude)

    @property
    @pulumi.getter(name="topicsToReplicate")
    def topics_to_replicate(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of regular expression patterns indicating the topics to copy.
        """
        return pulumi.get(self, "topics_to_replicate")

    @topics_to_replicate.setter
    def topics_to_replicate(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "topics_to_replicate", value)

    @property
    @pulumi.getter(name="copyAccessControlListsForTopics")
    def copy_access_control_lists_for_topics(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to periodically configure remote topic ACLs to match their corresponding upstream topics.
        """
        return pulumi.get(self, "copy_access_control_lists_for_topics")

    @copy_access_control_lists_for_topics.setter
    def copy_access_control_lists_for_topics(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "copy_access_control_lists_for_topics", value)

    @property
    @pulumi.getter(name="copyTopicConfigurations")
    def copy_topic_configurations(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to periodically configure remote topics to match their corresponding upstream topics.
        """
        return pulumi.get(self, "copy_topic_configurations")

    @copy_topic_configurations.setter
    def copy_topic_configurations(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "copy_topic_configurations", value)

    @property
    @pulumi.getter(name="detectAndCopyNewTopics")
    def detect_and_copy_new_topics(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to periodically check for new topics and partitions.
        """
        return pulumi.get(self, "detect_and_copy_new_topics")

    @detect_and_copy_new_topics.setter
    def detect_and_copy_new_topics(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "detect_and_copy_new_topics", value)

    @property
    @pulumi.getter(name="startingPosition")
    def starting_position(self) -> Optional[pulumi.Input['ReplicatorReplicationStartingPositionArgs']]:
        """
        Configuration for specifying the position in the topics to start replicating from.
        """
        return pulumi.get(self, "starting_position")

    @starting_position.setter
    def starting_position(self, value: Optional[pulumi.Input['ReplicatorReplicationStartingPositionArgs']]):
        pulumi.set(self, "starting_position", value)

    @property
    @pulumi.getter(name="topicsToExclude")
    def topics_to_exclude(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of regular expression patterns indicating the topics that should not be replicated.
        """
        return pulumi.get(self, "topics_to_exclude")

    @topics_to_exclude.setter
    def topics_to_exclude(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "topics_to_exclude", value)


@pulumi.input_type
class ServerlessClusterClientAuthenticationArgs:
    def __init__(__self__, *,
                 sasl: pulumi.Input['ServerlessClusterSaslArgs']):
        """
        :param pulumi.Input['ServerlessClusterSaslArgs'] sasl: Details for client authentication using SASL. To turn on SASL, you must also turn on `EncryptionInTransit` by setting `inCluster` to true. You must set `clientBroker` to either `TLS` or `TLS_PLAINTEXT` . If you choose `TLS_PLAINTEXT` , then you must also set `unauthenticated` to true.
        """
        pulumi.set(__self__, "sasl", sasl)

    @property
    @pulumi.getter
    def sasl(self) -> pulumi.Input['ServerlessClusterSaslArgs']:
        """
        Details for client authentication using SASL. To turn on SASL, you must also turn on `EncryptionInTransit` by setting `inCluster` to true. You must set `clientBroker` to either `TLS` or `TLS_PLAINTEXT` . If you choose `TLS_PLAINTEXT` , then you must also set `unauthenticated` to true.
        """
        return pulumi.get(self, "sasl")

    @sasl.setter
    def sasl(self, value: pulumi.Input['ServerlessClusterSaslArgs']):
        pulumi.set(self, "sasl", value)


@pulumi.input_type
class ServerlessClusterIamArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] enabled: SASL/IAM authentication is enabled or not.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        SASL/IAM authentication is enabled or not.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class ServerlessClusterSaslArgs:
    def __init__(__self__, *,
                 iam: pulumi.Input['ServerlessClusterIamArgs']):
        """
        :param pulumi.Input['ServerlessClusterIamArgs'] iam: Details for ClientAuthentication using IAM.
        """
        pulumi.set(__self__, "iam", iam)

    @property
    @pulumi.getter
    def iam(self) -> pulumi.Input['ServerlessClusterIamArgs']:
        """
        Details for ClientAuthentication using IAM.
        """
        return pulumi.get(self, "iam")

    @iam.setter
    def iam(self, value: pulumi.Input['ServerlessClusterIamArgs']):
        pulumi.set(self, "iam", value)


@pulumi.input_type
class ServerlessClusterVpcConfigArgs:
    def __init__(__self__, *,
                 subnet_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 security_groups: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        pulumi.set(__self__, "subnet_ids", subnet_ids)
        if security_groups is not None:
            pulumi.set(__self__, "security_groups", security_groups)

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "subnet_ids", value)

    @property
    @pulumi.getter(name="securityGroups")
    def security_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "security_groups")

    @security_groups.setter
    def security_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "security_groups", value)


