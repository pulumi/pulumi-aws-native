# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'BrowserSettingsWebContentFilteringPolicyArgs',
    'BrowserSettingsWebContentFilteringPolicyArgsDict',
    'DataProtectionSettingsCustomPatternArgs',
    'DataProtectionSettingsCustomPatternArgsDict',
    'DataProtectionSettingsInlineRedactionConfigurationArgs',
    'DataProtectionSettingsInlineRedactionConfigurationArgsDict',
    'DataProtectionSettingsInlineRedactionPatternArgs',
    'DataProtectionSettingsInlineRedactionPatternArgsDict',
    'DataProtectionSettingsRedactionPlaceHolderArgs',
    'DataProtectionSettingsRedactionPlaceHolderArgsDict',
    'IpAccessSettingsIpRuleArgs',
    'IpAccessSettingsIpRuleArgsDict',
    'SessionLoggerEventFilter0PropertiesArgs',
    'SessionLoggerEventFilter0PropertiesArgsDict',
    'SessionLoggerEventFilter1PropertiesArgs',
    'SessionLoggerEventFilter1PropertiesArgsDict',
    'SessionLoggerLogConfigurationArgs',
    'SessionLoggerLogConfigurationArgsDict',
    'SessionLoggerS3LogConfigurationArgs',
    'SessionLoggerS3LogConfigurationArgsDict',
    'SessionLoggerUnitArgs',
    'SessionLoggerUnitArgsDict',
    'UserSettingsBrandingConfigurationArgs',
    'UserSettingsBrandingConfigurationArgsDict',
    'UserSettingsCookieSpecificationArgs',
    'UserSettingsCookieSpecificationArgsDict',
    'UserSettingsCookieSynchronizationConfigurationArgs',
    'UserSettingsCookieSynchronizationConfigurationArgsDict',
    'UserSettingsImageMetadataArgs',
    'UserSettingsImageMetadataArgsDict',
    'UserSettingsLocalizedBrandingStringsArgs',
    'UserSettingsLocalizedBrandingStringsArgsDict',
    'UserSettingsToolbarConfigurationArgs',
    'UserSettingsToolbarConfigurationArgsDict',
]

MYPY = False

if not MYPY:
    class BrowserSettingsWebContentFilteringPolicyArgsDict(TypedDict):
        allowed_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        URLs and domains that are always accessible to end users.
        """
        blocked_categories: NotRequired[pulumi.Input[Sequence[pulumi.Input['BrowserSettingsCategory']]]]
        """
        Categories of websites that are blocked on the end user's browsers.
        """
        blocked_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        URLs and domains that end users cannot access.
        """
elif False:
    BrowserSettingsWebContentFilteringPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BrowserSettingsWebContentFilteringPolicyArgs:
    def __init__(__self__, *,
                 allowed_urls: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 blocked_categories: Optional[pulumi.Input[Sequence[pulumi.Input['BrowserSettingsCategory']]]] = None,
                 blocked_urls: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_urls: URLs and domains that are always accessible to end users.
        :param pulumi.Input[Sequence[pulumi.Input['BrowserSettingsCategory']]] blocked_categories: Categories of websites that are blocked on the end user's browsers.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] blocked_urls: URLs and domains that end users cannot access.
        """
        if allowed_urls is not None:
            pulumi.set(__self__, "allowed_urls", allowed_urls)
        if blocked_categories is not None:
            pulumi.set(__self__, "blocked_categories", blocked_categories)
        if blocked_urls is not None:
            pulumi.set(__self__, "blocked_urls", blocked_urls)

    @_builtins.property
    @pulumi.getter(name="allowedUrls")
    def allowed_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        URLs and domains that are always accessible to end users.
        """
        return pulumi.get(self, "allowed_urls")

    @allowed_urls.setter
    def allowed_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_urls", value)

    @_builtins.property
    @pulumi.getter(name="blockedCategories")
    def blocked_categories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BrowserSettingsCategory']]]]:
        """
        Categories of websites that are blocked on the end user's browsers.
        """
        return pulumi.get(self, "blocked_categories")

    @blocked_categories.setter
    def blocked_categories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BrowserSettingsCategory']]]]):
        pulumi.set(self, "blocked_categories", value)

    @_builtins.property
    @pulumi.getter(name="blockedUrls")
    def blocked_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        URLs and domains that end users cannot access.
        """
        return pulumi.get(self, "blocked_urls")

    @blocked_urls.setter
    def blocked_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "blocked_urls", value)


if not MYPY:
    class DataProtectionSettingsCustomPatternArgsDict(TypedDict):
        pattern_name: pulumi.Input[_builtins.str]
        """
        The pattern name for the custom pattern.
        """
        pattern_regex: pulumi.Input[_builtins.str]
        """
        The pattern regex for the customer pattern. The format must follow JavaScript regex format. The pattern must be enclosed between slashes, and can have flags behind the second slash. For example: "/ab+c/gi".
        """
        keyword_regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        The keyword regex for the customer pattern. After there is a match to the pattern regex, the keyword regex is used to search within the proximity of the match. If there is a keyword match, then the match is confirmed. If no keyword regex is provided, the pattern regex match will automatically be confirmed. The format must follow JavaScript regex format. The pattern must be enclosed between slashes, and can have flags behind the second slash. For example, "/ab+c/gi"
        """
        pattern_description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The pattern description for the customer pattern.
        """
elif False:
    DataProtectionSettingsCustomPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataProtectionSettingsCustomPatternArgs:
    def __init__(__self__, *,
                 pattern_name: pulumi.Input[_builtins.str],
                 pattern_regex: pulumi.Input[_builtins.str],
                 keyword_regex: Optional[pulumi.Input[_builtins.str]] = None,
                 pattern_description: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] pattern_name: The pattern name for the custom pattern.
        :param pulumi.Input[_builtins.str] pattern_regex: The pattern regex for the customer pattern. The format must follow JavaScript regex format. The pattern must be enclosed between slashes, and can have flags behind the second slash. For example: "/ab+c/gi".
        :param pulumi.Input[_builtins.str] keyword_regex: The keyword regex for the customer pattern. After there is a match to the pattern regex, the keyword regex is used to search within the proximity of the match. If there is a keyword match, then the match is confirmed. If no keyword regex is provided, the pattern regex match will automatically be confirmed. The format must follow JavaScript regex format. The pattern must be enclosed between slashes, and can have flags behind the second slash. For example, "/ab+c/gi"
        :param pulumi.Input[_builtins.str] pattern_description: The pattern description for the customer pattern.
        """
        pulumi.set(__self__, "pattern_name", pattern_name)
        pulumi.set(__self__, "pattern_regex", pattern_regex)
        if keyword_regex is not None:
            pulumi.set(__self__, "keyword_regex", keyword_regex)
        if pattern_description is not None:
            pulumi.set(__self__, "pattern_description", pattern_description)

    @_builtins.property
    @pulumi.getter(name="patternName")
    def pattern_name(self) -> pulumi.Input[_builtins.str]:
        """
        The pattern name for the custom pattern.
        """
        return pulumi.get(self, "pattern_name")

    @pattern_name.setter
    def pattern_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "pattern_name", value)

    @_builtins.property
    @pulumi.getter(name="patternRegex")
    def pattern_regex(self) -> pulumi.Input[_builtins.str]:
        """
        The pattern regex for the customer pattern. The format must follow JavaScript regex format. The pattern must be enclosed between slashes, and can have flags behind the second slash. For example: "/ab+c/gi".
        """
        return pulumi.get(self, "pattern_regex")

    @pattern_regex.setter
    def pattern_regex(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "pattern_regex", value)

    @_builtins.property
    @pulumi.getter(name="keywordRegex")
    def keyword_regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The keyword regex for the customer pattern. After there is a match to the pattern regex, the keyword regex is used to search within the proximity of the match. If there is a keyword match, then the match is confirmed. If no keyword regex is provided, the pattern regex match will automatically be confirmed. The format must follow JavaScript regex format. The pattern must be enclosed between slashes, and can have flags behind the second slash. For example, "/ab+c/gi"
        """
        return pulumi.get(self, "keyword_regex")

    @keyword_regex.setter
    def keyword_regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "keyword_regex", value)

    @_builtins.property
    @pulumi.getter(name="patternDescription")
    def pattern_description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The pattern description for the customer pattern.
        """
        return pulumi.get(self, "pattern_description")

    @pattern_description.setter
    def pattern_description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pattern_description", value)


if not MYPY:
    class DataProtectionSettingsInlineRedactionConfigurationArgsDict(TypedDict):
        inline_redaction_patterns: pulumi.Input[Sequence[pulumi.Input['DataProtectionSettingsInlineRedactionPatternArgsDict']]]
        """
        The inline redaction patterns to be enabled for the inline redaction configuration.
        """
        global_confidence_level: NotRequired[pulumi.Input[_builtins.float]]
        """
        The global confidence level for the inline redaction configuration. This indicates the certainty of data type matches in the redaction process. Confidence level 3 means high confidence, and requires a formatted text pattern match in order for content to be redacted. Confidence level 2 means medium confidence, and redaction considers both formatted and unformatted text, and adds keyword associate to the logic. Confidence level 1 means low confidence, and redaction is enforced for both formatted pattern + unformatted pattern without keyword. This is applied to patterns that do not have a pattern-level confidence level. Defaults to confidence level 2.
        """
        global_enforced_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The global enforced URL configuration for the inline redaction configuration. This is applied to patterns that do not have a pattern-level enforced URL list.
        """
        global_exempt_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The global exempt URL configuration for the inline redaction configuration. This is applied to patterns that do not have a pattern-level exempt URL list.
        """
elif False:
    DataProtectionSettingsInlineRedactionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataProtectionSettingsInlineRedactionConfigurationArgs:
    def __init__(__self__, *,
                 inline_redaction_patterns: pulumi.Input[Sequence[pulumi.Input['DataProtectionSettingsInlineRedactionPatternArgs']]],
                 global_confidence_level: Optional[pulumi.Input[_builtins.float]] = None,
                 global_enforced_urls: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 global_exempt_urls: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DataProtectionSettingsInlineRedactionPatternArgs']]] inline_redaction_patterns: The inline redaction patterns to be enabled for the inline redaction configuration.
        :param pulumi.Input[_builtins.float] global_confidence_level: The global confidence level for the inline redaction configuration. This indicates the certainty of data type matches in the redaction process. Confidence level 3 means high confidence, and requires a formatted text pattern match in order for content to be redacted. Confidence level 2 means medium confidence, and redaction considers both formatted and unformatted text, and adds keyword associate to the logic. Confidence level 1 means low confidence, and redaction is enforced for both formatted pattern + unformatted pattern without keyword. This is applied to patterns that do not have a pattern-level confidence level. Defaults to confidence level 2.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] global_enforced_urls: The global enforced URL configuration for the inline redaction configuration. This is applied to patterns that do not have a pattern-level enforced URL list.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] global_exempt_urls: The global exempt URL configuration for the inline redaction configuration. This is applied to patterns that do not have a pattern-level exempt URL list.
        """
        pulumi.set(__self__, "inline_redaction_patterns", inline_redaction_patterns)
        if global_confidence_level is not None:
            pulumi.set(__self__, "global_confidence_level", global_confidence_level)
        if global_enforced_urls is not None:
            pulumi.set(__self__, "global_enforced_urls", global_enforced_urls)
        if global_exempt_urls is not None:
            pulumi.set(__self__, "global_exempt_urls", global_exempt_urls)

    @_builtins.property
    @pulumi.getter(name="inlineRedactionPatterns")
    def inline_redaction_patterns(self) -> pulumi.Input[Sequence[pulumi.Input['DataProtectionSettingsInlineRedactionPatternArgs']]]:
        """
        The inline redaction patterns to be enabled for the inline redaction configuration.
        """
        return pulumi.get(self, "inline_redaction_patterns")

    @inline_redaction_patterns.setter
    def inline_redaction_patterns(self, value: pulumi.Input[Sequence[pulumi.Input['DataProtectionSettingsInlineRedactionPatternArgs']]]):
        pulumi.set(self, "inline_redaction_patterns", value)

    @_builtins.property
    @pulumi.getter(name="globalConfidenceLevel")
    def global_confidence_level(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The global confidence level for the inline redaction configuration. This indicates the certainty of data type matches in the redaction process. Confidence level 3 means high confidence, and requires a formatted text pattern match in order for content to be redacted. Confidence level 2 means medium confidence, and redaction considers both formatted and unformatted text, and adds keyword associate to the logic. Confidence level 1 means low confidence, and redaction is enforced for both formatted pattern + unformatted pattern without keyword. This is applied to patterns that do not have a pattern-level confidence level. Defaults to confidence level 2.
        """
        return pulumi.get(self, "global_confidence_level")

    @global_confidence_level.setter
    def global_confidence_level(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "global_confidence_level", value)

    @_builtins.property
    @pulumi.getter(name="globalEnforcedUrls")
    def global_enforced_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The global enforced URL configuration for the inline redaction configuration. This is applied to patterns that do not have a pattern-level enforced URL list.
        """
        return pulumi.get(self, "global_enforced_urls")

    @global_enforced_urls.setter
    def global_enforced_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "global_enforced_urls", value)

    @_builtins.property
    @pulumi.getter(name="globalExemptUrls")
    def global_exempt_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The global exempt URL configuration for the inline redaction configuration. This is applied to patterns that do not have a pattern-level exempt URL list.
        """
        return pulumi.get(self, "global_exempt_urls")

    @global_exempt_urls.setter
    def global_exempt_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "global_exempt_urls", value)


if not MYPY:
    class DataProtectionSettingsInlineRedactionPatternArgsDict(TypedDict):
        redaction_place_holder: pulumi.Input['DataProtectionSettingsRedactionPlaceHolderArgsDict']
        """
        The redaction placeholder that will replace the redacted text in session for the inline redaction pattern.
        """
        built_in_pattern_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The built-in pattern from the list of preconfigured patterns. Either a customPattern or builtInPatternId is required. To view the entire list of data types and their corresponding built-in pattern IDs, see [Base inline redaction](https://docs.aws.amazon.com/workspaces-web/latest/adminguide/base-inline-redaction.html) .
        """
        confidence_level: NotRequired[pulumi.Input[_builtins.float]]
        """
        The confidence level for inline redaction pattern. This indicates the certainty of data type matches in the redaction process. Confidence level 3 means high confidence, and requires a formatted text pattern match in order for content to be redacted. Confidence level 2 means medium confidence, and redaction considers both formatted and unformatted text, and adds keyword associate to the logic. Confidence level 1 means low confidence, and redaction is enforced for both formatted pattern + unformatted pattern without keyword. This overrides the global confidence level.
        """
        custom_pattern: NotRequired[pulumi.Input['DataProtectionSettingsCustomPatternArgsDict']]
        """
        The configuration for a custom pattern. Either a customPattern or builtInPatternId is required.
        """
        enforced_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The enforced URL configuration for the inline redaction pattern. This will override the global enforced URL configuration.
        """
        exempt_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The exempt URL configuration for the inline redaction pattern. This will override the global exempt URL configuration for the inline redaction pattern.
        """
elif False:
    DataProtectionSettingsInlineRedactionPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataProtectionSettingsInlineRedactionPatternArgs:
    def __init__(__self__, *,
                 redaction_place_holder: pulumi.Input['DataProtectionSettingsRedactionPlaceHolderArgs'],
                 built_in_pattern_id: Optional[pulumi.Input[_builtins.str]] = None,
                 confidence_level: Optional[pulumi.Input[_builtins.float]] = None,
                 custom_pattern: Optional[pulumi.Input['DataProtectionSettingsCustomPatternArgs']] = None,
                 enforced_urls: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 exempt_urls: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input['DataProtectionSettingsRedactionPlaceHolderArgs'] redaction_place_holder: The redaction placeholder that will replace the redacted text in session for the inline redaction pattern.
        :param pulumi.Input[_builtins.str] built_in_pattern_id: The built-in pattern from the list of preconfigured patterns. Either a customPattern or builtInPatternId is required. To view the entire list of data types and their corresponding built-in pattern IDs, see [Base inline redaction](https://docs.aws.amazon.com/workspaces-web/latest/adminguide/base-inline-redaction.html) .
        :param pulumi.Input[_builtins.float] confidence_level: The confidence level for inline redaction pattern. This indicates the certainty of data type matches in the redaction process. Confidence level 3 means high confidence, and requires a formatted text pattern match in order for content to be redacted. Confidence level 2 means medium confidence, and redaction considers both formatted and unformatted text, and adds keyword associate to the logic. Confidence level 1 means low confidence, and redaction is enforced for both formatted pattern + unformatted pattern without keyword. This overrides the global confidence level.
        :param pulumi.Input['DataProtectionSettingsCustomPatternArgs'] custom_pattern: The configuration for a custom pattern. Either a customPattern or builtInPatternId is required.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] enforced_urls: The enforced URL configuration for the inline redaction pattern. This will override the global enforced URL configuration.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exempt_urls: The exempt URL configuration for the inline redaction pattern. This will override the global exempt URL configuration for the inline redaction pattern.
        """
        pulumi.set(__self__, "redaction_place_holder", redaction_place_holder)
        if built_in_pattern_id is not None:
            pulumi.set(__self__, "built_in_pattern_id", built_in_pattern_id)
        if confidence_level is not None:
            pulumi.set(__self__, "confidence_level", confidence_level)
        if custom_pattern is not None:
            pulumi.set(__self__, "custom_pattern", custom_pattern)
        if enforced_urls is not None:
            pulumi.set(__self__, "enforced_urls", enforced_urls)
        if exempt_urls is not None:
            pulumi.set(__self__, "exempt_urls", exempt_urls)

    @_builtins.property
    @pulumi.getter(name="redactionPlaceHolder")
    def redaction_place_holder(self) -> pulumi.Input['DataProtectionSettingsRedactionPlaceHolderArgs']:
        """
        The redaction placeholder that will replace the redacted text in session for the inline redaction pattern.
        """
        return pulumi.get(self, "redaction_place_holder")

    @redaction_place_holder.setter
    def redaction_place_holder(self, value: pulumi.Input['DataProtectionSettingsRedactionPlaceHolderArgs']):
        pulumi.set(self, "redaction_place_holder", value)

    @_builtins.property
    @pulumi.getter(name="builtInPatternId")
    def built_in_pattern_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The built-in pattern from the list of preconfigured patterns. Either a customPattern or builtInPatternId is required. To view the entire list of data types and their corresponding built-in pattern IDs, see [Base inline redaction](https://docs.aws.amazon.com/workspaces-web/latest/adminguide/base-inline-redaction.html) .
        """
        return pulumi.get(self, "built_in_pattern_id")

    @built_in_pattern_id.setter
    def built_in_pattern_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "built_in_pattern_id", value)

    @_builtins.property
    @pulumi.getter(name="confidenceLevel")
    def confidence_level(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The confidence level for inline redaction pattern. This indicates the certainty of data type matches in the redaction process. Confidence level 3 means high confidence, and requires a formatted text pattern match in order for content to be redacted. Confidence level 2 means medium confidence, and redaction considers both formatted and unformatted text, and adds keyword associate to the logic. Confidence level 1 means low confidence, and redaction is enforced for both formatted pattern + unformatted pattern without keyword. This overrides the global confidence level.
        """
        return pulumi.get(self, "confidence_level")

    @confidence_level.setter
    def confidence_level(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "confidence_level", value)

    @_builtins.property
    @pulumi.getter(name="customPattern")
    def custom_pattern(self) -> Optional[pulumi.Input['DataProtectionSettingsCustomPatternArgs']]:
        """
        The configuration for a custom pattern. Either a customPattern or builtInPatternId is required.
        """
        return pulumi.get(self, "custom_pattern")

    @custom_pattern.setter
    def custom_pattern(self, value: Optional[pulumi.Input['DataProtectionSettingsCustomPatternArgs']]):
        pulumi.set(self, "custom_pattern", value)

    @_builtins.property
    @pulumi.getter(name="enforcedUrls")
    def enforced_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The enforced URL configuration for the inline redaction pattern. This will override the global enforced URL configuration.
        """
        return pulumi.get(self, "enforced_urls")

    @enforced_urls.setter
    def enforced_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "enforced_urls", value)

    @_builtins.property
    @pulumi.getter(name="exemptUrls")
    def exempt_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The exempt URL configuration for the inline redaction pattern. This will override the global exempt URL configuration for the inline redaction pattern.
        """
        return pulumi.get(self, "exempt_urls")

    @exempt_urls.setter
    def exempt_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exempt_urls", value)


if not MYPY:
    class DataProtectionSettingsRedactionPlaceHolderArgsDict(TypedDict):
        redaction_place_holder_type: pulumi.Input['DataProtectionSettingsRedactionPlaceHolderType']
        """
        The redaction placeholder type that will replace the redacted text in session.
        """
        redaction_place_holder_text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The redaction placeholder text that will replace the redacted text in session for the custom text redaction placeholder type.
        """
elif False:
    DataProtectionSettingsRedactionPlaceHolderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataProtectionSettingsRedactionPlaceHolderArgs:
    def __init__(__self__, *,
                 redaction_place_holder_type: pulumi.Input['DataProtectionSettingsRedactionPlaceHolderType'],
                 redaction_place_holder_text: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['DataProtectionSettingsRedactionPlaceHolderType'] redaction_place_holder_type: The redaction placeholder type that will replace the redacted text in session.
        :param pulumi.Input[_builtins.str] redaction_place_holder_text: The redaction placeholder text that will replace the redacted text in session for the custom text redaction placeholder type.
        """
        pulumi.set(__self__, "redaction_place_holder_type", redaction_place_holder_type)
        if redaction_place_holder_text is not None:
            pulumi.set(__self__, "redaction_place_holder_text", redaction_place_holder_text)

    @_builtins.property
    @pulumi.getter(name="redactionPlaceHolderType")
    def redaction_place_holder_type(self) -> pulumi.Input['DataProtectionSettingsRedactionPlaceHolderType']:
        """
        The redaction placeholder type that will replace the redacted text in session.
        """
        return pulumi.get(self, "redaction_place_holder_type")

    @redaction_place_holder_type.setter
    def redaction_place_holder_type(self, value: pulumi.Input['DataProtectionSettingsRedactionPlaceHolderType']):
        pulumi.set(self, "redaction_place_holder_type", value)

    @_builtins.property
    @pulumi.getter(name="redactionPlaceHolderText")
    def redaction_place_holder_text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The redaction placeholder text that will replace the redacted text in session for the custom text redaction placeholder type.
        """
        return pulumi.get(self, "redaction_place_holder_text")

    @redaction_place_holder_text.setter
    def redaction_place_holder_text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "redaction_place_holder_text", value)


if not MYPY:
    class IpAccessSettingsIpRuleArgsDict(TypedDict):
        ip_range: pulumi.Input[_builtins.str]
        """
        A single IP address or an IP address range in CIDR notation
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the IP rule.
        """
elif False:
    IpAccessSettingsIpRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpAccessSettingsIpRuleArgs:
    def __init__(__self__, *,
                 ip_range: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ip_range: A single IP address or an IP address range in CIDR notation
        :param pulumi.Input[_builtins.str] description: The description of the IP rule.
        """
        pulumi.set(__self__, "ip_range", ip_range)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter(name="ipRange")
    def ip_range(self) -> pulumi.Input[_builtins.str]:
        """
        A single IP address or an IP address range in CIDR notation
        """
        return pulumi.get(self, "ip_range")

    @ip_range.setter
    def ip_range(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip_range", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the IP rule.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class SessionLoggerEventFilter0PropertiesArgsDict(TypedDict):
        all: pulumi.Input['SessionLoggerUnitArgsDict']
elif False:
    SessionLoggerEventFilter0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SessionLoggerEventFilter0PropertiesArgs:
    def __init__(__self__, *,
                 all: pulumi.Input['SessionLoggerUnitArgs']):
        pulumi.set(__self__, "all", all)

    @_builtins.property
    @pulumi.getter
    def all(self) -> pulumi.Input['SessionLoggerUnitArgs']:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: pulumi.Input['SessionLoggerUnitArgs']):
        pulumi.set(self, "all", value)


if not MYPY:
    class SessionLoggerEventFilter1PropertiesArgsDict(TypedDict):
        include: pulumi.Input[Sequence[pulumi.Input['SessionLoggerEvent']]]
elif False:
    SessionLoggerEventFilter1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SessionLoggerEventFilter1PropertiesArgs:
    def __init__(__self__, *,
                 include: pulumi.Input[Sequence[pulumi.Input['SessionLoggerEvent']]]):
        pulumi.set(__self__, "include", include)

    @_builtins.property
    @pulumi.getter
    def include(self) -> pulumi.Input[Sequence[pulumi.Input['SessionLoggerEvent']]]:
        return pulumi.get(self, "include")

    @include.setter
    def include(self, value: pulumi.Input[Sequence[pulumi.Input['SessionLoggerEvent']]]):
        pulumi.set(self, "include", value)


if not MYPY:
    class SessionLoggerLogConfigurationArgsDict(TypedDict):
        s3: NotRequired[pulumi.Input['SessionLoggerS3LogConfigurationArgsDict']]
        """
        The configuration for delivering the logs to S3.
        """
elif False:
    SessionLoggerLogConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SessionLoggerLogConfigurationArgs:
    def __init__(__self__, *,
                 s3: Optional[pulumi.Input['SessionLoggerS3LogConfigurationArgs']] = None):
        """
        :param pulumi.Input['SessionLoggerS3LogConfigurationArgs'] s3: The configuration for delivering the logs to S3.
        """
        if s3 is not None:
            pulumi.set(__self__, "s3", s3)

    @_builtins.property
    @pulumi.getter
    def s3(self) -> Optional[pulumi.Input['SessionLoggerS3LogConfigurationArgs']]:
        """
        The configuration for delivering the logs to S3.
        """
        return pulumi.get(self, "s3")

    @s3.setter
    def s3(self, value: Optional[pulumi.Input['SessionLoggerS3LogConfigurationArgs']]):
        pulumi.set(self, "s3", value)


if not MYPY:
    class SessionLoggerS3LogConfigurationArgsDict(TypedDict):
        bucket: pulumi.Input[_builtins.str]
        """
        The S3 bucket name where logs are delivered.
        """
        folder_structure: pulumi.Input['SessionLoggerFolderStructure']
        """
        The folder structure that defines the organizational structure for log files in S3.
        """
        log_file_format: pulumi.Input['SessionLoggerLogFileFormat']
        """
        The format of the LogFile that is written to S3.
        """
        bucket_owner: NotRequired[pulumi.Input[_builtins.str]]
        """
        The expected bucket owner of the target S3 bucket. The caller must have permissions to write to the target bucket.
        """
        key_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The S3 path prefix that determines where log files are stored.
        """
elif False:
    SessionLoggerS3LogConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SessionLoggerS3LogConfigurationArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[_builtins.str],
                 folder_structure: pulumi.Input['SessionLoggerFolderStructure'],
                 log_file_format: pulumi.Input['SessionLoggerLogFileFormat'],
                 bucket_owner: Optional[pulumi.Input[_builtins.str]] = None,
                 key_prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket: The S3 bucket name where logs are delivered.
        :param pulumi.Input['SessionLoggerFolderStructure'] folder_structure: The folder structure that defines the organizational structure for log files in S3.
        :param pulumi.Input['SessionLoggerLogFileFormat'] log_file_format: The format of the LogFile that is written to S3.
        :param pulumi.Input[_builtins.str] bucket_owner: The expected bucket owner of the target S3 bucket. The caller must have permissions to write to the target bucket.
        :param pulumi.Input[_builtins.str] key_prefix: The S3 path prefix that determines where log files are stored.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "folder_structure", folder_structure)
        pulumi.set(__self__, "log_file_format", log_file_format)
        if bucket_owner is not None:
            pulumi.set(__self__, "bucket_owner", bucket_owner)
        if key_prefix is not None:
            pulumi.set(__self__, "key_prefix", key_prefix)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[_builtins.str]:
        """
        The S3 bucket name where logs are delivered.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter(name="folderStructure")
    def folder_structure(self) -> pulumi.Input['SessionLoggerFolderStructure']:
        """
        The folder structure that defines the organizational structure for log files in S3.
        """
        return pulumi.get(self, "folder_structure")

    @folder_structure.setter
    def folder_structure(self, value: pulumi.Input['SessionLoggerFolderStructure']):
        pulumi.set(self, "folder_structure", value)

    @_builtins.property
    @pulumi.getter(name="logFileFormat")
    def log_file_format(self) -> pulumi.Input['SessionLoggerLogFileFormat']:
        """
        The format of the LogFile that is written to S3.
        """
        return pulumi.get(self, "log_file_format")

    @log_file_format.setter
    def log_file_format(self, value: pulumi.Input['SessionLoggerLogFileFormat']):
        pulumi.set(self, "log_file_format", value)

    @_builtins.property
    @pulumi.getter(name="bucketOwner")
    def bucket_owner(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The expected bucket owner of the target S3 bucket. The caller must have permissions to write to the target bucket.
        """
        return pulumi.get(self, "bucket_owner")

    @bucket_owner.setter
    def bucket_owner(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_owner", value)

    @_builtins.property
    @pulumi.getter(name="keyPrefix")
    def key_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The S3 path prefix that determines where log files are stored.
        """
        return pulumi.get(self, "key_prefix")

    @key_prefix.setter
    def key_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_prefix", value)


if not MYPY:
    class SessionLoggerUnitArgsDict(TypedDict):
        pass
elif False:
    SessionLoggerUnitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SessionLoggerUnitArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class UserSettingsBrandingConfigurationArgsDict(TypedDict):
        color_theme: NotRequired[pulumi.Input['UserSettingsColorTheme']]
        """
        The color theme for components on the web portal. Choose `Light` if you upload a dark wallpaper, or `Dark` for a light wallpaper.
        """
        favicon: NotRequired[pulumi.Input[_builtins.str]]
        """
        The favicon image for the portal. Provide either a binary image file or an S3 URI pointing to the image file. Maximum 100 KB in JPEG, PNG, or ICO format.
        """
        favicon_metadata: NotRequired[pulumi.Input['UserSettingsImageMetadataArgsDict']]
        """
        Read-only. Metadata for the favicon image file, including the MIME type, file extension, and upload timestamp. This property is automatically populated by the service and cannot be specified in your template. It can be retrieved using the `Fn::GetAtt` intrinsic function.
        """
        localized_strings: NotRequired[pulumi.Input[Mapping[str, pulumi.Input['UserSettingsLocalizedBrandingStringsArgsDict']]]]
        """
        A map of localized text strings for different languages, allowing the portal to display content in the user's preferred language.
        """
        logo: NotRequired[pulumi.Input[_builtins.str]]
        """
        The logo image for the portal. Provide either a binary image file or an S3 URI pointing to the image file. Maximum 100 KB in JPEG, PNG, or ICO format.
        """
        logo_metadata: NotRequired[pulumi.Input['UserSettingsImageMetadataArgsDict']]
        """
        Read-only. Metadata for the logo image file, including the MIME type, file extension, and upload timestamp. This property is automatically populated by the service and cannot be specified in your template. It can be retrieved using the `Fn::GetAtt` intrinsic function.
        """
        terms_of_service: NotRequired[pulumi.Input[_builtins.str]]
        """
        The terms of service text in Markdown format that users must accept before accessing the portal.
        """
        wallpaper: NotRequired[pulumi.Input[_builtins.str]]
        """
        The wallpaper image for the portal. Provide either a binary image file or an S3 URI pointing to the image file. Maximum 5 MB in JPEG or PNG format.
        """
        wallpaper_metadata: NotRequired[pulumi.Input['UserSettingsImageMetadataArgsDict']]
        """
        Read-only. Metadata for the wallpaper image file, including the MIME type, file extension, and upload timestamp. This property is automatically populated by the service and cannot be specified in your template. It can be retrieved using the `Fn::GetAtt` intrinsic function.
        """
elif False:
    UserSettingsBrandingConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserSettingsBrandingConfigurationArgs:
    def __init__(__self__, *,
                 color_theme: Optional[pulumi.Input['UserSettingsColorTheme']] = None,
                 favicon: Optional[pulumi.Input[_builtins.str]] = None,
                 favicon_metadata: Optional[pulumi.Input['UserSettingsImageMetadataArgs']] = None,
                 localized_strings: Optional[pulumi.Input[Mapping[str, pulumi.Input['UserSettingsLocalizedBrandingStringsArgs']]]] = None,
                 logo: Optional[pulumi.Input[_builtins.str]] = None,
                 logo_metadata: Optional[pulumi.Input['UserSettingsImageMetadataArgs']] = None,
                 terms_of_service: Optional[pulumi.Input[_builtins.str]] = None,
                 wallpaper: Optional[pulumi.Input[_builtins.str]] = None,
                 wallpaper_metadata: Optional[pulumi.Input['UserSettingsImageMetadataArgs']] = None):
        """
        :param pulumi.Input['UserSettingsColorTheme'] color_theme: The color theme for components on the web portal. Choose `Light` if you upload a dark wallpaper, or `Dark` for a light wallpaper.
        :param pulumi.Input[_builtins.str] favicon: The favicon image for the portal. Provide either a binary image file or an S3 URI pointing to the image file. Maximum 100 KB in JPEG, PNG, or ICO format.
        :param pulumi.Input['UserSettingsImageMetadataArgs'] favicon_metadata: Read-only. Metadata for the favicon image file, including the MIME type, file extension, and upload timestamp. This property is automatically populated by the service and cannot be specified in your template. It can be retrieved using the `Fn::GetAtt` intrinsic function.
        :param pulumi.Input[Mapping[str, pulumi.Input['UserSettingsLocalizedBrandingStringsArgs']]] localized_strings: A map of localized text strings for different languages, allowing the portal to display content in the user's preferred language.
        :param pulumi.Input[_builtins.str] logo: The logo image for the portal. Provide either a binary image file or an S3 URI pointing to the image file. Maximum 100 KB in JPEG, PNG, or ICO format.
        :param pulumi.Input['UserSettingsImageMetadataArgs'] logo_metadata: Read-only. Metadata for the logo image file, including the MIME type, file extension, and upload timestamp. This property is automatically populated by the service and cannot be specified in your template. It can be retrieved using the `Fn::GetAtt` intrinsic function.
        :param pulumi.Input[_builtins.str] terms_of_service: The terms of service text in Markdown format that users must accept before accessing the portal.
        :param pulumi.Input[_builtins.str] wallpaper: The wallpaper image for the portal. Provide either a binary image file or an S3 URI pointing to the image file. Maximum 5 MB in JPEG or PNG format.
        :param pulumi.Input['UserSettingsImageMetadataArgs'] wallpaper_metadata: Read-only. Metadata for the wallpaper image file, including the MIME type, file extension, and upload timestamp. This property is automatically populated by the service and cannot be specified in your template. It can be retrieved using the `Fn::GetAtt` intrinsic function.
        """
        if color_theme is not None:
            pulumi.set(__self__, "color_theme", color_theme)
        if favicon is not None:
            pulumi.set(__self__, "favicon", favicon)
        if favicon_metadata is not None:
            pulumi.set(__self__, "favicon_metadata", favicon_metadata)
        if localized_strings is not None:
            pulumi.set(__self__, "localized_strings", localized_strings)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if logo_metadata is not None:
            pulumi.set(__self__, "logo_metadata", logo_metadata)
        if terms_of_service is not None:
            pulumi.set(__self__, "terms_of_service", terms_of_service)
        if wallpaper is not None:
            pulumi.set(__self__, "wallpaper", wallpaper)
        if wallpaper_metadata is not None:
            pulumi.set(__self__, "wallpaper_metadata", wallpaper_metadata)

    @_builtins.property
    @pulumi.getter(name="colorTheme")
    def color_theme(self) -> Optional[pulumi.Input['UserSettingsColorTheme']]:
        """
        The color theme for components on the web portal. Choose `Light` if you upload a dark wallpaper, or `Dark` for a light wallpaper.
        """
        return pulumi.get(self, "color_theme")

    @color_theme.setter
    def color_theme(self, value: Optional[pulumi.Input['UserSettingsColorTheme']]):
        pulumi.set(self, "color_theme", value)

    @_builtins.property
    @pulumi.getter
    def favicon(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The favicon image for the portal. Provide either a binary image file or an S3 URI pointing to the image file. Maximum 100 KB in JPEG, PNG, or ICO format.
        """
        return pulumi.get(self, "favicon")

    @favicon.setter
    def favicon(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "favicon", value)

    @_builtins.property
    @pulumi.getter(name="faviconMetadata")
    def favicon_metadata(self) -> Optional[pulumi.Input['UserSettingsImageMetadataArgs']]:
        """
        Read-only. Metadata for the favicon image file, including the MIME type, file extension, and upload timestamp. This property is automatically populated by the service and cannot be specified in your template. It can be retrieved using the `Fn::GetAtt` intrinsic function.
        """
        return pulumi.get(self, "favicon_metadata")

    @favicon_metadata.setter
    def favicon_metadata(self, value: Optional[pulumi.Input['UserSettingsImageMetadataArgs']]):
        pulumi.set(self, "favicon_metadata", value)

    @_builtins.property
    @pulumi.getter(name="localizedStrings")
    def localized_strings(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input['UserSettingsLocalizedBrandingStringsArgs']]]]:
        """
        A map of localized text strings for different languages, allowing the portal to display content in the user's preferred language.
        """
        return pulumi.get(self, "localized_strings")

    @localized_strings.setter
    def localized_strings(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input['UserSettingsLocalizedBrandingStringsArgs']]]]):
        pulumi.set(self, "localized_strings", value)

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The logo image for the portal. Provide either a binary image file or an S3 URI pointing to the image file. Maximum 100 KB in JPEG, PNG, or ICO format.
        """
        return pulumi.get(self, "logo")

    @logo.setter
    def logo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logo", value)

    @_builtins.property
    @pulumi.getter(name="logoMetadata")
    def logo_metadata(self) -> Optional[pulumi.Input['UserSettingsImageMetadataArgs']]:
        """
        Read-only. Metadata for the logo image file, including the MIME type, file extension, and upload timestamp. This property is automatically populated by the service and cannot be specified in your template. It can be retrieved using the `Fn::GetAtt` intrinsic function.
        """
        return pulumi.get(self, "logo_metadata")

    @logo_metadata.setter
    def logo_metadata(self, value: Optional[pulumi.Input['UserSettingsImageMetadataArgs']]):
        pulumi.set(self, "logo_metadata", value)

    @_builtins.property
    @pulumi.getter(name="termsOfService")
    def terms_of_service(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The terms of service text in Markdown format that users must accept before accessing the portal.
        """
        return pulumi.get(self, "terms_of_service")

    @terms_of_service.setter
    def terms_of_service(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "terms_of_service", value)

    @_builtins.property
    @pulumi.getter
    def wallpaper(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The wallpaper image for the portal. Provide either a binary image file or an S3 URI pointing to the image file. Maximum 5 MB in JPEG or PNG format.
        """
        return pulumi.get(self, "wallpaper")

    @wallpaper.setter
    def wallpaper(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "wallpaper", value)

    @_builtins.property
    @pulumi.getter(name="wallpaperMetadata")
    def wallpaper_metadata(self) -> Optional[pulumi.Input['UserSettingsImageMetadataArgs']]:
        """
        Read-only. Metadata for the wallpaper image file, including the MIME type, file extension, and upload timestamp. This property is automatically populated by the service and cannot be specified in your template. It can be retrieved using the `Fn::GetAtt` intrinsic function.
        """
        return pulumi.get(self, "wallpaper_metadata")

    @wallpaper_metadata.setter
    def wallpaper_metadata(self, value: Optional[pulumi.Input['UserSettingsImageMetadataArgs']]):
        pulumi.set(self, "wallpaper_metadata", value)


if not MYPY:
    class UserSettingsCookieSpecificationArgsDict(TypedDict):
        domain: pulumi.Input[_builtins.str]
        """
        The domain of the cookie.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the cookie.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path of the cookie.
        """
elif False:
    UserSettingsCookieSpecificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserSettingsCookieSpecificationArgs:
    def __init__(__self__, *,
                 domain: pulumi.Input[_builtins.str],
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] domain: The domain of the cookie.
        :param pulumi.Input[_builtins.str] name: The name of the cookie.
        :param pulumi.Input[_builtins.str] path: The path of the cookie.
        """
        pulumi.set(__self__, "domain", domain)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> pulumi.Input[_builtins.str]:
        """
        The domain of the cookie.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "domain", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the cookie.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path of the cookie.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class UserSettingsCookieSynchronizationConfigurationArgsDict(TypedDict):
        allowlist: pulumi.Input[Sequence[pulumi.Input['UserSettingsCookieSpecificationArgsDict']]]
        """
        The list of cookie specifications that are allowed to be synchronized to the remote browser.
        """
        blocklist: NotRequired[pulumi.Input[Sequence[pulumi.Input['UserSettingsCookieSpecificationArgsDict']]]]
        """
        The list of cookie specifications that are blocked from being synchronized to the remote browser.
        """
elif False:
    UserSettingsCookieSynchronizationConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserSettingsCookieSynchronizationConfigurationArgs:
    def __init__(__self__, *,
                 allowlist: pulumi.Input[Sequence[pulumi.Input['UserSettingsCookieSpecificationArgs']]],
                 blocklist: Optional[pulumi.Input[Sequence[pulumi.Input['UserSettingsCookieSpecificationArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['UserSettingsCookieSpecificationArgs']]] allowlist: The list of cookie specifications that are allowed to be synchronized to the remote browser.
        :param pulumi.Input[Sequence[pulumi.Input['UserSettingsCookieSpecificationArgs']]] blocklist: The list of cookie specifications that are blocked from being synchronized to the remote browser.
        """
        pulumi.set(__self__, "allowlist", allowlist)
        if blocklist is not None:
            pulumi.set(__self__, "blocklist", blocklist)

    @_builtins.property
    @pulumi.getter
    def allowlist(self) -> pulumi.Input[Sequence[pulumi.Input['UserSettingsCookieSpecificationArgs']]]:
        """
        The list of cookie specifications that are allowed to be synchronized to the remote browser.
        """
        return pulumi.get(self, "allowlist")

    @allowlist.setter
    def allowlist(self, value: pulumi.Input[Sequence[pulumi.Input['UserSettingsCookieSpecificationArgs']]]):
        pulumi.set(self, "allowlist", value)

    @_builtins.property
    @pulumi.getter
    def blocklist(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserSettingsCookieSpecificationArgs']]]]:
        """
        The list of cookie specifications that are blocked from being synchronized to the remote browser.
        """
        return pulumi.get(self, "blocklist")

    @blocklist.setter
    def blocklist(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserSettingsCookieSpecificationArgs']]]]):
        pulumi.set(self, "blocklist", value)


if not MYPY:
    class UserSettingsImageMetadataArgsDict(TypedDict):
        file_extension: pulumi.Input[_builtins.str]
        """
        The file extension of the image.
        """
        last_upload_timestamp: pulumi.Input[_builtins.str]
        """
        The timestamp when the image was last uploaded.
        """
        mime_type: pulumi.Input['UserSettingsMimeType']
        """
        The MIME type of the image.
        """
elif False:
    UserSettingsImageMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserSettingsImageMetadataArgs:
    def __init__(__self__, *,
                 file_extension: pulumi.Input[_builtins.str],
                 last_upload_timestamp: pulumi.Input[_builtins.str],
                 mime_type: pulumi.Input['UserSettingsMimeType']):
        """
        :param pulumi.Input[_builtins.str] file_extension: The file extension of the image.
        :param pulumi.Input[_builtins.str] last_upload_timestamp: The timestamp when the image was last uploaded.
        :param pulumi.Input['UserSettingsMimeType'] mime_type: The MIME type of the image.
        """
        pulumi.set(__self__, "file_extension", file_extension)
        pulumi.set(__self__, "last_upload_timestamp", last_upload_timestamp)
        pulumi.set(__self__, "mime_type", mime_type)

    @_builtins.property
    @pulumi.getter(name="fileExtension")
    def file_extension(self) -> pulumi.Input[_builtins.str]:
        """
        The file extension of the image.
        """
        return pulumi.get(self, "file_extension")

    @file_extension.setter
    def file_extension(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "file_extension", value)

    @_builtins.property
    @pulumi.getter(name="lastUploadTimestamp")
    def last_upload_timestamp(self) -> pulumi.Input[_builtins.str]:
        """
        The timestamp when the image was last uploaded.
        """
        return pulumi.get(self, "last_upload_timestamp")

    @last_upload_timestamp.setter
    def last_upload_timestamp(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "last_upload_timestamp", value)

    @_builtins.property
    @pulumi.getter(name="mimeType")
    def mime_type(self) -> pulumi.Input['UserSettingsMimeType']:
        """
        The MIME type of the image.
        """
        return pulumi.get(self, "mime_type")

    @mime_type.setter
    def mime_type(self, value: pulumi.Input['UserSettingsMimeType']):
        pulumi.set(self, "mime_type", value)


if not MYPY:
    class UserSettingsLocalizedBrandingStringsArgsDict(TypedDict):
        browser_tab_title: pulumi.Input[_builtins.str]
        """
        The text displayed in the browser tab title.
        """
        welcome_text: pulumi.Input[_builtins.str]
        """
        The welcome text displayed on the sign-in page.
        """
        contact_button_text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The text displayed on the contact button. This field is optional and defaults to "Contact us".
        """
        contact_link: NotRequired[pulumi.Input[_builtins.str]]
        """
        A contact link URL. The URL must start with `https://` or `mailto:` . If not provided, the contact button will be hidden from the web portal screen.
        """
        loading_text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The text displayed during session loading. This field is optional and defaults to "Loading your session".
        """
        login_button_text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The text displayed on the login button. This field is optional and defaults to "Sign In".
        """
        login_description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description text for the login section. This field is optional and defaults to "Sign in to your session".
        """
        login_title: NotRequired[pulumi.Input[_builtins.str]]
        """
        The title text for the login section. This field is optional and defaults to "Sign In".
        """
elif False:
    UserSettingsLocalizedBrandingStringsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserSettingsLocalizedBrandingStringsArgs:
    def __init__(__self__, *,
                 browser_tab_title: pulumi.Input[_builtins.str],
                 welcome_text: pulumi.Input[_builtins.str],
                 contact_button_text: Optional[pulumi.Input[_builtins.str]] = None,
                 contact_link: Optional[pulumi.Input[_builtins.str]] = None,
                 loading_text: Optional[pulumi.Input[_builtins.str]] = None,
                 login_button_text: Optional[pulumi.Input[_builtins.str]] = None,
                 login_description: Optional[pulumi.Input[_builtins.str]] = None,
                 login_title: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] browser_tab_title: The text displayed in the browser tab title.
        :param pulumi.Input[_builtins.str] welcome_text: The welcome text displayed on the sign-in page.
        :param pulumi.Input[_builtins.str] contact_button_text: The text displayed on the contact button. This field is optional and defaults to "Contact us".
        :param pulumi.Input[_builtins.str] contact_link: A contact link URL. The URL must start with `https://` or `mailto:` . If not provided, the contact button will be hidden from the web portal screen.
        :param pulumi.Input[_builtins.str] loading_text: The text displayed during session loading. This field is optional and defaults to "Loading your session".
        :param pulumi.Input[_builtins.str] login_button_text: The text displayed on the login button. This field is optional and defaults to "Sign In".
        :param pulumi.Input[_builtins.str] login_description: The description text for the login section. This field is optional and defaults to "Sign in to your session".
        :param pulumi.Input[_builtins.str] login_title: The title text for the login section. This field is optional and defaults to "Sign In".
        """
        pulumi.set(__self__, "browser_tab_title", browser_tab_title)
        pulumi.set(__self__, "welcome_text", welcome_text)
        if contact_button_text is not None:
            pulumi.set(__self__, "contact_button_text", contact_button_text)
        if contact_link is not None:
            pulumi.set(__self__, "contact_link", contact_link)
        if loading_text is not None:
            pulumi.set(__self__, "loading_text", loading_text)
        if login_button_text is not None:
            pulumi.set(__self__, "login_button_text", login_button_text)
        if login_description is not None:
            pulumi.set(__self__, "login_description", login_description)
        if login_title is not None:
            pulumi.set(__self__, "login_title", login_title)

    @_builtins.property
    @pulumi.getter(name="browserTabTitle")
    def browser_tab_title(self) -> pulumi.Input[_builtins.str]:
        """
        The text displayed in the browser tab title.
        """
        return pulumi.get(self, "browser_tab_title")

    @browser_tab_title.setter
    def browser_tab_title(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "browser_tab_title", value)

    @_builtins.property
    @pulumi.getter(name="welcomeText")
    def welcome_text(self) -> pulumi.Input[_builtins.str]:
        """
        The welcome text displayed on the sign-in page.
        """
        return pulumi.get(self, "welcome_text")

    @welcome_text.setter
    def welcome_text(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "welcome_text", value)

    @_builtins.property
    @pulumi.getter(name="contactButtonText")
    def contact_button_text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The text displayed on the contact button. This field is optional and defaults to "Contact us".
        """
        return pulumi.get(self, "contact_button_text")

    @contact_button_text.setter
    def contact_button_text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "contact_button_text", value)

    @_builtins.property
    @pulumi.getter(name="contactLink")
    def contact_link(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A contact link URL. The URL must start with `https://` or `mailto:` . If not provided, the contact button will be hidden from the web portal screen.
        """
        return pulumi.get(self, "contact_link")

    @contact_link.setter
    def contact_link(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "contact_link", value)

    @_builtins.property
    @pulumi.getter(name="loadingText")
    def loading_text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The text displayed during session loading. This field is optional and defaults to "Loading your session".
        """
        return pulumi.get(self, "loading_text")

    @loading_text.setter
    def loading_text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "loading_text", value)

    @_builtins.property
    @pulumi.getter(name="loginButtonText")
    def login_button_text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The text displayed on the login button. This field is optional and defaults to "Sign In".
        """
        return pulumi.get(self, "login_button_text")

    @login_button_text.setter
    def login_button_text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "login_button_text", value)

    @_builtins.property
    @pulumi.getter(name="loginDescription")
    def login_description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description text for the login section. This field is optional and defaults to "Sign in to your session".
        """
        return pulumi.get(self, "login_description")

    @login_description.setter
    def login_description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "login_description", value)

    @_builtins.property
    @pulumi.getter(name="loginTitle")
    def login_title(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The title text for the login section. This field is optional and defaults to "Sign In".
        """
        return pulumi.get(self, "login_title")

    @login_title.setter
    def login_title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "login_title", value)


if not MYPY:
    class UserSettingsToolbarConfigurationArgsDict(TypedDict):
        hidden_toolbar_items: NotRequired[pulumi.Input[Sequence[pulumi.Input['UserSettingsToolbarItem']]]]
        """
        The list of toolbar items to be hidden.
        """
        max_display_resolution: NotRequired[pulumi.Input['UserSettingsMaxDisplayResolution']]
        """
        The maximum display resolution that is allowed for the session.
        """
        toolbar_type: NotRequired[pulumi.Input['UserSettingsToolbarType']]
        """
        The type of toolbar displayed during the session.
        """
        visual_mode: NotRequired[pulumi.Input['UserSettingsVisualMode']]
        """
        The visual mode of the toolbar.
        """
elif False:
    UserSettingsToolbarConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserSettingsToolbarConfigurationArgs:
    def __init__(__self__, *,
                 hidden_toolbar_items: Optional[pulumi.Input[Sequence[pulumi.Input['UserSettingsToolbarItem']]]] = None,
                 max_display_resolution: Optional[pulumi.Input['UserSettingsMaxDisplayResolution']] = None,
                 toolbar_type: Optional[pulumi.Input['UserSettingsToolbarType']] = None,
                 visual_mode: Optional[pulumi.Input['UserSettingsVisualMode']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['UserSettingsToolbarItem']]] hidden_toolbar_items: The list of toolbar items to be hidden.
        :param pulumi.Input['UserSettingsMaxDisplayResolution'] max_display_resolution: The maximum display resolution that is allowed for the session.
        :param pulumi.Input['UserSettingsToolbarType'] toolbar_type: The type of toolbar displayed during the session.
        :param pulumi.Input['UserSettingsVisualMode'] visual_mode: The visual mode of the toolbar.
        """
        if hidden_toolbar_items is not None:
            pulumi.set(__self__, "hidden_toolbar_items", hidden_toolbar_items)
        if max_display_resolution is not None:
            pulumi.set(__self__, "max_display_resolution", max_display_resolution)
        if toolbar_type is not None:
            pulumi.set(__self__, "toolbar_type", toolbar_type)
        if visual_mode is not None:
            pulumi.set(__self__, "visual_mode", visual_mode)

    @_builtins.property
    @pulumi.getter(name="hiddenToolbarItems")
    def hidden_toolbar_items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserSettingsToolbarItem']]]]:
        """
        The list of toolbar items to be hidden.
        """
        return pulumi.get(self, "hidden_toolbar_items")

    @hidden_toolbar_items.setter
    def hidden_toolbar_items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserSettingsToolbarItem']]]]):
        pulumi.set(self, "hidden_toolbar_items", value)

    @_builtins.property
    @pulumi.getter(name="maxDisplayResolution")
    def max_display_resolution(self) -> Optional[pulumi.Input['UserSettingsMaxDisplayResolution']]:
        """
        The maximum display resolution that is allowed for the session.
        """
        return pulumi.get(self, "max_display_resolution")

    @max_display_resolution.setter
    def max_display_resolution(self, value: Optional[pulumi.Input['UserSettingsMaxDisplayResolution']]):
        pulumi.set(self, "max_display_resolution", value)

    @_builtins.property
    @pulumi.getter(name="toolbarType")
    def toolbar_type(self) -> Optional[pulumi.Input['UserSettingsToolbarType']]:
        """
        The type of toolbar displayed during the session.
        """
        return pulumi.get(self, "toolbar_type")

    @toolbar_type.setter
    def toolbar_type(self, value: Optional[pulumi.Input['UserSettingsToolbarType']]):
        pulumi.set(self, "toolbar_type", value)

    @_builtins.property
    @pulumi.getter(name="visualMode")
    def visual_mode(self) -> Optional[pulumi.Input['UserSettingsVisualMode']]:
        """
        The visual mode of the toolbar.
        """
        return pulumi.get(self, "visual_mode")

    @visual_mode.setter
    def visual_mode(self, value: Optional[pulumi.Input['UserSettingsVisualMode']]):
        pulumi.set(self, "visual_mode", value)


