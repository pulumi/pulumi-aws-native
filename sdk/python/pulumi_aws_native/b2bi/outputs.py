# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'CapabilityConfigurationProperties',
    'CapabilityEdiConfiguration',
    'CapabilityEdiTypeProperties',
    'CapabilityS3Location',
    'CapabilityX12Details',
    'PartnershipCapabilityOptions',
    'PartnershipInboundEdiOptions',
    'PartnershipOutboundEdiOptionsProperties',
    'PartnershipWrapOptions',
    'PartnershipX12AcknowledgmentOptions',
    'PartnershipX12ControlNumbers',
    'PartnershipX12Delimiters',
    'PartnershipX12Envelope',
    'PartnershipX12FunctionalGroupHeaders',
    'PartnershipX12InboundEdiOptions',
    'PartnershipX12InterchangeControlHeaders',
    'PartnershipX12OutboundEdiHeaders',
    'TransformerAdvancedOptions',
    'TransformerEdiTypeProperties',
    'TransformerFormatOptionsProperties',
    'TransformerInputConversion',
    'TransformerMapping',
    'TransformerOutputConversion',
    'TransformerSampleDocumentKeys',
    'TransformerSampleDocuments',
    'TransformerX12AdvancedOptions',
    'TransformerX12CodeListValidationRule',
    'TransformerX12Details',
    'TransformerX12ElementLengthValidationRule',
    'TransformerX12ElementRequirementValidationRule',
    'TransformerX12SplitOptions',
    'TransformerX12ValidationOptions',
    'TransformerX12ValidationRule0Properties',
    'TransformerX12ValidationRule1Properties',
    'TransformerX12ValidationRule2Properties',
]

@pulumi.output_type
class CapabilityConfigurationProperties(dict):
    def __init__(__self__, *,
                 edi: 'outputs.CapabilityEdiConfiguration'):
        pulumi.set(__self__, "edi", edi)

    @_builtins.property
    @pulumi.getter
    def edi(self) -> 'outputs.CapabilityEdiConfiguration':
        return pulumi.get(self, "edi")


@pulumi.output_type
class CapabilityEdiConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputLocation":
            suggest = "input_location"
        elif key == "outputLocation":
            suggest = "output_location"
        elif key == "transformerId":
            suggest = "transformer_id"
        elif key == "capabilityDirection":
            suggest = "capability_direction"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CapabilityEdiConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CapabilityEdiConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CapabilityEdiConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input_location: 'outputs.CapabilityS3Location',
                 output_location: 'outputs.CapabilityS3Location',
                 transformer_id: _builtins.str,
                 type: 'outputs.CapabilityEdiTypeProperties',
                 capability_direction: Optional['CapabilityDirection'] = None):
        pulumi.set(__self__, "input_location", input_location)
        pulumi.set(__self__, "output_location", output_location)
        pulumi.set(__self__, "transformer_id", transformer_id)
        pulumi.set(__self__, "type", type)
        if capability_direction is not None:
            pulumi.set(__self__, "capability_direction", capability_direction)

    @_builtins.property
    @pulumi.getter(name="inputLocation")
    def input_location(self) -> 'outputs.CapabilityS3Location':
        return pulumi.get(self, "input_location")

    @_builtins.property
    @pulumi.getter(name="outputLocation")
    def output_location(self) -> 'outputs.CapabilityS3Location':
        return pulumi.get(self, "output_location")

    @_builtins.property
    @pulumi.getter(name="transformerId")
    def transformer_id(self) -> _builtins.str:
        return pulumi.get(self, "transformer_id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> 'outputs.CapabilityEdiTypeProperties':
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="capabilityDirection")
    def capability_direction(self) -> Optional['CapabilityDirection']:
        return pulumi.get(self, "capability_direction")


@pulumi.output_type
class CapabilityEdiTypeProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "x12Details":
            suggest = "x12_details"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CapabilityEdiTypeProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CapabilityEdiTypeProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CapabilityEdiTypeProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x12_details: 'outputs.CapabilityX12Details'):
        pulumi.set(__self__, "x12_details", x12_details)

    @_builtins.property
    @pulumi.getter(name="x12Details")
    def x12_details(self) -> 'outputs.CapabilityX12Details':
        return pulumi.get(self, "x12_details")


@pulumi.output_type
class CapabilityS3Location(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CapabilityS3Location. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CapabilityS3Location.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CapabilityS3Location.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: Optional[_builtins.str] = None,
                 key: Optional[_builtins.str] = None):
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "bucket_name")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "key")


@pulumi.output_type
class CapabilityX12Details(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "transactionSet":
            suggest = "transaction_set"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CapabilityX12Details. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CapabilityX12Details.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CapabilityX12Details.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 transaction_set: Optional['CapabilityX12TransactionSet'] = None,
                 version: Optional['CapabilityX12Version'] = None):
        if transaction_set is not None:
            pulumi.set(__self__, "transaction_set", transaction_set)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="transactionSet")
    def transaction_set(self) -> Optional['CapabilityX12TransactionSet']:
        return pulumi.get(self, "transaction_set")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional['CapabilityX12Version']:
        return pulumi.get(self, "version")


@pulumi.output_type
class PartnershipCapabilityOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inboundEdi":
            suggest = "inbound_edi"
        elif key == "outboundEdi":
            suggest = "outbound_edi"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PartnershipCapabilityOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PartnershipCapabilityOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PartnershipCapabilityOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inbound_edi: Optional['outputs.PartnershipInboundEdiOptions'] = None,
                 outbound_edi: Optional['outputs.PartnershipOutboundEdiOptionsProperties'] = None):
        """
        :param 'PartnershipInboundEdiOptions' inbound_edi: A structure that contains the inbound EDI options for the capability.
        :param 'PartnershipOutboundEdiOptionsProperties' outbound_edi: A structure that contains the outbound EDI options.
        """
        if inbound_edi is not None:
            pulumi.set(__self__, "inbound_edi", inbound_edi)
        if outbound_edi is not None:
            pulumi.set(__self__, "outbound_edi", outbound_edi)

    @_builtins.property
    @pulumi.getter(name="inboundEdi")
    def inbound_edi(self) -> Optional['outputs.PartnershipInboundEdiOptions']:
        """
        A structure that contains the inbound EDI options for the capability.
        """
        return pulumi.get(self, "inbound_edi")

    @_builtins.property
    @pulumi.getter(name="outboundEdi")
    def outbound_edi(self) -> Optional['outputs.PartnershipOutboundEdiOptionsProperties']:
        """
        A structure that contains the outbound EDI options.
        """
        return pulumi.get(self, "outbound_edi")


@pulumi.output_type
class PartnershipInboundEdiOptions(dict):
    def __init__(__self__, *,
                 x12: Optional['outputs.PartnershipX12InboundEdiOptions'] = None):
        """
        :param 'PartnershipX12InboundEdiOptions' x12: A structure that contains X12-specific options for processing inbound X12 EDI files.
        """
        if x12 is not None:
            pulumi.set(__self__, "x12", x12)

    @_builtins.property
    @pulumi.getter
    def x12(self) -> Optional['outputs.PartnershipX12InboundEdiOptions']:
        """
        A structure that contains X12-specific options for processing inbound X12 EDI files.
        """
        return pulumi.get(self, "x12")


@pulumi.output_type
class PartnershipOutboundEdiOptionsProperties(dict):
    def __init__(__self__, *,
                 x12: 'outputs.PartnershipX12Envelope'):
        pulumi.set(__self__, "x12", x12)

    @_builtins.property
    @pulumi.getter
    def x12(self) -> 'outputs.PartnershipX12Envelope':
        return pulumi.get(self, "x12")


@pulumi.output_type
class PartnershipWrapOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lineLength":
            suggest = "line_length"
        elif key == "lineTerminator":
            suggest = "line_terminator"
        elif key == "wrapBy":
            suggest = "wrap_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PartnershipWrapOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PartnershipWrapOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PartnershipWrapOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 line_length: Optional[_builtins.float] = None,
                 line_terminator: Optional['PartnershipLineTerminator'] = None,
                 wrap_by: Optional['PartnershipWrapFormat'] = None):
        if line_length is not None:
            pulumi.set(__self__, "line_length", line_length)
        if line_terminator is not None:
            pulumi.set(__self__, "line_terminator", line_terminator)
        if wrap_by is not None:
            pulumi.set(__self__, "wrap_by", wrap_by)

    @_builtins.property
    @pulumi.getter(name="lineLength")
    def line_length(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "line_length")

    @_builtins.property
    @pulumi.getter(name="lineTerminator")
    def line_terminator(self) -> Optional['PartnershipLineTerminator']:
        return pulumi.get(self, "line_terminator")

    @_builtins.property
    @pulumi.getter(name="wrapBy")
    def wrap_by(self) -> Optional['PartnershipWrapFormat']:
        return pulumi.get(self, "wrap_by")


@pulumi.output_type
class PartnershipX12AcknowledgmentOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "functionalAcknowledgment":
            suggest = "functional_acknowledgment"
        elif key == "technicalAcknowledgment":
            suggest = "technical_acknowledgment"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PartnershipX12AcknowledgmentOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PartnershipX12AcknowledgmentOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PartnershipX12AcknowledgmentOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 functional_acknowledgment: 'PartnershipX12FunctionalAcknowledgment',
                 technical_acknowledgment: 'PartnershipX12TechnicalAcknowledgment'):
        """
        :param 'PartnershipX12FunctionalAcknowledgment' functional_acknowledgment: Specifies whether functional acknowledgments (997/999) should be generated for incoming X12 transactions. Valid values are `DO_NOT_GENERATE` , `GENERATE_ALL_SEGMENTS` and `GENERATE_WITHOUT_TRANSACTION_SET_RESPONSE_LOOP` .
               
               If you choose `GENERATE_WITHOUT_TRANSACTION_SET_RESPONSE_LOOP` , AWS B2B Data Interchange skips the AK2_Loop when generating an acknowledgment document.
        :param 'PartnershipX12TechnicalAcknowledgment' technical_acknowledgment: Specifies whether technical acknowledgments (TA1) should be generated for incoming X12 interchanges. Valid values are `DO_NOT_GENERATE` and `GENERATE_ALL_SEGMENTS` and.
        """
        pulumi.set(__self__, "functional_acknowledgment", functional_acknowledgment)
        pulumi.set(__self__, "technical_acknowledgment", technical_acknowledgment)

    @_builtins.property
    @pulumi.getter(name="functionalAcknowledgment")
    def functional_acknowledgment(self) -> 'PartnershipX12FunctionalAcknowledgment':
        """
        Specifies whether functional acknowledgments (997/999) should be generated for incoming X12 transactions. Valid values are `DO_NOT_GENERATE` , `GENERATE_ALL_SEGMENTS` and `GENERATE_WITHOUT_TRANSACTION_SET_RESPONSE_LOOP` .

        If you choose `GENERATE_WITHOUT_TRANSACTION_SET_RESPONSE_LOOP` , AWS B2B Data Interchange skips the AK2_Loop when generating an acknowledgment document.
        """
        return pulumi.get(self, "functional_acknowledgment")

    @_builtins.property
    @pulumi.getter(name="technicalAcknowledgment")
    def technical_acknowledgment(self) -> 'PartnershipX12TechnicalAcknowledgment':
        """
        Specifies whether technical acknowledgments (TA1) should be generated for incoming X12 interchanges. Valid values are `DO_NOT_GENERATE` and `GENERATE_ALL_SEGMENTS` and.
        """
        return pulumi.get(self, "technical_acknowledgment")


@pulumi.output_type
class PartnershipX12ControlNumbers(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startingFunctionalGroupControlNumber":
            suggest = "starting_functional_group_control_number"
        elif key == "startingInterchangeControlNumber":
            suggest = "starting_interchange_control_number"
        elif key == "startingTransactionSetControlNumber":
            suggest = "starting_transaction_set_control_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PartnershipX12ControlNumbers. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PartnershipX12ControlNumbers.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PartnershipX12ControlNumbers.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 starting_functional_group_control_number: Optional[_builtins.float] = None,
                 starting_interchange_control_number: Optional[_builtins.float] = None,
                 starting_transaction_set_control_number: Optional[_builtins.float] = None):
        if starting_functional_group_control_number is not None:
            pulumi.set(__self__, "starting_functional_group_control_number", starting_functional_group_control_number)
        if starting_interchange_control_number is not None:
            pulumi.set(__self__, "starting_interchange_control_number", starting_interchange_control_number)
        if starting_transaction_set_control_number is not None:
            pulumi.set(__self__, "starting_transaction_set_control_number", starting_transaction_set_control_number)

    @_builtins.property
    @pulumi.getter(name="startingFunctionalGroupControlNumber")
    def starting_functional_group_control_number(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "starting_functional_group_control_number")

    @_builtins.property
    @pulumi.getter(name="startingInterchangeControlNumber")
    def starting_interchange_control_number(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "starting_interchange_control_number")

    @_builtins.property
    @pulumi.getter(name="startingTransactionSetControlNumber")
    def starting_transaction_set_control_number(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "starting_transaction_set_control_number")


@pulumi.output_type
class PartnershipX12Delimiters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "componentSeparator":
            suggest = "component_separator"
        elif key == "dataElementSeparator":
            suggest = "data_element_separator"
        elif key == "segmentTerminator":
            suggest = "segment_terminator"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PartnershipX12Delimiters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PartnershipX12Delimiters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PartnershipX12Delimiters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 component_separator: Optional[_builtins.str] = None,
                 data_element_separator: Optional[_builtins.str] = None,
                 segment_terminator: Optional[_builtins.str] = None):
        if component_separator is not None:
            pulumi.set(__self__, "component_separator", component_separator)
        if data_element_separator is not None:
            pulumi.set(__self__, "data_element_separator", data_element_separator)
        if segment_terminator is not None:
            pulumi.set(__self__, "segment_terminator", segment_terminator)

    @_builtins.property
    @pulumi.getter(name="componentSeparator")
    def component_separator(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "component_separator")

    @_builtins.property
    @pulumi.getter(name="dataElementSeparator")
    def data_element_separator(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "data_element_separator")

    @_builtins.property
    @pulumi.getter(name="segmentTerminator")
    def segment_terminator(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "segment_terminator")


@pulumi.output_type
class PartnershipX12Envelope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "wrapOptions":
            suggest = "wrap_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PartnershipX12Envelope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PartnershipX12Envelope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PartnershipX12Envelope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 common: Optional['outputs.PartnershipX12OutboundEdiHeaders'] = None,
                 wrap_options: Optional['outputs.PartnershipWrapOptions'] = None):
        if common is not None:
            pulumi.set(__self__, "common", common)
        if wrap_options is not None:
            pulumi.set(__self__, "wrap_options", wrap_options)

    @_builtins.property
    @pulumi.getter
    def common(self) -> Optional['outputs.PartnershipX12OutboundEdiHeaders']:
        return pulumi.get(self, "common")

    @_builtins.property
    @pulumi.getter(name="wrapOptions")
    def wrap_options(self) -> Optional['outputs.PartnershipWrapOptions']:
        return pulumi.get(self, "wrap_options")


@pulumi.output_type
class PartnershipX12FunctionalGroupHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationReceiverCode":
            suggest = "application_receiver_code"
        elif key == "applicationSenderCode":
            suggest = "application_sender_code"
        elif key == "responsibleAgencyCode":
            suggest = "responsible_agency_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PartnershipX12FunctionalGroupHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PartnershipX12FunctionalGroupHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PartnershipX12FunctionalGroupHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_receiver_code: Optional[_builtins.str] = None,
                 application_sender_code: Optional[_builtins.str] = None,
                 responsible_agency_code: Optional[_builtins.str] = None):
        if application_receiver_code is not None:
            pulumi.set(__self__, "application_receiver_code", application_receiver_code)
        if application_sender_code is not None:
            pulumi.set(__self__, "application_sender_code", application_sender_code)
        if responsible_agency_code is not None:
            pulumi.set(__self__, "responsible_agency_code", responsible_agency_code)

    @_builtins.property
    @pulumi.getter(name="applicationReceiverCode")
    def application_receiver_code(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "application_receiver_code")

    @_builtins.property
    @pulumi.getter(name="applicationSenderCode")
    def application_sender_code(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "application_sender_code")

    @_builtins.property
    @pulumi.getter(name="responsibleAgencyCode")
    def responsible_agency_code(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "responsible_agency_code")


@pulumi.output_type
class PartnershipX12InboundEdiOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acknowledgmentOptions":
            suggest = "acknowledgment_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PartnershipX12InboundEdiOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PartnershipX12InboundEdiOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PartnershipX12InboundEdiOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acknowledgment_options: Optional['outputs.PartnershipX12AcknowledgmentOptions'] = None):
        """
        :param 'PartnershipX12AcknowledgmentOptions' acknowledgment_options: Specifies acknowledgment options for inbound X12 EDI files. These options control how functional and technical acknowledgments are handled.
        """
        if acknowledgment_options is not None:
            pulumi.set(__self__, "acknowledgment_options", acknowledgment_options)

    @_builtins.property
    @pulumi.getter(name="acknowledgmentOptions")
    def acknowledgment_options(self) -> Optional['outputs.PartnershipX12AcknowledgmentOptions']:
        """
        Specifies acknowledgment options for inbound X12 EDI files. These options control how functional and technical acknowledgments are handled.
        """
        return pulumi.get(self, "acknowledgment_options")


@pulumi.output_type
class PartnershipX12InterchangeControlHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acknowledgmentRequestedCode":
            suggest = "acknowledgment_requested_code"
        elif key == "receiverId":
            suggest = "receiver_id"
        elif key == "receiverIdQualifier":
            suggest = "receiver_id_qualifier"
        elif key == "repetitionSeparator":
            suggest = "repetition_separator"
        elif key == "senderId":
            suggest = "sender_id"
        elif key == "senderIdQualifier":
            suggest = "sender_id_qualifier"
        elif key == "usageIndicatorCode":
            suggest = "usage_indicator_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PartnershipX12InterchangeControlHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PartnershipX12InterchangeControlHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PartnershipX12InterchangeControlHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acknowledgment_requested_code: Optional[_builtins.str] = None,
                 receiver_id: Optional[_builtins.str] = None,
                 receiver_id_qualifier: Optional[_builtins.str] = None,
                 repetition_separator: Optional[_builtins.str] = None,
                 sender_id: Optional[_builtins.str] = None,
                 sender_id_qualifier: Optional[_builtins.str] = None,
                 usage_indicator_code: Optional[_builtins.str] = None):
        if acknowledgment_requested_code is not None:
            pulumi.set(__self__, "acknowledgment_requested_code", acknowledgment_requested_code)
        if receiver_id is not None:
            pulumi.set(__self__, "receiver_id", receiver_id)
        if receiver_id_qualifier is not None:
            pulumi.set(__self__, "receiver_id_qualifier", receiver_id_qualifier)
        if repetition_separator is not None:
            pulumi.set(__self__, "repetition_separator", repetition_separator)
        if sender_id is not None:
            pulumi.set(__self__, "sender_id", sender_id)
        if sender_id_qualifier is not None:
            pulumi.set(__self__, "sender_id_qualifier", sender_id_qualifier)
        if usage_indicator_code is not None:
            pulumi.set(__self__, "usage_indicator_code", usage_indicator_code)

    @_builtins.property
    @pulumi.getter(name="acknowledgmentRequestedCode")
    def acknowledgment_requested_code(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "acknowledgment_requested_code")

    @_builtins.property
    @pulumi.getter(name="receiverId")
    def receiver_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "receiver_id")

    @_builtins.property
    @pulumi.getter(name="receiverIdQualifier")
    def receiver_id_qualifier(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "receiver_id_qualifier")

    @_builtins.property
    @pulumi.getter(name="repetitionSeparator")
    def repetition_separator(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "repetition_separator")

    @_builtins.property
    @pulumi.getter(name="senderId")
    def sender_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sender_id")

    @_builtins.property
    @pulumi.getter(name="senderIdQualifier")
    def sender_id_qualifier(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "sender_id_qualifier")

    @_builtins.property
    @pulumi.getter(name="usageIndicatorCode")
    def usage_indicator_code(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "usage_indicator_code")


@pulumi.output_type
class PartnershipX12OutboundEdiHeaders(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlNumbers":
            suggest = "control_numbers"
        elif key == "functionalGroupHeaders":
            suggest = "functional_group_headers"
        elif key == "gs05TimeFormat":
            suggest = "gs05_time_format"
        elif key == "interchangeControlHeaders":
            suggest = "interchange_control_headers"
        elif key == "validateEdi":
            suggest = "validate_edi"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PartnershipX12OutboundEdiHeaders. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PartnershipX12OutboundEdiHeaders.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PartnershipX12OutboundEdiHeaders.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_numbers: Optional['outputs.PartnershipX12ControlNumbers'] = None,
                 delimiters: Optional['outputs.PartnershipX12Delimiters'] = None,
                 functional_group_headers: Optional['outputs.PartnershipX12FunctionalGroupHeaders'] = None,
                 gs05_time_format: Optional['PartnershipX12gs05TimeFormat'] = None,
                 interchange_control_headers: Optional['outputs.PartnershipX12InterchangeControlHeaders'] = None,
                 validate_edi: Optional[_builtins.bool] = None):
        if control_numbers is not None:
            pulumi.set(__self__, "control_numbers", control_numbers)
        if delimiters is not None:
            pulumi.set(__self__, "delimiters", delimiters)
        if functional_group_headers is not None:
            pulumi.set(__self__, "functional_group_headers", functional_group_headers)
        if gs05_time_format is not None:
            pulumi.set(__self__, "gs05_time_format", gs05_time_format)
        if interchange_control_headers is not None:
            pulumi.set(__self__, "interchange_control_headers", interchange_control_headers)
        if validate_edi is not None:
            pulumi.set(__self__, "validate_edi", validate_edi)

    @_builtins.property
    @pulumi.getter(name="controlNumbers")
    def control_numbers(self) -> Optional['outputs.PartnershipX12ControlNumbers']:
        return pulumi.get(self, "control_numbers")

    @_builtins.property
    @pulumi.getter
    def delimiters(self) -> Optional['outputs.PartnershipX12Delimiters']:
        return pulumi.get(self, "delimiters")

    @_builtins.property
    @pulumi.getter(name="functionalGroupHeaders")
    def functional_group_headers(self) -> Optional['outputs.PartnershipX12FunctionalGroupHeaders']:
        return pulumi.get(self, "functional_group_headers")

    @_builtins.property
    @pulumi.getter(name="gs05TimeFormat")
    def gs05_time_format(self) -> Optional['PartnershipX12gs05TimeFormat']:
        return pulumi.get(self, "gs05_time_format")

    @_builtins.property
    @pulumi.getter(name="interchangeControlHeaders")
    def interchange_control_headers(self) -> Optional['outputs.PartnershipX12InterchangeControlHeaders']:
        return pulumi.get(self, "interchange_control_headers")

    @_builtins.property
    @pulumi.getter(name="validateEdi")
    def validate_edi(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "validate_edi")


@pulumi.output_type
class TransformerAdvancedOptions(dict):
    def __init__(__self__, *,
                 x12: Optional['outputs.TransformerX12AdvancedOptions'] = None):
        """
        :param 'TransformerX12AdvancedOptions' x12: A structure that contains X12-specific advanced options, such as split options for processing X12 EDI files.
        """
        if x12 is not None:
            pulumi.set(__self__, "x12", x12)

    @_builtins.property
    @pulumi.getter
    def x12(self) -> Optional['outputs.TransformerX12AdvancedOptions']:
        """
        A structure that contains X12-specific advanced options, such as split options for processing X12 EDI files.
        """
        return pulumi.get(self, "x12")


@pulumi.output_type
class TransformerEdiTypeProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "x12Details":
            suggest = "x12_details"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TransformerEdiTypeProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TransformerEdiTypeProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TransformerEdiTypeProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 x12_details: 'outputs.TransformerX12Details'):
        pulumi.set(__self__, "x12_details", x12_details)

    @_builtins.property
    @pulumi.getter(name="x12Details")
    def x12_details(self) -> 'outputs.TransformerX12Details':
        return pulumi.get(self, "x12_details")


@pulumi.output_type
class TransformerFormatOptionsProperties(dict):
    def __init__(__self__, *,
                 x12: 'outputs.TransformerX12Details'):
        pulumi.set(__self__, "x12", x12)

    @_builtins.property
    @pulumi.getter
    def x12(self) -> 'outputs.TransformerX12Details':
        return pulumi.get(self, "x12")


@pulumi.output_type
class TransformerInputConversion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromFormat":
            suggest = "from_format"
        elif key == "advancedOptions":
            suggest = "advanced_options"
        elif key == "formatOptions":
            suggest = "format_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TransformerInputConversion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TransformerInputConversion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TransformerInputConversion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_format: 'TransformerFromFormat',
                 advanced_options: Optional['outputs.TransformerAdvancedOptions'] = None,
                 format_options: Optional['outputs.TransformerFormatOptionsProperties'] = None):
        """
        :param 'TransformerFromFormat' from_format: The format for the transformer input: currently on `X12` is supported.
        :param 'TransformerAdvancedOptions' advanced_options: Specifies advanced options for the input conversion process. These options provide additional control over how EDI files are processed during transformation.
        :param 'TransformerFormatOptionsProperties' format_options: A structure that contains the formatting options for an inbound transformer.
        """
        pulumi.set(__self__, "from_format", from_format)
        if advanced_options is not None:
            pulumi.set(__self__, "advanced_options", advanced_options)
        if format_options is not None:
            pulumi.set(__self__, "format_options", format_options)

    @_builtins.property
    @pulumi.getter(name="fromFormat")
    def from_format(self) -> 'TransformerFromFormat':
        """
        The format for the transformer input: currently on `X12` is supported.
        """
        return pulumi.get(self, "from_format")

    @_builtins.property
    @pulumi.getter(name="advancedOptions")
    def advanced_options(self) -> Optional['outputs.TransformerAdvancedOptions']:
        """
        Specifies advanced options for the input conversion process. These options provide additional control over how EDI files are processed during transformation.
        """
        return pulumi.get(self, "advanced_options")

    @_builtins.property
    @pulumi.getter(name="formatOptions")
    def format_options(self) -> Optional['outputs.TransformerFormatOptionsProperties']:
        """
        A structure that contains the formatting options for an inbound transformer.
        """
        return pulumi.get(self, "format_options")


@pulumi.output_type
class TransformerMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "templateLanguage":
            suggest = "template_language"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TransformerMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TransformerMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TransformerMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 template_language: 'TransformerMappingTemplateLanguage',
                 template: Optional[_builtins.str] = None):
        """
        :param 'TransformerMappingTemplateLanguage' template_language: The transformation language for the template, either XSLT or JSONATA.
        :param _builtins.str template: A string that represents the mapping template, in the transformation language specified in `templateLanguage` .
        """
        pulumi.set(__self__, "template_language", template_language)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @_builtins.property
    @pulumi.getter(name="templateLanguage")
    def template_language(self) -> 'TransformerMappingTemplateLanguage':
        """
        The transformation language for the template, either XSLT or JSONATA.
        """
        return pulumi.get(self, "template_language")

    @_builtins.property
    @pulumi.getter
    def template(self) -> Optional[_builtins.str]:
        """
        A string that represents the mapping template, in the transformation language specified in `templateLanguage` .
        """
        return pulumi.get(self, "template")


@pulumi.output_type
class TransformerOutputConversion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "toFormat":
            suggest = "to_format"
        elif key == "advancedOptions":
            suggest = "advanced_options"
        elif key == "formatOptions":
            suggest = "format_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TransformerOutputConversion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TransformerOutputConversion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TransformerOutputConversion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 to_format: 'TransformerToFormat',
                 advanced_options: Optional['outputs.TransformerAdvancedOptions'] = None,
                 format_options: Optional['outputs.TransformerFormatOptionsProperties'] = None):
        """
        :param 'TransformerToFormat' to_format: The format for the output from an outbound transformer: only X12 is currently supported.
        :param 'TransformerFormatOptionsProperties' format_options: A structure that contains the X12 transaction set and version for the transformer output.
        """
        pulumi.set(__self__, "to_format", to_format)
        if advanced_options is not None:
            pulumi.set(__self__, "advanced_options", advanced_options)
        if format_options is not None:
            pulumi.set(__self__, "format_options", format_options)

    @_builtins.property
    @pulumi.getter(name="toFormat")
    def to_format(self) -> 'TransformerToFormat':
        """
        The format for the output from an outbound transformer: only X12 is currently supported.
        """
        return pulumi.get(self, "to_format")

    @_builtins.property
    @pulumi.getter(name="advancedOptions")
    def advanced_options(self) -> Optional['outputs.TransformerAdvancedOptions']:
        return pulumi.get(self, "advanced_options")

    @_builtins.property
    @pulumi.getter(name="formatOptions")
    def format_options(self) -> Optional['outputs.TransformerFormatOptionsProperties']:
        """
        A structure that contains the X12 transaction set and version for the transformer output.
        """
        return pulumi.get(self, "format_options")


@pulumi.output_type
class TransformerSampleDocumentKeys(dict):
    def __init__(__self__, *,
                 input: Optional[_builtins.str] = None,
                 output: Optional[_builtins.str] = None):
        """
        :param _builtins.str input: An array of keys for your input sample documents.
        :param _builtins.str output: An array of keys for your output sample documents.
        """
        if input is not None:
            pulumi.set(__self__, "input", input)
        if output is not None:
            pulumi.set(__self__, "output", output)

    @_builtins.property
    @pulumi.getter
    def input(self) -> Optional[_builtins.str]:
        """
        An array of keys for your input sample documents.
        """
        return pulumi.get(self, "input")

    @_builtins.property
    @pulumi.getter
    def output(self) -> Optional[_builtins.str]:
        """
        An array of keys for your output sample documents.
        """
        return pulumi.get(self, "output")


@pulumi.output_type
class TransformerSampleDocuments(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TransformerSampleDocuments. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TransformerSampleDocuments.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TransformerSampleDocuments.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: _builtins.str,
                 keys: Sequence['outputs.TransformerSampleDocumentKeys']):
        """
        :param _builtins.str bucket_name: Contains the Amazon S3 bucket that is used to hold your sample documents.
        :param Sequence['TransformerSampleDocumentKeys'] keys: Contains an array of the Amazon S3 keys used to identify the location for your sample documents.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "keys", keys)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> _builtins.str:
        """
        Contains the Amazon S3 bucket that is used to hold your sample documents.
        """
        return pulumi.get(self, "bucket_name")

    @_builtins.property
    @pulumi.getter
    def keys(self) -> Sequence['outputs.TransformerSampleDocumentKeys']:
        """
        Contains an array of the Amazon S3 keys used to identify the location for your sample documents.
        """
        return pulumi.get(self, "keys")


@pulumi.output_type
class TransformerX12AdvancedOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "splitOptions":
            suggest = "split_options"
        elif key == "validationOptions":
            suggest = "validation_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TransformerX12AdvancedOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TransformerX12AdvancedOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TransformerX12AdvancedOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 split_options: Optional['outputs.TransformerX12SplitOptions'] = None,
                 validation_options: Optional['outputs.TransformerX12ValidationOptions'] = None):
        """
        :param 'TransformerX12SplitOptions' split_options: Specifies options for splitting X12 EDI files. These options control how large X12 files are divided into smaller, more manageable units.
        :param 'TransformerX12ValidationOptions' validation_options: Specifies validation options for X12 EDI processing. These options control how validation rules are applied during EDI document processing, including custom validation rules for element length constraints, code list validations, and element requirement checks.
        """
        if split_options is not None:
            pulumi.set(__self__, "split_options", split_options)
        if validation_options is not None:
            pulumi.set(__self__, "validation_options", validation_options)

    @_builtins.property
    @pulumi.getter(name="splitOptions")
    def split_options(self) -> Optional['outputs.TransformerX12SplitOptions']:
        """
        Specifies options for splitting X12 EDI files. These options control how large X12 files are divided into smaller, more manageable units.
        """
        return pulumi.get(self, "split_options")

    @_builtins.property
    @pulumi.getter(name="validationOptions")
    def validation_options(self) -> Optional['outputs.TransformerX12ValidationOptions']:
        """
        Specifies validation options for X12 EDI processing. These options control how validation rules are applied during EDI document processing, including custom validation rules for element length constraints, code list validations, and element requirement checks.
        """
        return pulumi.get(self, "validation_options")


@pulumi.output_type
class TransformerX12CodeListValidationRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "elementId":
            suggest = "element_id"
        elif key == "codesToAdd":
            suggest = "codes_to_add"
        elif key == "codesToRemove":
            suggest = "codes_to_remove"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TransformerX12CodeListValidationRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TransformerX12CodeListValidationRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TransformerX12CodeListValidationRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 element_id: _builtins.str,
                 codes_to_add: Optional[Sequence[_builtins.str]] = None,
                 codes_to_remove: Optional[Sequence[_builtins.str]] = None):
        pulumi.set(__self__, "element_id", element_id)
        if codes_to_add is not None:
            pulumi.set(__self__, "codes_to_add", codes_to_add)
        if codes_to_remove is not None:
            pulumi.set(__self__, "codes_to_remove", codes_to_remove)

    @_builtins.property
    @pulumi.getter(name="elementId")
    def element_id(self) -> _builtins.str:
        return pulumi.get(self, "element_id")

    @_builtins.property
    @pulumi.getter(name="codesToAdd")
    def codes_to_add(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "codes_to_add")

    @_builtins.property
    @pulumi.getter(name="codesToRemove")
    def codes_to_remove(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "codes_to_remove")


@pulumi.output_type
class TransformerX12Details(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "transactionSet":
            suggest = "transaction_set"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TransformerX12Details. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TransformerX12Details.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TransformerX12Details.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 transaction_set: Optional['TransformerX12TransactionSet'] = None,
                 version: Optional['TransformerX12Version'] = None):
        if transaction_set is not None:
            pulumi.set(__self__, "transaction_set", transaction_set)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="transactionSet")
    def transaction_set(self) -> Optional['TransformerX12TransactionSet']:
        return pulumi.get(self, "transaction_set")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional['TransformerX12Version']:
        return pulumi.get(self, "version")


@pulumi.output_type
class TransformerX12ElementLengthValidationRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "elementId":
            suggest = "element_id"
        elif key == "maxLength":
            suggest = "max_length"
        elif key == "minLength":
            suggest = "min_length"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TransformerX12ElementLengthValidationRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TransformerX12ElementLengthValidationRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TransformerX12ElementLengthValidationRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 element_id: _builtins.str,
                 max_length: _builtins.float,
                 min_length: _builtins.float):
        pulumi.set(__self__, "element_id", element_id)
        pulumi.set(__self__, "max_length", max_length)
        pulumi.set(__self__, "min_length", min_length)

    @_builtins.property
    @pulumi.getter(name="elementId")
    def element_id(self) -> _builtins.str:
        return pulumi.get(self, "element_id")

    @_builtins.property
    @pulumi.getter(name="maxLength")
    def max_length(self) -> _builtins.float:
        return pulumi.get(self, "max_length")

    @_builtins.property
    @pulumi.getter(name="minLength")
    def min_length(self) -> _builtins.float:
        return pulumi.get(self, "min_length")


@pulumi.output_type
class TransformerX12ElementRequirementValidationRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "elementPosition":
            suggest = "element_position"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TransformerX12ElementRequirementValidationRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TransformerX12ElementRequirementValidationRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TransformerX12ElementRequirementValidationRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 element_position: _builtins.str,
                 requirement: 'TransformerElementRequirement'):
        pulumi.set(__self__, "element_position", element_position)
        pulumi.set(__self__, "requirement", requirement)

    @_builtins.property
    @pulumi.getter(name="elementPosition")
    def element_position(self) -> _builtins.str:
        return pulumi.get(self, "element_position")

    @_builtins.property
    @pulumi.getter
    def requirement(self) -> 'TransformerElementRequirement':
        return pulumi.get(self, "requirement")


@pulumi.output_type
class TransformerX12SplitOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "splitBy":
            suggest = "split_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TransformerX12SplitOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TransformerX12SplitOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TransformerX12SplitOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 split_by: Optional['TransformerX12SplitBy'] = None):
        """
        :param 'TransformerX12SplitBy' split_by: Specifies the method used to split X12 EDI files. Valid values include `TRANSACTION` (split by individual transaction sets), or `NONE` (no splitting).
        """
        if split_by is not None:
            pulumi.set(__self__, "split_by", split_by)

    @_builtins.property
    @pulumi.getter(name="splitBy")
    def split_by(self) -> Optional['TransformerX12SplitBy']:
        """
        Specifies the method used to split X12 EDI files. Valid values include `TRANSACTION` (split by individual transaction sets), or `NONE` (no splitting).
        """
        return pulumi.get(self, "split_by")


@pulumi.output_type
class TransformerX12ValidationOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "validationRules":
            suggest = "validation_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TransformerX12ValidationOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TransformerX12ValidationOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TransformerX12ValidationOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 validation_rules: Optional[Sequence[Any]] = None):
        """
        :param Sequence[Union['TransformerX12ValidationRule0Properties', 'TransformerX12ValidationRule1Properties', 'TransformerX12ValidationRule2Properties']] validation_rules: Specifies a list of validation rules to apply during EDI document processing. These rules can include code list modifications, element length constraints, and element requirement changes.
        """
        if validation_rules is not None:
            pulumi.set(__self__, "validation_rules", validation_rules)

    @_builtins.property
    @pulumi.getter(name="validationRules")
    def validation_rules(self) -> Optional[Sequence[Any]]:
        """
        Specifies a list of validation rules to apply during EDI document processing. These rules can include code list modifications, element length constraints, and element requirement changes.
        """
        return pulumi.get(self, "validation_rules")


@pulumi.output_type
class TransformerX12ValidationRule0Properties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "codeListValidationRule":
            suggest = "code_list_validation_rule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TransformerX12ValidationRule0Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TransformerX12ValidationRule0Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TransformerX12ValidationRule0Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 code_list_validation_rule: 'outputs.TransformerX12CodeListValidationRule'):
        pulumi.set(__self__, "code_list_validation_rule", code_list_validation_rule)

    @_builtins.property
    @pulumi.getter(name="codeListValidationRule")
    def code_list_validation_rule(self) -> 'outputs.TransformerX12CodeListValidationRule':
        return pulumi.get(self, "code_list_validation_rule")


@pulumi.output_type
class TransformerX12ValidationRule1Properties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "elementLengthValidationRule":
            suggest = "element_length_validation_rule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TransformerX12ValidationRule1Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TransformerX12ValidationRule1Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TransformerX12ValidationRule1Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 element_length_validation_rule: 'outputs.TransformerX12ElementLengthValidationRule'):
        pulumi.set(__self__, "element_length_validation_rule", element_length_validation_rule)

    @_builtins.property
    @pulumi.getter(name="elementLengthValidationRule")
    def element_length_validation_rule(self) -> 'outputs.TransformerX12ElementLengthValidationRule':
        return pulumi.get(self, "element_length_validation_rule")


@pulumi.output_type
class TransformerX12ValidationRule2Properties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "elementRequirementValidationRule":
            suggest = "element_requirement_validation_rule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TransformerX12ValidationRule2Properties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TransformerX12ValidationRule2Properties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TransformerX12ValidationRule2Properties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 element_requirement_validation_rule: 'outputs.TransformerX12ElementRequirementValidationRule'):
        pulumi.set(__self__, "element_requirement_validation_rule", element_requirement_validation_rule)

    @_builtins.property
    @pulumi.getter(name="elementRequirementValidationRule")
    def element_requirement_validation_rule(self) -> 'outputs.TransformerX12ElementRequirementValidationRule':
        return pulumi.get(self, "element_requirement_validation_rule")


