# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'CapabilityConfigurationPropertiesArgs',
    'CapabilityConfigurationPropertiesArgsDict',
    'CapabilityEdiConfigurationArgs',
    'CapabilityEdiConfigurationArgsDict',
    'CapabilityEdiTypePropertiesArgs',
    'CapabilityEdiTypePropertiesArgsDict',
    'CapabilityS3LocationArgs',
    'CapabilityS3LocationArgsDict',
    'CapabilityX12DetailsArgs',
    'CapabilityX12DetailsArgsDict',
    'PartnershipCapabilityOptionsArgs',
    'PartnershipCapabilityOptionsArgsDict',
    'PartnershipInboundEdiOptionsArgs',
    'PartnershipInboundEdiOptionsArgsDict',
    'PartnershipOutboundEdiOptionsPropertiesArgs',
    'PartnershipOutboundEdiOptionsPropertiesArgsDict',
    'PartnershipWrapOptionsArgs',
    'PartnershipWrapOptionsArgsDict',
    'PartnershipX12AcknowledgmentOptionsArgs',
    'PartnershipX12AcknowledgmentOptionsArgsDict',
    'PartnershipX12ControlNumbersArgs',
    'PartnershipX12ControlNumbersArgsDict',
    'PartnershipX12DelimitersArgs',
    'PartnershipX12DelimitersArgsDict',
    'PartnershipX12EnvelopeArgs',
    'PartnershipX12EnvelopeArgsDict',
    'PartnershipX12FunctionalGroupHeadersArgs',
    'PartnershipX12FunctionalGroupHeadersArgsDict',
    'PartnershipX12InboundEdiOptionsArgs',
    'PartnershipX12InboundEdiOptionsArgsDict',
    'PartnershipX12InterchangeControlHeadersArgs',
    'PartnershipX12InterchangeControlHeadersArgsDict',
    'PartnershipX12OutboundEdiHeadersArgs',
    'PartnershipX12OutboundEdiHeadersArgsDict',
    'TransformerAdvancedOptionsArgs',
    'TransformerAdvancedOptionsArgsDict',
    'TransformerEdiTypePropertiesArgs',
    'TransformerEdiTypePropertiesArgsDict',
    'TransformerFormatOptionsPropertiesArgs',
    'TransformerFormatOptionsPropertiesArgsDict',
    'TransformerInputConversionArgs',
    'TransformerInputConversionArgsDict',
    'TransformerMappingArgs',
    'TransformerMappingArgsDict',
    'TransformerOutputConversionArgs',
    'TransformerOutputConversionArgsDict',
    'TransformerSampleDocumentKeysArgs',
    'TransformerSampleDocumentKeysArgsDict',
    'TransformerSampleDocumentsArgs',
    'TransformerSampleDocumentsArgsDict',
    'TransformerX12AdvancedOptionsArgs',
    'TransformerX12AdvancedOptionsArgsDict',
    'TransformerX12CodeListValidationRuleArgs',
    'TransformerX12CodeListValidationRuleArgsDict',
    'TransformerX12DetailsArgs',
    'TransformerX12DetailsArgsDict',
    'TransformerX12ElementLengthValidationRuleArgs',
    'TransformerX12ElementLengthValidationRuleArgsDict',
    'TransformerX12ElementRequirementValidationRuleArgs',
    'TransformerX12ElementRequirementValidationRuleArgsDict',
    'TransformerX12SplitOptionsArgs',
    'TransformerX12SplitOptionsArgsDict',
    'TransformerX12ValidationOptionsArgs',
    'TransformerX12ValidationOptionsArgsDict',
    'TransformerX12ValidationRule0PropertiesArgs',
    'TransformerX12ValidationRule0PropertiesArgsDict',
    'TransformerX12ValidationRule1PropertiesArgs',
    'TransformerX12ValidationRule1PropertiesArgsDict',
    'TransformerX12ValidationRule2PropertiesArgs',
    'TransformerX12ValidationRule2PropertiesArgsDict',
]

MYPY = False

if not MYPY:
    class CapabilityConfigurationPropertiesArgsDict(TypedDict):
        edi: pulumi.Input['CapabilityEdiConfigurationArgsDict']
elif False:
    CapabilityConfigurationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapabilityConfigurationPropertiesArgs:
    def __init__(__self__, *,
                 edi: pulumi.Input['CapabilityEdiConfigurationArgs']):
        pulumi.set(__self__, "edi", edi)

    @_builtins.property
    @pulumi.getter
    def edi(self) -> pulumi.Input['CapabilityEdiConfigurationArgs']:
        return pulumi.get(self, "edi")

    @edi.setter
    def edi(self, value: pulumi.Input['CapabilityEdiConfigurationArgs']):
        pulumi.set(self, "edi", value)


if not MYPY:
    class CapabilityEdiConfigurationArgsDict(TypedDict):
        input_location: pulumi.Input['CapabilityS3LocationArgsDict']
        output_location: pulumi.Input['CapabilityS3LocationArgsDict']
        transformer_id: pulumi.Input[_builtins.str]
        type: pulumi.Input['CapabilityEdiTypePropertiesArgsDict']
        capability_direction: NotRequired[pulumi.Input['CapabilityDirection']]
elif False:
    CapabilityEdiConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapabilityEdiConfigurationArgs:
    def __init__(__self__, *,
                 input_location: pulumi.Input['CapabilityS3LocationArgs'],
                 output_location: pulumi.Input['CapabilityS3LocationArgs'],
                 transformer_id: pulumi.Input[_builtins.str],
                 type: pulumi.Input['CapabilityEdiTypePropertiesArgs'],
                 capability_direction: Optional[pulumi.Input['CapabilityDirection']] = None):
        pulumi.set(__self__, "input_location", input_location)
        pulumi.set(__self__, "output_location", output_location)
        pulumi.set(__self__, "transformer_id", transformer_id)
        pulumi.set(__self__, "type", type)
        if capability_direction is not None:
            pulumi.set(__self__, "capability_direction", capability_direction)

    @_builtins.property
    @pulumi.getter(name="inputLocation")
    def input_location(self) -> pulumi.Input['CapabilityS3LocationArgs']:
        return pulumi.get(self, "input_location")

    @input_location.setter
    def input_location(self, value: pulumi.Input['CapabilityS3LocationArgs']):
        pulumi.set(self, "input_location", value)

    @_builtins.property
    @pulumi.getter(name="outputLocation")
    def output_location(self) -> pulumi.Input['CapabilityS3LocationArgs']:
        return pulumi.get(self, "output_location")

    @output_location.setter
    def output_location(self, value: pulumi.Input['CapabilityS3LocationArgs']):
        pulumi.set(self, "output_location", value)

    @_builtins.property
    @pulumi.getter(name="transformerId")
    def transformer_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "transformer_id")

    @transformer_id.setter
    def transformer_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "transformer_id", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['CapabilityEdiTypePropertiesArgs']:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['CapabilityEdiTypePropertiesArgs']):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="capabilityDirection")
    def capability_direction(self) -> Optional[pulumi.Input['CapabilityDirection']]:
        return pulumi.get(self, "capability_direction")

    @capability_direction.setter
    def capability_direction(self, value: Optional[pulumi.Input['CapabilityDirection']]):
        pulumi.set(self, "capability_direction", value)


if not MYPY:
    class CapabilityEdiTypePropertiesArgsDict(TypedDict):
        x12_details: pulumi.Input['CapabilityX12DetailsArgsDict']
elif False:
    CapabilityEdiTypePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapabilityEdiTypePropertiesArgs:
    def __init__(__self__, *,
                 x12_details: pulumi.Input['CapabilityX12DetailsArgs']):
        pulumi.set(__self__, "x12_details", x12_details)

    @_builtins.property
    @pulumi.getter(name="x12Details")
    def x12_details(self) -> pulumi.Input['CapabilityX12DetailsArgs']:
        return pulumi.get(self, "x12_details")

    @x12_details.setter
    def x12_details(self, value: pulumi.Input['CapabilityX12DetailsArgs']):
        pulumi.set(self, "x12_details", value)


if not MYPY:
    class CapabilityS3LocationArgsDict(TypedDict):
        bucket_name: NotRequired[pulumi.Input[_builtins.str]]
        key: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    CapabilityS3LocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapabilityS3LocationArgs:
    def __init__(__self__, *,
                 bucket_name: Optional[pulumi.Input[_builtins.str]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None):
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)


if not MYPY:
    class CapabilityX12DetailsArgsDict(TypedDict):
        transaction_set: NotRequired[pulumi.Input['CapabilityX12TransactionSet']]
        version: NotRequired[pulumi.Input['CapabilityX12Version']]
elif False:
    CapabilityX12DetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CapabilityX12DetailsArgs:
    def __init__(__self__, *,
                 transaction_set: Optional[pulumi.Input['CapabilityX12TransactionSet']] = None,
                 version: Optional[pulumi.Input['CapabilityX12Version']] = None):
        if transaction_set is not None:
            pulumi.set(__self__, "transaction_set", transaction_set)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="transactionSet")
    def transaction_set(self) -> Optional[pulumi.Input['CapabilityX12TransactionSet']]:
        return pulumi.get(self, "transaction_set")

    @transaction_set.setter
    def transaction_set(self, value: Optional[pulumi.Input['CapabilityX12TransactionSet']]):
        pulumi.set(self, "transaction_set", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input['CapabilityX12Version']]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input['CapabilityX12Version']]):
        pulumi.set(self, "version", value)


if not MYPY:
    class PartnershipCapabilityOptionsArgsDict(TypedDict):
        inbound_edi: NotRequired[pulumi.Input['PartnershipInboundEdiOptionsArgsDict']]
        """
        A structure that contains the inbound EDI options for the capability.
        """
        outbound_edi: NotRequired[pulumi.Input['PartnershipOutboundEdiOptionsPropertiesArgsDict']]
        """
        A structure that contains the outbound EDI options.
        """
elif False:
    PartnershipCapabilityOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PartnershipCapabilityOptionsArgs:
    def __init__(__self__, *,
                 inbound_edi: Optional[pulumi.Input['PartnershipInboundEdiOptionsArgs']] = None,
                 outbound_edi: Optional[pulumi.Input['PartnershipOutboundEdiOptionsPropertiesArgs']] = None):
        """
        :param pulumi.Input['PartnershipInboundEdiOptionsArgs'] inbound_edi: A structure that contains the inbound EDI options for the capability.
        :param pulumi.Input['PartnershipOutboundEdiOptionsPropertiesArgs'] outbound_edi: A structure that contains the outbound EDI options.
        """
        if inbound_edi is not None:
            pulumi.set(__self__, "inbound_edi", inbound_edi)
        if outbound_edi is not None:
            pulumi.set(__self__, "outbound_edi", outbound_edi)

    @_builtins.property
    @pulumi.getter(name="inboundEdi")
    def inbound_edi(self) -> Optional[pulumi.Input['PartnershipInboundEdiOptionsArgs']]:
        """
        A structure that contains the inbound EDI options for the capability.
        """
        return pulumi.get(self, "inbound_edi")

    @inbound_edi.setter
    def inbound_edi(self, value: Optional[pulumi.Input['PartnershipInboundEdiOptionsArgs']]):
        pulumi.set(self, "inbound_edi", value)

    @_builtins.property
    @pulumi.getter(name="outboundEdi")
    def outbound_edi(self) -> Optional[pulumi.Input['PartnershipOutboundEdiOptionsPropertiesArgs']]:
        """
        A structure that contains the outbound EDI options.
        """
        return pulumi.get(self, "outbound_edi")

    @outbound_edi.setter
    def outbound_edi(self, value: Optional[pulumi.Input['PartnershipOutboundEdiOptionsPropertiesArgs']]):
        pulumi.set(self, "outbound_edi", value)


if not MYPY:
    class PartnershipInboundEdiOptionsArgsDict(TypedDict):
        x12: NotRequired[pulumi.Input['PartnershipX12InboundEdiOptionsArgsDict']]
        """
        A structure that contains X12-specific options for processing inbound X12 EDI files.
        """
elif False:
    PartnershipInboundEdiOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PartnershipInboundEdiOptionsArgs:
    def __init__(__self__, *,
                 x12: Optional[pulumi.Input['PartnershipX12InboundEdiOptionsArgs']] = None):
        """
        :param pulumi.Input['PartnershipX12InboundEdiOptionsArgs'] x12: A structure that contains X12-specific options for processing inbound X12 EDI files.
        """
        if x12 is not None:
            pulumi.set(__self__, "x12", x12)

    @_builtins.property
    @pulumi.getter
    def x12(self) -> Optional[pulumi.Input['PartnershipX12InboundEdiOptionsArgs']]:
        """
        A structure that contains X12-specific options for processing inbound X12 EDI files.
        """
        return pulumi.get(self, "x12")

    @x12.setter
    def x12(self, value: Optional[pulumi.Input['PartnershipX12InboundEdiOptionsArgs']]):
        pulumi.set(self, "x12", value)


if not MYPY:
    class PartnershipOutboundEdiOptionsPropertiesArgsDict(TypedDict):
        x12: pulumi.Input['PartnershipX12EnvelopeArgsDict']
elif False:
    PartnershipOutboundEdiOptionsPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PartnershipOutboundEdiOptionsPropertiesArgs:
    def __init__(__self__, *,
                 x12: pulumi.Input['PartnershipX12EnvelopeArgs']):
        pulumi.set(__self__, "x12", x12)

    @_builtins.property
    @pulumi.getter
    def x12(self) -> pulumi.Input['PartnershipX12EnvelopeArgs']:
        return pulumi.get(self, "x12")

    @x12.setter
    def x12(self, value: pulumi.Input['PartnershipX12EnvelopeArgs']):
        pulumi.set(self, "x12", value)


if not MYPY:
    class PartnershipWrapOptionsArgsDict(TypedDict):
        line_length: NotRequired[pulumi.Input[_builtins.float]]
        line_terminator: NotRequired[pulumi.Input['PartnershipLineTerminator']]
        wrap_by: NotRequired[pulumi.Input['PartnershipWrapFormat']]
elif False:
    PartnershipWrapOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PartnershipWrapOptionsArgs:
    def __init__(__self__, *,
                 line_length: Optional[pulumi.Input[_builtins.float]] = None,
                 line_terminator: Optional[pulumi.Input['PartnershipLineTerminator']] = None,
                 wrap_by: Optional[pulumi.Input['PartnershipWrapFormat']] = None):
        if line_length is not None:
            pulumi.set(__self__, "line_length", line_length)
        if line_terminator is not None:
            pulumi.set(__self__, "line_terminator", line_terminator)
        if wrap_by is not None:
            pulumi.set(__self__, "wrap_by", wrap_by)

    @_builtins.property
    @pulumi.getter(name="lineLength")
    def line_length(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "line_length")

    @line_length.setter
    def line_length(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "line_length", value)

    @_builtins.property
    @pulumi.getter(name="lineTerminator")
    def line_terminator(self) -> Optional[pulumi.Input['PartnershipLineTerminator']]:
        return pulumi.get(self, "line_terminator")

    @line_terminator.setter
    def line_terminator(self, value: Optional[pulumi.Input['PartnershipLineTerminator']]):
        pulumi.set(self, "line_terminator", value)

    @_builtins.property
    @pulumi.getter(name="wrapBy")
    def wrap_by(self) -> Optional[pulumi.Input['PartnershipWrapFormat']]:
        return pulumi.get(self, "wrap_by")

    @wrap_by.setter
    def wrap_by(self, value: Optional[pulumi.Input['PartnershipWrapFormat']]):
        pulumi.set(self, "wrap_by", value)


if not MYPY:
    class PartnershipX12AcknowledgmentOptionsArgsDict(TypedDict):
        functional_acknowledgment: pulumi.Input['PartnershipX12FunctionalAcknowledgment']
        """
        Specifies whether functional acknowledgments (997/999) should be generated for incoming X12 transactions. Valid values are `DO_NOT_GENERATE` , `GENERATE_ALL_SEGMENTS` and `GENERATE_WITHOUT_TRANSACTION_SET_RESPONSE_LOOP` .

        If you choose `GENERATE_WITHOUT_TRANSACTION_SET_RESPONSE_LOOP` , AWS B2B Data Interchange skips the AK2_Loop when generating an acknowledgment document.
        """
        technical_acknowledgment: pulumi.Input['PartnershipX12TechnicalAcknowledgment']
        """
        Specifies whether technical acknowledgments (TA1) should be generated for incoming X12 interchanges. Valid values are `DO_NOT_GENERATE` and `GENERATE_ALL_SEGMENTS` and.
        """
elif False:
    PartnershipX12AcknowledgmentOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PartnershipX12AcknowledgmentOptionsArgs:
    def __init__(__self__, *,
                 functional_acknowledgment: pulumi.Input['PartnershipX12FunctionalAcknowledgment'],
                 technical_acknowledgment: pulumi.Input['PartnershipX12TechnicalAcknowledgment']):
        """
        :param pulumi.Input['PartnershipX12FunctionalAcknowledgment'] functional_acknowledgment: Specifies whether functional acknowledgments (997/999) should be generated for incoming X12 transactions. Valid values are `DO_NOT_GENERATE` , `GENERATE_ALL_SEGMENTS` and `GENERATE_WITHOUT_TRANSACTION_SET_RESPONSE_LOOP` .
               
               If you choose `GENERATE_WITHOUT_TRANSACTION_SET_RESPONSE_LOOP` , AWS B2B Data Interchange skips the AK2_Loop when generating an acknowledgment document.
        :param pulumi.Input['PartnershipX12TechnicalAcknowledgment'] technical_acknowledgment: Specifies whether technical acknowledgments (TA1) should be generated for incoming X12 interchanges. Valid values are `DO_NOT_GENERATE` and `GENERATE_ALL_SEGMENTS` and.
        """
        pulumi.set(__self__, "functional_acknowledgment", functional_acknowledgment)
        pulumi.set(__self__, "technical_acknowledgment", technical_acknowledgment)

    @_builtins.property
    @pulumi.getter(name="functionalAcknowledgment")
    def functional_acknowledgment(self) -> pulumi.Input['PartnershipX12FunctionalAcknowledgment']:
        """
        Specifies whether functional acknowledgments (997/999) should be generated for incoming X12 transactions. Valid values are `DO_NOT_GENERATE` , `GENERATE_ALL_SEGMENTS` and `GENERATE_WITHOUT_TRANSACTION_SET_RESPONSE_LOOP` .

        If you choose `GENERATE_WITHOUT_TRANSACTION_SET_RESPONSE_LOOP` , AWS B2B Data Interchange skips the AK2_Loop when generating an acknowledgment document.
        """
        return pulumi.get(self, "functional_acknowledgment")

    @functional_acknowledgment.setter
    def functional_acknowledgment(self, value: pulumi.Input['PartnershipX12FunctionalAcknowledgment']):
        pulumi.set(self, "functional_acknowledgment", value)

    @_builtins.property
    @pulumi.getter(name="technicalAcknowledgment")
    def technical_acknowledgment(self) -> pulumi.Input['PartnershipX12TechnicalAcknowledgment']:
        """
        Specifies whether technical acknowledgments (TA1) should be generated for incoming X12 interchanges. Valid values are `DO_NOT_GENERATE` and `GENERATE_ALL_SEGMENTS` and.
        """
        return pulumi.get(self, "technical_acknowledgment")

    @technical_acknowledgment.setter
    def technical_acknowledgment(self, value: pulumi.Input['PartnershipX12TechnicalAcknowledgment']):
        pulumi.set(self, "technical_acknowledgment", value)


if not MYPY:
    class PartnershipX12ControlNumbersArgsDict(TypedDict):
        starting_functional_group_control_number: NotRequired[pulumi.Input[_builtins.float]]
        starting_interchange_control_number: NotRequired[pulumi.Input[_builtins.float]]
        starting_transaction_set_control_number: NotRequired[pulumi.Input[_builtins.float]]
elif False:
    PartnershipX12ControlNumbersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PartnershipX12ControlNumbersArgs:
    def __init__(__self__, *,
                 starting_functional_group_control_number: Optional[pulumi.Input[_builtins.float]] = None,
                 starting_interchange_control_number: Optional[pulumi.Input[_builtins.float]] = None,
                 starting_transaction_set_control_number: Optional[pulumi.Input[_builtins.float]] = None):
        if starting_functional_group_control_number is not None:
            pulumi.set(__self__, "starting_functional_group_control_number", starting_functional_group_control_number)
        if starting_interchange_control_number is not None:
            pulumi.set(__self__, "starting_interchange_control_number", starting_interchange_control_number)
        if starting_transaction_set_control_number is not None:
            pulumi.set(__self__, "starting_transaction_set_control_number", starting_transaction_set_control_number)

    @_builtins.property
    @pulumi.getter(name="startingFunctionalGroupControlNumber")
    def starting_functional_group_control_number(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "starting_functional_group_control_number")

    @starting_functional_group_control_number.setter
    def starting_functional_group_control_number(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "starting_functional_group_control_number", value)

    @_builtins.property
    @pulumi.getter(name="startingInterchangeControlNumber")
    def starting_interchange_control_number(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "starting_interchange_control_number")

    @starting_interchange_control_number.setter
    def starting_interchange_control_number(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "starting_interchange_control_number", value)

    @_builtins.property
    @pulumi.getter(name="startingTransactionSetControlNumber")
    def starting_transaction_set_control_number(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "starting_transaction_set_control_number")

    @starting_transaction_set_control_number.setter
    def starting_transaction_set_control_number(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "starting_transaction_set_control_number", value)


if not MYPY:
    class PartnershipX12DelimitersArgsDict(TypedDict):
        component_separator: NotRequired[pulumi.Input[_builtins.str]]
        data_element_separator: NotRequired[pulumi.Input[_builtins.str]]
        segment_terminator: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PartnershipX12DelimitersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PartnershipX12DelimitersArgs:
    def __init__(__self__, *,
                 component_separator: Optional[pulumi.Input[_builtins.str]] = None,
                 data_element_separator: Optional[pulumi.Input[_builtins.str]] = None,
                 segment_terminator: Optional[pulumi.Input[_builtins.str]] = None):
        if component_separator is not None:
            pulumi.set(__self__, "component_separator", component_separator)
        if data_element_separator is not None:
            pulumi.set(__self__, "data_element_separator", data_element_separator)
        if segment_terminator is not None:
            pulumi.set(__self__, "segment_terminator", segment_terminator)

    @_builtins.property
    @pulumi.getter(name="componentSeparator")
    def component_separator(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "component_separator")

    @component_separator.setter
    def component_separator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "component_separator", value)

    @_builtins.property
    @pulumi.getter(name="dataElementSeparator")
    def data_element_separator(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "data_element_separator")

    @data_element_separator.setter
    def data_element_separator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data_element_separator", value)

    @_builtins.property
    @pulumi.getter(name="segmentTerminator")
    def segment_terminator(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "segment_terminator")

    @segment_terminator.setter
    def segment_terminator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "segment_terminator", value)


if not MYPY:
    class PartnershipX12EnvelopeArgsDict(TypedDict):
        common: NotRequired[pulumi.Input['PartnershipX12OutboundEdiHeadersArgsDict']]
        wrap_options: NotRequired[pulumi.Input['PartnershipWrapOptionsArgsDict']]
elif False:
    PartnershipX12EnvelopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PartnershipX12EnvelopeArgs:
    def __init__(__self__, *,
                 common: Optional[pulumi.Input['PartnershipX12OutboundEdiHeadersArgs']] = None,
                 wrap_options: Optional[pulumi.Input['PartnershipWrapOptionsArgs']] = None):
        if common is not None:
            pulumi.set(__self__, "common", common)
        if wrap_options is not None:
            pulumi.set(__self__, "wrap_options", wrap_options)

    @_builtins.property
    @pulumi.getter
    def common(self) -> Optional[pulumi.Input['PartnershipX12OutboundEdiHeadersArgs']]:
        return pulumi.get(self, "common")

    @common.setter
    def common(self, value: Optional[pulumi.Input['PartnershipX12OutboundEdiHeadersArgs']]):
        pulumi.set(self, "common", value)

    @_builtins.property
    @pulumi.getter(name="wrapOptions")
    def wrap_options(self) -> Optional[pulumi.Input['PartnershipWrapOptionsArgs']]:
        return pulumi.get(self, "wrap_options")

    @wrap_options.setter
    def wrap_options(self, value: Optional[pulumi.Input['PartnershipWrapOptionsArgs']]):
        pulumi.set(self, "wrap_options", value)


if not MYPY:
    class PartnershipX12FunctionalGroupHeadersArgsDict(TypedDict):
        application_receiver_code: NotRequired[pulumi.Input[_builtins.str]]
        application_sender_code: NotRequired[pulumi.Input[_builtins.str]]
        responsible_agency_code: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PartnershipX12FunctionalGroupHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PartnershipX12FunctionalGroupHeadersArgs:
    def __init__(__self__, *,
                 application_receiver_code: Optional[pulumi.Input[_builtins.str]] = None,
                 application_sender_code: Optional[pulumi.Input[_builtins.str]] = None,
                 responsible_agency_code: Optional[pulumi.Input[_builtins.str]] = None):
        if application_receiver_code is not None:
            pulumi.set(__self__, "application_receiver_code", application_receiver_code)
        if application_sender_code is not None:
            pulumi.set(__self__, "application_sender_code", application_sender_code)
        if responsible_agency_code is not None:
            pulumi.set(__self__, "responsible_agency_code", responsible_agency_code)

    @_builtins.property
    @pulumi.getter(name="applicationReceiverCode")
    def application_receiver_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "application_receiver_code")

    @application_receiver_code.setter
    def application_receiver_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "application_receiver_code", value)

    @_builtins.property
    @pulumi.getter(name="applicationSenderCode")
    def application_sender_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "application_sender_code")

    @application_sender_code.setter
    def application_sender_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "application_sender_code", value)

    @_builtins.property
    @pulumi.getter(name="responsibleAgencyCode")
    def responsible_agency_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "responsible_agency_code")

    @responsible_agency_code.setter
    def responsible_agency_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "responsible_agency_code", value)


if not MYPY:
    class PartnershipX12InboundEdiOptionsArgsDict(TypedDict):
        acknowledgment_options: NotRequired[pulumi.Input['PartnershipX12AcknowledgmentOptionsArgsDict']]
        """
        Specifies acknowledgment options for inbound X12 EDI files. These options control how functional and technical acknowledgments are handled.
        """
elif False:
    PartnershipX12InboundEdiOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PartnershipX12InboundEdiOptionsArgs:
    def __init__(__self__, *,
                 acknowledgment_options: Optional[pulumi.Input['PartnershipX12AcknowledgmentOptionsArgs']] = None):
        """
        :param pulumi.Input['PartnershipX12AcknowledgmentOptionsArgs'] acknowledgment_options: Specifies acknowledgment options for inbound X12 EDI files. These options control how functional and technical acknowledgments are handled.
        """
        if acknowledgment_options is not None:
            pulumi.set(__self__, "acknowledgment_options", acknowledgment_options)

    @_builtins.property
    @pulumi.getter(name="acknowledgmentOptions")
    def acknowledgment_options(self) -> Optional[pulumi.Input['PartnershipX12AcknowledgmentOptionsArgs']]:
        """
        Specifies acknowledgment options for inbound X12 EDI files. These options control how functional and technical acknowledgments are handled.
        """
        return pulumi.get(self, "acknowledgment_options")

    @acknowledgment_options.setter
    def acknowledgment_options(self, value: Optional[pulumi.Input['PartnershipX12AcknowledgmentOptionsArgs']]):
        pulumi.set(self, "acknowledgment_options", value)


if not MYPY:
    class PartnershipX12InterchangeControlHeadersArgsDict(TypedDict):
        acknowledgment_requested_code: NotRequired[pulumi.Input[_builtins.str]]
        receiver_id: NotRequired[pulumi.Input[_builtins.str]]
        receiver_id_qualifier: NotRequired[pulumi.Input[_builtins.str]]
        repetition_separator: NotRequired[pulumi.Input[_builtins.str]]
        sender_id: NotRequired[pulumi.Input[_builtins.str]]
        sender_id_qualifier: NotRequired[pulumi.Input[_builtins.str]]
        usage_indicator_code: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PartnershipX12InterchangeControlHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PartnershipX12InterchangeControlHeadersArgs:
    def __init__(__self__, *,
                 acknowledgment_requested_code: Optional[pulumi.Input[_builtins.str]] = None,
                 receiver_id: Optional[pulumi.Input[_builtins.str]] = None,
                 receiver_id_qualifier: Optional[pulumi.Input[_builtins.str]] = None,
                 repetition_separator: Optional[pulumi.Input[_builtins.str]] = None,
                 sender_id: Optional[pulumi.Input[_builtins.str]] = None,
                 sender_id_qualifier: Optional[pulumi.Input[_builtins.str]] = None,
                 usage_indicator_code: Optional[pulumi.Input[_builtins.str]] = None):
        if acknowledgment_requested_code is not None:
            pulumi.set(__self__, "acknowledgment_requested_code", acknowledgment_requested_code)
        if receiver_id is not None:
            pulumi.set(__self__, "receiver_id", receiver_id)
        if receiver_id_qualifier is not None:
            pulumi.set(__self__, "receiver_id_qualifier", receiver_id_qualifier)
        if repetition_separator is not None:
            pulumi.set(__self__, "repetition_separator", repetition_separator)
        if sender_id is not None:
            pulumi.set(__self__, "sender_id", sender_id)
        if sender_id_qualifier is not None:
            pulumi.set(__self__, "sender_id_qualifier", sender_id_qualifier)
        if usage_indicator_code is not None:
            pulumi.set(__self__, "usage_indicator_code", usage_indicator_code)

    @_builtins.property
    @pulumi.getter(name="acknowledgmentRequestedCode")
    def acknowledgment_requested_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "acknowledgment_requested_code")

    @acknowledgment_requested_code.setter
    def acknowledgment_requested_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "acknowledgment_requested_code", value)

    @_builtins.property
    @pulumi.getter(name="receiverId")
    def receiver_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "receiver_id")

    @receiver_id.setter
    def receiver_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "receiver_id", value)

    @_builtins.property
    @pulumi.getter(name="receiverIdQualifier")
    def receiver_id_qualifier(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "receiver_id_qualifier")

    @receiver_id_qualifier.setter
    def receiver_id_qualifier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "receiver_id_qualifier", value)

    @_builtins.property
    @pulumi.getter(name="repetitionSeparator")
    def repetition_separator(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "repetition_separator")

    @repetition_separator.setter
    def repetition_separator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repetition_separator", value)

    @_builtins.property
    @pulumi.getter(name="senderId")
    def sender_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "sender_id")

    @sender_id.setter
    def sender_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sender_id", value)

    @_builtins.property
    @pulumi.getter(name="senderIdQualifier")
    def sender_id_qualifier(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "sender_id_qualifier")

    @sender_id_qualifier.setter
    def sender_id_qualifier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sender_id_qualifier", value)

    @_builtins.property
    @pulumi.getter(name="usageIndicatorCode")
    def usage_indicator_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "usage_indicator_code")

    @usage_indicator_code.setter
    def usage_indicator_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "usage_indicator_code", value)


if not MYPY:
    class PartnershipX12OutboundEdiHeadersArgsDict(TypedDict):
        control_numbers: NotRequired[pulumi.Input['PartnershipX12ControlNumbersArgsDict']]
        delimiters: NotRequired[pulumi.Input['PartnershipX12DelimitersArgsDict']]
        functional_group_headers: NotRequired[pulumi.Input['PartnershipX12FunctionalGroupHeadersArgsDict']]
        gs05_time_format: NotRequired[pulumi.Input['PartnershipX12gs05TimeFormat']]
        interchange_control_headers: NotRequired[pulumi.Input['PartnershipX12InterchangeControlHeadersArgsDict']]
        validate_edi: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    PartnershipX12OutboundEdiHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PartnershipX12OutboundEdiHeadersArgs:
    def __init__(__self__, *,
                 control_numbers: Optional[pulumi.Input['PartnershipX12ControlNumbersArgs']] = None,
                 delimiters: Optional[pulumi.Input['PartnershipX12DelimitersArgs']] = None,
                 functional_group_headers: Optional[pulumi.Input['PartnershipX12FunctionalGroupHeadersArgs']] = None,
                 gs05_time_format: Optional[pulumi.Input['PartnershipX12gs05TimeFormat']] = None,
                 interchange_control_headers: Optional[pulumi.Input['PartnershipX12InterchangeControlHeadersArgs']] = None,
                 validate_edi: Optional[pulumi.Input[_builtins.bool]] = None):
        if control_numbers is not None:
            pulumi.set(__self__, "control_numbers", control_numbers)
        if delimiters is not None:
            pulumi.set(__self__, "delimiters", delimiters)
        if functional_group_headers is not None:
            pulumi.set(__self__, "functional_group_headers", functional_group_headers)
        if gs05_time_format is not None:
            pulumi.set(__self__, "gs05_time_format", gs05_time_format)
        if interchange_control_headers is not None:
            pulumi.set(__self__, "interchange_control_headers", interchange_control_headers)
        if validate_edi is not None:
            pulumi.set(__self__, "validate_edi", validate_edi)

    @_builtins.property
    @pulumi.getter(name="controlNumbers")
    def control_numbers(self) -> Optional[pulumi.Input['PartnershipX12ControlNumbersArgs']]:
        return pulumi.get(self, "control_numbers")

    @control_numbers.setter
    def control_numbers(self, value: Optional[pulumi.Input['PartnershipX12ControlNumbersArgs']]):
        pulumi.set(self, "control_numbers", value)

    @_builtins.property
    @pulumi.getter
    def delimiters(self) -> Optional[pulumi.Input['PartnershipX12DelimitersArgs']]:
        return pulumi.get(self, "delimiters")

    @delimiters.setter
    def delimiters(self, value: Optional[pulumi.Input['PartnershipX12DelimitersArgs']]):
        pulumi.set(self, "delimiters", value)

    @_builtins.property
    @pulumi.getter(name="functionalGroupHeaders")
    def functional_group_headers(self) -> Optional[pulumi.Input['PartnershipX12FunctionalGroupHeadersArgs']]:
        return pulumi.get(self, "functional_group_headers")

    @functional_group_headers.setter
    def functional_group_headers(self, value: Optional[pulumi.Input['PartnershipX12FunctionalGroupHeadersArgs']]):
        pulumi.set(self, "functional_group_headers", value)

    @_builtins.property
    @pulumi.getter(name="gs05TimeFormat")
    def gs05_time_format(self) -> Optional[pulumi.Input['PartnershipX12gs05TimeFormat']]:
        return pulumi.get(self, "gs05_time_format")

    @gs05_time_format.setter
    def gs05_time_format(self, value: Optional[pulumi.Input['PartnershipX12gs05TimeFormat']]):
        pulumi.set(self, "gs05_time_format", value)

    @_builtins.property
    @pulumi.getter(name="interchangeControlHeaders")
    def interchange_control_headers(self) -> Optional[pulumi.Input['PartnershipX12InterchangeControlHeadersArgs']]:
        return pulumi.get(self, "interchange_control_headers")

    @interchange_control_headers.setter
    def interchange_control_headers(self, value: Optional[pulumi.Input['PartnershipX12InterchangeControlHeadersArgs']]):
        pulumi.set(self, "interchange_control_headers", value)

    @_builtins.property
    @pulumi.getter(name="validateEdi")
    def validate_edi(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "validate_edi")

    @validate_edi.setter
    def validate_edi(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "validate_edi", value)


if not MYPY:
    class TransformerAdvancedOptionsArgsDict(TypedDict):
        x12: NotRequired[pulumi.Input['TransformerX12AdvancedOptionsArgsDict']]
        """
        A structure that contains X12-specific advanced options, such as split options for processing X12 EDI files.
        """
elif False:
    TransformerAdvancedOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerAdvancedOptionsArgs:
    def __init__(__self__, *,
                 x12: Optional[pulumi.Input['TransformerX12AdvancedOptionsArgs']] = None):
        """
        :param pulumi.Input['TransformerX12AdvancedOptionsArgs'] x12: A structure that contains X12-specific advanced options, such as split options for processing X12 EDI files.
        """
        if x12 is not None:
            pulumi.set(__self__, "x12", x12)

    @_builtins.property
    @pulumi.getter
    def x12(self) -> Optional[pulumi.Input['TransformerX12AdvancedOptionsArgs']]:
        """
        A structure that contains X12-specific advanced options, such as split options for processing X12 EDI files.
        """
        return pulumi.get(self, "x12")

    @x12.setter
    def x12(self, value: Optional[pulumi.Input['TransformerX12AdvancedOptionsArgs']]):
        pulumi.set(self, "x12", value)


if not MYPY:
    class TransformerEdiTypePropertiesArgsDict(TypedDict):
        x12_details: pulumi.Input['TransformerX12DetailsArgsDict']
elif False:
    TransformerEdiTypePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerEdiTypePropertiesArgs:
    def __init__(__self__, *,
                 x12_details: pulumi.Input['TransformerX12DetailsArgs']):
        pulumi.set(__self__, "x12_details", x12_details)

    @_builtins.property
    @pulumi.getter(name="x12Details")
    def x12_details(self) -> pulumi.Input['TransformerX12DetailsArgs']:
        return pulumi.get(self, "x12_details")

    @x12_details.setter
    def x12_details(self, value: pulumi.Input['TransformerX12DetailsArgs']):
        pulumi.set(self, "x12_details", value)


if not MYPY:
    class TransformerFormatOptionsPropertiesArgsDict(TypedDict):
        x12: pulumi.Input['TransformerX12DetailsArgsDict']
elif False:
    TransformerFormatOptionsPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerFormatOptionsPropertiesArgs:
    def __init__(__self__, *,
                 x12: pulumi.Input['TransformerX12DetailsArgs']):
        pulumi.set(__self__, "x12", x12)

    @_builtins.property
    @pulumi.getter
    def x12(self) -> pulumi.Input['TransformerX12DetailsArgs']:
        return pulumi.get(self, "x12")

    @x12.setter
    def x12(self, value: pulumi.Input['TransformerX12DetailsArgs']):
        pulumi.set(self, "x12", value)


if not MYPY:
    class TransformerInputConversionArgsDict(TypedDict):
        from_format: pulumi.Input['TransformerFromFormat']
        """
        The format for the transformer input: currently on `X12` is supported.
        """
        advanced_options: NotRequired[pulumi.Input['TransformerAdvancedOptionsArgsDict']]
        """
        Specifies advanced options for the input conversion process. These options provide additional control over how EDI files are processed during transformation.
        """
        format_options: NotRequired[pulumi.Input['TransformerFormatOptionsPropertiesArgsDict']]
        """
        A structure that contains the formatting options for an inbound transformer.
        """
elif False:
    TransformerInputConversionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerInputConversionArgs:
    def __init__(__self__, *,
                 from_format: pulumi.Input['TransformerFromFormat'],
                 advanced_options: Optional[pulumi.Input['TransformerAdvancedOptionsArgs']] = None,
                 format_options: Optional[pulumi.Input['TransformerFormatOptionsPropertiesArgs']] = None):
        """
        :param pulumi.Input['TransformerFromFormat'] from_format: The format for the transformer input: currently on `X12` is supported.
        :param pulumi.Input['TransformerAdvancedOptionsArgs'] advanced_options: Specifies advanced options for the input conversion process. These options provide additional control over how EDI files are processed during transformation.
        :param pulumi.Input['TransformerFormatOptionsPropertiesArgs'] format_options: A structure that contains the formatting options for an inbound transformer.
        """
        pulumi.set(__self__, "from_format", from_format)
        if advanced_options is not None:
            pulumi.set(__self__, "advanced_options", advanced_options)
        if format_options is not None:
            pulumi.set(__self__, "format_options", format_options)

    @_builtins.property
    @pulumi.getter(name="fromFormat")
    def from_format(self) -> pulumi.Input['TransformerFromFormat']:
        """
        The format for the transformer input: currently on `X12` is supported.
        """
        return pulumi.get(self, "from_format")

    @from_format.setter
    def from_format(self, value: pulumi.Input['TransformerFromFormat']):
        pulumi.set(self, "from_format", value)

    @_builtins.property
    @pulumi.getter(name="advancedOptions")
    def advanced_options(self) -> Optional[pulumi.Input['TransformerAdvancedOptionsArgs']]:
        """
        Specifies advanced options for the input conversion process. These options provide additional control over how EDI files are processed during transformation.
        """
        return pulumi.get(self, "advanced_options")

    @advanced_options.setter
    def advanced_options(self, value: Optional[pulumi.Input['TransformerAdvancedOptionsArgs']]):
        pulumi.set(self, "advanced_options", value)

    @_builtins.property
    @pulumi.getter(name="formatOptions")
    def format_options(self) -> Optional[pulumi.Input['TransformerFormatOptionsPropertiesArgs']]:
        """
        A structure that contains the formatting options for an inbound transformer.
        """
        return pulumi.get(self, "format_options")

    @format_options.setter
    def format_options(self, value: Optional[pulumi.Input['TransformerFormatOptionsPropertiesArgs']]):
        pulumi.set(self, "format_options", value)


if not MYPY:
    class TransformerMappingArgsDict(TypedDict):
        template_language: pulumi.Input['TransformerMappingTemplateLanguage']
        """
        The transformation language for the template, either XSLT or JSONATA.
        """
        template: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that represents the mapping template, in the transformation language specified in `templateLanguage` .
        """
elif False:
    TransformerMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerMappingArgs:
    def __init__(__self__, *,
                 template_language: pulumi.Input['TransformerMappingTemplateLanguage'],
                 template: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['TransformerMappingTemplateLanguage'] template_language: The transformation language for the template, either XSLT or JSONATA.
        :param pulumi.Input[_builtins.str] template: A string that represents the mapping template, in the transformation language specified in `templateLanguage` .
        """
        pulumi.set(__self__, "template_language", template_language)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @_builtins.property
    @pulumi.getter(name="templateLanguage")
    def template_language(self) -> pulumi.Input['TransformerMappingTemplateLanguage']:
        """
        The transformation language for the template, either XSLT or JSONATA.
        """
        return pulumi.get(self, "template_language")

    @template_language.setter
    def template_language(self, value: pulumi.Input['TransformerMappingTemplateLanguage']):
        pulumi.set(self, "template_language", value)

    @_builtins.property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that represents the mapping template, in the transformation language specified in `templateLanguage` .
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "template", value)


if not MYPY:
    class TransformerOutputConversionArgsDict(TypedDict):
        to_format: pulumi.Input['TransformerToFormat']
        """
        The format for the output from an outbound transformer: only X12 is currently supported.
        """
        advanced_options: NotRequired[pulumi.Input['TransformerAdvancedOptionsArgsDict']]
        format_options: NotRequired[pulumi.Input['TransformerFormatOptionsPropertiesArgsDict']]
        """
        A structure that contains the X12 transaction set and version for the transformer output.
        """
elif False:
    TransformerOutputConversionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerOutputConversionArgs:
    def __init__(__self__, *,
                 to_format: pulumi.Input['TransformerToFormat'],
                 advanced_options: Optional[pulumi.Input['TransformerAdvancedOptionsArgs']] = None,
                 format_options: Optional[pulumi.Input['TransformerFormatOptionsPropertiesArgs']] = None):
        """
        :param pulumi.Input['TransformerToFormat'] to_format: The format for the output from an outbound transformer: only X12 is currently supported.
        :param pulumi.Input['TransformerFormatOptionsPropertiesArgs'] format_options: A structure that contains the X12 transaction set and version for the transformer output.
        """
        pulumi.set(__self__, "to_format", to_format)
        if advanced_options is not None:
            pulumi.set(__self__, "advanced_options", advanced_options)
        if format_options is not None:
            pulumi.set(__self__, "format_options", format_options)

    @_builtins.property
    @pulumi.getter(name="toFormat")
    def to_format(self) -> pulumi.Input['TransformerToFormat']:
        """
        The format for the output from an outbound transformer: only X12 is currently supported.
        """
        return pulumi.get(self, "to_format")

    @to_format.setter
    def to_format(self, value: pulumi.Input['TransformerToFormat']):
        pulumi.set(self, "to_format", value)

    @_builtins.property
    @pulumi.getter(name="advancedOptions")
    def advanced_options(self) -> Optional[pulumi.Input['TransformerAdvancedOptionsArgs']]:
        return pulumi.get(self, "advanced_options")

    @advanced_options.setter
    def advanced_options(self, value: Optional[pulumi.Input['TransformerAdvancedOptionsArgs']]):
        pulumi.set(self, "advanced_options", value)

    @_builtins.property
    @pulumi.getter(name="formatOptions")
    def format_options(self) -> Optional[pulumi.Input['TransformerFormatOptionsPropertiesArgs']]:
        """
        A structure that contains the X12 transaction set and version for the transformer output.
        """
        return pulumi.get(self, "format_options")

    @format_options.setter
    def format_options(self, value: Optional[pulumi.Input['TransformerFormatOptionsPropertiesArgs']]):
        pulumi.set(self, "format_options", value)


if not MYPY:
    class TransformerSampleDocumentKeysArgsDict(TypedDict):
        input: NotRequired[pulumi.Input[_builtins.str]]
        """
        An array of keys for your input sample documents.
        """
        output: NotRequired[pulumi.Input[_builtins.str]]
        """
        An array of keys for your output sample documents.
        """
elif False:
    TransformerSampleDocumentKeysArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerSampleDocumentKeysArgs:
    def __init__(__self__, *,
                 input: Optional[pulumi.Input[_builtins.str]] = None,
                 output: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] input: An array of keys for your input sample documents.
        :param pulumi.Input[_builtins.str] output: An array of keys for your output sample documents.
        """
        if input is not None:
            pulumi.set(__self__, "input", input)
        if output is not None:
            pulumi.set(__self__, "output", output)

    @_builtins.property
    @pulumi.getter
    def input(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An array of keys for your input sample documents.
        """
        return pulumi.get(self, "input")

    @input.setter
    def input(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "input", value)

    @_builtins.property
    @pulumi.getter
    def output(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An array of keys for your output sample documents.
        """
        return pulumi.get(self, "output")

    @output.setter
    def output(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "output", value)


if not MYPY:
    class TransformerSampleDocumentsArgsDict(TypedDict):
        bucket_name: pulumi.Input[_builtins.str]
        """
        Contains the Amazon S3 bucket that is used to hold your sample documents.
        """
        keys: pulumi.Input[Sequence[pulumi.Input['TransformerSampleDocumentKeysArgsDict']]]
        """
        Contains an array of the Amazon S3 keys used to identify the location for your sample documents.
        """
elif False:
    TransformerSampleDocumentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerSampleDocumentsArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[_builtins.str],
                 keys: pulumi.Input[Sequence[pulumi.Input['TransformerSampleDocumentKeysArgs']]]):
        """
        :param pulumi.Input[_builtins.str] bucket_name: Contains the Amazon S3 bucket that is used to hold your sample documents.
        :param pulumi.Input[Sequence[pulumi.Input['TransformerSampleDocumentKeysArgs']]] keys: Contains an array of the Amazon S3 keys used to identify the location for your sample documents.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "keys", keys)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[_builtins.str]:
        """
        Contains the Amazon S3 bucket that is used to hold your sample documents.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter
    def keys(self) -> pulumi.Input[Sequence[pulumi.Input['TransformerSampleDocumentKeysArgs']]]:
        """
        Contains an array of the Amazon S3 keys used to identify the location for your sample documents.
        """
        return pulumi.get(self, "keys")

    @keys.setter
    def keys(self, value: pulumi.Input[Sequence[pulumi.Input['TransformerSampleDocumentKeysArgs']]]):
        pulumi.set(self, "keys", value)


if not MYPY:
    class TransformerX12AdvancedOptionsArgsDict(TypedDict):
        split_options: NotRequired[pulumi.Input['TransformerX12SplitOptionsArgsDict']]
        """
        Specifies options for splitting X12 EDI files. These options control how large X12 files are divided into smaller, more manageable units.
        """
        validation_options: NotRequired[pulumi.Input['TransformerX12ValidationOptionsArgsDict']]
        """
        Specifies validation options for X12 EDI processing. These options control how validation rules are applied during EDI document processing, including custom validation rules for element length constraints, code list validations, and element requirement checks.
        """
elif False:
    TransformerX12AdvancedOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerX12AdvancedOptionsArgs:
    def __init__(__self__, *,
                 split_options: Optional[pulumi.Input['TransformerX12SplitOptionsArgs']] = None,
                 validation_options: Optional[pulumi.Input['TransformerX12ValidationOptionsArgs']] = None):
        """
        :param pulumi.Input['TransformerX12SplitOptionsArgs'] split_options: Specifies options for splitting X12 EDI files. These options control how large X12 files are divided into smaller, more manageable units.
        :param pulumi.Input['TransformerX12ValidationOptionsArgs'] validation_options: Specifies validation options for X12 EDI processing. These options control how validation rules are applied during EDI document processing, including custom validation rules for element length constraints, code list validations, and element requirement checks.
        """
        if split_options is not None:
            pulumi.set(__self__, "split_options", split_options)
        if validation_options is not None:
            pulumi.set(__self__, "validation_options", validation_options)

    @_builtins.property
    @pulumi.getter(name="splitOptions")
    def split_options(self) -> Optional[pulumi.Input['TransformerX12SplitOptionsArgs']]:
        """
        Specifies options for splitting X12 EDI files. These options control how large X12 files are divided into smaller, more manageable units.
        """
        return pulumi.get(self, "split_options")

    @split_options.setter
    def split_options(self, value: Optional[pulumi.Input['TransformerX12SplitOptionsArgs']]):
        pulumi.set(self, "split_options", value)

    @_builtins.property
    @pulumi.getter(name="validationOptions")
    def validation_options(self) -> Optional[pulumi.Input['TransformerX12ValidationOptionsArgs']]:
        """
        Specifies validation options for X12 EDI processing. These options control how validation rules are applied during EDI document processing, including custom validation rules for element length constraints, code list validations, and element requirement checks.
        """
        return pulumi.get(self, "validation_options")

    @validation_options.setter
    def validation_options(self, value: Optional[pulumi.Input['TransformerX12ValidationOptionsArgs']]):
        pulumi.set(self, "validation_options", value)


if not MYPY:
    class TransformerX12CodeListValidationRuleArgsDict(TypedDict):
        element_id: pulumi.Input[_builtins.str]
        codes_to_add: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        codes_to_remove: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    TransformerX12CodeListValidationRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerX12CodeListValidationRuleArgs:
    def __init__(__self__, *,
                 element_id: pulumi.Input[_builtins.str],
                 codes_to_add: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 codes_to_remove: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "element_id", element_id)
        if codes_to_add is not None:
            pulumi.set(__self__, "codes_to_add", codes_to_add)
        if codes_to_remove is not None:
            pulumi.set(__self__, "codes_to_remove", codes_to_remove)

    @_builtins.property
    @pulumi.getter(name="elementId")
    def element_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "element_id")

    @element_id.setter
    def element_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "element_id", value)

    @_builtins.property
    @pulumi.getter(name="codesToAdd")
    def codes_to_add(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "codes_to_add")

    @codes_to_add.setter
    def codes_to_add(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "codes_to_add", value)

    @_builtins.property
    @pulumi.getter(name="codesToRemove")
    def codes_to_remove(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "codes_to_remove")

    @codes_to_remove.setter
    def codes_to_remove(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "codes_to_remove", value)


if not MYPY:
    class TransformerX12DetailsArgsDict(TypedDict):
        transaction_set: NotRequired[pulumi.Input['TransformerX12TransactionSet']]
        version: NotRequired[pulumi.Input['TransformerX12Version']]
elif False:
    TransformerX12DetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerX12DetailsArgs:
    def __init__(__self__, *,
                 transaction_set: Optional[pulumi.Input['TransformerX12TransactionSet']] = None,
                 version: Optional[pulumi.Input['TransformerX12Version']] = None):
        if transaction_set is not None:
            pulumi.set(__self__, "transaction_set", transaction_set)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="transactionSet")
    def transaction_set(self) -> Optional[pulumi.Input['TransformerX12TransactionSet']]:
        return pulumi.get(self, "transaction_set")

    @transaction_set.setter
    def transaction_set(self, value: Optional[pulumi.Input['TransformerX12TransactionSet']]):
        pulumi.set(self, "transaction_set", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input['TransformerX12Version']]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input['TransformerX12Version']]):
        pulumi.set(self, "version", value)


if not MYPY:
    class TransformerX12ElementLengthValidationRuleArgsDict(TypedDict):
        element_id: pulumi.Input[_builtins.str]
        max_length: pulumi.Input[_builtins.float]
        min_length: pulumi.Input[_builtins.float]
elif False:
    TransformerX12ElementLengthValidationRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerX12ElementLengthValidationRuleArgs:
    def __init__(__self__, *,
                 element_id: pulumi.Input[_builtins.str],
                 max_length: pulumi.Input[_builtins.float],
                 min_length: pulumi.Input[_builtins.float]):
        pulumi.set(__self__, "element_id", element_id)
        pulumi.set(__self__, "max_length", max_length)
        pulumi.set(__self__, "min_length", min_length)

    @_builtins.property
    @pulumi.getter(name="elementId")
    def element_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "element_id")

    @element_id.setter
    def element_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "element_id", value)

    @_builtins.property
    @pulumi.getter(name="maxLength")
    def max_length(self) -> pulumi.Input[_builtins.float]:
        return pulumi.get(self, "max_length")

    @max_length.setter
    def max_length(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "max_length", value)

    @_builtins.property
    @pulumi.getter(name="minLength")
    def min_length(self) -> pulumi.Input[_builtins.float]:
        return pulumi.get(self, "min_length")

    @min_length.setter
    def min_length(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "min_length", value)


if not MYPY:
    class TransformerX12ElementRequirementValidationRuleArgsDict(TypedDict):
        element_position: pulumi.Input[_builtins.str]
        requirement: pulumi.Input['TransformerElementRequirement']
elif False:
    TransformerX12ElementRequirementValidationRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerX12ElementRequirementValidationRuleArgs:
    def __init__(__self__, *,
                 element_position: pulumi.Input[_builtins.str],
                 requirement: pulumi.Input['TransformerElementRequirement']):
        pulumi.set(__self__, "element_position", element_position)
        pulumi.set(__self__, "requirement", requirement)

    @_builtins.property
    @pulumi.getter(name="elementPosition")
    def element_position(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "element_position")

    @element_position.setter
    def element_position(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "element_position", value)

    @_builtins.property
    @pulumi.getter
    def requirement(self) -> pulumi.Input['TransformerElementRequirement']:
        return pulumi.get(self, "requirement")

    @requirement.setter
    def requirement(self, value: pulumi.Input['TransformerElementRequirement']):
        pulumi.set(self, "requirement", value)


if not MYPY:
    class TransformerX12SplitOptionsArgsDict(TypedDict):
        split_by: NotRequired[pulumi.Input['TransformerX12SplitBy']]
        """
        Specifies the method used to split X12 EDI files. Valid values include `TRANSACTION` (split by individual transaction sets), or `NONE` (no splitting).
        """
elif False:
    TransformerX12SplitOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerX12SplitOptionsArgs:
    def __init__(__self__, *,
                 split_by: Optional[pulumi.Input['TransformerX12SplitBy']] = None):
        """
        :param pulumi.Input['TransformerX12SplitBy'] split_by: Specifies the method used to split X12 EDI files. Valid values include `TRANSACTION` (split by individual transaction sets), or `NONE` (no splitting).
        """
        if split_by is not None:
            pulumi.set(__self__, "split_by", split_by)

    @_builtins.property
    @pulumi.getter(name="splitBy")
    def split_by(self) -> Optional[pulumi.Input['TransformerX12SplitBy']]:
        """
        Specifies the method used to split X12 EDI files. Valid values include `TRANSACTION` (split by individual transaction sets), or `NONE` (no splitting).
        """
        return pulumi.get(self, "split_by")

    @split_by.setter
    def split_by(self, value: Optional[pulumi.Input['TransformerX12SplitBy']]):
        pulumi.set(self, "split_by", value)


if not MYPY:
    class TransformerX12ValidationOptionsArgsDict(TypedDict):
        validation_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input[Union['TransformerX12ValidationRule0PropertiesArgsDict', 'TransformerX12ValidationRule1PropertiesArgsDict', 'TransformerX12ValidationRule2PropertiesArgsDict']]]]]
        """
        Specifies a list of validation rules to apply during EDI document processing. These rules can include code list modifications, element length constraints, and element requirement changes.
        """
elif False:
    TransformerX12ValidationOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerX12ValidationOptionsArgs:
    def __init__(__self__, *,
                 validation_rules: Optional[pulumi.Input[Sequence[pulumi.Input[Union['TransformerX12ValidationRule0PropertiesArgs', 'TransformerX12ValidationRule1PropertiesArgs', 'TransformerX12ValidationRule2PropertiesArgs']]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[Union['TransformerX12ValidationRule0PropertiesArgs', 'TransformerX12ValidationRule1PropertiesArgs', 'TransformerX12ValidationRule2PropertiesArgs']]]] validation_rules: Specifies a list of validation rules to apply during EDI document processing. These rules can include code list modifications, element length constraints, and element requirement changes.
        """
        if validation_rules is not None:
            pulumi.set(__self__, "validation_rules", validation_rules)

    @_builtins.property
    @pulumi.getter(name="validationRules")
    def validation_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Union['TransformerX12ValidationRule0PropertiesArgs', 'TransformerX12ValidationRule1PropertiesArgs', 'TransformerX12ValidationRule2PropertiesArgs']]]]]:
        """
        Specifies a list of validation rules to apply during EDI document processing. These rules can include code list modifications, element length constraints, and element requirement changes.
        """
        return pulumi.get(self, "validation_rules")

    @validation_rules.setter
    def validation_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Union['TransformerX12ValidationRule0PropertiesArgs', 'TransformerX12ValidationRule1PropertiesArgs', 'TransformerX12ValidationRule2PropertiesArgs']]]]]):
        pulumi.set(self, "validation_rules", value)


if not MYPY:
    class TransformerX12ValidationRule0PropertiesArgsDict(TypedDict):
        code_list_validation_rule: pulumi.Input['TransformerX12CodeListValidationRuleArgsDict']
elif False:
    TransformerX12ValidationRule0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerX12ValidationRule0PropertiesArgs:
    def __init__(__self__, *,
                 code_list_validation_rule: pulumi.Input['TransformerX12CodeListValidationRuleArgs']):
        pulumi.set(__self__, "code_list_validation_rule", code_list_validation_rule)

    @_builtins.property
    @pulumi.getter(name="codeListValidationRule")
    def code_list_validation_rule(self) -> pulumi.Input['TransformerX12CodeListValidationRuleArgs']:
        return pulumi.get(self, "code_list_validation_rule")

    @code_list_validation_rule.setter
    def code_list_validation_rule(self, value: pulumi.Input['TransformerX12CodeListValidationRuleArgs']):
        pulumi.set(self, "code_list_validation_rule", value)


if not MYPY:
    class TransformerX12ValidationRule1PropertiesArgsDict(TypedDict):
        element_length_validation_rule: pulumi.Input['TransformerX12ElementLengthValidationRuleArgsDict']
elif False:
    TransformerX12ValidationRule1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerX12ValidationRule1PropertiesArgs:
    def __init__(__self__, *,
                 element_length_validation_rule: pulumi.Input['TransformerX12ElementLengthValidationRuleArgs']):
        pulumi.set(__self__, "element_length_validation_rule", element_length_validation_rule)

    @_builtins.property
    @pulumi.getter(name="elementLengthValidationRule")
    def element_length_validation_rule(self) -> pulumi.Input['TransformerX12ElementLengthValidationRuleArgs']:
        return pulumi.get(self, "element_length_validation_rule")

    @element_length_validation_rule.setter
    def element_length_validation_rule(self, value: pulumi.Input['TransformerX12ElementLengthValidationRuleArgs']):
        pulumi.set(self, "element_length_validation_rule", value)


if not MYPY:
    class TransformerX12ValidationRule2PropertiesArgsDict(TypedDict):
        element_requirement_validation_rule: pulumi.Input['TransformerX12ElementRequirementValidationRuleArgsDict']
elif False:
    TransformerX12ValidationRule2PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerX12ValidationRule2PropertiesArgs:
    def __init__(__self__, *,
                 element_requirement_validation_rule: pulumi.Input['TransformerX12ElementRequirementValidationRuleArgs']):
        pulumi.set(__self__, "element_requirement_validation_rule", element_requirement_validation_rule)

    @_builtins.property
    @pulumi.getter(name="elementRequirementValidationRule")
    def element_requirement_validation_rule(self) -> pulumi.Input['TransformerX12ElementRequirementValidationRuleArgs']:
        return pulumi.get(self, "element_requirement_validation_rule")

    @element_requirement_validation_rule.setter
    def element_requirement_validation_rule(self, value: pulumi.Input['TransformerX12ElementRequirementValidationRuleArgs']):
        pulumi.set(self, "element_requirement_validation_rule", value)


