# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'DeliveryDestinationDestinationPolicyArgs',
    'DeliveryDestinationDestinationPolicyArgsDict',
    'IntegrationOpenSearchResourceConfigArgs',
    'IntegrationOpenSearchResourceConfigArgsDict',
    'MetricFilterDimensionArgs',
    'MetricFilterDimensionArgsDict',
    'MetricFilterMetricTransformationArgs',
    'MetricFilterMetricTransformationArgsDict',
    'ResourceConfigPropertiesArgs',
    'ResourceConfigPropertiesArgsDict',
    'TransformerAddKeyEntryArgs',
    'TransformerAddKeyEntryArgsDict',
    'TransformerCopyValueEntryArgs',
    'TransformerCopyValueEntryArgsDict',
    'TransformerMoveKeyEntryArgs',
    'TransformerMoveKeyEntryArgsDict',
    'TransformerParseCloudfrontArgs',
    'TransformerParseCloudfrontArgsDict',
    'TransformerParsePostgresArgs',
    'TransformerParsePostgresArgsDict',
    'TransformerParseRoute53Args',
    'TransformerParseRoute53ArgsDict',
    'TransformerParseToOcsfArgs',
    'TransformerParseToOcsfArgsDict',
    'TransformerParseVpcArgs',
    'TransformerParseVpcArgsDict',
    'TransformerParseWafArgs',
    'TransformerParseWafArgsDict',
    'TransformerProcessorAddKeysPropertiesArgs',
    'TransformerProcessorAddKeysPropertiesArgsDict',
    'TransformerProcessorCopyValuePropertiesArgs',
    'TransformerProcessorCopyValuePropertiesArgsDict',
    'TransformerProcessorCsvPropertiesArgs',
    'TransformerProcessorCsvPropertiesArgsDict',
    'TransformerProcessorDateTimeConverterPropertiesArgs',
    'TransformerProcessorDateTimeConverterPropertiesArgsDict',
    'TransformerProcessorDeleteKeysPropertiesArgs',
    'TransformerProcessorDeleteKeysPropertiesArgsDict',
    'TransformerProcessorGrokPropertiesArgs',
    'TransformerProcessorGrokPropertiesArgsDict',
    'TransformerProcessorListToMapPropertiesArgs',
    'TransformerProcessorListToMapPropertiesArgsDict',
    'TransformerProcessorLowerCaseStringPropertiesArgs',
    'TransformerProcessorLowerCaseStringPropertiesArgsDict',
    'TransformerProcessorMoveKeysPropertiesArgs',
    'TransformerProcessorMoveKeysPropertiesArgsDict',
    'TransformerProcessorParseJsonPropertiesArgs',
    'TransformerProcessorParseJsonPropertiesArgsDict',
    'TransformerProcessorParseKeyValuePropertiesArgs',
    'TransformerProcessorParseKeyValuePropertiesArgsDict',
    'TransformerProcessorRenameKeysPropertiesArgs',
    'TransformerProcessorRenameKeysPropertiesArgsDict',
    'TransformerProcessorSplitStringPropertiesArgs',
    'TransformerProcessorSplitStringPropertiesArgsDict',
    'TransformerProcessorSubstituteStringPropertiesArgs',
    'TransformerProcessorSubstituteStringPropertiesArgsDict',
    'TransformerProcessorTrimStringPropertiesArgs',
    'TransformerProcessorTrimStringPropertiesArgsDict',
    'TransformerProcessorTypeConverterPropertiesArgs',
    'TransformerProcessorTypeConverterPropertiesArgsDict',
    'TransformerProcessorUpperCaseStringPropertiesArgs',
    'TransformerProcessorUpperCaseStringPropertiesArgsDict',
    'TransformerProcessorArgs',
    'TransformerProcessorArgsDict',
    'TransformerRenameKeyEntryArgs',
    'TransformerRenameKeyEntryArgsDict',
    'TransformerSplitStringEntryArgs',
    'TransformerSplitStringEntryArgsDict',
    'TransformerSubstituteStringEntryArgs',
    'TransformerSubstituteStringEntryArgsDict',
    'TransformerTypeConverterEntryArgs',
    'TransformerTypeConverterEntryArgsDict',
]

MYPY = False

if not MYPY:
    class DeliveryDestinationDestinationPolicyArgsDict(TypedDict):
        delivery_destination_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the delivery destination to assign this policy to
        """
        delivery_destination_policy: NotRequired[Any]
        """
        The contents of the policy attached to the delivery destination
        """
elif False:
    DeliveryDestinationDestinationPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeliveryDestinationDestinationPolicyArgs:
    def __init__(__self__, *,
                 delivery_destination_name: Optional[pulumi.Input[_builtins.str]] = None,
                 delivery_destination_policy: Optional[Any] = None):
        """
        :param pulumi.Input[_builtins.str] delivery_destination_name: The name of the delivery destination to assign this policy to
        :param Any delivery_destination_policy: The contents of the policy attached to the delivery destination
        """
        if delivery_destination_name is not None:
            pulumi.set(__self__, "delivery_destination_name", delivery_destination_name)
        if delivery_destination_policy is not None:
            pulumi.set(__self__, "delivery_destination_policy", delivery_destination_policy)

    @_builtins.property
    @pulumi.getter(name="deliveryDestinationName")
    def delivery_destination_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the delivery destination to assign this policy to
        """
        return pulumi.get(self, "delivery_destination_name")

    @delivery_destination_name.setter
    def delivery_destination_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delivery_destination_name", value)

    @_builtins.property
    @pulumi.getter(name="deliveryDestinationPolicy")
    def delivery_destination_policy(self) -> Optional[Any]:
        """
        The contents of the policy attached to the delivery destination
        """
        return pulumi.get(self, "delivery_destination_policy")

    @delivery_destination_policy.setter
    def delivery_destination_policy(self, value: Optional[Any]):
        pulumi.set(self, "delivery_destination_policy", value)


if not MYPY:
    class IntegrationOpenSearchResourceConfigArgsDict(TypedDict):
        dashboard_viewer_principals: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Specify the ARNs of IAM roles and IAM users who you want to grant permission to for viewing the dashboards.

        > In addition to specifying these users here, you must also grant them the *CloudWatchOpenSearchDashboardAccess* IAM policy. For more information, see [IAM policies for users](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/OpenSearch-Dashboards-UserRoles.html) .
        """
        data_source_role_arn: pulumi.Input[_builtins.str]
        """
        Specify the ARN of an IAM role that CloudWatch Logs will use to create the integration. This role must have the permissions necessary to access the OpenSearch Service collection to be able to create the dashboards. For more information about the permissions needed, see [Permissions that the integration needs](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/OpenSearch-Dashboards-CreateRole.html) in the CloudWatch Logs User Guide.
        """
        application_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        If you want to use an existing OpenSearch Service application for your integration with OpenSearch Service, specify it here. If you omit this, a new application will be created.
        """
        kms_key_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        To have the vended dashboard data encrypted with AWS KMS instead of the CloudWatch Logs default encryption method, specify the ARN of the AWS KMS key that you want to use.
        """
        retention_days: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specify how many days that you want the data derived by OpenSearch Service to be retained in the index that the dashboard refers to. This also sets the maximum time period that you can choose when viewing data in the dashboard. Choosing a longer time frame will incur additional costs.
        """
elif False:
    IntegrationOpenSearchResourceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntegrationOpenSearchResourceConfigArgs:
    def __init__(__self__, *,
                 dashboard_viewer_principals: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 data_source_role_arn: pulumi.Input[_builtins.str],
                 application_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 kms_key_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 retention_days: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] dashboard_viewer_principals: Specify the ARNs of IAM roles and IAM users who you want to grant permission to for viewing the dashboards.
               
               > In addition to specifying these users here, you must also grant them the *CloudWatchOpenSearchDashboardAccess* IAM policy. For more information, see [IAM policies for users](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/OpenSearch-Dashboards-UserRoles.html) .
        :param pulumi.Input[_builtins.str] data_source_role_arn: Specify the ARN of an IAM role that CloudWatch Logs will use to create the integration. This role must have the permissions necessary to access the OpenSearch Service collection to be able to create the dashboards. For more information about the permissions needed, see [Permissions that the integration needs](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/OpenSearch-Dashboards-CreateRole.html) in the CloudWatch Logs User Guide.
        :param pulumi.Input[_builtins.str] application_arn: If you want to use an existing OpenSearch Service application for your integration with OpenSearch Service, specify it here. If you omit this, a new application will be created.
        :param pulumi.Input[_builtins.str] kms_key_arn: To have the vended dashboard data encrypted with AWS KMS instead of the CloudWatch Logs default encryption method, specify the ARN of the AWS KMS key that you want to use.
        :param pulumi.Input[_builtins.int] retention_days: Specify how many days that you want the data derived by OpenSearch Service to be retained in the index that the dashboard refers to. This also sets the maximum time period that you can choose when viewing data in the dashboard. Choosing a longer time frame will incur additional costs.
        """
        pulumi.set(__self__, "dashboard_viewer_principals", dashboard_viewer_principals)
        pulumi.set(__self__, "data_source_role_arn", data_source_role_arn)
        if application_arn is not None:
            pulumi.set(__self__, "application_arn", application_arn)
        if kms_key_arn is not None:
            pulumi.set(__self__, "kms_key_arn", kms_key_arn)
        if retention_days is not None:
            pulumi.set(__self__, "retention_days", retention_days)

    @_builtins.property
    @pulumi.getter(name="dashboardViewerPrincipals")
    def dashboard_viewer_principals(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Specify the ARNs of IAM roles and IAM users who you want to grant permission to for viewing the dashboards.

        > In addition to specifying these users here, you must also grant them the *CloudWatchOpenSearchDashboardAccess* IAM policy. For more information, see [IAM policies for users](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/OpenSearch-Dashboards-UserRoles.html) .
        """
        return pulumi.get(self, "dashboard_viewer_principals")

    @dashboard_viewer_principals.setter
    def dashboard_viewer_principals(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "dashboard_viewer_principals", value)

    @_builtins.property
    @pulumi.getter(name="dataSourceRoleArn")
    def data_source_role_arn(self) -> pulumi.Input[_builtins.str]:
        """
        Specify the ARN of an IAM role that CloudWatch Logs will use to create the integration. This role must have the permissions necessary to access the OpenSearch Service collection to be able to create the dashboards. For more information about the permissions needed, see [Permissions that the integration needs](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/OpenSearch-Dashboards-CreateRole.html) in the CloudWatch Logs User Guide.
        """
        return pulumi.get(self, "data_source_role_arn")

    @data_source_role_arn.setter
    def data_source_role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "data_source_role_arn", value)

    @_builtins.property
    @pulumi.getter(name="applicationArn")
    def application_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If you want to use an existing OpenSearch Service application for your integration with OpenSearch Service, specify it here. If you omit this, a new application will be created.
        """
        return pulumi.get(self, "application_arn")

    @application_arn.setter
    def application_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "application_arn", value)

    @_builtins.property
    @pulumi.getter(name="kmsKeyArn")
    def kms_key_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        To have the vended dashboard data encrypted with AWS KMS instead of the CloudWatch Logs default encryption method, specify the ARN of the AWS KMS key that you want to use.
        """
        return pulumi.get(self, "kms_key_arn")

    @kms_key_arn.setter
    def kms_key_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key_arn", value)

    @_builtins.property
    @pulumi.getter(name="retentionDays")
    def retention_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specify how many days that you want the data derived by OpenSearch Service to be retained in the index that the dashboard refers to. This also sets the maximum time period that you can choose when viewing data in the dashboard. Choosing a longer time frame will incur additional costs.
        """
        return pulumi.get(self, "retention_days")

    @retention_days.setter
    def retention_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "retention_days", value)


if not MYPY:
    class MetricFilterDimensionArgsDict(TypedDict):
        """
        Specifies the CW metric dimensions to publish with this metric.
          Because dimensions are part of the unique identifier for a metric, whenever a unique dimension name/value pair is extracted from your logs, you are creating a new variation of that metric.
         For more information about publishing dimensions with metrics created by metric filters, see [Publishing dimensions with metrics from values in JSON or space-delimited log events](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/FilterAndPatternSyntax.html#logs-metric-filters-dimensions).
          Metrics extracted from log events are charged as custom metrics. To prevent unexpected high charges, do not specify high-cardinality fields such as ``IPAddress`` or ``requestID`` as dimensions. Each different value found for a dimension is treated as a separate metric and accrues charges as a separate custom metric. 
         To help prevent accidental high charges, Amazon disables a metric filter if it generates 1000 different name/value pairs for the dimensions that you have specified within a certain amount of time.
         You can also set up a billing alarm to alert you if your charges are higher than expected. For more information, see [Creating a Billing Alarm to Monitor Your Estimated Charges](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/monitor_estimated_charges_with_cloudwatch.html).
        """
        key: pulumi.Input[_builtins.str]
        """
        The name for the CW metric dimension that the metric filter creates.
         Dimension names must contain only ASCII characters, must include at least one non-whitespace character, and cannot start with a colon (:).
        """
        value: pulumi.Input[_builtins.str]
        """
        The log event field that will contain the value for this dimension. This dimension will only be published for a metric if the value is found in the log event. For example, ``$.eventType`` for JSON log events, or ``$server`` for space-delimited log events.
        """
elif False:
    MetricFilterDimensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricFilterDimensionArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        Specifies the CW metric dimensions to publish with this metric.
          Because dimensions are part of the unique identifier for a metric, whenever a unique dimension name/value pair is extracted from your logs, you are creating a new variation of that metric.
         For more information about publishing dimensions with metrics created by metric filters, see [Publishing dimensions with metrics from values in JSON or space-delimited log events](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/FilterAndPatternSyntax.html#logs-metric-filters-dimensions).
          Metrics extracted from log events are charged as custom metrics. To prevent unexpected high charges, do not specify high-cardinality fields such as ``IPAddress`` or ``requestID`` as dimensions. Each different value found for a dimension is treated as a separate metric and accrues charges as a separate custom metric. 
         To help prevent accidental high charges, Amazon disables a metric filter if it generates 1000 different name/value pairs for the dimensions that you have specified within a certain amount of time.
         You can also set up a billing alarm to alert you if your charges are higher than expected. For more information, see [Creating a Billing Alarm to Monitor Your Estimated Charges](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/monitor_estimated_charges_with_cloudwatch.html).
        :param pulumi.Input[_builtins.str] key: The name for the CW metric dimension that the metric filter creates.
                Dimension names must contain only ASCII characters, must include at least one non-whitespace character, and cannot start with a colon (:).
        :param pulumi.Input[_builtins.str] value: The log event field that will contain the value for this dimension. This dimension will only be published for a metric if the value is found in the log event. For example, ``$.eventType`` for JSON log events, or ``$server`` for space-delimited log events.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The name for the CW metric dimension that the metric filter creates.
         Dimension names must contain only ASCII characters, must include at least one non-whitespace character, and cannot start with a colon (:).
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        The log event field that will contain the value for this dimension. This dimension will only be published for a metric if the value is found in the log event. For example, ``$.eventType`` for JSON log events, or ``$server`` for space-delimited log events.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class MetricFilterMetricTransformationArgsDict(TypedDict):
        """
        ``MetricTransformation`` is a property of the ``AWS::Logs::MetricFilter`` resource that describes how to transform log streams into a CloudWatch metric.
        """
        metric_name: pulumi.Input[_builtins.str]
        """
        The name of the CloudWatch metric.
        """
        metric_namespace: pulumi.Input[_builtins.str]
        """
        A custom namespace to contain your metric in CloudWatch. Use namespaces to group together metrics that are similar. For more information, see [Namespaces](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html#Namespace).
        """
        metric_value: pulumi.Input[_builtins.str]
        """
        The value that is published to the CloudWatch metric. For example, if you're counting the occurrences of a particular term like ``Error``, specify 1 for the metric value. If you're counting the number of bytes transferred, reference the value that is in the log event by using $. followed by the name of the field that you specified in the filter pattern, such as ``$.size``.
        """
        default_value: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Optional) The value to emit when a filter pattern does not match a log event. This value can be null.
        """
        dimensions: NotRequired[pulumi.Input[Sequence[pulumi.Input['MetricFilterDimensionArgsDict']]]]
        """
        The fields to use as dimensions for the metric. One metric filter can include as many as three dimensions.
          Metrics extracted from log events are charged as custom metrics. To prevent unexpected high charges, do not specify high-cardinality fields such as ``IPAddress`` or ``requestID`` as dimensions. Each different value found for a dimension is treated as a separate metric and accrues charges as a separate custom metric. 
         CloudWatch Logs disables a metric filter if it generates 1000 different name/value pairs for your specified dimensions within a certain amount of time. This helps to prevent accidental high charges.
         You can also set up a billing alarm to alert you if your charges are higher than expected. For more information, see [Creating a Billing Alarm to Monitor Your Estimated Charges](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/monitor_estimated_charges_with_cloudwatch.html).
        """
        unit: NotRequired[pulumi.Input['MetricFilterMetricTransformationUnit']]
        """
        The unit to assign to the metric. If you omit this, the unit is set as ``None``.
        """
elif False:
    MetricFilterMetricTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricFilterMetricTransformationArgs:
    def __init__(__self__, *,
                 metric_name: pulumi.Input[_builtins.str],
                 metric_namespace: pulumi.Input[_builtins.str],
                 metric_value: pulumi.Input[_builtins.str],
                 default_value: Optional[pulumi.Input[_builtins.float]] = None,
                 dimensions: Optional[pulumi.Input[Sequence[pulumi.Input['MetricFilterDimensionArgs']]]] = None,
                 unit: Optional[pulumi.Input['MetricFilterMetricTransformationUnit']] = None):
        """
        ``MetricTransformation`` is a property of the ``AWS::Logs::MetricFilter`` resource that describes how to transform log streams into a CloudWatch metric.
        :param pulumi.Input[_builtins.str] metric_name: The name of the CloudWatch metric.
        :param pulumi.Input[_builtins.str] metric_namespace: A custom namespace to contain your metric in CloudWatch. Use namespaces to group together metrics that are similar. For more information, see [Namespaces](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html#Namespace).
        :param pulumi.Input[_builtins.str] metric_value: The value that is published to the CloudWatch metric. For example, if you're counting the occurrences of a particular term like ``Error``, specify 1 for the metric value. If you're counting the number of bytes transferred, reference the value that is in the log event by using $. followed by the name of the field that you specified in the filter pattern, such as ``$.size``.
        :param pulumi.Input[_builtins.float] default_value: (Optional) The value to emit when a filter pattern does not match a log event. This value can be null.
        :param pulumi.Input[Sequence[pulumi.Input['MetricFilterDimensionArgs']]] dimensions: The fields to use as dimensions for the metric. One metric filter can include as many as three dimensions.
                 Metrics extracted from log events are charged as custom metrics. To prevent unexpected high charges, do not specify high-cardinality fields such as ``IPAddress`` or ``requestID`` as dimensions. Each different value found for a dimension is treated as a separate metric and accrues charges as a separate custom metric. 
                CloudWatch Logs disables a metric filter if it generates 1000 different name/value pairs for your specified dimensions within a certain amount of time. This helps to prevent accidental high charges.
                You can also set up a billing alarm to alert you if your charges are higher than expected. For more information, see [Creating a Billing Alarm to Monitor Your Estimated Charges](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/monitor_estimated_charges_with_cloudwatch.html).
        :param pulumi.Input['MetricFilterMetricTransformationUnit'] unit: The unit to assign to the metric. If you omit this, the unit is set as ``None``.
        """
        pulumi.set(__self__, "metric_name", metric_name)
        pulumi.set(__self__, "metric_namespace", metric_namespace)
        pulumi.set(__self__, "metric_value", metric_value)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if dimensions is not None:
            pulumi.set(__self__, "dimensions", dimensions)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @_builtins.property
    @pulumi.getter(name="metricName")
    def metric_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the CloudWatch metric.
        """
        return pulumi.get(self, "metric_name")

    @metric_name.setter
    def metric_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metric_name", value)

    @_builtins.property
    @pulumi.getter(name="metricNamespace")
    def metric_namespace(self) -> pulumi.Input[_builtins.str]:
        """
        A custom namespace to contain your metric in CloudWatch. Use namespaces to group together metrics that are similar. For more information, see [Namespaces](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/cloudwatch_concepts.html#Namespace).
        """
        return pulumi.get(self, "metric_namespace")

    @metric_namespace.setter
    def metric_namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metric_namespace", value)

    @_builtins.property
    @pulumi.getter(name="metricValue")
    def metric_value(self) -> pulumi.Input[_builtins.str]:
        """
        The value that is published to the CloudWatch metric. For example, if you're counting the occurrences of a particular term like ``Error``, specify 1 for the metric value. If you're counting the number of bytes transferred, reference the value that is in the log event by using $. followed by the name of the field that you specified in the filter pattern, such as ``$.size``.
        """
        return pulumi.get(self, "metric_value")

    @metric_value.setter
    def metric_value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "metric_value", value)

    @_builtins.property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Optional) The value to emit when a filter pattern does not match a log event. This value can be null.
        """
        return pulumi.get(self, "default_value")

    @default_value.setter
    def default_value(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "default_value", value)

    @_builtins.property
    @pulumi.getter
    def dimensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MetricFilterDimensionArgs']]]]:
        """
        The fields to use as dimensions for the metric. One metric filter can include as many as three dimensions.
          Metrics extracted from log events are charged as custom metrics. To prevent unexpected high charges, do not specify high-cardinality fields such as ``IPAddress`` or ``requestID`` as dimensions. Each different value found for a dimension is treated as a separate metric and accrues charges as a separate custom metric. 
         CloudWatch Logs disables a metric filter if it generates 1000 different name/value pairs for your specified dimensions within a certain amount of time. This helps to prevent accidental high charges.
         You can also set up a billing alarm to alert you if your charges are higher than expected. For more information, see [Creating a Billing Alarm to Monitor Your Estimated Charges](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/monitor_estimated_charges_with_cloudwatch.html).
        """
        return pulumi.get(self, "dimensions")

    @dimensions.setter
    def dimensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MetricFilterDimensionArgs']]]]):
        pulumi.set(self, "dimensions", value)

    @_builtins.property
    @pulumi.getter
    def unit(self) -> Optional[pulumi.Input['MetricFilterMetricTransformationUnit']]:
        """
        The unit to assign to the metric. If you omit this, the unit is set as ``None``.
        """
        return pulumi.get(self, "unit")

    @unit.setter
    def unit(self, value: Optional[pulumi.Input['MetricFilterMetricTransformationUnit']]):
        pulumi.set(self, "unit", value)


if not MYPY:
    class ResourceConfigPropertiesArgsDict(TypedDict):
        """
        OpenSearchResourceConfig for the given Integration
        """
        open_search_resource_config: NotRequired[pulumi.Input['IntegrationOpenSearchResourceConfigArgsDict']]
        """
        This structure contains configuration details about an integration between CloudWatch Logs and OpenSearch Service.
        """
elif False:
    ResourceConfigPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceConfigPropertiesArgs:
    def __init__(__self__, *,
                 open_search_resource_config: Optional[pulumi.Input['IntegrationOpenSearchResourceConfigArgs']] = None):
        """
        OpenSearchResourceConfig for the given Integration
        :param pulumi.Input['IntegrationOpenSearchResourceConfigArgs'] open_search_resource_config: This structure contains configuration details about an integration between CloudWatch Logs and OpenSearch Service.
        """
        if open_search_resource_config is not None:
            pulumi.set(__self__, "open_search_resource_config", open_search_resource_config)

    @_builtins.property
    @pulumi.getter(name="openSearchResourceConfig")
    def open_search_resource_config(self) -> Optional[pulumi.Input['IntegrationOpenSearchResourceConfigArgs']]:
        """
        This structure contains configuration details about an integration between CloudWatch Logs and OpenSearch Service.
        """
        return pulumi.get(self, "open_search_resource_config")

    @open_search_resource_config.setter
    def open_search_resource_config(self, value: Optional[pulumi.Input['IntegrationOpenSearchResourceConfigArgs']]):
        pulumi.set(self, "open_search_resource_config", value)


if not MYPY:
    class TransformerAddKeyEntryArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The key of the new entry to be added to the log event
        """
        value: pulumi.Input[_builtins.str]
        """
        The value of the new entry to be added to the log event
        """
        overwrite_if_exists: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies whether to overwrite the value if the key already exists in the log event. If you omit this, the default is `false` .
        """
elif False:
    TransformerAddKeyEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerAddKeyEntryArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str],
                 overwrite_if_exists: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The key of the new entry to be added to the log event
        :param pulumi.Input[_builtins.str] value: The value of the new entry to be added to the log event
        :param pulumi.Input[_builtins.bool] overwrite_if_exists: Specifies whether to overwrite the value if the key already exists in the log event. If you omit this, the default is `false` .
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if overwrite_if_exists is not None:
            pulumi.set(__self__, "overwrite_if_exists", overwrite_if_exists)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The key of the new entry to be added to the log event
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        The value of the new entry to be added to the log event
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter(name="overwriteIfExists")
    def overwrite_if_exists(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies whether to overwrite the value if the key already exists in the log event. If you omit this, the default is `false` .
        """
        return pulumi.get(self, "overwrite_if_exists")

    @overwrite_if_exists.setter
    def overwrite_if_exists(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "overwrite_if_exists", value)


if not MYPY:
    class TransformerCopyValueEntryArgsDict(TypedDict):
        source: pulumi.Input[_builtins.str]
        target: pulumi.Input[_builtins.str]
        overwrite_if_exists: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    TransformerCopyValueEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerCopyValueEntryArgs:
    def __init__(__self__, *,
                 source: pulumi.Input[_builtins.str],
                 target: pulumi.Input[_builtins.str],
                 overwrite_if_exists: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "target", target)
        if overwrite_if_exists is not None:
            pulumi.set(__self__, "overwrite_if_exists", overwrite_if_exists)

    @_builtins.property
    @pulumi.getter
    def source(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target", value)

    @_builtins.property
    @pulumi.getter(name="overwriteIfExists")
    def overwrite_if_exists(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "overwrite_if_exists")

    @overwrite_if_exists.setter
    def overwrite_if_exists(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "overwrite_if_exists", value)


if not MYPY:
    class TransformerMoveKeyEntryArgsDict(TypedDict):
        source: pulumi.Input[_builtins.str]
        target: pulumi.Input[_builtins.str]
        overwrite_if_exists: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    TransformerMoveKeyEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerMoveKeyEntryArgs:
    def __init__(__self__, *,
                 source: pulumi.Input[_builtins.str],
                 target: pulumi.Input[_builtins.str],
                 overwrite_if_exists: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "target", target)
        if overwrite_if_exists is not None:
            pulumi.set(__self__, "overwrite_if_exists", overwrite_if_exists)

    @_builtins.property
    @pulumi.getter
    def source(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target", value)

    @_builtins.property
    @pulumi.getter(name="overwriteIfExists")
    def overwrite_if_exists(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "overwrite_if_exists")

    @overwrite_if_exists.setter
    def overwrite_if_exists(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "overwrite_if_exists", value)


if not MYPY:
    class TransformerParseCloudfrontArgsDict(TypedDict):
        source: NotRequired[pulumi.Input[_builtins.str]]
        """
        Omit this parameter and the whole log message will be processed by this processor. No other value than `@message` is allowed for `source` .
        """
elif False:
    TransformerParseCloudfrontArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerParseCloudfrontArgs:
    def __init__(__self__, *,
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] source: Omit this parameter and the whole log message will be processed by this processor. No other value than `@message` is allowed for `source` .
        """
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Omit this parameter and the whole log message will be processed by this processor. No other value than `@message` is allowed for `source` .
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class TransformerParsePostgresArgsDict(TypedDict):
        source: NotRequired[pulumi.Input[_builtins.str]]
        """
        Omit this parameter and the whole log message will be processed by this processor. No other value than `@message` is allowed for `source` .
        """
elif False:
    TransformerParsePostgresArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerParsePostgresArgs:
    def __init__(__self__, *,
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] source: Omit this parameter and the whole log message will be processed by this processor. No other value than `@message` is allowed for `source` .
        """
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Omit this parameter and the whole log message will be processed by this processor. No other value than `@message` is allowed for `source` .
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class TransformerParseRoute53ArgsDict(TypedDict):
        source: NotRequired[pulumi.Input[_builtins.str]]
        """
        Omit this parameter and the whole log message will be processed by this processor. No other value than `@message` is allowed for `source` .
        """
elif False:
    TransformerParseRoute53ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerParseRoute53Args:
    def __init__(__self__, *,
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] source: Omit this parameter and the whole log message will be processed by this processor. No other value than `@message` is allowed for `source` .
        """
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Omit this parameter and the whole log message will be processed by this processor. No other value than `@message` is allowed for `source` .
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class TransformerParseToOcsfArgsDict(TypedDict):
        event_source: pulumi.Input['TransformerEventSource']
        """
        Specify the service or process that produces the log events that will be converted with this processor.
        """
        ocsf_version: pulumi.Input['TransformerOcsfVersion']
        """
        Specify which version of the OCSF schema to use for the transformed log events.
        """
        source: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path to the field in the log event that you want to parse. If you omit this value, the whole log message is parsed.
        """
elif False:
    TransformerParseToOcsfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerParseToOcsfArgs:
    def __init__(__self__, *,
                 event_source: pulumi.Input['TransformerEventSource'],
                 ocsf_version: pulumi.Input['TransformerOcsfVersion'],
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['TransformerEventSource'] event_source: Specify the service or process that produces the log events that will be converted with this processor.
        :param pulumi.Input['TransformerOcsfVersion'] ocsf_version: Specify which version of the OCSF schema to use for the transformed log events.
        :param pulumi.Input[_builtins.str] source: The path to the field in the log event that you want to parse. If you omit this value, the whole log message is parsed.
        """
        pulumi.set(__self__, "event_source", event_source)
        pulumi.set(__self__, "ocsf_version", ocsf_version)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter(name="eventSource")
    def event_source(self) -> pulumi.Input['TransformerEventSource']:
        """
        Specify the service or process that produces the log events that will be converted with this processor.
        """
        return pulumi.get(self, "event_source")

    @event_source.setter
    def event_source(self, value: pulumi.Input['TransformerEventSource']):
        pulumi.set(self, "event_source", value)

    @_builtins.property
    @pulumi.getter(name="ocsfVersion")
    def ocsf_version(self) -> pulumi.Input['TransformerOcsfVersion']:
        """
        Specify which version of the OCSF schema to use for the transformed log events.
        """
        return pulumi.get(self, "ocsf_version")

    @ocsf_version.setter
    def ocsf_version(self, value: pulumi.Input['TransformerOcsfVersion']):
        pulumi.set(self, "ocsf_version", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path to the field in the log event that you want to parse. If you omit this value, the whole log message is parsed.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class TransformerParseVpcArgsDict(TypedDict):
        source: NotRequired[pulumi.Input[_builtins.str]]
        """
        Omit this parameter and the whole log message will be processed by this processor. No other value than `@message` is allowed for `source` .
        """
elif False:
    TransformerParseVpcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerParseVpcArgs:
    def __init__(__self__, *,
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] source: Omit this parameter and the whole log message will be processed by this processor. No other value than `@message` is allowed for `source` .
        """
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Omit this parameter and the whole log message will be processed by this processor. No other value than `@message` is allowed for `source` .
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class TransformerParseWafArgsDict(TypedDict):
        source: NotRequired[pulumi.Input[_builtins.str]]
        """
        Omit this parameter and the whole log message will be processed by this processor. No other value than `@message` is allowed for `source` .
        """
elif False:
    TransformerParseWafArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerParseWafArgs:
    def __init__(__self__, *,
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] source: Omit this parameter and the whole log message will be processed by this processor. No other value than `@message` is allowed for `source` .
        """
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Omit this parameter and the whole log message will be processed by this processor. No other value than `@message` is allowed for `source` .
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class TransformerProcessorAddKeysPropertiesArgsDict(TypedDict):
        """
        Use this parameter to include the [addKeys](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation.html#CloudWatch-Logs-Transformation-addKeys) processor in your transformer.
        """
        entries: pulumi.Input[Sequence[pulumi.Input['TransformerAddKeyEntryArgsDict']]]
elif False:
    TransformerProcessorAddKeysPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerProcessorAddKeysPropertiesArgs:
    def __init__(__self__, *,
                 entries: pulumi.Input[Sequence[pulumi.Input['TransformerAddKeyEntryArgs']]]):
        """
        Use this parameter to include the [addKeys](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation.html#CloudWatch-Logs-Transformation-addKeys) processor in your transformer.
        """
        pulumi.set(__self__, "entries", entries)

    @_builtins.property
    @pulumi.getter
    def entries(self) -> pulumi.Input[Sequence[pulumi.Input['TransformerAddKeyEntryArgs']]]:
        return pulumi.get(self, "entries")

    @entries.setter
    def entries(self, value: pulumi.Input[Sequence[pulumi.Input['TransformerAddKeyEntryArgs']]]):
        pulumi.set(self, "entries", value)


if not MYPY:
    class TransformerProcessorCopyValuePropertiesArgsDict(TypedDict):
        """
        Use this parameter to include the [copyValue](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-copyValue) processor in your transformer.
        """
        entries: pulumi.Input[Sequence[pulumi.Input['TransformerCopyValueEntryArgsDict']]]
elif False:
    TransformerProcessorCopyValuePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerProcessorCopyValuePropertiesArgs:
    def __init__(__self__, *,
                 entries: pulumi.Input[Sequence[pulumi.Input['TransformerCopyValueEntryArgs']]]):
        """
        Use this parameter to include the [copyValue](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-copyValue) processor in your transformer.
        """
        pulumi.set(__self__, "entries", entries)

    @_builtins.property
    @pulumi.getter
    def entries(self) -> pulumi.Input[Sequence[pulumi.Input['TransformerCopyValueEntryArgs']]]:
        return pulumi.get(self, "entries")

    @entries.setter
    def entries(self, value: pulumi.Input[Sequence[pulumi.Input['TransformerCopyValueEntryArgs']]]):
        pulumi.set(self, "entries", value)


if not MYPY:
    class TransformerProcessorCsvPropertiesArgsDict(TypedDict):
        """
        Use this parameter to include the [CSV](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation.html#CloudWatch-Logs-Transformation-CSV) processor in your transformer.
        """
        columns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        delimiter: NotRequired[pulumi.Input[_builtins.str]]
        quote_character: NotRequired[pulumi.Input[_builtins.str]]
        source: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TransformerProcessorCsvPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerProcessorCsvPropertiesArgs:
    def __init__(__self__, *,
                 columns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 delimiter: Optional[pulumi.Input[_builtins.str]] = None,
                 quote_character: Optional[pulumi.Input[_builtins.str]] = None,
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Use this parameter to include the [CSV](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation.html#CloudWatch-Logs-Transformation-CSV) processor in your transformer.
        """
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if quote_character is not None:
            pulumi.set(__self__, "quote_character", quote_character)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "columns", value)

    @_builtins.property
    @pulumi.getter
    def delimiter(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delimiter", value)

    @_builtins.property
    @pulumi.getter(name="quoteCharacter")
    def quote_character(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "quote_character")

    @quote_character.setter
    def quote_character(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "quote_character", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class TransformerProcessorDateTimeConverterPropertiesArgsDict(TypedDict):
        """
        Use this parameter to include the [datetimeConverter](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-datetimeConverter) processor in your transformer.
        """
        match_patterns: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        source: pulumi.Input[_builtins.str]
        target: pulumi.Input[_builtins.str]
        locale: NotRequired[pulumi.Input[_builtins.str]]
        source_timezone: NotRequired[pulumi.Input[_builtins.str]]
        target_format: NotRequired[pulumi.Input[_builtins.str]]
        target_timezone: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TransformerProcessorDateTimeConverterPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerProcessorDateTimeConverterPropertiesArgs:
    def __init__(__self__, *,
                 match_patterns: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 source: pulumi.Input[_builtins.str],
                 target: pulumi.Input[_builtins.str],
                 locale: Optional[pulumi.Input[_builtins.str]] = None,
                 source_timezone: Optional[pulumi.Input[_builtins.str]] = None,
                 target_format: Optional[pulumi.Input[_builtins.str]] = None,
                 target_timezone: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Use this parameter to include the [datetimeConverter](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-datetimeConverter) processor in your transformer.
        """
        pulumi.set(__self__, "match_patterns", match_patterns)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "target", target)
        if locale is not None:
            pulumi.set(__self__, "locale", locale)
        if source_timezone is not None:
            pulumi.set(__self__, "source_timezone", source_timezone)
        if target_format is not None:
            pulumi.set(__self__, "target_format", target_format)
        if target_timezone is not None:
            pulumi.set(__self__, "target_timezone", target_timezone)

    @_builtins.property
    @pulumi.getter(name="matchPatterns")
    def match_patterns(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "match_patterns")

    @match_patterns.setter
    def match_patterns(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "match_patterns", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target", value)

    @_builtins.property
    @pulumi.getter
    def locale(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "locale")

    @locale.setter
    def locale(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "locale", value)

    @_builtins.property
    @pulumi.getter(name="sourceTimezone")
    def source_timezone(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "source_timezone")

    @source_timezone.setter
    def source_timezone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_timezone", value)

    @_builtins.property
    @pulumi.getter(name="targetFormat")
    def target_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "target_format")

    @target_format.setter
    def target_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_format", value)

    @_builtins.property
    @pulumi.getter(name="targetTimezone")
    def target_timezone(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "target_timezone")

    @target_timezone.setter
    def target_timezone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_timezone", value)


if not MYPY:
    class TransformerProcessorDeleteKeysPropertiesArgsDict(TypedDict):
        """
        Use this parameter to include the [deleteKeys](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation.html#CloudWatch-Logs-Transformation-deleteKeys) processor in your transformer.
        """
        with_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    TransformerProcessorDeleteKeysPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerProcessorDeleteKeysPropertiesArgs:
    def __init__(__self__, *,
                 with_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        Use this parameter to include the [deleteKeys](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation.html#CloudWatch-Logs-Transformation-deleteKeys) processor in your transformer.
        """
        pulumi.set(__self__, "with_keys", with_keys)

    @_builtins.property
    @pulumi.getter(name="withKeys")
    def with_keys(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "with_keys")

    @with_keys.setter
    def with_keys(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "with_keys", value)


if not MYPY:
    class TransformerProcessorGrokPropertiesArgsDict(TypedDict):
        """
        Use this parameter to include the [grok](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-grok) processor in your transformer.
        """
        match: pulumi.Input[_builtins.str]
        source: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TransformerProcessorGrokPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerProcessorGrokPropertiesArgs:
    def __init__(__self__, *,
                 match: pulumi.Input[_builtins.str],
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Use this parameter to include the [grok](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-grok) processor in your transformer.
        """
        pulumi.set(__self__, "match", match)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def match(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class TransformerProcessorListToMapPropertiesArgsDict(TypedDict):
        """
        Use this parameter to include the [listToMap](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation.html#CloudWatch-Logs-Transformation-listToMap) processor in your transformer.
        """
        key: pulumi.Input[_builtins.str]
        source: pulumi.Input[_builtins.str]
        flatten: NotRequired[pulumi.Input[_builtins.bool]]
        flattened_element: NotRequired[pulumi.Input['TransformerProcessorListToMapPropertiesFlattenedElement']]
        target: NotRequired[pulumi.Input[_builtins.str]]
        value_key: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TransformerProcessorListToMapPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerProcessorListToMapPropertiesArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 source: pulumi.Input[_builtins.str],
                 flatten: Optional[pulumi.Input[_builtins.bool]] = None,
                 flattened_element: Optional[pulumi.Input['TransformerProcessorListToMapPropertiesFlattenedElement']] = None,
                 target: Optional[pulumi.Input[_builtins.str]] = None,
                 value_key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Use this parameter to include the [listToMap](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation.html#CloudWatch-Logs-Transformation-listToMap) processor in your transformer.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "source", source)
        if flatten is not None:
            pulumi.set(__self__, "flatten", flatten)
        if flattened_element is not None:
            pulumi.set(__self__, "flattened_element", flattened_element)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if value_key is not None:
            pulumi.set(__self__, "value_key", value_key)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter
    def flatten(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "flatten")

    @flatten.setter
    def flatten(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "flatten", value)

    @_builtins.property
    @pulumi.getter(name="flattenedElement")
    def flattened_element(self) -> Optional[pulumi.Input['TransformerProcessorListToMapPropertiesFlattenedElement']]:
        return pulumi.get(self, "flattened_element")

    @flattened_element.setter
    def flattened_element(self, value: Optional[pulumi.Input['TransformerProcessorListToMapPropertiesFlattenedElement']]):
        pulumi.set(self, "flattened_element", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target", value)

    @_builtins.property
    @pulumi.getter(name="valueKey")
    def value_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value_key")

    @value_key.setter
    def value_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value_key", value)


if not MYPY:
    class TransformerProcessorLowerCaseStringPropertiesArgsDict(TypedDict):
        """
        Use this parameter to include the [lowerCaseString](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-lowerCaseString) processor in your transformer.
        """
        with_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    TransformerProcessorLowerCaseStringPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerProcessorLowerCaseStringPropertiesArgs:
    def __init__(__self__, *,
                 with_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        Use this parameter to include the [lowerCaseString](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-lowerCaseString) processor in your transformer.
        """
        pulumi.set(__self__, "with_keys", with_keys)

    @_builtins.property
    @pulumi.getter(name="withKeys")
    def with_keys(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "with_keys")

    @with_keys.setter
    def with_keys(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "with_keys", value)


if not MYPY:
    class TransformerProcessorMoveKeysPropertiesArgsDict(TypedDict):
        """
        Use this parameter to include the [moveKeys](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-moveKeys) processor in your transformer.
        """
        entries: pulumi.Input[Sequence[pulumi.Input['TransformerMoveKeyEntryArgsDict']]]
elif False:
    TransformerProcessorMoveKeysPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerProcessorMoveKeysPropertiesArgs:
    def __init__(__self__, *,
                 entries: pulumi.Input[Sequence[pulumi.Input['TransformerMoveKeyEntryArgs']]]):
        """
        Use this parameter to include the [moveKeys](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-moveKeys) processor in your transformer.
        """
        pulumi.set(__self__, "entries", entries)

    @_builtins.property
    @pulumi.getter
    def entries(self) -> pulumi.Input[Sequence[pulumi.Input['TransformerMoveKeyEntryArgs']]]:
        return pulumi.get(self, "entries")

    @entries.setter
    def entries(self, value: pulumi.Input[Sequence[pulumi.Input['TransformerMoveKeyEntryArgs']]]):
        pulumi.set(self, "entries", value)


if not MYPY:
    class TransformerProcessorParseJsonPropertiesArgsDict(TypedDict):
        """
        Use this parameter to include the [parseJSON](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-parseJSON) processor in your transformer.
        """
        destination: NotRequired[pulumi.Input[_builtins.str]]
        source: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TransformerProcessorParseJsonPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerProcessorParseJsonPropertiesArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[_builtins.str]] = None,
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Use this parameter to include the [parseJSON](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-parseJSON) processor in your transformer.
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class TransformerProcessorParseKeyValuePropertiesArgsDict(TypedDict):
        """
        Use this parameter to include the [parseKeyValue](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-parseKeyValue) processor in your transformer.
        """
        destination: NotRequired[pulumi.Input[_builtins.str]]
        field_delimiter: NotRequired[pulumi.Input[_builtins.str]]
        key_prefix: NotRequired[pulumi.Input[_builtins.str]]
        key_value_delimiter: NotRequired[pulumi.Input[_builtins.str]]
        non_match_value: NotRequired[pulumi.Input[_builtins.str]]
        overwrite_if_exists: NotRequired[pulumi.Input[_builtins.bool]]
        source: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    TransformerProcessorParseKeyValuePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerProcessorParseKeyValuePropertiesArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input[_builtins.str]] = None,
                 field_delimiter: Optional[pulumi.Input[_builtins.str]] = None,
                 key_prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 key_value_delimiter: Optional[pulumi.Input[_builtins.str]] = None,
                 non_match_value: Optional[pulumi.Input[_builtins.str]] = None,
                 overwrite_if_exists: Optional[pulumi.Input[_builtins.bool]] = None,
                 source: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Use this parameter to include the [parseKeyValue](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-parseKeyValue) processor in your transformer.
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if field_delimiter is not None:
            pulumi.set(__self__, "field_delimiter", field_delimiter)
        if key_prefix is not None:
            pulumi.set(__self__, "key_prefix", key_prefix)
        if key_value_delimiter is not None:
            pulumi.set(__self__, "key_value_delimiter", key_value_delimiter)
        if non_match_value is not None:
            pulumi.set(__self__, "non_match_value", non_match_value)
        if overwrite_if_exists is not None:
            pulumi.set(__self__, "overwrite_if_exists", overwrite_if_exists)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter(name="fieldDelimiter")
    def field_delimiter(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "field_delimiter")

    @field_delimiter.setter
    def field_delimiter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "field_delimiter", value)

    @_builtins.property
    @pulumi.getter(name="keyPrefix")
    def key_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key_prefix")

    @key_prefix.setter
    def key_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_prefix", value)

    @_builtins.property
    @pulumi.getter(name="keyValueDelimiter")
    def key_value_delimiter(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key_value_delimiter")

    @key_value_delimiter.setter
    def key_value_delimiter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_value_delimiter", value)

    @_builtins.property
    @pulumi.getter(name="nonMatchValue")
    def non_match_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "non_match_value")

    @non_match_value.setter
    def non_match_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "non_match_value", value)

    @_builtins.property
    @pulumi.getter(name="overwriteIfExists")
    def overwrite_if_exists(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "overwrite_if_exists")

    @overwrite_if_exists.setter
    def overwrite_if_exists(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "overwrite_if_exists", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)


if not MYPY:
    class TransformerProcessorRenameKeysPropertiesArgsDict(TypedDict):
        """
        Use this parameter to include the [renameKeys](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation.html#CloudWatch-Logs-Transformation-renameKeys) processor in your transformer.
        """
        entries: pulumi.Input[Sequence[pulumi.Input['TransformerRenameKeyEntryArgsDict']]]
elif False:
    TransformerProcessorRenameKeysPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerProcessorRenameKeysPropertiesArgs:
    def __init__(__self__, *,
                 entries: pulumi.Input[Sequence[pulumi.Input['TransformerRenameKeyEntryArgs']]]):
        """
        Use this parameter to include the [renameKeys](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation.html#CloudWatch-Logs-Transformation-renameKeys) processor in your transformer.
        """
        pulumi.set(__self__, "entries", entries)

    @_builtins.property
    @pulumi.getter
    def entries(self) -> pulumi.Input[Sequence[pulumi.Input['TransformerRenameKeyEntryArgs']]]:
        return pulumi.get(self, "entries")

    @entries.setter
    def entries(self, value: pulumi.Input[Sequence[pulumi.Input['TransformerRenameKeyEntryArgs']]]):
        pulumi.set(self, "entries", value)


if not MYPY:
    class TransformerProcessorSplitStringPropertiesArgsDict(TypedDict):
        """
        Use this parameter to include the [splitString](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-splitString) processor in your transformer.
        """
        entries: pulumi.Input[Sequence[pulumi.Input['TransformerSplitStringEntryArgsDict']]]
elif False:
    TransformerProcessorSplitStringPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerProcessorSplitStringPropertiesArgs:
    def __init__(__self__, *,
                 entries: pulumi.Input[Sequence[pulumi.Input['TransformerSplitStringEntryArgs']]]):
        """
        Use this parameter to include the [splitString](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-splitString) processor in your transformer.
        """
        pulumi.set(__self__, "entries", entries)

    @_builtins.property
    @pulumi.getter
    def entries(self) -> pulumi.Input[Sequence[pulumi.Input['TransformerSplitStringEntryArgs']]]:
        return pulumi.get(self, "entries")

    @entries.setter
    def entries(self, value: pulumi.Input[Sequence[pulumi.Input['TransformerSplitStringEntryArgs']]]):
        pulumi.set(self, "entries", value)


if not MYPY:
    class TransformerProcessorSubstituteStringPropertiesArgsDict(TypedDict):
        """
        Use this parameter to include the [substituteString](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-substituteString) processor in your transformer.
        """
        entries: pulumi.Input[Sequence[pulumi.Input['TransformerSubstituteStringEntryArgsDict']]]
elif False:
    TransformerProcessorSubstituteStringPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerProcessorSubstituteStringPropertiesArgs:
    def __init__(__self__, *,
                 entries: pulumi.Input[Sequence[pulumi.Input['TransformerSubstituteStringEntryArgs']]]):
        """
        Use this parameter to include the [substituteString](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-substituteString) processor in your transformer.
        """
        pulumi.set(__self__, "entries", entries)

    @_builtins.property
    @pulumi.getter
    def entries(self) -> pulumi.Input[Sequence[pulumi.Input['TransformerSubstituteStringEntryArgs']]]:
        return pulumi.get(self, "entries")

    @entries.setter
    def entries(self, value: pulumi.Input[Sequence[pulumi.Input['TransformerSubstituteStringEntryArgs']]]):
        pulumi.set(self, "entries", value)


if not MYPY:
    class TransformerProcessorTrimStringPropertiesArgsDict(TypedDict):
        """
        Use this parameter to include the [trimString](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-trimString) processor in your transformer.
        """
        with_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    TransformerProcessorTrimStringPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerProcessorTrimStringPropertiesArgs:
    def __init__(__self__, *,
                 with_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        Use this parameter to include the [trimString](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-trimString) processor in your transformer.
        """
        pulumi.set(__self__, "with_keys", with_keys)

    @_builtins.property
    @pulumi.getter(name="withKeys")
    def with_keys(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "with_keys")

    @with_keys.setter
    def with_keys(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "with_keys", value)


if not MYPY:
    class TransformerProcessorTypeConverterPropertiesArgsDict(TypedDict):
        """
        Use this parameter to include the [typeConverter](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-typeConverter) processor in your transformer.
        """
        entries: pulumi.Input[Sequence[pulumi.Input['TransformerTypeConverterEntryArgsDict']]]
elif False:
    TransformerProcessorTypeConverterPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerProcessorTypeConverterPropertiesArgs:
    def __init__(__self__, *,
                 entries: pulumi.Input[Sequence[pulumi.Input['TransformerTypeConverterEntryArgs']]]):
        """
        Use this parameter to include the [typeConverter](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-typeConverter) processor in your transformer.
        """
        pulumi.set(__self__, "entries", entries)

    @_builtins.property
    @pulumi.getter
    def entries(self) -> pulumi.Input[Sequence[pulumi.Input['TransformerTypeConverterEntryArgs']]]:
        return pulumi.get(self, "entries")

    @entries.setter
    def entries(self, value: pulumi.Input[Sequence[pulumi.Input['TransformerTypeConverterEntryArgs']]]):
        pulumi.set(self, "entries", value)


if not MYPY:
    class TransformerProcessorUpperCaseStringPropertiesArgsDict(TypedDict):
        """
        Use this parameter to include the [upperCaseString](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-upperCaseString) processor in your transformer.
        """
        with_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    TransformerProcessorUpperCaseStringPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerProcessorUpperCaseStringPropertiesArgs:
    def __init__(__self__, *,
                 with_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        Use this parameter to include the [upperCaseString](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-upperCaseString) processor in your transformer.
        """
        pulumi.set(__self__, "with_keys", with_keys)

    @_builtins.property
    @pulumi.getter(name="withKeys")
    def with_keys(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "with_keys")

    @with_keys.setter
    def with_keys(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "with_keys", value)


if not MYPY:
    class TransformerProcessorArgsDict(TypedDict):
        """
        Individual processor configuration
        """
        add_keys: NotRequired[pulumi.Input['TransformerProcessorAddKeysPropertiesArgsDict']]
        """
        Use this parameter to include the [addKeys](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation.html#CloudWatch-Logs-Transformation-addKeys) processor in your transformer.
        """
        copy_value: NotRequired[pulumi.Input['TransformerProcessorCopyValuePropertiesArgsDict']]
        """
        Use this parameter to include the [copyValue](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-copyValue) processor in your transformer.
        """
        csv: NotRequired[pulumi.Input['TransformerProcessorCsvPropertiesArgsDict']]
        """
        Use this parameter to include the [CSV](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation.html#CloudWatch-Logs-Transformation-CSV) processor in your transformer.
        """
        date_time_converter: NotRequired[pulumi.Input['TransformerProcessorDateTimeConverterPropertiesArgsDict']]
        """
        Use this parameter to include the [datetimeConverter](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-datetimeConverter) processor in your transformer.
        """
        delete_keys: NotRequired[pulumi.Input['TransformerProcessorDeleteKeysPropertiesArgsDict']]
        """
        Use this parameter to include the [deleteKeys](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation.html#CloudWatch-Logs-Transformation-deleteKeys) processor in your transformer.
        """
        grok: NotRequired[pulumi.Input['TransformerProcessorGrokPropertiesArgsDict']]
        """
        Use this parameter to include the [grok](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-grok) processor in your transformer.
        """
        list_to_map: NotRequired[pulumi.Input['TransformerProcessorListToMapPropertiesArgsDict']]
        """
        Use this parameter to include the [listToMap](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation.html#CloudWatch-Logs-Transformation-listToMap) processor in your transformer.
        """
        lower_case_string: NotRequired[pulumi.Input['TransformerProcessorLowerCaseStringPropertiesArgsDict']]
        """
        Use this parameter to include the [lowerCaseString](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-lowerCaseString) processor in your transformer.
        """
        move_keys: NotRequired[pulumi.Input['TransformerProcessorMoveKeysPropertiesArgsDict']]
        """
        Use this parameter to include the [moveKeys](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-moveKeys) processor in your transformer.
        """
        parse_cloudfront: NotRequired[pulumi.Input['TransformerParseCloudfrontArgsDict']]
        """
        Use this parameter to include the [parseCloudfront](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-parseCloudfront) processor in your transformer.

        If you use this processor, it must be the first processor in your transformer.
        """
        parse_json: NotRequired[pulumi.Input['TransformerProcessorParseJsonPropertiesArgsDict']]
        """
        Use this parameter to include the [parseJSON](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-parseJSON) processor in your transformer.
        """
        parse_key_value: NotRequired[pulumi.Input['TransformerProcessorParseKeyValuePropertiesArgsDict']]
        """
        Use this parameter to include the [parseKeyValue](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-parseKeyValue) processor in your transformer.
        """
        parse_postgres: NotRequired[pulumi.Input['TransformerParsePostgresArgsDict']]
        """
        Use this parameter to include the [parsePostGres](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation.html#CloudWatch-Logs-Transformation-parsePostGres) processor in your transformer.

        If you use this processor, it must be the first processor in your transformer.
        """
        parse_route53: NotRequired[pulumi.Input['TransformerParseRoute53ArgsDict']]
        """
        Use this parameter to include the [parseRoute53](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-parseRoute53) processor in your transformer.

        If you use this processor, it must be the first processor in your transformer.
        """
        parse_to_ocsf: NotRequired[pulumi.Input['TransformerParseToOcsfArgsDict']]
        """
        Use this parameter to convert logs into Open Cybersecurity Schema (OCSF) format.
        """
        parse_vpc: NotRequired[pulumi.Input['TransformerParseVpcArgsDict']]
        """
        Use this parameter to include the [parseVPC](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-parseVPC) processor in your transformer.

        If you use this processor, it must be the first processor in your transformer.
        """
        parse_waf: NotRequired[pulumi.Input['TransformerParseWafArgsDict']]
        """
        Use this parameter to include the [parseWAF](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation.html#CloudWatch-Logs-Transformation-parseWAF) processor in your transformer.

        If you use this processor, it must be the first processor in your transformer.
        """
        rename_keys: NotRequired[pulumi.Input['TransformerProcessorRenameKeysPropertiesArgsDict']]
        """
        Use this parameter to include the [renameKeys](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation.html#CloudWatch-Logs-Transformation-renameKeys) processor in your transformer.
        """
        split_string: NotRequired[pulumi.Input['TransformerProcessorSplitStringPropertiesArgsDict']]
        """
        Use this parameter to include the [splitString](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-splitString) processor in your transformer.
        """
        substitute_string: NotRequired[pulumi.Input['TransformerProcessorSubstituteStringPropertiesArgsDict']]
        """
        Use this parameter to include the [substituteString](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-substituteString) processor in your transformer.
        """
        trim_string: NotRequired[pulumi.Input['TransformerProcessorTrimStringPropertiesArgsDict']]
        """
        Use this parameter to include the [trimString](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-trimString) processor in your transformer.
        """
        type_converter: NotRequired[pulumi.Input['TransformerProcessorTypeConverterPropertiesArgsDict']]
        """
        Use this parameter to include the [typeConverter](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-typeConverter) processor in your transformer.
        """
        upper_case_string: NotRequired[pulumi.Input['TransformerProcessorUpperCaseStringPropertiesArgsDict']]
        """
        Use this parameter to include the [upperCaseString](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-upperCaseString) processor in your transformer.
        """
elif False:
    TransformerProcessorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerProcessorArgs:
    def __init__(__self__, *,
                 add_keys: Optional[pulumi.Input['TransformerProcessorAddKeysPropertiesArgs']] = None,
                 copy_value: Optional[pulumi.Input['TransformerProcessorCopyValuePropertiesArgs']] = None,
                 csv: Optional[pulumi.Input['TransformerProcessorCsvPropertiesArgs']] = None,
                 date_time_converter: Optional[pulumi.Input['TransformerProcessorDateTimeConverterPropertiesArgs']] = None,
                 delete_keys: Optional[pulumi.Input['TransformerProcessorDeleteKeysPropertiesArgs']] = None,
                 grok: Optional[pulumi.Input['TransformerProcessorGrokPropertiesArgs']] = None,
                 list_to_map: Optional[pulumi.Input['TransformerProcessorListToMapPropertiesArgs']] = None,
                 lower_case_string: Optional[pulumi.Input['TransformerProcessorLowerCaseStringPropertiesArgs']] = None,
                 move_keys: Optional[pulumi.Input['TransformerProcessorMoveKeysPropertiesArgs']] = None,
                 parse_cloudfront: Optional[pulumi.Input['TransformerParseCloudfrontArgs']] = None,
                 parse_json: Optional[pulumi.Input['TransformerProcessorParseJsonPropertiesArgs']] = None,
                 parse_key_value: Optional[pulumi.Input['TransformerProcessorParseKeyValuePropertiesArgs']] = None,
                 parse_postgres: Optional[pulumi.Input['TransformerParsePostgresArgs']] = None,
                 parse_route53: Optional[pulumi.Input['TransformerParseRoute53Args']] = None,
                 parse_to_ocsf: Optional[pulumi.Input['TransformerParseToOcsfArgs']] = None,
                 parse_vpc: Optional[pulumi.Input['TransformerParseVpcArgs']] = None,
                 parse_waf: Optional[pulumi.Input['TransformerParseWafArgs']] = None,
                 rename_keys: Optional[pulumi.Input['TransformerProcessorRenameKeysPropertiesArgs']] = None,
                 split_string: Optional[pulumi.Input['TransformerProcessorSplitStringPropertiesArgs']] = None,
                 substitute_string: Optional[pulumi.Input['TransformerProcessorSubstituteStringPropertiesArgs']] = None,
                 trim_string: Optional[pulumi.Input['TransformerProcessorTrimStringPropertiesArgs']] = None,
                 type_converter: Optional[pulumi.Input['TransformerProcessorTypeConverterPropertiesArgs']] = None,
                 upper_case_string: Optional[pulumi.Input['TransformerProcessorUpperCaseStringPropertiesArgs']] = None):
        """
        Individual processor configuration
        :param pulumi.Input['TransformerProcessorAddKeysPropertiesArgs'] add_keys: Use this parameter to include the [addKeys](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation.html#CloudWatch-Logs-Transformation-addKeys) processor in your transformer.
        :param pulumi.Input['TransformerProcessorCopyValuePropertiesArgs'] copy_value: Use this parameter to include the [copyValue](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-copyValue) processor in your transformer.
        :param pulumi.Input['TransformerProcessorCsvPropertiesArgs'] csv: Use this parameter to include the [CSV](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation.html#CloudWatch-Logs-Transformation-CSV) processor in your transformer.
        :param pulumi.Input['TransformerProcessorDateTimeConverterPropertiesArgs'] date_time_converter: Use this parameter to include the [datetimeConverter](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-datetimeConverter) processor in your transformer.
        :param pulumi.Input['TransformerProcessorDeleteKeysPropertiesArgs'] delete_keys: Use this parameter to include the [deleteKeys](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation.html#CloudWatch-Logs-Transformation-deleteKeys) processor in your transformer.
        :param pulumi.Input['TransformerProcessorGrokPropertiesArgs'] grok: Use this parameter to include the [grok](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-grok) processor in your transformer.
        :param pulumi.Input['TransformerProcessorListToMapPropertiesArgs'] list_to_map: Use this parameter to include the [listToMap](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation.html#CloudWatch-Logs-Transformation-listToMap) processor in your transformer.
        :param pulumi.Input['TransformerProcessorLowerCaseStringPropertiesArgs'] lower_case_string: Use this parameter to include the [lowerCaseString](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-lowerCaseString) processor in your transformer.
        :param pulumi.Input['TransformerProcessorMoveKeysPropertiesArgs'] move_keys: Use this parameter to include the [moveKeys](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-moveKeys) processor in your transformer.
        :param pulumi.Input['TransformerParseCloudfrontArgs'] parse_cloudfront: Use this parameter to include the [parseCloudfront](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-parseCloudfront) processor in your transformer.
               
               If you use this processor, it must be the first processor in your transformer.
        :param pulumi.Input['TransformerProcessorParseJsonPropertiesArgs'] parse_json: Use this parameter to include the [parseJSON](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-parseJSON) processor in your transformer.
        :param pulumi.Input['TransformerProcessorParseKeyValuePropertiesArgs'] parse_key_value: Use this parameter to include the [parseKeyValue](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-parseKeyValue) processor in your transformer.
        :param pulumi.Input['TransformerParsePostgresArgs'] parse_postgres: Use this parameter to include the [parsePostGres](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation.html#CloudWatch-Logs-Transformation-parsePostGres) processor in your transformer.
               
               If you use this processor, it must be the first processor in your transformer.
        :param pulumi.Input['TransformerParseRoute53Args'] parse_route53: Use this parameter to include the [parseRoute53](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-parseRoute53) processor in your transformer.
               
               If you use this processor, it must be the first processor in your transformer.
        :param pulumi.Input['TransformerParseToOcsfArgs'] parse_to_ocsf: Use this parameter to convert logs into Open Cybersecurity Schema (OCSF) format.
        :param pulumi.Input['TransformerParseVpcArgs'] parse_vpc: Use this parameter to include the [parseVPC](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-parseVPC) processor in your transformer.
               
               If you use this processor, it must be the first processor in your transformer.
        :param pulumi.Input['TransformerParseWafArgs'] parse_waf: Use this parameter to include the [parseWAF](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation.html#CloudWatch-Logs-Transformation-parseWAF) processor in your transformer.
               
               If you use this processor, it must be the first processor in your transformer.
        :param pulumi.Input['TransformerProcessorRenameKeysPropertiesArgs'] rename_keys: Use this parameter to include the [renameKeys](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation.html#CloudWatch-Logs-Transformation-renameKeys) processor in your transformer.
        :param pulumi.Input['TransformerProcessorSplitStringPropertiesArgs'] split_string: Use this parameter to include the [splitString](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-splitString) processor in your transformer.
        :param pulumi.Input['TransformerProcessorSubstituteStringPropertiesArgs'] substitute_string: Use this parameter to include the [substituteString](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-substituteString) processor in your transformer.
        :param pulumi.Input['TransformerProcessorTrimStringPropertiesArgs'] trim_string: Use this parameter to include the [trimString](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-trimString) processor in your transformer.
        :param pulumi.Input['TransformerProcessorTypeConverterPropertiesArgs'] type_converter: Use this parameter to include the [typeConverter](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-typeConverter) processor in your transformer.
        :param pulumi.Input['TransformerProcessorUpperCaseStringPropertiesArgs'] upper_case_string: Use this parameter to include the [upperCaseString](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-upperCaseString) processor in your transformer.
        """
        if add_keys is not None:
            pulumi.set(__self__, "add_keys", add_keys)
        if copy_value is not None:
            pulumi.set(__self__, "copy_value", copy_value)
        if csv is not None:
            pulumi.set(__self__, "csv", csv)
        if date_time_converter is not None:
            pulumi.set(__self__, "date_time_converter", date_time_converter)
        if delete_keys is not None:
            pulumi.set(__self__, "delete_keys", delete_keys)
        if grok is not None:
            pulumi.set(__self__, "grok", grok)
        if list_to_map is not None:
            pulumi.set(__self__, "list_to_map", list_to_map)
        if lower_case_string is not None:
            pulumi.set(__self__, "lower_case_string", lower_case_string)
        if move_keys is not None:
            pulumi.set(__self__, "move_keys", move_keys)
        if parse_cloudfront is not None:
            pulumi.set(__self__, "parse_cloudfront", parse_cloudfront)
        if parse_json is not None:
            pulumi.set(__self__, "parse_json", parse_json)
        if parse_key_value is not None:
            pulumi.set(__self__, "parse_key_value", parse_key_value)
        if parse_postgres is not None:
            pulumi.set(__self__, "parse_postgres", parse_postgres)
        if parse_route53 is not None:
            pulumi.set(__self__, "parse_route53", parse_route53)
        if parse_to_ocsf is not None:
            pulumi.set(__self__, "parse_to_ocsf", parse_to_ocsf)
        if parse_vpc is not None:
            pulumi.set(__self__, "parse_vpc", parse_vpc)
        if parse_waf is not None:
            pulumi.set(__self__, "parse_waf", parse_waf)
        if rename_keys is not None:
            pulumi.set(__self__, "rename_keys", rename_keys)
        if split_string is not None:
            pulumi.set(__self__, "split_string", split_string)
        if substitute_string is not None:
            pulumi.set(__self__, "substitute_string", substitute_string)
        if trim_string is not None:
            pulumi.set(__self__, "trim_string", trim_string)
        if type_converter is not None:
            pulumi.set(__self__, "type_converter", type_converter)
        if upper_case_string is not None:
            pulumi.set(__self__, "upper_case_string", upper_case_string)

    @_builtins.property
    @pulumi.getter(name="addKeys")
    def add_keys(self) -> Optional[pulumi.Input['TransformerProcessorAddKeysPropertiesArgs']]:
        """
        Use this parameter to include the [addKeys](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation.html#CloudWatch-Logs-Transformation-addKeys) processor in your transformer.
        """
        return pulumi.get(self, "add_keys")

    @add_keys.setter
    def add_keys(self, value: Optional[pulumi.Input['TransformerProcessorAddKeysPropertiesArgs']]):
        pulumi.set(self, "add_keys", value)

    @_builtins.property
    @pulumi.getter(name="copyValue")
    def copy_value(self) -> Optional[pulumi.Input['TransformerProcessorCopyValuePropertiesArgs']]:
        """
        Use this parameter to include the [copyValue](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-copyValue) processor in your transformer.
        """
        return pulumi.get(self, "copy_value")

    @copy_value.setter
    def copy_value(self, value: Optional[pulumi.Input['TransformerProcessorCopyValuePropertiesArgs']]):
        pulumi.set(self, "copy_value", value)

    @_builtins.property
    @pulumi.getter
    def csv(self) -> Optional[pulumi.Input['TransformerProcessorCsvPropertiesArgs']]:
        """
        Use this parameter to include the [CSV](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation.html#CloudWatch-Logs-Transformation-CSV) processor in your transformer.
        """
        return pulumi.get(self, "csv")

    @csv.setter
    def csv(self, value: Optional[pulumi.Input['TransformerProcessorCsvPropertiesArgs']]):
        pulumi.set(self, "csv", value)

    @_builtins.property
    @pulumi.getter(name="dateTimeConverter")
    def date_time_converter(self) -> Optional[pulumi.Input['TransformerProcessorDateTimeConverterPropertiesArgs']]:
        """
        Use this parameter to include the [datetimeConverter](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-datetimeConverter) processor in your transformer.
        """
        return pulumi.get(self, "date_time_converter")

    @date_time_converter.setter
    def date_time_converter(self, value: Optional[pulumi.Input['TransformerProcessorDateTimeConverterPropertiesArgs']]):
        pulumi.set(self, "date_time_converter", value)

    @_builtins.property
    @pulumi.getter(name="deleteKeys")
    def delete_keys(self) -> Optional[pulumi.Input['TransformerProcessorDeleteKeysPropertiesArgs']]:
        """
        Use this parameter to include the [deleteKeys](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation.html#CloudWatch-Logs-Transformation-deleteKeys) processor in your transformer.
        """
        return pulumi.get(self, "delete_keys")

    @delete_keys.setter
    def delete_keys(self, value: Optional[pulumi.Input['TransformerProcessorDeleteKeysPropertiesArgs']]):
        pulumi.set(self, "delete_keys", value)

    @_builtins.property
    @pulumi.getter
    def grok(self) -> Optional[pulumi.Input['TransformerProcessorGrokPropertiesArgs']]:
        """
        Use this parameter to include the [grok](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-grok) processor in your transformer.
        """
        return pulumi.get(self, "grok")

    @grok.setter
    def grok(self, value: Optional[pulumi.Input['TransformerProcessorGrokPropertiesArgs']]):
        pulumi.set(self, "grok", value)

    @_builtins.property
    @pulumi.getter(name="listToMap")
    def list_to_map(self) -> Optional[pulumi.Input['TransformerProcessorListToMapPropertiesArgs']]:
        """
        Use this parameter to include the [listToMap](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation.html#CloudWatch-Logs-Transformation-listToMap) processor in your transformer.
        """
        return pulumi.get(self, "list_to_map")

    @list_to_map.setter
    def list_to_map(self, value: Optional[pulumi.Input['TransformerProcessorListToMapPropertiesArgs']]):
        pulumi.set(self, "list_to_map", value)

    @_builtins.property
    @pulumi.getter(name="lowerCaseString")
    def lower_case_string(self) -> Optional[pulumi.Input['TransformerProcessorLowerCaseStringPropertiesArgs']]:
        """
        Use this parameter to include the [lowerCaseString](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-lowerCaseString) processor in your transformer.
        """
        return pulumi.get(self, "lower_case_string")

    @lower_case_string.setter
    def lower_case_string(self, value: Optional[pulumi.Input['TransformerProcessorLowerCaseStringPropertiesArgs']]):
        pulumi.set(self, "lower_case_string", value)

    @_builtins.property
    @pulumi.getter(name="moveKeys")
    def move_keys(self) -> Optional[pulumi.Input['TransformerProcessorMoveKeysPropertiesArgs']]:
        """
        Use this parameter to include the [moveKeys](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-moveKeys) processor in your transformer.
        """
        return pulumi.get(self, "move_keys")

    @move_keys.setter
    def move_keys(self, value: Optional[pulumi.Input['TransformerProcessorMoveKeysPropertiesArgs']]):
        pulumi.set(self, "move_keys", value)

    @_builtins.property
    @pulumi.getter(name="parseCloudfront")
    def parse_cloudfront(self) -> Optional[pulumi.Input['TransformerParseCloudfrontArgs']]:
        """
        Use this parameter to include the [parseCloudfront](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-parseCloudfront) processor in your transformer.

        If you use this processor, it must be the first processor in your transformer.
        """
        return pulumi.get(self, "parse_cloudfront")

    @parse_cloudfront.setter
    def parse_cloudfront(self, value: Optional[pulumi.Input['TransformerParseCloudfrontArgs']]):
        pulumi.set(self, "parse_cloudfront", value)

    @_builtins.property
    @pulumi.getter(name="parseJson")
    def parse_json(self) -> Optional[pulumi.Input['TransformerProcessorParseJsonPropertiesArgs']]:
        """
        Use this parameter to include the [parseJSON](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-parseJSON) processor in your transformer.
        """
        return pulumi.get(self, "parse_json")

    @parse_json.setter
    def parse_json(self, value: Optional[pulumi.Input['TransformerProcessorParseJsonPropertiesArgs']]):
        pulumi.set(self, "parse_json", value)

    @_builtins.property
    @pulumi.getter(name="parseKeyValue")
    def parse_key_value(self) -> Optional[pulumi.Input['TransformerProcessorParseKeyValuePropertiesArgs']]:
        """
        Use this parameter to include the [parseKeyValue](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-parseKeyValue) processor in your transformer.
        """
        return pulumi.get(self, "parse_key_value")

    @parse_key_value.setter
    def parse_key_value(self, value: Optional[pulumi.Input['TransformerProcessorParseKeyValuePropertiesArgs']]):
        pulumi.set(self, "parse_key_value", value)

    @_builtins.property
    @pulumi.getter(name="parsePostgres")
    def parse_postgres(self) -> Optional[pulumi.Input['TransformerParsePostgresArgs']]:
        """
        Use this parameter to include the [parsePostGres](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation.html#CloudWatch-Logs-Transformation-parsePostGres) processor in your transformer.

        If you use this processor, it must be the first processor in your transformer.
        """
        return pulumi.get(self, "parse_postgres")

    @parse_postgres.setter
    def parse_postgres(self, value: Optional[pulumi.Input['TransformerParsePostgresArgs']]):
        pulumi.set(self, "parse_postgres", value)

    @_builtins.property
    @pulumi.getter(name="parseRoute53")
    def parse_route53(self) -> Optional[pulumi.Input['TransformerParseRoute53Args']]:
        """
        Use this parameter to include the [parseRoute53](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-parseRoute53) processor in your transformer.

        If you use this processor, it must be the first processor in your transformer.
        """
        return pulumi.get(self, "parse_route53")

    @parse_route53.setter
    def parse_route53(self, value: Optional[pulumi.Input['TransformerParseRoute53Args']]):
        pulumi.set(self, "parse_route53", value)

    @_builtins.property
    @pulumi.getter(name="parseToOcsf")
    def parse_to_ocsf(self) -> Optional[pulumi.Input['TransformerParseToOcsfArgs']]:
        """
        Use this parameter to convert logs into Open Cybersecurity Schema (OCSF) format.
        """
        return pulumi.get(self, "parse_to_ocsf")

    @parse_to_ocsf.setter
    def parse_to_ocsf(self, value: Optional[pulumi.Input['TransformerParseToOcsfArgs']]):
        pulumi.set(self, "parse_to_ocsf", value)

    @_builtins.property
    @pulumi.getter(name="parseVpc")
    def parse_vpc(self) -> Optional[pulumi.Input['TransformerParseVpcArgs']]:
        """
        Use this parameter to include the [parseVPC](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-parseVPC) processor in your transformer.

        If you use this processor, it must be the first processor in your transformer.
        """
        return pulumi.get(self, "parse_vpc")

    @parse_vpc.setter
    def parse_vpc(self, value: Optional[pulumi.Input['TransformerParseVpcArgs']]):
        pulumi.set(self, "parse_vpc", value)

    @_builtins.property
    @pulumi.getter(name="parseWaf")
    def parse_waf(self) -> Optional[pulumi.Input['TransformerParseWafArgs']]:
        """
        Use this parameter to include the [parseWAF](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation.html#CloudWatch-Logs-Transformation-parseWAF) processor in your transformer.

        If you use this processor, it must be the first processor in your transformer.
        """
        return pulumi.get(self, "parse_waf")

    @parse_waf.setter
    def parse_waf(self, value: Optional[pulumi.Input['TransformerParseWafArgs']]):
        pulumi.set(self, "parse_waf", value)

    @_builtins.property
    @pulumi.getter(name="renameKeys")
    def rename_keys(self) -> Optional[pulumi.Input['TransformerProcessorRenameKeysPropertiesArgs']]:
        """
        Use this parameter to include the [renameKeys](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation.html#CloudWatch-Logs-Transformation-renameKeys) processor in your transformer.
        """
        return pulumi.get(self, "rename_keys")

    @rename_keys.setter
    def rename_keys(self, value: Optional[pulumi.Input['TransformerProcessorRenameKeysPropertiesArgs']]):
        pulumi.set(self, "rename_keys", value)

    @_builtins.property
    @pulumi.getter(name="splitString")
    def split_string(self) -> Optional[pulumi.Input['TransformerProcessorSplitStringPropertiesArgs']]:
        """
        Use this parameter to include the [splitString](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-splitString) processor in your transformer.
        """
        return pulumi.get(self, "split_string")

    @split_string.setter
    def split_string(self, value: Optional[pulumi.Input['TransformerProcessorSplitStringPropertiesArgs']]):
        pulumi.set(self, "split_string", value)

    @_builtins.property
    @pulumi.getter(name="substituteString")
    def substitute_string(self) -> Optional[pulumi.Input['TransformerProcessorSubstituteStringPropertiesArgs']]:
        """
        Use this parameter to include the [substituteString](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-substituteString) processor in your transformer.
        """
        return pulumi.get(self, "substitute_string")

    @substitute_string.setter
    def substitute_string(self, value: Optional[pulumi.Input['TransformerProcessorSubstituteStringPropertiesArgs']]):
        pulumi.set(self, "substitute_string", value)

    @_builtins.property
    @pulumi.getter(name="trimString")
    def trim_string(self) -> Optional[pulumi.Input['TransformerProcessorTrimStringPropertiesArgs']]:
        """
        Use this parameter to include the [trimString](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-trimString) processor in your transformer.
        """
        return pulumi.get(self, "trim_string")

    @trim_string.setter
    def trim_string(self, value: Optional[pulumi.Input['TransformerProcessorTrimStringPropertiesArgs']]):
        pulumi.set(self, "trim_string", value)

    @_builtins.property
    @pulumi.getter(name="typeConverter")
    def type_converter(self) -> Optional[pulumi.Input['TransformerProcessorTypeConverterPropertiesArgs']]:
        """
        Use this parameter to include the [typeConverter](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-typeConverter) processor in your transformer.
        """
        return pulumi.get(self, "type_converter")

    @type_converter.setter
    def type_converter(self, value: Optional[pulumi.Input['TransformerProcessorTypeConverterPropertiesArgs']]):
        pulumi.set(self, "type_converter", value)

    @_builtins.property
    @pulumi.getter(name="upperCaseString")
    def upper_case_string(self) -> Optional[pulumi.Input['TransformerProcessorUpperCaseStringPropertiesArgs']]:
        """
        Use this parameter to include the [upperCaseString](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CloudWatch-Logs-Transformation-Processors.html#CloudWatch-Logs-Transformation-upperCaseString) processor in your transformer.
        """
        return pulumi.get(self, "upper_case_string")

    @upper_case_string.setter
    def upper_case_string(self, value: Optional[pulumi.Input['TransformerProcessorUpperCaseStringPropertiesArgs']]):
        pulumi.set(self, "upper_case_string", value)


if not MYPY:
    class TransformerRenameKeyEntryArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        rename_to: pulumi.Input[_builtins.str]
        overwrite_if_exists: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    TransformerRenameKeyEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerRenameKeyEntryArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 rename_to: pulumi.Input[_builtins.str],
                 overwrite_if_exists: Optional[pulumi.Input[_builtins.bool]] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "rename_to", rename_to)
        if overwrite_if_exists is not None:
            pulumi.set(__self__, "overwrite_if_exists", overwrite_if_exists)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="renameTo")
    def rename_to(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "rename_to")

    @rename_to.setter
    def rename_to(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "rename_to", value)

    @_builtins.property
    @pulumi.getter(name="overwriteIfExists")
    def overwrite_if_exists(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "overwrite_if_exists")

    @overwrite_if_exists.setter
    def overwrite_if_exists(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "overwrite_if_exists", value)


if not MYPY:
    class TransformerSplitStringEntryArgsDict(TypedDict):
        delimiter: pulumi.Input[_builtins.str]
        source: pulumi.Input[_builtins.str]
elif False:
    TransformerSplitStringEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerSplitStringEntryArgs:
    def __init__(__self__, *,
                 delimiter: pulumi.Input[_builtins.str],
                 source: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "delimiter", delimiter)
        pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter
    def delimiter(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "delimiter", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source", value)


if not MYPY:
    class TransformerSubstituteStringEntryArgsDict(TypedDict):
        from_: pulumi.Input[_builtins.str]
        source: pulumi.Input[_builtins.str]
        to: pulumi.Input[_builtins.str]
elif False:
    TransformerSubstituteStringEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerSubstituteStringEntryArgs:
    def __init__(__self__, *,
                 from_: pulumi.Input[_builtins.str],
                 source: pulumi.Input[_builtins.str],
                 to: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "to", to)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter
    def to(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "to", value)


if not MYPY:
    class TransformerTypeConverterEntryArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        type: pulumi.Input['TransformerTypeConverterEntryType']
elif False:
    TransformerTypeConverterEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransformerTypeConverterEntryArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 type: pulumi.Input['TransformerTypeConverterEntryType']):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['TransformerTypeConverterEntryType']:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['TransformerTypeConverterEntryType']):
        pulumi.set(self, "type", value)


