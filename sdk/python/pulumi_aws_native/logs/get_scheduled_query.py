# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from .. import outputs as _root_outputs
from ._enums import *

__all__ = [
    'GetScheduledQueryResult',
    'AwaitableGetScheduledQueryResult',
    'get_scheduled_query',
    'get_scheduled_query_output',
]

@pulumi.output_type
class GetScheduledQueryResult:
    def __init__(__self__, creation_time=None, description=None, destination_configuration=None, execution_role_arn=None, last_execution_status=None, last_triggered_time=None, last_updated_time=None, log_group_identifiers=None, query_language=None, query_string=None, schedule_end_time=None, schedule_expression=None, schedule_start_time=None, scheduled_query_arn=None, start_time_offset=None, state=None, tags=None, timezone=None):
        if creation_time and not isinstance(creation_time, float):
            raise TypeError("Expected argument 'creation_time' to be a float")
        pulumi.set(__self__, "creation_time", creation_time)
        if description and not isinstance(description, str):
            raise TypeError("Expected argument 'description' to be a str")
        pulumi.set(__self__, "description", description)
        if destination_configuration and not isinstance(destination_configuration, dict):
            raise TypeError("Expected argument 'destination_configuration' to be a dict")
        pulumi.set(__self__, "destination_configuration", destination_configuration)
        if execution_role_arn and not isinstance(execution_role_arn, str):
            raise TypeError("Expected argument 'execution_role_arn' to be a str")
        pulumi.set(__self__, "execution_role_arn", execution_role_arn)
        if last_execution_status and not isinstance(last_execution_status, str):
            raise TypeError("Expected argument 'last_execution_status' to be a str")
        pulumi.set(__self__, "last_execution_status", last_execution_status)
        if last_triggered_time and not isinstance(last_triggered_time, float):
            raise TypeError("Expected argument 'last_triggered_time' to be a float")
        pulumi.set(__self__, "last_triggered_time", last_triggered_time)
        if last_updated_time and not isinstance(last_updated_time, float):
            raise TypeError("Expected argument 'last_updated_time' to be a float")
        pulumi.set(__self__, "last_updated_time", last_updated_time)
        if log_group_identifiers and not isinstance(log_group_identifiers, list):
            raise TypeError("Expected argument 'log_group_identifiers' to be a list")
        pulumi.set(__self__, "log_group_identifiers", log_group_identifiers)
        if query_language and not isinstance(query_language, str):
            raise TypeError("Expected argument 'query_language' to be a str")
        pulumi.set(__self__, "query_language", query_language)
        if query_string and not isinstance(query_string, str):
            raise TypeError("Expected argument 'query_string' to be a str")
        pulumi.set(__self__, "query_string", query_string)
        if schedule_end_time and not isinstance(schedule_end_time, float):
            raise TypeError("Expected argument 'schedule_end_time' to be a float")
        pulumi.set(__self__, "schedule_end_time", schedule_end_time)
        if schedule_expression and not isinstance(schedule_expression, str):
            raise TypeError("Expected argument 'schedule_expression' to be a str")
        pulumi.set(__self__, "schedule_expression", schedule_expression)
        if schedule_start_time and not isinstance(schedule_start_time, float):
            raise TypeError("Expected argument 'schedule_start_time' to be a float")
        pulumi.set(__self__, "schedule_start_time", schedule_start_time)
        if scheduled_query_arn and not isinstance(scheduled_query_arn, str):
            raise TypeError("Expected argument 'scheduled_query_arn' to be a str")
        pulumi.set(__self__, "scheduled_query_arn", scheduled_query_arn)
        if start_time_offset and not isinstance(start_time_offset, int):
            raise TypeError("Expected argument 'start_time_offset' to be a int")
        pulumi.set(__self__, "start_time_offset", start_time_offset)
        if state and not isinstance(state, str):
            raise TypeError("Expected argument 'state' to be a str")
        pulumi.set(__self__, "state", state)
        if tags and not isinstance(tags, list):
            raise TypeError("Expected argument 'tags' to be a list")
        pulumi.set(__self__, "tags", tags)
        if timezone and not isinstance(timezone, str):
            raise TypeError("Expected argument 'timezone' to be a str")
        pulumi.set(__self__, "timezone", timezone)

    @_builtins.property
    @pulumi.getter(name="creationTime")
    def creation_time(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "creation_time")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="destinationConfiguration")
    def destination_configuration(self) -> Optional['outputs.ScheduledQueryDestinationConfiguration']:
        return pulumi.get(self, "destination_configuration")

    @_builtins.property
    @pulumi.getter(name="executionRoleArn")
    def execution_role_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "execution_role_arn")

    @_builtins.property
    @pulumi.getter(name="lastExecutionStatus")
    def last_execution_status(self) -> Optional['ScheduledQueryLastExecutionStatus']:
        return pulumi.get(self, "last_execution_status")

    @_builtins.property
    @pulumi.getter(name="lastTriggeredTime")
    def last_triggered_time(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "last_triggered_time")

    @_builtins.property
    @pulumi.getter(name="lastUpdatedTime")
    def last_updated_time(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "last_updated_time")

    @_builtins.property
    @pulumi.getter(name="logGroupIdentifiers")
    def log_group_identifiers(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "log_group_identifiers")

    @_builtins.property
    @pulumi.getter(name="queryLanguage")
    def query_language(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "query_language")

    @_builtins.property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "query_string")

    @_builtins.property
    @pulumi.getter(name="scheduleEndTime")
    def schedule_end_time(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "schedule_end_time")

    @_builtins.property
    @pulumi.getter(name="scheduleExpression")
    def schedule_expression(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "schedule_expression")

    @_builtins.property
    @pulumi.getter(name="scheduleStartTime")
    def schedule_start_time(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "schedule_start_time")

    @_builtins.property
    @pulumi.getter(name="scheduledQueryArn")
    def scheduled_query_arn(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "scheduled_query_arn")

    @_builtins.property
    @pulumi.getter(name="startTimeOffset")
    def start_time_offset(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "start_time_offset")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional['ScheduledQueryState']:
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['_root_outputs.Tag']]:
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def timezone(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "timezone")


class AwaitableGetScheduledQueryResult(GetScheduledQueryResult):
    # pylint: disable=using-constant-test
    def __await__(self):
        if False:
            yield self
        return GetScheduledQueryResult(
            creation_time=self.creation_time,
            description=self.description,
            destination_configuration=self.destination_configuration,
            execution_role_arn=self.execution_role_arn,
            last_execution_status=self.last_execution_status,
            last_triggered_time=self.last_triggered_time,
            last_updated_time=self.last_updated_time,
            log_group_identifiers=self.log_group_identifiers,
            query_language=self.query_language,
            query_string=self.query_string,
            schedule_end_time=self.schedule_end_time,
            schedule_expression=self.schedule_expression,
            schedule_start_time=self.schedule_start_time,
            scheduled_query_arn=self.scheduled_query_arn,
            start_time_offset=self.start_time_offset,
            state=self.state,
            tags=self.tags,
            timezone=self.timezone)


def get_scheduled_query(scheduled_query_arn: Optional[_builtins.str] = None,
                        opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetScheduledQueryResult:
    """
    Creates a new Scheduled Query that allows you to define a Logs Insights query that will run on a schedule and configure actions to take with the query results.
    """
    __args__ = dict()
    __args__['scheduledQueryArn'] = scheduled_query_arn
    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke('aws-native:logs:getScheduledQuery', __args__, opts=opts, typ=GetScheduledQueryResult).value

    return AwaitableGetScheduledQueryResult(
        creation_time=pulumi.get(__ret__, 'creation_time'),
        description=pulumi.get(__ret__, 'description'),
        destination_configuration=pulumi.get(__ret__, 'destination_configuration'),
        execution_role_arn=pulumi.get(__ret__, 'execution_role_arn'),
        last_execution_status=pulumi.get(__ret__, 'last_execution_status'),
        last_triggered_time=pulumi.get(__ret__, 'last_triggered_time'),
        last_updated_time=pulumi.get(__ret__, 'last_updated_time'),
        log_group_identifiers=pulumi.get(__ret__, 'log_group_identifiers'),
        query_language=pulumi.get(__ret__, 'query_language'),
        query_string=pulumi.get(__ret__, 'query_string'),
        schedule_end_time=pulumi.get(__ret__, 'schedule_end_time'),
        schedule_expression=pulumi.get(__ret__, 'schedule_expression'),
        schedule_start_time=pulumi.get(__ret__, 'schedule_start_time'),
        scheduled_query_arn=pulumi.get(__ret__, 'scheduled_query_arn'),
        start_time_offset=pulumi.get(__ret__, 'start_time_offset'),
        state=pulumi.get(__ret__, 'state'),
        tags=pulumi.get(__ret__, 'tags'),
        timezone=pulumi.get(__ret__, 'timezone'))
def get_scheduled_query_output(scheduled_query_arn: Optional[pulumi.Input[_builtins.str]] = None,
                               opts: Optional[Union[pulumi.InvokeOptions, pulumi.InvokeOutputOptions]] = None) -> pulumi.Output[GetScheduledQueryResult]:
    """
    Creates a new Scheduled Query that allows you to define a Logs Insights query that will run on a schedule and configure actions to take with the query results.
    """
    __args__ = dict()
    __args__['scheduledQueryArn'] = scheduled_query_arn
    opts = pulumi.InvokeOutputOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke_output('aws-native:logs:getScheduledQuery', __args__, opts=opts, typ=GetScheduledQueryResult)
    return __ret__.apply(lambda __response__: GetScheduledQueryResult(
        creation_time=pulumi.get(__response__, 'creation_time'),
        description=pulumi.get(__response__, 'description'),
        destination_configuration=pulumi.get(__response__, 'destination_configuration'),
        execution_role_arn=pulumi.get(__response__, 'execution_role_arn'),
        last_execution_status=pulumi.get(__response__, 'last_execution_status'),
        last_triggered_time=pulumi.get(__response__, 'last_triggered_time'),
        last_updated_time=pulumi.get(__response__, 'last_updated_time'),
        log_group_identifiers=pulumi.get(__response__, 'log_group_identifiers'),
        query_language=pulumi.get(__response__, 'query_language'),
        query_string=pulumi.get(__response__, 'query_string'),
        schedule_end_time=pulumi.get(__response__, 'schedule_end_time'),
        schedule_expression=pulumi.get(__response__, 'schedule_expression'),
        schedule_start_time=pulumi.get(__response__, 'schedule_start_time'),
        scheduled_query_arn=pulumi.get(__response__, 'scheduled_query_arn'),
        start_time_offset=pulumi.get(__response__, 'start_time_offset'),
        state=pulumi.get(__response__, 'state'),
        tags=pulumi.get(__response__, 'tags'),
        timezone=pulumi.get(__response__, 'timezone')))
