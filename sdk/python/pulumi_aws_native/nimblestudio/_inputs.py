# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'LaunchProfileStreamConfigurationSessionBackupArgs',
    'LaunchProfileStreamConfigurationSessionBackupArgsDict',
    'LaunchProfileStreamConfigurationSessionStorageArgs',
    'LaunchProfileStreamConfigurationSessionStorageArgsDict',
    'LaunchProfileStreamConfigurationArgs',
    'LaunchProfileStreamConfigurationArgsDict',
    'LaunchProfileStreamingSessionStorageRootArgs',
    'LaunchProfileStreamingSessionStorageRootArgsDict',
    'LaunchProfileVolumeConfigurationArgs',
    'LaunchProfileVolumeConfigurationArgsDict',
    'StudioComponentActiveDirectoryComputerAttributeArgs',
    'StudioComponentActiveDirectoryComputerAttributeArgsDict',
    'StudioComponentActiveDirectoryConfigurationArgs',
    'StudioComponentActiveDirectoryConfigurationArgsDict',
    'StudioComponentComputeFarmConfigurationArgs',
    'StudioComponentComputeFarmConfigurationArgsDict',
    'StudioComponentConfiguration0PropertiesArgs',
    'StudioComponentConfiguration0PropertiesArgsDict',
    'StudioComponentConfiguration1PropertiesArgs',
    'StudioComponentConfiguration1PropertiesArgsDict',
    'StudioComponentConfiguration2PropertiesArgs',
    'StudioComponentConfiguration2PropertiesArgsDict',
    'StudioComponentConfiguration3PropertiesArgs',
    'StudioComponentConfiguration3PropertiesArgsDict',
    'StudioComponentInitializationScriptArgs',
    'StudioComponentInitializationScriptArgsDict',
    'StudioComponentLicenseServiceConfigurationArgs',
    'StudioComponentLicenseServiceConfigurationArgsDict',
    'StudioComponentScriptParameterKeyValueArgs',
    'StudioComponentScriptParameterKeyValueArgsDict',
    'StudioComponentSharedFileSystemConfigurationArgs',
    'StudioComponentSharedFileSystemConfigurationArgsDict',
    'StudioEncryptionConfigurationArgs',
    'StudioEncryptionConfigurationArgsDict',
]

MYPY = False

if not MYPY:
    class LaunchProfileStreamConfigurationSessionBackupArgsDict(TypedDict):
        """
        <p>Configures how streaming sessions are backed up when launched from this launch
                    profile.</p>
        """
        max_backups_to_retain: NotRequired[pulumi.Input[float]]
        """
        <p>The maximum number of backups that each streaming session created from this launch
                    profile can have.</p>
        """
        mode: NotRequired[pulumi.Input['LaunchProfileSessionBackupMode']]
        """
        Specifies how artists sessions are backed up.

        Configures backups for streaming sessions launched with this launch profile. The default value is `DEACTIVATED` , which means that backups are deactivated. To allow backups, set this value to `AUTOMATIC` .
        """
elif False:
    LaunchProfileStreamConfigurationSessionBackupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchProfileStreamConfigurationSessionBackupArgs:
    def __init__(__self__, *,
                 max_backups_to_retain: Optional[pulumi.Input[float]] = None,
                 mode: Optional[pulumi.Input['LaunchProfileSessionBackupMode']] = None):
        """
        <p>Configures how streaming sessions are backed up when launched from this launch
                    profile.</p>
        :param pulumi.Input[float] max_backups_to_retain: <p>The maximum number of backups that each streaming session created from this launch
                           profile can have.</p>
        :param pulumi.Input['LaunchProfileSessionBackupMode'] mode: Specifies how artists sessions are backed up.
               
               Configures backups for streaming sessions launched with this launch profile. The default value is `DEACTIVATED` , which means that backups are deactivated. To allow backups, set this value to `AUTOMATIC` .
        """
        if max_backups_to_retain is not None:
            pulumi.set(__self__, "max_backups_to_retain", max_backups_to_retain)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter(name="maxBackupsToRetain")
    def max_backups_to_retain(self) -> Optional[pulumi.Input[float]]:
        """
        <p>The maximum number of backups that each streaming session created from this launch
                    profile can have.</p>
        """
        return pulumi.get(self, "max_backups_to_retain")

    @max_backups_to_retain.setter
    def max_backups_to_retain(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_backups_to_retain", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input['LaunchProfileSessionBackupMode']]:
        """
        Specifies how artists sessions are backed up.

        Configures backups for streaming sessions launched with this launch profile. The default value is `DEACTIVATED` , which means that backups are deactivated. To allow backups, set this value to `AUTOMATIC` .
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input['LaunchProfileSessionBackupMode']]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class LaunchProfileStreamConfigurationSessionStorageArgsDict(TypedDict):
        """
        <p>The configuration for a streaming session’s upload storage.</p>
        """
        mode: pulumi.Input[Sequence[pulumi.Input['LaunchProfileStreamingSessionStorageMode']]]
        """
        <p>Allows artists to upload files to their workstations. The only valid option is
                        <code>UPLOAD</code>.</p>
        """
        root: NotRequired[pulumi.Input['LaunchProfileStreamingSessionStorageRootArgsDict']]
        """
        The configuration for the upload storage root of the streaming session.
        """
elif False:
    LaunchProfileStreamConfigurationSessionStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchProfileStreamConfigurationSessionStorageArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input[Sequence[pulumi.Input['LaunchProfileStreamingSessionStorageMode']]],
                 root: Optional[pulumi.Input['LaunchProfileStreamingSessionStorageRootArgs']] = None):
        """
        <p>The configuration for a streaming session’s upload storage.</p>
        :param pulumi.Input[Sequence[pulumi.Input['LaunchProfileStreamingSessionStorageMode']]] mode: <p>Allows artists to upload files to their workstations. The only valid option is
                               <code>UPLOAD</code>.</p>
        :param pulumi.Input['LaunchProfileStreamingSessionStorageRootArgs'] root: The configuration for the upload storage root of the streaming session.
        """
        pulumi.set(__self__, "mode", mode)
        if root is not None:
            pulumi.set(__self__, "root", root)

    @property
    @pulumi.getter
    def mode(self) -> pulumi.Input[Sequence[pulumi.Input['LaunchProfileStreamingSessionStorageMode']]]:
        """
        <p>Allows artists to upload files to their workstations. The only valid option is
                        <code>UPLOAD</code>.</p>
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[Sequence[pulumi.Input['LaunchProfileStreamingSessionStorageMode']]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def root(self) -> Optional[pulumi.Input['LaunchProfileStreamingSessionStorageRootArgs']]:
        """
        The configuration for the upload storage root of the streaming session.
        """
        return pulumi.get(self, "root")

    @root.setter
    def root(self, value: Optional[pulumi.Input['LaunchProfileStreamingSessionStorageRootArgs']]):
        pulumi.set(self, "root", value)


if not MYPY:
    class LaunchProfileStreamConfigurationArgsDict(TypedDict):
        """
        <p>A configuration for a streaming session.</p>
        """
        clipboard_mode: pulumi.Input['LaunchProfileStreamingClipboardMode']
        """
        Allows or deactivates the use of the system clipboard to copy and paste between the streaming session and streaming client.
        """
        ec2_instance_types: pulumi.Input[Sequence[pulumi.Input['LaunchProfileStreamingInstanceType']]]
        """
        <p>The EC2 instance types that users can select from when launching a streaming session
                    with this launch profile.</p>
        """
        streaming_image_ids: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        <p>The streaming images that users can select from when launching a streaming session
                    with this launch profile.</p>
        """
        automatic_termination_mode: NotRequired[pulumi.Input['LaunchProfileAutomaticTerminationMode']]
        """
        Indicates if a streaming session created from this launch profile should be terminated automatically or retained without termination after being in a `STOPPED` state.

        - When `ACTIVATED` , the streaming session is scheduled for termination after being in the `STOPPED` state for the time specified in `maxStoppedSessionLengthInMinutes` .
        - When `DEACTIVATED` , the streaming session can remain in the `STOPPED` state indefinitely.

        This parameter is only allowed when `sessionPersistenceMode` is `ACTIVATED` . When allowed, the default value for this parameter is `DEACTIVATED` .
        """
        max_session_length_in_minutes: NotRequired[pulumi.Input[float]]
        """
        <p>The length of time, in minutes, that a streaming session can be active before it is
                    stopped or terminated. After this point, Nimble Studio automatically terminates or
                    stops the session. The default length of time is 690 minutes, and the maximum length of
                    time is 30 days.</p>
        """
        max_stopped_session_length_in_minutes: NotRequired[pulumi.Input[float]]
        """
        <p>Integer that determines if you can start and stop your sessions and how long a session
                    can stay in the <code>STOPPED</code> state. The default value is 0. The maximum value is
                    5760.</p>
                 <p>This field is allowed only when <code>sessionPersistenceMode</code> is
                        <code>ACTIVATED</code> and <code>automaticTerminationMode</code> is
                        <code>ACTIVATED</code>.</p>
                 <p>If the value is set to 0, your sessions can’t be <code>STOPPED</code>. If you then
                    call <code>StopStreamingSession</code>, the session fails. If the time that a session
                    stays in the <code>READY</code> state exceeds the <code>maxSessionLengthInMinutes</code>
                    value, the session will automatically be terminated (instead of
                    <code>STOPPED</code>).</p>
                 <p>If the value is set to a positive number, the session can be stopped. You can call
                        <code>StopStreamingSession</code> to stop sessions in the <code>READY</code> state.
                    If the time that a session stays in the <code>READY</code> state exceeds the
                        <code>maxSessionLengthInMinutes</code> value, the session will automatically be
                    stopped (instead of terminated).</p>
        """
        session_backup: NotRequired[pulumi.Input['LaunchProfileStreamConfigurationSessionBackupArgsDict']]
        """
        Information about the streaming session backup.
        """
        session_persistence_mode: NotRequired[pulumi.Input['LaunchProfileSessionPersistenceMode']]
        """
        Determine if a streaming session created from this launch profile can configure persistent storage. This means that `volumeConfiguration` and `automaticTerminationMode` are configured.
        """
        session_storage: NotRequired[pulumi.Input['LaunchProfileStreamConfigurationSessionStorageArgsDict']]
        """
        The upload storage for a streaming session.
        """
        volume_configuration: NotRequired[pulumi.Input['LaunchProfileVolumeConfigurationArgsDict']]
        """
        Custom volume configuration for the root volumes that are attached to streaming sessions.

        This parameter is only allowed when `sessionPersistenceMode` is `ACTIVATED` .
        """
elif False:
    LaunchProfileStreamConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchProfileStreamConfigurationArgs:
    def __init__(__self__, *,
                 clipboard_mode: pulumi.Input['LaunchProfileStreamingClipboardMode'],
                 ec2_instance_types: pulumi.Input[Sequence[pulumi.Input['LaunchProfileStreamingInstanceType']]],
                 streaming_image_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                 automatic_termination_mode: Optional[pulumi.Input['LaunchProfileAutomaticTerminationMode']] = None,
                 max_session_length_in_minutes: Optional[pulumi.Input[float]] = None,
                 max_stopped_session_length_in_minutes: Optional[pulumi.Input[float]] = None,
                 session_backup: Optional[pulumi.Input['LaunchProfileStreamConfigurationSessionBackupArgs']] = None,
                 session_persistence_mode: Optional[pulumi.Input['LaunchProfileSessionPersistenceMode']] = None,
                 session_storage: Optional[pulumi.Input['LaunchProfileStreamConfigurationSessionStorageArgs']] = None,
                 volume_configuration: Optional[pulumi.Input['LaunchProfileVolumeConfigurationArgs']] = None):
        """
        <p>A configuration for a streaming session.</p>
        :param pulumi.Input['LaunchProfileStreamingClipboardMode'] clipboard_mode: Allows or deactivates the use of the system clipboard to copy and paste between the streaming session and streaming client.
        :param pulumi.Input[Sequence[pulumi.Input['LaunchProfileStreamingInstanceType']]] ec2_instance_types: <p>The EC2 instance types that users can select from when launching a streaming session
                           with this launch profile.</p>
        :param pulumi.Input[Sequence[pulumi.Input[str]]] streaming_image_ids: <p>The streaming images that users can select from when launching a streaming session
                           with this launch profile.</p>
        :param pulumi.Input['LaunchProfileAutomaticTerminationMode'] automatic_termination_mode: Indicates if a streaming session created from this launch profile should be terminated automatically or retained without termination after being in a `STOPPED` state.
               
               - When `ACTIVATED` , the streaming session is scheduled for termination after being in the `STOPPED` state for the time specified in `maxStoppedSessionLengthInMinutes` .
               - When `DEACTIVATED` , the streaming session can remain in the `STOPPED` state indefinitely.
               
               This parameter is only allowed when `sessionPersistenceMode` is `ACTIVATED` . When allowed, the default value for this parameter is `DEACTIVATED` .
        :param pulumi.Input[float] max_session_length_in_minutes: <p>The length of time, in minutes, that a streaming session can be active before it is
                           stopped or terminated. After this point, Nimble Studio automatically terminates or
                           stops the session. The default length of time is 690 minutes, and the maximum length of
                           time is 30 days.</p>
        :param pulumi.Input[float] max_stopped_session_length_in_minutes: <p>Integer that determines if you can start and stop your sessions and how long a session
                           can stay in the <code>STOPPED</code> state. The default value is 0. The maximum value is
                           5760.</p>
                        <p>This field is allowed only when <code>sessionPersistenceMode</code> is
                               <code>ACTIVATED</code> and <code>automaticTerminationMode</code> is
                               <code>ACTIVATED</code>.</p>
                        <p>If the value is set to 0, your sessions can’t be <code>STOPPED</code>. If you then
                           call <code>StopStreamingSession</code>, the session fails. If the time that a session
                           stays in the <code>READY</code> state exceeds the <code>maxSessionLengthInMinutes</code>
                           value, the session will automatically be terminated (instead of
                           <code>STOPPED</code>).</p>
                        <p>If the value is set to a positive number, the session can be stopped. You can call
                               <code>StopStreamingSession</code> to stop sessions in the <code>READY</code> state.
                           If the time that a session stays in the <code>READY</code> state exceeds the
                               <code>maxSessionLengthInMinutes</code> value, the session will automatically be
                           stopped (instead of terminated).</p>
        :param pulumi.Input['LaunchProfileStreamConfigurationSessionBackupArgs'] session_backup: Information about the streaming session backup.
        :param pulumi.Input['LaunchProfileSessionPersistenceMode'] session_persistence_mode: Determine if a streaming session created from this launch profile can configure persistent storage. This means that `volumeConfiguration` and `automaticTerminationMode` are configured.
        :param pulumi.Input['LaunchProfileStreamConfigurationSessionStorageArgs'] session_storage: The upload storage for a streaming session.
        :param pulumi.Input['LaunchProfileVolumeConfigurationArgs'] volume_configuration: Custom volume configuration for the root volumes that are attached to streaming sessions.
               
               This parameter is only allowed when `sessionPersistenceMode` is `ACTIVATED` .
        """
        pulumi.set(__self__, "clipboard_mode", clipboard_mode)
        pulumi.set(__self__, "ec2_instance_types", ec2_instance_types)
        pulumi.set(__self__, "streaming_image_ids", streaming_image_ids)
        if automatic_termination_mode is not None:
            pulumi.set(__self__, "automatic_termination_mode", automatic_termination_mode)
        if max_session_length_in_minutes is not None:
            pulumi.set(__self__, "max_session_length_in_minutes", max_session_length_in_minutes)
        if max_stopped_session_length_in_minutes is not None:
            pulumi.set(__self__, "max_stopped_session_length_in_minutes", max_stopped_session_length_in_minutes)
        if session_backup is not None:
            pulumi.set(__self__, "session_backup", session_backup)
        if session_persistence_mode is not None:
            pulumi.set(__self__, "session_persistence_mode", session_persistence_mode)
        if session_storage is not None:
            pulumi.set(__self__, "session_storage", session_storage)
        if volume_configuration is not None:
            pulumi.set(__self__, "volume_configuration", volume_configuration)

    @property
    @pulumi.getter(name="clipboardMode")
    def clipboard_mode(self) -> pulumi.Input['LaunchProfileStreamingClipboardMode']:
        """
        Allows or deactivates the use of the system clipboard to copy and paste between the streaming session and streaming client.
        """
        return pulumi.get(self, "clipboard_mode")

    @clipboard_mode.setter
    def clipboard_mode(self, value: pulumi.Input['LaunchProfileStreamingClipboardMode']):
        pulumi.set(self, "clipboard_mode", value)

    @property
    @pulumi.getter(name="ec2InstanceTypes")
    def ec2_instance_types(self) -> pulumi.Input[Sequence[pulumi.Input['LaunchProfileStreamingInstanceType']]]:
        """
        <p>The EC2 instance types that users can select from when launching a streaming session
                    with this launch profile.</p>
        """
        return pulumi.get(self, "ec2_instance_types")

    @ec2_instance_types.setter
    def ec2_instance_types(self, value: pulumi.Input[Sequence[pulumi.Input['LaunchProfileStreamingInstanceType']]]):
        pulumi.set(self, "ec2_instance_types", value)

    @property
    @pulumi.getter(name="streamingImageIds")
    def streaming_image_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        <p>The streaming images that users can select from when launching a streaming session
                    with this launch profile.</p>
        """
        return pulumi.get(self, "streaming_image_ids")

    @streaming_image_ids.setter
    def streaming_image_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "streaming_image_ids", value)

    @property
    @pulumi.getter(name="automaticTerminationMode")
    def automatic_termination_mode(self) -> Optional[pulumi.Input['LaunchProfileAutomaticTerminationMode']]:
        """
        Indicates if a streaming session created from this launch profile should be terminated automatically or retained without termination after being in a `STOPPED` state.

        - When `ACTIVATED` , the streaming session is scheduled for termination after being in the `STOPPED` state for the time specified in `maxStoppedSessionLengthInMinutes` .
        - When `DEACTIVATED` , the streaming session can remain in the `STOPPED` state indefinitely.

        This parameter is only allowed when `sessionPersistenceMode` is `ACTIVATED` . When allowed, the default value for this parameter is `DEACTIVATED` .
        """
        return pulumi.get(self, "automatic_termination_mode")

    @automatic_termination_mode.setter
    def automatic_termination_mode(self, value: Optional[pulumi.Input['LaunchProfileAutomaticTerminationMode']]):
        pulumi.set(self, "automatic_termination_mode", value)

    @property
    @pulumi.getter(name="maxSessionLengthInMinutes")
    def max_session_length_in_minutes(self) -> Optional[pulumi.Input[float]]:
        """
        <p>The length of time, in minutes, that a streaming session can be active before it is
                    stopped or terminated. After this point, Nimble Studio automatically terminates or
                    stops the session. The default length of time is 690 minutes, and the maximum length of
                    time is 30 days.</p>
        """
        return pulumi.get(self, "max_session_length_in_minutes")

    @max_session_length_in_minutes.setter
    def max_session_length_in_minutes(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_session_length_in_minutes", value)

    @property
    @pulumi.getter(name="maxStoppedSessionLengthInMinutes")
    def max_stopped_session_length_in_minutes(self) -> Optional[pulumi.Input[float]]:
        """
        <p>Integer that determines if you can start and stop your sessions and how long a session
                    can stay in the <code>STOPPED</code> state. The default value is 0. The maximum value is
                    5760.</p>
                 <p>This field is allowed only when <code>sessionPersistenceMode</code> is
                        <code>ACTIVATED</code> and <code>automaticTerminationMode</code> is
                        <code>ACTIVATED</code>.</p>
                 <p>If the value is set to 0, your sessions can’t be <code>STOPPED</code>. If you then
                    call <code>StopStreamingSession</code>, the session fails. If the time that a session
                    stays in the <code>READY</code> state exceeds the <code>maxSessionLengthInMinutes</code>
                    value, the session will automatically be terminated (instead of
                    <code>STOPPED</code>).</p>
                 <p>If the value is set to a positive number, the session can be stopped. You can call
                        <code>StopStreamingSession</code> to stop sessions in the <code>READY</code> state.
                    If the time that a session stays in the <code>READY</code> state exceeds the
                        <code>maxSessionLengthInMinutes</code> value, the session will automatically be
                    stopped (instead of terminated).</p>
        """
        return pulumi.get(self, "max_stopped_session_length_in_minutes")

    @max_stopped_session_length_in_minutes.setter
    def max_stopped_session_length_in_minutes(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_stopped_session_length_in_minutes", value)

    @property
    @pulumi.getter(name="sessionBackup")
    def session_backup(self) -> Optional[pulumi.Input['LaunchProfileStreamConfigurationSessionBackupArgs']]:
        """
        Information about the streaming session backup.
        """
        return pulumi.get(self, "session_backup")

    @session_backup.setter
    def session_backup(self, value: Optional[pulumi.Input['LaunchProfileStreamConfigurationSessionBackupArgs']]):
        pulumi.set(self, "session_backup", value)

    @property
    @pulumi.getter(name="sessionPersistenceMode")
    def session_persistence_mode(self) -> Optional[pulumi.Input['LaunchProfileSessionPersistenceMode']]:
        """
        Determine if a streaming session created from this launch profile can configure persistent storage. This means that `volumeConfiguration` and `automaticTerminationMode` are configured.
        """
        return pulumi.get(self, "session_persistence_mode")

    @session_persistence_mode.setter
    def session_persistence_mode(self, value: Optional[pulumi.Input['LaunchProfileSessionPersistenceMode']]):
        pulumi.set(self, "session_persistence_mode", value)

    @property
    @pulumi.getter(name="sessionStorage")
    def session_storage(self) -> Optional[pulumi.Input['LaunchProfileStreamConfigurationSessionStorageArgs']]:
        """
        The upload storage for a streaming session.
        """
        return pulumi.get(self, "session_storage")

    @session_storage.setter
    def session_storage(self, value: Optional[pulumi.Input['LaunchProfileStreamConfigurationSessionStorageArgs']]):
        pulumi.set(self, "session_storage", value)

    @property
    @pulumi.getter(name="volumeConfiguration")
    def volume_configuration(self) -> Optional[pulumi.Input['LaunchProfileVolumeConfigurationArgs']]:
        """
        Custom volume configuration for the root volumes that are attached to streaming sessions.

        This parameter is only allowed when `sessionPersistenceMode` is `ACTIVATED` .
        """
        return pulumi.get(self, "volume_configuration")

    @volume_configuration.setter
    def volume_configuration(self, value: Optional[pulumi.Input['LaunchProfileVolumeConfigurationArgs']]):
        pulumi.set(self, "volume_configuration", value)


if not MYPY:
    class LaunchProfileStreamingSessionStorageRootArgsDict(TypedDict):
        """
        <p>The upload storage root location (folder) on streaming workstations where files are
                    uploaded.</p>
        """
        linux: NotRequired[pulumi.Input[str]]
        """
        <p>The folder path in Linux workstations where files are uploaded.</p>
        """
        windows: NotRequired[pulumi.Input[str]]
        """
        <p>The folder path in Windows workstations where files are uploaded.</p>
        """
elif False:
    LaunchProfileStreamingSessionStorageRootArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchProfileStreamingSessionStorageRootArgs:
    def __init__(__self__, *,
                 linux: Optional[pulumi.Input[str]] = None,
                 windows: Optional[pulumi.Input[str]] = None):
        """
        <p>The upload storage root location (folder) on streaming workstations where files are
                    uploaded.</p>
        :param pulumi.Input[str] linux: <p>The folder path in Linux workstations where files are uploaded.</p>
        :param pulumi.Input[str] windows: <p>The folder path in Windows workstations where files are uploaded.</p>
        """
        if linux is not None:
            pulumi.set(__self__, "linux", linux)
        if windows is not None:
            pulumi.set(__self__, "windows", windows)

    @property
    @pulumi.getter
    def linux(self) -> Optional[pulumi.Input[str]]:
        """
        <p>The folder path in Linux workstations where files are uploaded.</p>
        """
        return pulumi.get(self, "linux")

    @linux.setter
    def linux(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "linux", value)

    @property
    @pulumi.getter
    def windows(self) -> Optional[pulumi.Input[str]]:
        """
        <p>The folder path in Windows workstations where files are uploaded.</p>
        """
        return pulumi.get(self, "windows")

    @windows.setter
    def windows(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "windows", value)


if not MYPY:
    class LaunchProfileVolumeConfigurationArgsDict(TypedDict):
        """
        <p>Custom volume configuration for the root volumes that are attached to streaming
                    sessions.</p>
                 <p>This parameter is only allowed when <code>sessionPersistenceMode</code> is
                        <code>ACTIVATED</code>.</p>
        """
        iops: NotRequired[pulumi.Input[float]]
        """
        <p>The number of I/O operations per second for the root volume that is attached to
                    streaming session.</p>
        """
        size: NotRequired[pulumi.Input[float]]
        """
        <p>The size of the root volume that is attached to the streaming session. The root volume
                    size is measured in GiBs.</p>
        """
        throughput: NotRequired[pulumi.Input[float]]
        """
        <p>The throughput to provision for the root volume that is attached to the streaming
                    session. The throughput is measured in MiB/s.</p>
        """
elif False:
    LaunchProfileVolumeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LaunchProfileVolumeConfigurationArgs:
    def __init__(__self__, *,
                 iops: Optional[pulumi.Input[float]] = None,
                 size: Optional[pulumi.Input[float]] = None,
                 throughput: Optional[pulumi.Input[float]] = None):
        """
        <p>Custom volume configuration for the root volumes that are attached to streaming
                    sessions.</p>
                 <p>This parameter is only allowed when <code>sessionPersistenceMode</code> is
                        <code>ACTIVATED</code>.</p>
        :param pulumi.Input[float] iops: <p>The number of I/O operations per second for the root volume that is attached to
                           streaming session.</p>
        :param pulumi.Input[float] size: <p>The size of the root volume that is attached to the streaming session. The root volume
                           size is measured in GiBs.</p>
        :param pulumi.Input[float] throughput: <p>The throughput to provision for the root volume that is attached to the streaming
                           session. The throughput is measured in MiB/s.</p>
        """
        if iops is not None:
            pulumi.set(__self__, "iops", iops)
        if size is not None:
            pulumi.set(__self__, "size", size)
        if throughput is not None:
            pulumi.set(__self__, "throughput", throughput)

    @property
    @pulumi.getter
    def iops(self) -> Optional[pulumi.Input[float]]:
        """
        <p>The number of I/O operations per second for the root volume that is attached to
                    streaming session.</p>
        """
        return pulumi.get(self, "iops")

    @iops.setter
    def iops(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "iops", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[float]]:
        """
        <p>The size of the root volume that is attached to the streaming session. The root volume
                    size is measured in GiBs.</p>
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def throughput(self) -> Optional[pulumi.Input[float]]:
        """
        <p>The throughput to provision for the root volume that is attached to the streaming
                    session. The throughput is measured in MiB/s.</p>
        """
        return pulumi.get(self, "throughput")

    @throughput.setter
    def throughput(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "throughput", value)


if not MYPY:
    class StudioComponentActiveDirectoryComputerAttributeArgsDict(TypedDict):
        """
        <p>An LDAP attribute of an Active Directory computer account, in the form of a name:value
                    pair.</p>
        """
        name: NotRequired[pulumi.Input[str]]
        """
        <p>The name for the LDAP attribute.</p>
        """
        value: NotRequired[pulumi.Input[str]]
        """
        <p>The value for the LDAP attribute.</p>
        """
elif False:
    StudioComponentActiveDirectoryComputerAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StudioComponentActiveDirectoryComputerAttributeArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        <p>An LDAP attribute of an Active Directory computer account, in the form of a name:value
                    pair.</p>
        :param pulumi.Input[str] name: <p>The name for the LDAP attribute.</p>
        :param pulumi.Input[str] value: <p>The value for the LDAP attribute.</p>
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        <p>The name for the LDAP attribute.</p>
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        <p>The value for the LDAP attribute.</p>
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class StudioComponentActiveDirectoryConfigurationArgsDict(TypedDict):
        """
        <p>The configuration for a Microsoft Active Directory (Microsoft AD) studio
                    resource.</p>
        """
        computer_attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input['StudioComponentActiveDirectoryComputerAttributeArgsDict']]]]
        """
        <p>A collection of custom attributes for an Active Directory computer.</p>
        """
        directory_id: NotRequired[pulumi.Input[str]]
        """
        <p>The directory ID of the Directory Service for Microsoft Active Directory to access
                    using this studio component.</p>
        """
        organizational_unit_distinguished_name: NotRequired[pulumi.Input[str]]
        """
        <p>The distinguished name (DN) and organizational unit (OU) of an Active Directory
                    computer.</p>
        """
elif False:
    StudioComponentActiveDirectoryConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StudioComponentActiveDirectoryConfigurationArgs:
    def __init__(__self__, *,
                 computer_attributes: Optional[pulumi.Input[Sequence[pulumi.Input['StudioComponentActiveDirectoryComputerAttributeArgs']]]] = None,
                 directory_id: Optional[pulumi.Input[str]] = None,
                 organizational_unit_distinguished_name: Optional[pulumi.Input[str]] = None):
        """
        <p>The configuration for a Microsoft Active Directory (Microsoft AD) studio
                    resource.</p>
        :param pulumi.Input[Sequence[pulumi.Input['StudioComponentActiveDirectoryComputerAttributeArgs']]] computer_attributes: <p>A collection of custom attributes for an Active Directory computer.</p>
        :param pulumi.Input[str] directory_id: <p>The directory ID of the Directory Service for Microsoft Active Directory to access
                           using this studio component.</p>
        :param pulumi.Input[str] organizational_unit_distinguished_name: <p>The distinguished name (DN) and organizational unit (OU) of an Active Directory
                           computer.</p>
        """
        if computer_attributes is not None:
            pulumi.set(__self__, "computer_attributes", computer_attributes)
        if directory_id is not None:
            pulumi.set(__self__, "directory_id", directory_id)
        if organizational_unit_distinguished_name is not None:
            pulumi.set(__self__, "organizational_unit_distinguished_name", organizational_unit_distinguished_name)

    @property
    @pulumi.getter(name="computerAttributes")
    def computer_attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StudioComponentActiveDirectoryComputerAttributeArgs']]]]:
        """
        <p>A collection of custom attributes for an Active Directory computer.</p>
        """
        return pulumi.get(self, "computer_attributes")

    @computer_attributes.setter
    def computer_attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StudioComponentActiveDirectoryComputerAttributeArgs']]]]):
        pulumi.set(self, "computer_attributes", value)

    @property
    @pulumi.getter(name="directoryId")
    def directory_id(self) -> Optional[pulumi.Input[str]]:
        """
        <p>The directory ID of the Directory Service for Microsoft Active Directory to access
                    using this studio component.</p>
        """
        return pulumi.get(self, "directory_id")

    @directory_id.setter
    def directory_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "directory_id", value)

    @property
    @pulumi.getter(name="organizationalUnitDistinguishedName")
    def organizational_unit_distinguished_name(self) -> Optional[pulumi.Input[str]]:
        """
        <p>The distinguished name (DN) and organizational unit (OU) of an Active Directory
                    computer.</p>
        """
        return pulumi.get(self, "organizational_unit_distinguished_name")

    @organizational_unit_distinguished_name.setter
    def organizational_unit_distinguished_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "organizational_unit_distinguished_name", value)


if not MYPY:
    class StudioComponentComputeFarmConfigurationArgsDict(TypedDict):
        """
        <p>The configuration for a render farm that is associated with a studio resource.</p>
        """
        active_directory_user: NotRequired[pulumi.Input[str]]
        """
        <p>The name of an Active Directory user that is used on ComputeFarm worker
                    instances.</p>
        """
        endpoint: NotRequired[pulumi.Input[str]]
        """
        <p>The endpoint of the ComputeFarm that is accessed by the studio component
                    resource.</p>
        """
elif False:
    StudioComponentComputeFarmConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StudioComponentComputeFarmConfigurationArgs:
    def __init__(__self__, *,
                 active_directory_user: Optional[pulumi.Input[str]] = None,
                 endpoint: Optional[pulumi.Input[str]] = None):
        """
        <p>The configuration for a render farm that is associated with a studio resource.</p>
        :param pulumi.Input[str] active_directory_user: <p>The name of an Active Directory user that is used on ComputeFarm worker
                           instances.</p>
        :param pulumi.Input[str] endpoint: <p>The endpoint of the ComputeFarm that is accessed by the studio component
                           resource.</p>
        """
        if active_directory_user is not None:
            pulumi.set(__self__, "active_directory_user", active_directory_user)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)

    @property
    @pulumi.getter(name="activeDirectoryUser")
    def active_directory_user(self) -> Optional[pulumi.Input[str]]:
        """
        <p>The name of an Active Directory user that is used on ComputeFarm worker
                    instances.</p>
        """
        return pulumi.get(self, "active_directory_user")

    @active_directory_user.setter
    def active_directory_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "active_directory_user", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        <p>The endpoint of the ComputeFarm that is accessed by the studio component
                    resource.</p>
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)


if not MYPY:
    class StudioComponentConfiguration0PropertiesArgsDict(TypedDict):
        """
        <p>The configuration of the studio component, based on component type.</p>
        """
        active_directory_configuration: pulumi.Input['StudioComponentActiveDirectoryConfigurationArgsDict']
elif False:
    StudioComponentConfiguration0PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StudioComponentConfiguration0PropertiesArgs:
    def __init__(__self__, *,
                 active_directory_configuration: pulumi.Input['StudioComponentActiveDirectoryConfigurationArgs']):
        """
        <p>The configuration of the studio component, based on component type.</p>
        """
        pulumi.set(__self__, "active_directory_configuration", active_directory_configuration)

    @property
    @pulumi.getter(name="activeDirectoryConfiguration")
    def active_directory_configuration(self) -> pulumi.Input['StudioComponentActiveDirectoryConfigurationArgs']:
        return pulumi.get(self, "active_directory_configuration")

    @active_directory_configuration.setter
    def active_directory_configuration(self, value: pulumi.Input['StudioComponentActiveDirectoryConfigurationArgs']):
        pulumi.set(self, "active_directory_configuration", value)


if not MYPY:
    class StudioComponentConfiguration1PropertiesArgsDict(TypedDict):
        """
        <p>The configuration of the studio component, based on component type.</p>
        """
        compute_farm_configuration: pulumi.Input['StudioComponentComputeFarmConfigurationArgsDict']
elif False:
    StudioComponentConfiguration1PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StudioComponentConfiguration1PropertiesArgs:
    def __init__(__self__, *,
                 compute_farm_configuration: pulumi.Input['StudioComponentComputeFarmConfigurationArgs']):
        """
        <p>The configuration of the studio component, based on component type.</p>
        """
        pulumi.set(__self__, "compute_farm_configuration", compute_farm_configuration)

    @property
    @pulumi.getter(name="computeFarmConfiguration")
    def compute_farm_configuration(self) -> pulumi.Input['StudioComponentComputeFarmConfigurationArgs']:
        return pulumi.get(self, "compute_farm_configuration")

    @compute_farm_configuration.setter
    def compute_farm_configuration(self, value: pulumi.Input['StudioComponentComputeFarmConfigurationArgs']):
        pulumi.set(self, "compute_farm_configuration", value)


if not MYPY:
    class StudioComponentConfiguration2PropertiesArgsDict(TypedDict):
        """
        <p>The configuration of the studio component, based on component type.</p>
        """
        license_service_configuration: pulumi.Input['StudioComponentLicenseServiceConfigurationArgsDict']
elif False:
    StudioComponentConfiguration2PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StudioComponentConfiguration2PropertiesArgs:
    def __init__(__self__, *,
                 license_service_configuration: pulumi.Input['StudioComponentLicenseServiceConfigurationArgs']):
        """
        <p>The configuration of the studio component, based on component type.</p>
        """
        pulumi.set(__self__, "license_service_configuration", license_service_configuration)

    @property
    @pulumi.getter(name="licenseServiceConfiguration")
    def license_service_configuration(self) -> pulumi.Input['StudioComponentLicenseServiceConfigurationArgs']:
        return pulumi.get(self, "license_service_configuration")

    @license_service_configuration.setter
    def license_service_configuration(self, value: pulumi.Input['StudioComponentLicenseServiceConfigurationArgs']):
        pulumi.set(self, "license_service_configuration", value)


if not MYPY:
    class StudioComponentConfiguration3PropertiesArgsDict(TypedDict):
        """
        <p>The configuration of the studio component, based on component type.</p>
        """
        shared_file_system_configuration: pulumi.Input['StudioComponentSharedFileSystemConfigurationArgsDict']
elif False:
    StudioComponentConfiguration3PropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StudioComponentConfiguration3PropertiesArgs:
    def __init__(__self__, *,
                 shared_file_system_configuration: pulumi.Input['StudioComponentSharedFileSystemConfigurationArgs']):
        """
        <p>The configuration of the studio component, based on component type.</p>
        """
        pulumi.set(__self__, "shared_file_system_configuration", shared_file_system_configuration)

    @property
    @pulumi.getter(name="sharedFileSystemConfiguration")
    def shared_file_system_configuration(self) -> pulumi.Input['StudioComponentSharedFileSystemConfigurationArgs']:
        return pulumi.get(self, "shared_file_system_configuration")

    @shared_file_system_configuration.setter
    def shared_file_system_configuration(self, value: pulumi.Input['StudioComponentSharedFileSystemConfigurationArgs']):
        pulumi.set(self, "shared_file_system_configuration", value)


if not MYPY:
    class StudioComponentInitializationScriptArgsDict(TypedDict):
        """
        <p>Initialization scripts for studio components.</p>
        """
        launch_profile_protocol_version: NotRequired[pulumi.Input[str]]
        """
        <p>The version number of the protocol that is used by the launch profile. The only valid
                    version is "2021-03-31".</p>
        """
        platform: NotRequired[pulumi.Input['StudioComponentLaunchProfilePlatform']]
        """
        The platform of the initialization script, either Windows or Linux.
        """
        run_context: NotRequired[pulumi.Input['StudioComponentInitializationScriptRunContext']]
        """
        The method to use when running the initialization script.
        """
        script: NotRequired[pulumi.Input[str]]
        """
        <p>The initialization script.</p>
        """
elif False:
    StudioComponentInitializationScriptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StudioComponentInitializationScriptArgs:
    def __init__(__self__, *,
                 launch_profile_protocol_version: Optional[pulumi.Input[str]] = None,
                 platform: Optional[pulumi.Input['StudioComponentLaunchProfilePlatform']] = None,
                 run_context: Optional[pulumi.Input['StudioComponentInitializationScriptRunContext']] = None,
                 script: Optional[pulumi.Input[str]] = None):
        """
        <p>Initialization scripts for studio components.</p>
        :param pulumi.Input[str] launch_profile_protocol_version: <p>The version number of the protocol that is used by the launch profile. The only valid
                           version is "2021-03-31".</p>
        :param pulumi.Input['StudioComponentLaunchProfilePlatform'] platform: The platform of the initialization script, either Windows or Linux.
        :param pulumi.Input['StudioComponentInitializationScriptRunContext'] run_context: The method to use when running the initialization script.
        :param pulumi.Input[str] script: <p>The initialization script.</p>
        """
        if launch_profile_protocol_version is not None:
            pulumi.set(__self__, "launch_profile_protocol_version", launch_profile_protocol_version)
        if platform is not None:
            pulumi.set(__self__, "platform", platform)
        if run_context is not None:
            pulumi.set(__self__, "run_context", run_context)
        if script is not None:
            pulumi.set(__self__, "script", script)

    @property
    @pulumi.getter(name="launchProfileProtocolVersion")
    def launch_profile_protocol_version(self) -> Optional[pulumi.Input[str]]:
        """
        <p>The version number of the protocol that is used by the launch profile. The only valid
                    version is "2021-03-31".</p>
        """
        return pulumi.get(self, "launch_profile_protocol_version")

    @launch_profile_protocol_version.setter
    def launch_profile_protocol_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "launch_profile_protocol_version", value)

    @property
    @pulumi.getter
    def platform(self) -> Optional[pulumi.Input['StudioComponentLaunchProfilePlatform']]:
        """
        The platform of the initialization script, either Windows or Linux.
        """
        return pulumi.get(self, "platform")

    @platform.setter
    def platform(self, value: Optional[pulumi.Input['StudioComponentLaunchProfilePlatform']]):
        pulumi.set(self, "platform", value)

    @property
    @pulumi.getter(name="runContext")
    def run_context(self) -> Optional[pulumi.Input['StudioComponentInitializationScriptRunContext']]:
        """
        The method to use when running the initialization script.
        """
        return pulumi.get(self, "run_context")

    @run_context.setter
    def run_context(self, value: Optional[pulumi.Input['StudioComponentInitializationScriptRunContext']]):
        pulumi.set(self, "run_context", value)

    @property
    @pulumi.getter
    def script(self) -> Optional[pulumi.Input[str]]:
        """
        <p>The initialization script.</p>
        """
        return pulumi.get(self, "script")

    @script.setter
    def script(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "script", value)


if not MYPY:
    class StudioComponentLicenseServiceConfigurationArgsDict(TypedDict):
        """
        <p>The configuration for a license service that is associated with a studio
                    resource.</p>
        """
        endpoint: NotRequired[pulumi.Input[str]]
        """
        <p>The endpoint of the license service that is accessed by the studio component
                    resource.</p>
        """
elif False:
    StudioComponentLicenseServiceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StudioComponentLicenseServiceConfigurationArgs:
    def __init__(__self__, *,
                 endpoint: Optional[pulumi.Input[str]] = None):
        """
        <p>The configuration for a license service that is associated with a studio
                    resource.</p>
        :param pulumi.Input[str] endpoint: <p>The endpoint of the license service that is accessed by the studio component
                           resource.</p>
        """
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        <p>The endpoint of the license service that is accessed by the studio component
                    resource.</p>
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)


if not MYPY:
    class StudioComponentScriptParameterKeyValueArgsDict(TypedDict):
        """
        <p>A parameter for a studio component script, in the form of a key:value pair.</p>
        """
        key: NotRequired[pulumi.Input[str]]
        """
        <p>A script parameter key.</p>
        """
        value: NotRequired[pulumi.Input[str]]
        """
        <p>A script parameter value.</p>
        """
elif False:
    StudioComponentScriptParameterKeyValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StudioComponentScriptParameterKeyValueArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        <p>A parameter for a studio component script, in the form of a key:value pair.</p>
        :param pulumi.Input[str] key: <p>A script parameter key.</p>
        :param pulumi.Input[str] value: <p>A script parameter value.</p>
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        <p>A script parameter key.</p>
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        <p>A script parameter value.</p>
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class StudioComponentSharedFileSystemConfigurationArgsDict(TypedDict):
        """
        <p>The configuration for a shared file storage system that is associated with a studio
                    resource.</p>
        """
        endpoint: NotRequired[pulumi.Input[str]]
        """
        <p>The endpoint of the shared file system that is accessed by the studio component
                    resource.</p>
        """
        file_system_id: NotRequired[pulumi.Input[str]]
        """
        <p>The unique identifier for a file system.</p>
        """
        linux_mount_point: NotRequired[pulumi.Input[str]]
        """
        <p>The mount location for a shared file system on a Linux virtual workstation.</p>
        """
        share_name: NotRequired[pulumi.Input[str]]
        """
        <p>The name of the file share.</p>
        """
        windows_mount_drive: NotRequired[pulumi.Input[str]]
        """
        <p>The mount location for a shared file system on a Windows virtual workstation.</p>
        """
elif False:
    StudioComponentSharedFileSystemConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StudioComponentSharedFileSystemConfigurationArgs:
    def __init__(__self__, *,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 file_system_id: Optional[pulumi.Input[str]] = None,
                 linux_mount_point: Optional[pulumi.Input[str]] = None,
                 share_name: Optional[pulumi.Input[str]] = None,
                 windows_mount_drive: Optional[pulumi.Input[str]] = None):
        """
        <p>The configuration for a shared file storage system that is associated with a studio
                    resource.</p>
        :param pulumi.Input[str] endpoint: <p>The endpoint of the shared file system that is accessed by the studio component
                           resource.</p>
        :param pulumi.Input[str] file_system_id: <p>The unique identifier for a file system.</p>
        :param pulumi.Input[str] linux_mount_point: <p>The mount location for a shared file system on a Linux virtual workstation.</p>
        :param pulumi.Input[str] share_name: <p>The name of the file share.</p>
        :param pulumi.Input[str] windows_mount_drive: <p>The mount location for a shared file system on a Windows virtual workstation.</p>
        """
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if file_system_id is not None:
            pulumi.set(__self__, "file_system_id", file_system_id)
        if linux_mount_point is not None:
            pulumi.set(__self__, "linux_mount_point", linux_mount_point)
        if share_name is not None:
            pulumi.set(__self__, "share_name", share_name)
        if windows_mount_drive is not None:
            pulumi.set(__self__, "windows_mount_drive", windows_mount_drive)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        <p>The endpoint of the shared file system that is accessed by the studio component
                    resource.</p>
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="fileSystemId")
    def file_system_id(self) -> Optional[pulumi.Input[str]]:
        """
        <p>The unique identifier for a file system.</p>
        """
        return pulumi.get(self, "file_system_id")

    @file_system_id.setter
    def file_system_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_system_id", value)

    @property
    @pulumi.getter(name="linuxMountPoint")
    def linux_mount_point(self) -> Optional[pulumi.Input[str]]:
        """
        <p>The mount location for a shared file system on a Linux virtual workstation.</p>
        """
        return pulumi.get(self, "linux_mount_point")

    @linux_mount_point.setter
    def linux_mount_point(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "linux_mount_point", value)

    @property
    @pulumi.getter(name="shareName")
    def share_name(self) -> Optional[pulumi.Input[str]]:
        """
        <p>The name of the file share.</p>
        """
        return pulumi.get(self, "share_name")

    @share_name.setter
    def share_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "share_name", value)

    @property
    @pulumi.getter(name="windowsMountDrive")
    def windows_mount_drive(self) -> Optional[pulumi.Input[str]]:
        """
        <p>The mount location for a shared file system on a Windows virtual workstation.</p>
        """
        return pulumi.get(self, "windows_mount_drive")

    @windows_mount_drive.setter
    def windows_mount_drive(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "windows_mount_drive", value)


if not MYPY:
    class StudioEncryptionConfigurationArgsDict(TypedDict):
        """
        <p>Configuration of the encryption method that is used for the studio.</p>
        """
        key_type: pulumi.Input['StudioEncryptionConfigurationKeyType']
        """
        The type of KMS key that is used to encrypt studio data.
        """
        key_arn: NotRequired[pulumi.Input[str]]
        """
        <p>The ARN for a KMS key that is used to encrypt studio data.</p>
        """
elif False:
    StudioEncryptionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StudioEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 key_type: pulumi.Input['StudioEncryptionConfigurationKeyType'],
                 key_arn: Optional[pulumi.Input[str]] = None):
        """
        <p>Configuration of the encryption method that is used for the studio.</p>
        :param pulumi.Input['StudioEncryptionConfigurationKeyType'] key_type: The type of KMS key that is used to encrypt studio data.
        :param pulumi.Input[str] key_arn: <p>The ARN for a KMS key that is used to encrypt studio data.</p>
        """
        pulumi.set(__self__, "key_type", key_type)
        if key_arn is not None:
            pulumi.set(__self__, "key_arn", key_arn)

    @property
    @pulumi.getter(name="keyType")
    def key_type(self) -> pulumi.Input['StudioEncryptionConfigurationKeyType']:
        """
        The type of KMS key that is used to encrypt studio data.
        """
        return pulumi.get(self, "key_type")

    @key_type.setter
    def key_type(self, value: pulumi.Input['StudioEncryptionConfigurationKeyType']):
        pulumi.set(self, "key_type", value)

    @property
    @pulumi.getter(name="keyArn")
    def key_arn(self) -> Optional[pulumi.Input[str]]:
        """
        <p>The ARN for a KMS key that is used to encrypt studio data.</p>
        """
        return pulumi.get(self, "key_arn")

    @key_arn.setter
    def key_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_arn", value)


