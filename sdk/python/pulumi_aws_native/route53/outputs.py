# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'CidrCollectionLocation',
    'HealthCheckAlarmIdentifier',
    'HealthCheckConfigProperties',
    'HealthCheckTag',
    'HostedZoneConfig',
    'HostedZoneQueryLoggingConfig',
    'HostedZoneTag',
    'HostedZoneVpc',
    'RecordSetAliasTarget',
    'RecordSetCidrRoutingConfig',
    'RecordSetGeoLocation',
    'RecordSetGroupAliasTarget',
    'RecordSetGroupCidrRoutingConfig',
    'RecordSetGroupGeoLocation',
    'RecordSetGroupRecordSet',
]

@pulumi.output_type
class CidrCollectionLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cidrList":
            suggest = "cidr_list"
        elif key == "locationName":
            suggest = "location_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CidrCollectionLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CidrCollectionLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CidrCollectionLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr_list: Sequence[str],
                 location_name: str):
        """
        :param Sequence[str] cidr_list: A list of CIDR blocks.
        :param str location_name: The name of the location that is associated with the CIDR collection.
        """
        CidrCollectionLocation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cidr_list=cidr_list,
            location_name=location_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cidr_list: Sequence[str],
             location_name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cidr_list", cidr_list)
        _setter("location_name", location_name)

    @property
    @pulumi.getter(name="cidrList")
    def cidr_list(self) -> Sequence[str]:
        """
        A list of CIDR blocks.
        """
        return pulumi.get(self, "cidr_list")

    @property
    @pulumi.getter(name="locationName")
    def location_name(self) -> str:
        """
        The name of the location that is associated with the CIDR collection.
        """
        return pulumi.get(self, "location_name")


@pulumi.output_type
class HealthCheckAlarmIdentifier(dict):
    """
    A complex type that identifies the CloudWatch alarm that you want Amazon Route 53 health checkers to use to determine whether the specified health check is healthy.
    """
    def __init__(__self__, *,
                 name: str,
                 region: str):
        """
        A complex type that identifies the CloudWatch alarm that you want Amazon Route 53 health checkers to use to determine whether the specified health check is healthy.
        :param str name: The name of the CloudWatch alarm that you want Amazon Route 53 health checkers to use to determine whether this health check is healthy.
        :param str region: For the CloudWatch alarm that you want Route 53 health checkers to use to determine whether this health check is healthy, the region that the alarm was created in.
        """
        HealthCheckAlarmIdentifier._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             region: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("region", region)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the CloudWatch alarm that you want Amazon Route 53 health checkers to use to determine whether this health check is healthy.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        For the CloudWatch alarm that you want Route 53 health checkers to use to determine whether this health check is healthy, the region that the alarm was created in.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class HealthCheckConfigProperties(dict):
    """
    A complex type that contains information about the health check.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alarmIdentifier":
            suggest = "alarm_identifier"
        elif key == "childHealthChecks":
            suggest = "child_health_checks"
        elif key == "enableSni":
            suggest = "enable_sni"
        elif key == "failureThreshold":
            suggest = "failure_threshold"
        elif key == "fullyQualifiedDomainName":
            suggest = "fully_qualified_domain_name"
        elif key == "healthThreshold":
            suggest = "health_threshold"
        elif key == "insufficientDataHealthStatus":
            suggest = "insufficient_data_health_status"
        elif key == "ipAddress":
            suggest = "ip_address"
        elif key == "measureLatency":
            suggest = "measure_latency"
        elif key == "requestInterval":
            suggest = "request_interval"
        elif key == "resourcePath":
            suggest = "resource_path"
        elif key == "routingControlArn":
            suggest = "routing_control_arn"
        elif key == "searchString":
            suggest = "search_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HealthCheckConfigProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HealthCheckConfigProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HealthCheckConfigProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: 'HealthCheckConfigPropertiesType',
                 alarm_identifier: Optional['outputs.HealthCheckAlarmIdentifier'] = None,
                 child_health_checks: Optional[Sequence[str]] = None,
                 enable_sni: Optional[bool] = None,
                 failure_threshold: Optional[int] = None,
                 fully_qualified_domain_name: Optional[str] = None,
                 health_threshold: Optional[int] = None,
                 insufficient_data_health_status: Optional['HealthCheckConfigPropertiesInsufficientDataHealthStatus'] = None,
                 inverted: Optional[bool] = None,
                 ip_address: Optional[str] = None,
                 measure_latency: Optional[bool] = None,
                 port: Optional[int] = None,
                 regions: Optional[Sequence[str]] = None,
                 request_interval: Optional[int] = None,
                 resource_path: Optional[str] = None,
                 routing_control_arn: Optional[str] = None,
                 search_string: Optional[str] = None):
        """
        A complex type that contains information about the health check.
        """
        HealthCheckConfigProperties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            alarm_identifier=alarm_identifier,
            child_health_checks=child_health_checks,
            enable_sni=enable_sni,
            failure_threshold=failure_threshold,
            fully_qualified_domain_name=fully_qualified_domain_name,
            health_threshold=health_threshold,
            insufficient_data_health_status=insufficient_data_health_status,
            inverted=inverted,
            ip_address=ip_address,
            measure_latency=measure_latency,
            port=port,
            regions=regions,
            request_interval=request_interval,
            resource_path=resource_path,
            routing_control_arn=routing_control_arn,
            search_string=search_string,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: 'HealthCheckConfigPropertiesType',
             alarm_identifier: Optional['outputs.HealthCheckAlarmIdentifier'] = None,
             child_health_checks: Optional[Sequence[str]] = None,
             enable_sni: Optional[bool] = None,
             failure_threshold: Optional[int] = None,
             fully_qualified_domain_name: Optional[str] = None,
             health_threshold: Optional[int] = None,
             insufficient_data_health_status: Optional['HealthCheckConfigPropertiesInsufficientDataHealthStatus'] = None,
             inverted: Optional[bool] = None,
             ip_address: Optional[str] = None,
             measure_latency: Optional[bool] = None,
             port: Optional[int] = None,
             regions: Optional[Sequence[str]] = None,
             request_interval: Optional[int] = None,
             resource_path: Optional[str] = None,
             routing_control_arn: Optional[str] = None,
             search_string: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if alarm_identifier is not None:
            _setter("alarm_identifier", alarm_identifier)
        if child_health_checks is not None:
            _setter("child_health_checks", child_health_checks)
        if enable_sni is not None:
            _setter("enable_sni", enable_sni)
        if failure_threshold is not None:
            _setter("failure_threshold", failure_threshold)
        if fully_qualified_domain_name is not None:
            _setter("fully_qualified_domain_name", fully_qualified_domain_name)
        if health_threshold is not None:
            _setter("health_threshold", health_threshold)
        if insufficient_data_health_status is not None:
            _setter("insufficient_data_health_status", insufficient_data_health_status)
        if inverted is not None:
            _setter("inverted", inverted)
        if ip_address is not None:
            _setter("ip_address", ip_address)
        if measure_latency is not None:
            _setter("measure_latency", measure_latency)
        if port is not None:
            _setter("port", port)
        if regions is not None:
            _setter("regions", regions)
        if request_interval is not None:
            _setter("request_interval", request_interval)
        if resource_path is not None:
            _setter("resource_path", resource_path)
        if routing_control_arn is not None:
            _setter("routing_control_arn", routing_control_arn)
        if search_string is not None:
            _setter("search_string", search_string)

    @property
    @pulumi.getter
    def type(self) -> 'HealthCheckConfigPropertiesType':
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="alarmIdentifier")
    def alarm_identifier(self) -> Optional['outputs.HealthCheckAlarmIdentifier']:
        return pulumi.get(self, "alarm_identifier")

    @property
    @pulumi.getter(name="childHealthChecks")
    def child_health_checks(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "child_health_checks")

    @property
    @pulumi.getter(name="enableSni")
    def enable_sni(self) -> Optional[bool]:
        return pulumi.get(self, "enable_sni")

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter(name="fullyQualifiedDomainName")
    def fully_qualified_domain_name(self) -> Optional[str]:
        return pulumi.get(self, "fully_qualified_domain_name")

    @property
    @pulumi.getter(name="healthThreshold")
    def health_threshold(self) -> Optional[int]:
        return pulumi.get(self, "health_threshold")

    @property
    @pulumi.getter(name="insufficientDataHealthStatus")
    def insufficient_data_health_status(self) -> Optional['HealthCheckConfigPropertiesInsufficientDataHealthStatus']:
        return pulumi.get(self, "insufficient_data_health_status")

    @property
    @pulumi.getter
    def inverted(self) -> Optional[bool]:
        return pulumi.get(self, "inverted")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="measureLatency")
    def measure_latency(self) -> Optional[bool]:
        return pulumi.get(self, "measure_latency")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def regions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "regions")

    @property
    @pulumi.getter(name="requestInterval")
    def request_interval(self) -> Optional[int]:
        return pulumi.get(self, "request_interval")

    @property
    @pulumi.getter(name="resourcePath")
    def resource_path(self) -> Optional[str]:
        return pulumi.get(self, "resource_path")

    @property
    @pulumi.getter(name="routingControlArn")
    def routing_control_arn(self) -> Optional[str]:
        return pulumi.get(self, "routing_control_arn")

    @property
    @pulumi.getter(name="searchString")
    def search_string(self) -> Optional[str]:
        return pulumi.get(self, "search_string")


@pulumi.output_type
class HealthCheckTag(dict):
    """
    A key-value pair to associate with a resource.
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        A key-value pair to associate with a resource.
        :param str key: The key name of the tag.
        :param str value: The value for the tag.
        """
        HealthCheckTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key name of the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the tag.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostedZoneConfig(dict):
    """
    A complex type that contains an optional comment.

    If you don't want to specify a comment, omit the HostedZoneConfig and Comment elements.
    """
    def __init__(__self__, *,
                 comment: Optional[str] = None):
        """
        A complex type that contains an optional comment.

        If you don't want to specify a comment, omit the HostedZoneConfig and Comment elements.
        :param str comment: Any comments that you want to include about the hosted zone.
        """
        HostedZoneConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comment=comment,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comment: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if comment is not None:
            _setter("comment", comment)

    @property
    @pulumi.getter
    def comment(self) -> Optional[str]:
        """
        Any comments that you want to include about the hosted zone.
        """
        return pulumi.get(self, "comment")


@pulumi.output_type
class HostedZoneQueryLoggingConfig(dict):
    """
    A complex type that contains information about a configuration for DNS query logging.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudWatchLogsLogGroupArn":
            suggest = "cloud_watch_logs_log_group_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostedZoneQueryLoggingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostedZoneQueryLoggingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostedZoneQueryLoggingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_watch_logs_log_group_arn: str):
        """
        A complex type that contains information about a configuration for DNS query logging.
        :param str cloud_watch_logs_log_group_arn: The Amazon Resource Name (ARN) of the CloudWatch Logs log group that Amazon Route 53 is publishing logs to.
        """
        HostedZoneQueryLoggingConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_watch_logs_log_group_arn=cloud_watch_logs_log_group_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_watch_logs_log_group_arn: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cloud_watch_logs_log_group_arn", cloud_watch_logs_log_group_arn)

    @property
    @pulumi.getter(name="cloudWatchLogsLogGroupArn")
    def cloud_watch_logs_log_group_arn(self) -> str:
        """
        The Amazon Resource Name (ARN) of the CloudWatch Logs log group that Amazon Route 53 is publishing logs to.
        """
        return pulumi.get(self, "cloud_watch_logs_log_group_arn")


@pulumi.output_type
class HostedZoneTag(dict):
    """
    A complex type that contains information about a tag that you want to add or edit for the specified health check or hosted zone.
    """
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        A complex type that contains information about a tag that you want to add or edit for the specified health check or hosted zone.
        :param str key: The key name of the tag.
        :param str value: The value for the tag.
        """
        HostedZoneTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        The key name of the tag.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value for the tag.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HostedZoneVpc(dict):
    """
    A complex type that contains information about an Amazon VPC. Route 53 Resolver uses the records in the private hosted zone to route traffic in that VPC.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vpcId":
            suggest = "vpc_id"
        elif key == "vpcRegion":
            suggest = "vpc_region"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HostedZoneVpc. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HostedZoneVpc.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HostedZoneVpc.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 vpc_id: str,
                 vpc_region: str):
        """
        A complex type that contains information about an Amazon VPC. Route 53 Resolver uses the records in the private hosted zone to route traffic in that VPC.
        :param str vpc_id: The ID of an Amazon VPC.
        :param str vpc_region: The region that an Amazon VPC was created in. See https://docs.aws.amazon.com/general/latest/gr/rande.html for a list of up to date regions.
        """
        HostedZoneVpc._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            vpc_id=vpc_id,
            vpc_region=vpc_region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             vpc_id: str,
             vpc_region: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("vpc_id", vpc_id)
        _setter("vpc_region", vpc_region)

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        """
        The ID of an Amazon VPC.
        """
        return pulumi.get(self, "vpc_id")

    @property
    @pulumi.getter(name="vpcRegion")
    def vpc_region(self) -> str:
        """
        The region that an Amazon VPC was created in. See https://docs.aws.amazon.com/general/latest/gr/rande.html for a list of up to date regions.
        """
        return pulumi.get(self, "vpc_region")


@pulumi.output_type
class RecordSetAliasTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsName":
            suggest = "dns_name"
        elif key == "hostedZoneId":
            suggest = "hosted_zone_id"
        elif key == "evaluateTargetHealth":
            suggest = "evaluate_target_health"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecordSetAliasTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecordSetAliasTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecordSetAliasTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_name: str,
                 hosted_zone_id: str,
                 evaluate_target_health: Optional[bool] = None):
        RecordSetAliasTarget._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dns_name=dns_name,
            hosted_zone_id=hosted_zone_id,
            evaluate_target_health=evaluate_target_health,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dns_name: str,
             hosted_zone_id: str,
             evaluate_target_health: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("dns_name", dns_name)
        _setter("hosted_zone_id", hosted_zone_id)
        if evaluate_target_health is not None:
            _setter("evaluate_target_health", evaluate_target_health)

    @property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> str:
        return pulumi.get(self, "dns_name")

    @property
    @pulumi.getter(name="hostedZoneId")
    def hosted_zone_id(self) -> str:
        return pulumi.get(self, "hosted_zone_id")

    @property
    @pulumi.getter(name="evaluateTargetHealth")
    def evaluate_target_health(self) -> Optional[bool]:
        return pulumi.get(self, "evaluate_target_health")


@pulumi.output_type
class RecordSetCidrRoutingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "collectionId":
            suggest = "collection_id"
        elif key == "locationName":
            suggest = "location_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecordSetCidrRoutingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecordSetCidrRoutingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecordSetCidrRoutingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collection_id: str,
                 location_name: str):
        RecordSetCidrRoutingConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            collection_id=collection_id,
            location_name=location_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             collection_id: str,
             location_name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("collection_id", collection_id)
        _setter("location_name", location_name)

    @property
    @pulumi.getter(name="collectionId")
    def collection_id(self) -> str:
        return pulumi.get(self, "collection_id")

    @property
    @pulumi.getter(name="locationName")
    def location_name(self) -> str:
        return pulumi.get(self, "location_name")


@pulumi.output_type
class RecordSetGeoLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "continentCode":
            suggest = "continent_code"
        elif key == "countryCode":
            suggest = "country_code"
        elif key == "subdivisionCode":
            suggest = "subdivision_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecordSetGeoLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecordSetGeoLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecordSetGeoLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 continent_code: Optional[str] = None,
                 country_code: Optional[str] = None,
                 subdivision_code: Optional[str] = None):
        RecordSetGeoLocation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            continent_code=continent_code,
            country_code=country_code,
            subdivision_code=subdivision_code,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             continent_code: Optional[str] = None,
             country_code: Optional[str] = None,
             subdivision_code: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if continent_code is not None:
            _setter("continent_code", continent_code)
        if country_code is not None:
            _setter("country_code", country_code)
        if subdivision_code is not None:
            _setter("subdivision_code", subdivision_code)

    @property
    @pulumi.getter(name="continentCode")
    def continent_code(self) -> Optional[str]:
        return pulumi.get(self, "continent_code")

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> Optional[str]:
        return pulumi.get(self, "country_code")

    @property
    @pulumi.getter(name="subdivisionCode")
    def subdivision_code(self) -> Optional[str]:
        return pulumi.get(self, "subdivision_code")


@pulumi.output_type
class RecordSetGroupAliasTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsName":
            suggest = "dns_name"
        elif key == "hostedZoneId":
            suggest = "hosted_zone_id"
        elif key == "evaluateTargetHealth":
            suggest = "evaluate_target_health"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecordSetGroupAliasTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecordSetGroupAliasTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecordSetGroupAliasTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_name: str,
                 hosted_zone_id: str,
                 evaluate_target_health: Optional[bool] = None):
        RecordSetGroupAliasTarget._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dns_name=dns_name,
            hosted_zone_id=hosted_zone_id,
            evaluate_target_health=evaluate_target_health,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dns_name: str,
             hosted_zone_id: str,
             evaluate_target_health: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("dns_name", dns_name)
        _setter("hosted_zone_id", hosted_zone_id)
        if evaluate_target_health is not None:
            _setter("evaluate_target_health", evaluate_target_health)

    @property
    @pulumi.getter(name="dnsName")
    def dns_name(self) -> str:
        return pulumi.get(self, "dns_name")

    @property
    @pulumi.getter(name="hostedZoneId")
    def hosted_zone_id(self) -> str:
        return pulumi.get(self, "hosted_zone_id")

    @property
    @pulumi.getter(name="evaluateTargetHealth")
    def evaluate_target_health(self) -> Optional[bool]:
        return pulumi.get(self, "evaluate_target_health")


@pulumi.output_type
class RecordSetGroupCidrRoutingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "collectionId":
            suggest = "collection_id"
        elif key == "locationName":
            suggest = "location_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecordSetGroupCidrRoutingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecordSetGroupCidrRoutingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecordSetGroupCidrRoutingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collection_id: str,
                 location_name: str):
        RecordSetGroupCidrRoutingConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            collection_id=collection_id,
            location_name=location_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             collection_id: str,
             location_name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("collection_id", collection_id)
        _setter("location_name", location_name)

    @property
    @pulumi.getter(name="collectionId")
    def collection_id(self) -> str:
        return pulumi.get(self, "collection_id")

    @property
    @pulumi.getter(name="locationName")
    def location_name(self) -> str:
        return pulumi.get(self, "location_name")


@pulumi.output_type
class RecordSetGroupGeoLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "continentCode":
            suggest = "continent_code"
        elif key == "countryCode":
            suggest = "country_code"
        elif key == "subdivisionCode":
            suggest = "subdivision_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecordSetGroupGeoLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecordSetGroupGeoLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecordSetGroupGeoLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 continent_code: Optional[str] = None,
                 country_code: Optional[str] = None,
                 subdivision_code: Optional[str] = None):
        RecordSetGroupGeoLocation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            continent_code=continent_code,
            country_code=country_code,
            subdivision_code=subdivision_code,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             continent_code: Optional[str] = None,
             country_code: Optional[str] = None,
             subdivision_code: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if continent_code is not None:
            _setter("continent_code", continent_code)
        if country_code is not None:
            _setter("country_code", country_code)
        if subdivision_code is not None:
            _setter("subdivision_code", subdivision_code)

    @property
    @pulumi.getter(name="continentCode")
    def continent_code(self) -> Optional[str]:
        return pulumi.get(self, "continent_code")

    @property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> Optional[str]:
        return pulumi.get(self, "country_code")

    @property
    @pulumi.getter(name="subdivisionCode")
    def subdivision_code(self) -> Optional[str]:
        return pulumi.get(self, "subdivision_code")


@pulumi.output_type
class RecordSetGroupRecordSet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aliasTarget":
            suggest = "alias_target"
        elif key == "cidrRoutingConfig":
            suggest = "cidr_routing_config"
        elif key == "geoLocation":
            suggest = "geo_location"
        elif key == "healthCheckId":
            suggest = "health_check_id"
        elif key == "hostedZoneId":
            suggest = "hosted_zone_id"
        elif key == "hostedZoneName":
            suggest = "hosted_zone_name"
        elif key == "multiValueAnswer":
            suggest = "multi_value_answer"
        elif key == "resourceRecords":
            suggest = "resource_records"
        elif key == "setIdentifier":
            suggest = "set_identifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecordSetGroupRecordSet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecordSetGroupRecordSet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecordSetGroupRecordSet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 type: str,
                 alias_target: Optional['outputs.RecordSetGroupAliasTarget'] = None,
                 cidr_routing_config: Optional['outputs.RecordSetGroupCidrRoutingConfig'] = None,
                 failover: Optional[str] = None,
                 geo_location: Optional['outputs.RecordSetGroupGeoLocation'] = None,
                 health_check_id: Optional[str] = None,
                 hosted_zone_id: Optional[str] = None,
                 hosted_zone_name: Optional[str] = None,
                 multi_value_answer: Optional[bool] = None,
                 region: Optional[str] = None,
                 resource_records: Optional[Sequence[str]] = None,
                 set_identifier: Optional[str] = None,
                 ttl: Optional[str] = None,
                 weight: Optional[int] = None):
        RecordSetGroupRecordSet._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            type=type,
            alias_target=alias_target,
            cidr_routing_config=cidr_routing_config,
            failover=failover,
            geo_location=geo_location,
            health_check_id=health_check_id,
            hosted_zone_id=hosted_zone_id,
            hosted_zone_name=hosted_zone_name,
            multi_value_answer=multi_value_answer,
            region=region,
            resource_records=resource_records,
            set_identifier=set_identifier,
            ttl=ttl,
            weight=weight,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             type: str,
             alias_target: Optional['outputs.RecordSetGroupAliasTarget'] = None,
             cidr_routing_config: Optional['outputs.RecordSetGroupCidrRoutingConfig'] = None,
             failover: Optional[str] = None,
             geo_location: Optional['outputs.RecordSetGroupGeoLocation'] = None,
             health_check_id: Optional[str] = None,
             hosted_zone_id: Optional[str] = None,
             hosted_zone_name: Optional[str] = None,
             multi_value_answer: Optional[bool] = None,
             region: Optional[str] = None,
             resource_records: Optional[Sequence[str]] = None,
             set_identifier: Optional[str] = None,
             ttl: Optional[str] = None,
             weight: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("type", type)
        if alias_target is not None:
            _setter("alias_target", alias_target)
        if cidr_routing_config is not None:
            _setter("cidr_routing_config", cidr_routing_config)
        if failover is not None:
            _setter("failover", failover)
        if geo_location is not None:
            _setter("geo_location", geo_location)
        if health_check_id is not None:
            _setter("health_check_id", health_check_id)
        if hosted_zone_id is not None:
            _setter("hosted_zone_id", hosted_zone_id)
        if hosted_zone_name is not None:
            _setter("hosted_zone_name", hosted_zone_name)
        if multi_value_answer is not None:
            _setter("multi_value_answer", multi_value_answer)
        if region is not None:
            _setter("region", region)
        if resource_records is not None:
            _setter("resource_records", resource_records)
        if set_identifier is not None:
            _setter("set_identifier", set_identifier)
        if ttl is not None:
            _setter("ttl", ttl)
        if weight is not None:
            _setter("weight", weight)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="aliasTarget")
    def alias_target(self) -> Optional['outputs.RecordSetGroupAliasTarget']:
        return pulumi.get(self, "alias_target")

    @property
    @pulumi.getter(name="cidrRoutingConfig")
    def cidr_routing_config(self) -> Optional['outputs.RecordSetGroupCidrRoutingConfig']:
        return pulumi.get(self, "cidr_routing_config")

    @property
    @pulumi.getter
    def failover(self) -> Optional[str]:
        return pulumi.get(self, "failover")

    @property
    @pulumi.getter(name="geoLocation")
    def geo_location(self) -> Optional['outputs.RecordSetGroupGeoLocation']:
        return pulumi.get(self, "geo_location")

    @property
    @pulumi.getter(name="healthCheckId")
    def health_check_id(self) -> Optional[str]:
        return pulumi.get(self, "health_check_id")

    @property
    @pulumi.getter(name="hostedZoneId")
    def hosted_zone_id(self) -> Optional[str]:
        return pulumi.get(self, "hosted_zone_id")

    @property
    @pulumi.getter(name="hostedZoneName")
    def hosted_zone_name(self) -> Optional[str]:
        return pulumi.get(self, "hosted_zone_name")

    @property
    @pulumi.getter(name="multiValueAnswer")
    def multi_value_answer(self) -> Optional[bool]:
        return pulumi.get(self, "multi_value_answer")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="resourceRecords")
    def resource_records(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "resource_records")

    @property
    @pulumi.getter(name="setIdentifier")
    def set_identifier(self) -> Optional[str]:
        return pulumi.get(self, "set_identifier")

    @property
    @pulumi.getter
    def ttl(self) -> Optional[str]:
        return pulumi.get(self, "ttl")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")


