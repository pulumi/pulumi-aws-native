# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'GetRecordSetResult',
    'AwaitableGetRecordSetResult',
    'get_record_set',
    'get_record_set_output',
]

@pulumi.output_type
class GetRecordSetResult:
    def __init__(__self__, alias_target=None, cidr_routing_config=None, comment=None, failover=None, geo_location=None, health_check_id=None, id=None, multi_value_answer=None, region=None, resource_records=None, set_identifier=None, t_tl=None, type=None, weight=None):
        if alias_target and not isinstance(alias_target, dict):
            raise TypeError("Expected argument 'alias_target' to be a dict")
        pulumi.set(__self__, "alias_target", alias_target)
        if cidr_routing_config and not isinstance(cidr_routing_config, dict):
            raise TypeError("Expected argument 'cidr_routing_config' to be a dict")
        pulumi.set(__self__, "cidr_routing_config", cidr_routing_config)
        if comment and not isinstance(comment, str):
            raise TypeError("Expected argument 'comment' to be a str")
        pulumi.set(__self__, "comment", comment)
        if failover and not isinstance(failover, str):
            raise TypeError("Expected argument 'failover' to be a str")
        pulumi.set(__self__, "failover", failover)
        if geo_location and not isinstance(geo_location, dict):
            raise TypeError("Expected argument 'geo_location' to be a dict")
        pulumi.set(__self__, "geo_location", geo_location)
        if health_check_id and not isinstance(health_check_id, str):
            raise TypeError("Expected argument 'health_check_id' to be a str")
        pulumi.set(__self__, "health_check_id", health_check_id)
        if id and not isinstance(id, str):
            raise TypeError("Expected argument 'id' to be a str")
        pulumi.set(__self__, "id", id)
        if multi_value_answer and not isinstance(multi_value_answer, bool):
            raise TypeError("Expected argument 'multi_value_answer' to be a bool")
        pulumi.set(__self__, "multi_value_answer", multi_value_answer)
        if region and not isinstance(region, str):
            raise TypeError("Expected argument 'region' to be a str")
        pulumi.set(__self__, "region", region)
        if resource_records and not isinstance(resource_records, list):
            raise TypeError("Expected argument 'resource_records' to be a list")
        pulumi.set(__self__, "resource_records", resource_records)
        if set_identifier and not isinstance(set_identifier, str):
            raise TypeError("Expected argument 'set_identifier' to be a str")
        pulumi.set(__self__, "set_identifier", set_identifier)
        if t_tl and not isinstance(t_tl, str):
            raise TypeError("Expected argument 't_tl' to be a str")
        pulumi.set(__self__, "t_tl", t_tl)
        if type and not isinstance(type, str):
            raise TypeError("Expected argument 'type' to be a str")
        pulumi.set(__self__, "type", type)
        if weight and not isinstance(weight, int):
            raise TypeError("Expected argument 'weight' to be a int")
        pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="aliasTarget")
    def alias_target(self) -> Optional['outputs.RecordSetAliasTarget']:
        return pulumi.get(self, "alias_target")

    @property
    @pulumi.getter(name="cidrRoutingConfig")
    def cidr_routing_config(self) -> Optional['outputs.RecordSetCidrRoutingConfig']:
        return pulumi.get(self, "cidr_routing_config")

    @property
    @pulumi.getter
    def comment(self) -> Optional[str]:
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter
    def failover(self) -> Optional[str]:
        return pulumi.get(self, "failover")

    @property
    @pulumi.getter(name="geoLocation")
    def geo_location(self) -> Optional['outputs.RecordSetGeoLocation']:
        return pulumi.get(self, "geo_location")

    @property
    @pulumi.getter(name="healthCheckId")
    def health_check_id(self) -> Optional[str]:
        return pulumi.get(self, "health_check_id")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="multiValueAnswer")
    def multi_value_answer(self) -> Optional[bool]:
        return pulumi.get(self, "multi_value_answer")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="resourceRecords")
    def resource_records(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "resource_records")

    @property
    @pulumi.getter(name="setIdentifier")
    def set_identifier(self) -> Optional[str]:
        return pulumi.get(self, "set_identifier")

    @property
    @pulumi.getter(name="tTL")
    def t_tl(self) -> Optional[str]:
        return pulumi.get(self, "t_tl")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        return pulumi.get(self, "weight")


class AwaitableGetRecordSetResult(GetRecordSetResult):
    # pylint: disable=using-constant-test
    def __await__(self):
        if False:
            yield self
        return GetRecordSetResult(
            alias_target=self.alias_target,
            cidr_routing_config=self.cidr_routing_config,
            comment=self.comment,
            failover=self.failover,
            geo_location=self.geo_location,
            health_check_id=self.health_check_id,
            id=self.id,
            multi_value_answer=self.multi_value_answer,
            region=self.region,
            resource_records=self.resource_records,
            set_identifier=self.set_identifier,
            t_tl=self.t_tl,
            type=self.type,
            weight=self.weight)


def get_record_set(id: Optional[str] = None,
                   opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetRecordSetResult:
    """
    Resource Type definition for AWS::Route53::RecordSet
    """
    __args__ = dict()
    __args__['id'] = id
    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke('aws-native:route53:getRecordSet', __args__, opts=opts, typ=GetRecordSetResult).value

    return AwaitableGetRecordSetResult(
        alias_target=__ret__.alias_target,
        cidr_routing_config=__ret__.cidr_routing_config,
        comment=__ret__.comment,
        failover=__ret__.failover,
        geo_location=__ret__.geo_location,
        health_check_id=__ret__.health_check_id,
        id=__ret__.id,
        multi_value_answer=__ret__.multi_value_answer,
        region=__ret__.region,
        resource_records=__ret__.resource_records,
        set_identifier=__ret__.set_identifier,
        t_tl=__ret__.t_tl,
        type=__ret__.type,
        weight=__ret__.weight)


@_utilities.lift_output_func(get_record_set)
def get_record_set_output(id: Optional[pulumi.Input[str]] = None,
                          opts: Optional[pulumi.InvokeOptions] = None) -> pulumi.Output[GetRecordSetResult]:
    """
    Resource Type definition for AWS::Route53::RecordSet
    """
    ...
