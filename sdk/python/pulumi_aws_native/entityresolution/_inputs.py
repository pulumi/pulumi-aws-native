# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from ._enums import *

__all__ = [
    'IdMappingWorkflowIdMappingIncrementalRunConfigArgs',
    'IdMappingWorkflowIdMappingIncrementalRunConfigArgsDict',
    'IdMappingWorkflowIdMappingRuleBasedPropertiesArgs',
    'IdMappingWorkflowIdMappingRuleBasedPropertiesArgsDict',
    'IdMappingWorkflowIdMappingTechniquesArgs',
    'IdMappingWorkflowIdMappingTechniquesArgsDict',
    'IdMappingWorkflowInputSourceArgs',
    'IdMappingWorkflowInputSourceArgsDict',
    'IdMappingWorkflowIntermediateSourceConfigurationArgs',
    'IdMappingWorkflowIntermediateSourceConfigurationArgsDict',
    'IdMappingWorkflowOutputSourceArgs',
    'IdMappingWorkflowOutputSourceArgsDict',
    'IdMappingWorkflowProviderPropertiesArgs',
    'IdMappingWorkflowProviderPropertiesArgsDict',
    'IdMappingWorkflowRuleArgs',
    'IdMappingWorkflowRuleArgsDict',
    'IdNamespaceIdMappingWorkflowPropertiesArgs',
    'IdNamespaceIdMappingWorkflowPropertiesArgsDict',
    'IdNamespaceInputSourceArgs',
    'IdNamespaceInputSourceArgsDict',
    'IdNamespaceNamespaceProviderPropertiesArgs',
    'IdNamespaceNamespaceProviderPropertiesArgsDict',
    'IdNamespaceNamespaceRuleBasedPropertiesArgs',
    'IdNamespaceNamespaceRuleBasedPropertiesArgsDict',
    'IdNamespaceRuleArgs',
    'IdNamespaceRuleArgsDict',
    'MatchingWorkflowIncrementalRunConfigArgs',
    'MatchingWorkflowIncrementalRunConfigArgsDict',
    'MatchingWorkflowInputSourceArgs',
    'MatchingWorkflowInputSourceArgsDict',
    'MatchingWorkflowIntermediateSourceConfigurationArgs',
    'MatchingWorkflowIntermediateSourceConfigurationArgsDict',
    'MatchingWorkflowOutputAttributeArgs',
    'MatchingWorkflowOutputAttributeArgsDict',
    'MatchingWorkflowOutputSourceArgs',
    'MatchingWorkflowOutputSourceArgsDict',
    'MatchingWorkflowProviderPropertiesArgs',
    'MatchingWorkflowProviderPropertiesArgsDict',
    'MatchingWorkflowResolutionTechniquesArgs',
    'MatchingWorkflowResolutionTechniquesArgsDict',
    'MatchingWorkflowRuleBasedPropertiesArgs',
    'MatchingWorkflowRuleBasedPropertiesArgsDict',
    'MatchingWorkflowRuleConditionPropertiesArgs',
    'MatchingWorkflowRuleConditionPropertiesArgsDict',
    'MatchingWorkflowRuleConditionArgs',
    'MatchingWorkflowRuleConditionArgsDict',
    'MatchingWorkflowRuleArgs',
    'MatchingWorkflowRuleArgsDict',
    'SchemaMappingSchemaInputAttributeArgs',
    'SchemaMappingSchemaInputAttributeArgsDict',
]

MYPY = False

if not MYPY:
    class IdMappingWorkflowIdMappingIncrementalRunConfigArgsDict(TypedDict):
        incremental_run_type: pulumi.Input['IdMappingWorkflowIdMappingIncrementalRunConfigIncrementalRunType']
elif False:
    IdMappingWorkflowIdMappingIncrementalRunConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdMappingWorkflowIdMappingIncrementalRunConfigArgs:
    def __init__(__self__, *,
                 incremental_run_type: pulumi.Input['IdMappingWorkflowIdMappingIncrementalRunConfigIncrementalRunType']):
        pulumi.set(__self__, "incremental_run_type", incremental_run_type)

    @_builtins.property
    @pulumi.getter(name="incrementalRunType")
    def incremental_run_type(self) -> pulumi.Input['IdMappingWorkflowIdMappingIncrementalRunConfigIncrementalRunType']:
        return pulumi.get(self, "incremental_run_type")

    @incremental_run_type.setter
    def incremental_run_type(self, value: pulumi.Input['IdMappingWorkflowIdMappingIncrementalRunConfigIncrementalRunType']):
        pulumi.set(self, "incremental_run_type", value)


if not MYPY:
    class IdMappingWorkflowIdMappingRuleBasedPropertiesArgsDict(TypedDict):
        attribute_matching_model: pulumi.Input['IdMappingWorkflowIdMappingRuleBasedPropertiesAttributeMatchingModel']
        """
        The comparison type. You can either choose `ONE_TO_ONE` or `MANY_TO_MANY` as the `attributeMatchingModel` .

        If you choose `ONE_TO_ONE` , the system can only match attributes if the sub-types are an exact match. For example, for the `Email` attribute type, the system will only consider it a match if the value of the `Email` field of Profile A matches the value of the `Email` field of Profile B.

        If you choose `MANY_TO_MANY` , the system can match attributes across the sub-types of an attribute type. For example, if the value of the `Email` field of Profile A matches the value of the `BusinessEmail` field of Profile B, the two profiles are matched on the `Email` attribute type.
        """
        record_matching_model: pulumi.Input['IdMappingWorkflowIdMappingRuleBasedPropertiesRecordMatchingModel']
        """
        The type of matching record that is allowed to be used in an ID mapping workflow.

        If the value is set to `ONE_SOURCE_TO_ONE_TARGET` , only one record in the source can be matched to the same record in the target.

        If the value is set to `MANY_SOURCE_TO_ONE_TARGET` , multiple records in the source can be matched to one record in the target.
        """
        rule_definition_type: NotRequired[pulumi.Input['IdMappingWorkflowIdMappingRuleBasedPropertiesRuleDefinitionType']]
        """
        The set of rules you can use in an ID mapping workflow. The limitations specified for the source or target to define the match rules must be compatible.
        """
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['IdMappingWorkflowRuleArgsDict']]]]
        """
        The rules that can be used for ID mapping.
        """
elif False:
    IdMappingWorkflowIdMappingRuleBasedPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdMappingWorkflowIdMappingRuleBasedPropertiesArgs:
    def __init__(__self__, *,
                 attribute_matching_model: pulumi.Input['IdMappingWorkflowIdMappingRuleBasedPropertiesAttributeMatchingModel'],
                 record_matching_model: pulumi.Input['IdMappingWorkflowIdMappingRuleBasedPropertiesRecordMatchingModel'],
                 rule_definition_type: Optional[pulumi.Input['IdMappingWorkflowIdMappingRuleBasedPropertiesRuleDefinitionType']] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['IdMappingWorkflowRuleArgs']]]] = None):
        """
        :param pulumi.Input['IdMappingWorkflowIdMappingRuleBasedPropertiesAttributeMatchingModel'] attribute_matching_model: The comparison type. You can either choose `ONE_TO_ONE` or `MANY_TO_MANY` as the `attributeMatchingModel` .
               
               If you choose `ONE_TO_ONE` , the system can only match attributes if the sub-types are an exact match. For example, for the `Email` attribute type, the system will only consider it a match if the value of the `Email` field of Profile A matches the value of the `Email` field of Profile B.
               
               If you choose `MANY_TO_MANY` , the system can match attributes across the sub-types of an attribute type. For example, if the value of the `Email` field of Profile A matches the value of the `BusinessEmail` field of Profile B, the two profiles are matched on the `Email` attribute type.
        :param pulumi.Input['IdMappingWorkflowIdMappingRuleBasedPropertiesRecordMatchingModel'] record_matching_model: The type of matching record that is allowed to be used in an ID mapping workflow.
               
               If the value is set to `ONE_SOURCE_TO_ONE_TARGET` , only one record in the source can be matched to the same record in the target.
               
               If the value is set to `MANY_SOURCE_TO_ONE_TARGET` , multiple records in the source can be matched to one record in the target.
        :param pulumi.Input['IdMappingWorkflowIdMappingRuleBasedPropertiesRuleDefinitionType'] rule_definition_type: The set of rules you can use in an ID mapping workflow. The limitations specified for the source or target to define the match rules must be compatible.
        :param pulumi.Input[Sequence[pulumi.Input['IdMappingWorkflowRuleArgs']]] rules: The rules that can be used for ID mapping.
        """
        pulumi.set(__self__, "attribute_matching_model", attribute_matching_model)
        pulumi.set(__self__, "record_matching_model", record_matching_model)
        if rule_definition_type is not None:
            pulumi.set(__self__, "rule_definition_type", rule_definition_type)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter(name="attributeMatchingModel")
    def attribute_matching_model(self) -> pulumi.Input['IdMappingWorkflowIdMappingRuleBasedPropertiesAttributeMatchingModel']:
        """
        The comparison type. You can either choose `ONE_TO_ONE` or `MANY_TO_MANY` as the `attributeMatchingModel` .

        If you choose `ONE_TO_ONE` , the system can only match attributes if the sub-types are an exact match. For example, for the `Email` attribute type, the system will only consider it a match if the value of the `Email` field of Profile A matches the value of the `Email` field of Profile B.

        If you choose `MANY_TO_MANY` , the system can match attributes across the sub-types of an attribute type. For example, if the value of the `Email` field of Profile A matches the value of the `BusinessEmail` field of Profile B, the two profiles are matched on the `Email` attribute type.
        """
        return pulumi.get(self, "attribute_matching_model")

    @attribute_matching_model.setter
    def attribute_matching_model(self, value: pulumi.Input['IdMappingWorkflowIdMappingRuleBasedPropertiesAttributeMatchingModel']):
        pulumi.set(self, "attribute_matching_model", value)

    @_builtins.property
    @pulumi.getter(name="recordMatchingModel")
    def record_matching_model(self) -> pulumi.Input['IdMappingWorkflowIdMappingRuleBasedPropertiesRecordMatchingModel']:
        """
        The type of matching record that is allowed to be used in an ID mapping workflow.

        If the value is set to `ONE_SOURCE_TO_ONE_TARGET` , only one record in the source can be matched to the same record in the target.

        If the value is set to `MANY_SOURCE_TO_ONE_TARGET` , multiple records in the source can be matched to one record in the target.
        """
        return pulumi.get(self, "record_matching_model")

    @record_matching_model.setter
    def record_matching_model(self, value: pulumi.Input['IdMappingWorkflowIdMappingRuleBasedPropertiesRecordMatchingModel']):
        pulumi.set(self, "record_matching_model", value)

    @_builtins.property
    @pulumi.getter(name="ruleDefinitionType")
    def rule_definition_type(self) -> Optional[pulumi.Input['IdMappingWorkflowIdMappingRuleBasedPropertiesRuleDefinitionType']]:
        """
        The set of rules you can use in an ID mapping workflow. The limitations specified for the source or target to define the match rules must be compatible.
        """
        return pulumi.get(self, "rule_definition_type")

    @rule_definition_type.setter
    def rule_definition_type(self, value: Optional[pulumi.Input['IdMappingWorkflowIdMappingRuleBasedPropertiesRuleDefinitionType']]):
        pulumi.set(self, "rule_definition_type", value)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IdMappingWorkflowRuleArgs']]]]:
        """
        The rules that can be used for ID mapping.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IdMappingWorkflowRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class IdMappingWorkflowIdMappingTechniquesArgsDict(TypedDict):
        id_mapping_type: NotRequired[pulumi.Input['IdMappingWorkflowIdMappingTechniquesIdMappingType']]
        """
        The type of ID mapping.
        """
        normalization_version: NotRequired[pulumi.Input[_builtins.str]]
        provider_properties: NotRequired[pulumi.Input['IdMappingWorkflowProviderPropertiesArgsDict']]
        """
        An object which defines any additional configurations required by the provider service.
        """
        rule_based_properties: NotRequired[pulumi.Input['IdMappingWorkflowIdMappingRuleBasedPropertiesArgsDict']]
        """
        An object which defines any additional configurations required by rule-based matching.
        """
elif False:
    IdMappingWorkflowIdMappingTechniquesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdMappingWorkflowIdMappingTechniquesArgs:
    def __init__(__self__, *,
                 id_mapping_type: Optional[pulumi.Input['IdMappingWorkflowIdMappingTechniquesIdMappingType']] = None,
                 normalization_version: Optional[pulumi.Input[_builtins.str]] = None,
                 provider_properties: Optional[pulumi.Input['IdMappingWorkflowProviderPropertiesArgs']] = None,
                 rule_based_properties: Optional[pulumi.Input['IdMappingWorkflowIdMappingRuleBasedPropertiesArgs']] = None):
        """
        :param pulumi.Input['IdMappingWorkflowIdMappingTechniquesIdMappingType'] id_mapping_type: The type of ID mapping.
        :param pulumi.Input['IdMappingWorkflowProviderPropertiesArgs'] provider_properties: An object which defines any additional configurations required by the provider service.
        :param pulumi.Input['IdMappingWorkflowIdMappingRuleBasedPropertiesArgs'] rule_based_properties: An object which defines any additional configurations required by rule-based matching.
        """
        if id_mapping_type is not None:
            pulumi.set(__self__, "id_mapping_type", id_mapping_type)
        if normalization_version is not None:
            pulumi.set(__self__, "normalization_version", normalization_version)
        if provider_properties is not None:
            pulumi.set(__self__, "provider_properties", provider_properties)
        if rule_based_properties is not None:
            pulumi.set(__self__, "rule_based_properties", rule_based_properties)

    @_builtins.property
    @pulumi.getter(name="idMappingType")
    def id_mapping_type(self) -> Optional[pulumi.Input['IdMappingWorkflowIdMappingTechniquesIdMappingType']]:
        """
        The type of ID mapping.
        """
        return pulumi.get(self, "id_mapping_type")

    @id_mapping_type.setter
    def id_mapping_type(self, value: Optional[pulumi.Input['IdMappingWorkflowIdMappingTechniquesIdMappingType']]):
        pulumi.set(self, "id_mapping_type", value)

    @_builtins.property
    @pulumi.getter(name="normalizationVersion")
    def normalization_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "normalization_version")

    @normalization_version.setter
    def normalization_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "normalization_version", value)

    @_builtins.property
    @pulumi.getter(name="providerProperties")
    def provider_properties(self) -> Optional[pulumi.Input['IdMappingWorkflowProviderPropertiesArgs']]:
        """
        An object which defines any additional configurations required by the provider service.
        """
        return pulumi.get(self, "provider_properties")

    @provider_properties.setter
    def provider_properties(self, value: Optional[pulumi.Input['IdMappingWorkflowProviderPropertiesArgs']]):
        pulumi.set(self, "provider_properties", value)

    @_builtins.property
    @pulumi.getter(name="ruleBasedProperties")
    def rule_based_properties(self) -> Optional[pulumi.Input['IdMappingWorkflowIdMappingRuleBasedPropertiesArgs']]:
        """
        An object which defines any additional configurations required by rule-based matching.
        """
        return pulumi.get(self, "rule_based_properties")

    @rule_based_properties.setter
    def rule_based_properties(self, value: Optional[pulumi.Input['IdMappingWorkflowIdMappingRuleBasedPropertiesArgs']]):
        pulumi.set(self, "rule_based_properties", value)


if not MYPY:
    class IdMappingWorkflowInputSourceArgsDict(TypedDict):
        input_source_arn: pulumi.Input[_builtins.str]
        """
        An Glue table ARN for the input source table, MatchingWorkflow arn or IdNamespace ARN
        """
        schema_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ARN (Amazon Resource Name) that AWS Entity Resolution generated for the `SchemaMapping` .
        """
        type: NotRequired[pulumi.Input['IdMappingWorkflowInputSourceType']]
        """
        The type of ID namespace. There are two types: `SOURCE` and `TARGET` .

        The `SOURCE` contains configurations for `sourceId` data that will be processed in an ID mapping workflow.

        The `TARGET` contains a configuration of `targetId` which all `sourceIds` will resolve to.
        """
elif False:
    IdMappingWorkflowInputSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdMappingWorkflowInputSourceArgs:
    def __init__(__self__, *,
                 input_source_arn: pulumi.Input[_builtins.str],
                 schema_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input['IdMappingWorkflowInputSourceType']] = None):
        """
        :param pulumi.Input[_builtins.str] input_source_arn: An Glue table ARN for the input source table, MatchingWorkflow arn or IdNamespace ARN
        :param pulumi.Input[_builtins.str] schema_arn: The ARN (Amazon Resource Name) that AWS Entity Resolution generated for the `SchemaMapping` .
        :param pulumi.Input['IdMappingWorkflowInputSourceType'] type: The type of ID namespace. There are two types: `SOURCE` and `TARGET` .
               
               The `SOURCE` contains configurations for `sourceId` data that will be processed in an ID mapping workflow.
               
               The `TARGET` contains a configuration of `targetId` which all `sourceIds` will resolve to.
        """
        pulumi.set(__self__, "input_source_arn", input_source_arn)
        if schema_arn is not None:
            pulumi.set(__self__, "schema_arn", schema_arn)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="inputSourceArn")
    def input_source_arn(self) -> pulumi.Input[_builtins.str]:
        """
        An Glue table ARN for the input source table, MatchingWorkflow arn or IdNamespace ARN
        """
        return pulumi.get(self, "input_source_arn")

    @input_source_arn.setter
    def input_source_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "input_source_arn", value)

    @_builtins.property
    @pulumi.getter(name="schemaArn")
    def schema_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ARN (Amazon Resource Name) that AWS Entity Resolution generated for the `SchemaMapping` .
        """
        return pulumi.get(self, "schema_arn")

    @schema_arn.setter
    def schema_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_arn", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input['IdMappingWorkflowInputSourceType']]:
        """
        The type of ID namespace. There are two types: `SOURCE` and `TARGET` .

        The `SOURCE` contains configurations for `sourceId` data that will be processed in an ID mapping workflow.

        The `TARGET` contains a configuration of `targetId` which all `sourceIds` will resolve to.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input['IdMappingWorkflowInputSourceType']]):
        pulumi.set(self, "type", value)


if not MYPY:
    class IdMappingWorkflowIntermediateSourceConfigurationArgsDict(TypedDict):
        intermediate_s3_path: pulumi.Input[_builtins.str]
        """
        The s3 path that would be used to stage the intermediate data being generated during workflow execution.
        """
elif False:
    IdMappingWorkflowIntermediateSourceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdMappingWorkflowIntermediateSourceConfigurationArgs:
    def __init__(__self__, *,
                 intermediate_s3_path: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] intermediate_s3_path: The s3 path that would be used to stage the intermediate data being generated during workflow execution.
        """
        pulumi.set(__self__, "intermediate_s3_path", intermediate_s3_path)

    @_builtins.property
    @pulumi.getter(name="intermediateS3Path")
    def intermediate_s3_path(self) -> pulumi.Input[_builtins.str]:
        """
        The s3 path that would be used to stage the intermediate data being generated during workflow execution.
        """
        return pulumi.get(self, "intermediate_s3_path")

    @intermediate_s3_path.setter
    def intermediate_s3_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "intermediate_s3_path", value)


if not MYPY:
    class IdMappingWorkflowOutputSourceArgsDict(TypedDict):
        output_s3_path: pulumi.Input[_builtins.str]
        """
        The S3 path to which Entity Resolution will write the output table
        """
        kms_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        Customer AWS KMS ARN for encryption at rest. If not provided, system will use an AWS Entity Resolution managed KMS key.
        """
elif False:
    IdMappingWorkflowOutputSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdMappingWorkflowOutputSourceArgs:
    def __init__(__self__, *,
                 output_s3_path: pulumi.Input[_builtins.str],
                 kms_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] output_s3_path: The S3 path to which Entity Resolution will write the output table
        :param pulumi.Input[_builtins.str] kms_arn: Customer AWS KMS ARN for encryption at rest. If not provided, system will use an AWS Entity Resolution managed KMS key.
        """
        pulumi.set(__self__, "output_s3_path", output_s3_path)
        if kms_arn is not None:
            pulumi.set(__self__, "kms_arn", kms_arn)

    @_builtins.property
    @pulumi.getter(name="outputS3Path")
    def output_s3_path(self) -> pulumi.Input[_builtins.str]:
        """
        The S3 path to which Entity Resolution will write the output table
        """
        return pulumi.get(self, "output_s3_path")

    @output_s3_path.setter
    def output_s3_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "output_s3_path", value)

    @_builtins.property
    @pulumi.getter(name="kmsArn")
    def kms_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Customer AWS KMS ARN for encryption at rest. If not provided, system will use an AWS Entity Resolution managed KMS key.
        """
        return pulumi.get(self, "kms_arn")

    @kms_arn.setter
    def kms_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_arn", value)


if not MYPY:
    class IdMappingWorkflowProviderPropertiesArgsDict(TypedDict):
        provider_service_arn: pulumi.Input[_builtins.str]
        """
        Arn of the Provider Service being used.
        """
        intermediate_source_configuration: NotRequired[pulumi.Input['IdMappingWorkflowIntermediateSourceConfigurationArgsDict']]
        """
        The Amazon S3 location that temporarily stores your data while it processes. Your information won't be saved permanently.
        """
        provider_configuration: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Additional Provider configuration that would be required for the provider service. The Configuration must be in JSON string format
        """
elif False:
    IdMappingWorkflowProviderPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdMappingWorkflowProviderPropertiesArgs:
    def __init__(__self__, *,
                 provider_service_arn: pulumi.Input[_builtins.str],
                 intermediate_source_configuration: Optional[pulumi.Input['IdMappingWorkflowIntermediateSourceConfigurationArgs']] = None,
                 provider_configuration: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] provider_service_arn: Arn of the Provider Service being used.
        :param pulumi.Input['IdMappingWorkflowIntermediateSourceConfigurationArgs'] intermediate_source_configuration: The Amazon S3 location that temporarily stores your data while it processes. Your information won't be saved permanently.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] provider_configuration: Additional Provider configuration that would be required for the provider service. The Configuration must be in JSON string format
        """
        pulumi.set(__self__, "provider_service_arn", provider_service_arn)
        if intermediate_source_configuration is not None:
            pulumi.set(__self__, "intermediate_source_configuration", intermediate_source_configuration)
        if provider_configuration is not None:
            pulumi.set(__self__, "provider_configuration", provider_configuration)

    @_builtins.property
    @pulumi.getter(name="providerServiceArn")
    def provider_service_arn(self) -> pulumi.Input[_builtins.str]:
        """
        Arn of the Provider Service being used.
        """
        return pulumi.get(self, "provider_service_arn")

    @provider_service_arn.setter
    def provider_service_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "provider_service_arn", value)

    @_builtins.property
    @pulumi.getter(name="intermediateSourceConfiguration")
    def intermediate_source_configuration(self) -> Optional[pulumi.Input['IdMappingWorkflowIntermediateSourceConfigurationArgs']]:
        """
        The Amazon S3 location that temporarily stores your data while it processes. Your information won't be saved permanently.
        """
        return pulumi.get(self, "intermediate_source_configuration")

    @intermediate_source_configuration.setter
    def intermediate_source_configuration(self, value: Optional[pulumi.Input['IdMappingWorkflowIntermediateSourceConfigurationArgs']]):
        pulumi.set(self, "intermediate_source_configuration", value)

    @_builtins.property
    @pulumi.getter(name="providerConfiguration")
    def provider_configuration(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Additional Provider configuration that would be required for the provider service. The Configuration must be in JSON string format
        """
        return pulumi.get(self, "provider_configuration")

    @provider_configuration.setter
    def provider_configuration(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "provider_configuration", value)


if not MYPY:
    class IdMappingWorkflowRuleArgsDict(TypedDict):
        matching_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        A list of `MatchingKeys` . The `MatchingKeys` must have been defined in the `SchemaMapping` . Two records are considered to match according to this rule if all of the `MatchingKeys` match.
        """
        rule_name: pulumi.Input[_builtins.str]
        """
        A name for the matching rule.
        """
elif False:
    IdMappingWorkflowRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdMappingWorkflowRuleArgs:
    def __init__(__self__, *,
                 matching_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 rule_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] matching_keys: A list of `MatchingKeys` . The `MatchingKeys` must have been defined in the `SchemaMapping` . Two records are considered to match according to this rule if all of the `MatchingKeys` match.
        :param pulumi.Input[_builtins.str] rule_name: A name for the matching rule.
        """
        pulumi.set(__self__, "matching_keys", matching_keys)
        pulumi.set(__self__, "rule_name", rule_name)

    @_builtins.property
    @pulumi.getter(name="matchingKeys")
    def matching_keys(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        A list of `MatchingKeys` . The `MatchingKeys` must have been defined in the `SchemaMapping` . Two records are considered to match according to this rule if all of the `MatchingKeys` match.
        """
        return pulumi.get(self, "matching_keys")

    @matching_keys.setter
    def matching_keys(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "matching_keys", value)

    @_builtins.property
    @pulumi.getter(name="ruleName")
    def rule_name(self) -> pulumi.Input[_builtins.str]:
        """
        A name for the matching rule.
        """
        return pulumi.get(self, "rule_name")

    @rule_name.setter
    def rule_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "rule_name", value)


if not MYPY:
    class IdNamespaceIdMappingWorkflowPropertiesArgsDict(TypedDict):
        id_mapping_type: pulumi.Input['IdNamespaceIdMappingWorkflowPropertiesIdMappingType']
        """
        The type of ID mapping.
        """
        provider_properties: NotRequired[pulumi.Input['IdNamespaceNamespaceProviderPropertiesArgsDict']]
        """
        An object which defines any additional configurations required by the provider service.
        """
        rule_based_properties: NotRequired[pulumi.Input['IdNamespaceNamespaceRuleBasedPropertiesArgsDict']]
        """
        An object which defines any additional configurations required by rule-based matching.
        """
elif False:
    IdNamespaceIdMappingWorkflowPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdNamespaceIdMappingWorkflowPropertiesArgs:
    def __init__(__self__, *,
                 id_mapping_type: pulumi.Input['IdNamespaceIdMappingWorkflowPropertiesIdMappingType'],
                 provider_properties: Optional[pulumi.Input['IdNamespaceNamespaceProviderPropertiesArgs']] = None,
                 rule_based_properties: Optional[pulumi.Input['IdNamespaceNamespaceRuleBasedPropertiesArgs']] = None):
        """
        :param pulumi.Input['IdNamespaceIdMappingWorkflowPropertiesIdMappingType'] id_mapping_type: The type of ID mapping.
        :param pulumi.Input['IdNamespaceNamespaceProviderPropertiesArgs'] provider_properties: An object which defines any additional configurations required by the provider service.
        :param pulumi.Input['IdNamespaceNamespaceRuleBasedPropertiesArgs'] rule_based_properties: An object which defines any additional configurations required by rule-based matching.
        """
        pulumi.set(__self__, "id_mapping_type", id_mapping_type)
        if provider_properties is not None:
            pulumi.set(__self__, "provider_properties", provider_properties)
        if rule_based_properties is not None:
            pulumi.set(__self__, "rule_based_properties", rule_based_properties)

    @_builtins.property
    @pulumi.getter(name="idMappingType")
    def id_mapping_type(self) -> pulumi.Input['IdNamespaceIdMappingWorkflowPropertiesIdMappingType']:
        """
        The type of ID mapping.
        """
        return pulumi.get(self, "id_mapping_type")

    @id_mapping_type.setter
    def id_mapping_type(self, value: pulumi.Input['IdNamespaceIdMappingWorkflowPropertiesIdMappingType']):
        pulumi.set(self, "id_mapping_type", value)

    @_builtins.property
    @pulumi.getter(name="providerProperties")
    def provider_properties(self) -> Optional[pulumi.Input['IdNamespaceNamespaceProviderPropertiesArgs']]:
        """
        An object which defines any additional configurations required by the provider service.
        """
        return pulumi.get(self, "provider_properties")

    @provider_properties.setter
    def provider_properties(self, value: Optional[pulumi.Input['IdNamespaceNamespaceProviderPropertiesArgs']]):
        pulumi.set(self, "provider_properties", value)

    @_builtins.property
    @pulumi.getter(name="ruleBasedProperties")
    def rule_based_properties(self) -> Optional[pulumi.Input['IdNamespaceNamespaceRuleBasedPropertiesArgs']]:
        """
        An object which defines any additional configurations required by rule-based matching.
        """
        return pulumi.get(self, "rule_based_properties")

    @rule_based_properties.setter
    def rule_based_properties(self, value: Optional[pulumi.Input['IdNamespaceNamespaceRuleBasedPropertiesArgs']]):
        pulumi.set(self, "rule_based_properties", value)


if not MYPY:
    class IdNamespaceInputSourceArgsDict(TypedDict):
        input_source_arn: pulumi.Input[_builtins.str]
        """
        An AWS Glue table Amazon Resource Name (ARN) or a matching workflow ARN for the input source table.
        """
        schema_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the schema.
        """
elif False:
    IdNamespaceInputSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdNamespaceInputSourceArgs:
    def __init__(__self__, *,
                 input_source_arn: pulumi.Input[_builtins.str],
                 schema_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] input_source_arn: An AWS Glue table Amazon Resource Name (ARN) or a matching workflow ARN for the input source table.
        :param pulumi.Input[_builtins.str] schema_name: The name of the schema.
        """
        pulumi.set(__self__, "input_source_arn", input_source_arn)
        if schema_name is not None:
            pulumi.set(__self__, "schema_name", schema_name)

    @_builtins.property
    @pulumi.getter(name="inputSourceArn")
    def input_source_arn(self) -> pulumi.Input[_builtins.str]:
        """
        An AWS Glue table Amazon Resource Name (ARN) or a matching workflow ARN for the input source table.
        """
        return pulumi.get(self, "input_source_arn")

    @input_source_arn.setter
    def input_source_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "input_source_arn", value)

    @_builtins.property
    @pulumi.getter(name="schemaName")
    def schema_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the schema.
        """
        return pulumi.get(self, "schema_name")

    @schema_name.setter
    def schema_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schema_name", value)


if not MYPY:
    class IdNamespaceNamespaceProviderPropertiesArgsDict(TypedDict):
        provider_service_arn: pulumi.Input[_builtins.str]
        """
        The Amazon Resource Name (ARN) of the provider service.
        """
        provider_configuration: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Additional Provider configuration that would be required for the provider service. The Configuration must be in JSON string format.
        """
elif False:
    IdNamespaceNamespaceProviderPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdNamespaceNamespaceProviderPropertiesArgs:
    def __init__(__self__, *,
                 provider_service_arn: pulumi.Input[_builtins.str],
                 provider_configuration: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] provider_service_arn: The Amazon Resource Name (ARN) of the provider service.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] provider_configuration: Additional Provider configuration that would be required for the provider service. The Configuration must be in JSON string format.
        """
        pulumi.set(__self__, "provider_service_arn", provider_service_arn)
        if provider_configuration is not None:
            pulumi.set(__self__, "provider_configuration", provider_configuration)

    @_builtins.property
    @pulumi.getter(name="providerServiceArn")
    def provider_service_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The Amazon Resource Name (ARN) of the provider service.
        """
        return pulumi.get(self, "provider_service_arn")

    @provider_service_arn.setter
    def provider_service_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "provider_service_arn", value)

    @_builtins.property
    @pulumi.getter(name="providerConfiguration")
    def provider_configuration(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Additional Provider configuration that would be required for the provider service. The Configuration must be in JSON string format.
        """
        return pulumi.get(self, "provider_configuration")

    @provider_configuration.setter
    def provider_configuration(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "provider_configuration", value)


if not MYPY:
    class IdNamespaceNamespaceRuleBasedPropertiesArgsDict(TypedDict):
        attribute_matching_model: NotRequired[pulumi.Input['IdNamespaceNamespaceRuleBasedPropertiesAttributeMatchingModel']]
        """
        The comparison type. You can either choose `ONE_TO_ONE` or `MANY_TO_MANY` as the `attributeMatchingModel` .

        If you choose `ONE_TO_ONE` , the system can only match attributes if the sub-types are an exact match. For example, for the `Email` attribute type, the system will only consider it a match if the value of the `Email` field of Profile A matches the value of the `Email` field of Profile B.

        If you choose `MANY_TO_MANY` , the system can match attributes across the sub-types of an attribute type. For example, if the value of the `Email` field of Profile A matches the value of `BusinessEmail` field of Profile B, the two profiles are matched on the `Email` attribute type.
        """
        record_matching_models: NotRequired[pulumi.Input[Sequence[pulumi.Input['IdNamespaceRecordMatchingModel']]]]
        """
        The type of matching record that is allowed to be used in an ID mapping workflow.

        If the value is set to `ONE_SOURCE_TO_ONE_TARGET` , only one record in the source is matched to one record in the target.

        If the value is set to `MANY_SOURCE_TO_ONE_TARGET` , all matching records in the source are matched to one record in the target.
        """
        rule_definition_types: NotRequired[pulumi.Input[Sequence[pulumi.Input['IdNamespaceRuleDefinitionType']]]]
        """
        The sets of rules you can use in an ID mapping workflow. The limitations specified for the source and target must be compatible.
        """
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['IdNamespaceRuleArgsDict']]]]
        """
        The rules for the ID namespace.
        """
elif False:
    IdNamespaceNamespaceRuleBasedPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdNamespaceNamespaceRuleBasedPropertiesArgs:
    def __init__(__self__, *,
                 attribute_matching_model: Optional[pulumi.Input['IdNamespaceNamespaceRuleBasedPropertiesAttributeMatchingModel']] = None,
                 record_matching_models: Optional[pulumi.Input[Sequence[pulumi.Input['IdNamespaceRecordMatchingModel']]]] = None,
                 rule_definition_types: Optional[pulumi.Input[Sequence[pulumi.Input['IdNamespaceRuleDefinitionType']]]] = None,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['IdNamespaceRuleArgs']]]] = None):
        """
        :param pulumi.Input['IdNamespaceNamespaceRuleBasedPropertiesAttributeMatchingModel'] attribute_matching_model: The comparison type. You can either choose `ONE_TO_ONE` or `MANY_TO_MANY` as the `attributeMatchingModel` .
               
               If you choose `ONE_TO_ONE` , the system can only match attributes if the sub-types are an exact match. For example, for the `Email` attribute type, the system will only consider it a match if the value of the `Email` field of Profile A matches the value of the `Email` field of Profile B.
               
               If you choose `MANY_TO_MANY` , the system can match attributes across the sub-types of an attribute type. For example, if the value of the `Email` field of Profile A matches the value of `BusinessEmail` field of Profile B, the two profiles are matched on the `Email` attribute type.
        :param pulumi.Input[Sequence[pulumi.Input['IdNamespaceRecordMatchingModel']]] record_matching_models: The type of matching record that is allowed to be used in an ID mapping workflow.
               
               If the value is set to `ONE_SOURCE_TO_ONE_TARGET` , only one record in the source is matched to one record in the target.
               
               If the value is set to `MANY_SOURCE_TO_ONE_TARGET` , all matching records in the source are matched to one record in the target.
        :param pulumi.Input[Sequence[pulumi.Input['IdNamespaceRuleDefinitionType']]] rule_definition_types: The sets of rules you can use in an ID mapping workflow. The limitations specified for the source and target must be compatible.
        :param pulumi.Input[Sequence[pulumi.Input['IdNamespaceRuleArgs']]] rules: The rules for the ID namespace.
        """
        if attribute_matching_model is not None:
            pulumi.set(__self__, "attribute_matching_model", attribute_matching_model)
        if record_matching_models is not None:
            pulumi.set(__self__, "record_matching_models", record_matching_models)
        if rule_definition_types is not None:
            pulumi.set(__self__, "rule_definition_types", rule_definition_types)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter(name="attributeMatchingModel")
    def attribute_matching_model(self) -> Optional[pulumi.Input['IdNamespaceNamespaceRuleBasedPropertiesAttributeMatchingModel']]:
        """
        The comparison type. You can either choose `ONE_TO_ONE` or `MANY_TO_MANY` as the `attributeMatchingModel` .

        If you choose `ONE_TO_ONE` , the system can only match attributes if the sub-types are an exact match. For example, for the `Email` attribute type, the system will only consider it a match if the value of the `Email` field of Profile A matches the value of the `Email` field of Profile B.

        If you choose `MANY_TO_MANY` , the system can match attributes across the sub-types of an attribute type. For example, if the value of the `Email` field of Profile A matches the value of `BusinessEmail` field of Profile B, the two profiles are matched on the `Email` attribute type.
        """
        return pulumi.get(self, "attribute_matching_model")

    @attribute_matching_model.setter
    def attribute_matching_model(self, value: Optional[pulumi.Input['IdNamespaceNamespaceRuleBasedPropertiesAttributeMatchingModel']]):
        pulumi.set(self, "attribute_matching_model", value)

    @_builtins.property
    @pulumi.getter(name="recordMatchingModels")
    def record_matching_models(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IdNamespaceRecordMatchingModel']]]]:
        """
        The type of matching record that is allowed to be used in an ID mapping workflow.

        If the value is set to `ONE_SOURCE_TO_ONE_TARGET` , only one record in the source is matched to one record in the target.

        If the value is set to `MANY_SOURCE_TO_ONE_TARGET` , all matching records in the source are matched to one record in the target.
        """
        return pulumi.get(self, "record_matching_models")

    @record_matching_models.setter
    def record_matching_models(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IdNamespaceRecordMatchingModel']]]]):
        pulumi.set(self, "record_matching_models", value)

    @_builtins.property
    @pulumi.getter(name="ruleDefinitionTypes")
    def rule_definition_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IdNamespaceRuleDefinitionType']]]]:
        """
        The sets of rules you can use in an ID mapping workflow. The limitations specified for the source and target must be compatible.
        """
        return pulumi.get(self, "rule_definition_types")

    @rule_definition_types.setter
    def rule_definition_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IdNamespaceRuleDefinitionType']]]]):
        pulumi.set(self, "rule_definition_types", value)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IdNamespaceRuleArgs']]]]:
        """
        The rules for the ID namespace.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IdNamespaceRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class IdNamespaceRuleArgsDict(TypedDict):
        matching_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        A list of `MatchingKeys` . The `MatchingKeys` must have been defined in the `SchemaMapping` . Two records are considered to match according to this rule if all of the `MatchingKeys` match.
        """
        rule_name: pulumi.Input[_builtins.str]
        """
        A name for the matching rule.
        """
elif False:
    IdNamespaceRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdNamespaceRuleArgs:
    def __init__(__self__, *,
                 matching_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 rule_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] matching_keys: A list of `MatchingKeys` . The `MatchingKeys` must have been defined in the `SchemaMapping` . Two records are considered to match according to this rule if all of the `MatchingKeys` match.
        :param pulumi.Input[_builtins.str] rule_name: A name for the matching rule.
        """
        pulumi.set(__self__, "matching_keys", matching_keys)
        pulumi.set(__self__, "rule_name", rule_name)

    @_builtins.property
    @pulumi.getter(name="matchingKeys")
    def matching_keys(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        A list of `MatchingKeys` . The `MatchingKeys` must have been defined in the `SchemaMapping` . Two records are considered to match according to this rule if all of the `MatchingKeys` match.
        """
        return pulumi.get(self, "matching_keys")

    @matching_keys.setter
    def matching_keys(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "matching_keys", value)

    @_builtins.property
    @pulumi.getter(name="ruleName")
    def rule_name(self) -> pulumi.Input[_builtins.str]:
        """
        A name for the matching rule.
        """
        return pulumi.get(self, "rule_name")

    @rule_name.setter
    def rule_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "rule_name", value)


if not MYPY:
    class MatchingWorkflowIncrementalRunConfigArgsDict(TypedDict):
        incremental_run_type: pulumi.Input['MatchingWorkflowIncrementalRunConfigIncrementalRunType']
        """
        The type of incremental run. The only valid value is `IMMEDIATE` . This appears as "Automatic" in the console.

        > For workflows where `resolutionType` is `ML_MATCHING` or `PROVIDER` , incremental processing is not supported.
        """
elif False:
    MatchingWorkflowIncrementalRunConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MatchingWorkflowIncrementalRunConfigArgs:
    def __init__(__self__, *,
                 incremental_run_type: pulumi.Input['MatchingWorkflowIncrementalRunConfigIncrementalRunType']):
        """
        :param pulumi.Input['MatchingWorkflowIncrementalRunConfigIncrementalRunType'] incremental_run_type: The type of incremental run. The only valid value is `IMMEDIATE` . This appears as "Automatic" in the console.
               
               > For workflows where `resolutionType` is `ML_MATCHING` or `PROVIDER` , incremental processing is not supported.
        """
        pulumi.set(__self__, "incremental_run_type", incremental_run_type)

    @_builtins.property
    @pulumi.getter(name="incrementalRunType")
    def incremental_run_type(self) -> pulumi.Input['MatchingWorkflowIncrementalRunConfigIncrementalRunType']:
        """
        The type of incremental run. The only valid value is `IMMEDIATE` . This appears as "Automatic" in the console.

        > For workflows where `resolutionType` is `ML_MATCHING` or `PROVIDER` , incremental processing is not supported.
        """
        return pulumi.get(self, "incremental_run_type")

    @incremental_run_type.setter
    def incremental_run_type(self, value: pulumi.Input['MatchingWorkflowIncrementalRunConfigIncrementalRunType']):
        pulumi.set(self, "incremental_run_type", value)


if not MYPY:
    class MatchingWorkflowInputSourceArgsDict(TypedDict):
        input_source_arn: pulumi.Input[_builtins.str]
        """
        An Glue table ARN for the input source table
        """
        schema_arn: pulumi.Input[_builtins.str]
        """
        The name of the schema.
        """
        apply_normalization: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Normalizes the attributes defined in the schema in the input data. For example, if an attribute has an `AttributeType` of `PHONE_NUMBER` , and the data in the input table is in a format of 1234567890, AWS Entity Resolution will normalize this field in the output to (123)-456-7890.
        """
elif False:
    MatchingWorkflowInputSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MatchingWorkflowInputSourceArgs:
    def __init__(__self__, *,
                 input_source_arn: pulumi.Input[_builtins.str],
                 schema_arn: pulumi.Input[_builtins.str],
                 apply_normalization: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] input_source_arn: An Glue table ARN for the input source table
        :param pulumi.Input[_builtins.str] schema_arn: The name of the schema.
        :param pulumi.Input[_builtins.bool] apply_normalization: Normalizes the attributes defined in the schema in the input data. For example, if an attribute has an `AttributeType` of `PHONE_NUMBER` , and the data in the input table is in a format of 1234567890, AWS Entity Resolution will normalize this field in the output to (123)-456-7890.
        """
        pulumi.set(__self__, "input_source_arn", input_source_arn)
        pulumi.set(__self__, "schema_arn", schema_arn)
        if apply_normalization is not None:
            pulumi.set(__self__, "apply_normalization", apply_normalization)

    @_builtins.property
    @pulumi.getter(name="inputSourceArn")
    def input_source_arn(self) -> pulumi.Input[_builtins.str]:
        """
        An Glue table ARN for the input source table
        """
        return pulumi.get(self, "input_source_arn")

    @input_source_arn.setter
    def input_source_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "input_source_arn", value)

    @_builtins.property
    @pulumi.getter(name="schemaArn")
    def schema_arn(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the schema.
        """
        return pulumi.get(self, "schema_arn")

    @schema_arn.setter
    def schema_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "schema_arn", value)

    @_builtins.property
    @pulumi.getter(name="applyNormalization")
    def apply_normalization(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Normalizes the attributes defined in the schema in the input data. For example, if an attribute has an `AttributeType` of `PHONE_NUMBER` , and the data in the input table is in a format of 1234567890, AWS Entity Resolution will normalize this field in the output to (123)-456-7890.
        """
        return pulumi.get(self, "apply_normalization")

    @apply_normalization.setter
    def apply_normalization(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "apply_normalization", value)


if not MYPY:
    class MatchingWorkflowIntermediateSourceConfigurationArgsDict(TypedDict):
        intermediate_s3_path: pulumi.Input[_builtins.str]
        """
        The s3 path that would be used to stage the intermediate data being generated during workflow execution.
        """
elif False:
    MatchingWorkflowIntermediateSourceConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MatchingWorkflowIntermediateSourceConfigurationArgs:
    def __init__(__self__, *,
                 intermediate_s3_path: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] intermediate_s3_path: The s3 path that would be used to stage the intermediate data being generated during workflow execution.
        """
        pulumi.set(__self__, "intermediate_s3_path", intermediate_s3_path)

    @_builtins.property
    @pulumi.getter(name="intermediateS3Path")
    def intermediate_s3_path(self) -> pulumi.Input[_builtins.str]:
        """
        The s3 path that would be used to stage the intermediate data being generated during workflow execution.
        """
        return pulumi.get(self, "intermediate_s3_path")

    @intermediate_s3_path.setter
    def intermediate_s3_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "intermediate_s3_path", value)


if not MYPY:
    class MatchingWorkflowOutputAttributeArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A name of a column to be written to the output. This must be an `InputField` name in the schema mapping.
        """
        hashed: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables the ability to hash the column values in the output.
        """
elif False:
    MatchingWorkflowOutputAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MatchingWorkflowOutputAttributeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 hashed: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A name of a column to be written to the output. This must be an `InputField` name in the schema mapping.
        :param pulumi.Input[_builtins.bool] hashed: Enables the ability to hash the column values in the output.
        """
        pulumi.set(__self__, "name", name)
        if hashed is not None:
            pulumi.set(__self__, "hashed", hashed)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A name of a column to be written to the output. This must be an `InputField` name in the schema mapping.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def hashed(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables the ability to hash the column values in the output.
        """
        return pulumi.get(self, "hashed")

    @hashed.setter
    def hashed(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "hashed", value)


if not MYPY:
    class MatchingWorkflowOutputSourceArgsDict(TypedDict):
        output: pulumi.Input[Sequence[pulumi.Input['MatchingWorkflowOutputAttributeArgsDict']]]
        """
        A list of `OutputAttribute` objects, each of which have the fields `Name` and `Hashed` . Each of these objects selects a column to be included in the output table, and whether the values of the column should be hashed.
        """
        output_s3_path: pulumi.Input[_builtins.str]
        """
        The S3 path to which Entity Resolution will write the output table
        """
        apply_normalization: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Normalizes the attributes defined in the schema in the input data. For example, if an attribute has an `AttributeType` of `PHONE_NUMBER` , and the data in the input table is in a format of 1234567890, AWS Entity Resolution will normalize this field in the output to (123)-456-7890.
        """
        kms_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        Customer KMS ARN for encryption at rest. If not provided, system will use an AWS Entity Resolution managed KMS key.
        """
elif False:
    MatchingWorkflowOutputSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MatchingWorkflowOutputSourceArgs:
    def __init__(__self__, *,
                 output: pulumi.Input[Sequence[pulumi.Input['MatchingWorkflowOutputAttributeArgs']]],
                 output_s3_path: pulumi.Input[_builtins.str],
                 apply_normalization: Optional[pulumi.Input[_builtins.bool]] = None,
                 kms_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['MatchingWorkflowOutputAttributeArgs']]] output: A list of `OutputAttribute` objects, each of which have the fields `Name` and `Hashed` . Each of these objects selects a column to be included in the output table, and whether the values of the column should be hashed.
        :param pulumi.Input[_builtins.str] output_s3_path: The S3 path to which Entity Resolution will write the output table
        :param pulumi.Input[_builtins.bool] apply_normalization: Normalizes the attributes defined in the schema in the input data. For example, if an attribute has an `AttributeType` of `PHONE_NUMBER` , and the data in the input table is in a format of 1234567890, AWS Entity Resolution will normalize this field in the output to (123)-456-7890.
        :param pulumi.Input[_builtins.str] kms_arn: Customer KMS ARN for encryption at rest. If not provided, system will use an AWS Entity Resolution managed KMS key.
        """
        pulumi.set(__self__, "output", output)
        pulumi.set(__self__, "output_s3_path", output_s3_path)
        if apply_normalization is not None:
            pulumi.set(__self__, "apply_normalization", apply_normalization)
        if kms_arn is not None:
            pulumi.set(__self__, "kms_arn", kms_arn)

    @_builtins.property
    @pulumi.getter
    def output(self) -> pulumi.Input[Sequence[pulumi.Input['MatchingWorkflowOutputAttributeArgs']]]:
        """
        A list of `OutputAttribute` objects, each of which have the fields `Name` and `Hashed` . Each of these objects selects a column to be included in the output table, and whether the values of the column should be hashed.
        """
        return pulumi.get(self, "output")

    @output.setter
    def output(self, value: pulumi.Input[Sequence[pulumi.Input['MatchingWorkflowOutputAttributeArgs']]]):
        pulumi.set(self, "output", value)

    @_builtins.property
    @pulumi.getter(name="outputS3Path")
    def output_s3_path(self) -> pulumi.Input[_builtins.str]:
        """
        The S3 path to which Entity Resolution will write the output table
        """
        return pulumi.get(self, "output_s3_path")

    @output_s3_path.setter
    def output_s3_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "output_s3_path", value)

    @_builtins.property
    @pulumi.getter(name="applyNormalization")
    def apply_normalization(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Normalizes the attributes defined in the schema in the input data. For example, if an attribute has an `AttributeType` of `PHONE_NUMBER` , and the data in the input table is in a format of 1234567890, AWS Entity Resolution will normalize this field in the output to (123)-456-7890.
        """
        return pulumi.get(self, "apply_normalization")

    @apply_normalization.setter
    def apply_normalization(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "apply_normalization", value)

    @_builtins.property
    @pulumi.getter(name="kmsArn")
    def kms_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Customer KMS ARN for encryption at rest. If not provided, system will use an AWS Entity Resolution managed KMS key.
        """
        return pulumi.get(self, "kms_arn")

    @kms_arn.setter
    def kms_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_arn", value)


if not MYPY:
    class MatchingWorkflowProviderPropertiesArgsDict(TypedDict):
        provider_service_arn: pulumi.Input[_builtins.str]
        """
        Arn of the Provider service being used.
        """
        intermediate_source_configuration: NotRequired[pulumi.Input['MatchingWorkflowIntermediateSourceConfigurationArgsDict']]
        """
        The Amazon S3 location that temporarily stores your data while it processes. Your information won't be saved permanently.
        """
        provider_configuration: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Additional Provider configuration that would be required for the provider service. The Configuration must be in JSON string format
        """
elif False:
    MatchingWorkflowProviderPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MatchingWorkflowProviderPropertiesArgs:
    def __init__(__self__, *,
                 provider_service_arn: pulumi.Input[_builtins.str],
                 intermediate_source_configuration: Optional[pulumi.Input['MatchingWorkflowIntermediateSourceConfigurationArgs']] = None,
                 provider_configuration: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] provider_service_arn: Arn of the Provider service being used.
        :param pulumi.Input['MatchingWorkflowIntermediateSourceConfigurationArgs'] intermediate_source_configuration: The Amazon S3 location that temporarily stores your data while it processes. Your information won't be saved permanently.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] provider_configuration: Additional Provider configuration that would be required for the provider service. The Configuration must be in JSON string format
        """
        pulumi.set(__self__, "provider_service_arn", provider_service_arn)
        if intermediate_source_configuration is not None:
            pulumi.set(__self__, "intermediate_source_configuration", intermediate_source_configuration)
        if provider_configuration is not None:
            pulumi.set(__self__, "provider_configuration", provider_configuration)

    @_builtins.property
    @pulumi.getter(name="providerServiceArn")
    def provider_service_arn(self) -> pulumi.Input[_builtins.str]:
        """
        Arn of the Provider service being used.
        """
        return pulumi.get(self, "provider_service_arn")

    @provider_service_arn.setter
    def provider_service_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "provider_service_arn", value)

    @_builtins.property
    @pulumi.getter(name="intermediateSourceConfiguration")
    def intermediate_source_configuration(self) -> Optional[pulumi.Input['MatchingWorkflowIntermediateSourceConfigurationArgs']]:
        """
        The Amazon S3 location that temporarily stores your data while it processes. Your information won't be saved permanently.
        """
        return pulumi.get(self, "intermediate_source_configuration")

    @intermediate_source_configuration.setter
    def intermediate_source_configuration(self, value: Optional[pulumi.Input['MatchingWorkflowIntermediateSourceConfigurationArgs']]):
        pulumi.set(self, "intermediate_source_configuration", value)

    @_builtins.property
    @pulumi.getter(name="providerConfiguration")
    def provider_configuration(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Additional Provider configuration that would be required for the provider service. The Configuration must be in JSON string format
        """
        return pulumi.get(self, "provider_configuration")

    @provider_configuration.setter
    def provider_configuration(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "provider_configuration", value)


if not MYPY:
    class MatchingWorkflowResolutionTechniquesArgsDict(TypedDict):
        provider_properties: NotRequired[pulumi.Input['MatchingWorkflowProviderPropertiesArgsDict']]
        """
        The properties of the provider service.
        """
        resolution_type: NotRequired[pulumi.Input['MatchingWorkflowResolutionType']]
        """
        The type of matching workflow to create. Specify one of the following types:

        - `RULE_MATCHING` : Match records using configurable rule-based criteria
        - `ML_MATCHING` : Match records using machine learning models
        - `PROVIDER` : Match records using a third-party matching provider
        """
        rule_based_properties: NotRequired[pulumi.Input['MatchingWorkflowRuleBasedPropertiesArgsDict']]
        """
        An object which defines the list of matching rules to run and has a field `rules` , which is a list of rule objects.
        """
        rule_condition_properties: NotRequired[pulumi.Input['MatchingWorkflowRuleConditionPropertiesArgsDict']]
        """
        An object containing the `rules` for a matching workflow.
        """
elif False:
    MatchingWorkflowResolutionTechniquesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MatchingWorkflowResolutionTechniquesArgs:
    def __init__(__self__, *,
                 provider_properties: Optional[pulumi.Input['MatchingWorkflowProviderPropertiesArgs']] = None,
                 resolution_type: Optional[pulumi.Input['MatchingWorkflowResolutionType']] = None,
                 rule_based_properties: Optional[pulumi.Input['MatchingWorkflowRuleBasedPropertiesArgs']] = None,
                 rule_condition_properties: Optional[pulumi.Input['MatchingWorkflowRuleConditionPropertiesArgs']] = None):
        """
        :param pulumi.Input['MatchingWorkflowProviderPropertiesArgs'] provider_properties: The properties of the provider service.
        :param pulumi.Input['MatchingWorkflowResolutionType'] resolution_type: The type of matching workflow to create. Specify one of the following types:
               
               - `RULE_MATCHING` : Match records using configurable rule-based criteria
               - `ML_MATCHING` : Match records using machine learning models
               - `PROVIDER` : Match records using a third-party matching provider
        :param pulumi.Input['MatchingWorkflowRuleBasedPropertiesArgs'] rule_based_properties: An object which defines the list of matching rules to run and has a field `rules` , which is a list of rule objects.
        :param pulumi.Input['MatchingWorkflowRuleConditionPropertiesArgs'] rule_condition_properties: An object containing the `rules` for a matching workflow.
        """
        if provider_properties is not None:
            pulumi.set(__self__, "provider_properties", provider_properties)
        if resolution_type is not None:
            pulumi.set(__self__, "resolution_type", resolution_type)
        if rule_based_properties is not None:
            pulumi.set(__self__, "rule_based_properties", rule_based_properties)
        if rule_condition_properties is not None:
            pulumi.set(__self__, "rule_condition_properties", rule_condition_properties)

    @_builtins.property
    @pulumi.getter(name="providerProperties")
    def provider_properties(self) -> Optional[pulumi.Input['MatchingWorkflowProviderPropertiesArgs']]:
        """
        The properties of the provider service.
        """
        return pulumi.get(self, "provider_properties")

    @provider_properties.setter
    def provider_properties(self, value: Optional[pulumi.Input['MatchingWorkflowProviderPropertiesArgs']]):
        pulumi.set(self, "provider_properties", value)

    @_builtins.property
    @pulumi.getter(name="resolutionType")
    def resolution_type(self) -> Optional[pulumi.Input['MatchingWorkflowResolutionType']]:
        """
        The type of matching workflow to create. Specify one of the following types:

        - `RULE_MATCHING` : Match records using configurable rule-based criteria
        - `ML_MATCHING` : Match records using machine learning models
        - `PROVIDER` : Match records using a third-party matching provider
        """
        return pulumi.get(self, "resolution_type")

    @resolution_type.setter
    def resolution_type(self, value: Optional[pulumi.Input['MatchingWorkflowResolutionType']]):
        pulumi.set(self, "resolution_type", value)

    @_builtins.property
    @pulumi.getter(name="ruleBasedProperties")
    def rule_based_properties(self) -> Optional[pulumi.Input['MatchingWorkflowRuleBasedPropertiesArgs']]:
        """
        An object which defines the list of matching rules to run and has a field `rules` , which is a list of rule objects.
        """
        return pulumi.get(self, "rule_based_properties")

    @rule_based_properties.setter
    def rule_based_properties(self, value: Optional[pulumi.Input['MatchingWorkflowRuleBasedPropertiesArgs']]):
        pulumi.set(self, "rule_based_properties", value)

    @_builtins.property
    @pulumi.getter(name="ruleConditionProperties")
    def rule_condition_properties(self) -> Optional[pulumi.Input['MatchingWorkflowRuleConditionPropertiesArgs']]:
        """
        An object containing the `rules` for a matching workflow.
        """
        return pulumi.get(self, "rule_condition_properties")

    @rule_condition_properties.setter
    def rule_condition_properties(self, value: Optional[pulumi.Input['MatchingWorkflowRuleConditionPropertiesArgs']]):
        pulumi.set(self, "rule_condition_properties", value)


if not MYPY:
    class MatchingWorkflowRuleBasedPropertiesArgsDict(TypedDict):
        attribute_matching_model: pulumi.Input['MatchingWorkflowRuleBasedPropertiesAttributeMatchingModel']
        """
        The comparison type. You can choose `ONE_TO_ONE` or `MANY_TO_MANY` as the `attributeMatchingModel` .

        If you choose `ONE_TO_ONE` , the system can only match attributes if the sub-types are an exact match. For example, for the `Email` attribute type, the system will only consider it a match if the value of the `Email` field of Profile A matches the value of the `Email` field of Profile B.

        If you choose `MANY_TO_MANY` , the system can match attributes across the sub-types of an attribute type. For example, if the value of the `Email` field of Profile A and the value of `BusinessEmail` field of Profile B matches, the two profiles are matched on the `Email` attribute type.
        """
        rules: pulumi.Input[Sequence[pulumi.Input['MatchingWorkflowRuleArgsDict']]]
        """
        A list of `Rule` objects, each of which have fields `RuleName` and `MatchingKeys` .
        """
        match_purpose: NotRequired[pulumi.Input['MatchingWorkflowRuleBasedPropertiesMatchPurpose']]
        """
        An indicator of whether to generate IDs and index the data or not.

        If you choose `IDENTIFIER_GENERATION` , the process generates IDs and indexes the data.

        If you choose `INDEXING` , the process indexes the data without generating IDs.
        """
elif False:
    MatchingWorkflowRuleBasedPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MatchingWorkflowRuleBasedPropertiesArgs:
    def __init__(__self__, *,
                 attribute_matching_model: pulumi.Input['MatchingWorkflowRuleBasedPropertiesAttributeMatchingModel'],
                 rules: pulumi.Input[Sequence[pulumi.Input['MatchingWorkflowRuleArgs']]],
                 match_purpose: Optional[pulumi.Input['MatchingWorkflowRuleBasedPropertiesMatchPurpose']] = None):
        """
        :param pulumi.Input['MatchingWorkflowRuleBasedPropertiesAttributeMatchingModel'] attribute_matching_model: The comparison type. You can choose `ONE_TO_ONE` or `MANY_TO_MANY` as the `attributeMatchingModel` .
               
               If you choose `ONE_TO_ONE` , the system can only match attributes if the sub-types are an exact match. For example, for the `Email` attribute type, the system will only consider it a match if the value of the `Email` field of Profile A matches the value of the `Email` field of Profile B.
               
               If you choose `MANY_TO_MANY` , the system can match attributes across the sub-types of an attribute type. For example, if the value of the `Email` field of Profile A and the value of `BusinessEmail` field of Profile B matches, the two profiles are matched on the `Email` attribute type.
        :param pulumi.Input[Sequence[pulumi.Input['MatchingWorkflowRuleArgs']]] rules: A list of `Rule` objects, each of which have fields `RuleName` and `MatchingKeys` .
        :param pulumi.Input['MatchingWorkflowRuleBasedPropertiesMatchPurpose'] match_purpose: An indicator of whether to generate IDs and index the data or not.
               
               If you choose `IDENTIFIER_GENERATION` , the process generates IDs and indexes the data.
               
               If you choose `INDEXING` , the process indexes the data without generating IDs.
        """
        pulumi.set(__self__, "attribute_matching_model", attribute_matching_model)
        pulumi.set(__self__, "rules", rules)
        if match_purpose is not None:
            pulumi.set(__self__, "match_purpose", match_purpose)

    @_builtins.property
    @pulumi.getter(name="attributeMatchingModel")
    def attribute_matching_model(self) -> pulumi.Input['MatchingWorkflowRuleBasedPropertiesAttributeMatchingModel']:
        """
        The comparison type. You can choose `ONE_TO_ONE` or `MANY_TO_MANY` as the `attributeMatchingModel` .

        If you choose `ONE_TO_ONE` , the system can only match attributes if the sub-types are an exact match. For example, for the `Email` attribute type, the system will only consider it a match if the value of the `Email` field of Profile A matches the value of the `Email` field of Profile B.

        If you choose `MANY_TO_MANY` , the system can match attributes across the sub-types of an attribute type. For example, if the value of the `Email` field of Profile A and the value of `BusinessEmail` field of Profile B matches, the two profiles are matched on the `Email` attribute type.
        """
        return pulumi.get(self, "attribute_matching_model")

    @attribute_matching_model.setter
    def attribute_matching_model(self, value: pulumi.Input['MatchingWorkflowRuleBasedPropertiesAttributeMatchingModel']):
        pulumi.set(self, "attribute_matching_model", value)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> pulumi.Input[Sequence[pulumi.Input['MatchingWorkflowRuleArgs']]]:
        """
        A list of `Rule` objects, each of which have fields `RuleName` and `MatchingKeys` .
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: pulumi.Input[Sequence[pulumi.Input['MatchingWorkflowRuleArgs']]]):
        pulumi.set(self, "rules", value)

    @_builtins.property
    @pulumi.getter(name="matchPurpose")
    def match_purpose(self) -> Optional[pulumi.Input['MatchingWorkflowRuleBasedPropertiesMatchPurpose']]:
        """
        An indicator of whether to generate IDs and index the data or not.

        If you choose `IDENTIFIER_GENERATION` , the process generates IDs and indexes the data.

        If you choose `INDEXING` , the process indexes the data without generating IDs.
        """
        return pulumi.get(self, "match_purpose")

    @match_purpose.setter
    def match_purpose(self, value: Optional[pulumi.Input['MatchingWorkflowRuleBasedPropertiesMatchPurpose']]):
        pulumi.set(self, "match_purpose", value)


if not MYPY:
    class MatchingWorkflowRuleConditionPropertiesArgsDict(TypedDict):
        rules: pulumi.Input[Sequence[pulumi.Input['MatchingWorkflowRuleConditionArgsDict']]]
        """
        A list of rule objects, each of which have fields `ruleName` and `condition` .
        """
elif False:
    MatchingWorkflowRuleConditionPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MatchingWorkflowRuleConditionPropertiesArgs:
    def __init__(__self__, *,
                 rules: pulumi.Input[Sequence[pulumi.Input['MatchingWorkflowRuleConditionArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['MatchingWorkflowRuleConditionArgs']]] rules: A list of rule objects, each of which have fields `ruleName` and `condition` .
        """
        pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> pulumi.Input[Sequence[pulumi.Input['MatchingWorkflowRuleConditionArgs']]]:
        """
        A list of rule objects, each of which have fields `ruleName` and `condition` .
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: pulumi.Input[Sequence[pulumi.Input['MatchingWorkflowRuleConditionArgs']]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class MatchingWorkflowRuleConditionArgsDict(TypedDict):
        condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        A statement that specifies the conditions for a matching rule.

        If your data is accurate, use an Exact matching function: `Exact` or `ExactManyToMany` .

        If your data has variations in spelling or pronunciation, use a Fuzzy matching function: `Cosine` , `Levenshtein` , or `Soundex` .

        Use operators if you want to combine ( `AND` ), separate ( `OR` ), or group matching functions `(...)` .

        For example: `(Cosine(a, 10) AND Exact(b, true)) OR ExactManyToMany(c, d)`
        """
        rule_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A name for the matching rule.

        For example: `Rule1`
        """
elif False:
    MatchingWorkflowRuleConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MatchingWorkflowRuleConditionArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input[_builtins.str]] = None,
                 rule_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] condition: A statement that specifies the conditions for a matching rule.
               
               If your data is accurate, use an Exact matching function: `Exact` or `ExactManyToMany` .
               
               If your data has variations in spelling or pronunciation, use a Fuzzy matching function: `Cosine` , `Levenshtein` , or `Soundex` .
               
               Use operators if you want to combine ( `AND` ), separate ( `OR` ), or group matching functions `(...)` .
               
               For example: `(Cosine(a, 10) AND Exact(b, true)) OR ExactManyToMany(c, d)`
        :param pulumi.Input[_builtins.str] rule_name: A name for the matching rule.
               
               For example: `Rule1`
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if rule_name is not None:
            pulumi.set(__self__, "rule_name", rule_name)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A statement that specifies the conditions for a matching rule.

        If your data is accurate, use an Exact matching function: `Exact` or `ExactManyToMany` .

        If your data has variations in spelling or pronunciation, use a Fuzzy matching function: `Cosine` , `Levenshtein` , or `Soundex` .

        Use operators if you want to combine ( `AND` ), separate ( `OR` ), or group matching functions `(...)` .

        For example: `(Cosine(a, 10) AND Exact(b, true)) OR ExactManyToMany(c, d)`
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "condition", value)

    @_builtins.property
    @pulumi.getter(name="ruleName")
    def rule_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A name for the matching rule.

        For example: `Rule1`
        """
        return pulumi.get(self, "rule_name")

    @rule_name.setter
    def rule_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rule_name", value)


if not MYPY:
    class MatchingWorkflowRuleArgsDict(TypedDict):
        matching_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        A list of `MatchingKeys` . The `MatchingKeys` must have been defined in the `SchemaMapping` . Two records are considered to match according to this rule if all of the `MatchingKeys` match.
        """
        rule_name: pulumi.Input[_builtins.str]
        """
        A name for the matching rule.
        """
elif False:
    MatchingWorkflowRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MatchingWorkflowRuleArgs:
    def __init__(__self__, *,
                 matching_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 rule_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] matching_keys: A list of `MatchingKeys` . The `MatchingKeys` must have been defined in the `SchemaMapping` . Two records are considered to match according to this rule if all of the `MatchingKeys` match.
        :param pulumi.Input[_builtins.str] rule_name: A name for the matching rule.
        """
        pulumi.set(__self__, "matching_keys", matching_keys)
        pulumi.set(__self__, "rule_name", rule_name)

    @_builtins.property
    @pulumi.getter(name="matchingKeys")
    def matching_keys(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        A list of `MatchingKeys` . The `MatchingKeys` must have been defined in the `SchemaMapping` . Two records are considered to match according to this rule if all of the `MatchingKeys` match.
        """
        return pulumi.get(self, "matching_keys")

    @matching_keys.setter
    def matching_keys(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "matching_keys", value)

    @_builtins.property
    @pulumi.getter(name="ruleName")
    def rule_name(self) -> pulumi.Input[_builtins.str]:
        """
        A name for the matching rule.
        """
        return pulumi.get(self, "rule_name")

    @rule_name.setter
    def rule_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "rule_name", value)


if not MYPY:
    class SchemaMappingSchemaInputAttributeArgsDict(TypedDict):
        field_name: pulumi.Input[_builtins.str]
        type: pulumi.Input['SchemaMappingSchemaAttributeType']
        group_name: NotRequired[pulumi.Input[_builtins.str]]
        hashed: NotRequired[pulumi.Input[_builtins.bool]]
        match_key: NotRequired[pulumi.Input[_builtins.str]]
        sub_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The subtype of the Attribute. Would be required only when type is PROVIDER_ID
        """
elif False:
    SchemaMappingSchemaInputAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SchemaMappingSchemaInputAttributeArgs:
    def __init__(__self__, *,
                 field_name: pulumi.Input[_builtins.str],
                 type: pulumi.Input['SchemaMappingSchemaAttributeType'],
                 group_name: Optional[pulumi.Input[_builtins.str]] = None,
                 hashed: Optional[pulumi.Input[_builtins.bool]] = None,
                 match_key: Optional[pulumi.Input[_builtins.str]] = None,
                 sub_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] sub_type: The subtype of the Attribute. Would be required only when type is PROVIDER_ID
        """
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "type", type)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if hashed is not None:
            pulumi.set(__self__, "hashed", hashed)
        if match_key is not None:
            pulumi.set(__self__, "match_key", match_key)
        if sub_type is not None:
            pulumi.set(__self__, "sub_type", sub_type)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "field_name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input['SchemaMappingSchemaAttributeType']:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input['SchemaMappingSchemaAttributeType']):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "group_name", value)

    @_builtins.property
    @pulumi.getter
    def hashed(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "hashed")

    @hashed.setter
    def hashed(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "hashed", value)

    @_builtins.property
    @pulumi.getter(name="matchKey")
    def match_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "match_key")

    @match_key.setter
    def match_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_key", value)

    @_builtins.property
    @pulumi.getter(name="subType")
    def sub_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The subtype of the Attribute. Would be required only when type is PROVIDER_ID
        """
        return pulumi.get(self, "sub_type")

    @sub_type.setter
    def sub_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sub_type", value)


