# coding=utf-8
# *** WARNING: this file was generated by the Pulumi SDK Generator. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AnalysisTemplateAnalysisParameter',
    'AnalysisTemplateAnalysisSchema',
    'AnalysisTemplateAnalysisSource',
    'AnalysisTemplateTag',
    'CollaborationDataEncryptionMetadata',
    'CollaborationMemberSpecification',
    'CollaborationTag',
    'ConfiguredTableAggregateColumn',
    'ConfiguredTableAggregationConstraint',
    'ConfiguredTableAnalysisRule',
    'ConfiguredTableAnalysisRuleAggregation',
    'ConfiguredTableAnalysisRuleCustom',
    'ConfiguredTableAnalysisRuleList',
    'ConfiguredTableAnalysisRulePolicy',
    'ConfiguredTableAnalysisRulePolicyV10Properties',
    'ConfiguredTableAnalysisRulePolicyV11Properties',
    'ConfiguredTableAnalysisRulePolicyV12Properties',
    'ConfiguredTableAssociationTag',
    'ConfiguredTableGlueTableReference',
    'ConfiguredTableTableReference',
    'ConfiguredTableTag',
    'MembershipProtectedQueryOutputConfiguration',
    'MembershipProtectedQueryResultConfiguration',
    'MembershipProtectedQueryS3OutputConfiguration',
    'MembershipTag',
]

@pulumi.output_type
class AnalysisTemplateAnalysisParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultValue":
            suggest = "default_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTemplateAnalysisParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTemplateAnalysisParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTemplateAnalysisParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 type: 'AnalysisTemplateAnalysisParameterType',
                 default_value: Optional[str] = None):
        AnalysisTemplateAnalysisParameter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            type=type,
            default_value=default_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             type: Optional['AnalysisTemplateAnalysisParameterType'] = None,
             default_value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if name is None:
            raise TypeError("Missing 'name' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")
        if default_value is None and 'defaultValue' in kwargs:
            default_value = kwargs['defaultValue']

        _setter("name", name)
        _setter("type", type)
        if default_value is not None:
            _setter("default_value", default_value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> 'AnalysisTemplateAnalysisParameterType':
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[str]:
        return pulumi.get(self, "default_value")


@pulumi.output_type
class AnalysisTemplateAnalysisSchema(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "referencedTables":
            suggest = "referenced_tables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AnalysisTemplateAnalysisSchema. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AnalysisTemplateAnalysisSchema.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AnalysisTemplateAnalysisSchema.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 referenced_tables: Sequence[str]):
        AnalysisTemplateAnalysisSchema._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            referenced_tables=referenced_tables,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             referenced_tables: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if referenced_tables is None and 'referencedTables' in kwargs:
            referenced_tables = kwargs['referencedTables']
        if referenced_tables is None:
            raise TypeError("Missing 'referenced_tables' argument")

        _setter("referenced_tables", referenced_tables)

    @property
    @pulumi.getter(name="referencedTables")
    def referenced_tables(self) -> Sequence[str]:
        return pulumi.get(self, "referenced_tables")


@pulumi.output_type
class AnalysisTemplateAnalysisSource(dict):
    def __init__(__self__, *,
                 text: str):
        AnalysisTemplateAnalysisSource._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            text=text,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             text: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if text is None:
            raise TypeError("Missing 'text' argument")

        _setter("text", text)

    @property
    @pulumi.getter
    def text(self) -> str:
        return pulumi.get(self, "text")


@pulumi.output_type
class AnalysisTemplateTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        AnalysisTemplateTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class CollaborationDataEncryptionMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowCleartext":
            suggest = "allow_cleartext"
        elif key == "allowDuplicates":
            suggest = "allow_duplicates"
        elif key == "allowJoinsOnColumnsWithDifferentNames":
            suggest = "allow_joins_on_columns_with_different_names"
        elif key == "preserveNulls":
            suggest = "preserve_nulls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CollaborationDataEncryptionMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CollaborationDataEncryptionMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CollaborationDataEncryptionMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_cleartext: bool,
                 allow_duplicates: bool,
                 allow_joins_on_columns_with_different_names: bool,
                 preserve_nulls: bool):
        CollaborationDataEncryptionMetadata._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow_cleartext=allow_cleartext,
            allow_duplicates=allow_duplicates,
            allow_joins_on_columns_with_different_names=allow_joins_on_columns_with_different_names,
            preserve_nulls=preserve_nulls,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow_cleartext: Optional[bool] = None,
             allow_duplicates: Optional[bool] = None,
             allow_joins_on_columns_with_different_names: Optional[bool] = None,
             preserve_nulls: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if allow_cleartext is None and 'allowCleartext' in kwargs:
            allow_cleartext = kwargs['allowCleartext']
        if allow_cleartext is None:
            raise TypeError("Missing 'allow_cleartext' argument")
        if allow_duplicates is None and 'allowDuplicates' in kwargs:
            allow_duplicates = kwargs['allowDuplicates']
        if allow_duplicates is None:
            raise TypeError("Missing 'allow_duplicates' argument")
        if allow_joins_on_columns_with_different_names is None and 'allowJoinsOnColumnsWithDifferentNames' in kwargs:
            allow_joins_on_columns_with_different_names = kwargs['allowJoinsOnColumnsWithDifferentNames']
        if allow_joins_on_columns_with_different_names is None:
            raise TypeError("Missing 'allow_joins_on_columns_with_different_names' argument")
        if preserve_nulls is None and 'preserveNulls' in kwargs:
            preserve_nulls = kwargs['preserveNulls']
        if preserve_nulls is None:
            raise TypeError("Missing 'preserve_nulls' argument")

        _setter("allow_cleartext", allow_cleartext)
        _setter("allow_duplicates", allow_duplicates)
        _setter("allow_joins_on_columns_with_different_names", allow_joins_on_columns_with_different_names)
        _setter("preserve_nulls", preserve_nulls)

    @property
    @pulumi.getter(name="allowCleartext")
    def allow_cleartext(self) -> bool:
        return pulumi.get(self, "allow_cleartext")

    @property
    @pulumi.getter(name="allowDuplicates")
    def allow_duplicates(self) -> bool:
        return pulumi.get(self, "allow_duplicates")

    @property
    @pulumi.getter(name="allowJoinsOnColumnsWithDifferentNames")
    def allow_joins_on_columns_with_different_names(self) -> bool:
        return pulumi.get(self, "allow_joins_on_columns_with_different_names")

    @property
    @pulumi.getter(name="preserveNulls")
    def preserve_nulls(self) -> bool:
        return pulumi.get(self, "preserve_nulls")


@pulumi.output_type
class CollaborationMemberSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountId":
            suggest = "account_id"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "memberAbilities":
            suggest = "member_abilities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CollaborationMemberSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CollaborationMemberSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CollaborationMemberSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_id: str,
                 display_name: str,
                 member_abilities: Sequence['CollaborationMemberAbility']):
        CollaborationMemberSpecification._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            account_id=account_id,
            display_name=display_name,
            member_abilities=member_abilities,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             account_id: Optional[str] = None,
             display_name: Optional[str] = None,
             member_abilities: Optional[Sequence['CollaborationMemberAbility']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if account_id is None and 'accountId' in kwargs:
            account_id = kwargs['accountId']
        if account_id is None:
            raise TypeError("Missing 'account_id' argument")
        if display_name is None and 'displayName' in kwargs:
            display_name = kwargs['displayName']
        if display_name is None:
            raise TypeError("Missing 'display_name' argument")
        if member_abilities is None and 'memberAbilities' in kwargs:
            member_abilities = kwargs['memberAbilities']
        if member_abilities is None:
            raise TypeError("Missing 'member_abilities' argument")

        _setter("account_id", account_id)
        _setter("display_name", display_name)
        _setter("member_abilities", member_abilities)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> str:
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="memberAbilities")
    def member_abilities(self) -> Sequence['CollaborationMemberAbility']:
        return pulumi.get(self, "member_abilities")


@pulumi.output_type
class CollaborationTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        CollaborationTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class ConfiguredTableAggregateColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnNames":
            suggest = "column_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfiguredTableAggregateColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfiguredTableAggregateColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfiguredTableAggregateColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_names: Sequence[str],
                 function: 'ConfiguredTableAggregateFunctionName'):
        ConfiguredTableAggregateColumn._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_names=column_names,
            function=function,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_names: Optional[Sequence[str]] = None,
             function: Optional['ConfiguredTableAggregateFunctionName'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if column_names is None and 'columnNames' in kwargs:
            column_names = kwargs['columnNames']
        if column_names is None:
            raise TypeError("Missing 'column_names' argument")
        if function is None:
            raise TypeError("Missing 'function' argument")

        _setter("column_names", column_names)
        _setter("function", function)

    @property
    @pulumi.getter(name="columnNames")
    def column_names(self) -> Sequence[str]:
        return pulumi.get(self, "column_names")

    @property
    @pulumi.getter
    def function(self) -> 'ConfiguredTableAggregateFunctionName':
        return pulumi.get(self, "function")


@pulumi.output_type
class ConfiguredTableAggregationConstraint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnName":
            suggest = "column_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfiguredTableAggregationConstraint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfiguredTableAggregationConstraint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfiguredTableAggregationConstraint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_name: str,
                 minimum: float,
                 type: 'ConfiguredTableAggregationType'):
        ConfiguredTableAggregationConstraint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column_name=column_name,
            minimum=minimum,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column_name: Optional[str] = None,
             minimum: Optional[float] = None,
             type: Optional['ConfiguredTableAggregationType'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if column_name is None and 'columnName' in kwargs:
            column_name = kwargs['columnName']
        if column_name is None:
            raise TypeError("Missing 'column_name' argument")
        if minimum is None:
            raise TypeError("Missing 'minimum' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("column_name", column_name)
        _setter("minimum", minimum)
        _setter("type", type)

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> str:
        return pulumi.get(self, "column_name")

    @property
    @pulumi.getter
    def minimum(self) -> float:
        return pulumi.get(self, "minimum")

    @property
    @pulumi.getter
    def type(self) -> 'ConfiguredTableAggregationType':
        return pulumi.get(self, "type")


@pulumi.output_type
class ConfiguredTableAnalysisRule(dict):
    def __init__(__self__, *,
                 policy: 'outputs.ConfiguredTableAnalysisRulePolicy',
                 type: 'ConfiguredTableAnalysisRuleType'):
        ConfiguredTableAnalysisRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            policy=policy,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             policy: Optional['outputs.ConfiguredTableAnalysisRulePolicy'] = None,
             type: Optional['ConfiguredTableAnalysisRuleType'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if policy is None:
            raise TypeError("Missing 'policy' argument")
        if type is None:
            raise TypeError("Missing 'type' argument")

        _setter("policy", policy)
        _setter("type", type)

    @property
    @pulumi.getter
    def policy(self) -> 'outputs.ConfiguredTableAnalysisRulePolicy':
        return pulumi.get(self, "policy")

    @property
    @pulumi.getter
    def type(self) -> 'ConfiguredTableAnalysisRuleType':
        return pulumi.get(self, "type")


@pulumi.output_type
class ConfiguredTableAnalysisRuleAggregation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregateColumns":
            suggest = "aggregate_columns"
        elif key == "dimensionColumns":
            suggest = "dimension_columns"
        elif key == "joinColumns":
            suggest = "join_columns"
        elif key == "outputConstraints":
            suggest = "output_constraints"
        elif key == "scalarFunctions":
            suggest = "scalar_functions"
        elif key == "allowedJoinOperators":
            suggest = "allowed_join_operators"
        elif key == "joinRequired":
            suggest = "join_required"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfiguredTableAnalysisRuleAggregation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfiguredTableAnalysisRuleAggregation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfiguredTableAnalysisRuleAggregation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregate_columns: Sequence['outputs.ConfiguredTableAggregateColumn'],
                 dimension_columns: Sequence[str],
                 join_columns: Sequence[str],
                 output_constraints: Sequence['outputs.ConfiguredTableAggregationConstraint'],
                 scalar_functions: Sequence['ConfiguredTableScalarFunctions'],
                 allowed_join_operators: Optional[Sequence['ConfiguredTableJoinOperator']] = None,
                 join_required: Optional['ConfiguredTableJoinRequiredOption'] = None):
        ConfiguredTableAnalysisRuleAggregation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregate_columns=aggregate_columns,
            dimension_columns=dimension_columns,
            join_columns=join_columns,
            output_constraints=output_constraints,
            scalar_functions=scalar_functions,
            allowed_join_operators=allowed_join_operators,
            join_required=join_required,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregate_columns: Optional[Sequence['outputs.ConfiguredTableAggregateColumn']] = None,
             dimension_columns: Optional[Sequence[str]] = None,
             join_columns: Optional[Sequence[str]] = None,
             output_constraints: Optional[Sequence['outputs.ConfiguredTableAggregationConstraint']] = None,
             scalar_functions: Optional[Sequence['ConfiguredTableScalarFunctions']] = None,
             allowed_join_operators: Optional[Sequence['ConfiguredTableJoinOperator']] = None,
             join_required: Optional['ConfiguredTableJoinRequiredOption'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if aggregate_columns is None and 'aggregateColumns' in kwargs:
            aggregate_columns = kwargs['aggregateColumns']
        if aggregate_columns is None:
            raise TypeError("Missing 'aggregate_columns' argument")
        if dimension_columns is None and 'dimensionColumns' in kwargs:
            dimension_columns = kwargs['dimensionColumns']
        if dimension_columns is None:
            raise TypeError("Missing 'dimension_columns' argument")
        if join_columns is None and 'joinColumns' in kwargs:
            join_columns = kwargs['joinColumns']
        if join_columns is None:
            raise TypeError("Missing 'join_columns' argument")
        if output_constraints is None and 'outputConstraints' in kwargs:
            output_constraints = kwargs['outputConstraints']
        if output_constraints is None:
            raise TypeError("Missing 'output_constraints' argument")
        if scalar_functions is None and 'scalarFunctions' in kwargs:
            scalar_functions = kwargs['scalarFunctions']
        if scalar_functions is None:
            raise TypeError("Missing 'scalar_functions' argument")
        if allowed_join_operators is None and 'allowedJoinOperators' in kwargs:
            allowed_join_operators = kwargs['allowedJoinOperators']
        if join_required is None and 'joinRequired' in kwargs:
            join_required = kwargs['joinRequired']

        _setter("aggregate_columns", aggregate_columns)
        _setter("dimension_columns", dimension_columns)
        _setter("join_columns", join_columns)
        _setter("output_constraints", output_constraints)
        _setter("scalar_functions", scalar_functions)
        if allowed_join_operators is not None:
            _setter("allowed_join_operators", allowed_join_operators)
        if join_required is not None:
            _setter("join_required", join_required)

    @property
    @pulumi.getter(name="aggregateColumns")
    def aggregate_columns(self) -> Sequence['outputs.ConfiguredTableAggregateColumn']:
        return pulumi.get(self, "aggregate_columns")

    @property
    @pulumi.getter(name="dimensionColumns")
    def dimension_columns(self) -> Sequence[str]:
        return pulumi.get(self, "dimension_columns")

    @property
    @pulumi.getter(name="joinColumns")
    def join_columns(self) -> Sequence[str]:
        return pulumi.get(self, "join_columns")

    @property
    @pulumi.getter(name="outputConstraints")
    def output_constraints(self) -> Sequence['outputs.ConfiguredTableAggregationConstraint']:
        return pulumi.get(self, "output_constraints")

    @property
    @pulumi.getter(name="scalarFunctions")
    def scalar_functions(self) -> Sequence['ConfiguredTableScalarFunctions']:
        return pulumi.get(self, "scalar_functions")

    @property
    @pulumi.getter(name="allowedJoinOperators")
    def allowed_join_operators(self) -> Optional[Sequence['ConfiguredTableJoinOperator']]:
        return pulumi.get(self, "allowed_join_operators")

    @property
    @pulumi.getter(name="joinRequired")
    def join_required(self) -> Optional['ConfiguredTableJoinRequiredOption']:
        return pulumi.get(self, "join_required")


@pulumi.output_type
class ConfiguredTableAnalysisRuleCustom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedAnalyses":
            suggest = "allowed_analyses"
        elif key == "allowedAnalysisProviders":
            suggest = "allowed_analysis_providers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfiguredTableAnalysisRuleCustom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfiguredTableAnalysisRuleCustom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfiguredTableAnalysisRuleCustom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_analyses: Sequence[str],
                 allowed_analysis_providers: Optional[Sequence[str]] = None):
        ConfiguredTableAnalysisRuleCustom._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allowed_analyses=allowed_analyses,
            allowed_analysis_providers=allowed_analysis_providers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allowed_analyses: Optional[Sequence[str]] = None,
             allowed_analysis_providers: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if allowed_analyses is None and 'allowedAnalyses' in kwargs:
            allowed_analyses = kwargs['allowedAnalyses']
        if allowed_analyses is None:
            raise TypeError("Missing 'allowed_analyses' argument")
        if allowed_analysis_providers is None and 'allowedAnalysisProviders' in kwargs:
            allowed_analysis_providers = kwargs['allowedAnalysisProviders']

        _setter("allowed_analyses", allowed_analyses)
        if allowed_analysis_providers is not None:
            _setter("allowed_analysis_providers", allowed_analysis_providers)

    @property
    @pulumi.getter(name="allowedAnalyses")
    def allowed_analyses(self) -> Sequence[str]:
        return pulumi.get(self, "allowed_analyses")

    @property
    @pulumi.getter(name="allowedAnalysisProviders")
    def allowed_analysis_providers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allowed_analysis_providers")


@pulumi.output_type
class ConfiguredTableAnalysisRuleList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "joinColumns":
            suggest = "join_columns"
        elif key == "listColumns":
            suggest = "list_columns"
        elif key == "allowedJoinOperators":
            suggest = "allowed_join_operators"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfiguredTableAnalysisRuleList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfiguredTableAnalysisRuleList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfiguredTableAnalysisRuleList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 join_columns: Sequence[str],
                 list_columns: Sequence[str],
                 allowed_join_operators: Optional[Sequence['ConfiguredTableJoinOperator']] = None):
        ConfiguredTableAnalysisRuleList._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            join_columns=join_columns,
            list_columns=list_columns,
            allowed_join_operators=allowed_join_operators,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             join_columns: Optional[Sequence[str]] = None,
             list_columns: Optional[Sequence[str]] = None,
             allowed_join_operators: Optional[Sequence['ConfiguredTableJoinOperator']] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if join_columns is None and 'joinColumns' in kwargs:
            join_columns = kwargs['joinColumns']
        if join_columns is None:
            raise TypeError("Missing 'join_columns' argument")
        if list_columns is None and 'listColumns' in kwargs:
            list_columns = kwargs['listColumns']
        if list_columns is None:
            raise TypeError("Missing 'list_columns' argument")
        if allowed_join_operators is None and 'allowedJoinOperators' in kwargs:
            allowed_join_operators = kwargs['allowedJoinOperators']

        _setter("join_columns", join_columns)
        _setter("list_columns", list_columns)
        if allowed_join_operators is not None:
            _setter("allowed_join_operators", allowed_join_operators)

    @property
    @pulumi.getter(name="joinColumns")
    def join_columns(self) -> Sequence[str]:
        return pulumi.get(self, "join_columns")

    @property
    @pulumi.getter(name="listColumns")
    def list_columns(self) -> Sequence[str]:
        return pulumi.get(self, "list_columns")

    @property
    @pulumi.getter(name="allowedJoinOperators")
    def allowed_join_operators(self) -> Optional[Sequence['ConfiguredTableJoinOperator']]:
        return pulumi.get(self, "allowed_join_operators")


@pulumi.output_type
class ConfiguredTableAnalysisRulePolicy(dict):
    def __init__(__self__, *,
                 v1: Any):
        ConfiguredTableAnalysisRulePolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            v1=v1,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             v1: Optional[Any] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if v1 is None:
            raise TypeError("Missing 'v1' argument")

        _setter("v1", v1)

    @property
    @pulumi.getter
    def v1(self) -> Any:
        return pulumi.get(self, "v1")


@pulumi.output_type
class ConfiguredTableAnalysisRulePolicyV10Properties(dict):
    def __init__(__self__, *,
                 list: 'outputs.ConfiguredTableAnalysisRuleList'):
        ConfiguredTableAnalysisRulePolicyV10Properties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            list=list,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             list: Optional['outputs.ConfiguredTableAnalysisRuleList'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if list is None:
            raise TypeError("Missing 'list' argument")

        _setter("list", list)

    @property
    @pulumi.getter
    def list(self) -> 'outputs.ConfiguredTableAnalysisRuleList':
        return pulumi.get(self, "list")


@pulumi.output_type
class ConfiguredTableAnalysisRulePolicyV11Properties(dict):
    def __init__(__self__, *,
                 aggregation: 'outputs.ConfiguredTableAnalysisRuleAggregation'):
        ConfiguredTableAnalysisRulePolicyV11Properties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: Optional['outputs.ConfiguredTableAnalysisRuleAggregation'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if aggregation is None:
            raise TypeError("Missing 'aggregation' argument")

        _setter("aggregation", aggregation)

    @property
    @pulumi.getter
    def aggregation(self) -> 'outputs.ConfiguredTableAnalysisRuleAggregation':
        return pulumi.get(self, "aggregation")


@pulumi.output_type
class ConfiguredTableAnalysisRulePolicyV12Properties(dict):
    def __init__(__self__, *,
                 custom: 'outputs.ConfiguredTableAnalysisRuleCustom'):
        ConfiguredTableAnalysisRulePolicyV12Properties._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom=custom,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom: Optional['outputs.ConfiguredTableAnalysisRuleCustom'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if custom is None:
            raise TypeError("Missing 'custom' argument")

        _setter("custom", custom)

    @property
    @pulumi.getter
    def custom(self) -> 'outputs.ConfiguredTableAnalysisRuleCustom':
        return pulumi.get(self, "custom")


@pulumi.output_type
class ConfiguredTableAssociationTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        ConfiguredTableAssociationTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class ConfiguredTableGlueTableReference(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "tableName":
            suggest = "table_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfiguredTableGlueTableReference. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfiguredTableGlueTableReference.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfiguredTableGlueTableReference.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: str,
                 table_name: str):
        ConfiguredTableGlueTableReference._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            database_name=database_name,
            table_name=table_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             database_name: Optional[str] = None,
             table_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if database_name is None and 'databaseName' in kwargs:
            database_name = kwargs['databaseName']
        if database_name is None:
            raise TypeError("Missing 'database_name' argument")
        if table_name is None and 'tableName' in kwargs:
            table_name = kwargs['tableName']
        if table_name is None:
            raise TypeError("Missing 'table_name' argument")

        _setter("database_name", database_name)
        _setter("table_name", table_name)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> str:
        return pulumi.get(self, "table_name")


@pulumi.output_type
class ConfiguredTableTableReference(dict):
    def __init__(__self__, *,
                 glue: 'outputs.ConfiguredTableGlueTableReference'):
        ConfiguredTableTableReference._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            glue=glue,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             glue: Optional['outputs.ConfiguredTableGlueTableReference'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if glue is None:
            raise TypeError("Missing 'glue' argument")

        _setter("glue", glue)

    @property
    @pulumi.getter
    def glue(self) -> 'outputs.ConfiguredTableGlueTableReference':
        return pulumi.get(self, "glue")


@pulumi.output_type
class ConfiguredTableTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        ConfiguredTableTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class MembershipProtectedQueryOutputConfiguration(dict):
    def __init__(__self__, *,
                 s3: 'outputs.MembershipProtectedQueryS3OutputConfiguration'):
        MembershipProtectedQueryOutputConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            s3=s3,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             s3: Optional['outputs.MembershipProtectedQueryS3OutputConfiguration'] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if s3 is None:
            raise TypeError("Missing 's3' argument")

        _setter("s3", s3)

    @property
    @pulumi.getter
    def s3(self) -> 'outputs.MembershipProtectedQueryS3OutputConfiguration':
        return pulumi.get(self, "s3")


@pulumi.output_type
class MembershipProtectedQueryResultConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "outputConfiguration":
            suggest = "output_configuration"
        elif key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MembershipProtectedQueryResultConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MembershipProtectedQueryResultConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MembershipProtectedQueryResultConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 output_configuration: 'outputs.MembershipProtectedQueryOutputConfiguration',
                 role_arn: Optional[str] = None):
        MembershipProtectedQueryResultConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            output_configuration=output_configuration,
            role_arn=role_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             output_configuration: Optional['outputs.MembershipProtectedQueryOutputConfiguration'] = None,
             role_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if output_configuration is None and 'outputConfiguration' in kwargs:
            output_configuration = kwargs['outputConfiguration']
        if output_configuration is None:
            raise TypeError("Missing 'output_configuration' argument")
        if role_arn is None and 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']

        _setter("output_configuration", output_configuration)
        if role_arn is not None:
            _setter("role_arn", role_arn)

    @property
    @pulumi.getter(name="outputConfiguration")
    def output_configuration(self) -> 'outputs.MembershipProtectedQueryOutputConfiguration':
        return pulumi.get(self, "output_configuration")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class MembershipProtectedQueryS3OutputConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resultFormat":
            suggest = "result_format"
        elif key == "keyPrefix":
            suggest = "key_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MembershipProtectedQueryS3OutputConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MembershipProtectedQueryS3OutputConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MembershipProtectedQueryS3OutputConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket: str,
                 result_format: 'MembershipResultFormat',
                 key_prefix: Optional[str] = None):
        MembershipProtectedQueryS3OutputConfiguration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket=bucket,
            result_format=result_format,
            key_prefix=key_prefix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket: Optional[str] = None,
             result_format: Optional['MembershipResultFormat'] = None,
             key_prefix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if bucket is None:
            raise TypeError("Missing 'bucket' argument")
        if result_format is None and 'resultFormat' in kwargs:
            result_format = kwargs['resultFormat']
        if result_format is None:
            raise TypeError("Missing 'result_format' argument")
        if key_prefix is None and 'keyPrefix' in kwargs:
            key_prefix = kwargs['keyPrefix']

        _setter("bucket", bucket)
        _setter("result_format", result_format)
        if key_prefix is not None:
            _setter("key_prefix", key_prefix)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter(name="resultFormat")
    def result_format(self) -> 'MembershipResultFormat':
        return pulumi.get(self, "result_format")

    @property
    @pulumi.getter(name="keyPrefix")
    def key_prefix(self) -> Optional[str]:
        return pulumi.get(self, "key_prefix")


@pulumi.output_type
class MembershipTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        MembershipTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions] = None,
             **kwargs):
        if key is None:
            raise TypeError("Missing 'key' argument")
        if value is None:
            raise TypeError("Missing 'value' argument")

        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


